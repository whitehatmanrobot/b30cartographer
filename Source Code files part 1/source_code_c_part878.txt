    = GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64);
}

//+---------------------------------------------------------------------------
//
// FindSYSTHREAD
//
//+---------------------------------------------------------------------------

SYSTHREAD *FindSYSTHREAD()
{
    SYSTHREAD *psfn;

    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    psfn = (SYSTHREAD *)TlsGetValue(g_dwTLSIndex);

    return psfn;
}

//+---------------------------------------------------------------------------
//
// GetSYSTHREAD
//
//+---------------------------------------------------------------------------

SYSTHREAD *GetSYSTHREAD()
{
    SYSTHREAD *psfn;

    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    psfn = (SYSTHREAD *)TlsGetValue(g_dwTLSIndex);

    if (!psfn)
    {
        //
        // we don't allocate psfn after detached.
        //
        if (g_fDllProcessDetached)
            return NULL;

        psfn = (SYSTHREAD *)cicMemAllocClear(sizeof(SYSTHREAD));
        if (!TlsSetValue(g_dwTLSIndex, psfn))
        {
            cicMemFree(psfn);
            psfn = NULL;
        }

        if (psfn)
        {
            psfn->dwThreadId = GetCurrentThreadId();
            psfn->dwProcessId = GetCurrentProcessId();

            CicEnterCriticalSection(g_csInDllMain);

            if (!g_rgSysThread)
                g_rgSysThread = new CPtrArray<SYSTHREAD>;
            
            if (g_rgSysThread)
            {
                if (g_rgSysThread->Insert(0, 1))
                    g_rgSysThread->Set(0, psfn);
            }

            CicLeaveCriticalSection(g_csInDllMain);

            //
            // init nModalLangBarId
            //
            psfn->nModalLangBarId = -1;
            EnsureTIMList(psfn);
        }
    }

    return psfn;
}


//+---------------------------------------------------------------------------
//
// FreeSYSTHREAD2
//
//+---------------------------------------------------------------------------

void FreeSYSTHREAD2(SYSTHREAD *psfn)
{
    Assert(psfn); // it's caller's responsibility to pass in a valid psfn
    Assert(psfn->ptim == NULL); // someone leaked us?
    Assert(psfn->pipp == NULL); // someone leaked us?
    Assert(psfn->pdam == NULL); // someone leaked us?

    UninitThreadHooks(psfn);

    UninitLangBarAddIns(psfn);
    delete psfn->_pGlobalCompMgr;
    psfn->_pGlobalCompMgr = NULL;

    if (psfn->plbim)
    {
        psfn->plbim->_RemoveSystemItems(psfn);
    }

    FreeMarshaledStubs(psfn);

    if (psfn->plbim)
    {
        TraceMsg(TF_GENERAL, "FreeSYSTHREAD2 clean up plbim");
        //
        // Clean up a pointer that is marshalled to UTB.
        //
        delete psfn->plbim;
        psfn->plbim = NULL;
    }

    if (psfn->ptim)
        psfn->ptim->ClearLangBarItemMgr();

    CicEnterCriticalSection(g_csInDllMain);

    if (g_rgSysThread)
    {
        int nCnt = g_rgSysThread->Count();
        while (nCnt)
        {
            nCnt--;
            if (g_rgSysThread->Get(nCnt) == psfn)
            {
                g_rgSysThread->Remove(nCnt, 1);
                break;
            }
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);

    if (psfn->pAsmList)
    {
        delete psfn->pAsmList;
        psfn->pAsmList = NULL;
    }

    //
    // remove the timlist entry for the current thread.
    //
    psfn->pti = NULL;
    g_timlist.RemoveThread(psfn->dwThreadId);

    DestroySharedHeap(psfn);
    DestroySharedBlocks(psfn);

    cicMemFree(psfn);
}

void FreeSYSTHREAD()
{
    SYSTHREAD *psfn = (SYSTHREAD *)TlsGetValue(g_dwTLSIndex);
    if (psfn)
    {
        //
        // don't call ClearLangBarAddIns in FreeSYSTHREAD2.
        // it is not safe to call this in DllMain(PROCESS_DETACH).
        //
        ClearLangBarAddIns(psfn, CLSID_NULL);

        FreeSYSTHREAD2(psfn);
        TlsSetValue(g_dwTLSIndex, NULL);
    }
}

//+---------------------------------------------------------------------------
//
// EnsureAssemblyList
//
//+---------------------------------------------------------------------------

CAssemblyList *EnsureAssemblyList(SYSTHREAD *psfn, BOOL fUpdate)
{
    if (!fUpdate && psfn->pAsmList)
        return psfn->pAsmList;

    if (!psfn->pAsmList)
        psfn->pAsmList = new CAssemblyList;

    if (psfn->pAsmList)
    {
        psfn->pAsmList->Load();

        UpdateSystemLangBarItems(psfn, NULL, TRUE);

        if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
            psfn->plbim->_GetLBarItemCtrl()->_AsmListUpdated(TRUE);

    }

    return psfn->pAsmList;
}

//+---------------------------------------------------------------------------
//
// UpdateRegIMXHandler()
//
//+---------------------------------------------------------------------------

void UpdateRegIMXHandler()
{
    SYSTHREAD *psfn = GetSYSTHREAD();

    //
    //  clear Category cache
    //
    CCategoryMgr::FreeCatCache();

    TF_InitMlngInfo();

    //
    //  Update Assembly list
    //
    if (psfn && psfn->pAsmList)
    {
        EnsureAssemblyList(psfn, TRUE);

        if (!psfn->pAsmList->FindAssemblyByLangId(GetCurrentAssemblyLangId(psfn)))
        {
            CAssembly *pAsm = psfn->pAsmList->GetAssembly(0);
            if (pAsm)
                ActivateAssembly(pAsm->GetLangId(), ACTASM_NONE);
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetCurrentAssemblyLangid
//
//+---------------------------------------------------------------------------

LANGID GetCurrentAssemblyLangId(SYSTHREAD *psfn)
{
    if (!psfn)
    {
        psfn = GetSYSTHREAD();
        if (!psfn)
            return 0;
    }

    if (!psfn->langidCurrent)
    {
        HKL hKL = GetKeyboardLayout(NULL);
        psfn->langidPrev = psfn->langidCurrent;
        psfn->langidCurrent = LANGIDFROMHKL(hKL);
    }

    return psfn->langidCurrent;
}

//+---------------------------------------------------------------------------
//
// SetCurrentAssemblyLangid
//
//+---------------------------------------------------------------------------

void SetCurrentAssemblyLangId(SYSTHREAD *psfn, LANGID langid)
{
    psfn->langidPrev = psfn->langidCurrent;
    psfn->langidCurrent = langid;
}

//+---------------------------------------------------------------------------
//
// CheckVisibleWindowEnumProc
//
// find any other visible window in the thread.
//
//+---------------------------------------------------------------------------

typedef struct tag_CHECKVISIBLEWND {
    BOOL fVisibleFound;
    HWND hwndBeingDestroyed;
    HWND hwndMarshal;
} CHECKVISIBLEWND;

BOOL CheckVisibleWindowEnumProc(HWND hwnd, LPARAM lParam)
{
    CHECKVISIBLEWND *pcmw = (CHECKVISIBLEWND *)lParam;
    LONG_PTR style;

    //
    // skip itself.
    //
    if (pcmw->hwndMarshal == hwnd)
        return TRUE;

    //
    // skip one being destroyed.
    //
    if (pcmw->hwndBeingDestroyed == hwnd)
        return TRUE;

    //
    // skip IME windows.
    //
    style = GetClassLongPtr(hwnd, GCL_STYLE);
    if (style & CS_IME)
        return TRUE;

    //
    // skip disable windows if it is not NT4.
    //
    // we disabled code on NT4 because mashaling window is not in HWND_MSG.
    //
    if (IsOnNT5())
    {
        style = GetWindowLongPtr(hwnd, GWL_STYLE);
        if (style & WS_DISABLED)
            return TRUE;
    }

    //
    // skip in visible windows.
    //
    if (!IsWindowVisible(hwnd))
        return TRUE;

    //
    // skip in destroy windows.
    //

    // #624872
    // This is private user32 function.
    // Due to dead lock of LdrpLoaderLock, we don't use delay load.
    if (IsWindowInDestroy(hwnd))
        return TRUE;

    //
    // ok, we found visible window and stop enumerating.
    //
    pcmw->fVisibleFound = TRUE;

    return FALSE;
}

#ifdef CUAS_ENABLE
//+---------------------------------------------------------------------------
//
// CheckNoWindowEnumProc
//
// find any other window in the thread.
//
//+---------------------------------------------------------------------------

typedef struct tag_CHECKNOWND {
    BOOL fWindowFound;
    HWND hwndBeingDestroyed;
} CHECKNOWND;

BOOL CheckNoWindowEnumProc(HWND hwnd, LPARAM lParam)
{
    CHECKNOWND *pcmw = (CHECKNOWND *)lParam;

    //
    // skip one being destroyed.
    //
    if (pcmw->hwndBeingDestroyed == hwnd)
        return TRUE;

    //
    // ok, we found window and stop enumerating.
    //
    pcmw->fWindowFound = TRUE;

    return FALSE;
}
#endif // CUAS_ENABLE


//+---------------------------------------------------------------------------
//
// IsConsoleWindow
//
//+---------------------------------------------------------------------------

#define CONSOLE_WINDOW_CLASS     TEXT("ConsoleWindowClass")

BOOL IsConsoleWindow(HWND hWnd)
{
    if (IsOnNT())
    {
        int n;
        char szClass[33];

        n = GetClassName(hWnd, szClass, sizeof(szClass)-1);

        szClass[n] = TEXT('\0');

        if (lstrcmp(szClass, CONSOLE_WINDOW_CLASS) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// Input_EnumChildWndProc
//
// disable all controls that is in legacy keyboard property page.
//+---------------------------------------------------------------------------

BOOL CALLBACK Input_EnumChildWndProc(HWND hwnd, LPARAM lParam)
{

    EnableWindow(hwnd, FALSE);
    ShowWindow(hwnd, SW_HIDE);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IntlCPLFetchWndProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK IntlCPLFetchWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case (WM_CREATE) :
        {
            HWND hwndStatic;
            HWND hwndButton;
            HWND hwndGroup;
            RECT rc;
            HFONT hFont;

            GetWindowRect(hwnd, &rc);

            hwndGroup = CreateWindow(TEXT("button"), g_szCPLGroupBox,
                                      WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
                                      0, 0, 0, 0,
                                      hwnd, NULL, g_hInst, NULL
                                      );
            MoveWindow(hwndGroup, 0, 0, rc.right-rc.left-20, 110, TRUE);

            hwndStatic = CreateWindow(TEXT("static"), g_szOldCPLMsg,
                                      WS_CHILD | WS_VISIBLE | SS_LEFT,
                                      0, 0, 0, 0,
                                      hwnd, NULL, g_hInst, NULL
                                      );
            MoveWindow(hwndStatic, 50, 20, rc.right-rc.left-80, 50, TRUE);

            hwndButton = CreateWindow(TEXT("button"), g_szCPLButton,
                                      WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON,
                                      0, 0, 0, 0,
                                      hwnd, NULL, g_hInst, NULL
                                      );
            MoveWindow(hwndButton, 50, 75, 100, 25, TRUE);

            hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);

            SendMessage(hwndGroup, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(hwndStatic, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(hwndButton, WM_SETFONT, (WPARAM)hFont, TRUE);

            return FALSE;
        }

        case (WM_COMMAND) :
        {
            switch (LOWORD(wParam))
            {
                case ( BN_CLICKED ):
                    TF_RunInputCPL();

                    return FALSE;

                default:
                    break;
            }
        }

        case (WM_PAINT) :
        {
            HDC hdc;
            HICON hIcon;
            PAINTSTRUCT ps;

            hdc = BeginPaint(hwnd, &ps);

            if (hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TEXT_SERVICE)))
            {
                DrawIconEx(hdc, 10, 20, hIcon, 32, 32, 0, NULL, DI_NORMAL);
                ReleaseDC(hwnd, hdc);
            }
            EndPaint(hwnd, &ps);

            return FALSE;
        }
    }

    return DefWindowProc(hwnd, message, wParam, lParam);

}

//+---------------------------------------------------------------------------
//
// CreateCPLFetchWindow
//
// Creating the fetch window to bring up the new Text Service cpl.
//+---------------------------------------------------------------------------

void CreateCPLFetchWindow(HWND hwnd)
{
    RECT rc;
    HWND hwndCPLFetch;
    WNDCLASSEX wndclass;

    if (!(hwndCPLFetch = FindWindowEx(hwnd, NULL, c_szIntlCPLFetchClass, NULL)))
    {
        EnumChildWindows(hwnd, (WNDENUMPROC)Input_EnumChildWndProc, 0);

        GetWindowRect(hwnd, &rc);

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.hInstance     = g_hInst;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpfnWndProc   = IntlCPLFetchWndProc;
        wndclass.lpszClassName = c_szIntlCPLFetchClass;
        RegisterClassEx(&wndclass);


        hwndCPLFetch = CreateWindowEx(0, c_szIntlCPLFetchClass, "",
                                WS_VISIBLE | WS_CHILD | WS_TABSTOP,
                                rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
                                hwnd, NULL, g_hInst, NULL
                                );

        MoveWindow(hwndCPLFetch, 10, 10, rc.right-rc.left-10, rc.bottom-rc.top-10, TRUE);
        ShowWindow(hwndCPLFetch, SW_SHOW);
    }
}

//+---------------------------------------------------------------------------
//
// Intl_EnumChildWndProc
//
// filtering the legacy keyboard property page.
//+---------------------------------------------------------------------------

BOOL CALLBACK Intl_EnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    TCHAR szWndName[MAX_PATH];
    TCHAR szKbdPage[MAX_PATH];

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hwnd, NULL))
        return TRUE;

    SafeGetWindowText(hwnd, szWndName, MAX_PATH);

    if (*szWndName == TEXT('\0'))
        return TRUE;

    if (IsOnNT())
        StringCopyArray(szKbdPage, g_szNTCPLTitle);
    else
    {
        LONG_PTR lpWndHandle;

        if (lstrcmp(szWndName, g_szKbdCPLTitle) == 0)
            return FALSE;

        //
        // Thunk call isn't good way to load 16bit module from here.
        // So look up the window instance handle to determine keyboard
        // "Language" tab window.
        // This is Win9x specification and we can detect 32bit handle instance
        // from HIWORD value form GWLP_HINSTANCE.
        //
        lpWndHandle = GetWindowLongPtr(hwnd, GWLP_HINSTANCE);

        if (HIWORD((DWORD) (LONG_PTR) lpWndHandle) != 0)
            return FALSE;

        StringCopyArray(szKbdPage, g_szKbdCPLTitle);
    }

    if ((lstrcmp(szWndName, szKbdPage) == 0) ||
        (!IsOnNT() && lstrcmp(szWndName, szKbdPage) != 0))
    {
        CreateCPLFetchWindow(hwnd);
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Intl_CH9xIMEEnumChildWndProc
//
// filtering the chinese Win9x special IME layout setting cpl.
//+---------------------------------------------------------------------------

BOOL CALLBACK Intl_CH9xIMEEnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    TCHAR szWndName[MAX_PATH];
    TCHAR szKbdPage[MAX_PATH];
    LONG_PTR lpWndHandle;

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hwnd, NULL))
        return TRUE;

    SafeGetWindowText(hwnd, szWndName, MAX_PATH);

    if (*szWndName == TEXT('\0'))
        return TRUE;

    if (lstrcmp(szWndName, g_szKbdCPLTitle) == 0)
        return FALSE;

    //
    // Thunk call isn't good way to load 16bit module from here.
    // So look up the window instance handle to determine keyboard
    // "Language" tab window.
    // This is Win9x specification and we can detect 32bit handle instance
    // from HIWORD value form GWLP_HINSTANCE.
    //
    lpWndHandle = GetWindowLongPtr(hwnd, GWLP_HINSTANCE);

    //if (HIWORD((DWORD) (LONG_PTR) lpWndHandle) != 0 &&
    //    (lstrcmp(szWndName, g_szCH9xKbdCPLTitle) != 0))
    // Need to show up Chinese IME hotkey setting pages
    if (HIWORD((DWORD) (LONG_PTR) lpWndHandle) != 0)
        return FALSE;

    StringCopyArray(szKbdPage, g_szKbdCPLTitle);

    if (!IsOnNT() && lstrcmp(szWndName, szKbdPage) != 0)
    {
        CreateCPLFetchWindow(hwnd);
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Intl_CHEnumChildWndProc
//
// filtering the chinese NT4 special IME layout setting cpl.
//+---------------------------------------------------------------------------

BOOL CALLBACK Intl_CHEnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    TCHAR szWndName[MAX_PATH];

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hwnd, NULL))
        return TRUE;

    SafeGetWindowText(hwnd, szWndName, MAX_PATH);

    if (*szWndName == TEXT('\0'))
        return TRUE;

    //if ((lstrcmp(szWndName, g_szCHNT4CPLTitle1) == 0) ||
    //    (lstrcmp(szWndName, g_szCHNT4CPLTitle2) == 0))
    // Need to show up Chinese IME hotkey setting pages
    if ((lstrcmp(szWndName, g_szCHNT4CPLTitle1) == 0))
    {
        CreateCPLFetchWindow(hwnd);
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetDialogCaptionTitle
//
//+---------------------------------------------------------------------------

BOOL GetDialogCaptionTitle(HINSTANCE hInst, LPCTSTR lpName, LPTSTR lpTitle, int cchTitleMax)
{
    BOOL bRet = FALSE;
    HRSRC hrsrc = NULL;

    hrsrc = FindResourceA(hInst, lpName, RT_DIALOG);

    if (hrsrc)
    {
        PVOID pTemp;
        DWORD dwCodePage;
        LANGID langRes = 0;
        UINT dwTitleOffset;
        TCHAR szCodePage[10];

        pTemp = (PVOID)LoadResource(hInst, (HRSRC)hrsrc);

        if (pTemp == NULL)
            goto Exit;

        if (*((char *)pTemp) == 1)
            dwTitleOffset = sizeof(DLGTEMPLATEEX) + 4;
        else
            dwTitleOffset = sizeof(DLGTEMPLATE) + 4;

        langRes = GetPlatformResourceLangID();

        if (GetLocaleInfo(MAKELCID(langRes, SORT_DEFAULT),
                          LOCALE_IDEFAULTANSICODEPAGE,
                          szCodePage,
                          ARRAYSIZE(szCodePage)))
        {
            szCodePage[ARRAYSIZE(szCodePage)-1] = 0;
            if (!AsciiToNumDec(szCodePage, &dwCodePage))
            {
                dwCodePage = GetACP();
            }
        }
        else
            dwCodePage = GetACP();

        if (WideCharToMultiByte(dwCodePage, NULL,
                                (LPCWSTR)((char *)pTemp + dwTitleOffset), -1,
                                lpTitle, cchTitleMax,
                                NULL, NULL))
            bRet = TRUE;
    }

Exit:
    return bRet;
}


//+---------------------------------------------------------------------------
//
// CheckLegacyInputCPL
//
//+---------------------------------------------------------------------------

void CheckLegacyInputCPL(HWND hwndFore)
{
    if (hwndFore && !IsOnNT51())
    {
        TCHAR szWndName[MAX_PATH];
        TCHAR szWndName2[MAX_PATH];
        TCHAR szWndName3[MAX_PATH];

        //
        // Load legacy keyboard cpl name and tab titles.
        //
        if (!g_fLoadedCPLName)
        {
             HANDLE hrsrc = NULL;
             HINSTANCE hIntlInst = NULL;
             HINSTANCE hMainInst = NULL;
             HINSTANCE hCHIMEInst = NULL;

             //
             //  Get the default CPL input locale Tab title name string
             //
             if (!LoadString(g_hInst, IDS_CPL_WIN9X_KBDCPLTITLE, g_szKbdCPLTitle, sizeof(g_szKbdCPLTitle)))
                 StringCopyArray(g_szKbdCPLTitle, TEXT("Speed"));

             if (!LoadString(g_hInst, IDS_CPL_WINNT_KBDCPLTITLE, g_szNTCPLTitle, sizeof(g_szNTCPLTitle)))
                 StringCopyArray(g_szNTCPLTitle, TEXT("Input Locales"));

             //
             //  Load CPL files to read CPL name and titles
             //
             hMainInst = LoadSystemLibraryEx(MAINCPL, NULL, LOAD_LIBRARY_AS_DATAFILE);

             hIntlInst = LoadSystemLibraryEx(INTLCPL, NULL, LOAD_LIBRARY_AS_DATAFILE);

             if (!LoadString(hMainInst, WINCPLNAMEID, g_szKbdCPLName, sizeof(g_szKbdCPLName)))
                 StringCopyArray(g_szKbdCPLName, TEXT("Keyboard Properties"));

             if (IsOnNT())
             {
                 if (!LoadString(hIntlInst, NTCPLNAMEID, g_szNTCPLName, sizeof(g_szNTCPLName)))
                     StringCopyArray(g_szNTCPLName, TEXT("Regional Options"));

                 if (!GetDialogCaptionTitle(hIntlInst, (LPTSTR)(LONG_PTR)NTCPLTITLEID, g_szNTCPLTitle, ARRAYSIZE(g_szNTCPLTitle)))
                     StringCopyArray(g_szNTCPLTitle, TEXT("Input Locales"));

                 if (!IsOnNT5())
                 {
                     switch (GetACP())
                     {
                        case 936:
                        case 950:

                            hCHIMEInst = LoadSystemLibraryEx(CHIMECPL, NULL, LOAD_LIBRARY_AS_DATAFILE);

                            if (!LoadString(hCHIMEInst, CHNT4CPLNAMEID, g_szCHNT4CPLName, sizeof(g_szCHNT4CPLName)))
                                *g_szCHNT4CPLName = TEXT('\0');

                            if (!GetDialogCaptionTitle(hCHIMEInst, (LPTSTR)(LONG_PTR)CHNT4CPLTITLEID1, g_szCHNT4CPLTitle1, ARRAYSIZE(g_szCHNT4CPLTitle1)))
                                *g_szCHNT4CPLTitle1 = TEXT('\0');

                            if (!GetDialogCaptionTitle(hCHIMEInst, (LPTSTR)(LONG_PTR)CHNT4CPLTITLEID2, g_szCHNT4CPLTitle2, ARRAYSIZE(g_szCHNT4CPLTitle2)))
                                *g_szCHNT4CPLTitle2 = TEXT('\0');

                            g_fCHNT4 = TRUE;
                            break;
                     }
                 }
             }
             else
             {
                 switch (GetACP())
                 {
                    case 936:
                    case 950:
                        if (!LoadString(hMainInst, WINCPLCHNAMEID, g_szWinCHCPLName, sizeof(g_szWinCHCPLName)))
                            *g_szWinCHCPLName = TEXT('\0');

                        if (!GetDialogCaptionTitle(hMainInst, (LPTSTR)(LONG_PTR)WINCPLCHTITLEID, g_szCH9xKbdCPLTitle, ARRAYSIZE(g_szCH9xKbdCPLTitle)))
                            *g_szCH9xKbdCPLTitle = TEXT('\0');

                        g_fCHWin9x = TRUE;
                        break;
                 }

                 if (!GetDialogCaptionTitle(hMainInst, (LPTSTR)(LONG_PTR)WINCPLTITLEID, g_szKbdCPLTitle, ARRAYSIZE(g_szKbdCPLTitle)))
                     StringCopyArray(g_szKbdCPLTitle, TEXT("Speed"));
             }

             if (hMainInst)
                 FreeLibrary(hMainInst);

             if (hIntlInst)
                 FreeLibrary(hIntlInst);

             if (hCHIMEInst)
                 FreeLibrary(hCHIMEInst);

             if (!LoadString(g_hInst, IDS_CPL_INPUT_DISABLED, g_szOldCPLMsg, sizeof(g_szOldCPLMsg)))
                 StringCopyArray(g_szOldCPLMsg, TEXT("This dialog has been updated. \r\n\r\nPlease use the Text Input Settings applet in the Control Panel."));

             if (!LoadString(g_hInst, IDS_CPL_INPUT_CHAANGE_BTN, g_szCPLButton, sizeof(g_szCPLButton)))
                 StringCopyArray(g_szCPLButton, TEXT("&Change..."));

             if (!LoadString(g_hInst, IDS_CPL_INPUT_GROUPBOX, g_szCPLGroupBox, sizeof(g_szCPLGroupBox)))
                 StringCopyArray(g_szCPLGroupBox, TEXT("Input Languages and Methods"));

             g_fLoadedCPLName = TRUE;
        }

        if (GetCurrentThreadId() != GetWindowThreadProcessId(hwndFore, NULL))
            return;

        SafeGetWindowText(hwndFore, szWndName, MAX_PATH);
        StringCopyArray(szWndName2, szWndName);
        StringCopyArray(szWndName3, szWndName);

        int nSize = lstrlen(g_szNTCPLName);
        *(szWndName3 + min(ARRAYSIZE(szWndName3), nSize)) = TEXT('\0');

        if (IsOnNT() && *szWndName3 && lstrcmp(szWndName3, g_szNTCPLName) == 0)
        {
            EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_EnumChildWndProc, 0);
            return;
        }

        nSize = lstrlen(g_szKbdCPLName);
        *(szWndName + min(ARRAYSIZE(szWndName), nSize)) = TEXT('\0');

        if (*szWndName && lstrcmp(szWndName, g_szKbdCPLName) == 0)
        {
            if (!IsOnNT() && !FindWindowEx(hwndFore, NULL, NULL, g_szKbdCPLTitle))
                return;

            EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_EnumChildWndProc, 0);
            return;
        }

        if (g_fCHWin9x)
        {
            nSize = lstrlen(g_szWinCHCPLName);

            *(szWndName2 + min(ARRAYSIZE(szWndName2), nSize)) = TEXT('\0');

            if (*g_szWinCHCPLName && lstrcmp(szWndName2, g_szWinCHCPLName) == 0)
            {
                if (FindWindowEx(hwndFore, NULL, NULL, g_szWinCHCPLName))
                    EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_CH9xIMEEnumChildWndProc, 0);
            }
        }

        if (g_fCHNT4)
        {
            nSize = lstrlen(g_szCHNT4CPLName);

            *(szWndName2 + min(ARRAYSIZE(szWndName2), nSize)) = TEXT('\0');

            if (*g_szCHNT4CPLName && lstrcmp(szWndName2, g_szCHNT4CPLName) == 0)
            {
                if (FindWindowEx(hwndFore, NULL, NULL, g_szCHNT4CPLName))
                    EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_CHEnumChildWndProc, 0);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
// OnForegroundChanged
//
//+---------------------------------------------------------------------------

BOOL IsParentWindow(HWND hwnd, HWND hwndParent)
{
    while (hwnd)
    {
        if (hwnd == hwndParent)
            return TRUE;

        hwnd = GetParent(hwnd);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// OnForegroundChanged
//
//+---------------------------------------------------------------------------

BOOL OnForegroundChanged(HWND hwndFocus)
{
    HWND hwndFore;

    if (!hwndFocus)
        hwndFocus = GetFocus();

    hwndFore = GetForegroundWindow();

    TraceMsg(TF_GENERAL, "OnForegroundChanged %x %x %x", GetCurrentThreadId(), hwndFore, hwndFocus);

    //
    // if foreground window is NULL
    //    OR foregrond window is minimized
    //    OR focus window is notify tray window,
    //
    //   we keep the previous status.
    //
    if (!hwndFore || 
        IsIconic(hwndFore) || 
        IsNotifyTrayWnd(hwndFocus ? hwndFocus : hwndFore))
    {
        return FALSE;
    }


    //
    // we want to update both SharedMem->hwndForegorundPrev and 
    // SharedMem->dwFocusThreadPrev, if the foregorund window was changed.
    //
    if (hwndFore != GetSharedMemory()->hwndForeground)
    {
        GetSharedMemory()->hwndForegroundPrev = GetSharedMemory()->hwndForeground;
        GetSharedMemory()->dwFocusThreadPrev = GetSharedMemory()->dwFocusThread;
    }

    GetSharedMemory()->hwndForeground = hwndFore;
    if (hwndFocus)
    {
        DWORD dwFocusThread;
        DWORD dwFocusProcess;

        dwFocusThread = GetWindowThreadProcessId(hwndFocus, &dwFocusProcess);

        if (hwndFore && 
            (dwFocusThread != GetWindowThreadProcessId(hwndFore, NULL)))
        {
            if (!IsParentWindow(hwndFocus, hwndFore))
                return FALSE;
        }

        //
        // Even the foregorund window was not changed, we may need to check
        // the thread of focus window. New focus window is in different
        // thread. Then we need to make TFPRIV_ONSETTHREADFOCUS message.
        //

        DWORD dwFocusThreadPrev = GetSharedMemory()->dwFocusThread;
        GetSharedMemory()->dwFocusThread = dwFocusThread;
        GetSharedMemory()->dwFocusProcess = dwFocusProcess;

        if (dwFocusThreadPrev != GetSharedMemory()->dwFocusThread)
            GetSharedMemory()->dwFocusThreadPrev = dwFocusThreadPrev;
    }
    else if (hwndFore)
    {
        //
        // The focus window is not in the current thread... So at first we 
        // try to get the thread id of the foreground window.
        // The focus window may not be in the foreground window's thread. But
        // it is ok, as long as we track the focus in the focus thread.
        //
        GetSharedMemory()->dwFocusThread = GetWindowThreadProcessId(GetSharedMemory()->hwndForeground, &GetSharedMemory()->dwFocusProcess);
    }
    else
    {
        GetSharedMemory()->dwFocusThread = 0;
        GetSharedMemory()->dwFocusProcess = 0;
    }

    if (GetSharedMemory()->dwFocusThread != GetSharedMemory()->dwLastFocusSinkThread)
    {
        //
        // Perf:
        //
        // See SysGetMsgProc()!
        // Now, only thread that has TIM needs to receive 
        // TFPRIV_ONKILLTHREADFOCUS or TF_PRIV_ONSETTHREADFOCUS.
        // We should check the target thread has TIM or not. So we can
        // save the number of these post messages.
        //

        if (GetSharedMemory()->dwFocusThreadPrev != 0)
        {
            PostThreadMessage(GetSharedMemory()->dwFocusThreadPrev, 
                              g_msgPrivate, 
                              TFPRIV_ONKILLTHREADFOCUS, 
                              0);
        }

        if (GetSharedMemory()->dwFocusThread != 0)
        {
            PostThreadMessage(GetSharedMemory()->dwFocusThread, 
                              g_msgPrivate, 
                              TFPRIV_ONSETTHREADFOCUS, 
                              0);

        }

        GetSharedMemory()->dwLastFocusSinkThread = GetSharedMemory()->dwFocusThread;
    }

    //
    // Checking legacy keyboard CPL.
    //
    CheckLegacyInputCPL(hwndFore);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// OnIMENotify
//
//+---------------------------------------------------------------------------

void OnIMENotify()
{
    SYSTHREAD *psfn;

    if (psfn = GetSYSTHREAD())
    {
        if (psfn->plbim && psfn->plbim->_GetLBarItemWin32IME())
        {
            psfn->plbim->_GetLBarItemWin32IME()->UpdateIMEIcon();
        }
    }
}

#ifdef CHECKFEIMESELECTED
//+---------------------------------------------------------------------------
//
// CheckFEIMESelected
//
// This function checks the current selected FEIME is active in Cicero
// Assembly. If it is not activated, we calls ActivateAssemblyItem().
//
//+---------------------------------------------------------------------------


void CheckFEIMESelected(SYSTHREAD *psfn, HKL hKL)
{
    int i;
    CAssembly *pAsm;
    BOOL fFound;

    Assert(psfn);

    if (!psfn->pAsmList)
        return;

    if (!IsPureIMEHKL(hKL))
        return;

    pAsm = psfn->pAsmList->FindAssemblyByLangId(LANGIDFROMHKL(hKL));
    if (!pAsm)
        return;

    //
    // Windows #311672 
    //
    // EUDCEDIT.EXE calls ActivateKeyboardLayout() to activate IME hKL.
    // Cicero should not break the API on WinXP. Skip SmartVoice hardcode.
    //
    //
#if 0
    //
    // SmartVoice Hack
    // 
    //  we want to remove this smart voice hack section to solve
    //  general ActivateKayboardLayout() problem. However Office10 wants
    //  the safest fix for this problem. So we check SmartVoice IME here
    //  to minimize the rish of CheckFEIMESelected() call.
    //
    {
        static const char c_szSmartVoiceIME[] = "smartv20.ime";
        char szIMEFile[MAX_PATH];
        if (!ImmGetIMEFileNameA(hKL, szIMEFile, sizeof(szIMEFile)))
            return;

        if (lstrcmpi(szIMEFile, c_szSmartVoiceIME))
            return;
    }
#endif

    //
    // check if the hKL is substituted by the activate Item.
    //
    // We try to find the active Item first.
    //
    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem)
            continue;

        if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        if (!pItem->fEnabled)
            continue;

        if (!pItem->fActive)
            continue;

        if (pItem->hklSubstitute == hKL)
        {
            //
            // #383710 OfficeXP's RichEd20.dll calls ActivateKeyboardlayout()
            // with Korean IME hKL even though it is running on AIMM mode.
            // we need to adjust the assembly item.
            //
            CThreadInputMgr *ptim = psfn->ptim;
            if (ptim)
            {
                if (ptim->_GetFocusDocInputMgr()) 
                {
                    ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, 0);
                }
                else
                {
                    //
                    // we could not have a chance to sync the current hKL
                    // init hklBeingActivated and try when DIM gets the focus.
                    //
                    psfn->hklBeingActivated = NULL;
                }
            }
            return;
        }
    }

    //
    // Ok we could not find active Item with hKL as its substitute hKL.
    // Let's find it from non-active Item, too.
    //
    if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr()) 
    {
        for (i = 0; i < pAsm->Count(); i++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(i);

            if (!pItem)
                continue;

            if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
                continue;

            if (!pItem->fEnabled)
                continue;

            if (pItem->hklSubstitute == hKL)
            {
                ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, 0);
                return;
            }
        }
    }


    fFound = FALSE;
    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItem;
        pItem= pAsm->GetItem(i);

        if (!pItem)
            continue;

        if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        if (pItem->hkl != hKL)
            continue;

        fFound = TRUE;
        if (!pItem->fActive)
        {
            //
            // This item is not activated.
            // Call ActivateAssemblyItem() now and return.
            //
            ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, 0);
            return;
        }
    }

    //
    // we could not find the activated hKL in our Asmlist.
    //
    if (!fFound)
    {
        UnknownFEIMESelected(LANGIDFROMHKL(hKL));
    }
}
#endif CHECKFEIMESELECTED

//+---------------------------------------------------------------------------
//
// OnShellLanguage
//
//+---------------------------------------------------------------------------
void OnShellLanguage(HKL hKL)
{
    SYSTHREAD *psfn;

    HWND hwndFore = GetForegroundWindow();
    if (IsConsoleWindow(hwndFore))
    {
        DWORD dwThreadId = GetWindowThreadProcessId(hwndFore, NULL);

        g_timlist.SetConsoleHKL(dwThreadId, hKL);

        if (OnForegroundChanged(NULL))
            MakeSetFocusNotify(g_msgSetFocus, 0, 0);

        MakeSetFocusNotify(g_msgLBUpdate, 
                           TF_LBU_NTCONSOLELANGCHANGE, 
                           (LPARAM)hKL);
        return;
    }

    psfn = GetSYSTHREAD();
    if (!psfn)
        return;

    if (psfn->hklBeingActivated == hKL)
        psfn->hklBeingActivated = NULL;


    if (LANGIDFROMHKL(hKL) != GetCurrentAssemblyLangId(psfn))
    {
        //
        // if it is in Cicero aware and the hKL does not match with
        // current assembly, someone else might call ActivateKayboardLayout().
        // we need to change the current assembly right away..
        //
        // ActivateAssembly(LANGIDFROMHKL(hKL), ACTASM_ONSHELLLANGCHANGE);
        //

        //
        // WM_INPUTLANGCHNAGEREQUEST is being queued now.
        // Post another message to confirm the hKL.
        //
        PostThreadMessage(GetCurrentThreadId(),
                          g_msgPrivate,
                          TFPRIV_POSTINPUTCHANGEREQUEST,
                          0);
    }
    else
    {
        if (psfn->plbim)
             UpdateSystemLangBarItems(psfn, 
                                      hKL, 
                                      !psfn->plbim->InAssemblyChange());

    }

    if (IsPureIMEHKL(hKL))
    {
        OnIMENotify();

        //
        // Temp rolling back SmartVoice (Cic#4580) fix. Since we got some
        // regression like Cic#4713 and so on.
        //
#ifdef CHECKFEIMESELECTED
        //
        // check this hkl is activated in Cicero Assembly.
        //
        CheckFEIMESelected(psfn, hKL);
#endif
    }
}

//+---------------------------------------------------------------------------
//
// UninitThread
//
//+---------------------------------------------------------------------------

typedef HRESULT (*PFNCTFIMETHREADDETACH)(void);

void UninitThread()
{
    DWORD dwThreadId = GetCurrentThreadId();
    SYSTHREAD *psfn = FindSYSTHREAD();

    if (psfn)
        psfn->fCUASDllDetachInOtherOrMe = TRUE;

//  g_SharedMemory.Close();

#if 1
    if (GetSharedMemory() == NULL && ! IsSharedMemoryCreated())
    {
        // Shared memory already closed.
        return;
    }
#endif

    if (GetSharedMemory()->dwFocusThread == dwThreadId)
    {
        GetSharedMemory()->dwFocusThread  = 0;
        GetSharedMemory()->dwFocusProcess  = 0;
        GetSharedMemory()->hwndForeground = NULL;
    }

    if (GetSharedMemory()->dwFocusThreadPrev == dwThreadId)
    {
        GetSharedMemory()->hwndForegroundPrev = NULL;
        GetSharedMemory()->dwFocusThreadPrev = 0;
    }

    if (GetSharedMemory()->dwLastFocusSinkThread == dwThreadId)
    {
        GetSharedMemory()->dwLastFocusSinkThread = 0;
    }

    //
    // Issue: 
    //
    // UninitThread() is called from DLL_THREAD_DETACH so 
    // we should not call MakeSetFocusNotify() because it uses 
    // ciritical section and could cause dead lock.
    //
    MakeSetFocusNotify(g_msgThreadTerminate, 0, (LPARAM)dwThreadId);


    if (psfn && GetSystemMetrics(SM_SHUTTINGDOWN))
    {
        psfn->fUninitThreadOnShuttingDown = TRUE;
    }

    //
    // Tell msctfime that msctf's thread_detach is being called.
    // So it can deactivate TIM now. If we don't do this now,
    // it may deactivate TIM afte msctf's thread detach is called.
    //
    if (g_fCUAS && g_szCUASImeFile[0])
    {
        HINSTANCE hInstMsctfime;

        hInstMsctfime = GetSystemModuleHandle(g_szCUASImeFile);
        if (hInstMsctfime)
        {
            PFNCTFIMETHREADDETACH pfn = NULL;
            pfn = (PFNCTFIMETHREADDETACH)GetProcAddress(hInstMsctfime,
                                                        "CtfImeThreadDetach");
            if (pfn)
                pfn();
        }
    }

}

//+---------------------------------------------------------------------------
//
// SysShellProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK SysShellProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    TraceMsg(TF_GENERAL, "SysShellProc %x %x %x", nCode, wParam, lParam);
    HHOOK hHook;

    if (g_fDllProcessDetached)
    {
        hHook = s_hSysShellHook;
        goto Exit;
    }

    _try
    {
        hHook = GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64);

        _ShellProc(nCode, wParam, lParam);
    }
    _except(CicExceptionFilter(GetExceptionInformation()))
    {
        Assert(0);
    }

Exit:
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _ShellProc
//
//+---------------------------------------------------------------------------

UINT _ShellProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HWND hwndActive;

    //
    // give AIMM the Shell events.
    //
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;
    if (psfn = GetSYSTHREAD())
    {
        if (ptim = psfn->ptim)
        {
            if (ptim->GetSysHookSink())
            {
                ptim->GetSysHookSink()->OnSysShellProc(nCode, wParam, lParam);
            }
        }
    }

    switch (nCode)
    {
        case HSHELL_LANGUAGE:
            OnShellLanguage((HKL)lParam);
            break;

        case HSHELL_WINDOWACTIVATED:
            //TraceMsg(TF_GENERAL, "SysShellProc: HSHELL_WINDOWACTIVATED %x", GetCurrentThreadId());
            GetSharedMemory()->fInFullScreen = lParam ? TRUE : FALSE;

            hwndActive = GetActiveWindow();
            if (hwndActive && 
                (GetWindowThreadProcessId(hwndActive, NULL) == GetCurrentThreadId()))
            {
                if (OnForegroundChanged(NULL))
                    MakeSetFocusNotify(g_msgSetFocus, 0, 0);
            }
            else 
            {
                hwndActive = GetForegroundWindow();
                goto CheckConsole;
            }
            break;

        case HSHELL_WINDOWCREATED:
            hwndActive = (HWND)wParam;
CheckConsole:
            if (hwndActive && IsOnNT() && IsConsoleWindow(hwndActive))
            {
                DWORD dwProcessId;
                DWORD dwThreadId = GetWindowThreadProcessId(hwndActive, 
                                                            &dwProcessId);

                if ((nCode == HSHELL_WINDOWCREATED) ||
                     !(g_timlist.GetFlags(dwThreadId) & TLF_NTCONSOLE))
                    g_timlist.AddThreadProcess(dwThreadId, 
                                               dwProcessId, 
                                               NULL, 
                                               TLF_NTCONSOLE);

                if (OnForegroundChanged(NULL))
                {
                    HKL hklConsole = g_timlist.GetConsoleHKL(dwThreadId);
                    if (!hklConsole)
                    {
                        hklConsole = GetKeyboardLayout(dwThreadId);
                        g_timlist.SetConsoleHKL(dwThreadId, hklConsole);
                    }
                    MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                    MakeSetFocusNotify(g_msgLBUpdate, 
                                       TF_LBU_NTCONSOLELANGCHANGE, 
                                       (LPARAM) (HKL)hklConsole);
                }
            }
            break;

    }

    return 1;
}

//+---------------------------------------------------------------------------
//
// OnSetWindowFocus()
//
//+---------------------------------------------------------------------------

void OnSetWindowFocus(SYSTHREAD *psfn, HWND hwnd)
{
    CThreadInputMgr *ptim;
    Assert(psfn)

    if (psfn->hklDelayActive)
    {
        ActivateKeyboardLayout(psfn->hklDelayActive, 0);
        psfn->hklDelayActive = NULL;
    }

    if (ptim = psfn->ptim)
    {
        if (hwnd)
        {
            if (ptim->GetSysHookSink())
                ptim->GetSysHookSink()->OnPreFocusDIM(hwnd);

            Assert(GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId());
            CDocumentInputManager *pdim;

            pdim = ptim->_GetAssoc(hwnd);

            //
            // we don't want to clear focus dim if there is no
            // foreground window.
            //
            if (pdim || GetForegroundWindow())
            {
                // focus dim will be clear if pdim is NULL.
                ptim->_SetFocus(pdim, TRUE);
            }
        }
    }

    //
    // update foregorund window handle and thread id.
    // Because shell hook is posted event, we need to update
    // before MakeSetFocusNotify. Otherwise we miss timing to 
    // update them.
    //
    // We can not call GetFocus() since it may return
    // the previous focus during CBT hook.
    // When the focus moves back from embedded OLE server,
    // GetFocus() may get the the OLE server's window handle.
    //
    if (OnForegroundChanged(hwnd))
    {
        //
        // If hwndFocus is NULL, focus is moved to other thread.
        //
        MakeSetFocusNotify(g_msgSetFocus, 0, 0);
    }

}

//+---------------------------------------------------------------------------
//
// OnSetWindowFocusHandler()
//
//+---------------------------------------------------------------------------

void OnSetWindowFocusHandler(SYSTHREAD *psfn, MSG *pmsg)
{
    if (!psfn)
        return;

    //
    // We're destroying the marhacl window right now. We don't have
    // any more visible windows.
    //
    if (psfn->uDestroyingMarshalWnd)
    {
        goto Exit;
    }

    HWND hwndFocus = GetFocus();
    if (hwndFocus)
    {
        //
        // review review
        //
        // Don't we need to call 
        // OnForegroundChanged() if psfn->hwndBegin
        // gFocued() is NULL?
        // Maybe no, OnForegroundChanged() is 
        // called in activatewindow.
        //
        if (psfn->hwndBeingFocused == hwndFocus)
        {
            OnSetWindowFocus(psfn, hwndFocus);
        }
        else 
        {
            //
            // #476100
            //
            // if we miss this, we need to post
            // TFPRIV_ONSETWINDOWFOCUS again.
            // Because the focus thread might processed
            // this meesage already and it does not
            // call OnSetWindowFocus().
            //
            DWORD dwFocusWndThread = GetWindowThreadProcessId(hwndFocus, NULL);
            if (psfn->dwThreadId != dwFocusWndThread)
            {
                PostThreadMessage(dwFocusWndThread,
                                  g_msgPrivate, 
                                  TFPRIV_ONSETWINDOWFOCUS,  
                                  (LPARAM)-1);
            }
            else if (pmsg->lParam == (LPARAM)-2)
            {
                if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr())
                {
                    HWND hwndAssoc;

                    hwndAssoc = psfn->ptim->_GetAssoced(psfn->ptim->_GetFocusDocInputMgr());
                    //
                    // lParam is -2 because the SetFocus(dim) is already 
                    // called. 
                    // hwndAssoc is NULL. Now we're in Cicero aware.
                    //
                    // So we just do OnForegroundChanged(). Don't call
                    // OnSetWindowFocus().
                    //
                    // Bug#623920 - Don't need to check up hwndAssoc since the current focus
                    // window has the right dim value and also need to update language bar even
                    // with hwndAssoc
                    //
                    //if (!hwndAssoc)
                    //
                    {
                        if (OnForegroundChanged(hwndFocus))
                        {
                            MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                        }
                    }
                }
            }
            else if ((pmsg->lParam == (LPARAM)-1) ||
                     (psfn->dwThreadId == GetWindowThreadProcessId(GetForegroundWindow(), NULL)))
            {
                //
                // #479926
                //
                // The first SetFocus() in the thread
                // may break the order of CBT hook
                // because xxxSetFocus() calls
                // xxxActivateWindow() and this cause
                // another xxxSetFocus(). After 
                // xxxActivateWindow() returns
                // the first xxxSetFocus() updates
                // the spwndFocus.
                //
                // see ntuser\kernel\focusact.c
                //
                // Now we need to hack. We're 100% sure
                // if the focus window and the fore-
                // ground window is in same thread,
                // we can do _SetFocus(dim).
                // but if focusdim does not have a associated window,
                // Cicero App might call SetFocus() already. Then
                // we don't do anything.
                //
                if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr())
                {
                    HWND hwndAssoc;

                    hwndAssoc = psfn->ptim->_GetAssoced(psfn->ptim->_GetFocusDocInputMgr());
                    if (hwndAssoc && hwndFocus != hwndAssoc)
                        OnSetWindowFocus(psfn, hwndFocus);
                }
                else if (!psfn->ptim ||
                          psfn->ptim->_IsNoFirstSetFocusAfterActivated() ||
                          psfn->ptim->_IsInternalFocusedDim())
                {
                    OnSetWindowFocus(psfn, hwndFocus);
                }
            }
        }

    }


    //
    // try to update Kana status every time 
    // focus changes.
    //
    //
    // when the focus is changed, we need to make
    // notification again.
    //
    psfn->fInitCapsKanaIndicator = FALSE; 
    StartKanaCapsUpdateTimer(psfn);

Exit:
    psfn->hwndBeingFocused = NULL;
    psfn->fSetWindowFocusPosted = FALSE;
}

//--------------------------------------------------------------------------
//
//  IsPostedMessage
//
//--------------------------------------------------------------------------

__inline BOOL IsPostedMessage()
{
    DWORD dwQueueStatus = GetQueueStatus(QS_POSTMESSAGE);
    return (HIWORD(dwQueueStatus) & QS_POSTMESSAGE) ? TRUE : FALSE;
}
//--------------------------------------------------------------------------
//
//  RemovePrivateMessage
//
//--------------------------------------------------------------------------

void RemovePrivateMessage(SYSTHREAD *psfn, HWND hwnd, UINT uMsg)
{
    MSG msg;
    UINT nQuitCode;
    BOOL fQuitReceived = FALSE;
    DWORD dwPMFlags = PM_REMOVE | PM_NOYIELD;

    if (!IsPostedMessage())
        return;


    //
    // Cic#4666 PostPet v1.12 fault.
    // PostPet.exe cause av when it receives its internal message in 
    // CBT_DESTROYWINDOW hook when it is terminated.
    // At this time, the child thread is calling SendMessage() to the window
    // in the main thread. So calling PeekMessage() may receive the message
    // and pass it to PostPet window.
    //
    // I found Win98 has a bug in PM_QS_POSTMESSAGE. Win98's PeekMessage()
    // handles the message that is sent from other thread without
    // PM_QS_SENDMESSAGE. 
    //
    // If we has to fix this problem on Win98, I think it is better to have
    // another compatibility flag so we can skip this PeekMessage() in
    // PostPet.exe. In PostPet.exe, it is ok not to clean queue since
    // this happens only app termination.
    //
    if (IsOnNT5())
        dwPMFlags |= PM_QS_POSTMESSAGE;

    while (PeekMessage(&msg, hwnd, uMsg, uMsg, dwPMFlags ))
    {
        if (msg.message == WM_QUIT)
        {
            nQuitCode = (UINT)(msg.wParam);
            fQuitReceived = TRUE;
            break;
        }

        //
        // should we dispatch the message to the marshal window?
        //
#if 0
        //
        // Cic#4869
        //
        // we don't want to dispatch this message to marshal window.
        // This HCBT_DESTROYWINDOW may be in OLEAUT32.DLL's DllMain() and
        // dispatching this message could cause the reentry to OLEAUT32's
        // DLLMain() because we do delay load.
        //

        //
        // dispatch if this message is for marshal window.
        //
        if (psfn->hwndMarshal && (psfn->hwndMarshal == msg.hwnd))
        {
            DispatchMessage(&msg);
        }
#endif

        //
        // Cic#4699
        //
        // Exception MSUIM.Msg.MuiMgrDirtyUpdate private message.
        // If we get this message, reset CLangBarItemMgr::_fDirtyUpdateHandling
        //
        if (psfn->hwndMarshal && (psfn->hwndMarshal == msg.hwnd) &&
            msg.message == g_msgNuiMgrDirtyUpdate &&
            psfn->plbim)
        {
            psfn->plbim->ResetDirtyUpdate();
        }

    }

    if (fQuitReceived)
        PostQuitMessage(nQuitCode);

}


//+---------------------------------------------------------------------------
//
// CheckQueueOnLastWindowDestroyed()
//
// Super EnumWindow hack.
//
// When the last visible window in the thread is destroyed.
//
//  1. we destroy the marshal worker window on NT4. (Cic #658)
//    Because some application may found Cic marshal window 
//    by calling EnumWindow.
//    
//
//  2. we need to clean up the thread queue. (Cic #3080)
//    Because some application calls GetMessage() or PeekMessage()
//    with specific window handle or message soour private messages
//    remain in the queue. Then WM_QUIT message won't be handled..
//
// this is not complete solution but at least we can avoid
// the ghost windows or remained message in the queue.
//
//+---------------------------------------------------------------------------

void CheckQueueOnLastWindowDestroyed(SYSTHREAD *psfn, HWND hwnd)
{
    BOOL fOnNT4;

    //
    // we don't have to do this on ctfmon process.
    //
    if (psfn->fCTFMON)
        return;

    //
    // check if it's nt4.
    //
    fOnNT4 = (IsOnNT() && !IsOnNT5()) ? TRUE : FALSE;

#if 0
    if (!fOnNT4)
    {
        //
        // If there is no posted message, we don't have to do this.
        // EnumThreadWindow() is slow....
        //
        if (!IsPostedMessage())
            return;
    }
#endif

    LONG_PTR style = GetWindowLongPtr(hwnd, GWL_STYLE);
    if (style & WS_CHILD) 
        return;

    if (hwnd == psfn->hwndMarshal)
        return;

    //
    // skip IME windows.
    //
    style = GetClassLongPtr(hwnd, GCL_STYLE);
    if (style & CS_IME)
        return;


    //
    // check the focus window first. 
    //
    // if there is a focus window and it is not a child
    // of the window that is being destroyed, we don't 
    // have to destroy marshal window.
    //
    HWND hwndTmp = GetFocus();
    if (hwndTmp && 
        (GetCurrentThreadId() != GetWindowThreadProcessId(hwndTmp, NULL)))
        hwndTmp = NULL;

    if (hwndTmp)
    {
        BOOL fParentFound = FALSE;
        do {
            if (hwndTmp == hwnd)
                fParentFound = TRUE;

            hwndTmp = GetParent(hwndTmp);
        } while(hwndTmp);

        if (!fParentFound)
            return;
    }

    CHECKVISIBLEWND cmw;
    cmw.hwndMarshal = psfn->hwndMarshal;
    cmw.hwndBeingDestroyed = hwnd;
    cmw.fVisibleFound = FALSE;
    EnumThreadWindows(psfn->dwThreadId,
                      CheckVisibleWindowEnumProc,
                      (LPARAM)&cmw);

    if (!cmw.fVisibleFound)
    {
        BOOL fInDestroyingMarshalWnd = FALSE;
        if (psfn->uDestroyingMarshalWnd)
            fInDestroyingMarshalWnd = TRUE;

        psfn->uDestroyingMarshalWnd++;

        DestroyMarshalWindow(psfn, hwnd);

#ifdef CUAS_ENABLE
        //
        // Under CUAS, we need to deactivate TIM to destroy all TIP's window
        // when there is no visible window in this thread.
        // And we destroy the default IME window so we can restore TIM for 
        // CUAS when the default IME window is created again in this thread.
        // There is no way to know if the default IME window finds another
        // top level window if it is created during DestroyWindow().
        //
        if (CtfImmIsCiceroEnabled() && 
            !CtfImmIsTextFrameServiceDisabled() &&
            !psfn->fCUASInCreateDummyWnd &&
            !psfn->fDeactivatingTIP)
        {
            if (!psfn->fCUASInCtfImmLastEnabledWndDestroy)
            {
                psfn->fCUASInCtfImmLastEnabledWndDestroy = TRUE;

                CtfImmLastEnabledWndDestroy(0);

                if (!(InSendMessageEx(NULL) & ISMEX_SEND))
                    CtfImmCoUninitialize();

                psfn->fCUASInCtfImmLastEnabledWndDestroy = FALSE;
            }

            if (!fInDestroyingMarshalWnd)
            {
                HWND hwndImmDef = ImmGetDefaultIMEWnd(hwnd);
                if (hwndImmDef)
                {
                    DestroyWindow(hwndImmDef);
                }
            }

            psfn->fCUASNoVisibleWindowChecked = TRUE;
        }
#endif CUAS_ENABLE

        psfn->uDestroyingMarshalWnd--;
    }
}

void DestroyMarshalWindow(SYSTHREAD* psfn, HWND hwnd)
{
    BOOL fOnNT4;

    if (IsPostedMessage())
    {
        if (psfn->hwndMarshal)
            RemovePrivateMessage(psfn, psfn->hwndMarshal, 0);

        RemovePrivateMessage(psfn, NULL, g_msgPrivate);
        RemovePrivateMessage(psfn, NULL, g_msgRpcSendReceive);
        RemovePrivateMessage(psfn, NULL, g_msgThreadMarshal);
        RemovePrivateMessage(psfn, NULL, g_msgStubCleanUp);
    }

    //
    // #339621
    //
    // This is rare but. We need to clear ShareMem->dwFocusThread and
    // dwFocusProcess. Otherwise we will get another PostThreadMessage()
    // with TFPRIV_ONKILLTHREADFOCUS later. And SQL setup hungs.
    //
    if (GetSharedMemory()->dwFocusThread == psfn->dwThreadId)
        GetSharedMemory()->dwFocusThread = 0;

    if (GetSharedMemory()->dwFocusProcess == psfn->dwProcessId)
        GetSharedMemory()->dwFocusProcess = 0;

    //
    // check if it's nt4.
    //
    fOnNT4 = (IsOnNT() && !IsOnNT5()) ? TRUE : FALSE;

    if (fOnNT4 && IsWindow(psfn->hwndMarshal))
    {
        DestroyWindow(psfn->hwndMarshal);
        psfn->hwndMarshal = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CreateDummyWndForDefIMEWnd
//
//+---------------------------------------------------------------------------

#ifdef CUAS_ENABLE
BOOL g_fCDWRegistered = FALSE;
const CHAR c_szDummyWndForDefIMEWnd[] = "CicDUmmyWndForDefIMEWnd";

//+---------------------------------------------------------------------------
//
// CicDummyForDefIMEWndProc
//
// This needs to be user mode wndproc. Otherwise system does not create
// a default IME window
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK CicDummyForDefIMEWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

void CreateDummyWndForDefIMEWnd()
{
    HWND hwnd;

    if (!g_fCDWRegistered)
    {
        WNDCLASSEX wndclass;

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.hInstance     = g_hInst;
        wndclass.hCursor       = NULL;
        wndclass.lpfnWndProc   = CicDummyForDefIMEWndProc;
        wndclass.lpszClassName = c_szDummyWndForDefIMEWnd;

        if (RegisterClassEx(&wndclass))
           g_fCDWRegistered = TRUE;
    }


    //
    // call CraeteWindow() to create a default IME window.
    //
    hwnd = CreateWindowEx(0, c_szDummyWndForDefIMEWnd, NULL,
                          WS_POPUP,
                          0,0,0,0,
                          NULL, NULL, g_hInst, NULL);
    if (hwnd)
        DestroyWindow(hwnd);

}
#endif // CUAS_ENABLE

#ifdef CUAS_ENABLE
//+---------------------------------------------------------------------------
//
// UninitThreadHooksIfNoWindow()
//
// When the last window in the thread is destroyed.
// Unhook thread local hook for SetThreadDesktop().
//
//+---------------------------------------------------------------------------

void UninitThreadHooksIfNoWindow(SYSTHREAD* psfn, HWND hwnd)
{
    CHECKNOWND cmw;
    cmw.hwndBeingDestroyed = hwnd;
    cmw.fWindowFound = FALSE;
    EnumThreadWindows(psfn->dwThreadId,
                      CheckNoWindowEnumProc,
                      (LPARAM)&cmw);

    if (! cmw.fWindowFound)
    {
        DestroyMarshalWindow(psfn, hwnd);
        if (IsWindow(psfn->hwndMarshal) &&
            (psfn->hwndMarshal != hwnd)   )
        {
            DestroyWindow(psfn->hwndMarshal);
            psfn->hwndMarshal = NULL;
        }
        UninitThreadHooks(psfn);
    }
}
#endif // CUAS_ENABLE

//+---------------------------------------------------------------------------
//
// SysCBTProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK SysCBTProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn;
    HHOOK hHook;

    if (g_fDllProcessDetached)
    {
        hHook = s_hSysCBTHook;
        goto Exit;
    }

    _try
    {
        hHook = GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64);

        InitThreadHook(GetCurrentThreadId());

        switch (nCode)
        {
            case HCBT_CREATEWND:
                    if ((psfn = GetSYSTHREAD()) &&
                        psfn->hklDelayActive)
                    {
                        if (ActivateKeyboardLayout(psfn->hklDelayActive, 0))
                            psfn->hklDelayActive = NULL;
                    }
                    break;

            case HCBT_ACTIVATE:
                    _CBTHook(HCBT_ACTIVATE, wParam, lParam);
                    break;

            case HCBT_SETFOCUS:
                    _CBTHook(HCBT_SETFOCUS, wParam, lParam);
                    break;

            case HCBT_DESTROYWND:
                    if (psfn = GetSYSTHREAD())
                    {
                        CheckQueueOnLastWindowDestroyed(psfn, (HWND)wParam);
#ifdef CUAS_ENABLE
                        UninitThreadHooksIfNoWindow(psfn, (HWND)wParam);
#endif // CUAS_ENABLE
                    }

                    break;
        }
    }
    _except(CicExceptionFilter(GetExceptionInformation()))
    {
        Assert(0);
    }

Exit:
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

UINT _CBTHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn;

    switch (nCode)
    {
        case HCBT_ACTIVATE:
                if (wParam)
                {
                    if (((HWND)wParam == GetForegroundWindow()) &&
                        OnForegroundChanged(NULL))
                            MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                }
                break;

        case HCBT_SETFOCUS:
                if (psfn = GetSYSTHREAD())
                {
#ifdef CUAS_ENABLE
                    //
                    // Cic#5254
                    //
                    // After we detect no more visible window,
                    // some window could become visible. 
                    // Since we destroyed the default IME window,
                    // we need to recreate it.
                    //
                    // Here is a hack to do. Call a dummy CreateWindow()
                    // to create a default IME window in this thread.
                    //
                    if (psfn->fCUASNoVisibleWindowChecked)
                    {
                        psfn->fCUASInCreateDummyWnd = TRUE;
                        CreateDummyWndForDefIMEWnd();
                        psfn->fCUASInCreateDummyWnd = FALSE;
                        psfn->fCUASNoVisibleWindowChecked = FALSE;
                    }
#endif

                    psfn->hwndBeingFocused = (HWND)wParam;

                    if (!psfn->fSetWindowFocusPosted)
                    {
                        PostThreadMessage(GetCurrentThreadId(), 
                                          g_msgPrivate, 
                                          TFPRIV_ONSETWINDOWFOCUS,  
                                          (LPARAM)wParam);
                        psfn->fSetWindowFocusPosted = TRUE;
                    }
                }
                break;
    }

    return 1;
}

//+---------------------------------------------------------------------------
//
// RemoveThisMessage
//
//+---------------------------------------------------------------------------

BOOL RemoveThisMessage(MSG *pmsg)
{
    MSG msg;
    SYSTHREAD *psfn;

    if (psfn = GetSYSTHREAD())
    {
        if (psfn->uMsgRemoved)
        {
            Assert(psfn->uMsgRemoved == pmsg->message);
            // Assert(psfn->dwMsgTime == pmsg->time);
            return TRUE;
        }

        Assert(!psfn->uMsgRemoved);
        psfn->uMsgRemoved = pmsg->message;
        psfn->dwMsgTime = pmsg->time;
    }

    PeekMessage(&msg, NULL, pmsg->message, pmsg->message, PM_REMOVE | PM_NOYIELD);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  HandledThisMessage
//
//+---------------------------------------------------------------------------

void FinishThisMessage(MSG *pmsg)
{
    SYSTHREAD *psfn;

    if (psfn = GetSYSTHREAD())
    {
        psfn->uMsgRemoved = 0;
        psfn->dwMsgTime = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  PostInputChangeRequestHandler()
//
//  this is the function that is called by TFPRIV_POSTINPUTCHANGEREQUEST.
//  We need to confirm the current hKL mathes with Cicero assembly language.
//  And we need to check the substitute hKL is selected on Cicero control.
//
//+---------------------------------------------------------------------------

void PostInputChangeRequestHandler()
{
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (!psfn)
        return;

    //
    // If the current hKL does not match with
    // Cicero assembly language, we call 
    // ActivateAssembly() to sync to the current 
    // hKL. Someone accepted this language change.
    //
    HKL hKL = GetKeyboardLayout(0);

    if (LANGIDFROMHKL(hKL) != GetCurrentAssemblyLangId(psfn))
    {
        //
        // #494602, Corel Draw 10 calls LoadKeyboardLayout and ActivateKeyboardLayout.
        // If specified hKL doesn't exist in our assembly list, then should update.
        //
        if (! IsPureIMEHKL(hKL) && psfn->pAsmList)
        {
            CAssembly *pAsm = psfn->pAsmList->FindAssemblyByLangId(LANGIDFROMHKL(hKL));
            if (! pAsm)
            {
                CAssemblyList::InvalidCache();
                EnsureAssemblyList(psfn, TRUE);
            }
        }

        ActivateAssembly(LANGIDFROMHKL(hKL), ACTASM_NONE);
    }
    else
    {
        CThreadInputMgr *ptim = psfn->ptim;
        if (ptim && ptim->_GetFocusDocInputMgr()) 
        {
            ASSEMBLYITEM *pItem = NULL;

            if (psfn->pAsmList)
            {
                CAssembly *pAsm = psfn->pAsmList->FindAssemblyByLangId(LANGIDFROMHKL(hKL));
                if (pAsm)
                    pItem = pAsm->GetSubstituteItem(hKL);
            }

            if (pItem)
                ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, AAIF_CHANGEDEFAULT);
        }
    }
}

//+---------------------------------------------------------------------------
//
// InputLangChangeHandler
//
//+---------------------------------------------------------------------------

void InputLangChangeHandler(MSG *pmsg)
{
    SYSTHREAD *psfn;
    IMM32HOTKEY *pHotKey;
    HKL hKL = GetKeyboardLayout(0);
    psfn = GetSYSTHREAD();

    if (psfn)
        psfn->hklBeingActivated = NULL;

    if (IsInLangChangeHotkeyStatus())
    { 
        pmsg->message = WM_NULL;
        return;
    }

    if (pHotKey = IsInImmHotkeyStatus(psfn, LANGIDFROMHKL(hKL)))
    {
        //
        // if we're hooking in IMM32's HotKey, we need to skip 
        // this INPUTLANGUAGECHANGEREQUEST.
        //
        pmsg->message = WM_NULL;
#ifdef SIMULATE_EATENKEYS
        CancelImmHotkey(psfn, pmsg->hwnd, pHotKey);
#endif

        //
        // Chinese IME-NONIME toggle Hack for NT.
        //
        // On Win9x, we're using real IME as a dummy hKL of CH-Tips.
        // we can forward the hotkey request to Assembly here.
        //
        if ((pHotKey->dwId == IME_CHOTKEY_IME_NONIME_TOGGLE) ||
            (pHotKey->dwId == IME_THOTKEY_IME_NONIME_TOGGLE))
        {
            if (!IsOnNT())
            {
                PostThreadMessage(GetCurrentThreadId(), 
                                  g_msgPrivate, 
                                  TFPRIV_ACTIVATELANG,  
                                  0x0409);
        
            }
            else
            {
                ToggleCHImeNoIme(psfn, LANGIDFROMHKL(hKL), LANGIDFROMHKL(hKL));
            }
        }
    }

    //
    // WM_INPUTLANGCHNAGEREQUEST is being queued now.
    // Post another message to confirm the hKL.
    //
    PostThreadMessage(GetCurrentThreadId(),
                      g_msgPrivate,
                      TFPRIV_POSTINPUTCHANGEREQUEST,
                      0);
}

//+---------------------------------------------------------------------------
//
// _InsideLoaderLock
//
//+---------------------------------------------------------------------------

BOOL _InsideLoaderLock()
{
    return (NtCurrentTeb()->ClientId.UniqueThread ==
           ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);
}

//+---------------------------------------------------------------------------
//
// _OwnedLoaderLockBySomeone
//
//+---------------------------------------------------------------------------

BOOL _OwnedLoaderLockBySomeone()
{
    return ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread ? TRUE : FALSE;
}


LONG WINAPI CicExceptionFilter(struct _EXCEPTION_POINTERS *pExceptionInfo)
{
    (LONG)RtlUnhandledExceptionFilter(pExceptionInfo);
    return(EXCEPTION_EXECUTE_HANDLER);
}


//+---------------------------------------------------------------------------
//
// SysGetMsgProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK SysGetMsgProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HHOOK hHook;

    if (g_fDllProcessDetached)
    {
        hHook = s_hSysGetMsgHook;
        goto Exit;
    }

    _try 
    {
        hHook = GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64);

        if (nCode == HC_ACTION && (wParam & PM_REMOVE)) // bug 29656: sometimes w/ word wParam is set to PM_REMOVE | PM_NOYIELD
        {                                               // PM_NOYIELD is meaningless in win32 and sould be ignored
            _GetMsgHook(wParam, lParam);
        }
    }
    _except(CicExceptionFilter(GetExceptionInformation()))
    {
        Assert(0);
    }

Exit:
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

UINT _GetMsgHook(WPARAM wParam, LPARAM lParam)
{
    MSG *pmsg;
    UINT uMsg;
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;

    pmsg = (MSG *)lParam;
    uMsg = pmsg->message;

    switch (uMsg)
    {
        case WM_ACTIVATEAPP:
            TraceMsg(TF_GENERAL, "SysGetMsgProc: WM_ACTIVATEAPP %x %x", GetCurrentThreadId(), pmsg->wParam);
            if (pmsg->wParam)
            {
                OnForegroundChanged(NULL);
            }
            break;

        case WM_INPUTLANGCHANGEREQUEST:
            InputLangChangeHandler(pmsg);
            break;

        default:                
            if (uMsg == g_msgPrivate)
            {
                psfn = GetSYSTHREAD();
                if (psfn && psfn->pti)
                {
                    DWORD dwFlags = TLFlagFromTFPriv(pmsg->wParam);
                    psfn->pti->dwFlags &= ~dwFlags;
                }

                switch (LOWORD(pmsg->wParam))
                {
                    case TFPRIV_ONSETWINDOWFOCUS:
                        OnSetWindowFocusHandler(psfn, pmsg);
                        break;

                    case TFPRIV_ONKILLTHREADFOCUS:
                        //
                        // #497764
                        //
                        // PENJPN.DLL calls LoadImage() in ThreadFocusSink.
                        // But it needs loader lock because it calls 
                        // GetModuleFileName().
                        //
                        // So we can not call ThreadFocusSink while someone 
                        // holds the loader lock.
                        //
                        if (_OwnedLoaderLockBySomeone() && !_InsideLoaderLock())
                        {
                            Assert(0);
                            DWORD dwCurrentThread = GetCurrentThreadId();
                            if (GetSharedMemory()->dwFocusThread != dwCurrentThread)
                            {
                                PostThreadMessage(dwCurrentThread,
                                                  g_msgPrivate, 
                                                  TFPRIV_ONKILLTHREADFOCUS,
                                                  0);
                            }
                            break;
                        }
                        // fall through...
                    case TFPRIV_ONSETTHREADFOCUS:
                        if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                        {
                            ptim->_OnThreadFocus(pmsg->wParam == TFPRIV_ONSETTHREADFOCUS);
                        }
                        break;

                    case TFPRIV_UPDATEDISPATTR:
                        if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                        {
                            ptim->UpdateDispAttr();
                        }
                        break;

                    case TFPRIV_LANGCHANGE:
                        if (psfn && psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
                        {
                            BOOL bRet = ActivateNextAssembly((BOOL)(pmsg->lParam));
                        }
                        break;

                    case TFPRIV_KEYTIPCHANGE:
                        if (psfn && psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
                        {
                            ActivateNextKeyTip((BOOL)(pmsg->lParam));
                        }
                        break;

                    case TFPRIV_GLOBALCOMPARTMENTSYNC:
                        if (psfn)
                        {
                            if (psfn->_pGlobalCompMgr)
                                psfn->_pGlobalCompMgr->NotifyGlobalCompartmentChange((DWORD)(pmsg->lParam));
                        }
                        break;

                    case TFPRIV_SETMODALLBAR:
                        SetModalLBarId(HIWORD((DWORD)pmsg->lParam),
                                       LOWORD((DWORD)pmsg->lParam));
                        break;

                    case TFPRIV_RELEASEMODALLBAR:
                        SetModalLBarId(-1, -1);
                        break;

                    case TFPRIV_UPDATE_REG_KBDTOGGLE:
                        InitLangChangeHotKey();
                        break;

                    case TFPRIV_UPDATE_REG_IMX:
                        UpdateRegIMXHandler();
                        break;

                     case TFPRIV_REGISTEREDNEWLANGBAR:
//                        TraceMsg(TF_GENERAL, "TFPRIV_REGISTEREDNEWLANGBAR current thread %x", GetCurrentThreadId());
                        MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                        break;

                     case TFPRIV_SYSCOLORCHANGED:
                        if (psfn)
                            FlushIconIndex(psfn);

                        break;

                     case TFPRIV_LOCKREQ:
                        if (psfn)
                        {
                            psfn->_fLockRequestPosted = FALSE;
                            CInputContext::_PostponeLockRequestCallback(psfn, NULL);
                        }
                        break;

                     case TFPRIV_POSTINPUTCHANGEREQUEST:
                         PostInputChangeRequestHandler();
                         break;

                     case TFPRIV_LANGBARCLOSED:
                         LangBarClosed();
                         break;

                     case TFPRIV_ACTIVATELANG:
                         ActivateAssembly((LANGID)pmsg->lParam, ACTASM_NONE);
                         break;

                     case TFPRIV_ENABLE_MSAA:
                         if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                         {
                            ptim->_InitMSAA();
                         }
                         break;

                     case TFPRIV_DISABLE_MSAA:
                         if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                         {
                             ptim->_UninitMSAA();
                         }
                         break;
                }
            }
            else if ((uMsg == g_msgSetFocus) ||
                     (uMsg == g_msgThreadTerminate) ||
                     (uMsg == g_msgThreadItemChange) ||
                     (uMsg == g_msgShowFloating) ||
                     (uMsg == g_msgLBUpdate))
            {
                SetFocusNotifyHandler(uMsg, pmsg->wParam, pmsg->lParam);
            }
            else if (uMsg == g_msgLBarModal)
            {
                DispatchModalLBar((DWORD)pmsg->wParam, pmsg->lParam);
            }
#ifdef DEBUG
            else if ((uMsg == g_msgRpcSendReceive) ||
#ifdef POINTER_MARSHAL
                     (uMsg == g_msgPointerMarshal) ||
#endif //  POINTER_MARSHAL
                     (uMsg == g_msgThreadMarshal) ||
                     (uMsg == g_msgStubCleanUp)) 
            {
                 if (!pmsg->hwnd)
                 {
                     Assert(0);
                 }
            }
#endif


            break;
    }

    return 1;
}

//+---------------------------------------------------------------------------
//
// StartKanaCapsUpdateTimer
//
//+---------------------------------------------------------------------------

void StartKanaCapsUpdateTimer(SYSTHREAD *psfn)
{
    if (GetCurrentAssemblyLangId(psfn) != 0x0411)
        return;

    if (!IsWindow(psfn->hwndMarshal))
        return;

    SetTimer(psfn->hwndMarshal, MARSHALWND_TIMER_UPDATEKANACAPS, 300, NULL);
}

//+---------------------------------------------------------------------------
//
// KanaCapsUpdate
//
//+---------------------------------------------------------------------------

void KanaCapsUpdate(SYSTHREAD *psfn)
{
    static SHORT g_sCaps = 0;
    static SHORT g_sKana = 0;

    if (GetCurrentAssemblyLangId(psfn) != 0x0411)
        return;

    SHORT sCaps = g_sCaps;
    SHORT sKana = g_sKana;
    g_sCaps = GetKeyState(VK_CAPITAL) & 0x01;
    g_sKana = GetKeyState(VK_KANA) & 0x01;

    //
    // if psfn->fInitCapsKanaIndicator is true, it is enough to make a
    // notification only when status is changed.
    //
    if ((sCaps != g_sCaps) || 
        (sKana != g_sKana) ||
        !psfn->fInitCapsKanaIndicator)
    {
        MakeSetFocusNotify(g_msgLBUpdate, TF_LBU_CAPSKANAKEY, 
                           (LPARAM)((g_sCaps ? TF_LBUF_CAPS : 0) | 
                                    (g_sKana ? TF_LBUF_KANA : 0)));

        psfn->fInitCapsKanaIndicator = TRUE; 
    }
}

//+---------------------------------------------------------------------------
//
// CheckKoreanMouseClick
//
//+---------------------------------------------------------------------------

BOOL CheckKoreanMouseClick(SYSTHREAD *psfn, WPARAM wParam, LPARAM lParam)
{
    //
    //  check KeyUp and VK_PROCESSKEY
    //
    if (!(HIWORD(lParam) & KF_UP) || ((wParam & 0xff) != VK_PROCESSKEY))
        return FALSE;

    //
    //  if the current language is not 0x412, return.
    //
    if (GetCurrentAssemblyLangId(psfn) != 0x412)
        return FALSE;

    //
    //  If toolbar is clicked, we eat this VK_PROCESSKEY.
    //
    POINT pt;
    HWND hwnd;
    if (!GetCursorPos(&pt))
        return FALSE;

    hwnd = WindowFromPoint(pt);
    if (!hwnd)
        return FALSE;

    DWORD dwTimFlags = g_timlist.GetFlags(GetWindowThreadProcessId(hwnd, NULL));

    return (dwTimFlags & TLF_CTFMONPROCESS) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// IsJapaneseNonIMEVKKANJI
//
//+---------------------------------------------------------------------------

BOOL IsJapaneseNonIMEVKKANJI(WPARAM wParam)
{
    if ((wParam & 0xff) != VK_KANJI)
        return FALSE;

    HKL hkl = GetKeyboardLayout(0);
    if (IsPureIMEHKL(hkl))
        return FALSE;

    if (PRIMARYLANGID(LANGIDFROMHKL(hkl)) != LANG_JAPANESE)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsKoreanNonIMEVKJUNJA
//
//+---------------------------------------------------------------------------

BOOL IsKoreanNonIMEVKJUNJA(WPARAM wParam)
{
    if ((wParam & 0xff) != VK_JUNJA)
        return FALSE;

    HKL hkl = GetKeyboardLayout(0);
    if (IsPureIMEHKL(hkl))
        return FALSE;

    if (PRIMARYLANGID(LANGIDFROMHKL(hkl)) != LANG_KOREAN)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ThreadKeyboardProc
//
//+---------------------------------------------------------------------------

//
// Workaround for global keyboard hook
//
// On IA64 platform, Cicero install two global keyboard hooks which is 64bit and 32bit code.
// When any keyboard event occur on one apps instance, there two global keyboard hook procedure
// (SysKeyboardProc) called from win32k xxxCallHook2.
// If xxxCallHook2 detect different instance between current and receiver which is 64bit and 32bit, 
// this function notify by InterSendMsg.
//
LRESULT CALLBACK ThreadKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HHOOK hHook = NULL;
    UINT ret = 0;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn)
        hHook = psfn->hThreadKeyboardHook;

    if (g_fDllProcessDetached)
        goto Exit;

    if (nCode == HC_ACTION)
    {
        _try
        {
            ret = _KeyboardHook(wParam, lParam);
        }
        _except(CicExceptionFilter(GetExceptionInformation()))
        {
            Assert(0);
        }
    }

Exit:
    if ((ret == 0) && hHook)
        return CallNextHookEx(hHook, nCode, wParam, lParam);
    else
        return ret;
}

UINT _KeyboardHook(WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CThreadInputMgr *ptim = NULL;
    BOOL fEaten;
    HRESULT hr;

    if (psfn)
        ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // If we're in Modal Lang bar mode (menu is shown.), 
    // we want to eat keys.
    //
    if (HandleModalLBar((HIWORD(lParam) & KF_UP) ? WM_KEYUP : WM_KEYDOWN,
                         wParam, lParam))
        return 1;


    if (CheckKoreanMouseClick(psfn, wParam, lParam))
        return 1;

    UpdateModifiers(wParam, lParam);

    if ((HIWORD(lParam) & KF_UP))
        StartKanaCapsUpdateTimer(psfn);

    if (psfn)
    {
        if (CheckLangChangeHotKey(psfn, wParam, lParam))
        {
            //
            // Cic#4645 We need to forward this key envent ot the next hook.
            // mstsc.exe (TS client) needs it.
            //
            return 0;
            // goto Exit;
            // return 1;
        }
    }

    //
    // On CUAS, Imm32's Hotkey is simulated in ImmProcessKey
    //
    if (!psfn || !CtfImmIsCiceroStartedInThread())
        CheckImm32HotKey(wParam, lParam);

    if (HandleDBEKeys(wParam, lParam))
    {
        //
        // #519671
        //
        // If there is a focus DIM and the current asm item is not Japanese
        // TIP, we switch the assembly to Japanese TIP and open it.
        //
        // we do this after calling HandleDBEKeys(). So TIP's keyboard
        // event sink for VK_KANJI won't be called.
        //
        if (IsJapaneseNonIMEVKKANJI(wParam))
            ToggleJImeNoIme(psfn);

        //
        // Cic#4645 We need to forward this key envent ot the next hook.
        // mstsc.exe (TS client) needs it.
        //
        return 0;
        // goto Exit;
        // return 1;
    }

    if (ptim)
    {
        ptim->_NotifyKeyTraceEventSink(wParam, lParam);

        if (ptim->_ProcessHotKey(wParam, lParam, TSH_SYSHOTKEY, FALSE, FALSE))
            return 1;

        //
        // give AIMM the key events.
        //
        if (ptim->GetSysHookSink())
        {
            hr = ptim->GetSysHookSink()->OnSysKeyboardProc(wParam, lParam);
            if (hr == S_OK)
                return 1;
        }

        //
        // At last we can call KeyStrokemMgr.
        //
        if (!ptim->_AppWantsKeystrokes() &&
            ptim->_IsKeystrokeFeedEnabled() &&
            wParam != VK_PROCESSKEY &&
            (!(HIWORD(lParam) & (KF_MENUMODE | KF_ALTDOWN)) || IsKoreanNonIMEVKJUNJA(wParam)))
        {
            hr = (HIWORD(lParam) & KF_UP) ? ptim->KeyUp(wParam, lParam, &fEaten) :
                                            ptim->KeyDown(wParam, lParam, &fEaten);

            if (hr == S_OK && fEaten)
                return 1;
        }

        //
        // F10 SysKeyDown work arround.
        //
        // KSMGR won't be called on WM_SYSKEYDOWN/UP. So we foward F10
        // through AsynKeyHandler to support SyncLock in KS callback.
        //
        // we don't have to do this if there is no foreground keyboard tip.
        //
        if (((wParam & 0xff) == VK_F10) &&
            (ptim->GetForegroundKeyboardTip() != TF_INVALID_GUIDATOM))
        {
            fEaten = FALSE;
            if (ptim->_AsyncKeyHandler(wParam, 
                                       lParam, 
                                       TIM_AKH_SIMULATEKEYMSGS, 
                                       &fEaten) && fEaten)
                return 1;
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
// ThreadMouseProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK ThreadMouseProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HHOOK hHook = NULL;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn)
        hHook = psfn->hThreadMouseHook;

    if (g_fDllProcessDetached)
        goto Exit;

    if (nCode == HC_ACTION)
    {
        BOOL bRet = FALSE;
        if ((wParam  == WM_MOUSEMOVE) || (wParam == WM_NCMOUSEMOVE))
            goto Exit;

        _try
        {
            bRet = HandleModalLBar((UINT)wParam, 0,
                                MAKELPARAM(((MOUSEHOOKSTRUCT *)lParam)->pt.x,
                                           ((MOUSEHOOKSTRUCT *)lParam)->pt.y));
        }
        _except(CicExceptionFilter(GetExceptionInformation()))
        {
            Assert(0);
        }

        if (bRet)
            return 1;
    }

Exit:
    if (hHook)
        return CallNextHookEx(hHook, nCode, wParam, lParam);
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
// UninitHooks
//
//+---------------------------------------------------------------------------

void UninitHooks()
{
    HHOOK _h;

    if ( (_h = GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64)) != NULL)
    {
        UnhookWindowsHookEx(_h);
        GetSharedMemory()->hSysShellHook.SetHandle(g_bOnWow64, NULL);
    }

    if ( (_h = GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64)) != NULL)
    {
        UnhookWindowsHookEx(_h);
        GetSharedMemory()->hSysCBTHook.SetHandle(g_bOnWow64, NULL);
    }

    if ( (_h = GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64)) != NULL)
    {
        UnhookWindowsHookEx(_h);
        GetSharedMemory()->hSysGetMsgHook.SetHandle(g_bOnWow64, NULL);
    }
}

//+---------------------------------------------------------------------------
//
// InitHooks
//
//+---------------------------------------------------------------------------

void InitHooks()
{
    Assert(! GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64));
    GetSharedMemory()->hSysShellHook.SetHandle(g_bOnWow64, SetWindowsHookEx(WH_SHELL, SysShellProc, g_hInst, 0));

    //
    // nb:     we could move GetMsgHook to per-thread hook if we get rid of
    //         TFPRIV_MARSHALINTERFACE for non-cicero apps.
    //         TFPRIV_MARSHALINTERFACE is necesary because Tipbar does not
    //         know if the target thread has TIM. If there is no TIP or
    //         the GetMsgHook, the tipbar waits until timeout.
    //         To solve this problem, we must have TIM's thread list
    //         in shared mem. Maybe we should do this.
    //
    Assert(! GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64));
    if (IsOnNT())
    {
        // we need a W hook on NT to work-around an os dbcs/unicode translation bug (4243)
        GetSharedMemory()->hSysGetMsgHook.SetHandle(g_bOnWow64, SetWindowsHookExW(WH_GETMESSAGE, SysGetMsgProc, g_hInst, 0));
    }
    else
    {
        GetSharedMemory()->hSysGetMsgHook.SetHandle(g_bOnWow64, SetWindowsHookExA(WH_GETMESSAGE, SysGetMsgProc, g_hInst, 0));
    }

    Assert(! GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64));
    GetSharedMemory()->hSysCBTHook.SetHandle(g_bOnWow64, SetWindowsHookEx(WH_CBT, SysCBTProc, g_hInst, 0));

    InitStaticHooks();
}

//+---------------------------------------------------------------------------
//
// InitThreadHooks
//
//+---------------------------------------------------------------------------

void InitThreadHook(DWORD dwThreadId)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return;

    if (psfn->hThreadKeyboardHook && psfn->hThreadMouseHook)
        return;

    PVOID pvLdrLockCookie = NULL;
    ULONG ulLockState = 0;

    // make sure that no one else owns the loader lock because we
    //  could otherwise deadlock
    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY, &ulLockState, 
                      &pvLdrLockCookie);
    if (ulLockState == LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED)
    {
        __try {
            if (!psfn->hThreadKeyboardHook)
            {
                //
                // Install Local keyboard hook with hMod value.
                // win32k mantain hMod ref count even another global hook 
                // detached.
                //
                psfn->hThreadKeyboardHook = SetWindowsHookEx(WH_KEYBOARD, ThreadKeyboardProc, g_hInst, dwThreadId);

            }
            if (!psfn->hThreadMouseHook)
            {
                //
                // Install Local keyboard hook with hMod value.
                // win32k mantain hMod ref count even another global hook 
                // detached.
                //
                psfn->hThreadMouseHook = SetWindowsHookEx(WH_MOUSE, ThreadMouseProc, g_hInst, dwThreadId);
            }

        }
        _except(CicExceptionFilter(GetExceptionInformation()))
        {
        }
        LdrUnlockLoaderLock(0, pvLdrLockCookie);
    }

}

//+---------------------------------------------------------------------------
//
// UninitThreadHooks
//
//+---------------------------------------------------------------------------

void UninitThreadHooks(SYSTHREAD *psfn)
{
    if (!psfn)
        return;

    if (psfn->hThreadKeyboardHook)
    {
        UnhookWindowsHookEx(psfn->hThreadKeyboardHook);
        psfn->hThreadKeyboardHook = NULL;
    }
    if (psfn->hThreadMouseHook)
    {
        UnhookWindowsHookEx(psfn->hThreadMouseHook);
        psfn->hThreadMouseHook = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// TF_InitSystem
//
// Called by ctfmon on a single thread.
//+---------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_InitSystem(void)
{
    SYSTHREAD *psfn;

    g_fCTFMONProcess = TRUE;
    g_timlist.Init(TRUE);
    if (psfn = GetSYSTHREAD())
    {
        g_gcomplist.Init(psfn);

        EnsureAsmCacheFileMap();
        EnsureAssemblyList(psfn);
        psfn->fCTFMON = TRUE;
    }

    InitHooks();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// TF_UninitSystem
//
// Called by ctfmon on a single thread.
//+---------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_UninitSystem(void)
{
    CThreadMarshalWnd::DestroyAll();

    UninitAsmCacheFileMap();

    g_timlist.Uninit();

    SYSTHREAD *psfn = FindSYSTHREAD();
    g_gcomplist.Uninit(psfn);

    UninitHooks();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// TF_InitThreadSystem
//
//+---------------------------------------------------------------------------

BOOL TF_InitThreadSystem(void)
{
    DWORD dwThreadId = GetCurrentThreadId();

    //
    // we should not see the timlist entry of this thread. This thread
    // is starting now.
    // the thread with same ID was terminated incorrectly so there was no
    // chance to clean timlist up.
    //

    if (g_timlist.IsThreadId(dwThreadId))
    {
        g_timlist.RemoveThread(dwThreadId);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// TF_UninitThreadSystem
//
//+---------------------------------------------------------------------------

BOOL TF_UninitThreadSystem(void)
{
    SYSTHREAD *psfn = FindSYSTHREAD();

    g_gcomplist.Uninit(psfn);

    FreeSYSTHREAD();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UninitProcess()
//
//+---------------------------------------------------------------------------

void UninitProcess()
{
    DWORD dwProcessId = GetCurrentProcessId();

    //
    // FreeSYSTHREAD2() removes psfn from PtrArray.
    //
    if (g_rgSysThread)
    {

        while(g_rgSysThread->Count())
        {
            SYSTHREAD *psfn = g_rgSysThread->Get(0);
            if (psfn)
                FreeSYSTHREAD2(psfn);
        }
        delete g_rgSysThread;
        g_rgSysThread = NULL;

    }

    //
    // remove all timlist entries for the current process.
    //
    g_timlist.RemoveProcess(dwProcessId);


    CCategoryMgr::UninitGlobal();
}

//+---------------------------------------------------------------------------
//
// InitAppCompatFlags
//
//+---------------------------------------------------------------------------

BOOL InitAppCompatFlags()
{
    TCHAR szAppCompatKey[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    if (::GetModuleFileName(NULL,            // handle to module
                            szFileName,      // file name of module
                            sizeof(szFileName)/sizeof(TCHAR)) == 0)
        return FALSE;

    TCHAR  szModuleName[MAX_PATH];
    LPTSTR pszFilePart = NULL;
    ::GetFullPathName(szFileName,            // file name
                      sizeof(szModuleName)/sizeof(TCHAR),
                      szModuleName,          // path buffer
                      &pszFilePart);         // address of file name in path

    if (pszFilePart == NULL)
        return FALSE;


    StringCopyArray(szAppCompatKey, c_szAppCompat);
    StringCatArray(szAppCompatKey, pszFilePart);
    CMyRegKey key;
    if (key.Open(HKEY_LOCAL_MACHINE, szAppCompatKey, KEY_READ) == S_OK)
    {
        DWORD dw;
        if (key.QueryValue(dw, c_szCompatibility) == S_OK)
            g_dwAppCompatibility = dw;
    }

    //
    // Ciero #4605
    //
    // hack for 16bit apps on Win9x platform.
    // all 16bit apps shrare one PPI (process info) and this means that
    // there is one main thread for WaitForInputIdle() for all 16 bit apps.
    // so we stop using WaitForInputIdle().
    //
    if (!IsOnNT())
    {
        if (!lstrcmpi(pszFilePart, "kernel32.dll"))
            g_dwAppCompatibility |= CIC_COMPAT_NOWAITFORINPUTIDLEONWIN9X;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// InitCUASFlag
//
//+---------------------------------------------------------------------------

void InitCUASFlag()
{
    CMyRegKey key;
    CMyRegKey keyIMM;
    if (key.Open(HKEY_LOCAL_MACHINE, c_szCtfShared, KEY_READ) == S_OK)
    {
        DWORD dw;
        if (key.QueryValue(dw, c_szCUAS) == S_OK)
            g_fCUAS = dw ? TRUE : FALSE;
    }

    g_szCUASImeFile[0] = '\0';
    if (g_fCUAS)
    {
        if (keyIMM.Open(HKEY_LOCAL_MACHINE, c_szIMMKey, KEY_READ) == S_OK)
        {
            TCHAR szCUASImeFile[16];
            if (keyIMM.QueryValueCch(szCUASImeFile, c_szCUASIMEFile, ARRAYSIZE(szCUASImeFile)) == S_OK)
                lstrcpy(g_szCUASImeFile, szCUASImeFile);
        }
    }

}

//+---------------------------------------------------------------------------
//
// TF_DllDetachInOther
//
//+---------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_DllDetachInOther()
{
    SYSTHREAD *psfn = FindSYSTHREAD();

    if (psfn)
        psfn->fCUASDllDetachInOtherOrMe = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSCTF"
#ifndef _WIN64
#define SZ_MODULE       "MSCTF  "
#else
#define SZ_MODULE       "MSCTF64"
#endif
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\csecattr.cpp ===
//
// csecattr.cpp
//
#include "private.h"
#include "osver.h"
#include "csecattr.h"

extern TCHAR g_szUserSidString[];
extern BOOL g_fUserSidString;
extern BOOL InitUserSidString();


//----------------------------------------------------------------------------
//
// CreateProperSecurityDescriptor
//
//----------------------------------------------------------------------------

BOOL CreateProperSecurityDescriptor(HANDLE hToken, PSECURITY_DESCRIPTOR * ppsdec)
{
    PSECURITY_DESCRIPTOR psdec = NULL;
    PSECURITY_DESCRIPTOR psdAbs = NULL;
    DWORD dwSizeSdec = 0;
    BOOL bRet = FALSE;
    TCHAR strDesc[MAX_PATH];

    if (!InitUserSidString())
        return FALSE;

    //construct the descriptor as "O:(user SID)G:DU:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;(user SID))"
    lstrcpy(strDesc, "O:");
    lstrcat(strDesc, g_szUserSidString);
    lstrcat(strDesc, "D:(A;;GA;;;BA)(A;;GA;;;RC)(A;;GA;;;SY)(A;;GA;;;");
    lstrcat(strDesc, g_szUserSidString);
    lstrcat(strDesc, ")");

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(strDesc,
        SDDL_REVISION_1,
        &psdec,
        &dwSizeSdec))
    {
        *ppsdec = psdec;
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\dam.cpp ===
//
// dam.cpp
//

#include "private.h"
#include "tlhelp32.h"
#include "globals.h"
#include "dam.h"
#include "tim.h"
#include "thdutil.h"
#include "timlist.h"

// get CLSID_STRLEN
#include "regsvr.h"

/* ff4619e8-ea5e-43e5-b308-11cd26ab6b3a */
const IID IID_CDisplayAttributeMgr = { 0xff4619e8, 0xea5e, 0x43e5, {0xb3, 0x08, 0x11, 0xcd, 0x26, 0xab, 0x6b, 0x3a} };

const TCHAR c_szDAMCacheKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\DisplayAttributeCache\\");
const TCHAR c_szDAMNumValue[] = TEXT("CheckNum");

CDispAttrGuidCache *g_pDispAttrGuidCache = NULL;

//
// from aimm1.2\win32\aimmdap.cpp
//
/* 503286E2-5D2A-4D3D-B0D1-EE50D843B79D */
const CLSID CLSID_CAImmDAP = {
    0x503286E2,
    0x5D2A,
    0x4D3D,
    {0xB0, 0xD1, 0xEE, 0x50, 0xD8, 0x43, 0xB7, 0x9D}
  };


DBG_ID_INSTANCE(CDisplayAttributeMgr);
DBG_ID_INSTANCE(CEnumDisplayAttributeInfo);

//////////////////////////////////////////////////////////////////////////////
//
// CDispAttrGuidCache
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// StaticUnInit
//
// Caller must hold mutex.
//----------------------------------------------------------------------------

void CDispAttrGuidCache::StaticUnInit()
{
    Assert(ISINDLLMAIN()); // for mutex

    if (g_pDispAttrGuidCache)
        delete g_pDispAttrGuidCache;
     g_pDispAttrGuidCache = NULL;
}


//+---------------------------------------------------------------------------
//
// StaticInit
//
//----------------------------------------------------------------------------

void CDispAttrGuidCache::StaticInit()
{
    CicEnterCriticalSection(g_cs);

    if (!g_pDispAttrGuidCache)
    {
        g_pDispAttrGuidCache = new CDispAttrGuidCache();

        if (g_pDispAttrGuidCache)
            g_pDispAttrGuidCache->Load();
    }

    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Add
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::Add(REFCLSID clsid, REFGUID guid)
{
    BOOL bRet = FALSE;
    TfGuidAtom gaGuid;
    TfGuidAtom gaClsid;

    if (FAILED(MyRegisterGUID(clsid, &gaClsid)))
        return bRet;

    if (FAILED(MyRegisterGUID(guid, &gaGuid)))
        return bRet;
    
    CicEnterCriticalSection(g_cs);

    if (!Get(gaGuid, NULL))
    {
        DISPATTRGUID *pGuid;

        if (!_rgDispAttrGuid.Insert(0, 1))
        {
            goto Exit;
        }

        pGuid = _rgDispAttrGuid.GetPtr(0);
        pGuid->clsid = clsid;
        pGuid->gaClsid = gaClsid;
        pGuid->guid = guid;
        pGuid->gaGuid = gaGuid;
    }
    bRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CDispAttrGuidCache::Remove(TfGuidAtom guidatom)
{
    int nCnt = _rgDispAttrGuid.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        DISPATTRGUID *pGuid = _rgDispAttrGuid.GetPtr(i);
        if (pGuid->gaGuid == guidatom)
        {
            _rgDispAttrGuid.Remove(i, 1);
            return;
        }
    }
}

//+---------------------------------------------------------------------------
//
// RemoveClsid
//
//----------------------------------------------------------------------------

void CDispAttrGuidCache::RemoveClsid(TfGuidAtom guidatom)
{
    int nCnt = _rgDispAttrGuid.Count();
    int i;

    i = 0;
    while (i < nCnt)
    {
        DISPATTRGUID *pGuid = _rgDispAttrGuid.GetPtr(i);
        if (pGuid->gaClsid == guidatom)
        {
            _rgDispAttrGuid.Remove(i, 1);
            nCnt--;
            continue;
        }
        i++;
    }
}

//+---------------------------------------------------------------------------
//
// Get
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::Get(TfGuidAtom guidatom, DISPATTRGUID *pDisp)
{
    BOOL bRet;
    CicEnterCriticalSection(g_cs);
    bRet = InternalGet(guidatom, pDisp);
    CicLeaveCriticalSection(g_cs);
    return bRet;
}

//+---------------------------------------------------------------------------
//
// InternalGet
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::InternalGet(TfGuidAtom guidatom, DISPATTRGUID *pDisp)
{
    int nCnt;
    int i;
    BOOL bRet = FALSE;

    nCnt = _rgDispAttrGuid.Count();
    DISPATTRGUID *pGuid = _rgDispAttrGuid.GetPtr(0);

    for (i = 0; i < nCnt; i++)
    {
        if (pGuid->gaGuid == guidatom)
        {
            if (pDisp)
                *pDisp = *pGuid;
            bRet = TRUE;
            goto Exit;
        }
        pGuid++;
    }
Exit:
    return bRet;
}

//+---------------------------------------------------------------------------
//
// IsClsid
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::IsClsid(TfGuidAtom gaClsid)
{
    BOOL bRet = FALSE;
    int nCnt;
    int i;
    DISPATTRGUID *pGuid;

    CicEnterCriticalSection(g_cs);

    pGuid = _rgDispAttrGuid.GetPtr(0);
    nCnt = _rgDispAttrGuid.Count();

    for (i = 0; i < nCnt; i++)
    {
        if (pGuid->gaClsid == gaClsid)
        {
            bRet = TRUE;
            break;
        }
        pGuid++;
    }

    CicLeaveCriticalSection(g_cs);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// Save
//
//----------------------------------------------------------------------------

HRESULT CDispAttrGuidCache::Save()
{
    DWORD dw;
    HKEY hKeyDAM;
    DISPATTRGUID *pDAG;
    int nCnt;

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDAMCacheKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }
    
    nCnt = _rgDispAttrGuid.Count();

    if (nCnt)
    {
       pDAG = _rgDispAttrGuid.GetPtr(0);

       RegSetValueEx(hKeyDAM, NULL, 0, REG_BINARY, 
                     (CONST BYTE *)pDAG, sizeof(DISPATTRGUID) * nCnt);

       RegSetValueEx(hKeyDAM, c_szDAMNumValue, 0, REG_DWORD,
                        (LPBYTE)&nCnt, sizeof(DWORD));
    }
    else
    {
       RegDeleteValue(hKeyDAM, NULL);
       RegDeleteValue(hKeyDAM, c_szDAMNumValue);
    }
    
    RegCloseKey(hKeyDAM);


    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Load
//
//----------------------------------------------------------------------------

HRESULT CDispAttrGuidCache::Load()
{
    HKEY hKeyDAM;
    HRESULT hr = E_FAIL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDAMCacheKey, 0,
                     KEY_READ, &hKeyDAM) != ERROR_SUCCESS)
    {
        return hr;
    }

    
    Assert(_rgDispAttrGuid.Count() == 0);

    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwCntReg = 0;

    //
    // Issue: should be removed before release.
    // we changed the size of structre so old chace does not match with
    // new one. Check the size of structure.
    //
    if (RegQueryValueEx(hKeyDAM, c_szDAMNumValue, 0, &dwType, 
                        (LPBYTE)&dwCntReg, &dwSize) != ERROR_SUCCESS)
        dwCntReg = 0;

    dwType = REG_BINARY;

    if (RegQueryValueEx(hKeyDAM, NULL, 0, &dwType, 
                        NULL, &dwSize) == ERROR_SUCCESS)
    {
         DWORD i;
         DWORD dwCnt = dwSize / sizeof(DISPATTRGUID);

         if (dwCnt != dwCntReg)
             goto Exit;

         _rgDispAttrGuid.Insert(0, dwCnt);
         DISPATTRGUID *pDAG = _rgDispAttrGuid.GetPtr(0);
         RegQueryValueEx(hKeyDAM, NULL, 0, &dwType, (BYTE *)pDAG, &dwSize);

         for (i = 0; i < dwCnt; i++)
         {
              if (FAILED(MyRegisterGUID(pDAG[i].clsid, &pDAG[i].gaClsid)))
                  goto Exit;

              if (FAILED(MyRegisterGUID(pDAG[i].guid, &pDAG[i].gaGuid)))
                  goto Exit;
         }
    }
    
    hr = S_OK;
Exit:
    RegCloseKey(hKeyDAM);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDisplayAttributeMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CDisplayAttributeMgr::CDisplayAttributeMgr()
{
    Dbg_MemSetThisNameID(TEXT("CDisplayAttributeMgr"));
    _SetThis(this);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CDisplayAttributeMgr::~CDisplayAttributeMgr()
{
    int nCnt = _rgDaPrv.Count();

    if (nCnt)
    {
        DAPROVIDERMAP *pDaPrv;
        pDaPrv = _rgDaPrv.GetPtr(0);

        while(nCnt--)
        {
            pDaPrv->pPrv->Release();
            pDaPrv++;
        }
    }
    _SetThis(NULL); // clear out singleton tls
}

//----------------------------------------------------------------------------
//
// OnUndateinfo
//
//  Use kernel32 or ntdll directly to enumerate all threads, because
//  we don't have global TIM list. 
//
//----------------------------------------------------------------------------


HRESULT CDisplayAttributeMgr::OnUpdateInfo()
{
    PostTimListMessage(TLF_TIMACTIVE,
                       0,
                       g_msgPrivate, 
                       TFPRIV_UPDATEDISPATTR, 
                       0);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// EnumThreadProc
//
//----------------------------------------------------------------------------

BOOL CDisplayAttributeMgr::EnumThreadProc(DWORD dwThread, DWORD dwProcessId, void *pv)
{
    PostThreadMessage(dwThread, g_msgPrivate, TFPRIV_UPDATEDISPATTR, 0);
    return FALSE;
}

//----------------------------------------------------------------------------
//
// EnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum)
{
    CEnumDisplayAttributeInfo *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    pEnum = new CEnumDisplayAttributeInfo();

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (pEnum->Init())
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    return pEnum ? S_OK : E_FAIL;
}

//----------------------------------------------------------------------------
//
// GetDisplayAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo, CLSID *pclsid)
{
    CLSID clsid;
    ITfDisplayAttributeProvider *pProvider;
    HRESULT hr = E_FAIL;

    StaticCacheInit();

    if (ppInfo)
        *ppInfo = NULL;

    if (g_pDispAttrGuidCache)
    {
        DISPATTRGUID dag;
        TfGuidAtom gaGuid;

        if (FAILED(MyRegisterGUID(guid, &gaGuid)))
            return hr;

        if (g_pDispAttrGuidCache->Get(gaGuid, &dag))
        {
            if (ppInfo)
            {
                DAPROVIDERMAP *pDaPrv;
                int i;
                int nCnt = _rgDaPrv.Count();
                BOOL bFound = FALSE;

                for (i = 0; i < nCnt; i++)
                {
                    pDaPrv = _rgDaPrv.GetPtr(i);
                    if (pDaPrv->gaClsid == dag.gaClsid)
                    {
                        Assert(pDaPrv->pPrv);
                        hr = pDaPrv->pPrv->GetDisplayAttributeInfo(guid, ppInfo);
                        bFound = TRUE;
                        break;
                    }
                }

                if (!bFound &&
                    SUCCEEDED(CoCreateInstance(dag.clsid,
                                               NULL, 
                                               CLSCTX_INPROC_SERVER, 
                                               IID_ITfDisplayAttributeProvider, 
                                               (void**)&pProvider)))
                {
    
                    hr = pProvider->GetDisplayAttributeInfo(guid, ppInfo);

                    if (_rgDaPrv.Insert(nCnt, 1))
                    {
                        pDaPrv = _rgDaPrv.GetPtr(nCnt);
                        pDaPrv->gaClsid = dag.gaClsid;
                        pDaPrv->pPrv = pProvider;
                    }
                    else
                        pProvider->Release();
                }
            }
            else
            {
                hr = S_OK;
            }
    
            if (SUCCEEDED(hr))
            {
                if (pclsid)
                    *pclsid = dag.clsid;
                return hr;
            }

            //
            // someone removed DisplayAttribute Info. So we clear the cache.
            //
            g_pDispAttrGuidCache->Clear();
        }
    }


    IEnumGUID *pEnumGUID;

    if (FAILED(MyEnumItemsInCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER, &pEnumGUID)))
        return E_FAIL;

    DWORD dwIndex = 0;
    BOOL fFound = FALSE;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();

    if (ptim == NULL)
        goto Exit;

    while (!fFound &&  (pEnumGUID->Next(1, &clsid, NULL) == S_OK))
    {
        if (!IsEqualCLSID(clsid, CLSID_CAImmDAP) &&
            (ptim->_IsActiveInputProcessor(clsid) != S_OK))
            continue;

        //
        // Issue: 
        //
        // we may want to load only providers that are enabled in this 
        // thread. Use CIMEList to check if tips is enabled.
        //
        if (SUCCEEDED(CoCreateInstance(clsid,
                                       NULL, 
                                       CLSCTX_INPROC_SERVER, 
                                       IID_ITfDisplayAttributeProvider, 
                                       (void**)&pProvider)))
        {
            IEnumTfDisplayAttributeInfo *pEnumDAI;

            if (SUCCEEDED(pProvider->EnumDisplayAttributeInfo(&pEnumDAI)))
            {
                ITfDisplayAttributeInfo *pInfo;

                while (pEnumDAI->Next(1, &pInfo, NULL) == S_OK)
                {
                    GUID guidTemp;
                    if (SUCCEEDED(pInfo->GetGUID(&guidTemp)))
                    { 
                        if (g_pDispAttrGuidCache)
                            g_pDispAttrGuidCache->Add(clsid, guidTemp);

                        if (IsEqualGUID(guidTemp, guid))
                        {

                            if (ppInfo)
                                *ppInfo = pInfo;
                            if (pclsid)
                                *pclsid = clsid;

                            fFound = TRUE;
                            hr = S_OK;
                            break;
                        }
                    }
                    pInfo->Release();
                }
                pEnumDAI->Release();
            }

            pProvider->Release();
        }

    }

Exit:
    pEnumGUID->Release();

    if (g_pDispAttrGuidCache)
        g_pDispAttrGuidCache->Save();

    return hr;
}

//----------------------------------------------------------------------------
//
// RegisterGUID
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::_RegisterGUID(const TCHAR *pszKey, REFGUID rguid, WCHAR *pszDesc, ULONG cchDesc)
{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(rguid, achGuid);

    if (RegCreateKeyEx(hKeyDAM, achGuid, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyItem, 
                       &dw) == ERROR_SUCCESS)
    {
        int cchDescA = cchDesc * sizeof(WCHAR) + 1;
        char *pszDescA = new char[cchDescA];
        if (pszDescA)
        {
            cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                           pszDesc, wcslen(pszDesc), 
                                           pszDescA, cchDescA, 
                                           NULL, NULL);
            *(pszDescA + cchDescA) = L'\0';

            RegSetValueEx(hKeyItem, TEXT("Description"), 0, REG_SZ, 
                          (CONST BYTE *)pszDescA, cchDescA);

            delete pszDescA;
        }
        RegCloseKey(hKeyItem);
    }
    RegCloseKey(hKeyDAM);


    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterGUID
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::_UnregisterGUID(const TCHAR *pszKey, REFGUID rguid)
{
    DWORD dw;
    HKEY hKeyDAM;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,  pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(rguid, achGuid);

    RegDeleteKey(hKeyDAM, achGuid);

    RegCloseKey(hKeyDAM);


    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumDisplayAttributeInfo
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::CEnumDisplayAttributeInfo()
{
    Dbg_MemSetThisNameID(TEXT("CEnumDisplayAttributeInfo"));
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CEnumDisplayAttributeInfo::Init()
{
    IEnumGUID *pEnumGUID;
    CLSID clsid;
    ULONG uDAMax;
    BOOL fRet;

    StaticCacheInit();

    if (FAILED(MyEnumItemsInCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER, &pEnumGUID)))
        return FALSE;

    fRet = FALSE;

    if ((_prgUnk = SUA_Alloc(1)) == NULL)
        goto Exit;

    _prgUnk->cRef = 1;
    _prgUnk->cUnk = 0;
    uDAMax = 1;

    while (pEnumGUID->Next(1, &clsid, NULL) == S_OK)
    {
        ITfDisplayAttributeProvider *pProvider;
        //
        // Issue: 
        //
        // we may want to load only providers that are enabled in this 
        // thread. Use CIMEList to check if tips is enabled.
        //
        if (SUCCEEDED(CoCreateInstance(clsid,
                                       NULL, 
                                       CLSCTX_INPROC_SERVER, 
                                       IID_ITfDisplayAttributeProvider, 
                                       (void**)&pProvider)))
        {
            IEnumTfDisplayAttributeInfo *pEnum;
            if (SUCCEEDED(pProvider->EnumDisplayAttributeInfo(&pEnum)))
            {
                ITfDisplayAttributeInfo *pInfo;

                while (pEnum->Next(1, &pInfo, NULL) == S_OK)
                {
                    GUID guidTemp;
                    if (SUCCEEDED(pInfo->GetGUID(&guidTemp)))
                    { 
                        if (g_pDispAttrGuidCache)
                            g_pDispAttrGuidCache->Add(clsid, guidTemp);
                    }

                    if (_prgUnk->cUnk >= uDAMax)
                    {
                        // need a bigger array
                        uDAMax *= 2;
                        if (!SUA_ReAlloc(&_prgUnk, uDAMax))
                        {
                            pInfo->Release();
                            SUA_Release(_prgUnk);
                            _prgUnk = NULL;
                            goto Exit;
                        }
                    }

                    _prgUnk->rgUnk[_prgUnk->cUnk++] = pInfo;
                }

                pEnum->Release();
            }

            pProvider->Release();
        }
    }

    if (uDAMax > _prgUnk->cUnk)
    {
        // free up unused mem
        SUA_ReAlloc(&_prgUnk, _prgUnk->cUnk);
    }

    fRet = TRUE;

Exit:
    pEnumGUID->Release();

    if (g_pDispAttrGuidCache)
        g_pDispAttrGuidCache->Save();

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\delay.cpp ===
//
// delay.cpp
//
// Delay load imported functions for perf.
//

#include "private.h"
#include "globals.h"

extern "C" BOOL WINAPI ImmSetHotKey(IN DWORD, IN UINT, IN UINT, IN HKL);

CCicCriticalSectionStatic g_csDelayLoad;

FARPROC GetFn(HINSTANCE *phInst, TCHAR *pchLib, TCHAR *pchFunc, BOOL fCheckModule)
{
    Assert(g_dwThreadDllMain != GetCurrentThreadId());

    if (*phInst == 0)
    {
#ifdef DEBUG
        if (!IsOnFE() && !IsOnNT5() && lstrcmp(pchLib, TEXT("imm32.dll")) == 0)
        {
            // what in the heck are we doing loading imm32 on a non-fe system?!
            Assert(0);
        }
#endif
        if (fCheckModule)
        {
            Assert(0);
            return NULL;
        }

        EnterCriticalSection(g_csDelayLoad);

        // need to check again after entering crit sec
        if (*phInst == 0)
        {
            *phInst = LoadSystemLibrary(pchLib);
        }

        LeaveCriticalSection(g_csDelayLoad);

        if (*phInst == 0)
        {
            Assert(0);
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}

#define DELAYLOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule)   \
_RetType _CallConv _FuncName _Args1                                           \
{                                                                             \
    static FARPROC pfn = NULL;                                                \
                                                                              \
    if (pfn == NULL || _hInst == NULL)                                        \
    {                                                                         \
        pfn = GetFn(&_hInst, #_DllName, #_FuncName, _CheckModule);            \
                                                                              \
        if (pfn == NULL)                                                      \
        {                                                                     \
            Assert(0);                                                        \
            return (_RetType) _ErrVal;                                        \
        }                                                                     \
    }                                                                         \
                                                                              \
    return ((_RetType (_CallConv *)_Args1) (pfn)) _Args2;                     \
}

#define INIT_LOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule)   \
static FARPROC g_pfn_ ## _FuncName ##  = NULL;                                \
void Init_ ## _FuncName ##()                                                  \
{                                                                             \
    if (g_pfn_ ##_FuncName ## == NULL )                                       \
    {                                                                         \
        g_pfn_ ##_FuncName ## = GetProcAddress(_hInst, #_FuncName);           \
                                                                              \
    }                                                                         \
                                                                              \
}                                                                             \
_RetType _CallConv _FuncName _Args1                                           \
{                                                                             \
                                                                              \
    if (!g_pfn_ ## _FuncName ##)                                              \
            return (_RetType) _ErrVal;                                        \
    return ((_RetType (_CallConv *)_Args1) (g_pfn_ ## _FuncName ##)) _Args2;  \
}

//
// imm32.dll
//

HINSTANCE g_hImm32 = 0;

#define IMM32LOAD(_FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule) \
    INIT_LOAD(g_hImm32, imm32.dll, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule)


IMM32LOAD( CtfImmCoUninitialize, (void), (), void, FALSE, TRUE)
IMM32LOAD( CtfImmLastEnabledWndDestroy, (LPARAM lParam), (lParam), HRESULT, S_FALSE, TRUE)
IMM32LOAD( CtfImmSetCiceroStartInThread, (BOOL fSet), (fSet), HRESULT, S_FALSE, TRUE)
IMM32LOAD( CtfImmIsCiceroStartedInThread, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmIsCiceroEnabled, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmIsTextFrameServiceDisabled, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmEnterCoInitCountSkipMode, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmLeaveCoInitCountSkipMode, (void), (), BOOL, FALSE, TRUE)

IMM32LOAD( ImmGetDefaultIMEWnd, (HWND hWnd), (hWnd), HWND, 0, FALSE)
IMM32LOAD( ImmReleaseContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmNotifyIME, (HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue), (hIMC, dwAction, dwIndex, dwValue), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetConversionStatus, (HIMC hIMC, DWORD dw1, DWORD dw2), (hIMC, dw1, dw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetConversionStatus, (HIMC hIMC, LPDWORD pdw1, LPDWORD pdw2), (hIMC, pdw1, pdw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetProperty, (HKL hKL, DWORD dw), (hKL, dw), DWORD, 0, FALSE)
IMM32LOAD( ImmGetOpenStatus, (HIMC hIMC), (hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetContext, (HWND hWnd), (hWnd), HIMC, 0, FALSE)
IMM32LOAD( ImmSetOpenStatus, (HIMC hIMC, BOOL f), (hIMC, f), BOOL, FALSE, FALSE)
IMM32LOAD( ImmInstallIMEA, (LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText), (lpszIMEFileName, lpszLayoutText), HKL, 0, FALSE)
IMM32LOAD( ImmGetDescriptionA, (HKL hKL, LPSTR psz, UINT uBufLen), (hKL, psz, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetDescriptionW, (HKL hKL, LPWSTR psz, UINT uBufLen), (hKL, psz, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameA, (HKL hKL, LPSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameW, (HKL hKL, LPWSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmSetHotKey, (DWORD dwId, UINT uModifiers, UINT uVkey, HKL hkl), (dwId, uModifiers, uVkey, hkl), BOOL, FALSE, FALSE)

#ifdef UNUSED_IMM32_APIS

IMM32LOAD( ImmCreateIMCC, (DWORD dw), (dw), HIMCC, FALSE, FALSE)
IMM32LOAD( ImmIsUIMessageA, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE, FALSE)
IMM32LOAD( ImmIsUIMessageW, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetVirtualKey, (HWND hWnd), (hWnd), UINT, VK_PROCESSKEY, FALSE)
IMM32LOAD( ImmSetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM pCF), (hIMC, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmConfigureIMEA, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE, FALSE)
IMM32LOAD( ImmConfigureIMEW, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE, FALSE)
IMM32LOAD( ImmDestroyContext, (HIMC hIMC), (hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmAssociateContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), HIMC, 0, FALSE)
IMM32LOAD( ImmEscapeA, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0, FALSE)
IMM32LOAD( ImmEscapeW, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0, FALSE)
IMM32LOAD( ImmIsIME, (HKL hKL), (hKL), BOOL, FALSE, FALSE)
IMM32LOAD( ImmCreateContext, (void), (), HIMC, 0, FALSE)
IMM32LOAD( ImmGetCompositionFontA, (HIMC hIMC, LPLOGFONTA plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetCompositionFontW, (HIMC hIMC, LPLOGFONTW plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetCandidateWindow, (HIMC hIMC, DWORD dw, LPCANDIDATEFORM pCF), (hIMC, dw, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetCandidateListA, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCandidateListW, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCandidateListCountA, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCandidateListCountW, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCompositionStringA, (HIMC hIMC, DWORD dw1, LPVOID pv, DWORD dw2), (hIMC, dw1, pv, dw2), LONG, 0, FALSE)
IMM32LOAD( ImmGetCompositionStringW, (HIMC hIMC, DWORD dw1, LPVOID pv, DWORD dw2), (hIMC, dw1, pv, dw2), LONG, 0, FALSE)
IMM32LOAD( ImmGetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM pCF), (hIMC, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetConversionListA, (HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0, FALSE)
IMM32LOAD( ImmGetConversionListW, (HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0, FALSE)
IMM32LOAD( ImmGetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetIMCCSize, (HIMCC hIMCC), (hIMCC), DWORD, 0, FALSE)
IMM32LOAD( ImmReSizeIMCC, (HIMCC hIMCC, DWORD dw), (hIMCC, dw), HIMCC, 0, FALSE)
IMM32LOAD( ImmUnlockIMCC, (HIMCC hIMCC), (hIMCC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmLockIMCC, (HIMCC hIMCC), (hIMCC), LPVOID, NULL, FALSE)
IMM32LOAD( ImmDestroyIMCC, (HIMCC hIMCC), (hIMCC), HIMCC, hIMCC, FALSE)
IMM32LOAD( ImmUnlockIMC, (HIMC hIMC), (hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmLockIMC, (HIMC hIMC), (hIMC), LPINPUTCONTEXT, NULL, FALSE)
IMM32LOAD( ImmSetCompositionStringA, (HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dw1, LPCVOID lpRead, DWORD dw2), (hIMC, dwIndex, lpComp, dw1, lpRead, dw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCompositionStringW, (HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dw1, LPCVOID lpRead, DWORD dw2), (hIMC, dwIndex, lpComp, dw1, lpRead, dw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCompositionFontA, (HIMC hIMC, LPLOGFONTA plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCompositionFontW, (HIMC hIMC, LPLOGFONTW plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCandidateWindow, (HIMC hIMC, LPCANDIDATEFORM pCF), (hIMC, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmRegisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmRegisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmUnregisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmUnregisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetRegisterWordStyleA, (HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0, FALSE)
IMM32LOAD( ImmGetRegisterWordStyleW, (HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0, FALSE)
IMM32LOAD( ImmSimulateHotKey, (HWND hWnd, DWORD dwHotKeyID), (hWnd, dwHotKeyID), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetGuideLineA, (HIMC hIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetGuideLineW, (HIMC hIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameA, (HKL hKL, LPSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameW, (HKL hKL, LPWSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmAssociateContextEx, (HWND hWnd, HIMC hIMC, DWORD dwFlags), (hWnd, hIMC, dwFlags), BOOL, FALSE, FALSE)
IMM32LOAD( ImmDisableIME, (DWORD dwId), (dwId), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetImeMenuItemsA, (HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize), DWORD, 0, FALSE)
IMM32LOAD( ImmGetImeMenuItemsW, (HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize), DWORD, 0, FALSE)
IMM32LOAD( ImmRequestMessageA, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0, FALSE)
IMM32LOAD( ImmRequestMessageW, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0, FALSE)

#endif // UNUSED_IMM32_APIS

//
// shell32.dll
//

HINSTANCE g_hShell32 = 0;

UINT STDAPICALLTYPE Internal_ExtractIconExA(LPCTSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hShell32 == NULL)
    {
        pfn = GetFn(&g_hShell32, "shell32.dll", "ExtractIconExA", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return 0;
        }
    }

    return ((UINT (STDAPICALLTYPE *)(LPCTSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons))(pfn))(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
}

HINSTANCE g_hShlwapi = 0;

HRESULT STDAPICALLTYPE Internal_SHLoadRegUIStringW(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hShlwapi == NULL)
    {
#if 0
        if (g_hShlwapi == 0)
        {
            EnterCriticalSection(g_csDelayLoad);
            if (g_hShlwapi == 0)
            {
                g_hShlwapi = LoadSystemLibrary("shlwapi.dll");
            }
            LeaveCriticalSection(g_csDelayLoad);

            if (g_hShlwapi == 0)
            {
                Assert(0);
                return E_FAIL;
            }
        }

        pfn = GetProcAddress(g_hShlwapi, (LPSTR) 439);
#else
        pfn = GetFn(&g_hShlwapi, "shlwapi.dll", (LPSTR)439, FALSE);
#endif

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf))(pfn))(hkey, pszValue, pszOutBuf, cchOutBuf);
}

//
// ole32
//
HINSTANCE g_hOle32 = 0;

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoCreateInstance", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            if (ppv != NULL)
            {
                *ppv = NULL;
            }
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv))(pfn))(rclsid, punkOuter, dwClsContext, riid, ppv);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoTaskMemAlloc", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(ULONG cb))(pfn))(cb);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoTaskMemRealloc", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(LPVOID pv, ULONG cb))(pfn))(pv, cb);
}

void STDAPICALLTYPE Internal_CoTaskMemFree(void *pv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoTaskMemFree", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return;
        }
    }

    ((void (STDAPICALLTYPE *)(void *pv))(pfn))(pv);
}

void STDAPICALLTYPE Internal_ReleaseStgMedium(STGMEDIUM *pMedium)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "ReleaseStgMedium", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return;
        }
    }

    ((void (STDAPICALLTYPE *)(STGMEDIUM *pMedium))(pfn))(pMedium);
}

#pragma warning(disable: 4715)  //  not all control paths return a value
HRESULT STDAPICALLTYPE Internal_CoInitialize(void *pv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoInitialize", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    ((HRESULT (STDAPICALLTYPE *)(void *pv))(pfn))(pv);
}

HRESULT STDAPICALLTYPE Internal_CoUninitialize(void)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoUninitialize", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    ((HRESULT (STDAPICALLTYPE *)(void))(pfn))();
}
#pragma warning(3: 4715)  //  not all control paths return a value

void InitDelayedLibs()
{
    //
    // This is called in DllMain(). Don't do LoadLibrary().
    //
    g_hImm32 = GetSystemModuleHandle("imm32.dll");

    Init_CtfImmCoUninitialize();
    Init_CtfImmLastEnabledWndDestroy();
    Init_CtfImmSetCiceroStartInThread();
    Init_CtfImmIsCiceroStartedInThread();
    Init_CtfImmIsCiceroEnabled();
    Init_CtfImmIsTextFrameServiceDisabled();
    Init_CtfImmEnterCoInitCountSkipMode();
    Init_CtfImmLeaveCoInitCountSkipMode();
    Init_ImmGetDefaultIMEWnd();
    Init_ImmReleaseContext();
    Init_ImmNotifyIME();
    Init_ImmSetConversionStatus();
    Init_ImmGetConversionStatus();
    Init_ImmGetProperty();
    Init_ImmGetOpenStatus();
    Init_ImmGetContext();
    Init_ImmSetOpenStatus();
    Init_ImmInstallIMEA();
    Init_ImmGetDescriptionA();
    Init_ImmGetDescriptionW();
    Init_ImmGetIMEFileNameA();
    Init_ImmGetIMEFileNameW();
    Init_ImmSetHotKey();
}

void ReleaseDelayedLibs()
{
    EnterCriticalSection(g_csDelayLoad);

    if (g_hShell32 != NULL)
    {
        FreeLibrary(g_hShell32);
        g_hShell32 = NULL;
    }

    if (g_hShlwapi != NULL)
    {
        FreeLibrary(g_hShlwapi);
        g_hShlwapi = NULL;
    }

    if (g_hOle32 != NULL)
    {
        FreeLibrary(g_hOle32);
        g_hOle32 = NULL;
    }

    LeaveCriticalSection(g_csDelayLoad);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\dam.h ===
//
// dam.h
//

#ifndef DAM_H
#define DAM_H

#include "private.h"
#include "ptrary.h"
#include "strary.h"
#include "enumguid.h"
#include "sunka.h"
#include "globals.h"

extern const IID IID_CDisplayAttributeMgr; // private iid for CDisplayAttributeMgr pointer

typedef struct tagDISPATTRGUID {
    CLSID clsid;
    TfGuidAtom gaClsid;
    GUID guid;
    TfGuidAtom gaGuid;
} DISPATTRGUID;

#define StaticCacheInit() CDispAttrGuidCache::StaticInit()

class CDispAttrGuidCache;
extern CDispAttrGuidCache *g_pDispAttrGuidCache;

//////////////////////////////////////////////////////////////////////////////
//
// CRenderMarkupCollection
//
//////////////////////////////////////////////////////////////////////////////

class CRenderMarkupCollection
{
public:
    CRenderMarkupCollection();

    void _Advise(ITfTextInputProcessor *tip, TfGuidAtom gaTip);
    void _Unadvise(TfGuidAtom gaTip);

    int _Count()
    {
        return _rgGUIDAtom.Count();
    }
    const TfGuidAtom *_GetAtoms()
    {
        return _rgGUIDAtom.GetPtr(0);
    }
    TfGuidAtom _GetAtom(int i)
    {
        return *_rgGUIDAtom.GetPtr(i);
    }

    BOOL _IsInCollection(REFGUID rguidProperty);

private:
    typedef struct
    {
        ULONG uPriority;
        TfGuidAtom gaTip;
    } MARKUP_DATA;

    // these are parallel arrays
    // they aren't merged because we want to use CalcCicPropertyTrackerAnchors
    // which takes a flat array of TfGuidAtoms
    CStructArray<TfGuidAtom> _rgGUIDAtom;
    CStructArray<MARKUP_DATA> _rgOther;
};


//////////////////////////////////////////////////////////////////////////////
//
// CDispAttrGuidCache
//
//////////////////////////////////////////////////////////////////////////////

class CDispAttrGuidCache
{
public:
    CDispAttrGuidCache() {}

    static void StaticUnInit();
    static void StaticInit();
    BOOL Add(REFCLSID clsid, REFGUID guid);
    void Remove(TfGuidAtom guidatom);
    void RemoveClsid(TfGuidAtom guidatom);
    BOOL Get(TfGuidAtom guidatom, DISPATTRGUID *pDisp);
    BOOL InternalGet(TfGuidAtom guidatom, DISPATTRGUID *pDisp);
    BOOL IsClsid(TfGuidAtom gaClsid);
    HRESULT Save();
    HRESULT Load();
    void Clear() {_rgDispAttrGuid.Clear(); Save();}

private:
    CStructArray<DISPATTRGUID> _rgDispAttrGuid;
};

//////////////////////////////////////////////////////////////////////////////
//
// CDisplayAttributeMgr
//
//////////////////////////////////////////////////////////////////////////////

typedef struct tagDAPROVIDERMAP {
    TfGuidAtom gaClsid;
    ITfDisplayAttributeProvider *pPrv;
} DAPROVIDERMAP;

class CDisplayAttributeMgr : 
      public ITfDisplayAttributeMgr,
      public ITfDisplayAttributeCollectionMgr,
      public CComObjectRoot_CreateSingletonInstance<CDisplayAttributeMgr>
{
public:
    CDisplayAttributeMgr();
    ~CDisplayAttributeMgr();

    BEGIN_COM_MAP_IMMX(CDisplayAttributeMgr)
        COM_INTERFACE_ENTRY(ITfDisplayAttributeMgr)
        COM_INTERFACE_ENTRY(ITfDisplayAttributeCollectionMgr)
        COM_INTERFACE_ENTRY_IID(IID_CDisplayAttributeMgr, CDisplayAttributeMgr)
    END_COM_MAP_IMMX()

    //
    // ITfDisplayAttributeMgr
    //
    STDMETHODIMP OnUpdateInfo();
    STDMETHODIMP EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo, CLSID *pclsid);

    // ITfDisplayAttributeCollectionMgr
    STDMETHODIMP EnumCollections(IEnumTfCollection **ppEnum);

    static HRESULT StaticRegisterProperty(REFGUID guidProp, WCHAR *pszName);

    CRenderMarkupCollection *_GetMarkupCollection()
    {
        return &_rgMarkupCollection;
    }

    static void _AdviseMarkupCollection(ITfTextInputProcessor *tip, TfGuidAtom gaTip)
    {
        CDisplayAttributeMgr *pDisplayAttrMgr;

        if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) != S_OK)
            return;

        pDisplayAttrMgr->_rgMarkupCollection._Advise(tip, gaTip);
    
        pDisplayAttrMgr->Release();
    }

    static void _UnadviseMarkupCollection(TfGuidAtom gaTip)
    {
        CDisplayAttributeMgr *pDisplayAttrMgr;

        if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) != S_OK)
            return;

        pDisplayAttrMgr->_rgMarkupCollection._Unadvise(gaTip);

        pDisplayAttrMgr->Release();
    }

    static BOOL _IsInCollection(REFGUID rguidProperty)
    {
        CDisplayAttributeMgr *pDisplayAttrMgr;
        BOOL fRet;

        if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) != S_OK)
            return FALSE;

        fRet = pDisplayAttrMgr->_rgMarkupCollection._IsInCollection(rguidProperty);

        pDisplayAttrMgr->Release();

        return fRet;
    }

    static CDisplayAttributeMgr *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;
        return psfn->pdam;
    }

private:

    static BOOL _SetThis(CDisplayAttributeMgr *_this)
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return FALSE;

        psfn->pdam = _this;
        return TRUE;
    }


    static HRESULT _RegisterGUID(const TCHAR *pszKey, REFGUID rguid, WCHAR *pszName, ULONG cchName);
    static HRESULT _UnregisterGUID(const TCHAR *pszKey, REFGUID rguid);

    CStructArray<DAPROVIDERMAP> _rgDaPrv;

    CRenderMarkupCollection _rgMarkupCollection;

    static BOOL EnumThreadProc(DWORD dwThread, DWORD dwProcessId, void *pv);

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CEnumDisplayAttributeInfo
//
//////////////////////////////////////////////////////////////////////////////

class CEnumDisplayAttributeInfo : public IEnumTfDisplayAttributeInfo,
                                  public CEnumUnknown,
                                  public CComObjectRootImmx
{
public:
    CEnumDisplayAttributeInfo();

    BEGIN_COM_MAP_IMMX(CEnumDisplayAttributeInfo)
        COM_INTERFACE_ENTRY(IEnumTfDisplayAttributeInfo)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfDisplayAttributeInfo, CEnumDisplayAttributeInfo, ITfDisplayAttributeInfo)

    BOOL Init();

private:
    DBG_ID_DECLARE;
};



#endif //DAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\delay.h ===
//
// delay.h
//

#ifndef DELAY_H
#define DELAY_H

//
// imm32
//

void WINAPI CtfImmCoUninitialize();
HRESULT WINAPI CtfImmLastEnabledWndDestroy(LPARAM lParam);
HRESULT WINAPI CtfImmSetCiceroStartInThread(BOOL fSet);
BOOL WINAPI CtfImmEnterCoInitCountSkipMode();
BOOL WINAPI CtfImmLeaveCoInitCountSkipMode();

//
// shell32
//

UINT STDAPICALLTYPE Internal_ExtractIconExA(LPCTSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
#define ExtractIconExA Internal_ExtractIconExA

//
// shwapi
//

HRESULT STDAPICALLTYPE Internal_SHLoadRegUIStringW(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf);
#define SHLoadRegUIStringW Internal_SHLoadRegUIStringW

//
// ole32
//

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
#define CoCreateInstance Internal_CoCreateInstance

void STDAPICALLTYPE Internal_ReleaseStgMedium(STGMEDIUM *pMedium);
#define ReleaseStgMedium Internal_ReleaseStgMedium

LPVOID STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb);
#define CoTaskMemAlloc Internal_CoTaskMemAlloc

LPVOID STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb);
#define CoTaskMemRealloc Internal_CoTaskMemRealloc

void STDAPICALLTYPE Internal_CoTaskMemFree(void *pv);
#define CoTaskMemFree Internal_CoTaskMemFree

HRESULT STDAPICALLTYPE Internal_CoInitialize(void *pv);
#define CoInitialize Internal_CoInitialize

HRESULT STDAPICALLTYPE Internal_CoUninitialize(void);
#define CoUninitialize Internal_CoUninitialize

void InitDelayedLibs();

#endif // DELAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\dim.cpp ===
//
// CDocumentInputManager.cpp
//

#include "private.h"
#include "dim.h"
#include "globals.h"
#include "tim.h"
#include "emptyic.h"

DBG_ID_INSTANCE(CDocumentInputManager);

/* dca73cc8-e2ed-48c4-8b25-ba2e9908095f */
extern const IID IID_PRIV_CDIM = { 0xdca73cc8, 0xe2ed, 0x48c4, {0x8b, 0x25, 0xba, 0x2e, 0x99, 0x08, 0x09, 0x5f} };
                
//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CDocumentInputManager::CDocumentInputManager()
                      : CCompartmentMgr(g_gaApp /* Issue */, COMPTYPE_DIM)
{
    Dbg_MemSetThisNameID(TEXT("CDocumentInputManager"));

    Assert(_peic == NULL);
    _iStack = -1;
}


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CDocumentInputManager::~CDocumentInputManager()
{
    // stack should have been cleared in CThreadInputMgr::RemoveDocumentInputMgr
    Assert(_iStack == -1);

    SafeRelease(_peic);

    //
    // remove this from dim ptr array of TIM.
    //
    CThreadInputMgr *tim;
    if (tim = CThreadInputMgr::_GetThis())
    {
        int i = 0;
        int nCnt = tim->_rgdim.Count();
        CDocumentInputManager **ppdim = tim->_rgdim.GetPtr(0);
        while (i < nCnt)
        {
            if (*ppdim == this)
            {
                tim->_rgdim.Remove(i, 1);
                break;
            }
            i++;
            ppdim++;
        }

        tim->GetDimWndMap()->_Remove(this);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\dim.h ===
//
// dim.h
//

#ifndef DIM_H
#define DIM_H

#include "private.h"
#include "compart.h"

#define ICS_STACK_SIZE 2

class CInputContext;
class CEmptyInputContext;

extern const IID IID_PRIV_CDIM;

class CDocumentInputManager : public ITfDocumentMgr,
                              public CCompartmentMgr,
                              public CComObjectRootImmx
{
public:
    CDocumentInputManager();
    ~CDocumentInputManager();

    BEGIN_COM_MAP_IMMX(CDocumentInputManager)
        COM_INTERFACE_ENTRY(ITfDocumentMgr)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CDIM, CDocumentInputManager)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfDocumentManager
    //
    STDMETHODIMP CreateContext(TfClientId tid, DWORD dwFlags, IUnknown *punk, ITfContext **ppic, TfEditCookie *pecTextStore);
    STDMETHODIMP Push(ITfContext *pic);
    STDMETHODIMP Pop(DWORD dwFlags);
    STDMETHODIMP GetTop(ITfContext **ppic);
    STDMETHODIMP GetBase(ITfContext **ppBase);
    STDMETHODIMP EnumContexts(IEnumTfContexts **ppEnum);

    BOOL _Pop(CThreadInputMgr *tim);

    HRESULT _GetContext(int iStack, ITfContext **ppic);

    CInputContext *_GetTopIC();

    int _GetCurrentStack() { return _iStack; }

    CInputContext *_GetIC(int iStack)
    {
         if (iStack < 0)
             return NULL;
         if (iStack > _iStack)
             return NULL;

         return _Stack[iStack];
    }

private:
    CInputContext *_Stack[ICS_STACK_SIZE];
    int _iStack;
    BOOL _fPoppingStack : 1;

    CEmptyInputContext *_peic;

    DBG_ID_DECLARE;
};

inline CDocumentInputManager *GetCDocumentInputMgr(IUnknown *punk)
{
    CDocumentInputManager *dim;

    punk->QueryInterface(IID_PRIV_CDIM, (void **)&dim);

    return dim;
}

#endif // DIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\editrec.cpp ===
//
// editrec.cpp
//

#include "private.h"
#include "editrec.h"
#include "ic.h"
#include "enumss.h"

DBG_ID_INSTANCE(CEditRecord);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEditRecord::CEditRecord(CInputContext *pic)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEditRecord"), PERF_EDITREC_COUNTER);

    Assert(_fSelChanged == FALSE);

    _pic = pic;
    _pic->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEditRecord::~CEditRecord()
{
    int i;
    PROPSPAN *pps;

    _pic->Release();

    for (i=0; i<_rgssProperties.Count(); i++)
    {
        pps = (PROPSPAN *)_rgssProperties.GetPtr(i);
        delete pps->pss;
    }
}

//+---------------------------------------------------------------------------
//
// GetSelectionStatus
//
//----------------------------------------------------------------------------

STDAPI CEditRecord::GetSelectionStatus(BOOL *pfChanged)
{
    if (pfChanged == NULL)
        return E_INVALIDARG;

    *pfChanged = _fSelChanged;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetTextAndPropertyUpdates
//
//----------------------------------------------------------------------------

STDAPI CEditRecord::GetTextAndPropertyUpdates(DWORD dwFlags, const GUID **rgProperties, ULONG cProperties, IEnumTfRanges **ppEnumProp)
{
    CEnumSpanSetRanges *pssAccumulate;
    CSpanSet *pssCurrent;
    ULONG i;

    if (ppEnumProp == NULL)
        return E_INVALIDARG;

    *ppEnumProp = NULL;

    if (dwFlags & ~TF_GTP_INCL_TEXT)
        return E_INVALIDARG;

    if (!(dwFlags & TF_GTP_INCL_TEXT) &&
        (rgProperties == NULL || cProperties < 1))
    {
        return E_INVALIDARG;
    }

    if ((pssAccumulate = new CEnumSpanSetRanges(_pic)) == NULL)
        return E_OUTOFMEMORY;

    if (dwFlags & TF_GTP_INCL_TEXT)
    {
        pssAccumulate->_Merge(&_ssText);
    }

    for (i=0; i<cProperties; i++)
    {
        if ((pssCurrent = _FindPropertySpanSet(*rgProperties[i])) == NULL)
            continue;

        pssAccumulate->_Merge(pssCurrent);
    }

    *ppEnumProp = pssAccumulate;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _AddProperty
//
//----------------------------------------------------------------------------

BOOL CEditRecord::_AddProperty(TfGuidAtom gaType, CSpanSet *pss)
{
    int i;
    PROPSPAN *pps;

    pps = _FindProperty(gaType, &i);
    Assert(pps == NULL); // property should not already have been added

    return _InsertProperty(gaType, pss, i+1, FALSE);
}

//+---------------------------------------------------------------------------
//
// _FindCreateAppAttr
//
//----------------------------------------------------------------------------

CSpanSet *CEditRecord::_FindCreateAppAttr(TfGuidAtom gaType)
{
    int i;
    PROPSPAN *pps;
    CSpanSet *pss;

    pps = _FindProperty(gaType, &i);

    if (pps != NULL)
    {
        return pps->pss;
    }

    if ((pss = new CSpanSet) == NULL)
        return FALSE;

    if (!_InsertProperty(gaType, pss, i+1, TRUE))
    {
        delete pss;
        return NULL;
    }

    return pss;
}

//+---------------------------------------------------------------------------
//
// _InsertProperty
//
//----------------------------------------------------------------------------

BOOL CEditRecord::_InsertProperty(TfGuidAtom gaType, CSpanSet *pss, int i, BOOL fAppProperty)
{
    PROPSPAN *pps;

    if (!_rgssProperties.Insert(i, 1))
        return FALSE;

    pps = _rgssProperties.GetPtr(i);

    pps->gaType = gaType;
    pps->fAppProperty = fAppProperty;
    pps->pss = pss;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _FindProperty
//
//----------------------------------------------------------------------------

PROPSPAN *CEditRecord::_FindProperty(TfGuidAtom gaType, int *piOut)
{
    PROPSPAN *ps;
    PROPSPAN *psMatch;
    int iMin;
    int iMax;
    int iMid;

    //
    // Issue: we should have a generic bsort function
    // instead of all this code dup!
    //

    psMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgssProperties.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        ps = _rgssProperties.GetPtr(iMid);
        Assert(ps != NULL);

        if (gaType < ps->gaType)
        {
            iMax = iMid;
        }
        else if (gaType > ps->gaType)
        {
            iMin = iMid + 1;
        }
        else // match!
        {
            psMatch = ps;
            break;
        }
    }

    if (piOut != NULL)
    {
        if (psMatch == NULL && _rgssProperties.Count() > 0)
        {
            // couldn't find a match, return the next lowest span
            Assert(iMid == 0 || _rgssProperties.GetPtr(iMid-1)->gaType < gaType);
            if (_rgssProperties.GetPtr(iMid)->gaType > gaType)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return psMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumdim.h ===
//
// enumdim.h
//

#ifndef ENUMDIM_H
#define ENUMDIM_H

#include "sunka.h"
#include "tim.h"

class CThreadInputMgr;

class CEnumDocumentInputMgrs : public IEnumTfDocumentMgrs,
                               public CEnumUnknown,
                               public CComObjectRootImmx
{
public:
    CEnumDocumentInputMgrs()
    {
        Dbg_MemSetThisNameID(TEXT("CEnumDocumentInputMgrs"));
    }

    BEGIN_COM_MAP_IMMX(CEnumDocumentInputMgrs)
        COM_INTERFACE_ENTRY(IEnumTfDocumentMgrs)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfDocumentMgrs, CEnumDocumentInputMgrs, ITfDocumentMgr)

    BOOL _Init(CThreadInputMgr *tim)
    {
        _iCur = 0;

        return (_prgUnk = SUA_Init(tim->_rgdim.Count(), (IUnknown **)tim->_rgdim.GetPtr(0))) != NULL;
    }

private:
    DBG_ID_DECLARE;
};


#endif // ENUMDIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\dllmain.cpp ===
//
// dllmain.cpp
//

#include "private.h"
#include "globals.h"
#include "tim.h"
#include "imelist.h"
#include "utb.h"
#include "dam.h"
#include "catmgr.h"
#include "nuimgr.h"
#include "profiles.h"
#include "internat.h"
#include "acp2anch.h"
#include "cicmutex.h"
#include "strary.h"
#include "range.h"
#include "compart.h"
#include "marshal.h"
#include "timlist.h"
#include "gcompart.h"
#include "mui.h"
#include "anchoref.h"
#include "hotkey.h"
#include "lbaddin.h"

extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);

extern HINSTANCE g_hOle32;

extern CCicCriticalSectionStatic g_csDelayLoad;;

#ifdef DEBUG
void dbg_RangeDump(ITfRange *pRange);
#endif

extern void UninitThread(void);

extern void RegisterMarshalWndClass();

CCicMutex g_mutexLBES;
CCicMutex g_mutexCompart;
CCicMutex g_mutexAsm;
CCicMutex g_mutexLayouts;
CCicMutex g_mutexTMD;
extern void UninitLayoutMappedFile();

char g_szAsmListCache[MAX_PATH];
char g_szTimListCache[MAX_PATH];
char g_szLayoutsCache[MAX_PATH];

//
// Hack for Office10 BVT.
//
// MSACCESS 10 Debug version (CMallocSpy) shows MsgBox after DLL is detached 
// from process.
// Showing MsgBox calls window Hook so Hook entry is called then.
// Need to check the DLL was already detached.
//
BOOL g_fDllProcessDetached = FALSE;
DWORD g_dwThreadDllMain = 0;
void InitStaticHooks();

BOOL g_bOnWow64;


BOOL gf_CRT_INIT    = FALSE;
BOOL gfSharedMemory = FALSE;


//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    CcshellGetDebugFlags();

    Perf_Init();

#ifdef DEBUG
    //
    // Do you know how to link non-used function??
    //
    dbg_RangeDump(NULL);
#endif

#ifndef NOCLIB
    gf_CRT_INIT = TRUE;
#endif

    if (!g_cs.Init())
        return FALSE;

    if (!g_csInDllMain.Init())
        return FALSE;

    if (!g_csDelayLoad.Init())
        return FALSE;

    g_bOnWow64 = RunningOnWow64();

    Dbg_MemInit( ! g_bOnWow64 ? TEXT("MSCTF") : TEXT("MSCTF(wow64)"), g_rgPerfObjCounters);

    g_hInst = hInstance;
    g_hklDefault = GetKeyboardLayout(0);

    g_dwTLSIndex = TlsAlloc();
    if (g_dwTLSIndex == TLS_OUT_OF_INDEXES)
        return FALSE;

    g_msgPrivate = RegisterWindowMessage(TEXT("MSUIM.Msg.Private"));
    if (!g_msgPrivate)
        return FALSE;

    g_msgSetFocus = RegisterWindowMessage(TEXT("MSUIM.Msg.SetFocus"));
    if (!g_msgSetFocus)
        return FALSE;

    g_msgThreadTerminate = RegisterWindowMessage(TEXT("MSUIM.Msg.ThreadTerminate"));
    if (!g_msgThreadTerminate)
        return FALSE;

    g_msgThreadItemChange = RegisterWindowMessage(TEXT("MSUIM.Msg.ThreadItemChange"));
    if (!g_msgThreadItemChange)
        return FALSE;

    g_msgLBarModal = RegisterWindowMessage(TEXT("MSUIM.Msg.LangBarModal"));
    if (!g_msgLBarModal)
        return FALSE;

    g_msgRpcSendReceive = RegisterWindowMessage(TEXT("MSUIM.Msg.RpcSendReceive"));
    if (!g_msgRpcSendReceive)
        return FALSE;

    g_msgThreadMarshal = RegisterWindowMessage(TEXT("MSUIM.Msg.ThreadMarshal"));
    if (!g_msgThreadMarshal)
        return FALSE;

    g_msgCheckThreadInputIdel = RegisterWindowMessage(TEXT("MSUIM.Msg.CheckThreadInputIdel"));
    if (!g_msgCheckThreadInputIdel)
        return FALSE;

    g_msgStubCleanUp = RegisterWindowMessage(TEXT("MSUIM.Msg.StubCleanUp"));
    if (!g_msgStubCleanUp)
        return FALSE;

    g_msgShowFloating = RegisterWindowMessage(TEXT("MSUIM.Msg.ShowFloating"));
    if (!g_msgShowFloating)
        return FALSE;

    g_msgLBUpdate = RegisterWindowMessage(TEXT("MSUIM.Msg.LBUpdate"));
    if (!g_msgLBUpdate)
        return FALSE;

    g_msgNuiMgrDirtyUpdate = RegisterWindowMessage(TEXT("MSUIM.Msg.MuiMgrDirtyUpdate"));
    if (!g_msgNuiMgrDirtyUpdate)
        return FALSE;

    InitOSVer();

    //
    // get imm32's hmodule.
    //
    InitDelayedLibs();

    InitUniqueString();

    g_SharedMemory.BaseInit();
    if (!g_SharedMemory.Start())
        return FALSE;

    gfSharedMemory = TRUE;

    InitAppCompatFlags();
    InitCUASFlag();

    g_rglbes = new CStructArray<LBAREVENTSINKLOCAL>;
    if (!g_rglbes)
        return FALSE;

    RegisterMarshalWndClass();

    GetDesktopUniqueNameArray(TEXT("CTF.AsmListCache.FMP"), g_szAsmListCache);
    GetDesktopUniqueNameArray(TEXT("CTF.TimListCache.FMP"), g_szTimListCache);
    GetDesktopUniqueNameArray(TEXT("CTF.LayoutsCache.FMP"), g_szLayoutsCache);

    TCHAR ach[MAX_PATH];

    GetDesktopUniqueNameArray(TEXT("CTF.LBES.Mutex"), ach);

    CCicSecAttr sa;
    if (!g_mutexLBES.Init(sa, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.Compart.Mutex"), ach);
    if (!g_mutexCompart.Init(sa, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.Asm.Mutex"), ach);
    if (!g_mutexAsm.Init(sa, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.Layouts.Mutex"), ach);
    if (!g_mutexLayouts.Init(sa, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.TMD.Mutex"), ach);
    if (!g_mutexTMD.Init(sa, ach))
        return FALSE;

    InitLangChangeHotKey();

    CRange::_InitClass();

    CAnchorRef::_InitClass();

    dbg_InitMarshalTimeOut();

    MuiLoadResource(hInstance, TEXT("msctf.dll"));

    CheckAnchorStores();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDetach
//
//----------------------------------------------------------------------------

void ProcessDetach(HINSTANCE hInstance)
{
#ifndef NOCLIB
    if (gf_CRT_INIT)
    {
#endif
        if (gfSharedMemory)
        {
            //
            // If _Module.m_nLockCnt != 0, then TFUninitLib() doesn't calls from DllUninit().
            // So critical section of g_csIMLib never deleted.
            //
            if (DllRefCount() != 0)
            {
                TFUninitLib();
            }

            CRange::_UninitClass();
            CAnchorRef::_UninitClass();

            MuiClearResource();
        }

        UninitINAT();
        CDispAttrGuidCache::StaticUnInit();

        UninitThread();

        //
        // clean up all marshal window in this thread.
        //
        CThreadMarshalWnd::ClearMarshalWndProc(GetCurrentProcessId());

        TF_UninitThreadSystem();

        UninitProcess();
        if (g_dwTLSIndex != TLS_OUT_OF_INDEXES)
            TlsFree(g_dwTLSIndex);
        g_dwTLSIndex = TLS_OUT_OF_INDEXES;

        if (g_rglbes)
            delete g_rglbes;

        g_rglbes = NULL;

        g_gcomplist.CleanUp();
        g_timlist.CleanUp();
        Dbg_MemUninit();

        g_cs.Delete();
        g_csInDllMain.Delete();
        g_csDelayLoad.Delete();

        if (gfSharedMemory)
        {
            g_mutexLBES.Uninit();
            g_mutexCompart.Uninit();
            g_mutexAsm.Uninit();

            //
            // call UninitLayoutMappedFile before uninitializing the mutex.
            //
            UninitLayoutMappedFile();
            g_mutexLayouts.Uninit();

            g_mutexTMD.Uninit();

            InitStaticHooks(); // must happen before we uninit shared memory
            g_SharedMemory.Close();
        }
        g_SharedMemory.Finalize();

#ifndef NOCLIB
    }

    if (g_fDllProcessDetached)
    {
        // why were we called twice?
        Assert(0);
    }
#endif

    Assert(DllRefCount() == 0); // leaked something?

    g_fDllProcessDetached = TRUE;
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    BOOL bRet = TRUE;
    g_dwThreadDllMain = GetCurrentThreadId();

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDetach(hInstance);
                bRet = FALSE;
                break;
            }

            //
            // fall thru
            //

            //
            // to call TF_InitThreadSystem(), make sure we have not initialized
            // timlist yet.
            //
            Assert(!g_timlist.IsInitialized());

        case DLL_THREAD_ATTACH:
            TF_InitThreadSystem();
            break;

        case DLL_THREAD_DETACH:
            UninitThread();
            TF_UninitThreadSystem();
            break;

        case DLL_PROCESS_DETACH:
            ProcessDetach(hInstance);
            break;
    }

    g_dwThreadDllMain = 0;
    return bRet;
}

#ifdef DEBUG
//+---------------------------------------------------------------------------
//
// dbg_RangeDump
//
//----------------------------------------------------------------------------

void dbg_RangeDump(ITfRange *pRange)
{
    WCHAR ach[256];
    ULONG cch;
    char  ch[256];
    ULONG cch1 = ARRAYSIZE(ch);

    if (!pRange)
        return;    

    pRange->GetText(BACKDOOR_EDIT_COOKIE, 0, ach, ARRAYSIZE(ach), &cch);
    ach[cch] = L'\0';
    
    TraceMsg(TF_GENERAL, "dbg_RangeDump");
    TraceMsg(TF_GENERAL, "\tpRange:       %x", (UINT_PTR)pRange);
    cch1 = WideCharToMultiByte(CP_ACP, 0, ach, -1, ch, sizeof(ch)-1, NULL, NULL);
    ch[cch1] = '\0';
    TraceMsg(TF_GENERAL, "\t%s", ch);

    char sz[512];
    sz[0] = '\0';
    for (UINT i = 0; i < cch; i++)
    {
         StringCchPrintf(sz, ARRAYSIZE(sz), "%s%04x ", sz, ach[i]);
    }
    TraceMsg(TF_GENERAL, "\t%s", sz);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\emptyic.h ===
//
// emptyic.h
//

#ifndef EMPTYIC_H
#define EMPTYIC_H

#include "private.h"
#include "globals.h"
#include "compart.h"

class CDocumentInputManager;
class CEmptyInputContext;
CEmptyInputContext *EnsureEmptyContext();


//////////////////////////////////////////////////////////////////////////////
//
// CEmptyInputContext
//
//////////////////////////////////////////////////////////////////////////////

class CEmptyInputContext : public ITfContext,
                           public CCompartmentMgr,
                           public CComObjectRootImmx
{
public:
    CEmptyInputContext(CDocumentInputManager *dim);
    ~CEmptyInputContext();

    BEGIN_COM_MAP_IMMX(CEmptyInputContext)
        COM_INTERFACE_ENTRY(ITfContext)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfContext
    //
    STDMETHODIMP RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession);
    STDMETHODIMP InWriteSession(TfClientId tid, BOOL *pfWriteSession);
    STDMETHODIMP GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection);
    STDMETHODIMP GetStart(TfEditCookie ec, ITfRange **ppStart);
    STDMETHODIMP GetEnd(TfEditCookie ec, ITfRange **ppEnd);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP GetActiveView(ITfContextView **ppView);
    STDMETHODIMP EnumViews(IEnumTfContextViews **ppEnum);
    STDMETHODIMP GetProperty(REFGUID guidProp, ITfProperty **ppv);

    STDMETHODIMP GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp);
    STDMETHODIMP TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX);

    STDMETHODIMP EnumProperties(IEnumTfProperties **ppEnum);
    STDMETHODIMP GetDocumentMgr(ITfDocumentMgr **ppDoc);
    STDMETHODIMP CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup);

    HRESULT Init();

private:
    CDocumentInputManager *_dim;

    DBG_ID_DECLARE;
};


#endif // EMPTYIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\editrec.h ===
//
// editrec.h
//

#ifndef EDITREC_H
#define EDITREC_H

#include "private.h"
#include "spans.h"
#include "strary.h"
#include "globals.h"

typedef struct
{
    TfGuidAtom gaType;
    BOOL fAppProperty;
    CSpanSet *pss;
} PROPSPAN;

class CInputContext;

class CEditRecord : public ITfEditRecord,
                    public CComObjectRootImmx
{
public:
    CEditRecord(CInputContext *pic);
    ~CEditRecord();

    BEGIN_COM_MAP_IMMX(CEditRecord)
        COM_INTERFACE_ENTRY(ITfEditRecord)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfEditRecord
    STDMETHODIMP GetSelectionStatus(BOOL *pfChanged);
    STDMETHODIMP GetTextAndPropertyUpdates(DWORD dwFlags, const GUID **rgProperties, ULONG cProperties, IEnumTfRanges **ppEnumProp);

    BOOL _GetSelectionStatus() { return _fSelChanged; }
    void _SetSelectionStatus() { _fSelChanged = TRUE; }

    CSpanSet *_GetTextSpanSet() { return &_ssText; }

    BOOL _AddProperty(TfGuidAtom gaType, CSpanSet *pss);
    CSpanSet *_FindCreateAppAttr(TfGuidAtom gaType);

    BOOL _SecondRef()
    {
        return (m_dwRef > 1);
    }

    BOOL _IsEmpty()
    {
        return (!_fSelChanged) &&
               (_ssText.GetCount() == 0) &&
               (_rgssProperties.Count() == 0); // prop ss are only added if non-empty
    }

    void _Reset()
    {
        int i;
        PROPSPAN *pps;

        _fSelChanged = FALSE;
        _ssText.Reset();

        for (i=0; i<_rgssProperties.Count(); i++)
        {
            pps = (PROPSPAN *)_rgssProperties.GetPtr(i);
            // nb: caller takes ownership of cicero property span sets, we just free the pointer array
            if (pps->fAppProperty)
            {
                delete pps->pss;
            }
        }
        _rgssProperties.Clear(); // perf: use Reset?
    }

private:

    BOOL _InsertProperty(TfGuidAtom gaType, CSpanSet *pss, int i, BOOL fAppProperty);

    PROPSPAN *_FindProperty(TfGuidAtom gaType, int *piOut);
    int _FindPropertySpanIndex(TfGuidAtom gaType)
    {
        int i;

        _FindProperty(gaType, &i);
        return i;
    }
    CSpanSet *_FindPropertySpanSet(REFGUID rguid)
    {
        TfGuidAtom guidatom;
        PROPSPAN *pps;

        MyRegisterGUID(rguid, &guidatom);
        pps = _FindProperty(guidatom, NULL);

        return (pps == NULL) ? NULL : pps->pss;
    }

    CInputContext *_pic;
    CSpanSet _ssText;
    BOOL _fSelChanged;
    CStructArray<PROPSPAN> _rgssProperties;

    DBG_ID_DECLARE;
};

#endif // EDITREC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\emptyic.cpp ===
//
// emptyic.cpp
//

#include "private.h"
#include "emptyic.h"
#include "globals.h"
#include "compart.h"
#include "dim.h"

DBG_ID_INSTANCE(CEmptyInputContext);


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEmptyInputContext::CEmptyInputContext(CDocumentInputManager *dim)
                      : CCompartmentMgr(TF_INVALID_GUIDATOM, COMPTYPE_IC)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEmptyInputContext"), PERF_CONTEXT_COUNTER);

    _dim = dim;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEmptyInputContext::~CEmptyInputContext()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

HRESULT CEmptyInputContext::Init()
{
    HRESULT hr = MySetCompartmentDWORD(TF_INVALID_GUIDATOM, this, GUID_COMPARTMENT_EMPTYCONTEXT, 1);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession)
{
    if (phrSession)
        *phrSession = TF_E_EMPTYCONTEXT;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::InWriteSession(TfClientId tid, BOOL *pfWriteSession)
{
    if (pfWriteSession)
        *pfWriteSession = FALSE;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched)
{
    if (pSelection)
        memset(pSelection, 0, sizeof(TF_SELECTION));

    if (pcFetched)
        *pcFetched = 0;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection)
{
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetStart(TfEditCookie ec, ITfRange **ppStart)
{
    if (ppStart)
        *ppStart = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetEnd(TfEditCookie ec, ITfRange **ppEnd)
{
    if (ppEnd)
        *ppEnd = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetStatus(TS_STATUS *pdcs)
{
    if (pdcs)
        memset(pdcs, 0, sizeof(TS_STATUS));

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetActiveView(ITfContextView **ppView)
{
    if (ppView)
        *ppView = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::EnumViews(IEnumTfContextViews **ppEnum)
{
    if (ppEnum)
        *ppEnum = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetProperty(REFGUID guidProp, ITfProperty **ppv)
{
    if (ppv)
        *ppv = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------


STDAPI CEmptyInputContext::GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp)
{
    if (ppProp)
        *ppProp = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX)
{
    if (ppPropX)
        *ppPropX = NULL;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------


STDAPI CEmptyInputContext::EnumProperties(IEnumTfProperties **ppEnum)
{
    if (ppEnum)
        *ppEnum = NULL;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetDocumentMgr(ITfDocumentMgr **ppDm)
{
    if (ppDm == NULL)
        return E_INVALIDARG;

    *ppDm = _dim;
    if (*ppDm)
        (*ppDm)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup)
{
    if (ppBackup)
        *ppBackup = NULL;

    return TF_E_EMPTYCONTEXT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumfnpr.h ===
//
// enumfnpr.h
//

#ifndef ENUMFNPR_H
#define ENUMFNPR_H

#include "ptrary.h"
#include "sunka.h"

class CThreadInputMgr;

class CEnumFunctionProviders : public IEnumTfFunctionProviders,
                               public CEnumUnknown,
                               public CComObjectRootImmx
{
public:
    CEnumFunctionProviders()
    {
        Dbg_MemSetThisNameID(TEXT("CEnumFunctionProviders"));
    }

    BEGIN_COM_MAP_IMMX(CEnumFunctionProviders)
        COM_INTERFACE_ENTRY(IEnumTfFunctionProviders)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfFunctionProviders, CEnumFunctionProviders, ITfFunctionProvider)

    BOOL _Init(CThreadInputMgr *tim);

private:
    DBG_ID_DECLARE;
};


#endif // ENUMFNPR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumguid.cpp ===
//
// enumguid.cpp
//

#include "private.h"
#include "globals.h"
#include "enumguid.h"

DBG_ID_INSTANCE(CEnumGuid);

//////////////////////////////////////////////////////////////////////////////
//
// CEnumGuid
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumGuid::CEnumGuid()
{
    Dbg_MemSetThisNameID(TEXT("CEnumGuid"));
    Assert(_nCur == 0);
    Assert(_pga == 0);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumGuid::~CEnumGuid()
{
    CicEnterCriticalSection(g_cs);
    SGA_Release(_pga);
    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Clone(IEnumGUID **ppClone)
{
    CEnumGuid *pClone;
    HRESULT hr = E_FAIL;

    if (ppClone == NULL)
        return E_INVALIDARG;

    CicEnterCriticalSection(g_cs);

    *ppClone = NULL;

    if ((pClone = new CEnumGuid) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pClone->_nCur = _nCur;
    pClone->_pga = _pga;
    SGA_AddRef(pClone->_pga);

    *ppClone = pClone;

    CicLeaveCriticalSection(g_cs);
    hr = S_OK;

Exit:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Next(ULONG ulCount, GUID *pguid, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    Assert(pguid);

    CicEnterCriticalSection(g_cs);

    while (cFetched < ulCount)
    {
        if ((ULONG)_nCur >= _pga->cGuid)
            break;

        *pguid = _pga->rgGuid[_nCur];

        _nCur++;
        pguid++;
        cFetched++;
    }

    CicLeaveCriticalSection(g_cs);

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Reset()
{
    _nCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Skip(ULONG ulCount)
{
    HRESULT hr = S_OK;

    _nCur += ulCount;

    CicEnterCriticalSection(g_cs);

    if ((ULONG)_nCur >= _pga->cGuid)
    {
        _nCur = _pga->cGuid; // prevent overflow for repeated calls
        hr =  S_FALSE;
    }

    CicLeaveCriticalSection(g_cs);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumfnpr.cpp ===
//
// enumfnpr.cpp
//

#include "private.h"
#include "enumfnpr.h"
#include "tim.h"

DBG_ID_INSTANCE(CEnumFunctionProviders);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumFunctionProviders::_Init(CThreadInputMgr *tim)
{
    ULONG uCount;
    ULONG i;
    const CTip *tip;

    uCount = 0;

    for (i=0; i<tim->_GetTIPCount(); i++)
    {
        if (tim->_GetCTip(i)->_pFuncProvider != NULL)
        {
            uCount++;
        }
    }

    if ((_prgUnk = SUA_Alloc(uCount)) == NULL)
        return FALSE;

    _iCur = 0;
    _prgUnk->cRef = 1;
    _prgUnk->cUnk = 0;

    for (i=0; i<tim->_GetTIPCount(); i++)
    {
        tip = tim->_GetCTip(i);

        if (tip->_pFuncProvider != NULL)
        {
            _prgUnk->rgUnk[_prgUnk->cUnk] = tip->_pFuncProvider;
            _prgUnk->rgUnk[_prgUnk->cUnk]->AddRef();
            _prgUnk->cUnk++;
        }
    }
    Assert(_prgUnk->cUnk == uCount);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumguid.h ===
//
// enumguid.h
//

#ifndef ENUMGUID_H
#define ENUMGUID_H

#include "private.h"
#include "comcat.h"

// I would love to make this a class,
// but I can't get the compiler to accept a run-time template arg
typedef struct _SHARED_GUID_ARRAY
{
    ULONG cRef;
    ULONG cGuid;
    GUID rgGuid[1]; // one or more...
} SHARED_GUID_ARRAY;

inline void SGA_AddRef(SHARED_GUID_ARRAY *pga)
{
    pga->cRef++;
}

inline void SGA_Release(SHARED_GUID_ARRAY *pga)
{
    if (pga == NULL)
        return;

    Assert(pga->cRef > 0);
    if (--pga->cRef == 0)
    {
        cicMemFree(pga);
    }
}

inline SHARED_GUID_ARRAY *SGA_Alloc(ULONG cGuid)
{
    return (SHARED_GUID_ARRAY *)cicMemAlloc(sizeof(SHARED_GUID_ARRAY)+sizeof(GUID)*cGuid-sizeof(GUID));
}

inline BOOL SGA_ReAlloc(SHARED_GUID_ARRAY **ppga, ULONG cGuid)
{
    SHARED_GUID_ARRAY *pga;

    pga = (SHARED_GUID_ARRAY *)cicMemReAlloc(*ppga, sizeof(SHARED_GUID_ARRAY)+sizeof(GUID)*cGuid-sizeof(GUID));
    
    if (pga != NULL)
    {
        *ppga = pga;
        return TRUE;
    }

    return FALSE;
}

inline SHARED_GUID_ARRAY *SGA_Init(ULONG cGuid, const GUID *prgGuid)
{
    SHARED_GUID_ARRAY *pga;

    pga = SGA_Alloc(cGuid);

    if (pga == NULL)
        return NULL;

    pga->cRef = 1;
    pga->cGuid = cGuid;

    if (prgGuid != NULL)
    {
        memcpy(pga->rgGuid, prgGuid, cGuid*sizeof(GUID));
    }

    return pga;
}

class CEnumGuid : public IEnumGUID,
                  public CComObjectRootImmx
{
public:
    CEnumGuid();
    virtual ~CEnumGuid();

    BEGIN_COM_MAP_IMMX(CEnumGuid)
        COM_INTERFACE_ENTRY(IEnumGUID)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // derived class supplies an _Init() method here
    // It must initialize:
    //      _nCur
    //      _pga
    //
    // the default dtor will clean these guys up.

    virtual BOOL _Init(ULONG cGuid, const GUID *prgGuid)
    {
        _pga = SGA_Init(cGuid, prgGuid);

        return (_pga != NULL);
    }

    STDMETHODIMP Clone(IEnumGUID **pClone);
    STDMETHODIMP Next(ULONG ulCount, GUID *pguid, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

protected:
    int _nCur;
    SHARED_GUID_ARRAY *_pga;

    DBG_ID_DECLARE;
};

#endif // ENUMGUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumic.cpp ===
//
// enumdim.cpp
//

#include "private.h"
#include "enumic.h"
#include "dim.h"
#include "ic.h"

DBG_ID_INSTANCE(CEnumInputContexts);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumInputContexts::CEnumInputContexts()
{
    Dbg_MemSetThisNameID(TEXT("CEnumInputContexts"));

    Assert(_rgContexts[0] == NULL);
    Assert(_rgContexts[1] == NULL);
}
 

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumInputContexts::~CEnumInputContexts()
{
    SafeRelease(_rgContexts[0]);
    SafeRelease(_rgContexts[1]);
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumInputContexts::_Init(CDocumentInputManager *pdim)
{
    int i;

    Assert(_iCur == 0);
    _iCount = pdim->_GetCurrentStack() + 1;

    for (i=0; i<_iCount; i++)
    {
        _rgContexts[i] = pdim->_GetIC(i);

        if (_rgContexts[i] == NULL)
            goto ExitError;

        _rgContexts[i]->AddRef();
    }

    return TRUE;

ExitError:
    SafeRelease(_rgContexts[0]);
    Assert(_rgContexts[1] == NULL);
    return FALSE;
}
 
//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Next(ULONG ulCount, ITfContext **ppic, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    if (pcFetched != NULL)
    {
        *pcFetched = 0;
    }

    if (ppic == NULL && ulCount > 0)
        return E_INVALIDARG;
    
    while (cFetched < ulCount)
    {
        if (_iCur >= _iCount)
            break;

        *ppic = _rgContexts[_iCur];
        (*ppic)->AddRef();

        ppic++;
        _iCur++;
        cFetched++;
    }

    if (pcFetched != NULL)
    {
        *pcFetched = cFetched;
    }

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Clone(IEnumTfContexts **ppEnum)
{
    CEnumInputContexts *ec;
    int i;

    ec = new CEnumInputContexts;

    if (ec == NULL)
        return E_OUTOFMEMORY;

    ec->_iCur = _iCur;
    ec->_iCount = _iCount;

    for (i=0; i<_iCount; i++)
    {
        ec->_rgContexts[i] = _rgContexts[i];
        ec->_rgContexts[i]->AddRef();
    }

    *ppEnum = ec;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Skip(ULONG ulCount)
{    
    // protect against overflow
    if (_iCur >= 2)
        return S_FALSE;
    ulCount = min(ulCount, 2);

    _iCur += ulCount;

    return (_iCur <= _iCount) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumic.h ===
//
// enumic.h
//

#ifndef ENUMIC_H
#define ENUMIC_H


class CDocumentInputManager;

class CEnumInputContexts : public IEnumTfContexts,
                           public CComObjectRootImmx
{
public:
    CEnumInputContexts();
    ~CEnumInputContexts();

    BOOL _Init(CDocumentInputManager *pdim);

    BEGIN_COM_MAP_IMMX(CEnumInputContexts)
        COM_INTERFACE_ENTRY(IEnumTfContexts)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // IEnumTfContexts
    //
    STDMETHODIMP Clone(IEnumTfContexts **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfContext **ppic, ULONG *pcFetch);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    ITfContext *_rgContexts[2];
    int _iCur;
    int _iCount;

    DBG_ID_DECLARE;
};


#endif // ENUMIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumprop.cpp ===
//
// enumprop.cpp
//

#include "private.h"
#include "ic.h"
#include "enumprop.h"
#include "range.h"
#include "attr.h"
#include "saa.h"

DBG_ID_INSTANCE(CEnumPropertyRanges);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumPropertyRanges::_Init(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, CProperty *pProperty)
{
    TfGuidAtom atom;
    LONG cSpans;    

    Assert(_iCur == 0);
    Assert(_pic == NULL);
    Assert(_prgAnchors == NULL);

    cSpans = pProperty->GetPropNum();

    if (cSpans == 0)
    {
        // special case the no spans case since paStart, paEnd may be NULL
        _prgAnchors = new CSharedAnchorArray;
    }
    else
    {
        // property has one or more spans

        if (paStart == NULL)
        {
            Assert(paEnd == NULL);
            // CalcCicPropertyTrackerAnchors won't accept NULL, get that here
            // NULL means enum all spans
            paStart = pProperty->QuickGetPropList(0)->_paStart;
            paEnd = pProperty->QuickGetPropList(cSpans-1)->_paEnd;
        }

        atom = pProperty->GetPropGuidAtom();

        _prgAnchors = CalcCicPropertyTrackerAnchors(pic, paStart, paEnd, 1, &atom);
    }

    if (_prgAnchors == NULL)
        return FALSE; // out of memory

    _pic = pic;
    _pic->AddRef();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumprop.h ===
//
// enumprop.h
//

#ifndef ENUMPROP_H
#define ENUMPROP_H

#include "erfa.h"

class CEnumPropertyRanges : public CEnumRangesFromAnchorsBase
{
public:
    CEnumPropertyRanges()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumPropertyRanges"), PERF_ENUMPROPRANGE_COUNTER);
    }

    BOOL _Init(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, CProperty *pProperty);

private:
    DBG_ID_DECLARE;
};

#endif // ENUMPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumss.h ===
//
// enumss.h
//
// CEnumSpanSetRanges
//

#ifndef ENUMSS_H
#define ENUMSS_H

#include "private.h"
#include "spans.h"
#include "ic.h"

class CEnumSpanSetRanges : private CSpanSet,
                           public IEnumTfRanges,
                           public CComObjectRootImmx
{
public:
    CEnumSpanSetRanges(CInputContext *pic);
    ~CEnumSpanSetRanges();

    BEGIN_COM_MAP_IMMX(CEnumSpanSetRanges)
        COM_INTERFACE_ENTRY(IEnumTfRanges)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // IEnumTfRanges
    STDMETHODIMP Clone(IEnumTfRanges **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

    void _Merge(CSpanSet *pss);

private:
    CInputContext *_pic;
    int _iCur;

    DBG_ID_DECLARE;
};

#endif // ENUMSS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\erfa.h ===
//
// erfa.h
//
// CEnumRangesFromAnchorsBase
//
// Base class for range enumerators.
//

#ifndef ERFA_H
#define ERFA_H

class CInputContext;
class CSharedAnchorArray;

class __declspec(novtable) CEnumRangesFromAnchorsBase : public IEnumTfRanges,
                                                        public CComObjectRootImmx
{
public:
    CEnumRangesFromAnchorsBase() {}
    virtual ~CEnumRangesFromAnchorsBase();

    BEGIN_COM_MAP_IMMX(CEnumRangesFromAnchorsBase)
        COM_INTERFACE_ENTRY(IEnumTfRanges)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // derived class supplies an _Init() method here
    // It must initialize:
    //      _pic
    //      _iCur
    //      _prgAnchors
    //
    // the default dtor will clean these guys up.

    // IEnumTfRanges
    STDMETHODIMP Clone(IEnumTfRanges **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

protected:
    CInputContext *_pic;
    int _iCur;
    CSharedAnchorArray *_prgAnchors;
};

#endif // ERFA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\erfa.cpp ===
//
// erfa.cpp
//
// CEnumRangesFromAnchorsBase
//
// Base class for range enumerators.
//

#include "private.h"
#include "erfa.h"
#include "saa.h"
#include "ic.h"
#include "range.h"
#include "immxutil.h"

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumRangesFromAnchorsBase::~CEnumRangesFromAnchorsBase()
{
    SafeRelease(_pic);

    if (_prgAnchors != NULL)
    {
        _prgAnchors->_Release();
    }
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Clone(IEnumTfRanges **ppEnum)
{
    CEnumRangesFromAnchorsBase *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumRangesFromAnchorsBase) == NULL)
        return E_OUTOFMEMORY;

    pClone->_iCur = _iCur;

    pClone->_prgAnchors = _prgAnchors;
    pClone->_prgAnchors->_AddRef();

    pClone->_pic = _pic;
    pClone->_pic->AddRef();

    *ppEnum = pClone;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched)
{
    ULONG cFetched;
    CRange *range;
    IAnchor *paPrev;
    IAnchor *pa;
    int iCurOld;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    iCurOld = _iCur;

    if (ulCount > 0 && ppRange == NULL)
        return E_INVALIDARG;

    // special case empty enum, or 1 anchor enum
    if (_prgAnchors->Count() < 2)
    {
        if (_prgAnchors->Count() == 0 || _iCur > 0)
        {
            return S_FALSE;
        }
        // when we have a single anchor in the enum, need to handle it carefully
        if ((range = new CRange) == NULL)
            return E_OUTOFMEMORY;
        if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, _prgAnchors->Get(0), _prgAnchors->Get(0)))
        {
            range->Release();
            return E_FAIL;
        }

        *ppRange = (ITfRangeAnchor *)range;
        *pcFetched = 1;
        _iCur = 1;
        goto Exit;
    }

    paPrev = _prgAnchors->Get(_iCur);

    while (_iCur < _prgAnchors->Count()-1 && *pcFetched < ulCount)
    {
        pa = _prgAnchors->Get(_iCur+1);

        if ((range = new CRange) == NULL)
            goto ErrorExit;
        if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paPrev, pa))
        {
            range->Release();
            goto ErrorExit;
        }

        // we should never be returning empty ranges, since currently this base
        // class is only used for property enums and property spans are never
        // empty.
        // Similarly, paPrev should always precede pa.
        Assert(CompareAnchors(paPrev, pa) < 0);

        *ppRange++ = (ITfRangeAnchor *)range;
        *pcFetched = *pcFetched + 1;
        _iCur++;
        paPrev = pa;
    }

Exit:
    return *pcFetched == ulCount ? S_OK : S_FALSE;

ErrorExit:
    while (--_iCur > iCurOld) // Issue: just return what we have, rather than freeing everything
    {
        (*--ppRange)->Release();
    }
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _prgAnchors->Count()-1) ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\epval.cpp ===
//
// epval.cpp
//
// CEnumPropertyValue
//

#include "private.h"
#include "epval.h"

DBG_ID_INSTANCE(CEnumPropertyValue);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// SHARED_TFPROPERTYVAL_ARRAY
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// SAA_New
//
//----------------------------------------------------------------------------

SHARED_TFPROPERTYVAL_ARRAY *SAA_New(ULONG cAttrVals)
{
    SHARED_TFPROPERTYVAL_ARRAY *paa;

    paa = (SHARED_TFPROPERTYVAL_ARRAY *)cicMemAlloc(sizeof(SHARED_TFPROPERTYVAL_ARRAY)+sizeof(TF_PROPERTYVAL)*cAttrVals-sizeof(TF_PROPERTYVAL));

    if (paa != NULL)
    {
        paa->cRef = 1;
        paa->cAttrVals = cAttrVals;
        // clear out the attrs so VariantClear is safe
        memset(paa->rgAttrVals, 0, cAttrVals*sizeof(TF_PROPERTYVAL));
    }

    return paa;
}

//+---------------------------------------------------------------------------
//
// SAA_Release
//
//----------------------------------------------------------------------------

void SAA_Release(SHARED_TFPROPERTYVAL_ARRAY *paa)
{
    ULONG i;

    Assert(paa->cRef > 0);
    if (--paa->cRef == 0)
    {
        for (i=0; i<paa->cAttrVals; i++)
        {
            VariantClear(&paa->rgAttrVals[i].varValue);
        }
        cicMemFree(paa);
    }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumPropertyValue
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Clone(IEnumTfPropertyValue **ppEnum)
{
    CEnumPropertyValue *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumPropertyValue) == NULL)
        return E_OUTOFMEMORY;

    pClone->_ulCur = _ulCur;

    pClone->_paa = _paa;
    SAA_AddRef(pClone->_paa);

    *ppEnum = pClone;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Next(ULONG ulCount, TF_PROPERTYVAL *prgValues, ULONG *pcFetched)
{
    ULONG cFetched;
    ULONG ulCurOld;
    ULONG ulSize;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    ulCurOld = _ulCur;

    if (ulCount > 0 && prgValues == NULL)
        return E_INVALIDARG;

    ulSize = _paa->cAttrVals;

    while (_ulCur < ulSize && *pcFetched < ulCount)
    {
        QuickVariantInit(&prgValues->varValue);

        prgValues->guidId = _paa->rgAttrVals[_ulCur].guidId;

        if (VariantCopy(&prgValues->varValue, &_paa->rgAttrVals[_ulCur].varValue) != S_OK)
            goto ErrorExit;

        prgValues++;
        *pcFetched = *pcFetched + 1;
        _ulCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;

ErrorExit:
    while (--_ulCur > ulCurOld)
    {
        prgValues--;
        VariantClear(&prgValues->varValue);
    }
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Reset()
{
    _ulCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Skip(ULONG ulCount)
{
    _ulCur += ulCount;
    
    return (_ulCur < _paa->cAttrVals) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\enumss.cpp ===
//
// enumss.cpp
//
// CEnumSpanSetRanges
//

#include "private.h"
#include "enumss.h"
#include "range.h"

DBG_ID_INSTANCE(CEnumSpanSetRanges);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumSpanSetRanges::CEnumSpanSetRanges(CInputContext *pic)
{
    Dbg_MemSetThisNameID(TEXT("CEnumSpanSetRanges"));
    
    _pic = pic;
    _pic->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumSpanSetRanges::~CEnumSpanSetRanges()
{
    _pic->Release();
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Clone(IEnumTfRanges **ppEnum)
{
    CEnumSpanSetRanges *pClone;
    SPAN *pSpanSrc;
    SPAN *pSpanDst;
    int i;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumSpanSetRanges(_pic)) == NULL)
        return E_OUTOFMEMORY;

    pClone->_iCur = _iCur;

    i = 0;

    if (!pClone->_rgSpans.Insert(0, _rgSpans.Count()))
        goto ErrorExit;

    for (; i<_rgSpans.Count(); i++)
    {
        pSpanDst = pClone->_rgSpans.GetPtr(i);
        pSpanSrc = _rgSpans.GetPtr(i);

        pSpanDst->paStart = pSpanDst->paEnd = NULL;

        if (pSpanSrc->paStart->Clone(&pSpanDst->paStart)!= S_OK)
            goto ErrorExit;
        if (pSpanSrc->paEnd->Clone(&pSpanDst->paEnd) != S_OK)
            goto ErrorExit;
        pSpanDst->dwFlags = pSpanSrc->dwFlags;
    }

    *ppEnum = pClone;
    return S_OK;

ErrorExit:
    for (; i>=0; i--)
    {
        pSpanDst = pClone->_rgSpans.GetPtr(i);

        if (pSpanDst != NULL)
        {
            SafeRelease(pSpanDst->paStart);
            SafeRelease(pSpanDst->paEnd);
        }
    }
    pClone->Release();
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched)
{
    ULONG cFetched;
    CRange *range;
    SPAN *pSpan;
    int iCurOld;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    iCurOld = _iCur;

    if (ulCount > 0 && ppRange == NULL)
        return E_INVALIDARG;

    while (_iCur < _rgSpans.Count() && *pcFetched < ulCount)
    {
        pSpan = _rgSpans.GetPtr(_iCur);

        if ((range = new CRange) == NULL)
            goto ErrorExit;
        if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pSpan->paStart, pSpan->paEnd))
        {
            range->Release();
            goto ErrorExit;
        }

        *ppRange++ = (ITfRangeAnchor *)range;
        *pcFetched = *pcFetched + 1;
        _iCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;

ErrorExit:
    while (--_iCur > iCurOld)
    {
        (*--ppRange)->Release();
    }
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _rgSpans.Count()) ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------------------
//
// _Merge
//
//----------------------------------------------------------------------------

void CEnumSpanSetRanges::_Merge(CSpanSet *pss)
{
    int i;
    SPAN *rgSpans;

    //
    // perf: this method could be much more efficient -> O(n log n) -> O(n)
    // we could take advantage of the fact that we are always
    // adding new spans _that are already ordered_.
    //

    // get rid of any NULL/NULL spans -> covers entire doc
    //
    // perf: wait to normalize until all _Merge calls are done!
    //
    if (!pss->Normalize(_pic->_GetTSI()))
    {
        Assert(0); // doh!
        return;
    }

    rgSpans = pss->GetSpans();

    for (i=0; i<pss->GetCount();i++)
    {
        Add(0, rgSpans[i].paStart, rgSpans[i].paEnd, COPY_ANCHORS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\fnrecon.cpp ===
//
// reconv.cpp
//

#include "private.h"
#include "globals.h"
#include "tim.h"
#include "ic.h"
#include "helpers.h"
#include "fnrecon.h"
#include "funcprv.h"
#include "ptrary.h"
#include "immxutil.h"
#include "proputil.h"
#include "rprop.h"
#include "range.h"

//+---------------------------------------------------------------------------
//
// ::GrowEmptyRangeByOne
//
// Helper to enlarge empty ranges by shifting the end anchor + 1.
//
//----------------------------------------------------------------------------

HRESULT GrowEmptyRangeByOne(CInputContext *pic, ITfRange *range)
{
    HRESULT hr = S_OK;

    if (pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_GROWRANGE, range, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
    }

    return hr;
}

HRESULT GrowEmptyRangeByOneCallback(TfEditCookie ec, ITfRange *range)
{
    BOOL fEmpty;
    LONG l;
    HRESULT hr = S_OK;

    //
    // Check the length of the given range.
    // If the given range is 0 length, we try to find the owner of
    // the next char.
    //
    range->IsEmpty(ec, &fEmpty);
    if (fEmpty)
    {
        hr = range->ShiftEnd(ec, +1, &l, NULL);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunction::CFunction(CFunctionProvider *pFuncPrv)
{
    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunction::~CFunction()
{
    SafeRelease(_pFuncPrv);
    CleanUpOwnerRange();
}

//+---------------------------------------------------------------------------
//
// CleanUpOwnerRange
//
//----------------------------------------------------------------------------

void CFunction::CleanUpOwnerRange()
{
    CRangeOwnerList *pRangeOwner;
    while (pRangeOwner = _listRangeOwner.GetFirst())
    {
        _listRangeOwner.Remove(pRangeOwner);
        delete pRangeOwner;
    }
}

//+---------------------------------------------------------------------------
//
// BuildOwnerRangeList
//
//----------------------------------------------------------------------------

BOOL CFunction::BuildOwnerRangeList(CInputContext *pic, ITfRange *pRange)
{
    HRESULT hr = S_OK;
    BUILDOWNERRANGELISTQUEUEINFO qInfo;
    BOOL bRet = TRUE;

    qInfo.pFunc = this;
    qInfo.pRange = pRange;

    if (pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_BUILDOWNERRANGELIST, &qInfo, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
        bRet = FALSE;
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// BuildOwnerRangeListCallback
//
//----------------------------------------------------------------------------

HRESULT CFunction::BuildOwnerRangeListCallback(TfEditCookie ec, CInputContext *pic, ITfRange *pRange)
{
    CProperty *pProp;
    IEnumTfRanges *pEnumPropRange;
    CRange *pRangeP = NULL;
    HRESULT hr = E_FAIL;

    if (pic->_pPropTextOwner == NULL)
        goto ExitOk;

    pProp = pic->_pPropTextOwner;
   
    CleanUpOwnerRange();

    //
    // if pRange is NULL, we build owner list for entire dcoument.
    // we will enumerate all property ranges.
    //
    if (pRange)
    {
        if ((pRangeP = GetCRange_NA(pRange)) == NULL)
            goto Exit;
    }

    if (SUCCEEDED(pProp->EnumRanges(ec, &pEnumPropRange, pRange)))
    {
        ITfRange *pPropRange;
        while (pEnumPropRange->Next(1, &pPropRange, NULL) == S_OK)
        {
            TfGuidAtom guidOwner;
            CRangeOwnerList *pRangeOwner;
            ITfRange *pRangeTmp;
            CRange *pRangeTmpP;
            BOOL bKnownOwner = FALSE;

            pPropRange->Clone(&pRangeTmp);

            GetGUIDPropertyData(ec, pProp, pPropRange, &guidOwner);

            //
            // check if this guidOwner already appeared in the range.
            //
            pRangeOwner = _listRangeOwner.GetFirst();
            while(pRangeOwner)
            {
                if (guidOwner == pRangeOwner->_guidOwner)
                {
                    bKnownOwner = TRUE;
                }
                pRangeOwner = pRangeOwner->GetNext();
            }

            //
            // get CRange.
            //
            if ((pRangeTmpP = GetCRange_NA(pRangeTmp)) == NULL)
                goto NoCRange;

            //
            // if pRangeP is NULL, we build owner list for entire document.
            // So we don't have to adjust pRangeTmp.
            //
            if (pRangeP)
            {
                if (CompareAnchors(pRangeTmpP->_GetStart(), pRangeP->_GetStart()) < 0)
                {
                    // move pRangeTmp's start to match pRange
                    pRangeTmpP->_GetStart()->ShiftTo(pRangeP->_GetStart());
                    // insure pRangeTmp's end is no greater than pRange's end
                    if (CompareAnchors(pRangeTmpP->_GetEnd(), pRangeP->_GetEnd()) > 0)
                    {
                        pRangeTmpP->_GetEnd()->ShiftTo(pRangeP->_GetEnd());
                    }
                }
                else if (CompareAnchors(pRangeTmpP->_GetEnd(), pRangeP->_GetEnd()) > 0)
                {
                    pRangeTmpP->_GetEnd()->ShiftTo(pRangeP->_GetEnd());
                }
            }

            pRangeOwner = new CRangeOwnerList(guidOwner, pRangeTmp, bKnownOwner);
            _listRangeOwner.Add(pRangeOwner);

NoCRange:
            pPropRange->Release();
            pRangeTmp->Release();
        }
        pEnumPropRange->Release();
    }

ExitOk:
    hr = S_OK;

Exit:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnReconversion::CFnReconversion(CFunctionProvider *pFuncPrv) :CFunction(pFuncPrv)
{
    _pReconvCache = NULL;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnReconversion::~CFnReconversion()
{
    SafeRelease(_pReconvCache);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Reconversion");
    return *pbstrName != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::GetReconversion
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList)
{
    if (ppCandList == NULL)
        return E_INVALIDARG;

    *ppCandList = NULL;

    if (pRange == NULL)
        return E_INVALIDARG;

    return Internal_GetReconversion(pRange, ppCandList, NULL, RF_GETRECONVERSION, NULL);
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::QueryRange
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable)
{
    if (ppNewRange != NULL)
    {
        *ppNewRange = NULL;
    }
    if (pfConvertable != NULL)
    {
        *pfConvertable = FALSE;
    }
    if (pRange == NULL ||
        ppNewRange == NULL ||
        pfConvertable == NULL)
    {
        return E_INVALIDARG;
    }

    return Internal_GetReconversion(pRange, NULL, ppNewRange, RF_QUERYRECONVERT, pfConvertable);
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::Reconvert
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::Reconvert(ITfRange *pRange)
{
    if (pRange == NULL)
        return E_INVALIDARG;

    return Internal_GetReconversion(pRange, NULL, NULL, RF_RECONVERT, NULL);
}



//+---------------------------------------------------------------------------
//
// CFnReconversion::Internal_GetReconversion
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::Internal_GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList, ITfRange **ppNewRange, RECONVFUNC rf, BOOL *pfConvertable)
{
    BOOL bReleaseCache = FALSE;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;
    ITfRange *pNewRange = NULL;
    ITfContext *pic = NULL;

    if (FAILED(pRange->Clone(&pRangeTmp)))
        goto Exit;

    if (FAILED(pRangeTmp->GetContext(&pic)))
        goto Exit;

    //
    // when RF_QUERYRECONVERT, we alwasy create new Reconv cache.
    // we will keep using this chace unless another RF_QUERYRECONVERT comes.
    //
    if (rf == RF_QUERYRECONVERT)
        SafeReleaseClear(_pReconvCache);

    if (!_pReconvCache)
    {
        CInputContext *pcic = GetCInputContext(pic);
        if (pcic)
        {
            QueryAndGetFunction(pcic, pRangeTmp, &_pReconvCache, &pNewRange);
            pcic->Release();
        }

        //
        // when it's not RF_QUERYRECONVERT and there was no cache, 
        // we don't hold the reconv cache.
        //
        if (rf != RF_QUERYRECONVERT)
            bReleaseCache = TRUE;
    }

    if (!_pReconvCache)
    {
        hr = S_OK;
        goto Exit;
    }

    switch (rf)
    {
        case RF_GETRECONVERSION:
            if ((hr = _pReconvCache->GetReconversion(pRangeTmp, ppCandList)) != S_OK)
            {
                *ppCandList = NULL;
            }
            break;

        case RF_RECONVERT:
            hr = _pReconvCache->Reconvert(pRangeTmp);
            break;

        case RF_QUERYRECONVERT:
            if (!pNewRange)
            {
                if ((hr = _pReconvCache->QueryRange(pRangeTmp, ppNewRange, pfConvertable)) != S_OK)
                {
                    *ppNewRange = NULL;
                    *pfConvertable = FALSE;
                }
            }
            else
            {
                *ppNewRange = pNewRange;
                (*ppNewRange)->AddRef();
                *pfConvertable = TRUE;
                hr = S_OK;
            }
            break;
    }

    Assert(hr == S_OK);

Exit:
    if (bReleaseCache || FAILED(hr))
        SafeReleaseClear(_pReconvCache);

    SafeRelease(pRangeTmp);
    SafeRelease(pNewRange);
    SafeRelease(pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::QueryAndGetFunction(CInputContext *pic, ITfRange *pRange, ITfFnReconversion **ppFunc, ITfRange **ppRange)
{
    IEnumTfFunctionProviders *pEnumFuncPrv;
    ITfFunctionProvider *pFuncPrv;
    CRangeOwnerList *pRangeOwner;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;
    CThreadInputMgr *ptim;

    *ppFunc = NULL;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        goto Exit;

    if (pRange)
    {
        //
        // To find the properr function provider, we use pRangeTmp.
        //
        if (FAILED(pRange->Clone(&pRangeTmp)))
            goto Exit;

        //
        // Check the length of the given range.
        // If the given range is 0 length, we try to find the owner of
        // the next char.
        //
        if (GrowEmptyRangeByOne(pic, pRangeTmp) != S_OK)
            goto Exit;
    }

    if (!BuildOwnerRangeList(pic, pRangeTmp))
        goto Exit;

    pRangeOwner = _listRangeOwner.GetFirst();

    if (pRangeOwner)
    {
        GUID guid;

        if (SUCCEEDED(MyGetGUID(pRangeOwner->_guidOwner, &guid)))
        {
            CTip *ptip;

            //
            // A way to get the TextOwner's reconversion function.
            //
            //   - find a function provider of the ower.
            //   - Do QI the text owner TIP.
            //   - CoCreate the text onwer CLSID.
            //
            if (SUCCEEDED(ptim->GetFunctionProvider(guid, &pFuncPrv)))
            {
                hr = pFuncPrv->GetFunction(GUID_NULL, 
                                           IID_ITfFnReconversion, 
                                           (IUnknown **)ppFunc);

                SafeReleaseClear(pFuncPrv);
            }
            else if (ptim->_GetCTipfromGUIDATOM(pRangeOwner->_guidOwner, &ptip) && ptip->_pTip)
            {
                hr = ptip->_pTip->QueryInterface(IID_ITfFnReconversion, 
                                                 (void **)ppFunc);
            }
            else 
            {
                hr = CoCreateInstance(guid,
                                      NULL, 
                                      CLSCTX_INPROC_SERVER, 
                                      IID_ITfFnReconversion, 
                                      (void**)ppFunc);
                
            }

            if (FAILED(hr))
                *ppFunc = NULL;
        }
    }

    //
    // if there is no owner or the owner of the first range does not
    // have ITfFunction, we may find someone who has 
    // ITfFunction.
    //
    if (!(*ppFunc) && 
        SUCCEEDED(ptim->EnumFunctionProviders(&pEnumFuncPrv)))
    {
        while (!(*ppFunc) && pEnumFuncPrv->Next(1, &pFuncPrv, NULL) == S_OK)
        {
            GUID guid;

            BOOL fSkip = TRUE;
            if (SUCCEEDED(pFuncPrv->GetType(&guid)))
            {
                 if (!IsEqualGUID(guid, GUID_SYSTEM_FUNCTIONPROVIDER))
                     fSkip = FALSE;
            }

            if(!fSkip)
            {
                hr = pFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)ppFunc);

                if ((SUCCEEDED(hr) && *ppFunc))
                {
                    BOOL fConvertable = FALSE;
                    hr = (*ppFunc)->QueryRange(pRange, ppRange, &fConvertable);
                    if (FAILED(hr) || !fConvertable)
                    {
                       (*ppFunc)->Release();
                       *ppFunc = NULL;
                    }
                }                
            }
            SafeReleaseClear(pFuncPrv);
        }
        pEnumFuncPrv->Release();
    }

Exit:
    SafeRelease(pRangeTmp);
    return (*ppFunc) ? S_OK : E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnAbort::CFnAbort(CFunctionProvider *pFuncPrv) : CFunction(pFuncPrv)
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnAbort::~CFnAbort()
{
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Abort");
    return *pbstrName != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// CFnAbort::Abort
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::Abort(ITfContext *pic)
{
    CThreadInputMgr *ptim;
    HRESULT hr = E_FAIL;
    int i;
    int nCnt;

    if (!pic)
        return E_INVALIDARG;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        goto Exit;

    //
    // notify all tips with ITfFnAbort to abort any pending conversion.
    //
    nCnt = ptim->_GetTIPCount();
    for (i = 0; i < nCnt; i++)
    {
        ITfFnAbort *pAbort;
        const CTip *ptip = ptim->_GetCTip(i);

        if (!ptip->_pFuncProvider)
            continue;

        if (SUCCEEDED(ptip->_pFuncProvider->GetFunction(GUID_NULL, 
                                                        IID_ITfFnAbort, 
                                                        (IUnknown  **)&pAbort)))
        {
            pAbort->Abort(pic);
            pAbort->Release();
        }
    }

    hr = S_OK;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\epval.h ===
//
// epval.h
//
// CEnumPropertyValBase
//

#ifndef EPVAL_H
#define EPVAL_H

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// SHARED_TFPROPERTYVAL_ARRAY
//
// I would love to make this a class,
// but I can't get the compiler to accept a run-time template arg
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef struct _SHARED_TFPROPERTYVAL_ARRAY
{
    ULONG cRef;
    ULONG cAttrVals;
    TF_PROPERTYVAL rgAttrVals[1]; // 1 or more...
} SHARED_TFPROPERTYVAL_ARRAY;

SHARED_TFPROPERTYVAL_ARRAY *SAA_New(ULONG cAttrVals);

inline void SAA_AddRef(SHARED_TFPROPERTYVAL_ARRAY *paa)
{
    paa->cRef++;
}

void SAA_Release(SHARED_TFPROPERTYVAL_ARRAY *paa);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumPropertyValue
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumPropertyValue : public IEnumTfPropertyValue,
                           public CComObjectRootImmx
{
public:
    CEnumPropertyValue(SHARED_TFPROPERTYVAL_ARRAY *paa) 
    {
        Dbg_MemSetThisNameID(TEXT("CEnumPropertyValue"));
        Assert(_ulCur == 0);
        _paa = paa;
        SAA_AddRef(paa);
    }
    ~CEnumPropertyValue()
    { 
        if (_paa != NULL)
        {
            SAA_Release(_paa);
        }
    }

    BEGIN_COM_MAP_IMMX(CEnumPropertyValue)
        COM_INTERFACE_ENTRY(IEnumTfPropertyValue)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // IEnumTfAppPropertyValue
    STDMETHODIMP Clone(IEnumTfPropertyValue **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, TF_PROPERTYVAL *rgValues, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    CEnumPropertyValue() { Dbg_MemSetThisNameID(TEXT("CEnumPropertyValue")); }

    ULONG _ulCur;
    SHARED_TFPROPERTYVAL_ARRAY *_paa;
    DBG_ID_DECLARE;
};

#endif // EPVAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\fnrecon.h ===
//
// fnrecon.h
//

#ifndef FNRECON_H
#define FNRECON_H

#include "private.h"
#include "immlist.h"
#include "ctffunc.h"

class CFunctionProvider;
class CEditSession;
class CRange;
class CInputContext;

HRESULT GrowEmptyRangeByOneCallback(TfEditCookie ec, ITfRange *range);

class CFunction;

typedef struct tag_BUILDOWNERRANGELISTQUEUEINFO
{
    CFunction *pFunc;
    ITfRange *pRange; 
} BUILDOWNERRANGELISTQUEUEINFO;

//
// for PSEUDO_ESCB_SHIFTENDTORANGE
//
typedef struct tag_SHIFTENDTORANGEQUEUEITEM
{
    ITfRange *pRange;
    ITfRange *pRangeTo;
    TfAnchor aPos;
} SHIFTENDTORANGEQUEUEITEM;

//
// for PSEUDO_ESCB_GETSELECTION
//
typedef struct tag_GETSELECTIONQUEUEITEM
{
    ITfRange **ppRange;
} GETSELECTIONQUEUEITEM;

//
// for PSEUDO_ESCB_GETWHOLEDOCRANGE
//
typedef struct tag_GETWHOLEDOCRANGE
{
    ITfRange **ppRange;
} GETWHOLEDOCRANGE;

//////////////////////////////////////////////////////////////////////////////
//
// CRangeOwnerList
//
//////////////////////////////////////////////////////////////////////////////

class CRangeOwnerList : public CPtrCicListItem<CRangeOwnerList>
{
public:
     CRangeOwnerList(TfGuidAtom guidOwner, ITfRange *pRange, BOOL bDupOwner) 
     {
         _pRange = pRange;
         _pRange->AddRef();
         _guidOwner = guidOwner;
         _bDupOwner = bDupOwner;
     }

     ~CRangeOwnerList()
     {
         _pRange->Release();
         SafeRelease(_pConvRange);
     }

     ITfRange *_pRange;
     TfGuidAtom _guidOwner;
     BOOL _bDupOwner;
     ITfRange *_pConvRange;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CFunction : public CComObjectRootImmx
{
public:
    CFunction(CFunctionProvider *pFuncPrv);
    ~CFunction();

    HRESULT BuildOwnerRangeListCallback(TfEditCookie ec, CInputContext *pic, ITfRange *pRange);
protected:
    void CleanUpOwnerRange();
    BOOL BuildOwnerRangeList(CInputContext *pic, ITfRange *pRange);


    CFunctionProvider *_pFuncPrv;
    CPtrCicList<CRangeOwnerList> _listRangeOwner;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

class CFnReconversion : public ITfFnReconversion,
                        public CFunction
{
public:
    CFnReconversion(CFunctionProvider *pFuncPrv);
    ~CFnReconversion();

    BEGIN_COM_MAP_IMMX(CFnReconversion)
        COM_INTERFACE_ENTRY(ITfFnReconversion)
        COM_INTERFACE_ENTRY(ITfFunction)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnReconversion
    //
    STDMETHODIMP GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList);
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable);
    STDMETHODIMP Reconvert(ITfRange *pRange);


private:
    typedef enum { RF_GETRECONVERSION,
                   RF_RECONVERT,
                   RF_QUERYRECONVERT } RECONVFUNC;
    HRESULT Internal_GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList, ITfRange **ppNewRange, RECONVFUNC rf, BOOL *pfConvertable);
    HRESULT QueryAndGetFunction(CInputContext *pic, ITfRange *pRange, ITfFnReconversion **ppFunc, ITfRange **ppRange);

    ITfFnReconversion *_pReconvCache;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

class CFnAbort : public ITfFnAbort,
                 public CFunction
{
public:
    CFnAbort(CFunctionProvider *pFuncPrv);
    ~CFnAbort();

    BEGIN_COM_MAP_IMMX(CFnAbort)
        COM_INTERFACE_ENTRY(ITfFnAbort)
        COM_INTERFACE_ENTRY(ITfFunction)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnAbort
    //
    STDMETHODIMP Abort(ITfContext *pic);
};

#endif // FNRECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\funcprv.h ===
//
// funcprv.h
//

#ifndef FUNCPRV_H
#define FUNCPRV_H

#include "private.h"

class CInputContext;

class CFunctionProvider : public ITfFunctionProvider,
                          public CComObjectRootImmx
{
public:
    CFunctionProvider();
    ~CFunctionProvider();

    BEGIN_COM_MAP_IMMX(CFunctionProvider)
        COM_INTERFACE_ENTRY(ITfFunctionProvider)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfFunctionProvider
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

private:
    DWORD _dwCookie;

    long _cRef;
    DBG_ID_DECLARE;
};

#endif // FUNCPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\gcompart.h ===
//
// gcompart.h
//

#ifndef GCOMPART_H
#define GCOMPART_H

#include "private.h"
#include "tfprop.h"
#include "smblock.h"

#define INITIAL_GCOMPART_SIZE 0x10000

class CGCompartList;
extern CGCompartList g_gcomplist;

#define CALCID(pgc, pgcl) (DWORD)(DWORD_PTR)((BYTE *)pgc - (BYTE *)&pgcl->rgGCompart[0]) / sizeof(GLOBALCOMPARTMENT)

class CGCompartList
{
public:
    void CleanUp()
    {
        if (_psb)
            delete _psb;

        _psb = NULL;
    }

    BOOL Enter()
    {
        if (!_psb || !_psb->GetBase())
            return FALSE;
        
        if (ISINDLLMAIN())
            return TRUE;

        if (!_psb->GetMutex() || !_psb->GetMutex()->Enter())
            return FALSE;

        return TRUE;
    }

    void Leave()
    {
        if (ISINDLLMAIN())
            return;

        _psb->GetMutex()->Leave();
    }

    typedef struct tag_GLOBALCOMPARTMENTPROP {
         TfPropertyType type;
         union {
             GUID guid;
             DWORD dw;
         };
    } GLOBALCOMPARTMENTPROP;

    typedef struct tag_GLOBALCOMPARTMENT {
         GUID guid;
         DWORD dwId;
         LONG cRef;
         GLOBALCOMPARTMENTPROP gprop;
    } GLOBALCOMPARTMENT;

    typedef struct tag_GLOBALCOMPARTMENTLIST {
        ULONG ulNum;
        GLOBALCOMPARTMENT rgGCompart[1];
    } GLOBALCOMPARTMENTLIST;

    BOOL Init(SYSTHREAD *psfn);
    BOOL Start();
    BOOL Uninit(SYSTHREAD *psfn);
    DWORD SetProperty(REFGUID guid, TFPROPERTY *pProp);
    BOOL GetProperty(REFGUID guid, TFPROPERTY *pProp);
    DWORD GetId(REFGUID guid);

private:
    GLOBALCOMPARTMENT *FindProperty(REFGUID guid);

    static CSharedBlock *_psb;
    static ULONG _ulCommitSize;
    static LONG _nRef;
    static BOOL _fCreate;
};


#endif // GCOMPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\gcompart.cpp ===
//
// gcompart.cpp
//

#include "private.h"
#include "globals.h"
#include "gcompart.h"
#include "cregkey.h"
#include "thdutil.h"
#include "regsvr.h"

CGCompartList g_gcomplist;

CSharedBlock *CGCompartList::_psb = NULL;
ULONG CGCompartList::_ulCommitSize = INITIAL_GCOMPART_SIZE;
LONG CGCompartList::_nRef = -1;
BOOL CGCompartList::_fCreate = FALSE;

//////////////////////////////////////////////////////////////////////////////
//
// CGCompartList
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

BOOL CGCompartList::Init(SYSTHREAD *psfn)
{
    static const char c_szGCompartList[] = "MSCTF.GCompartList";
    BOOL bRet = FALSE;
    BOOL bAlreadyExist = FALSE;


    if (!psfn)
        return FALSE;

    Assert(!psfn->fInitGlobalCompartment);

    CicEnterCriticalSection(g_csInDllMain);

    if (++_nRef)
    {
        bRet = TRUE;
        goto Exit;
    }

    _psb = new CSharedBlockNT(c_szGCompartList, 0, TRUE);

    if (!_psb)
    {
        Assert(0);
        goto Exit;
    }

    HRESULT hr = _psb->Init(NULL, 0x40000, _ulCommitSize, NULL, TRUE, &bAlreadyExist);
    if (FAILED(hr))
    {
        Assert(0);
        goto Exit;
    }

    if (!bAlreadyExist)
    {
       Start();
    }

    bRet = TRUE;
Exit:
    if (!bRet)
    {
        _nRef--;
        if (_psb)
            delete _psb;

        _psb = NULL;
    }

    CicLeaveCriticalSection(g_csInDllMain);

    if (bRet)
        psfn->fInitGlobalCompartment = TRUE;

    return bRet;
}

//--------------------------------------------------------------------------
//
//  Start
//
//--------------------------------------------------------------------------

BOOL CGCompartList::Start()
{
    GLOBALCOMPARTMENTLIST *pgcl;

    if (!_psb)
    {
        Assert(0);
        return FALSE;
    }

    _fCreate = TRUE;
    CMyRegKey key;
    CMyRegKey keyLM;
    DWORD ulNum = 0;
    char szSubKey[MAX_PATH];
    pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();

    keyLM.Open(HKEY_LOCAL_MACHINE, c_szCompartKey, KEY_READ);

    if (key.Open(HKEY_CURRENT_USER, c_szCompartKey, KEY_READ) == S_OK)
    {
        DWORD dwIndex = 0;
        while (key.EnumKey(dwIndex, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
        {
            CMyRegKey subkey;
            CMyRegKey subkeyLM;
            CLSID clsid;
            if (!StringAToCLSID(szSubKey, &clsid))
               continue;

            DWORD dwReqSize = ((ulNum + 1) * sizeof(GLOBALCOMPARTMENT)) +
                              sizeof(GLOBALCOMPARTMENTLIST);

            if (_ulCommitSize < dwReqSize)
            {
                dwReqSize *= 2;
                if (FAILED(_psb->Commit(dwReqSize)))
                    goto Exit;

                _ulCommitSize = dwReqSize;
            }

            if (subkey.Open(key, szSubKey, KEY_READ) == S_OK)
            {
                DWORD dwNonInit = 0;
                if ((HKEY)keyLM && 
                    subkeyLM.Open(keyLM, szSubKey, KEY_READ) == S_OK)
                {
                    if (subkeyLM.QueryValue(dwNonInit, c_szNonInit) != S_OK)
                        dwNonInit = 0;
                }

                if (!dwNonInit)
                {
                    GLOBALCOMPARTMENT *pgc = &pgcl->rgGCompart[ulNum];
                    DWORD dwCount = sizeof(GLOBALCOMPARTMENT);
                    if (subkey.QueryBinaryValue(pgc, 
                                            dwCount,
                                            c_szGlobalCompartment) == S_OK)
                        ulNum++;
                }

            }

            dwIndex++;
        }
    }
    pgcl->ulNum = ulNum;

Exit:
    return TRUE;
}

//--------------------------------------------------------------------------
//
//  UnInit
//
//--------------------------------------------------------------------------

BOOL CGCompartList::Uninit(SYSTHREAD *psfn)
{
    if (!psfn)
        return FALSE;

    if (!_psb)
        return TRUE;

    if (_fCreate)
    {
        CMyRegKey key;
        if (key.Create(HKEY_CURRENT_USER, c_szCompartKey) == S_OK)
        {
            char szSubKey[MAX_PATH];
            ULONG i;
            GLOBALCOMPARTMENTLIST *pgcl;

            pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();

            for (i = 0; i < pgcl->ulNum; i++)
            {
                GLOBALCOMPARTMENT *pgc = &pgcl->rgGCompart[i];
                CMyRegKey subkey;
                CLSIDToStringA(pgc->guid, szSubKey);
                if (subkey.Create(key, szSubKey) == S_OK)
                {
                    subkey.SetBinaryValue(pgc, 
                                          sizeof(GLOBALCOMPARTMENT), 
                                          c_szGlobalCompartment);
                }
            }
        }
    }

    if (!psfn->fInitGlobalCompartment)
        return TRUE;

    CicEnterCriticalSection(g_csInDllMain);

    if (--_nRef >= 0)
        goto Exit;

    if (_psb)
        delete _psb;

    _psb = NULL;

Exit:
    CicLeaveCriticalSection(g_csInDllMain);

    psfn->fInitGlobalCompartment = FALSE;

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  SetProperty
//
//--------------------------------------------------------------------------

CGCompartList::GLOBALCOMPARTMENT *CGCompartList::FindProperty(REFGUID guid)
{
    GLOBALCOMPARTMENTLIST *pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();
    UINT i;
    GLOBALCOMPARTMENT *pgc = NULL;

    if (!pgcl)
    {
        Assert(0);
        return NULL;
    }

    for (i = 0; i < pgcl->ulNum; i++)
    {
        GLOBALCOMPARTMENT *pgcTemp = &pgcl->rgGCompart[i];
        if (IsEqualGUID(pgcTemp->guid, guid))
        {
            pgc = pgcTemp;
            break;
        }
    }

    return pgc;
}

//--------------------------------------------------------------------------
//
//  SetProperty
//
//--------------------------------------------------------------------------

DWORD CGCompartList::SetProperty(REFGUID guid, TFPROPERTY *pProp)
{
    DWORD dwRet = (DWORD)(-1);
    GLOBALCOMPARTMENTLIST *pgcl;
    GLOBALCOMPARTMENT *pgc;

    if (!Enter())
        return dwRet;

    pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();
    if (!pgcl)
    {
        Assert(0);
        return dwRet;
    }

    pgc = FindProperty(guid);

    if (!pgc)
    {

        if (_ulCommitSize <  sizeof(GLOBALCOMPARTMENTLIST) + (pgcl->ulNum * sizeof(DWORD)))
        {
            _ulCommitSize = sizeof(GLOBALCOMPARTMENTLIST) + (pgcl->ulNum * sizeof(DWORD));
            _ulCommitSize += INITIAL_GCOMPART_SIZE;
            if (FAILED(_psb->Commit(_ulCommitSize)))
            {
                Assert(0);
                goto Exit;
            }
        }
        pgc = &pgcl->rgGCompart[pgcl->ulNum];
        pgc->guid = guid;
        pgcl->ulNum++;
    }

    pgc->gprop.type = pProp->type;
    switch (pgc->gprop.type)
    {
        case TF_PT_DWORD:
             pgc->gprop.dw = pProp->dw;
             break;

        case TF_PT_GUID:
             MyGetGUID(pProp->guidatom, &pgc->gprop.guid);
             break;

        case TF_PT_NONE:
             break;

        default:
             Assert(0);
             break;
    }

    dwRet = CALCID(pgc, pgcl);
    
Exit:
    Leave();
    return dwRet;
}

//--------------------------------------------------------------------------
//
//  GetProperty
//
//--------------------------------------------------------------------------

BOOL CGCompartList::GetProperty(REFGUID guid, TFPROPERTY *pProp)
{
    BOOL bRet = FALSE;
    GLOBALCOMPARTMENT *pgc;

    if (!Enter())
        return bRet;

    pgc = FindProperty(guid);

    if (!pgc)
    {
        goto Exit;
    }

    pProp->type = pgc->gprop.type;
    switch (pgc->gprop.type)
    {
        case TF_PT_DWORD:
             pProp->dw = pgc->gprop.dw;
             break;

        case TF_PT_GUID:
             MyRegisterGUID(pgc->gprop.guid, &pProp->guidatom);
             break;

        case TF_PT_NONE:
             break;

        default:
             Assert(0);
             break;
    }
    
    bRet = TRUE;
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetId
//
//--------------------------------------------------------------------------

DWORD CGCompartList::GetId(REFGUID guid)
{
    DWORD dwRet = (DWORD)(-1);
    GLOBALCOMPARTMENTLIST *pgcl;
    GLOBALCOMPARTMENT *pgc;

    if (!Enter())
        return dwRet;

    pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();
    pgc = FindProperty(guid);

    if (pgc)
    {
        dwRet = CALCID(pgc, pgcl);
    }

    Leave();
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\hotkey.cpp ===
//
// hotkey.cpp
//

#include "private.h"
#include "tim.h"
#include "dim.h"
#include "ic.h"
#include "hotkey.h"
#include "nuictrl.h"
#include "nuihkl.h"
#include "cregkey.h"
#include "ime.h"
#include "ctffunc.h"
#include "profiles.h"


#define TF_MOD_ALL (TF_MOD_ALT |                    \
                    TF_MOD_CONTROL |                \
                    TF_MOD_SHIFT |                  \
                    TF_MOD_RALT |                   \
                    TF_MOD_RCONTROL |               \
                    TF_MOD_RSHIFT |                 \
                    TF_MOD_LALT |                   \
                    TF_MOD_LCONTROL |               \
                    TF_MOD_LSHIFT |                 \
                    TF_MOD_ON_KEYUP |               \
                    TF_MOD_IGNORE_ALL_MODIFIER |    \
                    TF_MOD_WIN |                    \
                    TF_MOD_LWIN |                   \
                    TF_MOD_RWIN)

static const TCHAR c_szKbdToggleKey[]  = TEXT("Keyboard Layout\\Toggle");
static const TCHAR c_szHotKey[] = TEXT("Control Panel\\Input Method\\Hot Keys");
static const TCHAR c_szModifiers[] = TEXT("Key Modifiers");
static const TCHAR c_szVKey[] = TEXT("Virtual Key");

UINT g_uLangHotKeyModifiers = 0;
UINT g_uLangHotKeyVKey[2] = {0,0};
UINT g_uKeyTipHotKeyModifiers = 0;
UINT g_uKeyTipHotKeyVKey[2] = {0,0};
UINT g_uModifiers = 0;

#define CHSLANGID MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)
#define CHTLANGID MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)

//
// default IMM32 hotkeys.
//
// we use these default hotkey values if there is no entry in
// HKCU\Control Panel\Input Method\Hot Keys.
//
//

IMM32HOTKEY   g_ImmHotKeys411[] = {
 {IME_JHOTKEY_CLOSE_OPEN             , VK_KANJI, TF_MOD_IGNORE_ALL_MODIFIER, FALSE},
 {0                                  ,  0,  0, FALSE}
};

IMM32HOTKEY   g_ImmHotKeys412[] = {
 {IME_KHOTKEY_SHAPE_TOGGLE           , -1, -1, FALSE},
 {IME_KHOTKEY_HANJACONVERT           , -1, -1, FALSE},
 {IME_KHOTKEY_ENGLISH                , -1, -1, FALSE},
 {0                                  ,  0,  0, FALSE}
};

IMM32HOTKEY   g_ImmHotKeys804[] = {
 {IME_CHOTKEY_IME_NONIME_TOGGLE      , VK_SPACE, TF_MOD_CONTROL, FALSE},
 {IME_CHOTKEY_SHAPE_TOGGLE           , VK_SPACE, TF_MOD_SHIFT,   FALSE},
 {IME_CHOTKEY_SYMBOL_TOGGLE          , -1, -1, FALSE},
 {0                                  ,  0,  0, FALSE}
};

IMM32HOTKEY   g_ImmHotKeys404[] = {
 {IME_THOTKEY_IME_NONIME_TOGGLE      , VK_SPACE, TF_MOD_CONTROL, FALSE},
 {IME_THOTKEY_SHAPE_TOGGLE           , VK_SPACE, TF_MOD_SHIFT,   FALSE},
 {IME_THOTKEY_SYMBOL_TOGGLE          , -1, -1, FALSE},
 {IME_ITHOTKEY_RESEND_RESULTSTR      , -1, -1, FALSE},
 {IME_ITHOTKEY_PREVIOUS_COMPOSITION  , -1, -1, FALSE},
 {IME_ITHOTKEY_UISTYLE_TOGGLE        , -1, -1, FALSE},
 {IME_ITHOTKEY_RECONVERTSTRING       , -1, -1, FALSE},
 {0                                  ,  0,  0, FALSE}
};

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncProcessHotKeyQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncProcessHotKeyQueueItem : public CAsyncQueueItem
{
public:
    CAsyncProcessHotKeyQueueItem(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest, BOOL fSync) : CAsyncQueueItem(fSync)
    {
        _wParam = wParam;
        _lParam = lParam;
        _tsh = tsh;
        _fTest = fTest;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
        if (!ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        ptim->_SyncProcessHotKey(_wParam, _lParam, _tsh, _fTest);
        return S_OK;
    }

private:
    WPARAM _wParam;
    LPARAM _lParam;
    TimSysHotkey _tsh;
    BOOL _fTest;
};

//////////////////////////////////////////////////////////////////////////////
//
// MSCTF default hotkeys.
//
//////////////////////////////////////////////////////////////////////////////

typedef struct tag_DEFAULTHOTKEY
{
    const GUID   *pguid;
    UINT         uId;
    TF_PRESERVEDKEY prekey;
    TfGuidAtom   guidatom;
} DEFAULTHOTKEY;

/* 61847d8e-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_CORRECTION = { 
    0x61847d8e,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 61847d8f-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_VOICE = { 
    0x61847d8f,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 61847d90-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_TOGGLE = { 
    0x61847d90,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 61847d91-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_HANDWRITE = {
    0x61847d91,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

#define DHID_CORRECTION 0
#define DHID_VOICE      1
#define DHID_TOGGLE     2
#define DHID_HANDWRITE  3
#define DEFHOTKEYNUM    4

DEFAULTHOTKEY g_DefHotKeys[] = {
    {&GUID_DEFHOTKEY_CORRECTION,  DHID_CORRECTION, {'C',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
    {&GUID_DEFHOTKEY_VOICE,       DHID_VOICE,      {'V',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
    {&GUID_DEFHOTKEY_TOGGLE,      DHID_TOGGLE,     {'T',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
    {&GUID_DEFHOTKEY_HANDWRITE,   DHID_HANDWRITE,  {'H',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
};


//+---------------------------------------------------------------------------
//
// InitDefaultHotkeys
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::InitDefaultHotkeys()
{
    int i;
   
    for (i = 0; i < DEFHOTKEYNUM; i++)
    {
        CHotKey *pHotKey;
        HRESULT hr;
        hr = InternalPreserveKey(NULL, 
                            *g_DefHotKeys[i].pguid,
                            &g_DefHotKeys[i].prekey,
                            NULL, 0, 0, &pHotKey);

        if (SUCCEEDED(hr) && pHotKey)
            g_DefHotKeys[i].guidatom = pHotKey->_guidatom;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UninitDefaultHotkeys
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::UninitDefaultHotkeys()
{
    int i;
    for (i = 0; i < DEFHOTKEYNUM; i++)
    {
        UnpreserveKey(*g_DefHotKeys[i].pguid,
                      &g_DefHotKeys[i].prekey);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// PreserveKey
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::PreserveKey(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    return InternalPreserveKey(ctip, rguid, pprekey, pchDesc, cchDesc, 0, NULL);
}

//+---------------------------------------------------------------------------
//
// PreserveKeyEx
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::PreserveKeyEx(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    return InternalPreserveKey(ctip, rguid, pprekey, pchDesc, cchDesc, dwFlags, NULL);
}

//+---------------------------------------------------------------------------
//
// InternalPreserveKey
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::InternalPreserveKey(CTip *ctip, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags, CHotKey **ppHotKey)
{
    CHotKey *pHotKey = NULL;
    int nCnt;
    HRESULT hr = E_FAIL;

    if (!pprekey)
        return E_INVALIDARG;

    if (pprekey->uVKey > 0xff)
    {
        hr =  E_INVALIDARG;
        goto Exit;
    }

    if (ctip && _IsThisHotKey(ctip->_guidatom, pprekey))
    {
        hr =  TF_E_ALREADY_EXISTS;
        goto Exit;
    }

    if (!(pHotKey = new CHotKey()))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pHotKey->Init(ctip ? ctip->_guidatom : g_gaSystem, pprekey, rguid, dwFlags))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!pHotKey->SetDesc(pchDesc, cchDesc))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!_rgHotKey[pprekey->uVKey])
    {
        if (!(_rgHotKey[pprekey->uVKey] = new CPtrArray<CHotKey>))
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    //
    // Insert this to VKey list
    //
    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    if (!_rgHotKey[pprekey->uVKey]->Insert(nCnt, 1))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    _rgHotKey[pprekey->uVKey]->Set(nCnt, pHotKey);

    //
    // Insert this to CTip list
    //
    if (ctip)
    {
        nCnt = ctip->_rgHotKey.Count();
        if (!ctip->_rgHotKey.Insert(nCnt, 1))
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ctip->_rgHotKey.Set(nCnt, pHotKey);
    }

    hr = S_OK;
    _OnPreservedKeyUpdate(pHotKey);

Exit:
    if (pHotKey && (hr != S_OK))
    {
        delete pHotKey;
    }

    if (ppHotKey)
        *ppHotKey = (hr == S_OK) ? pHotKey : NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
// _IsThisHotKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_IsThisHotKey(TfClientId tid, const TF_PRESERVEDKEY *pprekey)
{
    int nCnt;
    int i;

    if (!_rgHotKey[pprekey->uVKey])
        return FALSE;
    
    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    for (i = 0; i < nCnt; i++)
    {
        CHotKey *pHotKey;
        pHotKey = _rgHotKey[pprekey->uVKey]->Get(i);
        Assert(pHotKey);
        Assert(pHotKey->_prekey.uVKey == pprekey->uVKey);

        if (!pHotKey->IsValidTID(tid))
            continue;

        if (pHotKey->_prekey.uModifiers == pprekey->uModifiers)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// UnregisterHotKey
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::UnpreserveKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey)
{
    int i;
    BOOL bFound = FALSE;
    HRESULT hr = CONNECT_E_NOCONNECTION;
    CTip *ctip = NULL;
    TfGuidAtom guidatom;
    CHotKey *pHotKey = NULL;
    int nCnt;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return E_INVALIDARG;

    if (!_rgHotKey[pprekey->uVKey])
        return hr;

    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    Assert(nCnt); // this should not be 0.

    for (i = 0; i < nCnt; i++)
    {
        pHotKey = _rgHotKey[pprekey->uVKey]->Get(i);

        if (pHotKey->_guidatom == guidatom)
        {
            //
            // Remove this from VKey list.
            //
            _rgHotKey[pprekey->uVKey]->Remove(i, 1);

            if (!ctip && (pHotKey->GetTID() != g_gaSystem))
                _GetCTipfromGUIDATOM(pHotKey->GetTID(), &ctip);

            //
            // Remove this from CTip list.
            //
            if (ctip)
            {
                int nCntTid = ctip->_rgHotKey.Count();
                int k;
                for (k = 0; k < nCntTid; k++)
                {
                    if (pHotKey == ctip->_rgHotKey.Get(k))
                    {
                         ctip->_rgHotKey.Remove(k, 1);
                         break;
                    }
                }
            }

            // 
            // if there is no hotkey in this vkey, delete ptrary.
            // 
            if (!_rgHotKey[pprekey->uVKey]->Count())
            {
                delete _rgHotKey[pprekey->uVKey];
                _rgHotKey[pprekey->uVKey] = NULL;
            }

            // 
            // make a notification.
            // 
            _OnPreservedKeyUpdate(pHotKey);

            // 
            // delete it.
            // 
            delete pHotKey;

            hr = S_OK;
            break;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// _ProcessHotKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_ProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest, BOOL fSync)
{
    UINT uVKey = (UINT)wParam & 0xff;
    CAsyncProcessHotKeyQueueItem *pAsyncProcessHotKeyQueueItem;
    CHotKey *pHotKey;
    BOOL bRet;
    HRESULT hr;

    if (!_rgHotKey[uVKey])
        return FALSE;
    
    if (!_FindHotKeyByTID(TF_INVALID_GUIDATOM, 
                          wParam, 
                          lParam, 
                          &pHotKey, 
                          tsh, 
                          g_uModifiers))
        return FALSE;

    if (!pHotKey)
        return FALSE;

    if (!pHotKey->IsNoDimNeeded() && !_pFocusDocInputMgr)
        return FALSE;

    if (!_pFocusDocInputMgr || (_pFocusDocInputMgr->_GetCurrentStack() < 0))
    {
        //
        // we may need to invoke system hotkey under Empty DIM.
        //
        BOOL fEaten = FALSE;

        if (fTest)
            fEaten = TRUE;
        else
        {
            GUID guid;
            if (SUCCEEDED(MyGetGUID(pHotKey->_guidatom, &guid)))
                _CallSimulatePreservedKey(pHotKey, NULL, guid, &fEaten);
        }

        return fEaten;
    }

    //
    // Issue:
    //
    // We don't know which IC in the focus DIM will handle the hotkey yet.
    // because the selection is changed by the application so we need to get ec
    // to update the current selection pos. We do call GetSelection
    // inside the root IC's lock. So it might be failed if hotkey's target
    // is TOP IC.
    //
    CInputContext *pic = _pFocusDocInputMgr->_GetIC(0);

    pAsyncProcessHotKeyQueueItem = new CAsyncProcessHotKeyQueueItem(wParam, lParam, tsh, fTest, fSync);
    if (!pAsyncProcessHotKeyQueueItem)
        return FALSE;
    
    hr = S_OK;

    bRet = TRUE;
    if ((pic->_QueueItem(pAsyncProcessHotKeyQueueItem->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
    {
        Assert(0);
        bRet = FALSE;
    }

    pAsyncProcessHotKeyQueueItem->_Release();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// _SyncProcessHotKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_SyncProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest)
{
    CHotKey *pHotKey;
    CInputContext *pic;
    UINT uVKey = (UINT)wParam & 0xff;
    BOOL fEaten = FALSE;

    if (!_pFocusDocInputMgr)
        return FALSE;

    if (!_rgHotKey[uVKey])
        return FALSE;

    if (_FindHotKeyAndIC(wParam, lParam, &pHotKey, &pic, tsh, g_uModifiers))
    {
        if (fTest)
            fEaten = TRUE;
        else
        {
            GUID guid;
            if (SUCCEEDED(MyGetGUID(pHotKey->_guidatom, &guid)))
                _CallSimulatePreservedKey(pHotKey, pic,  guid, &fEaten);
        }
    }

    return fEaten;
}

//+---------------------------------------------------------------------------
//
// _FindHotKeyByTiD
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_FindHotKeyByTID(TfClientId tid, WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, TimSysHotkey tsh, UINT uModCurrent)
{
    UINT uVKey = (UINT)wParam & 0xff;
    int nCnt;
    int i;
    CHotKey *pHotKey;

    Assert(_rgHotKey[uVKey]);
    
    nCnt = _rgHotKey[uVKey]->Count();
    for (i = 0; i < nCnt; i++)
    {
        pHotKey = _rgHotKey[uVKey]->Get(i);
        Assert(pHotKey);
        Assert(pHotKey->_prekey.uVKey == uVKey);

        if ((tid != TF_INVALID_GUIDATOM) && !pHotKey->IsValidTID(tid))
            continue;

        switch (tsh)
        {
            case TSH_SYSHOTKEY:
                if (!pHotKey->IsSysHotkey())
                    continue;
                break;

            case TSH_NONSYSHOTKEY:
                if (pHotKey->IsSysHotkey())
                    continue;
                break;

            case TSH_DONTCARE:
                break;

            default:
                Assert(0);
                break;
        }

        if ((pHotKey->_prekey.uModifiers & TF_MOD_ON_KEYUP) != 
                       ((lParam & 0x80000000) ? (UINT)TF_MOD_ON_KEYUP : 0))
            continue;

        if (ModifiersCheck(uModCurrent, pHotKey->_prekey.uModifiers))
        {
            if (ppHotKey)
                *ppHotKey = pHotKey;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _FindHotkeyIC
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_FindHotKeyAndIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext **ppic, TimSysHotkey tsh, UINT uModCurrent)
{
    int iStack;

    Assert(_pFocusDocInputMgr);

    iStack = _pFocusDocInputMgr->_GetCurrentStack();
    if (iStack < 0)
        return FALSE;

    while (iStack >= 0)
    {
        CInputContext *pic = _pFocusDocInputMgr->_GetIC(iStack);
        if (_FindHotKeyInIC(wParam, lParam, ppHotKey, pic, tsh, uModCurrent))
        { 
            if (ppic)
                *ppic = pic;
            return TRUE;
        }
        iStack--;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _FindHotkey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_FindHotKeyInIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext *pic, TimSysHotkey tsh, UINT uModCurrent)
{
    TfClientId tid;

    pic->_UpdateKeyEventFilter();

    //
    // try left side of the selection.
    //
    if ((tid = pic->_gaKeyEventFilterTIP[LEFT_FILTERTIP]) != TF_INVALID_GUIDATOM)
    {
        if (_FindHotKeyByTID(tid, wParam, lParam, ppHotKey, tsh, uModCurrent))
        { 
            return TRUE;
        }
    }

    //
    // try right side of the selection.
    //
    if ((tid = pic->_gaKeyEventFilterTIP[RIGHT_FILTERTIP]) != TF_INVALID_GUIDATOM)
    {
        if (_FindHotKeyByTID(tid, wParam, lParam, ppHotKey, tsh, uModCurrent))
        {     
            return TRUE;
        }
    }

    //
    // try foreground tip.
    //
    if ((_tidForeground != TF_INVALID_GUIDATOM) || (tsh == TSH_SYSHOTKEY))
    {
        if (_FindHotKeyByTID(_tidForeground, wParam, lParam, ppHotKey, tsh, uModCurrent))
        { 
            return TRUE;
        }
    }

    //
    // we may have a system hotkey that matched with the wParm and lParam.
    //
    if (_FindHotKeyByTID(TF_INVALID_GUIDATOM, wParam, lParam, ppHotKey, TSH_SYSHOTKEY, uModCurrent))
    { 
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CallKeyEventSink
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_CallSimulatePreservedKey(CHotKey *pHotKey, CInputContext *pic, REFGUID rguid, BOOL *pfEaten)
{
    ITfKeyEventSink *pSink;
    CTip *ctip;

    //
    // This is tip's Preserved key.
    //
    if (pHotKey->GetTID() != g_gaSystem)
    {
        if (!pHotKey->IsNoDimNeeded() && !pic)
            return S_FALSE;

        if (!_GetCTipfromGUIDATOM(pHotKey->GetTID(), &ctip))
            return E_INVALIDARG;

        if (!(pSink = ctip->_pKeyEventSink))
            return S_FALSE;

        return pSink->OnPreservedKey(pic, rguid, pfEaten);
    }


    UINT uId = -1;
    int i;
    HRESULT hr = S_OK;

    for (i = 0; i < DEFHOTKEYNUM; i++)
    {
        if (g_DefHotKeys[i].guidatom == pHotKey->_guidatom)
        {
            uId = g_DefHotKeys[i].uId;
            break;
        }
    }

    switch (g_DefHotKeys[i].uId)
    {
        case DHID_CORRECTION:
            //
            // simulate Reconversion Button.
            //
            hr = AsyncReconversion();
            break;

        case DHID_VOICE:
            hr = MyToggleCompartmentDWORD(g_gaSystem, 
                                          GetGlobalComp(), 
                                          GUID_COMPARTMENT_SPEECH_OPENCLOSE,
                                          NULL);
            if (hr == S_OK)
                *pfEaten = TRUE;

            break;

        case DHID_HANDWRITE:
            hr = MyToggleCompartmentDWORD(g_gaSystem, 
                                          this,
                                          GUID_COMPARTMENT_HANDWRITING_OPENCLOSE,
                                          NULL);
            if (hr == S_OK)
                *pfEaten = TRUE;

            break;

        case DHID_TOGGLE:

            DWORD dwMicOn;

            if (FAILED(MyGetCompartmentDWORD(GetGlobalComp(), 
                                  GUID_COMPARTMENT_SPEECH_OPENCLOSE,
                                  &dwMicOn)))
            {
                hr = E_FAIL;
                break;
            }

            if ( dwMicOn )
            {
                DWORD dwSpeechStatus;
            
                if (FAILED(MyGetCompartmentDWORD(GetGlobalComp(), 
                                      GUID_COMPARTMENT_SPEECH_GLOBALSTATE,
                                      &dwSpeechStatus)))
                {
                    hr = E_FAIL;
                    break;
                }

                if ((dwSpeechStatus & (TF_DICTATION_ON | TF_COMMANDING_ON)) == 0 )
                {
                    // Both dictation and voice command are OFF
                    // After toggled, we set dictation ON.
                    dwSpeechStatus |= TF_DICTATION_ON;
                }
                else
                {
                    dwSpeechStatus ^= TF_DICTATION_ON;
                    dwSpeechStatus ^= TF_COMMANDING_ON;
                }

                hr = MySetCompartmentDWORD(g_gaSystem,
                                  GetGlobalComp(), 
                                  GUID_COMPARTMENT_SPEECH_GLOBALSTATE, 
                                  dwSpeechStatus);

            }

            if (hr == S_OK)
                *pfEaten = TRUE;

            break;

        default:
            Assert(0);
            hr = E_FAIL;
            break;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetPreservedKey
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetPreservedKey(ITfContext *pic, const TF_PRESERVEDKEY *pprekey, GUID *pguid)
{
    CHotKey *pHotKey;
    CInputContext *pcic;
    HRESULT hr = S_FALSE; // we return S_FALE, if there is no proper keys.

    if (!pguid)
        return E_INVALIDARG;

    *pguid = GUID_NULL;

    if (!pprekey)
        return E_INVALIDARG;

    if (pprekey->uVKey >= ARRAYSIZE(_rgHotKey))
        return E_INVALIDARG;

    if (pprekey->uModifiers & ~TF_MOD_ALL)
        return E_INVALIDARG;

    if (!pic)
        return E_INVALIDARG;

    if (!(pcic = GetCInputContext(pic)))
        return E_INVALIDARG;

    if (!_rgHotKey[pprekey->uVKey])
        goto Exit;

    //
    // we always get KeyUp preserve key first.
    //
    if (_FindHotKeyInIC(pprekey->uVKey, 0x80000000, &pHotKey, pcic, TSH_DONTCARE,  pprekey->uModifiers))
    {
        hr = MyGetGUID(pHotKey->_guidatom, pguid);
    }
    else if (_FindHotKeyInIC(pprekey->uVKey, 0x0, &pHotKey, pcic, TSH_DONTCARE,  pprekey->uModifiers))
    {
        hr = MyGetGUID(pHotKey->_guidatom, pguid);
    }

Exit:
    SafeRelease(pcic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// isPreservedKeyInfo
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::IsPreservedKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey, BOOL *pfRegistered)
{
    TfGuidAtom guidatom;
    int i;
    int nCnt;

    if (!pfRegistered)
        return E_INVALIDARG;

    *pfRegistered = FALSE;

    if (!pprekey)
        return E_INVALIDARG;

    if (pprekey->uVKey >= ARRAYSIZE(_rgHotKey))
        return E_INVALIDARG;

    if (pprekey->uModifiers & ~TF_MOD_ALL)
        return E_INVALIDARG;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return E_FAIL;

    if (!_rgHotKey[pprekey->uVKey])
        return S_FALSE;
    
    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    for (i = 0; i < nCnt; i++)
    {
        CHotKey *pHotKey = _rgHotKey[pprekey->uVKey]->Get(i);
        if ((guidatom == pHotKey->_guidatom) &&
            (pprekey->uModifiers == pHotKey->_prekey.uModifiers))
        {
            *pfRegistered = TRUE;
            return S_OK;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// GetPreservedKeyInfoInternal
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetFirstPreservedKey(REFGUID rguid, CHotKey **ppHotKey)
{
    UINT uVKey;
    TfGuidAtom guidatom;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return FALSE;
    
    for (uVKey = 0; uVKey < 256; uVKey++)
    {
        int nCnt;
        int i;

        if (!_rgHotKey[uVKey])
            continue;

        nCnt = _rgHotKey[uVKey]->Count();
        for (i = 0; i < nCnt; i++)
        {
            CHotKey *pHotKey = _rgHotKey[uVKey]->Get(i);
            if (guidatom == pHotKey->_guidatom)
            {
                *ppHotKey = pHotKey;
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// SimulatePreservedKey
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SimulatePreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten)
{
    CInputContext *pcic;
    CHotKey *pHotKey;
    HRESULT hr;
  
    if (!pfEaten)
        return E_INVALIDARG;

    if (!(pcic = GetCInputContext(pic)))
        return E_INVALIDARG;

    hr = S_OK;
    *pfEaten = FALSE;

    if (_GetFirstPreservedKey(rguid, &pHotKey))
    {
        //
        // we always get KeyUp preserve key first.
        //
        if (_FindHotKeyInIC(pHotKey->_prekey.uVKey, 
                             0x80000000, 
                             NULL,
                             pcic, 
                             TSH_DONTCARE,  
                             pHotKey->_prekey.uModifiers))
        {
            hr = _CallSimulatePreservedKey(pHotKey, pcic, rguid, pfEaten);
        }
        else if (_FindHotKeyInIC(pHotKey->_prekey.uVKey, 
                                  0x0, 
                                  NULL,
                                  pcic, 
                                  TSH_DONTCARE,  
                                  pHotKey->_prekey.uModifiers))
        {
            hr = _CallSimulatePreservedKey(pHotKey, pcic, rguid, pfEaten);
        }

    }

    SafeRelease(pcic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// _OnPreservedKeyUpdate
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_OnPreservedKeyUpdate(CHotKey *pHotKey)
{
    CStructArray<GENERICSINK> *pSinks = _GetPreservedKeyNotifySinks();
    int i;

    //
    // we don't make a notification for system default hotkeys.
    //
    if (pHotKey->GetTID() == g_gaSystem)
        return S_OK;

    for (i = 0; i < pSinks->Count(); i++)
    {
        ((ITfPreservedKeyNotifySink *)pSinks->GetPtr(i)->pSink)->OnUpdated(&pHotKey->_prekey);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetPreservedKeyDescription
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SetPreservedKeyDescription(REFGUID rguid, const WCHAR *pchDesc, ULONG cchDesc)
{
    CHotKey *pHotKey;
    if (!_GetFirstPreservedKey(rguid, &pHotKey))
        return E_INVALIDARG;

    if (!pHotKey->SetDesc(pchDesc, cchDesc))
        return E_FAIL;

    _OnPreservedKeyUpdate(pHotKey);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetPreservedKeyDescription
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetPreservedKeyDescription(REFGUID rguid, BSTR *pbstrDesc)
{
    CHotKey *pHotKey;
    if (!_GetFirstPreservedKey(rguid, &pHotKey))
        return E_INVALIDARG;

    if (!pHotKey->GetDesc(pbstrDesc))
        return E_FAIL;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// Static Functions
//
//////////////////////////////////////////////////////////////////////////////

#define IsAlt(u)     ((u & TF_MOD_ALT) ? 1 : 0)
#define IsShift(u)   ((u & TF_MOD_SHIFT) ? 1 : 0)
#define IsControl(u) ((u & TF_MOD_CONTROL) ? 1 : 0)
#define IsWin(u)     ((u & TF_MOD_WIN) ? 1 : 0)


#define CheckMod(m0, m1, mod)                                \
     if (m1 & TF_MOD_ ## mod ##)                             \
     {                                                       \
         if (!(m0 & TF_MOD_ ## mod ##))                      \
             return FALSE;                                   \
     }                                                       \
     else                                                    \
     {                                                       \
         if ((m1 ^ m0) & TF_MOD_RL ## mod ##)                \
             return FALSE;                                   \
     }                                             

//+---------------------------------------------------------------------------
//
// ModifiersCheck
//
//----------------------------------------------------------------------------
BOOL ModifiersCheck(UINT uModCurrent, UINT uMod)
{
     uMod &= ~TF_MOD_ON_KEYUP;

     if (uMod & TF_MOD_IGNORE_ALL_MODIFIER)
         return TRUE;

     if (uModCurrent == uMod)
         return TRUE;

     if (uModCurrent && !uMod)
         return FALSE;

     CheckMod(uModCurrent, uMod, ALT);
     CheckMod(uModCurrent, uMod, SHIFT);
     CheckMod(uModCurrent, uMod, CONTROL);
     CheckMod(uModCurrent, uMod, WIN);

     return TRUE;
}

//+---------------------------------------------------------------------------
//
// InitLangChangeHotKey
//
//----------------------------------------------------------------------------

BOOL InitLangChangeHotKey()
{
    CMyRegKey key;
    TCHAR sz[2] = TEXT("3");
    TCHAR sz2[2] = TEXT("3");

    if (key.Open(HKEY_CURRENT_USER, c_szKbdToggleKey, KEY_READ) == S_OK)
    {
        if (key.QueryValueCch(sz, TEXT("Language Hotkey"), ARRAYSIZE(sz)) != S_OK)
        {
            if (key.QueryValueCch(sz, IsOnNT() ? TEXT("Hotkey") : NULL, ARRAYSIZE(sz)) != S_OK)
            {
                sz[0] = TEXT('1');
                sz[1] = TEXT('\0');
            }

            if (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_CHINESE)
            {
                sz[0] = TEXT('1');
                sz[1] = TEXT('\0');
            }
        }
        if (key.QueryValueCch(sz2, TEXT("Layout Hotkey"), ARRAYSIZE(sz)) != S_OK)
        {
            if (lstrcmp(sz, TEXT("2")) == 0)
            {
                sz2[0] = TEXT('1');
                sz2[1] = TEXT('\0');
            }
            else
            {
                sz2[0] = TEXT('2');
                sz2[1] = TEXT('\0');
            }

            if (GetSystemMetrics(SM_MIDEASTENABLED))
            {
                sz2[0] = TEXT('3');
                sz2[1] = TEXT('\0');
            }
        }
    }

    //
    // if lang and layout hotkey is the same key, let's disable the layout hotkey
    //
    if (lstrcmp(sz, sz2) == 0)
    {
        if (lstrcmp(sz, TEXT("1")) == 0)
        {
            sz2[0] = TEXT('2');
            sz2[1] = TEXT('\0');
        }
        else if (lstrcmp(sz, TEXT("2")) == 0)
        {
            sz2[0] = TEXT('1');
            sz2[1] = TEXT('\0');
        }
        else
        {
            sz2[0] = TEXT('3');
            sz2[1] = TEXT('\0');
        }
    }

    CicEnterCriticalSection(g_csInDllMain);

    switch (sz[0])
    {
        case ( TEXT('1') ) :
        default:
        {
            g_uLangHotKeyModifiers = TF_MOD_ALT | TF_MOD_SHIFT;
            g_uLangHotKeyVKey[0] = VK_SHIFT;
            g_uLangHotKeyVKey[1] = VK_MENU;
            break;
        }
        case ( TEXT('2') ) :
        {
            g_uLangHotKeyModifiers = TF_MOD_CONTROL | TF_MOD_SHIFT;
            g_uLangHotKeyVKey[0] = VK_SHIFT;
            g_uLangHotKeyVKey[1] = VK_CONTROL;
            break;
        }
        case ( TEXT('3') ) :
        {
            g_uLangHotKeyModifiers = 0;
            g_uLangHotKeyVKey[0] = 0;
            g_uLangHotKeyVKey[1] = 0;
            break;
        }
        case ( TEXT('4') ) :
        {
            g_uLangHotKeyModifiers = 0;
            g_uLangHotKeyVKey[0] = CHAR_GRAVE;
            g_uLangHotKeyVKey[1] = 0;
            break;
        }
    }

    //
    // Set the layout switch hotkey.
    //
    switch (sz2[0])
    {
        case ( TEXT('1') ) :
        default:
        {
            g_uKeyTipHotKeyModifiers = TF_MOD_LALT | TF_MOD_SHIFT;
            g_uKeyTipHotKeyVKey[0] = VK_SHIFT;
            g_uKeyTipHotKeyVKey[1] = VK_MENU;
            break;
        }
        case ( TEXT('2') ) :
        {
            g_uKeyTipHotKeyModifiers = TF_MOD_CONTROL | TF_MOD_SHIFT;
            g_uKeyTipHotKeyVKey[0] = VK_SHIFT;
            g_uKeyTipHotKeyVKey[1] = VK_CONTROL;
            break;
        }
        case ( TEXT('3') ) :
        {
            g_uKeyTipHotKeyModifiers = 0;
            g_uKeyTipHotKeyVKey[0] = 0;
            g_uKeyTipHotKeyVKey[1] = 0;
            break;
        }
        case ( TEXT('4') ) :
        {
            g_uKeyTipHotKeyModifiers = 0;
            g_uKeyTipHotKeyVKey[0] = VK_GRAVE;
            g_uKeyTipHotKeyVKey[1] = 0;
            break;
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UpdateModifiers
//
//----------------------------------------------------------------------------

BOOL UpdateModifiers(WPARAM wParam, LPARAM lParam)
{
    SHORT sksMenu = GetKeyState(VK_MENU);
    SHORT sksCtrl = GetKeyState(VK_CONTROL);
    SHORT sksShft = GetKeyState(VK_SHIFT);
    SHORT sksLWin = GetKeyState(VK_LWIN);
    SHORT sksRWin = GetKeyState(VK_RWIN);

    CicEnterCriticalSection(g_cs);
    switch (wParam & 0xff)
    {
        case VK_MENU:
            if (sksMenu & 0x8000)
            {
                if (lParam & 0x01000000)
                    g_uModifiers |= (TF_MOD_RALT | TF_MOD_ALT);
                else
                    g_uModifiers |= (TF_MOD_LALT | TF_MOD_ALT);
            }
            break;

        case VK_CONTROL:
            if (sksCtrl & 0x8000)
            {
                if (lParam & 0x01000000)
                    g_uModifiers |= (TF_MOD_RCONTROL | TF_MOD_CONTROL);
                else
                    g_uModifiers |= (TF_MOD_LCONTROL | TF_MOD_CONTROL);
            }
            break;

        case VK_SHIFT:
            if (sksShft & 0x8000)
            {
                if (((lParam >> 16) & 0x00ff) == 0x36)
                    g_uModifiers |= (TF_MOD_RSHIFT | TF_MOD_SHIFT);
                else
                    g_uModifiers |= (TF_MOD_LSHIFT | TF_MOD_SHIFT);
            }
            break;

        case VK_LWIN:
            if (sksLWin & 0x8000)
                g_uModifiers |= (TF_MOD_LWIN | TF_MOD_WIN);
            break;

        case VK_RWIN:
            if (sksRWin & 0x8000)
                g_uModifiers |= (TF_MOD_RWIN | TF_MOD_WIN);
            break;
    }

    if (!(sksMenu & 0x8000))
        g_uModifiers &= ~TF_MOD_ALLALT;
    if (!(sksCtrl & 0x8000))
        g_uModifiers &= ~TF_MOD_ALLCONTROL;
    if (!(sksShft & 0x8000))
        g_uModifiers &= ~TF_MOD_ALLSHIFT;
    if (!(sksRWin & 0x8000))
        g_uModifiers &= ~TF_MOD_RWIN;
    if (!(sksLWin & 0x8000))
        g_uModifiers &= ~TF_MOD_LWIN;
    if (!(sksRWin & 0x8000) && !(sksLWin & 0x8000))
        g_uModifiers &= ~TF_MOD_WIN;

    CicLeaveCriticalSection(g_cs);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsInLangChangeHotkeyStatus
//
// This function check the current keyboard status is in LangChange hotkey.
// This will be a trigger to eat WM_INPUTLANGUAGECHANGEREQUEST that was
// genereated by System. This is a fallback code because sometimes we
// could not eat the message in CheckLangChangeHotKey() (inside keyboard hook).
//
//----------------------------------------------------------------------------

BOOL IsInLangChangeHotkeyStatus()
{
    //
    // we don't need this hack on NT.
    //
    if (IsOnNT())
        return FALSE;


    //
    // this Modifiers patch works for only Key-Down time hotkey.
    // this hack does not work for Key-Up time hotkey.
    //
#if 0
    //
    // patch Shift status for g_uModifiers. 
    // we might not be able to catch up the current keystatus because
    // sytstem could eat Shift key and no keyboard hook was called.
    //
    if (GetKeyState(VK_SHIFT) & 0x8000)
        g_uModifiers |= TF_MOD_SHIFT;
    else
        g_uModifiers &= ~TF_MOD_ALLSHIFT;
#endif

    if (g_uLangHotKeyModifiers &&
        ModifiersCheck(g_uModifiers, g_uLangHotKeyModifiers))
        return TRUE;

    if (g_uKeyTipHotKeyModifiers &&
        ModifiersCheck(g_uModifiers, g_uKeyTipHotKeyModifiers))
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CheckLangChangeHotKey
//
//----------------------------------------------------------------------------

BOOL CheckLangChangeHotKey(SYSTHREAD *psfn, WPARAM wParam, LPARAM lParam)
{
    BOOL fLangHotKeys;
    BOOL fKeyTipHotKeys;

    if (psfn == NULL)
        return FALSE;

    //
    // we don't care about reperted key down.
    //
    if ((lParam & 0xffff) > 1)
        return FALSE;

    //
    // If we are not interested in the VKey (wParam), 
    // clear bToggleReady up and don't eat it.
    //
    if ((g_uLangHotKeyVKey[0] != wParam) &&
        (g_uLangHotKeyVKey[1] != wParam))
    {
        if (psfn->bLangToggleReady)
        {
            psfn->bLangToggleReady = FALSE;
        }

        fLangHotKeys = FALSE;
    }
    else
    {
        fLangHotKeys = TRUE;
    }

    if ((g_uKeyTipHotKeyVKey[0] != wParam) &&
        (g_uKeyTipHotKeyVKey[1] != wParam))
    {
        if (psfn->bKeyTipToggleReady)
        {
            psfn->bKeyTipToggleReady = FALSE;
        }

        fKeyTipHotKeys = FALSE;
    }
    else
    {
        fKeyTipHotKeys = TRUE;
    }

    if (fLangHotKeys && !psfn->bLangToggleReady)
    {
        if (!(lParam & 0x80000000))
        {
            if (g_uLangHotKeyModifiers &&
                ModifiersCheck(g_uModifiers, g_uLangHotKeyModifiers))
            {
                //
                // we will change assembly at next key up.
                //
                psfn->bLangToggleReady = TRUE;

                //
                // we always eat Language change hotkey to stop system
                // to change hKL.
                //
                return FALSE;
            }
        }
    }

    if (fKeyTipHotKeys && !psfn->bKeyTipToggleReady)
    {
        if (!(lParam & 0x80000000))
        {
            if (g_uKeyTipHotKeyModifiers &&
                ModifiersCheck(g_uModifiers, g_uKeyTipHotKeyModifiers))
            {
                if (GetKeyboardItemNum() >= 2)
                {
                    //
                    // we will change assembly at next key up.
                    //
                    psfn->bKeyTipToggleReady = TRUE;

                    //
                    // we don't want to eat KeyTip change hotkey if there is 
                    // only one keyboard item in this language.
                    // Ctrl+Shift is used by apps.
                    //
                    return FALSE;
                }
            }
            else if (wParam == VK_GRAVE && g_uKeyTipHotKeyVKey[0] == wParam)
            {
                //
                // we will change assembly at next key up.
                //
                psfn->bKeyTipToggleReady = TRUE;

                return TRUE;
            }
        }
    }

    if (!(lParam & 0x80000000))
    {
        //
        // want to eat Grave Accent if it is a layout switching hotkey for ME.
        //
        if (g_uKeyTipHotKeyVKey[0] == wParam && wParam == VK_GRAVE)
            return TRUE;
        else
            return FALSE;
    }

    BOOL bLangToggleReady = psfn->bLangToggleReady;
    BOOL bKeyTipToggleReady = psfn->bKeyTipToggleReady;
    psfn->bLangToggleReady = FALSE;
    psfn->bKeyTipToggleReady = FALSE;

    if (bLangToggleReady)
    {

        //
        // remove all WM_INPUTLANGCHANGEREQUEST message.
        //
        MSG msg;
        while(PeekMessage(&msg, NULL,
                          WM_INPUTLANGCHANGEREQUEST, 
                          WM_INPUTLANGCHANGEREQUEST,
                          PM_REMOVE));

        if (g_uLangHotKeyVKey[0] == VK_SHIFT)
        {
            BOOL bRightShift = FALSE;
            if ((((wParam & 0xff) == VK_SHIFT) && 
                                (((lParam >> 16) & 0x00ff) == 0x36)) ||
                  (g_uModifiers & TF_MOD_RSHIFT))
                bRightShift = TRUE;

            PostThreadMessage(GetCurrentThreadId(), 
                              g_msgPrivate, 
                              TFPRIV_LANGCHANGE,  
                              bRightShift);
            return TRUE;
        }
        else if (g_uLangHotKeyVKey[0] == CHAR_GRAVE)
        {
            //
            // Issue: we need to do something for Thai.
            //
            return TRUE;
        }
    }
    else if (bKeyTipToggleReady)
    {
        //
        // remove all WM_INPUTLANGCHANGEREQUEST message.
        //
        MSG msg;
        while(PeekMessage(&msg, NULL,
                          WM_INPUTLANGCHANGEREQUEST, 
                          WM_INPUTLANGCHANGEREQUEST,
                          PM_REMOVE));

        if (g_uKeyTipHotKeyVKey[0] == VK_SHIFT)
        {
            BOOL bRightShift = FALSE;
            if ((((wParam & 0xff) == VK_SHIFT) && 
                                (((lParam >> 16) & 0x00ff) == 0x36)) ||
                  (g_uModifiers & TF_MOD_RSHIFT))
                bRightShift = TRUE;

            PostThreadMessage(GetCurrentThreadId(), 
                              g_msgPrivate, 
                              TFPRIV_KEYTIPCHANGE,  
                              bRightShift);
            return TRUE;
        }
        else if (g_uKeyTipHotKeyVKey[0] == VK_GRAVE)
        {
            // checking for Middle East(Arabic or Hebrew) layout hotkey to
            // support the third hotkey value(Grave Accent) instead of Ctrl+Shift
            // or Alt+Shift.

            PostThreadMessage(GetCurrentThreadId(),
                              g_msgPrivate,
                              TFPRIV_KEYTIPCHANGE,
                              FALSE);

            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// Imm32ModtoCicMod
//
//----------------------------------------------------------------------------

UINT Imm32ModtoCicMod(UINT uImm32Mod)
{
    UINT uMod = 0;
    if ((uImm32Mod & (MOD_LEFT | MOD_RIGHT)) == (MOD_LEFT | MOD_RIGHT))
         uImm32Mod &=  ~(MOD_LEFT | MOD_RIGHT);

    if (uImm32Mod & MOD_LEFT)
    {
        if (uImm32Mod & MOD_ALT)     uMod |= TF_MOD_LALT;  
        if (uImm32Mod & MOD_CONTROL) uMod |= TF_MOD_LCONTROL;
        if (uImm32Mod & MOD_SHIFT)   uMod |= TF_MOD_LSHIFT;
    }
    else if (uImm32Mod & MOD_RIGHT)
    {
        if (uImm32Mod & MOD_ALT)     uMod |= TF_MOD_RALT;  
        if (uImm32Mod & MOD_CONTROL) uMod |= TF_MOD_RCONTROL;
        if (uImm32Mod & MOD_SHIFT)   uMod |= TF_MOD_RSHIFT;
    }
    else
    {
        if (uImm32Mod & MOD_ALT)     uMod |= TF_MOD_ALT;  
        if (uImm32Mod & MOD_CONTROL) uMod |= TF_MOD_CONTROL;
        if (uImm32Mod & MOD_SHIFT)   uMod |= TF_MOD_SHIFT;
    }
 
    if (uImm32Mod & MOD_ON_KEYUP)   uMod |= TF_MOD_ON_KEYUP;
    if (uImm32Mod & MOD_IGNORE_ALL_MODIFIER)   uMod |= TF_MOD_IGNORE_ALL_MODIFIER;

    return uMod;
}


//+---------------------------------------------------------------------------
//
// LoadImmHotkeyFromReg
//
//----------------------------------------------------------------------------

BOOL LoadImmHotkeyFromReg(IMM32HOTKEY *pHotKey)
{
    CMyRegKey key;
    UINT uMod;
    DWORD dw;
    TCHAR szKey[256];

    pHotKey->fInit = TRUE;

    StringCchPrintf(szKey, ARRAYSIZE(szKey),"%s\\%08x", c_szHotKey, pHotKey->dwId);
    if (key.Open(HKEY_CURRENT_USER, szKey, KEY_READ) != S_OK)
        goto Exit;

    pHotKey->uVKey = (UINT)-2;
    dw = sizeof(DWORD);
    key.QueryBinaryValue(&uMod, dw, c_szModifiers);
    dw = sizeof(DWORD);
    key.QueryBinaryValue(&pHotKey->uVKey, dw, c_szVKey);

    pHotKey->uModifiers = Imm32ModtoCicMod(uMod);

Exit:
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetImmHotKeyTable()
//
//----------------------------------------------------------------------------

IMM32HOTKEY *GetImmHotKeyTable(LANGID langid)
{
   IMM32HOTKEY *pHotKeys;

    switch (langid)
    {
        case 0x0411: pHotKeys = g_ImmHotKeys411; break;
        case 0x0412: pHotKeys = g_ImmHotKeys412; break;
        case 0x0404: pHotKeys = g_ImmHotKeys404; break;
        case 0x0804: pHotKeys = g_ImmHotKeys804; break;
        default:
            switch (g_uACP)
            {
                case 932: pHotKeys = g_ImmHotKeys411; break;
                case 936: pHotKeys = g_ImmHotKeys804; break;
                case 949: pHotKeys = g_ImmHotKeys412; break;
                case 950: pHotKeys = g_ImmHotKeys404; break;
            }
            return NULL;
    }
    return pHotKeys;
}

//+---------------------------------------------------------------------------
//
// IsImmHotkey
//
//----------------------------------------------------------------------------

IMM32HOTKEY *IsImmHotkey(UINT uVKey, BOOL fUp, UINT uModifiers, LANGID langid)
{
    int i = 0;
    BOOL bRet = FALSE;
    IMM32HOTKEY *pHotKeys;
    IMM32HOTKEY *pHotKeyRet = NULL;

    pHotKeys = GetImmHotKeyTable(langid);
    if (!pHotKeys)
        return NULL;

    CicEnterCriticalSection(g_cs);

    while (pHotKeys[i].dwId)
    {
         if (!pHotKeys[i].fInit)
             LoadImmHotkeyFromReg(&pHotKeys[i]);

         if ((pHotKeys[i].uVKey == uVKey) && 
             pHotKeys[i].uModifiers &&
             ModifiersCheck(uModifiers, pHotKeys[i].uModifiers))
         {
             pHotKeyRet = &pHotKeys[i];

             if ((pHotKeyRet->uModifiers & TF_MOD_ON_KEYUP) && !fUp)
                pHotKeyRet = NULL;
             else if (!(pHotKeyRet->uModifiers & TF_MOD_ON_KEYUP) && fUp)
                pHotKeyRet = NULL;

             goto Exit;
         }

         i++;
    }

Exit:
    CicLeaveCriticalSection(g_cs);
    return pHotKeyRet;
}

//+---------------------------------------------------------------------------
//
// IsInImmHotkeyStatus
//
// 
// This function check the current keyboard status is in IMM32's hotkey.
// This will be a trigger to eat WM_INPUTLANGUAGECHANGEREQUEST that was
// genereated by IMM32. This is a fallback code because sometimes we
// could not eat the message in CheckImm32HotKey() (inside keyboard hook).
//
//----------------------------------------------------------------------------

IMM32HOTKEY *IsInImmHotkeyStatus(SYSTHREAD *psfn, LANGID langid)
{
    int i = 0;
    IMM32HOTKEY *pHotKeys;
    IMM32HOTKEY *pHotKeyRet = NULL;
    BYTE bkey[256];
    UINT uModifiers;

    if (!psfn)
        return NULL;

    if (psfn->fRemovingInputLangChangeReq)
        return NULL;

    if (!psfn->ptim)
        return NULL;

    if (!psfn->ptim->_GetFocusDocInputMgr())
        return NULL;

    if (!GetKeyboardState(bkey))
        return NULL;

    pHotKeys = GetImmHotKeyTable(langid);
    if (!pHotKeys)
        return NULL;

    uModifiers = 0;
    if (bkey[VK_MENU] & 0x80)
       uModifiers |= TF_MOD_ALT;

    if (bkey[VK_CONTROL] & 0x80)
       uModifiers |= TF_MOD_CONTROL;

    if (bkey[VK_SHIFT] & 0x80)
       uModifiers |= TF_MOD_SHIFT;

    CicEnterCriticalSection(g_cs);
    
    while (pHotKeys[i].dwId)
    {
         if (!pHotKeys[i].fInit)
             LoadImmHotkeyFromReg(&pHotKeys[i]);

         if ((bkey[pHotKeys[i].uVKey & 0xff] & 0x80) &&
             pHotKeys[i].uModifiers &&
             ModifiersCheck(uModifiers, pHotKeys[i].uModifiers))
         {
             pHotKeyRet = &pHotKeys[i];

             if (pHotKeyRet->uModifiers & TF_MOD_ON_KEYUP)
                  pHotKeyRet = NULL;

             goto Exit;
         }

         i++;
    }

Exit:
    CicLeaveCriticalSection(g_cs);
    return pHotKeyRet;
}

//+---------------------------------------------------------------------------
//
// CancelImmHotkey
//
//----------------------------------------------------------------------------

#ifdef SIMULATE_EATENKEYS
BOOL CancelImmHotkey(SYSTHREAD *psfn, HWND hwnd, IMM32HOTKEY *pHotKey)
{
    UINT uMsg;

    if (pHotKey->uModifiers & TF_MOD_ON_KEYUP)
        uMsg = WM_KEYUP;
    else
        uMsg = WM_KEYDOWN;

    PostMessage(hwnd, uMsg, (WPARAM)pHotKey->uVKey, 0);

    return TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
// void ToggleCHImeNoIme
//
//----------------------------------------------------------------------------

BOOL ToggleCHImeNoIme(SYSTHREAD *psfn, LANGID langidCur, LANGID langid)
{
    int i;
    LANGID langidPrev;
    GUID guidPrevProfile;
    HKL hklPrev;
    BOOL fCiceroClient= FALSE;

    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItem;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    langidPrev = psfn->langidPrevForCHHotkey;
    guidPrevProfile = psfn->guidPrevProfileForCHHotkey;
    hklPrev = psfn->hklPrevForCHHotkey;
    psfn->guidPrevProfileForCHHotkey = GUID_NULL;
    psfn->langidPrevForCHHotkey = 0;
    psfn->hklPrevForCHHotkey = 0;

    pAsm = pAsmList->FindAssemblyByLangId(langidCur);
    if (!pAsm)
        return FALSE;

    if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    if (fCiceroClient)
    {
        pItem = pAsm->FindActiveKeyboardItem();
        if (!pItem)
            return FALSE;
    }
    else
    {
        pItem = pAsm->FindKeyboardLayoutItem(GetKeyboardLayout(0));
        if (!pItem)
            return FALSE;
    }

    if (!IsEqualGUID(pItem->clsid, GUID_NULL) || IsPureIMEHKL(pItem->hkl))
    {
        //
        // Not the current active keyboard item is TIP or IME.
        //

        psfn->guidPrevProfileForCHHotkey = pItem->guidProfile;
        psfn->hklPrevForCHHotkey = pItem->hkl;
        psfn->langidPrevForCHHotkey = langid;

        for (i = 0; i < pAsm->Count(); i++)
        {
            pItem = pAsm->GetItem(i);
            if (!pItem)
                continue;

            if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
                IsEqualGUID(pItem->clsid, GUID_NULL) &&
                !IsPureIMEHKL(pItem->hkl))
            {
                ActivateAssemblyItem(psfn, 
                                     langidCur, 
                                     pItem, 
                                     AAIF_CHANGEDEFAULT);
                return TRUE;
            }
        }

        PostThreadMessage(GetCurrentThreadId(), 
                          g_msgPrivate, 
                          TFPRIV_ACTIVATELANG,  
                          0x0409);

        return TRUE;
    }
    else
    {
        BOOL fActivateFirstIME = FALSE;
        BOOL fCheckItem = FALSE;

        if (langidCur != langid)
            ActivateAssembly(langid, ACTASM_NONE);

        pAsm = pAsmList->FindAssemblyByLangId(langid);
        if (!pAsm)
            return FALSE;

        if ((langidPrev == langid) &&
            (!IsEqualGUID(guidPrevProfile, GUID_NULL) ||
            IsPureIMEHKL(hklPrev)))
        {
             fCheckItem = TRUE;
        }
        else if (!langidPrev && 
                 IsEqualGUID(guidPrevProfile, GUID_NULL) &&
                 !hklPrev)
        {
             fActivateFirstIME = TRUE;
        }

        if (fActivateFirstIME)
        {
             return ActivateNextKeyTip(FALSE);
        }

        for (i = 0; i < pAsm->Count(); i++)
        {
            pItem = pAsm->GetItem(i);
            if (!pItem)
                continue;

            if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
                continue;

            //
            // Bug#494617 - Check the item is enabled or not.
            //
            if (!pItem->fEnabled)
                continue;

            if (fCheckItem)
            {
                 if ((!IsEqualGUID(guidPrevProfile, GUID_NULL) &&
                      IsEqualGUID(pItem->guidProfile, guidPrevProfile)) ||
                     (IsPureIMEHKL(hklPrev) && (hklPrev == pItem->hkl)))
                 {
                     ActivateAssemblyItem(psfn, 
                                          langid, 
                                          pItem, 
                                          AAIF_CHANGEDEFAULT);
                     return TRUE;
                 }
            }
            else if (!IsEqualGUID(pItem->guidProfile, GUID_NULL))
            { 
                 ActivateAssemblyItem(psfn, 
                                      langid, 
                                      pItem, 
                                      AAIF_CHANGEDEFAULT);
                 return TRUE;
            }
        }
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncOpenKeyboardTip
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncOpenKeyboardTip : public CAsyncQueueItem
{
public:
    CAsyncOpenKeyboardTip(CThreadInputMgr *ptim, BOOL fSync) : CAsyncQueueItem(fSync)
    {
        _ptim = ptim;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        if (!_ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        MySetCompartmentDWORD(g_gaSystem, 
                              _ptim,
                              GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                              TRUE);
                                  
        return S_OK;
    }

private:
    CThreadInputMgr *_ptim;
};

//+---------------------------------------------------------------------------
//
// void ToggleJImeNoIme
//
//----------------------------------------------------------------------------

BOOL ToggleJImeNoIme(SYSTHREAD *psfn)
{
    int i;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItem;

    if (!psfn)
        return FALSE;

    if (!psfn->ptim)
        return FALSE;

    //
    // if there is no Focus DIM, we don't have to do this.
    //
    if (!psfn->ptim->_GetFocusDocInputMgr())
        return FALSE;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(0x0411);
    if (!pAsm)
        return FALSE;

    pItem = pAsm->FindActiveKeyboardItem();
    if (!pItem)
        return FALSE;

    if (!IsEqualGUID(pItem->clsid, GUID_NULL))
        return FALSE;

    if (IsPureIMEHKL(pItem->hkl))
        return FALSE;


    ASSEMBLYITEM *pItemNew = NULL;
    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItemTemp;
        pItemTemp = pAsm->GetItem(i);
        if (!pItemTemp)
            continue;

        if (pItemTemp == pItem)
            continue;

        if (!IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
        {
            pItemNew = pItemTemp;
            break;
        }

        if (IsPureIMEHKL(pItemTemp->hkl))
        {
            pItemNew = pItemTemp;
            break;
        }
    }

    if (pItemNew)
    {
        ActivateAssemblyItem(psfn, 
                             0x0411, 
                             pItemNew, 
                             AAIF_CHANGEDEFAULT);


        //
        // Open Keyboard TIP.
        //
        CInputContext *pic = NULL;
        pic = psfn->ptim->_GetFocusDocInputMgr()->_GetIC(0);
        if (pic)
        {
            CAsyncOpenKeyboardTip  *pAsyncOpenKeyboardTip;
            pAsyncOpenKeyboardTip = new CAsyncOpenKeyboardTip(psfn->ptim, FALSE);
            if (pAsyncOpenKeyboardTip)
            {
                HRESULT hr = S_OK;

                if ((pic->_QueueItem(pAsyncOpenKeyboardTip->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
                {
                    Assert(0);
                }

                pAsyncOpenKeyboardTip->_Release();
            }
        }
    }

    return TRUE;
}



//+---------------------------------------------------------------------------
//
// CheckImm32HotKey
//
//----------------------------------------------------------------------------

BOOL CheckImm32HotKey(WPARAM wParam, LPARAM lParam)
{
    HKL hKL;
    SYSTHREAD *psfn = GetSYSTHREAD();
    IMM32HOTKEY *pHotKey;
    BOOL bRet = FALSE;

    if (psfn == NULL)
        return FALSE;

    //
    // If there is no tim, let system change hKL.
    //
    if (!psfn->ptim)
        return FALSE;

    //
    // If there is focus dim, we need to handle it.
    // If there is no focus dim, but msctfime can eat the hotkey,
    // we need to do this instead of system.
    //
    if (!psfn->ptim->_GetFocusDocInputMgr())
    {
        if (!CtfImmIsCiceroStartedInThread())
            return FALSE;
    }

    hKL = GetKeyboardLayout(NULL);

    pHotKey = IsImmHotkey((UINT)wParam & 0xff, 
                          (HIWORD(lParam) & KF_UP) ? TRUE : FALSE,
                          g_uModifiers, 
                          (LANGID)LOWORD((UINT_PTR)hKL));

    if (!pHotKey)
    {
        //
        // Chinese IME-NONIME toggle Hack for NT.
        //
        // On NT, we're using non IME as a dummy hKL of CH-Tips.
        // we need to simulate HotKey.
        //
        LANGID langidPrev = psfn->langidPrev;

        //
        // If the Chinese IME-NONIME toggle has never been done in this thread
        // and the current thread locale is Chinese, let's try to do
        // IME-NONIME toggle.
        //
        if ((langidPrev != CHTLANGID) && 
            (langidPrev != CHSLANGID) &&
             !psfn->langidPrevForCHHotkey)
        {
            LANGID langidThread = LANGIDFROMLCID(GetThreadLocale());
            if ((langidThread == CHTLANGID) || (langidThread == CHSLANGID))
                langidPrev = langidThread;
        }

        if (IsOnNT() &&
            ((langidPrev == CHTLANGID) || (langidPrev == CHSLANGID)))
        {
            pHotKey = IsImmHotkey((UINT)wParam & 0xff, 
                                  (HIWORD(lParam) & KF_UP) ? TRUE : FALSE,
                                  g_uModifiers, 
                                  langidPrev);

            if (pHotKey)
            {
                //
                // if it is a IME-NONIME toggle hotkey
                // we need to simulate it.
                //
                if ((pHotKey->dwId == IME_CHOTKEY_IME_NONIME_TOGGLE) ||
                    (pHotKey->dwId == IME_THOTKEY_IME_NONIME_TOGGLE))
                {
                    bRet = ToggleCHImeNoIme(psfn,  
                                     LANGIDFROMHKL(hKL),
                                     langidPrev);

                    //
                    // On CUAS, Imm32's Hotkey is simulated in ImmProcessKey
                    // So this function is called there.
                    // We don't need this Toggle status hack.
                    //
                    if (!CtfImmIsCiceroStartedInThread()) 
                       psfn->bInImeNoImeToggle = TRUE;
                }
            }
        }

        return bRet;
    }

    //
    // remove all WM_INPUTLANGCHANGEREQUEST message.
    //
    // sometimes, this can not catch the IMM32's language change. We 
    // fallback hack for them in default.cpp's WM_INPUTLANGCHANGEREQUEST
    // handler. Check IsInImmHotKeyStatus() and CancelImmHotkey().
    //
    MSG msg;
    ULONG ulQuitCode;
    BOOL fQuitReceived = FALSE;

    psfn->fRemovingInputLangChangeReq = TRUE;

    while(PeekMessage(&msg, NULL,
                      WM_INPUTLANGCHANGEREQUEST, 
                      WM_INPUTLANGCHANGEREQUEST,
                      PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
        {
            ulQuitCode = (ULONG)(msg.wParam);
            fQuitReceived = TRUE;
        }
    }

    if (fQuitReceived)
        PostQuitMessage(ulQuitCode);
   
    psfn->fRemovingInputLangChangeReq = FALSE;

    //
    // Chinese IME-NONIME toggle Hack for NT.
    //
    // On NT, we're using non IME as a dummy hKL of CH-Tips.
    // we need to simulate HotKey.
    //
    if (IsOnNT() && !psfn->bInImeNoImeToggle)
    {
        if ((pHotKey->dwId == IME_CHOTKEY_IME_NONIME_TOGGLE) ||
            (pHotKey->dwId == IME_THOTKEY_IME_NONIME_TOGGLE))
        {
            bRet = ToggleCHImeNoIme(psfn, LANGIDFROMHKL(hKL), LANGIDFROMHKL(hKL));
        }
    }
    psfn->bInImeNoImeToggle = FALSE;

    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncProcessDBEKeyQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncProcessDBEKeyQueueItem : public CAsyncQueueItem
{
public:
    CAsyncProcessDBEKeyQueueItem(CThreadInputMgr *ptim, WPARAM wParam, LPARAM lParam, BOOL fTest, BOOL fSync) : CAsyncQueueItem(fSync)
    {
        _wParam = wParam;
        _lParam = lParam;
        _fTest = fTest;
        _ptim = ptim;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        if (!_ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        BOOL fEaten;

        return _ptim->_KeyStroke((_lParam & 0x80000000) ? KS_UP : KS_DOWN, 
                                  _wParam, 
                                  _lParam, 
                                  &fEaten, 
                                  _fTest,
                                  TF_KEY_INTERNAL);
                                  
    }

private:
    WPARAM _wParam;
    LPARAM _lParam;
    BOOL _fTest;
    CThreadInputMgr *_ptim;
};

//+---------------------------------------------------------------------------
//
// HandleDBEKeys
//
//----------------------------------------------------------------------------

BOOL HandleDBEKeys(WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CThreadInputMgr *ptim;
    LANGID langid;

    //
    // only Japanese layout has DBE keys.
    //
    langid = GetCurrentAssemblyLangId(psfn);
    if (langid != 0x0411)
        return FALSE;

    //
    // no need to forward this on non Cicero apps.
    //
    if (!(ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
        return FALSE;

    if (!ptim->_GetFocusDocInputMgr())
        return FALSE;

    //
    // if ALT is not held, app can forward this to TIPs.
    //
    if (!(g_uModifiers & TF_MOD_ALT))
        return FALSE;

    UINT uVKey = (UINT)wParam & 0xff;
    BOOL fRet = FALSE;

    switch (uVKey)
    {
        case VK_DBE_ALPHANUMERIC:
        case VK_DBE_KATAKANA:
        case VK_DBE_HIRAGANA:
        case VK_DBE_SBCSCHAR:
        case VK_DBE_DBCSCHAR:
        case VK_DBE_ROMAN:
        case VK_DBE_NOROMAN:
        case VK_DBE_CODEINPUT:
        case VK_DBE_NOCODEINPUT:
        case VK_DBE_ENTERWORDREGISTERMODE:
        case VK_DBE_ENTERIMECONFIGMODE:
        case VK_DBE_ENTERDLGCONVERSIONMODE:
        case VK_DBE_DETERMINESTRING:
        case VK_DBE_FLUSHSTRING:
        case VK_CONVERT:
        case VK_KANJI:
            

            //
            // Issue:
            //
            // We don't know which IC in the focus DIM will handle the hotkey yet.
            // because the selection is changed by the application so we need to get ec
            // to update the current selection pos. We do call GetSelection
            // inside the root IC's lock. So it might be failed if hotkey's target
            // is TOP IC.
            //
            CInputContext *pic = ptim->_GetFocusDocInputMgr()->_GetIC(0);

            if (!pic)
                return FALSE;

            CAsyncProcessDBEKeyQueueItem  *pAsyncProcessDBEKeyQueueItem;
            pAsyncProcessDBEKeyQueueItem = new CAsyncProcessDBEKeyQueueItem(ptim, wParam, lParam, FALSE, FALSE);
            if (!pAsyncProcessDBEKeyQueueItem)
                return FALSE;
    
            HRESULT hr = S_OK;

            fRet = TRUE;
            if ((pic->_QueueItem(pAsyncProcessDBEKeyQueueItem->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
            {
                Assert(0);
                fRet = FALSE;
            }

            pAsyncProcessDBEKeyQueueItem->_Release();
            break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\focusnfy.cpp ===
//
// focusnfy.cpp
//
#include "private.h"
#include "globals.h"
#include "thdutil.h"
#include "cicmutex.h"
#include "tim.h"
#include "internat.h"
#include "marshal.h"
#include "catmgr.h"
#include "timlist.h"
#include "ithdmshl.h"
#include "marshal.h"
#include "shlapip.h"

const DWORD TF_LBESF_GLOBAL   = 0x0001;
const DWORD TF_LBSMI_FILTERCURRENTTHREAD = 0x0001;

LPVOID SharedAlloc(UINT cbSize,DWORD dwProcessId,HANDLE *pProcessHandle);
VOID SharedFree(LPVOID lpv,HANDLE hProcess);

CStructArray<LBAREVENTSINKLOCAL> *g_rglbes = NULL;
extern CCicMutex g_mutexLBES;

void CallFocusNotifySink(ITfLangBarEventSink *pSink, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fLocalSink, DWORD dwSinkCookie);


// --------------------------------------------------------------------------
//
//  FindLBES
//
// --------------------------------------------------------------------------
int FindLBES()
{
    int nId = -1;

    for (nId = 0; nId < MAX_LPES_NUM; nId++)
    {
        if (!(GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE))
            break;

        if (!g_timlist.IsThreadId(GetSharedMemory()->lbes[nId].m_dwThreadId))
        {
            //
            // Bug#354475 - Explorer can call deskband(msutb.dll module)
            // directly before loading the ctfmon.exe process. In this case,
            // explorer tray window thread didn't recognized by g_timlist.
            // Since shared block memory didn't create yet. So checking the
            // tray window thread and keep up language bar event sink for
            // language deskband support.
            //
            // Bug#370802
            //  we can not cache the window handle because explorer could
            //  crash. And we don't have a window to track "TaskbarCreated"
            //  message. The shell message is boradcasted by SendNotifyMessage()
            //  with HWMD_BROADCASTR. So the marshal window can not get it.
            //
            HWND hwndTray;
            DWORD dwThreadIdTray = 0;

            hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

            if (hwndTray)
                dwThreadIdTray = GetWindowThreadProcessId(hwndTray, NULL);

            if (!dwThreadIdTray ||
                dwThreadIdTray != GetSharedMemory()->lbes[nId].m_dwThreadId)
                break;
        }
    }

    if (nId == MAX_LPES_NUM)
    {
        nId = -1;
    }

    return nId;
}


// --------------------------------------------------------------------------
//
//  IntrnalRegisterLangBarNotifySink
//
// --------------------------------------------------------------------------

HRESULT RegisterLangBarNotifySink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie)
{
    HRESULT hr = E_FAIL;
    int nId;

    //
    // Bugbug#376500 - When CPL runs ctfmon.exe with deskband status, ThreadId
    // list doesn't include ctfmon thread, so need to make sure thread id list.
    //
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (psfn)
        EnsureTIMList(psfn);

    if (!(dwFlags & TF_LBESF_GLOBAL))
    {
        int nCnt;
        LBAREVENTSINKLOCAL *plbes;

        //
        // Local LangBarEventSink
        //
        CicEnterCriticalSection(g_csInDllMain);

        nCnt = g_rglbes->Count();
        if (g_rglbes->Insert(nCnt,1))
        {
            plbes = g_rglbes->GetPtr(nCnt);

            plbes->m_pSink = pSink;
            pSink->AddRef();

            plbes->lb.m_dwThreadId = GetCurrentThreadId();
            plbes->lb.m_dwProcessId = GetCurrentProcessId();
            plbes->lb.m_dwCookie = GetSharedMemory()->dwlbesCookie++;
            plbes->lb.m_dwLangBarFlags = dwFlags;
            *pdwCookie = plbes->lb.m_dwCookie;
            plbes->lb.m_hWnd = hwnd;
            plbes->lb.m_dwFlags = LBESF_INUSE;
            hr = S_OK;
        }

        CicLeaveCriticalSection(g_csInDllMain);
    }
    else 
    {
        if (psfn)
        {
            CCicMutexHelper mutexhlp(&g_mutexLBES);
            //
            // Global LangBarEventSink
            //
            if (mutexhlp.Enter())
            {
                if ((nId = FindLBES()) != -1)
                {
                    GetSharedMemory()->lbes[nId].m_dwThreadId = GetCurrentThreadId();
                    GetSharedMemory()->lbes[nId].m_dwProcessId = GetCurrentProcessId();
                    GetSharedMemory()->lbes[nId].m_dwCookie = GetSharedMemory()->dwlbesCookie++;
                    GetSharedMemory()->lbes[nId].m_dwLangBarFlags = dwFlags;
                    *pdwCookie = GetSharedMemory()->lbes[nId].m_dwCookie;
                    GetSharedMemory()->lbes[nId].m_hWnd = hwnd;
                    GetSharedMemory()->lbes[nId].m_dwFlags = LBESF_INUSE;

                    psfn->_pLangBarEventSink = pSink;
                    pSink->AddRef();
                    psfn->_dwLangBarEventCookie = *pdwCookie;

                    hr = S_OK;
                }
                mutexhlp.Leave();
            }
        }
    }

    return hr;
}

// --------------------------------------------------------------------------
//
//  UnregisterLangBarNotifySink
//
// --------------------------------------------------------------------------

HRESULT UnregisterLangBarNotifySink(DWORD dwCookie)
{
    DWORD dwThreadId = GetCurrentThreadId();
    DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr = E_FAIL;
    int nId;
    int nCnt;
    SYSTHREAD *psfn = GetSYSTHREAD();
    CCicMutexHelper mutexhlp(&g_mutexLBES);
    BOOL fUnregistereGlobalSink = FALSE;

    //
    // Local LangBarEventSink
    //
    CicEnterCriticalSection(g_csInDllMain);

    nCnt = g_rglbes->Count();
    for (nId = 0; nId < nCnt; nId++)
    {
        LBAREVENTSINKLOCAL *plbes;
        plbes = g_rglbes->GetPtr(nId);

        if ((plbes->lb.m_dwCookie == dwCookie) &&
            (plbes->lb.m_dwThreadId == dwThreadId) &&
            (plbes->lb.m_dwProcessId == dwProcessId))
        {
            //
            // if the process of msutb.dll is killed, pSink is bogus pointer. 
            // And this is expected in the unusuall case.
            //
            _try {
                plbes->m_pSink->Release();
            }
            _except(CicExceptionFilter(GetExceptionInformation())) {
                // Assert(0);
            }
            plbes->m_pSink = NULL;
            g_rglbes->Remove(nId, 1);
            hr = S_OK;
            goto ExitCrit;
        }
    }

ExitCrit:
    CicLeaveCriticalSection(g_csInDllMain);

    if (SUCCEEDED(hr))
        goto Exit;

    if (!psfn)
        goto Exit;

    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if ((GetSharedMemory()->lbes[nId].m_dwCookie == dwCookie) &&
                (GetSharedMemory()->lbes[nId].m_dwThreadId == dwThreadId) &&
                (GetSharedMemory()->lbes[nId].m_dwProcessId == dwProcessId) &&
                (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
            {
                //
                // if the process of msutb.dll is killed, pSink is bogus pointer. 
                // And this is expected in the unusuall case.
                //
                _try {
                    psfn->_pLangBarEventSink->Release();
                }
                _except(CicExceptionFilter(GetExceptionInformation())) {
                    // Assert(0);
                }

                psfn->_pLangBarEventSink=NULL;
                psfn->_dwLangBarEventCookie=NULL;

                GetSharedMemory()->lbes[nId].m_dwCookie = 0;
                GetSharedMemory()->lbes[nId].m_dwThreadId = 0;
                GetSharedMemory()->lbes[nId].m_dwProcessId = 0;
                GetSharedMemory()->lbes[nId].m_dwFlags = 0;
                fUnregistereGlobalSink = TRUE;
                hr = S_OK;
                goto ExitMutex;
            }
        }
ExitMutex:
        mutexhlp.Leave();
    }

    //
    // clean up all amrshaling stubs.
    //
    if (fUnregistereGlobalSink)
        FreeMarshaledStubs(psfn);

Exit:
    return hr;
}

// -------------------------------------------------------------------------
//
//  TLFlagFromMsg
//
// -------------------------------------------------------------------------

DWORD TLFlagFromMsg(UINT uMsg)
{
    if (uMsg == g_msgSetFocus)
        return LBESF_SETFOCUSINQUEUE;

    return 0;
}

// --------------------------------------------------------------------------
//
//  MakeSetFocusNotify
//
// --------------------------------------------------------------------------

void MakeSetFocusNotify(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int nId;
    DWORD dwCurThreadId = GetCurrentThreadId();
    int nCnt;
    DWORD dwPostThread[MAX_LPES_NUM];
    CCicMutexHelper mutexhlp(&g_mutexLBES);
    DWORD dwMsgMaskFlag = TLFlagFromMsg(uMsg);

    if (uMsg == g_msgSetFocus)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        TF_InitMlngInfo();
        CCategoryMgr::InitGlobal();
        EnsureAssemblyList(psfn);
        EnsureMarshalWnd();
        //EnsureLangBarItemMgr(psfn);
        EnsureTIMList(psfn);

        //
        // I think this is a bogus assert, but it is better to catch the case
        // to find another case this happen rather than OLE embedded apps.
        //
        // Assert(dwCurThreadId == GetSharedMemory()->dwFocusThread);

        TraceMsg(TF_GENERAL, "Make SetFocus notify  %x", dwCurThreadId);
    }

    //
    // Local LangBarEventSink
    //
    CicEnterCriticalSection(g_csInDllMain);

    nCnt = g_rglbes->Count();
    for (nId = 0; nId < nCnt; nId++)
    {
        LBAREVENTSINKLOCAL *plbes;
        DWORD dwThreadId;


        plbes = g_rglbes->GetPtr(nId);
        Assert(!(plbes->lb.m_dwLangBarFlags & TF_LBESF_GLOBAL));
        dwThreadId = plbes->lb.m_dwThreadId;


        if (dwThreadId != dwCurThreadId)
            continue;

        Assert(plbes->lb.m_dwFlags & LBESF_INUSE);

        if (!(plbes->lb.m_dwFlags & dwMsgMaskFlag))
        {
            PostThreadMessage(dwThreadId, uMsg, 0, lParam);

            //
            // set message mask.
            //
            plbes->lb.m_dwFlags |= dwMsgMaskFlag;
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);

    //
    // Global LangBarEventSink
    //
    BOOL fInDllMain = ISINDLLMAIN();
    if (fInDllMain || mutexhlp.Enter())
    {
        BOOL fPost = FALSE;

        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            DWORD dwFlags = GetSharedMemory()->lbes[nId].m_dwFlags;

            // init array.
            dwPostThread[nId] = 0;

            if (!(dwFlags & LBESF_INUSE))
                continue;

            DWORD dwTargetProcessId = g_timlist.GetProcessId(GetSharedMemory()->lbes[nId].m_dwThreadId);
            if (dwTargetProcessId && (GetSharedMemory()->lbes[nId].m_dwProcessId != dwTargetProcessId))
            {
                // 
                // thread on the process is gone without cleaninglbes.
                // 
                Assert(0);
                GetSharedMemory()->lbes[nId].m_dwFlags &= ~LBESF_INUSE;
                continue;
            }


            Assert(GetSharedMemory()->lbes[nId].m_dwLangBarFlags & TF_LBESF_GLOBAL);

            //
            // Check the msg mask bit so there won't be duplicated messages.
            //
            if (dwFlags & dwMsgMaskFlag)
                continue;

            //
            // avoid from posting exactly same messages into the queue.
            //
            if ((GetSharedMemory()->lbes[nId].m_lastmsg.uMsg == uMsg) &&
                (GetSharedMemory()->lbes[nId].m_lastmsg.wParam == wParam) &&
                (GetSharedMemory()->lbes[nId].m_lastmsg.lParam == lParam))
                continue;

            fPost = TRUE;
            dwPostThread[nId] = GetSharedMemory()->lbes[nId].m_dwThreadId;

            //
            // set message mask.
            //
            GetSharedMemory()->lbes[nId].m_dwFlags |= dwMsgMaskFlag;

            //
            // update last posted message.
            //
            GetSharedMemory()->lbes[nId].m_lastmsg.uMsg = uMsg;
            GetSharedMemory()->lbes[nId].m_lastmsg.wParam = wParam;
            GetSharedMemory()->lbes[nId].m_lastmsg.lParam = lParam;
   
        }

        if (fPost) 
        {
            for (nId = 0; nId < MAX_LPES_NUM; nId++)
            {
                if (dwPostThread[nId])
                    PostThreadMessage(dwPostThread[nId], uMsg, wParam, lParam);
            }
        }

        if (!fInDllMain)
            mutexhlp.Leave();
    }
}

//+---------------------------------------------------------------------------
//
// GetThreadInputIdle()
//
//----------------------------------------------------------------------------

DWORD GetThreadInputIdle(DWORD dwProcessId, DWORD dwThreadId)
{
    DWORD dwRet = 0;

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                  FALSE, dwProcessId);
    if (hProcess)
    {
        dwRet = WaitForInputIdle(hProcess, 0);
        CloseHandle(hProcess);
    }

    return dwRet;
}

// --------------------------------------------------------------------------
//
//  NotifyTryAgain
//
// --------------------------------------------------------------------------

BOOL NotifyTryAgain(DWORD dwProcessId, DWORD dwThreadId)
{
     if (IsOnNT())
     {
         if (!CicIs16bitTask(dwProcessId, dwThreadId))
         {
             DWORD dwRet = GetThreadInputIdle(dwProcessId, dwThreadId);
             if (dwRet && (dwRet != WAIT_FAILED))
                 return TRUE;
         }
     }
     else 
     {
         DWORD dwThreadFlags = 0;
         if (TF_GetThreadFlags(dwThreadId, &dwThreadFlags, NULL, NULL))
         {
             if (dwThreadFlags & TLF_NOWAITFORINPUTIDLEONWIN9X)
                 return FALSE;
         }

         DWORD dwRet = GetThreadInputIdle(dwProcessId, dwThreadId);
         if (dwRet && (dwRet != WAIT_FAILED))
             return TRUE;
     }
     return FALSE;
}

// --------------------------------------------------------------------------
//
//  SetFocusNotifyHandler
//
// --------------------------------------------------------------------------

void SetFocusNotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int nId;
    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    int nCnt;
    ITfLangBarEventSink *pSinkLocal = NULL;
    ITfLangBarEventSink *pSinkGlobal = NULL;
    DWORD dwSinkCookie = 0;
    DWORD dwMsgMaskFlag = TLFlagFromMsg(uMsg);
    MSG msg;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (PeekMessage(&msg, NULL, uMsg, uMsg, PM_NOREMOVE | PM_NOYIELD))
    {
        if ((msg.message == uMsg) &&
            (msg.wParam == wParam) &&
            (msg.lParam == lParam))
        return;
    }

    if ((uMsg == g_msgThreadTerminate) && psfn)
    {
        FreeMarshaledStubsForThread(psfn, (DWORD)lParam);
    }

    //
    // Local LangBarEventSink
    //
    CicEnterCriticalSection(g_csInDllMain);

    nCnt = g_rglbes->Count();
    for (nId = 0; nId < nCnt; nId++)
    {
        LBAREVENTSINKLOCAL *plbes = g_rglbes->GetPtr(nId);

        Assert(!(plbes->lb.m_dwLangBarFlags & TF_LBESF_GLOBAL));

        if (plbes->lb.m_dwThreadId == dwCurThreadId)
        {
            pSinkLocal = plbes->m_pSink;

            dwSinkCookie = plbes->lb.m_dwCookie;

            //
            // clear message mask.
            //
            plbes->lb.m_dwFlags &= ~dwMsgMaskFlag;

            break;
        }
    }
    CicLeaveCriticalSection(g_csInDllMain);



    if (psfn)
    {
        CCicMutexHelper mutexhlp(&g_mutexLBES);
        //
        // Global LangBarEventSink
        //
        if (mutexhlp.Enter())
        {
            for (nId = 0; nId < MAX_LPES_NUM; nId++)
            {
                if ((GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE) &&
                    (GetSharedMemory()->lbes[nId].m_dwThreadId == dwCurThreadId) &&
                    (GetSharedMemory()->lbes[nId].m_dwProcessId == dwCurProcessId) &&
                    (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
                {
                    pSinkGlobal = psfn->_pLangBarEventSink;

                    dwSinkCookie = GetSharedMemory()->lbes[nId].m_dwCookie;

                    //
                    // clear message mask.
                    //
                    GetSharedMemory()->lbes[nId].m_dwFlags &= ~dwMsgMaskFlag;

                    //
                    // clear last posted message.
                    //
                    GetSharedMemory()->lbes[nId].m_lastmsg.uMsg = 0;
                    GetSharedMemory()->lbes[nId].m_lastmsg.wParam = 0;
                    GetSharedMemory()->lbes[nId].m_lastmsg.lParam = 0;
                    break;
                }
            }
            mutexhlp.Leave();
        }
    }

    if (pSinkLocal)
        CallFocusNotifySink(pSinkLocal, uMsg, wParam, lParam, TRUE, dwSinkCookie);

    if (pSinkGlobal)
        CallFocusNotifySink(pSinkGlobal, uMsg, wParam, lParam, FALSE, dwSinkCookie);
}

// --------------------------------------------------------------------------
//
//  CallFocusNotifySink
//
// --------------------------------------------------------------------------

void CallFocusNotifySink(ITfLangBarEventSink *pSink, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fLocalSink, DWORD dwSinkCookie)
{
    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    SYSTHREAD *psfn;
   
    if (uMsg == g_msgSetFocus)
    {
        DWORD dwActiveThreadId;
        dwActiveThreadId = GetSharedMemory()->dwFocusThread;
        if (g_timlist.IsThreadId(dwActiveThreadId))
        {
            DWORD dwProcessId = GetSharedMemory()->dwFocusProcess;
            if (dwProcessId != dwCurProcessId)
            {
#if 0
                if (NotifyTryAgain(dwProcessId, dwActiveThreadId))
                {
                    HWND hwndMarshal;
                    if (hwndMarshal = EnsureMarshalWnd())
                    {
                        KillTimer(hwndMarshal, MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS);
                        SetTimer(hwndMarshal, 
                                 MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS,
                                 100, NULL);
                    }
                    goto Exit;
                }
#endif
            }
            if ((!fLocalSink || dwActiveThreadId == dwCurThreadId) &&
                (psfn = GetSYSTHREAD()))
            {
                psfn->fInmsgSetFocus = TRUE;
                _try {
                    pSink->OnSetFocus(dwActiveThreadId);
                }
                _except(CicExceptionFilter(GetExceptionInformation())) {
                    //
                    // On NT5, if we get an exception in MsgHookProc,
                    // it is unhooked by system. To keep the hook,
                    // we handle any excpeiton here.
                    //
                    Assert(0);

                    //
                    // Then we enregister the Sink. Don't use it any more.
                    //
                    // UnregisterLangBarNotifySink(dwSinkCookie);
                }
                psfn->fInmsgSetFocus = FALSE;
            }
        }
    }
    else if (uMsg == g_msgThreadTerminate)
    {            
        if (!fLocalSink && // skip this call for local sinks, they should already be unadvised
            (psfn = GetSYSTHREAD()))
        {
            psfn->fInmsgThreadTerminate = TRUE;
            _try {
                pSink->OnThreadTerminate((DWORD)lParam);
            }
            _except(CicExceptionFilter(GetExceptionInformation())) {
                //
                // On NT5, if we get an exception in MsgHookProc,
                // it is unhooked by system. To keep the hook,
                // we handle any excpeiton here.
                //
                Assert(0);

                //
                // Then we enregister the Sink. Don't use it any more.
                //
                // UnregisterLangBarNotifySink(dwSinkCookie);
            }
            psfn->fInmsgThreadTerminate = FALSE;
        }
    }
    else if (uMsg == g_msgThreadItemChange)
    {
        if (g_timlist.IsThreadId((DWORD)lParam) &&
            (psfn = GetSYSTHREAD()))
        {
            DWORD dwProcessId;

            if (psfn->fInmsgThreadItemChange)
                goto Exit;

            if ((DWORD)lParam == GetSharedMemory()->dwFocusThread)
                dwProcessId = GetSharedMemory()->dwFocusProcess;
            else 
                dwProcessId = g_timlist.GetProcessId((DWORD)lParam);

#if 0
            if (dwProcessId != dwCurProcessId)
            {
                if (NotifyTryAgain(dwProcessId, (DWORD)lParam))
                {
                    PostThreadMessage(dwCurThreadId,uMsg, 0, lParam);
                    goto Exit;
                }
            }
#endif

            psfn->fInmsgThreadItemChange = TRUE;
            _try {
                pSink->OnThreadItemChange((DWORD)lParam);
            }
            _except(CicExceptionFilter(GetExceptionInformation())) {
                //
                // On NT5, if we get an exception in MsgHookProc,
                // it is unhooked by system. To keep the hook,
                // we handle any excpeiton here.
                //
                Assert(0);

                //
                // Then we enregister the Sink. Don't use it any more.
                //
                // UnregisterLangBarNotifySink(dwSinkCookie);
            }
            psfn->fInmsgThreadItemChange = FALSE;
        }
    }
    else if (uMsg == g_msgShowFloating)
    {
        _try {
            pSink->ShowFloating((DWORD)lParam);
        }
        _except(CicExceptionFilter(GetExceptionInformation())) {
            //
            // On NT5, if we get an exception in MsgHookProc,
            // it is unhooked by system. To keep the hook,
            // we handle any excpeiton here.
            //
            Assert(0);

            //
            // Then we enregister the Sink. Don't use it any more.
            //
            // UnregisterLangBarNotifySink(dwSinkCookie);
        }
    }
    else if (uMsg == g_msgLBUpdate)
    {
        _try {
            ITfLangBarEventSink_P *pSinkP;
            if (SUCCEEDED(pSink->QueryInterface(IID_ITfLangBarEventSink_P, (void **)&pSinkP)) && pSinkP)
            {
                pSinkP->OnLangBarUpdate((DWORD)wParam, lParam);
                pSinkP->Release();
            }
        }
        _except(CicExceptionFilter(GetExceptionInformation())) {
            //
            // On NT5, if we get an exception in MsgHookProc,
            // it is unhooked by system. To keep the hook,
            // we handle any excpeiton here.
            //
            Assert(0);

            //
            // Then we enregister the Sink. Don't use it any more.
            //
            // UnregisterLangBarNotifySink(dwSinkCookie);
        }
    }

Exit:
    return;
}


// --------------------------------------------------------------------------
//
//  SetModalLBarSink
//
// --------------------------------------------------------------------------

void SetModalLBarSink(DWORD dwTargetThreadId, BOOL fSet, DWORD dwFlags)
{
    int nId;
    CCicMutexHelper mutexhlp(&g_mutexLBES);

    Assert(!(0xffff0000 & dwFlags));

    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if (GetSharedMemory()->lbes[nId].m_dwThreadId == GetCurrentThreadId())
            {
                LPARAM lParam  = (LPARAM)((nId << 16) + (dwFlags & 0xffff));
                PostThreadMessage(dwTargetThreadId,
                                  g_msgPrivate, 
                                  fSet ? TFPRIV_SETMODALLBAR : TFPRIV_RELEASEMODALLBAR,
                                  (LPARAM)lParam);
                break;
            }
        }
        mutexhlp.Leave();
    }
}

// --------------------------------------------------------------------------
//
//  SetModalLBarId
//
// --------------------------------------------------------------------------

void SetModalLBarId(int nId, DWORD dwFlags)
{
     SYSTHREAD *psfn;

     if (psfn = GetSYSTHREAD())
     {
         psfn->nModalLangBarId = nId;
         psfn->dwModalLangBarFlags = dwFlags;
     }
}

// --------------------------------------------------------------------------
//
//  HandlModalLBar
//
// --------------------------------------------------------------------------

BOOL HandleModalLBar(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    DWORD dwThreadId = 0;

    if (psfn == NULL)
        return FALSE;

    if (psfn->nModalLangBarId == -1)
         return FALSE;

    if ((((uMsg >= WM_NCMOUSEMOVE) && (uMsg <= WM_NCMBUTTONDBLCLK)) ||
         ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST)))  &&
        (psfn->dwModalLangBarFlags & TF_LBSMI_FILTERCURRENTTHREAD))
    {
         POINT pt = {LOWORD((DWORD)lParam), HIWORD((DWORD)lParam)};
         HWND hwnd = WindowFromPoint(pt);
         if (GetCurrentThreadId() == GetWindowThreadProcessId(hwnd, NULL))
             return FALSE;
    }

    CCicMutexHelper mutexhlp(&g_mutexLBES);
    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        if (GetSharedMemory()->lbes[psfn->nModalLangBarId].m_dwFlags & LBESF_INUSE)
            dwThreadId = GetSharedMemory()->lbes[psfn->nModalLangBarId].m_dwThreadId;

        mutexhlp.Leave();
    }

    if (!dwThreadId)
    {
        psfn->nModalLangBarId = -1;
        return FALSE;
    }
    
    Assert(g_timlist.IsThreadId(dwThreadId));

    //
    // Here, we will lost HIWORD(uMsg) and HIWORD(wParam).
    //
    // if we need scan code for WM_KEYxxx, message. we need to put it 
    // HIBYTE(LOWORD(wParam))
    //
    PostThreadMessage(dwThreadId,
                      g_msgLBarModal, 
                      (WPARAM)((LOWORD(uMsg) << 16) | LOWORD(wParam)),
                      lParam);
    return TRUE;
}

// --------------------------------------------------------------------------
//
//  DispatchModalLBar
//
// --------------------------------------------------------------------------

BOOL DispatchModalLBar(WPARAM wParam, LPARAM lParam)
{
    int nId;

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    ITfLangBarEventSink *pSink = NULL;

    //
    // we don't need to check Local LangBarEventSink
    //

    CCicMutexHelper mutexhlp(&g_mutexLBES);
    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if ((GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE) &&
                (GetSharedMemory()->lbes[nId].m_dwThreadId == dwCurThreadId) &&
                (GetSharedMemory()->lbes[nId].m_dwProcessId == dwCurProcessId) &&
                (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
            {
                pSink = psfn->_pLangBarEventSink;
                break;
            }
        }
        mutexhlp.Leave();
    }
   
    if (pSink)
    {
        //
        // restore uMsg and wParam from posted wParam.
        //
       
        _try {
            pSink->OnModalInput(GetSharedMemory()->dwFocusThread,
                                (UINT)HIWORD(wParam),
                                (WPARAM)LOWORD(wParam),
                                lParam);
        }
        _except(CicExceptionFilter(GetExceptionInformation())) {
            Assert(0);
        }
    }
    return TRUE;
}

// --------------------------------------------------------------------------
//
//  ThreadGetItemFloatingRect
//
// --------------------------------------------------------------------------

HRESULT ThreadGetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    ITfLangBarEventSink *pSink = NULL;
    DWORD dwThreadIdSink = 0;
    int nId;

    CCicMutexHelper mutexhlp(&g_mutexLBES);
    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if (GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE)
            {
                if (!dwThreadIdSink)
                    dwThreadIdSink = GetSharedMemory()->lbes[nId].m_dwThreadId;

                if ((GetSharedMemory()->lbes[nId].m_dwThreadId == dwCurThreadId) &&
                    (GetSharedMemory()->lbes[nId].m_dwProcessId == dwCurProcessId) &&
                    (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
                {
                    pSink = psfn->_pLangBarEventSink;
                    break;
                }
            }
        }
        mutexhlp.Leave();
    }

    if (pSink)
        return pSink->GetItemFloatingRect(dwThreadId, rguid, prc);

    HRESULT hrRet = E_FAIL;
    if (dwThreadIdSink)
    {
        ITfLangBarItemMgr *plbim;

        if ((GetThreadUIManager(dwThreadIdSink, &plbim, NULL) == S_OK) && plbim)
        {
            hrRet = plbim->GetItemFloatingRect(dwThreadId, rguid, prc);
            plbim->Release();
        }
    }

    return hrRet;
}

// --------------------------------------------------------------------------
//
//  IsCTFMONBusy
//
// --------------------------------------------------------------------------

const TCHAR c_szLoaderWndClass[] = TEXT("CicLoaderWndClass");

BOOL IsCTFMONBusy()
{
    HWND hwndLoader = NULL;
    DWORD dwProcessId;
    DWORD dwThreadId;

    hwndLoader = FindWindow(c_szLoaderWndClass, NULL);

    if (!hwndLoader)
        return FALSE;

    dwThreadId = GetWindowThreadProcessId(hwndLoader, &dwProcessId);

    if (!dwThreadId)
        return FALSE;

    return NotifyTryAgain(dwProcessId, dwThreadId);
}

// --------------------------------------------------------------------------
//
//  IsInPopupMenuMode
//
// --------------------------------------------------------------------------

BOOL IsInPopupMenuMode()
{
    //
    // bug: 399755
    //
    // when the popup menu is being shown, the OLE RPC and Cicero marshalling
    // get blocked the thread. We should postpone plbim->OnUpdateHandler().
    //

    DWORD dwThreadId = GetCurrentThreadId();
    GUITHREADINFO gti;
    gti.cbSize = sizeof(GUITHREADINFO);

    if (!GetGUIThreadInfo(dwThreadId, &gti))
        return FALSE;


    return (gti.flags & GUI_POPUPMENUMODE) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\funcprv.cpp ===
//
// funcprv.cpp
//

#include "private.h"
#include "globals.h"
#include "funcprv.h"
#include "fnrecon.h"
#include "helpers.h"
#include "immxutil.h"
#include "ic.h"

DBG_ID_INSTANCE(CFunctionProvider);

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunctionProvider::CFunctionProvider()
{
    Dbg_MemSetThisNameID(TEXT("CFunctionProvider"));

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunctionProvider::~CFunctionProvider()
{
}


//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetType(GUID *pguid)
{
    *pguid = GUID_SYSTEM_FUNCTIONPROVIDER;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetDescription(BSTR *pbstrDesc)
{
    *pbstrDesc = SysAllocString(L"System Function Provider");
    return *pbstrDesc != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    if (!ppunk)
        return E_INVALIDARG;

    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_UNEXPECTED;

    if (IsEqualIID(riid, IID_ITfFnReconversion))
    {
        CFnReconversion *pReconv = new CFnReconversion(this);
        pReconv->QueryInterface(IID_IUnknown, (void **)ppunk);
        pReconv->Release();
    }
    else if (IsEqualIID(riid, IID_ITfFnAbort))
    {
        *ppunk = new CFnAbort(this);
    }

    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "resource.h"
#include "ptrary.h"
#include "strary.h"
#include "cicmutex.h"
#include "tfpriv.h"
#include "ctflbui.h"
#include "csecattr.h"

void CheckAnchorStores();
extern BOOL g_fNoITextStoreAnchor;

inline size_t Align(size_t a)
{
     //
     // Alignment width should be 8 BYTES for IA64 wow64 platform
     // even x86 build enviroment.
     //
     return (size_t) ((a + 7) & ~7);
}

#ifndef StringCopyArray
#define StringCopyArray(Dstr, Sstr)     StringCchCopy((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCopyArrayA
#define StringCopyArrayA(Dstr, Sstr)    StringCchCopyA((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCopyArrayW
#define StringCopyArrayW(Dstr, Sstr)    StringCchCopyW((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCatArray
#define StringCatArray(Dstr, Sstr)     StringCchCat((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCatArrayA
#define StringCatArrayA(Dstr, Sstr)    StringCchCatA((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCatArrayW
#define StringCatArrayW(Dstr, Sstr)    StringCchCatW((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif


#define LANGIDFROMHKL(x) LANGID(LOWORD(HandleToLong(x)))

#define BACKDOOR_EDIT_COOKIE    ((DWORD)1) // 0 is TF_INVALID_EDIT_COOKIE

#define EC_MIN                  (BACKDOOR_EDIT_COOKIE + 1) // minimum value to avoid collisions with reserved values


//
// timer ids for marshaling window
//
#define MARSHALWND_TIMER_UPDATEKANACAPS      1
#define MARSHALWND_TIMER_NUIMGRDIRTYUPDATE   2
#define MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS   3

//
// alignment for platforms.
//
#define CIC_ALIGNMENT 7

extern TfGuidAtom g_gaApp;
extern TfGuidAtom g_gaSystem;

extern BOOL g_fCTFMONProcess;
extern BOOL g_fCUAS;
extern TCHAR g_szCUASImeFile[];

extern DWORD g_dwThreadDllMain;
#define ISINDLLMAIN() ((g_dwThreadDllMain == GetCurrentThreadId()) ? TRUE : FALSE)

extern CCicCriticalSectionStatic g_cs;
extern CCicCriticalSectionStatic g_csInDllMain;

#ifndef DEBUG

#define CicEnterCriticalSection(lpCriticalSection)  EnterCriticalSection(lpCriticalSection)

#else // DEBUG

extern const TCHAR *g_szMutexEnterFile;
extern int g_iMutexEnterLine;

//
// In debug, you can see the file/line number where g_cs was last entered
// by checking g_szMutexEnterFile and g_iMutexEnterLine.
//
#define CicEnterCriticalSection(lpCriticalSection)              \
{                                                               \
    Assert((g_dwThreadDllMain != GetCurrentThreadId()) ||       \
           (lpCriticalSection == (CRITICAL_SECTION *)g_csInDllMain));              \
                                                                \
    EnterCriticalSection(lpCriticalSection);                    \
                                                                \
    if (lpCriticalSection == (CRITICAL_SECTION *)g_cs)                             \
    {                                                           \
        g_szMutexEnterFile = __FILE__;                          \
        g_iMutexEnterLine = __LINE__;                           \
        /* need the InterlockedXXX to keep retail from optimizing away the assignment */ \
        InterlockedIncrement((long *)&g_szMutexEnterFile);      \
        InterlockedDecrement((long *)&g_szMutexEnterFile);      \
        InterlockedIncrement((long *)&g_iMutexEnterLine);       \
        InterlockedDecrement((long *)&g_iMutexEnterLine);       \
    }                                                           \
}

#endif // DEBUG

inline void CicLeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    Assert((g_dwThreadDllMain != GetCurrentThreadId()) || 
           (lpCriticalSection == (CRITICAL_SECTION *)g_csInDllMain));

    LeaveCriticalSection(lpCriticalSection);
}

extern HKL g_hklDefault;

extern const GUID GUID_APPLICATION;
extern const GUID GUID_SYSTEM;

//
// application compatibility flag
//
//
#define CIC_COMPAT_NOWAITFORINPUTIDLEONWIN9X   0x00000001
#define CIC_COMPAT_DELAYFIRSTACTIVATEKBDLAYOUT 0x00000002
extern DWORD g_dwAppCompatibility;
#define CicTestAppCompat(x)   ((g_dwAppCompatibility & (x)) ? TRUE : FALSE)
extern BOOL InitAppCompatFlags();
extern void InitCUASFlag();

extern const TCHAR c_szCTFKey[];
extern const TCHAR c_szTIPKey[];
extern const TCHAR c_szCTFTIPKey[];
extern const TCHAR c_szLangBarKey[];
extern const WCHAR c_szDescriptionW[];
extern const WCHAR c_szMUIDescriptionW[];
extern const WCHAR c_szEnableW[];
extern const TCHAR c_szEnable[];
extern const TCHAR c_szDisabledOnTransitory[];
extern const TCHAR c_szAsmKey[];
extern const TCHAR c_szCompartKey[];
extern const TCHAR c_szGlobalCompartment[];
extern const TCHAR c_szNonInit[];
extern const TCHAR c_szDefault[];
extern const TCHAR c_szProfile[];
extern const WCHAR c_szProfileW[];
extern const TCHAR c_szDefaultAsmName[];
extern const TCHAR c_szUpdateProfile[];
extern const TCHAR c_szAssembly[];
extern const TCHAR c_szLanguageProfileKey[];
extern const TCHAR c_szSubstitutehKL[];
extern const TCHAR c_szKeybaordLayout[];
extern const WCHAR c_szIconFileW[];
extern const TCHAR c_szIconIndex[];
extern const WCHAR c_szIconIndexW[];
extern const TCHAR c_szShowStatus[];
extern const TCHAR c_szLabel[];
extern const TCHAR c_szTransparency[];
extern const TCHAR c_szExtraIconsOnMinimized[];
extern const TCHAR c_szLocaleInfo[];
extern const TCHAR c_szLocaleInfoNT4[];
extern const TCHAR c_szKeyboardLayout[];
extern const TCHAR c_szKeyboardLayoutKey[];
extern const TCHAR c_szKbdUSNameNT[];
extern const TCHAR c_szKbdUSName[];
extern const TCHAR c_szLayoutFile[];
extern const TCHAR c_szIMEFile[];
extern const TCHAR c_szRunInputCPLCmdLine[];
extern const TCHAR c_szRunInputCPL[];
extern const TCHAR c_szRunInputCPLOnWin9x[];
extern const TCHAR c_szRunInputCPLOnNT51[];
extern const TCHAR c_szCicMarshalClass[];
extern const TCHAR c_szCicMarshalWnd[];
extern const TCHAR c_szHHEXELANGBARCHM[];
extern const TCHAR c_szHHEXE[];
extern const TCHAR c_szAppCompat[];
extern const TCHAR c_szCompatibility[];
extern const TCHAR c_szCtfShared[];
extern const TCHAR c_szCUAS[];
extern const TCHAR c_szIMMKey[];
extern const TCHAR c_szCUASIMEFile[];


extern HINSTANCE g_hInst;
extern DWORD g_dwTLSIndex;

class CThreadInputMgr;
class CLangBarItemMgr;
class CLangBarMgr;
class CLBarItemCtrl;
class CLBarItemHelp;
class CLBarItemReconv;
class CLBarItemWin32IME;
class CLBarItemDeviceType;
class CDisplayAttributeMgr;
class CInputProcessorProfiles;
class CAssemblyList;
class CStub;
class CSharedHeap;
class CSharedBlock;
class CInputContext;
class CGlobalCompartmentMgr;

typedef struct tag_LANGBARADDIN {
    GUID  _guid;
    CLSID _clsid;
    ITfLangBarAddIn *_plbai;
    HINSTANCE _hInst;
    BOOL _fStarted : 1;
    BOOL _fEnabled : 1;
    WCHAR _wszFilePath[MAX_PATH];
} LANGBARADDIN;

typedef enum { COPY_ANCHORS, OWN_ANCHORS } AnchorOwnership;

typedef struct tag_TL_THREADINFO {
    DWORD dwThreadId;
    DWORD dwProcessId;
    DWORD dwFlags;

    //
    // handle of marshal worker window.
    //
    CAlignWinHandle<HWND>  hwndMarshal;

    //
    // now this thread is being called by Stub.
    //
    ULONG ulInMarshal;

    //
    // now this thread is waiting for marshaling reply from the thread.
    //
    DWORD dwMarshalWaitingThread;

    DWORD dwTickTime;

    //
    // Store the keyboard layout of console app here.
    //
    CAlignWinHKL  hklConsole;

} TL_THREADINFO;

typedef struct
{
    CThreadInputMgr *ptim;
    CLangBarItemMgr *plbim;
    CDisplayAttributeMgr *pdam;
    CInputProcessorProfiles *pipp;

    DWORD dwThreadId;
    DWORD dwProcessId;

    UINT uMsgRemoved;
    DWORD dwMsgTime;

    CAssemblyList *pAsmList;
    LANGID langidCurrent;
    LANGID langidPrev;
    BOOL bInImeNoImeToggle : 1;

    BOOL bLangToggleReady : 1;    // Lang hotkey toggle flag.
    BOOL bKeyTipToggleReady : 1;  // Lang hotkey toggle flag.
    int  nModalLangBarId;
    int  dwModalLangBarFlags;

    ULONG ulMshlCnt;
    HWND  hwndMarshal;

    CPtrArray<CStub> *prgStub;

    CSharedHeap *psheap;
    CPtrArray<CSharedBlock> *prgThreadMem;

    HKL hklDelayActive;
    HKL hklBeingActivated;

    //
    // delay focus DIM change.
    // Cicero saves the last focused window here in CBT hook. And actual
    // _SetFocus() will be done in TFPRIV_ONSETWIDOWFOCUS.
    //
    HWND hwndBeingFocused;
    BOOL fSetWindowFocusPosted : 1;

    BOOL fCTFMON : 1;
    BOOL fInmsgSetFocus : 1;
    BOOL fInmsgThreadItemChange : 1;
    BOOL fInmsgThreadTerminate : 1;
    BOOL fInActivateAssembly : 1;
    BOOL fInitCapsKanaIndicator : 1;
    BOOL fRemovingInputLangChangeReq : 1;
    BOOL fInitGlobalCompartment : 1;
    BOOL fStopImm32HandlerInHook : 1;
    BOOL fStopLangHotkeyHandlerInHook : 1;

    //
    // CUAS
    //
    BOOL fCUASInCtfImmLastEnabledWndDestroy : 1;
    BOOL fCUASNoVisibleWindowChecked : 1;
    BOOL fCUASInCreateDummyWnd : 1;
    BOOL fCUASDllDetachInOtherOrMe : 1;
    BOOL fUninitThreadOnShuttingDown : 1;
    BOOL fDeactivatingTIP : 1;

    ULONG uDestroyingMarshalWnd;

    TL_THREADINFO *pti;

    //
    // Workaround for global keyboard hook
    //
    HHOOK hThreadKeyboardHook;
    HHOOK hThreadMouseHook;

    //
    // For CH IME-NonIME toggle hotkey
    //
    LANGID langidPrevForCHHotkey;
    GUID   guidPrevProfileForCHHotkey;
    HKL   hklPrevForCHHotkey;

    DWORD _dwLockRequestICRef;
    DWORD _fLockRequestPosted;

    CGlobalCompartmentMgr *_pGlobalCompMgr;
    CAlignWinHandle<HWND>  hwndOleMainThread;

    CPtrArray<LANGBARADDIN> *prgLBAddIn;
    BOOL fLBAddInLoaded;

    ITfLangBarEventSink    *_pLangBarEventSink;
    DWORD                  _dwLangBarEventCookie;

} SYSTHREAD;

extern SYSTHREAD *GetSYSTHREAD();
extern SYSTHREAD *FindSYSTHREAD();
extern void FreeSYSTHREAD();

class CCatGUIDTbl;
extern CCatGUIDTbl *g_pCatGUIDTbl;

class CTimList;
extern CTimList g_timlist;

// registered messages
extern UINT g_msgPrivate;
extern UINT g_msgSetFocus;
extern UINT g_msgThreadTerminate;
extern UINT g_msgThreadItemChange;
extern UINT g_msgLBarModal;
extern UINT g_msgRpcSendReceive;
extern UINT g_msgThreadMarshal;
extern UINT g_msgCheckThreadInputIdel;
#ifdef POINTER_MARSHAL
extern UINT g_msgPointerMarshal;
#endif
extern UINT g_msgStubCleanUp;
extern UINT g_msgShowFloating;
extern UINT g_msgLBUpdate;
extern UINT g_msgNuiMgrDirtyUpdate;

extern HWND g_hwndLastForeground;
extern DWORD g_dwThreadLastFocus;

#define TF_S_GENERALPROPSTORE        MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x0401)
#define TF_S_PROPSTOREPROXY          MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x0402)

//
// default.cpp
//
extern LONG WINAPI CicExceptionFilter(struct _EXCEPTION_POINTERS *pExceptionInfo);
extern CAssemblyList *EnsureAssemblyList(SYSTHREAD *psfn, BOOL fUpdate = FALSE);
extern LANGID GetCurrentAssemblyLangId(SYSTHREAD *psfn);
extern void SetCurrentAssemblyLangId(SYSTHREAD *psfn, LANGID langid);
extern BOOL TF_InitThreadSystem(void);
extern BOOL TF_UninitThreadSystem(void);
extern void UninitProcess();
extern BOOL OnForegroundChanged(HWND hwndFocus);
extern void OnIMENotify();
extern void KanaCapsUpdate(SYSTHREAD *psfn);
extern void StartKanaCapsUpdateTimer(SYSTHREAD *psfn);
BOOL InitUniqueString();
void GetDesktopUniqueName(const TCHAR *pszPrefix, TCHAR *pch, ULONG cchPch);
BOOL IsMsctfEnabledUser();

#define GetDesktopUniqueNameArray(prefix, buf)    \
GetDesktopUniqueName((prefix), buf, ARRAYSIZE(buf));

//
// ithdmshl.cpp and focusnfy.cpp
//
void SetFocusNotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam);
void MakeSetFocusNotify(UINT uMsg, WPARAM wParam, LPARAM lParam);
void SetModalLBarSink(DWORD dwTargetThreadId, BOOL fSet, DWORD dwFlags);
void SetModalLBarId(int nId, DWORD dwFlags);
BOOL HandleModalLBar(UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL DispatchModalLBar(WPARAM wParam, LPARAM lParam);
HRESULT ThreadGetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
BOOL InitSharedHeap();
BOOL DestroySharedHeap();
BOOL IsCTFMONBusy();
BOOL IsInPopupMenuMode();

//
// nuihkl.cpp
//
BOOL GetFontSig(HWND hwnd, HKL hKL);
void PostInputLangRequest(SYSTHREAD *psfn, HKL hkl, BOOL fUsePost);
void FlushIconIndex(SYSTHREAD *psfn);

//
// imelist.h
//
BOOL InitProfileRegKeyStr(char *psz, ULONG cchMax, REFCLSID rclsid, LANGID langid, REFGUID guidProfile);

#include "catmgr.h"
inline BOOL MyIsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid)
{
    BOOL fEqual;

    CCategoryMgr::s_IsEqualTfGuidAtom(guidatom, rguid, &fEqual);

    return fEqual;
}

inline HRESULT MyGetGUID(TfGuidAtom guidatom, GUID *pguid)
{
    return CCategoryMgr::s_GetGUID(guidatom, pguid);
}

inline HRESULT MyRegisterCategory(REFGUID rcatid, REFGUID rguid)
{
    return CCategoryMgr::s_RegisterCategory(GUID_SYSTEM, rcatid, rguid);
}

inline HRESULT MyUnregisterCategory(REFGUID rcatid, REFGUID rguid)
{
    return CCategoryMgr::s_UnregisterCategory(GUID_SYSTEM, rcatid, rguid);
}

inline HRESULT MyRegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom)
{
    return CCategoryMgr::s_RegisterGUID(rguid, pguidatom);
}

inline HRESULT MyRegisterGUIDDescription(REFGUID rguid, WCHAR *psz)
{
    return CCategoryMgr::s_RegisterGUIDDescription(GUID_SYSTEM, rguid, psz);
}

inline HRESULT MyUnregisterGUIDDescription(REFGUID rguid)
{
    return CCategoryMgr::s_UnregisterGUIDDescription(GUID_SYSTEM, rguid);
}

inline HRESULT MyGetGUIDDescription(REFGUID rguid, BSTR *pbstr)
{
    return CCategoryMgr::s_GetGUIDDescription(rguid, pbstr);
}

inline HRESULT MyGetGUIDValue(REFGUID rguid, const WCHAR *psz, BSTR *pbstr)
{
    return CCategoryMgr::s_GetGUIDValue(rguid, psz, pbstr);
}

inline HRESULT MyRegisterGUIDDWORD(REFGUID rguid, DWORD dw)
{
    return CCategoryMgr::s_RegisterGUIDDWORD(GUID_SYSTEM, rguid, dw);
}

inline HRESULT MyUnregisterGUIDDWORD(REFGUID rguid)
{
    return CCategoryMgr::s_UnregisterGUIDDWORD(GUID_SYSTEM, rguid);
}

inline HRESULT MyGetGUIDDWORD(REFGUID rguid, DWORD *pdw)
{
    return CCategoryMgr::s_GetGUIDDWORD(rguid, pdw);
}

inline BOOL MyIsValidGUIDATOM(TfGuidAtom guidatom)
{
    return CCategoryMgr::s_IsValidGUIDATOM(guidatom);
}

inline HRESULT MyEnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return CCategoryMgr::s_EnumItemsInCategory(rcatid, ppEnum);
}

typedef struct tag_LBESLASTMSG {
   UINT uMsg;
   CAlignPointer<WPARAM> wParam;
   CAlignPointer<LPARAM> lParam;
} LBESLASTMSG;

typedef struct tag_LBAREVENTSINK {
   DWORD                  m_dwProcessId;
   DWORD                  m_dwThreadId;
   DWORD                  m_dwCookie;
   DWORD                  m_dwLangBarFlags;
   DWORD                  m_dwFlags;
   CAlignWinHandle<HWND>  m_hWnd;       // window handle to avoid notification.
   LBESLASTMSG            m_lastmsg;
} LBAREVENTSINK;

typedef struct tag_LBAREVENTSINKLOCAL {
   ITfLangBarEventSink* m_pSink;
   LBAREVENTSINK lb;
} LBAREVENTSINKLOCAL;

#define LBESF_INUSE              0x00000001
#define LBESF_SETFOCUSINQUEUE    0x00000002

extern CStructArray<LBAREVENTSINKLOCAL> *g_rglbes;


extern BOOL g_fDllProcessDetached;
extern BOOL g_bOnWow64;

typedef struct {
   BOOL   m_fInUse;
   DWORD  m_dwThreadId;
   DWORD  m_dwSrcThreadId;
   GUID   m_iid;
   CAlignPointer<LRESULT>  m_ref;
   union {
       DWORD    m_dwType;
       struct {
            //
            // IUnknown pointer used only own process.
            // Other process distingush exists interface.
            //
            CNativeOrWow64_Pointer<IUnknown*> m_punk;

            ULONG    m_ulStubId;
            DWORD    m_dwStubTime;
       };
   };
   TCHAR m_szName[_MAX_PATH];
   TCHAR m_szNameConnection[_MAX_PATH];
} THREADMARSHALINTERFACEDATA;

#define CBBUFFERSIZE       0x80 // 0x80 is enough for NUI manager

typedef struct {
   BOOL  m_fInUse;
   DWORD m_dwSize;
   BYTE  m_bBuffer[CBBUFFERSIZE];
} BUFFER, *PBUFFER;


//
// All shared memory for msctf.dll must live in this struct, it will
// be stored in a filemapping.
//
// Use GetSharedMemory()->myData to access shared memory.
//

typedef struct
{
    //
    // Issue:
    //
    // max number of the threads that can initialize marshaled interface same time.
    // 5 is enough??
    //
    #define NUM_TMD 5

    THREADMARSHALINTERFACEDATA tmd[NUM_TMD];

    //
    // The current focus thread, proccess and foreground window.
    //
    DWORD dwFocusThread;
    DWORD dwFocusProcess;
    CAlignWinHandle<HWND> hwndForeground;

    //
    // The previous focus thread, proccess and foreground window.
    //
    DWORD dwFocusThreadPrev;
    CAlignWinHandle<HWND> hwndForegroundPrev;


    //
    // The last thread of ITfThreadFocusSink
    //
    DWORD dwLastFocusSinkThread;

    //
    // Native/WOW6432 system hook
    //
    CNativeOrWow64_WinHandle<HHOOK> hSysShellHook;

    CNativeOrWow64_WinHandle<HHOOK> hSysGetMsgHook;
    CNativeOrWow64_WinHandle<HHOOK> hSysCBTHook;

    //
    // track shell hook WINDOWACTIVATE
    //
    BOOL fInFullScreen;

    //
    // Issue:
    //
    // we must take care of more Sinks.
    //
    #define MAX_LPES_NUM 5

    LBAREVENTSINK lbes[MAX_LPES_NUM];
    DWORD         dwlbesCookie;


    LONG    cProcessesMinus1;
    CAlignWinHandle<HANDLE>  hheapShared;    // Only use on Windows95/98 platform

    // MSAA activation ref count
    LONG    cMSAARef; // inited to -1 for win95 InterlockedIncrement compat

    DWORD dwPrevShowFloatingStatus;
} SHAREMEM;

class CCiceroSharedMem : public CCicFileMappingStatic
{
public:
    BOOL Start()
    {
        BOOL fAlreadyExists;
        TCHAR ach[MAX_PATH];

        GetDesktopUniqueName(TEXT("CiceroSharedMem"), ach, ARRAYSIZE(ach));

        Init(ach, NULL);
        // Init(TEXT("CiceroSharedMem"), NULL);

        CCicSecAttr sa;

        if (Create(sa, sizeof(SHAREMEM), &fAlreadyExists) == NULL)
            return FALSE;

        if (!fAlreadyExists)
        {
            // by default, every member initialize to 0

            // initialize other members here
            ((SHAREMEM *)_pv)->cProcessesMinus1 = -1;
            ((SHAREMEM *)_pv)->cMSAARef = -1;
        }

        return TRUE;
    }

    SHAREMEM *GetPtr() { return (SHAREMEM *)_pv; }

private:
};

extern CCiceroSharedMem g_SharedMemory;

inline SHAREMEM *GetSharedMemory() { return g_SharedMemory.GetPtr(); }
inline BOOL      IsSharedMemoryCreated() { return g_SharedMemory.IsCreated(); }

inline BOOL IsChinesePlatform()
{
    if (g_uACP == 936) 
        return TRUE;

    if (g_uACP == 950) 
        return TRUE;

    return FALSE;
}

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\ic.cpp ===
//
// ic.cpp
//

#include "private.h"
#include "ic.h"
#include "range.h"
#include "tim.h"
#include "prop.h"
#include "tsi.h"
#include "rprop.h"
#include "funcprv.h"
#include "immxutil.h"
#include "acp2anch.h"
#include "dim.h"
#include "rangebk.h"
#include "view.h"
#include "compose.h"
#include "anchoref.h"
#include "dam.h"

#define TW_ICOWNERSINK_COOKIE 0x80000000 // high bit must be set to avoid conflict with GenericAdviseSink!
#define TW_ICKBDSINK_COOKIE   0x80000001 // high bit must be set to avoid conflict with GenericAdviseSink!

DBG_ID_INSTANCE(CInputContext);

/* 12e53b1b-7d7f-40bd-8f88-4603ee40cf58 */
extern const IID IID_PRIV_CINPUTCONTEXT = { 0x12e53b1b, 0x7d7f, 0x40bd, {0x8f, 0x88, 0x46, 0x03, 0xee, 0x40, 0xcf, 0x58} };

const IID *CInputContext::_c_rgConnectionIIDs[IC_NUM_CONNECTIONPTS] =
{
    &IID_ITfTextEditSink,
    &IID_ITfTextLayoutSink,
    &IID_ITfStatusSink,
    &IID_ITfStartReconversionNotifySink,
    &IID_ITfEditTransactionSink,
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CInputContext::CInputContext(TfClientId tid)
              : CCompartmentMgr(tid, COMPTYPE_IC)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CInputContext"), PERF_CONTEXT_COUNTER);

    // we sometimes use _dwLastLockReleaseID-1, which must still be > IGNORE_LAST_LOCKRELEASED
    // Issue: need to handle wrap-around case
    _dwLastLockReleaseID = (DWORD)((int)IGNORE_LAST_LOCKRELEASED + 2);
}


//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_Init(CThreadInputMgr *tim,
                             CDocumentInputManager *dm, ITextStoreAnchor *ptsi,
                             ITfContextOwnerCompositionSink *pOwnerComposeSink)
{
    CTextStoreImpl *ptsiACP;

    _dm = dm; // no need to AddRef, cleared when the dm dies

    // scramble the _ec a bit to help debug calling EditSession on the wrong ic
    _ec = (TfEditCookie)((DWORD)(UINT_PTR)this<<8);
    if (_ec < EC_MIN) // for portability, win32 pointers can't have values this low
    {
        _ec = EC_MIN;
    }

    if (ptsi == NULL)
    {
        if ((ptsiACP = new CTextStoreImpl(this)) == NULL)
            return E_OUTOFMEMORY;

        _ptsi = new CACPWrap(ptsiACP);
        ptsiACP->Release();

        if (_ptsi == NULL)
            return E_OUTOFMEMORY;

        _fCiceroTSI = TRUE;
    }
    else
    {
        _ptsi = ptsi;
        _ptsi->AddRef();

        Assert(_fCiceroTSI == FALSE);
    }

    _pOwnerComposeSink = pOwnerComposeSink;
    if (_pOwnerComposeSink != NULL)
    {
        _pOwnerComposeSink->AddRef();
    }

    Assert(_pMSAAState == NULL);
    if (tim->_IsMSAAEnabled())
    {
        _InitMSAAHook(tim->_GetAAAdaptor());
    }

    Assert(_dwEditSessionFlags == 0);
    Assert(_dbg_fInOnLockGranted == FALSE);

    Assert(_fLayoutChanged == FALSE);
    Assert(_dwStatusChangedFlags == 0);
    Assert(_fStatusChanged == FALSE);

    _tidInEditSession = TF_CLIENTID_NULL;

    Assert(_pPropTextOwner == NULL);
    _dwSysFuncPrvCookie = GENERIC_ERROR_COOKIE;

    _gaKeyEventFilterTIP[LEFT_FILTERTIP] = TF_INVALID_GUIDATOM;
    _gaKeyEventFilterTIP[RIGHT_FILTERTIP] = TF_INVALID_GUIDATOM;
    _fInvalidKeyEventFilterTIP = TRUE;

    _pEditRecord = new CEditRecord(this); // perf: delay load
    if (!_pEditRecord)
        return E_OUTOFMEMORY;

    Assert(_pActiveView == NULL);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CInputContext::~CInputContext()
{
    CProperty *pProp;
    int i;
    SPAN *span;

    // being paranoid...these should be NULL
    Assert(_pICKbdSink == NULL);

    // nix any allocated properties
    while (_pPropList != NULL)
    {
        pProp = _pPropList;
        _pPropList = _pPropList->_pNext;
        delete pProp;
    }

    // nix any cached app changes
    for (i=0; i<_rgAppTextChanges.Count(); i++)
    {
        span = _rgAppTextChanges.GetPtr(i);
        span->paStart->Release();
        span->paEnd->Release();
    }

    Assert(_pMSAAState == NULL); // should have already cleaned up msaa hook

    Assert(_pOwnerComposeSink == NULL); // should cleared in _UnadviseSinks
    SafeRelease(_pOwnerComposeSink);

    Assert(_ptsi == NULL); // should be NULL, cleared in _UnadviseSinks
    SafeRelease(_ptsi);

    Assert(_pCompositionList == NULL); // all compositions should be terminated
    Assert(_rgLockQueue.Count() == 0); // all queue items should be freed

    //
    // all pending flag should be cleared 
    // Otherwise psfn->_dwfLockRequestICRef could be broken..
    //
    Assert(_dwPendingLockRequest == 0); 
}

//+---------------------------------------------------------------------------
//
// _AdviseSinks
//
// Called when this ic is pushed.
//
//----------------------------------------------------------------------------

void CInputContext::_AdviseSinks()
{
    if (_ptsi != NULL)
    {
        // attach our ITextStoreAnchorSink
        _ptsi->AdviseSink(IID_ITextStoreAnchorSink, SAFECAST(this, ITextStoreAnchorSink *), TS_AS_ALL_SINKS);
    }
}

//+---------------------------------------------------------------------------
//
// _UnadviseSinks
//
// Called when this ic is popped.
// All references to the ITextStore impl should be released here.
//
//----------------------------------------------------------------------------

void CInputContext::_UnadviseSinks(CThreadInputMgr *tim)
{
    // kill any compositions
    _AbortCompositions();

    SafeReleaseClear(_pEditRecord);
    SafeReleaseClear(_pActiveView);

    // for now just skip any pending edit sessions
    // do this here in case any of the edit sessions
    // have a ref to this ic
    
    _AbortQueueItems();

    if (_ptsi != NULL)
    {
        // detach our ITextStoreAnchorSink
        _ptsi->UnadviseSink(SAFECAST(this, ITextStoreAnchorSink *));
        // if there is an ic owner sink, unadvise it now while we still can
        // this is to help buggy clients
        _UnadviseOwnerSink();

        // if we're msaa hooked, unhook now
        // must do this before Releasing _ptsi
        if (_pMSAAState != NULL)
        {
            Assert(tim->_GetAAAdaptor() != NULL);
            _UninitMSAAHook(tim->_GetAAAdaptor());
        }

        // and let the ptsi go
        _ptsi->Release();
        _ptsi = NULL;
    }

    SafeReleaseClear(_pOwnerComposeSink);

    // our owning doc is no longer valid
    _dm = NULL;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    ITfContextOwner *pICOwnerSink;
    CTextStoreImpl *ptsi;
    IServiceProvider *psp;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = GENERIC_ERROR_COOKIE;

    if (punk == NULL)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (IsEqualIID(riid, IID_ITfContextOwner))
    {
        // there can be only one ic owner sink, so special case it
        if (!_IsCiceroTSI())
        {
            Assert(0); // sink should only used for def tsi
            return E_UNEXPECTED;
        }

        // use QueryService to get the tsi since msaa may be wrapping it
        if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK)
        {
            Assert(0);
            return E_UNEXPECTED;
        }

        hr = psp->QueryService(GUID_SERVICE_TF, IID_PRIV_CTSI, (void **)&ptsi);

        psp->Release();

        if (hr != S_OK)
        {
            Assert(0);
            return E_UNEXPECTED;
        }

        pICOwnerSink = NULL;

        if (ptsi->_HasOwner())
        {
            hr = CONNECT_E_ADVISELIMIT;
            goto ExitOwner;
        }

        if (FAILED(punk->QueryInterface(IID_ITfContextOwner, 
                                        (void **)&pICOwnerSink)))
        {
            hr = E_UNEXPECTED;
            goto ExitOwner;
        }

        ptsi->_AdviseOwner(pICOwnerSink);

ExitOwner:
        ptsi->Release();
        SafeRelease(pICOwnerSink);

        if (hr == S_OK)
        {
            *pdwCookie = TW_ICOWNERSINK_COOKIE;
        }

        return hr;
    }
    else if (IsEqualIID(riid, IID_ITfContextKeyEventSink))
    {
        // there can be only one ic kbd sink, so special case it
        if (_pICKbdSink != NULL)
            return CONNECT_E_ADVISELIMIT;

        if (FAILED(punk->QueryInterface(IID_ITfContextKeyEventSink, 
                                        (void **)&_pICKbdSink)))
            return E_UNEXPECTED;

        *pdwCookie = TW_ICKBDSINK_COOKIE;

        return S_OK;
    }

    return GenericAdviseSink(riid, punk, _c_rgConnectionIIDs, _rgSinks, IC_NUM_CONNECTIONPTS, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::UnadviseSink(DWORD dwCookie)
{
    if (dwCookie == TW_ICOWNERSINK_COOKIE)
    {
        // there can be only one ic owner sink, so special case it
        return _UnadviseOwnerSink();
    }
    else if (dwCookie == TW_ICKBDSINK_COOKIE)
    {
        // there can be only one ic owner sink, so special case it
        if (_pICKbdSink == NULL)
            return CONNECT_E_NOCONNECTION;

        SafeReleaseClear(_pICKbdSink);
        return S_OK;
    }

    return GenericUnadviseSink(_rgSinks, IC_NUM_CONNECTIONPTS, dwCookie);
}

//+---------------------------------------------------------------------------
//
// AdviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk)
{
    CTip *ctip;
    CLEANUPSINK *pCleanup;
    CThreadInputMgr *tim;
    ITfCleanupContextSink *pSink;

    if (punk == NULL)
        return E_INVALIDARG;

    if ((tim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    if (!tim->_GetCTipfromGUIDATOM(tid, &ctip) && (tid != g_gaApp))
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        if (_GetCleanupListIndex(tid) >= 0)
             return CONNECT_E_ADVISELIMIT;

        if (punk->QueryInterface(IID_ITfCleanupContextSink, (void **)&pSink) != S_OK)
            return E_NOINTERFACE;

        if ((pCleanup = _rgCleanupSinks.Append(1)) == NULL)
        {
            pSink->Release();
            return E_OUTOFMEMORY;
        }

        pCleanup->tid = tid;
        pCleanup->pSink = pSink;

        return S_OK;
    }

    return CONNECT_E_CANNOTCONNECT;
}

//+---------------------------------------------------------------------------
//
// UnadviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::UnadviseSingleSink(TfClientId tid, REFIID riid)
{
    int i;

    if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        if ((i = _GetCleanupListIndex(tid)) < 0)
             return CONNECT_E_NOCONNECTION;

        _rgCleanupSinks.GetPtr(i)->pSink->Release();
        _rgCleanupSinks.Remove(i, 1);

        return S_OK;
    }

    return CONNECT_E_NOCONNECTION;
}

//+---------------------------------------------------------------------------
//
// _UnadviseOwnerSink
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_UnadviseOwnerSink()
{
    IServiceProvider *psp;
    CTextStoreImpl *ptsi;
    HRESULT hr;

    if (!_IsCiceroTSI())
        return E_UNEXPECTED; // only our default tsi can accept an owner sink

    if (!_IsConnected()) // _ptsi is not safe if disconnected
        return TF_E_DISCONNECTED;

    // use QueryService to get the tsi since msaa may be wrapping it
    if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    hr = psp->QueryService(GUID_SERVICE_TF, IID_PRIV_CTSI, (void **)&ptsi);

    psp->Release();

    if (hr != S_OK)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (!ptsi->_HasOwner())
    {
        hr = CONNECT_E_NOCONNECTION;
        goto Exit;
    }

    ptsi->_UnadviseOwner();

    hr = S_OK;

Exit:
    ptsi->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetProperty(REFGUID rguidProp, ITfProperty **ppv)
{
    CProperty *property;
    HRESULT hr;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    hr = _GetProperty(rguidProp, &property);

    *ppv = property;
    return hr;
}

//+---------------------------------------------------------------------------
//
// _GetProperty
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_GetProperty(REFGUID rguidProp, CProperty **ppv)
{
    CProperty *pProp = _FindProperty(rguidProp);
    DWORD dwAuthority = PROPA_NONE;
    TFPROPERTYSTYLE propStyle;
    DWORD dwPropFlags;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = pProp;

    if (pProp != NULL)
    {
        (*ppv)->AddRef();
        return S_OK;
    }

    //
    // Overwrite propstyle for known properties.
    //
    if (IsEqualGUID(rguidProp, GUID_PROP_ATTRIBUTE))
    {
        propStyle = TFPROPSTYLE_STATIC;
        dwAuthority = PROPA_FOCUSRANGE | PROPA_TEXTOWNER | PROPA_WONT_SERIALZE;
        dwPropFlags = PROPF_VTI4TOGUIDATOM;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_READING))
    {
        propStyle = TFPROPSTYLE_CUSTOM;
        dwPropFlags = 0;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_COMPOSING))
    {
        propStyle = TFPROPSTYLE_STATICCOMPACT;
        dwAuthority = PROPA_READONLY | PROPA_WONT_SERIALZE;
        dwPropFlags = 0;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_LANGID))
    {
        propStyle = TFPROPSTYLE_STATICCOMPACT;
        dwPropFlags = 0;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_TEXTOWNER))
    {
        propStyle = TFPROPSTYLE_STATICCOMPACT;
        dwAuthority = PROPA_TEXTOWNER;
        dwPropFlags = PROPF_ACCEPTCORRECTION | PROPF_VTI4TOGUIDATOM;
    }
    else
    {
        propStyle = _GetPropStyle(rguidProp);
        dwPropFlags = 0;

        // nb: after a property is created, the PROPF_MARKUP_COLLECTION is never
        // again set.  We make sure to call ITfDisplayAttributeCollectionProvider::GetCollection
        // before activating tips that use the property GUID.
        if (CDisplayAttributeMgr::_IsInCollection(rguidProp))
        {
            dwPropFlags = PROPF_MARKUP_COLLECTION;
        }
    }
 
    //
    //  Allow NULL propStyle for only predefined properties.
    //  Check the property style is correct.
    //
    if (!propStyle)
    { 
        Assert(0);
        return E_FAIL;
    }

    pProp = new CProperty(this, rguidProp, propStyle, dwAuthority, dwPropFlags);

    if (pProp)
    {
        pProp->_pNext = _pPropList;
        _pPropList = pProp;

        // Update _pPropTextOner now.
        if (IsEqualGUID(rguidProp, GUID_PROP_TEXTOWNER))
             _pPropTextOwner = pProp;
    }

    if (*ppv = pProp)
    {
        (*ppv)->AddRef();
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetTextOwnerProperty
//
//----------------------------------------------------------------------------

CProperty *CInputContext::GetTextOwnerProperty()
{
    ITfProperty *prop;

    // GetProperty initializes _pPropTextOwner.

    if (!_pPropTextOwner)
    {
        GetProperty(GUID_PROP_TEXTOWNER, &prop);
        SafeRelease(prop);
    }

    Assert(_pPropTextOwner);
    return _pPropTextOwner;
}

//+---------------------------------------------------------------------------
//
// _FindProperty
//
//----------------------------------------------------------------------------

CProperty *CInputContext::_FindProperty(TfGuidAtom gaProp)
{
    CProperty *pProp = _pPropList;

    // perf: should this be faster?
    while (pProp)
    {
         if (pProp->GetPropGuidAtom() == gaProp)
             return pProp;

         pProp = pProp->_pNext;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _PropertyTextUpdate
//
//----------------------------------------------------------------------------

void CInputContext::_PropertyTextUpdate(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *pProp = _pPropList;
    DWORD dwPrevESFlag = _dwEditSessionFlags;

    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    while (pProp)
    {
        // clear the values over the edited text
        pProp->Clear(paStart, paEnd, dwFlags, TRUE /* fTextUpdate */);

        if (pProp->GetPropStyle() == TFPROPSTYLE_STATICCOMPACT ||
            pProp->GetPropStyle() == TFPROPSTYLE_CUSTOM_COMPACT)
        {
            pProp->Defrag(paStart, paEnd);
        }

        pProp = pProp->_pNext;
    }

    _dwEditSessionFlags = dwPrevESFlag;
}

//+---------------------------------------------------------------------------
//
// _GetStartOrEnd
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_GetStartOrEnd(TfEditCookie ec, BOOL fStart, ITfRange **ppStart)
{
    CRange *range;
    IAnchor *paStart;
    IAnchor *paEnd;
    HRESULT hr;

    if (ppStart == NULL)
        return E_INVALIDARG;

    *ppStart = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = fStart ? _ptsi->GetStart(&paStart) : _ptsi->GetEnd(&paStart);

    if (hr == E_NOTIMPL)
        return E_NOTIMPL;
    if (hr != S_OK)
        return E_FAIL;

    hr = E_FAIL;

    if (FAILED(paStart->Clone(&paEnd)))
        goto Exit;

    if ((range = new CRange) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    if (!range->_InitWithDefaultGravity(this, OWN_ANCHORS, paStart, paEnd))
    {
        range->Release();
        goto Exit;
    }

    *ppStart = (ITfRangeAnchor *)range;

    hr = S_OK;

Exit:
    if (hr != S_OK)
    {
        SafeRelease(paStart);
        SafeRelease(paEnd);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CreateRange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::CreateRange(IAnchor *paStart, IAnchor *paEnd, ITfRangeAnchor **ppRange)
{
    CRange *range;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (paStart == NULL || paEnd == NULL)
        return E_INVALIDARG;

    if (CompareAnchors(paStart, paEnd) > 0)
        return E_INVALIDARG;

    if ((range = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!range->_InitWithDefaultGravity(this, COPY_ANCHORS, paStart, paEnd))
    {
        range->Release();
        return E_FAIL;
    }

    *ppRange = range;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreateRange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange)
{
    IServiceProvider *psp;
    CRange *range;
    CACPWrap *pACPWrap;
    IAnchor *paStart;
    IAnchor *paEnd;
    HRESULT hr;

    if (ppRange == NULL)
        return E_INVALIDARG;

    pACPWrap = NULL;
    *ppRange = NULL;
    paEnd = NULL;
    hr = E_FAIL;

    if (acpStart > acpEnd)
        return E_INVALIDARG;

    if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) == S_OK)
    {
        if (psp->QueryService(GUID_SERVICE_TF, IID_PRIV_ACPWRAP, (void **)&pACPWrap) == S_OK)
        {
            // the actual impl is acp based, so this is easy
            if ((paStart = pACPWrap->_CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
                goto Exit;
            if ((paEnd = pACPWrap->_CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
                goto Exit;
        }
        else
        {
            // in case QueryService sets it on failure to garbage...
            pACPWrap = NULL;
        }
        psp->Release();
    }

    if (paEnd == NULL) // failure above?
    {
        Assert(0); // who's calling this?
        // caller should know whether or not it has an acp text store.
        // we don't, so we won't support this case.
        hr = E_FAIL;
        goto Exit;
    }

    if ((range = new CRange) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!range->_InitWithDefaultGravity(this, OWN_ANCHORS, paStart, paEnd))
    {
        range->Release();
        goto Exit;
    }

    *ppRange = range;

    hr = S_OK;

Exit:
    SafeRelease(pACPWrap);
    if (hr != S_OK)
    {
        SafeRelease(paStart);
        SafeRelease(paEnd);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// _Pushed
//
//----------------------------------------------------------------------------

void CInputContext::_Pushed()
{
    CThreadInputMgr *tim;
    if ((tim = CThreadInputMgr::_GetThis()) != NULL)
        tim->_NotifyCallbacks(TIM_INITIC, NULL, this);
}

//+---------------------------------------------------------------------------
//
// _Popped
//
//----------------------------------------------------------------------------

void CInputContext::_Popped()
{
    CThreadInputMgr *tim;
    if ((tim = CThreadInputMgr::_GetThis()) != NULL)
        tim->_NotifyCallbacks(TIM_UNINITIC, NULL, this);

    //
    // We release all properties and property stores.
    //
    CProperty *pProp;

    while (_pPropList != NULL)
    {
        pProp = _pPropList;
        _pPropList = _pPropList->_pNext;
        pProp->Release();
    }
    // we just free up the cached text property, so make sure
    // we don't try to use it later!
    _pPropTextOwner = NULL;

    //
    // We release all compartments.
    //
    CleanUp();
}

//+---------------------------------------------------------------------------
//
// _GetPropStyle
//
//----------------------------------------------------------------------------

const GUID *CInputContext::_c_rgPropStyle[] =
{
    &GUID_TFCAT_PROPSTYLE_CUSTOM,
    // {0x24af3031,0x852d,0x40a2,{0xbc,0x09,0x89,0x92,0x89,0x8c,0xe7,0x22}},
    &GUID_TFCAT_PROPSTYLE_STATIC,
    // {0x565fb8d8,0x6bd4,0x4ca1,{0xb2,0x23,0x0f,0x2c,0xcb,0x8f,0x4f,0x96}},
    &GUID_TFCAT_PROPSTYLE_STATICCOMPACT,
    // {0x85f9794b,0x4d19,0x40d8,{0x88,0x64,0x4e,0x74,0x73,0x71,0xa6,0x6d}}
    &GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT,
};

TFPROPERTYSTYLE CInputContext::_GetPropStyle(REFGUID rguidProp)
{
    GUID guidStyle = GUID_NULL;

    CCategoryMgr::s_FindClosestCategory(rguidProp, 
                                        &guidStyle, 
                                        _c_rgPropStyle, 
                                        ARRAYSIZE(_c_rgPropStyle));

    if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_CUSTOM))
        return TFPROPSTYLE_CUSTOM;
    else if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_STATIC))
        return TFPROPSTYLE_STATIC;
    else if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_STATICCOMPACT))
        return TFPROPSTYLE_STATICCOMPACT;
    else if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT))
        return TFPROPSTYLE_CUSTOM_COMPACT;

    return TFPROPSTYLE_NULL;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream)
{
    ITextStoreACPServices *ptss;
    HRESULT hr;

    if (pHdr == NULL)
        return E_INVALIDARG;

    memset(pHdr, 0, sizeof(*pHdr));

    if (!_IsCiceroTSI())
        return E_UNEXPECTED;

    if (_ptsi->QueryInterface(IID_ITextStoreACPServices, (void **)&ptss) != S_OK)
        return E_FAIL;

    hr = ptss->Serialize(pProp, pRange, pHdr, pStream);

    ptss->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader)
{
    ITextStoreACPServices *ptss;
    HRESULT hr;

    if (!_IsCiceroTSI())
        return E_UNEXPECTED;

    if (_ptsi->QueryInterface(IID_ITextStoreACPServices, (void **)&ptss) != S_OK)
        return E_FAIL;

    hr = ptss->Unserialize(pProp, pHdr, pStream, pLoader);

    ptss->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetDocumentMgr(ITfDocumentMgr **ppDm)
{
    CDocumentInputManager *dm;

    if (ppDm == NULL)
        return E_INVALIDARG;

    *ppDm = NULL;

    if ((dm = _GetDm()) == NULL)
        return S_FALSE; // the ic has been popped

    *ppDm = dm;
    (*ppDm)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumProperties
//
//----------------------------------------------------------------------------

STDAPI CInputContext::EnumProperties(IEnumTfProperties **ppEnum)
{
    CEnumProperties *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    pEnum = new CEnumProperties;

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
        return E_FAIL;

    *ppEnum = pEnum;

    return S_OK;
}
//+---------------------------------------------------------------------------
//
// GetStart
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetStart(TfEditCookie ec, ITfRange **ppStart)
{
    return _GetStartOrEnd(ec, TRUE, ppStart);
}

//+---------------------------------------------------------------------------
//
// GetEnd
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetEnd(TfEditCookie ec, ITfRange **ppEnd)
{
    return _GetStartOrEnd(ec, FALSE, ppEnd);
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetStatus(TS_STATUS *pdcs)
{
    if (pdcs == NULL)
        return E_INVALIDARG;

    memset(pdcs, 0, sizeof(*pdcs));

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    return _GetTSI()->GetStatus(pdcs);
}

//+---------------------------------------------------------------------------
//
// CreateRangeBackup
//
//----------------------------------------------------------------------------

STDAPI CInputContext::CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup)
{
    CRangeBackup *pRangeBackup;
    CRange *range;
    HRESULT hr;

    if (!ppBackup)
        return E_INVALIDARG;

    *ppBackup = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }
   
    if (!pRange)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, range))
        return E_INVALIDARG;

    range->_QuickCheckCrossedAnchors();

    pRangeBackup = new CRangeBackup(this);
    if (!pRangeBackup)
        return E_OUTOFMEMORY;

    if (FAILED(hr = pRangeBackup->Init(ec, range)))
    {
        pRangeBackup->Clear();
        pRangeBackup->Release();
        return E_FAIL;
    }

    *ppBackup = pRangeBackup;
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CInputContext::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    IServiceProvider *psp;
    HRESULT hr;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (IsEqualGUID(guidService, GUID_SERVICE_TEXTSTORE) &&
        IsEqualIID(riid, IID_IServiceProvider))
    {
        // caller wants to talk to the text store
        if (_ptsi == NULL)
            return E_FAIL;

        // we use an extra level of indirection, asking the IServiceProvider for an IServiceProvider
        // because we want to leave the app free to not expose the ITextStore object
        // otherwise tips could QI the IServiceProvider for ITextStore

        if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK || psp == NULL)
            return E_FAIL;

        hr = psp->QueryService(GUID_SERVICE_TEXTSTORE, IID_IServiceProvider, ppv);

        psp->Release();

        return hr;
    }

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF) ||
        !IsEqualIID(riid, IID_PRIV_CINPUTCONTEXT))
    {
        // SVC_E_NOSERVICE is proper return code for wrong service....
        // but it's not defined anywhere.  So use E_NOINTERFACE for both
        // cases as trident is rumored to do
        return E_NOINTERFACE;
    }

    *ppv = this;
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::AdviseMouseSink(ITfRange *range, ITfMouseSink *pSink, DWORD *pdwCookie)
{
    CRange *pCRange;
    CRange *pClone;
    ITfMouseTrackerAnchor *pTrackerAnchor;
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = 0;

    if (range == NULL || pSink == NULL)
        return E_INVALIDARG;

    if ((pCRange = GetCRange_NA(range)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pCRange))
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    pTrackerACP = NULL;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerAnchor, (void **)&pTrackerAnchor) != S_OK)
    {
        pTrackerAnchor = NULL;
        // we also try IID_ITfMouseTrackerACP for the benefit of wrapped implementations who
        // just want to forward the request off to an ACP app
        if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) != S_OK)
            return E_NOTIMPL;
    }

    hr = E_FAIL;

    // need to pass on a clone, so app can hang onto range/anchors
    if ((pClone = pCRange->_Clone()) == NULL)
        goto Exit;

    hr = (pTrackerAnchor != NULL) ?
         pTrackerAnchor->AdviseMouseSink(pClone->_GetStart(), pClone->_GetEnd(), pSink, pdwCookie) :
         pTrackerACP->AdviseMouseSink((ITfRangeACP *)pClone, pSink, pdwCookie);

    pClone->Release();

Exit:
    SafeRelease(pTrackerAnchor);
    SafeRelease(pTrackerACP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::UnadviseMouseSink(DWORD dwCookie)
{
    ITfMouseTrackerAnchor *pTrackerAnchor;
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerAnchor, (void **)&pTrackerAnchor) == S_OK)
    {
        hr = pTrackerAnchor->UnadviseMouseSink(dwCookie);
        pTrackerAnchor->Release();
    }
    else if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) == S_OK)
    {
        // we also try IID_ITfMouseTrackerACP for the benefit of wrapped implementations who
        // just want to forward the request off to an ACP app
        hr = pTrackerACP->UnadviseMouseSink(dwCookie);
        pTrackerACP->Release();
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetActiveView
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetActiveView(ITfContextView **ppView)
{
    CContextView *pView;
    TsViewCookie vcActiveView;
    HRESULT hr;

    if (ppView == NULL)
        return E_INVALIDARG;

    *ppView = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    hr = _ptsi->GetActiveView(&vcActiveView);

    if (hr != S_OK)
    {
        Assert(0); // why did it fail?

        if (hr != E_NOTIMPL)
            return E_FAIL;

        // for E_NOTIMPL, we will assume a single view and supply
        // a constant value here
        vcActiveView = 0;
    }

    // Issue: for now, just supporting an active view
    // need to to handle COM identity correctly for mult views
    if (_pActiveView == NULL)
    {
        if ((_pActiveView = new CContextView(this, vcActiveView)) == NULL)
            return E_OUTOFMEMORY;
    }

    pView = _pActiveView;
    pView->AddRef();

    *ppView = pView;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumView
//
//----------------------------------------------------------------------------

STDAPI CInputContext::EnumViews(IEnumTfContextViews **ppEnum)
{
    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    // Issue: support this
    Assert(0);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// QueryInsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CInputContext::QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable)
{
    if (pfInsertable == NULL)
        return E_INVALIDARG;

    *pfInsertable = FALSE;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    return _ptsi->QueryInsertEmbedded(pguidService, pFormatEtc, pfInsertable);
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::InsertTextAtSelection(TfEditCookie ec, DWORD dwFlags,
                                            const WCHAR *pchText, LONG cch,
                                            ITfRange **ppRange)
{
    IAS_OBJ iasobj;

    iasobj.type = IAS_OBJ::IAS_TEXT;
    iasobj.state.text.pchText = pchText;
    iasobj.state.text.cch = cch;

    return _InsertXAtSelection(ec, dwFlags, &iasobj, ppRange);
}

//+---------------------------------------------------------------------------
//
// InsertEmbeddedAtSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::InsertEmbeddedAtSelection(TfEditCookie ec, DWORD dwFlags,
                                                IDataObject *pDataObject,
                                                ITfRange **ppRange)
{
    IAS_OBJ iasobj;

    iasobj.type = IAS_OBJ::IAS_DATAOBJ;
    iasobj.state.obj.pDataObject = pDataObject;

    return _InsertXAtSelection(ec, dwFlags, &iasobj, ppRange);
}

//+---------------------------------------------------------------------------
//
// _InsertXAtSelection
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_InsertXAtSelection(TfEditCookie ec, DWORD dwFlags,
                                           IAS_OBJ *pObj,
                                           ITfRange **ppRange)
{
    IAnchor *paStart;
    IAnchor *paEnd;
    CRange *range;
    CComposition *pComposition;
    HRESULT hr;
    BOOL fNoDefaultComposition;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (pObj->type == IAS_OBJ::IAS_TEXT)
    {
        if (pObj->state.text.pchText == NULL && pObj->state.text.cch != 0)
            return E_INVALIDARG;

        if (!(dwFlags & TS_IAS_QUERYONLY) && (pObj->state.text.pchText == NULL || pObj->state.text.cch == 0))
            return E_INVALIDARG;
    }
    else
    {
        Assert(pObj->type == IAS_OBJ::IAS_DATAOBJ);
        if (!(dwFlags & TS_IAS_QUERYONLY) && pObj->state.obj.pDataObject == NULL)
            return E_INVALIDARG;
    }

    if ((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) == (TS_IAS_NOQUERY | TS_IAS_QUERYONLY))
        return E_INVALIDARG;

    if ((dwFlags & ~(TS_IAS_NOQUERY | TS_IAS_QUERYONLY | TF_IAS_NO_DEFAULT_COMPOSITION)) != 0)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, (dwFlags & TF_IAS_QUERYONLY) ? TF_ES_READ : TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    // we need to clear out the TF_IAS_NO_DEFAULT_COMPOSITION bit because it is not legal
    // for ITextStore methods
    fNoDefaultComposition = (dwFlags & TF_IAS_NO_DEFAULT_COMPOSITION);
    dwFlags &= ~TF_IAS_NO_DEFAULT_COMPOSITION;

    if (pObj->type == IAS_OBJ::IAS_TEXT)
    {
        if (pObj->state.text.cch < 0)
        {
            pObj->state.text.cch = wcslen(pObj->state.text.pchText);
        }

        hr = _ptsi->InsertTextAtSelection(dwFlags, pObj->state.text.pchText, pObj->state.text.cch, &paStart, &paEnd);
    }
    else
    {
        Assert(pObj->type == IAS_OBJ::IAS_DATAOBJ);

        hr = _ptsi->InsertEmbeddedAtSelection(dwFlags, pObj->state.obj.pDataObject, &paStart, &paEnd);
    }

    if (hr == S_OK)
    {
        if (!(dwFlags & TS_IAS_QUERYONLY))
        {
            CComposition::_IsRangeCovered(this, _GetClientInEditSession(ec), paStart, paEnd, &pComposition);

            _DoPostTextEditNotifications(pComposition, ec, 0, 1, paStart, paEnd, NULL);

            // try to start a composition
            // any active compositions?
            if (!fNoDefaultComposition && pComposition == NULL)
            {
                // not covered, need to (try to) create a composition
                hr = _StartComposition(ec, paStart, paEnd, NULL, &pComposition);

                if (hr == S_OK && pComposition != NULL)
                {
                    // we just wanted to set the composing property, so end this one immediately
                    pComposition->EndComposition(ec);
                    pComposition->Release();
                }
            }
        }
    }
    else
    {
        // the InsertAtSelection call failed in the app
        switch (hr)
        {
            case TS_E_NOSELECTION:
            case TS_E_READONLY:
                return hr;

            case E_NOTIMPL:
                // the app hasn't implemented InsertAtSelection, so we'll fake it using GetSelection/SetText
                if (!_InsertXAtSelectionAggressive(ec, dwFlags, pObj, &paStart, &paEnd))
                    return E_FAIL;
                break;

            default:
                return E_FAIL;
        }
    }

    if (!(dwFlags & TF_IAS_NOQUERY))
    {
        if (paStart == NULL || paEnd == NULL)
        {
            Assert(0); // text store returning bogus values
            return E_FAIL;
        }

        if ((range = new CRange) == NULL)
            return E_OUTOFMEMORY;

        if (!range->_InitWithDefaultGravity(this, OWN_ANCHORS, paStart, paEnd))
        {
            range->Release();
            return E_FAIL;
        }

        *ppRange = (ITfRangeAnchor *)range;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InsertXAtSelectionAggressive
//
//----------------------------------------------------------------------------

BOOL CInputContext::_InsertXAtSelectionAggressive(TfEditCookie ec, DWORD dwFlags, IAS_OBJ *pObj, IAnchor **ppaStart, IAnchor **ppaEnd)
{
    CRange *range;
    TF_SELECTION sel;
    ULONG pcFetched;
    HRESULT hr;

    // this is more expensive then using ITextStore methods directly, but by using a CRange we
    // get all the composition/notification code for free

    if (GetSelection(ec, TF_DEFAULT_SELECTION, 1, &sel, &pcFetched) != S_OK)
        return FALSE;

    hr = E_FAIL;

    if (pcFetched != 1)
        goto Exit;

    if (dwFlags & TS_IAS_QUERYONLY)
    {
        hr = S_OK;
        goto OutParams;
    }

    if (pObj->type == IAS_OBJ::IAS_TEXT)
    {
        hr = sel.range->SetText(ec, 0, pObj->state.text.pchText, pObj->state.text.cch);
    }
    else
    {
        Assert(pObj->type == IAS_OBJ::IAS_DATAOBJ);

        hr = sel.range->InsertEmbedded(ec, 0, pObj->state.obj.pDataObject);
    }

    if (hr == S_OK)
    {
OutParams:
        range = GetCRange_NA(sel.range);

        *ppaStart = range->_GetStart();
        (*ppaStart)->AddRef();
        *ppaEnd = range->_GetEnd();
        (*ppaEnd)->AddRef();
    }

Exit:
    sel.range->Release();

    return (hr == S_OK);
}


//+---------------------------------------------------------------------------
//
// _DoPostTextEditNotifications
//
//----------------------------------------------------------------------------

void CInputContext::_DoPostTextEditNotifications(CComposition *pComposition, 
                                                 TfEditCookie ec, DWORD dwFlags,
                                                 ULONG cchInserted,
                                                 IAnchor *paStart, IAnchor *paEnd,
                                                 CRange *range)
{
    CProperty *property;
    VARIANT var;

    if (range != NULL)
    {
        Assert(paStart == NULL);
        Assert(paEnd == NULL);
        paStart = range->_GetStart();
        paEnd = range->_GetEnd();
    }

    if (cchInserted > 0)
    {
        // an insert could have crossed some anchors
        _IncLastLockReleaseID(); // force a re-check for everyone!
        if (range != NULL)
        {
            range->_QuickCheckCrossedAnchors(); // and check this guy right away
        }
    }

    // the app won't notify us about changes we initiate, so do that now
    _OnTextChangeInternal(dwFlags, paStart, paEnd, COPY_ANCHORS);

    // let properties know about the update
    _PropertyTextUpdate(dwFlags, paStart, paEnd);

    // Set text owner property
    if (cchInserted > 0
        && !IsEqualAnchor(paStart, paEnd))
    {
        // text owner property
        TfClientId tid = _GetClientInEditSession(ec);
        if ((tid != g_gaApp) && (tid != g_gaSystem) && 
            (property = GetTextOwnerProperty()))
        {
            var.vt = VT_I4;
            var.lVal = tid;

            Assert(var.lVal != TF_CLIENTID_NULL);

            property->_SetDataInternal(ec, paStart, paEnd, &var);
        }

        // composition property
        if (range != NULL &&
            _GetProperty(GUID_PROP_COMPOSING, &property) == S_OK) // perf: consider caching property ptr
        {
            var.vt = VT_I4;
            var.lVal = TRUE;

            property->_SetDataInternal(ec, paStart, paEnd, &var);

            property->Release();
        }
    }

    // composition update
    if (pComposition != NULL && _GetOwnerCompositionSink() != NULL)
    {
        _GetOwnerCompositionSink()->OnUpdateComposition(pComposition, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"

HINSTANCE g_hInst = NULL;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

DWORD g_dwTLSIndex = TLS_OUT_OF_INDEXES;

DECLARE_OSVER()

CCiceroSharedMem g_SharedMemory;

HKL g_hklDefault;

// registered messages
UINT g_msgPrivate;

//
// private message for SetFocusNotifySink
//
UINT g_msgSetFocus;
UINT g_msgThreadTerminate;
UINT g_msgThreadItemChange;

//
// private message for Modal LangBar
//
UINT g_msgLBarModal;

UINT g_msgRpcSendReceive;
UINT g_msgThreadMarshal;
UINT g_msgCheckThreadInputIdel;
#ifdef POINTER_MARSHAL
UINT g_msgPointerMarshal;
#endif
UINT g_msgStubCleanUp;
UINT g_msgShowFloating;
UINT g_msgLBUpdate;
UINT g_msgNuiMgrDirtyUpdate;

//
// g_csInDllMain.
//  
//    We should try not to use Thread Synchronizaion. However we got some
//    race condition in stress testing so we need it.
//    g_csInDllMain just protect the section that could be touched from
//    DllMain so that we need to be very careful for the critical section.
//    We can not call some Kernel API (LoadLibrary, CreateProcess and so on) 
//    there.
//
CCicCriticalSectionStatic g_csInDllMain;

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

#ifdef DEBUG
// for tracking last owner of g_cs
const TCHAR *g_szMutexEnterFile = NULL;
int g_iMutexEnterLine = -1;
#endif // DEBUG

TfGuidAtom g_gaApp;
TfGuidAtom g_gaSystem;

BOOL g_fCTFMONProcess = FALSE;
BOOL g_fCUAS = FALSE;
TCHAR g_szCUASImeFile[16];

//
// application compatibility flag
//
DWORD g_dwAppCompatibility = 0;


/* 626761ad-78d2-44d2-be8b-752cf122acec */
const GUID GUID_APPLICATION = { 0x626761ad, 0x78d2, 0x44d2, {0xbe, 0x8b, 0x75, 0x2c, 0xf1, 0x22, 0xac, 0xec} };
/* 78cb5b0e-26ed-4fcc-854c-77e8f3d1aa80 */
const GUID GUID_SYSTEM = { 0x78cb5b0e, 0x26ed, 0x4fcc, {0x85, 0x4c, 0x77, 0xe8, 0xf3, 0xd1, 0xaa, 0x80} };

const TCHAR c_szCTFKey[] =           TEXT("SOFTWARE\\Microsoft\\CTF\\");
const TCHAR c_szTIPKey[] =           TEXT("TIP");
const TCHAR c_szCTFTIPKey[] =        TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
const TCHAR c_szLangBarKey[] =       TEXT("SOFTWARE\\Microsoft\\CTF\\LangBar\\");
const WCHAR c_szDescriptionW[] =     L"Description";
const WCHAR c_szMUIDescriptionW[] =  L"Display Description";
const WCHAR c_szEnableW[] =          L"Enable";
const TCHAR c_szEnable[] =           TEXT("Enable");
const TCHAR c_szDisabledOnTransitory[] = TEXT("DisabledOnTransitory");
const TCHAR c_szAsmKey[] =           TEXT("SOFTWARE\\Microsoft\\CTF\\Assemblies");
const TCHAR c_szCompartKey[] =       TEXT("SOFTWARE\\Microsoft\\CTF\\Compartment");
const TCHAR c_szGlobalCompartment[] = TEXT("GlobalCompartment");
const TCHAR c_szNonInit[] =          TEXT("NonInit");
const TCHAR c_szDefault[] =          TEXT("Default");
const TCHAR c_szProfile[] =          TEXT("Profile");
const WCHAR c_szProfileW[] =         L"Profile";
const TCHAR c_szDefaultAsmName[] =   TEXT("Default Assembly");
const TCHAR c_szUpdateProfile[] =    TEXT("UpdateProfile");
const TCHAR c_szAssembly[] =         TEXT("Assemblies");
const TCHAR c_szLanguageProfileKey[] = TEXT("LanguageProfile\\");
const TCHAR c_szSubstitutehKL[] =      TEXT("SubstituteLayout");
const TCHAR c_szKeyboardLayout[] =   TEXT("KeyboardLayout");
const WCHAR c_szIconFileW[] =        L"IconFile";
const TCHAR c_szIconIndex[] =        TEXT("IconIndex");
const WCHAR c_szIconIndexW[] =       L"IconIndex";
const TCHAR c_szShowStatus[] =       TEXT("ShowStatus");
const TCHAR c_szLabel[] =            TEXT("Label");
const TCHAR c_szTransparency[] =     TEXT("Transparency");
const TCHAR c_szExtraIconsOnMinimized[] =     TEXT("ExtraIconsOnMinimized");
const TCHAR c_szLocaleInfo[] =       TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Locale");
const TCHAR c_szLocaleInfoNT4[] =    TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Language");
const TCHAR c_szKeyboardLayoutKey[] =   TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\");
const TCHAR c_szKbdUSNameNT[] =      TEXT("kbdus.dll");
const TCHAR c_szKbdUSName[] =        TEXT("kbdus.kbd");
const TCHAR c_szLayoutFile[] =       TEXT("layout file");
const TCHAR c_szIMEFile[] =          TEXT("IME file");
const TCHAR c_szRunInputCPLCmdLine[] =  TEXT("RunDll32.exe shell32.dll,Control_RunDLL %s");
const TCHAR c_szRunInputCPL[]        =  TEXT("input.cpl");
const TCHAR c_szRunInputCPLOnWin9x[] =  TEXT("input98.cpl");
const TCHAR c_szRunInputCPLOnNT51[]  =  TEXT("input.dll");
const TCHAR c_szHHEXELANGBARCHM[]    = TEXT("hh.exe langbar.chm");
const TCHAR c_szHHEXE[]              = TEXT("hh.exe");

// marshal window class
const TCHAR c_szCicMarshalClass[] = "CicMarshalWndClass";
const TCHAR c_szCicMarshalWnd[] = "CicMarshalWnd";
const TCHAR c_szAppCompat[] =       TEXT("SOFTWARE\\Microsoft\\CTF\\Compatibility\\");
const TCHAR c_szCompatibility[] = TEXT("Compatibility");
const TCHAR c_szCtfShared[] =  TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared\\");
const TCHAR c_szCUAS[] =  TEXT("CUAS");
const TCHAR c_szIMMKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\IMM");
const TCHAR c_szCUASIMEFile[] =  TEXT("IME File");

//+---------------------------------------------------------------------------
//
// CheckAnchorStores
//
//----------------------------------------------------------------------------

// if set TRUE, we don't ask for ITextStoreAnchor during context creation
BOOL g_fNoITextStoreAnchor = TRUE;

void CheckAnchorStores()
{
    HKEY hKeyCTF;
    DWORD cb;
    DWORD dwEnable;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCTFKey, NULL, KEY_READ, &hKeyCTF) != ERROR_SUCCESS)
        return;

    cb = sizeof(DWORD);

    if (RegQueryValueEx(hKeyCTF, TEXT("EnableAnchorContext"), NULL, NULL, (BYTE *)&dwEnable, &cb) == ERROR_SUCCESS &&
        cb == sizeof(DWORD) &&
        dwEnable == 1)
    {
        g_fNoITextStoreAnchor = FALSE;
    }

    RegCloseKey(hKeyCTF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\hotkey.h ===
//
// hotkey.h
//
// CHotKey
//


#ifndef HOTKEY_H
#define HOTKEY_H

#include "private.h"

#define TF_MOD_ALLALT     (TF_MOD_RALT | TF_MOD_LALT | TF_MOD_ALT)
#define TF_MOD_ALLCONTROL (TF_MOD_RCONTROL | TF_MOD_LCONTROL | TF_MOD_CONTROL)
#define TF_MOD_ALLSHIFT   (TF_MOD_RSHIFT | TF_MOD_LSHIFT | TF_MOD_SHIFT)
#define TF_MOD_RLALT     (TF_MOD_RALT | TF_MOD_LALT)
#define TF_MOD_RLCONTROL (TF_MOD_RCONTROL | TF_MOD_LCONTROL)
#define TF_MOD_RLSHIFT   (TF_MOD_RSHIFT | TF_MOD_LSHIFT)

//
// internal WIN modifiers
//
#define TF_MOD_WIN                          0x00010000
#define TF_MOD_RWIN                         0x00020000
#define TF_MOD_LWIN                         0x00040000
#define TF_MOD_RLWIN   (TF_MOD_RWIN | TF_MOD_LWIN)

#define CHAR_GRAVE           TEXT('`')

#define VK_GRAVE            0xC0

//////////////////////////////////////////////////////////////////////////////
//
// CHotKey
//
//////////////////////////////////////////////////////////////////////////////

class CHotKey
{
public:
     CHotKey()
     {
     }

     BOOL Init (TfClientId tid, const TF_PRESERVEDKEY *pprekey, REFGUID rguid, DWORD dwFlags)
     {
         _tid = tid;
         _prekey = *pprekey;
         _dwFlags = dwFlags;

         if (_prekey.uVKey == VK_F10)
              _fAlt = TRUE;
         else if (_prekey.uVKey == VK_MENU)
              _fAlt = TRUE;
         else if (_prekey.uModifiers & (TF_MOD_RALT | TF_MOD_LALT | TF_MOD_ALT))
              _fAlt = TRUE;
         else
              _fAlt = FALSE;

         if (_prekey.uModifiers & (TF_MOD_RWIN | TF_MOD_LWIN | TF_MOD_WIN))
              _fWin = TRUE;
         else
              _fWin = FALSE;

         if (FAILED(MyRegisterGUID(rguid, &_guidatom)))
             return FALSE;

         return TRUE;
     }

     ~CHotKey()
     {
         if (_pszDesc)
             delete _pszDesc;
     }

     BOOL SetDesc(const WCHAR *pchDesc, ULONG cchDesc)
     {
         if (_pszDesc)
         {
             delete _pszDesc;
             _pszDesc = NULL;
         }

         if (!cchDesc)
             return TRUE;

         _pszDesc = new WCHAR[cchDesc + 1];
         if (!_pszDesc)
             return FALSE;

         memcpy(_pszDesc, pchDesc, sizeof(WCHAR) * cchDesc);
         return TRUE;
     }

     BOOL GetDesc(BSTR *pbstr)
     {
         *pbstr = SysAllocString(_pszDesc);
         return (*pbstr) ? TRUE : FALSE;
     }

     BOOL IsNoDimNeeded()
     {
         return (_dwFlags & TF_PKEX_NONEEDDIM) ? TRUE : FALSE;
     }

     BOOL IsSysHotkey()
     {
         if (_fAlt)
             return TRUE;

         if (_fWin)
             return TRUE;

         if (_dwFlags & TF_PKEX_SYSHOTKEY)
             return TRUE;

         return FALSE;
     }

     TF_PRESERVEDKEY _prekey;
     TfGuidAtom _guidatom;
     BOOL _fAlt;
     BOOL _fWin;
     DWORD _dwFlags;
     WCHAR *_pszDesc;

     BOOL IsValidTID(TfClientId tid)
     {
         if (_tid == tid)
             return TRUE;

         if (_tid == g_gaSystem)
             return TRUE;

         return FALSE;
     }

     TfClientId GetTID() {return _tid;}
private:
     TfClientId _tid;
};



typedef struct tag_IMM32HOTKEY {
    DWORD  dwId;
    UINT   uVKey;
    UINT   uModifiers;
    BOOL   fInit;
} IMM32HOTKEY;

BOOL ModifiersCheck(UINT uModSrc, UINT uMod);
BOOL InitLangChangeHotKey();
BOOL UpdateModifiers(WPARAM wParam, LPARAM lParam);
BOOL IsInLangChangeHotkeyStatus();
BOOL CheckLangChangeHotKey(SYSTHREAD *psfn, WPARAM wParam, LPARAM lParam);
BOOL CheckImm32HotKey(WPARAM wParam, LPARAM lParam);
BOOL HandleDBEKeys(WPARAM wParam, LPARAM lParam);
IMM32HOTKEY *IsInImmHotkeyStatus(SYSTHREAD *psfn, LANGID langid);
BOOL CancelImmHotkey(SYSTHREAD *psfn, HWND hwnd, IMM32HOTKEY *pHotKey);
BOOL ToggleCHImeNoIme(SYSTHREAD *psfn, LANGID langidCur, LANGID langid);
BOOL ToggleJImeNoIme(SYSTHREAD *psfn);

#endif // HOTKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\ic.h ===
//
// ic.h
//

#ifndef IC_H
#define IC_H

#include "private.h"
#include "globals.h"
#include "rprop.h"
#include "editrec.h"
#include "strary.h"
#include "compart.h"

#define TF_ES_INEDITSESSION          0x80000000
#define TF_ES_INNOTIFY               0x40000000
#define TF_ES_WRITE                  (TF_ES_READWRITE & ~TF_ES_READ)
#define TF_ES_PROPERTY_WRITE         (TF_ES_READ_PROPERTY_WRITE & ~TF_ES_READ)
#define TF_ES_ALL_ACCESS_BITS        (TF_ES_READWRITE | TF_ES_READ_PROPERTY_WRITE)

#define IC_NUM_CONNECTIONPTS        5
// these are indices into _rgSinks, must match CInputContext::_c_rgConnectionIIDs
#define IC_SINK_ITfTextEditSink                     0
#define IC_SINK_ITfTextLayoutSink                   1
#define IC_SINK_ITfStatusSink                       2
#define IC_SINK_ITfStartReconversionNotifySink      3
#define IC_SINK_ITfEditTransactionSink              4

class CRange;
class CProperty;
class CThreadInputMgr;
class CFunctionProvider;
class CFunction;
class CContextView;
class CComposition;
class CDocumentInputManager;
class CInputContext;

extern const IID IID_PRIV_CINPUTCONTEXT;

#define LEFT_FILTERTIP    0
#define RIGHT_FILTERTIP   1

typedef struct _CLEANUPSINK
{
    TfClientId tid;
    ITfCleanupContextSink *pSink;
} CLEANUPSINK;

//////////////////////////////////////////////////////////////////////////////
//
// QUEUE_ITEM structures
//
//////////////////////////////////////////////////////////////////////////////

typedef enum { QI_ADDREF, QI_DISPATCH, QI_FREE } QiCallbackCode;

struct _TS_QUEUE_ITEM;

typedef HRESULT (*QI_CALLBACK)(CInputContext *pic, struct _TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);

typedef struct _EDITSESSION
{
    TfClientId tid;
    ITfEditSession *pes;
} EDITSESSION;

typedef struct _PSEUDO_EDITSESSION
{
    ULONG uCode;
    void *pvState;
} PSEUDO_EDITSESSION;

class CAsyncQueueItem;
typedef struct _ASYNCQUEUE_EDITSESSION
{
    CAsyncQueueItem *paqi;
} ASYNCQUEUE_EDITSESSION;

typedef struct _TS_QUEUE_ITEM
{
    QI_CALLBACK pfnCallback;
    DWORD dwFlags; // TF_ES_READWRITE | TF_ES_READ | TF_ES_WRITE | TF_ES_SYNC
    
    union
    {
        // state for edit sessions
        EDITSESSION es;

        PSEUDO_EDITSESSION pes;

        ASYNCQUEUE_EDITSESSION aqe;

        // other state...
    } state;
} TS_QUEUE_ITEM;

//
// PSEUDO_EDITSESSION callback codes
//
#define PSEUDO_ESCB_TERMCOMPOSITION       0
#define PSEUDO_ESCB_UPDATEKEYEVENTFILTER  1
#define PSEUDO_ESCB_GROWRANGE             2
#define PSEUDO_ESCB_BUILDOWNERRANGELIST   3
#define PSEUDO_ESCB_SHIFTENDTORANGE       4
#define PSEUDO_ESCB_GETSELECTION          5
#define PSEUDO_ESCB_SERIALIZE_ACP         6
#define PSEUDO_ESCB_SERIALIZE_ANCHOR      7
#define PSEUDO_ESCB_UNSERIALIZE_ACP       8
#define PSEUDO_ESCB_UNSERIALIZE_ANCHOR    9
#define PSEUDO_ESCB_GETWHOLEDOCRANGE      10

typedef struct _SERIALIZE_ANCHOR_PARAMS
{
    CProperty *pProp;
    CRange *pRange;
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr;
    IStream *pStream;
} SERIALIZE_ANCHOR_PARAMS;

typedef struct _UNSERIALIZE_ANCHOR_PARAMS
{
    CProperty *pProp;
    const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr;
    IStream *pStream;
    ITfPersistentPropertyLoaderAnchor *pLoader;
} UNSERIALIZE_ANCHOR_PARAMS;

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncQueueItem
{
public:
    CAsyncQueueItem(BOOL fSync = FALSE)
    {
        _item.pfnCallback = _EditSessionQiCallback;
        _item.dwFlags = TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0);
        _item.state.aqe.paqi = this;

        _cRef = 1;
    }

    virtual ~CAsyncQueueItem() {};

    static HRESULT _EditSessionQiCallback(CInputContext *pic, struct _TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);

    virtual HRESULT DoDispatch(CInputContext *pic) = 0;

    void _CheckReadOnly(CInputContext *pic);

    TS_QUEUE_ITEM *GetItem()
    {
        return &_item;
    }

    LONG _AddRef() 
    {
        _cRef++;
        return _cRef;
    }

    LONG _Release() 
    {
        LONG ret = --_cRef;
        if (!_cRef)
            delete this;

        return ret;
    }

private:
    LONG _cRef;
    TS_QUEUE_ITEM _item;
};

//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////

class CInputContext : public ITfContext_P,
                      public ITfQueryEmbedded,
                      public ITfInsertAtSelection,
                      public ITfContextOwnerServices,
                      public ITfContextOwnerCompositionServices,
                      public ITfSource,
                      public ITfSourceSingle,
                      public ITextStoreAnchorSink,
                      public ITextStoreAnchorServices,
                      public ITfMouseTracker,
                      public IServiceProvider,
                      public ITfContextRenderingMarkup,
                      public CCompartmentMgr,
                      public CComObjectRootImmx
{
public:
    CInputContext(TfClientId tid);
    ~CInputContext();

    BEGIN_COM_MAP_IMMX(CInputContext)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CINPUTCONTEXT, CInputContext)
        COM_INTERFACE_ENTRY(ITfContext)
        COM_INTERFACE_ENTRY(ITfContext_P)
        COM_INTERFACE_ENTRY(ITfQueryEmbedded)
        COM_INTERFACE_ENTRY(ITfInsertAtSelection)
        COM_INTERFACE_ENTRY(ITfContextComposition)
        COM_INTERFACE_ENTRY(ITfContextOwnerCompositionServices)
        COM_INTERFACE_ENTRY(ITfSource)
        COM_INTERFACE_ENTRY(ITfSourceSingle)
        COM_INTERFACE_ENTRY(ITextStoreAnchorSink)
        COM_INTERFACE_ENTRY(ITextStoreAnchorServices)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
        COM_INTERFACE_ENTRY(ITfContextOwnerServices) // Issue: it would be nice if this was only avail w/ cicero def text store
                                                          // COM_INTERFACE_ENTRY_FUNC
        COM_INTERFACE_ENTRY(ITfMouseTracker)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(ITfContextRenderingMarkup)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfContext
    //
    STDMETHODIMP RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession);
    STDMETHODIMP InWriteSession(TfClientId tid, BOOL *pfWriteSession);
    STDMETHODIMP GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection);
    STDMETHODIMP GetStart(TfEditCookie ec, ITfRange **ppStart);
    STDMETHODIMP GetEnd(TfEditCookie ec, ITfRange **ppEnd);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP GetActiveView(ITfContextView **ppView);
    STDMETHODIMP EnumViews(IEnumTfContextViews **ppEnum);
    STDMETHODIMP GetProperty(REFGUID guidProp, ITfProperty **ppv);

    STDMETHODIMP GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp);
    STDMETHODIMP TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX);

    STDMETHODIMP EnumProperties(IEnumTfProperties **ppEnum);
    STDMETHODIMP GetDocumentMgr(ITfDocumentMgr **ppDoc);
    STDMETHODIMP CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup);

    // ITfQueryEmbedded
    STDMETHODIMP QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable);

    // ITfInsertAtSelection
    STDMETHODIMP InsertTextAtSelection(TfEditCookie ec, DWORD dwFlags, const WCHAR *pchText, LONG cch, ITfRange **ppRange);
    STDMETHODIMP InsertEmbeddedAtSelection(TfEditCookie ec, DWORD dwFlags, IDataObject *pDataObject, ITfRange **ppRange);

    // ITfContextOwnerServices
    STDMETHODIMP OnLayoutChange();
    //STDMETHODIMP OnStatusChange(); // use ITextStoreAnchorSink::OnStatusChange
    STDMETHODIMP OnAttributeChange(REFGUID rguidAttribute);
    STDMETHODIMP Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream);
    STDMETHODIMP Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader);
    STDMETHODIMP ForceLoadProperty(ITfProperty *pProp);
    STDMETHODIMP CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange);

    // ITfContextComposition
    STDMETHODIMP StartComposition(TfEditCookie ecWrite, ITfRange *pCompositionRange, ITfCompositionSink *pSink, ITfComposition **ppComposition);
    STDMETHODIMP EnumCompositions(IEnumITfCompositionView **ppEnum);
    STDMETHODIMP FindComposition(TfEditCookie ecRead, ITfRange *pTestRange, IEnumITfCompositionView **ppEnum);
    STDMETHODIMP TakeOwnership(TfEditCookie ecWrite, ITfCompositionView *pComposition, ITfCompositionSink *pSink, ITfComposition **ppComposition);

    // ITfContextOwnerCompositionServices
    STDMETHODIMP TerminateComposition(ITfCompositionView *pComposition);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    // ITfSourceSingle
    STDMETHODIMP AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk);
    STDMETHODIMP UnadviseSingleSink(TfClientId tid, REFIID riid);

    // ITextStoreAnchorSink
    STDMETHODIMP OnTextChange(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd);
    STDMETHODIMP OnSelectionChange();
    STDMETHODIMP OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView);
    STDMETHODIMP OnStatusChange(DWORD dwFlags);
    STDMETHODIMP OnAttrsChange(IAnchor *paStart, IAnchor *paEnd, ULONG cAttrs, const TS_ATTRID *paAttrs);
    STDMETHODIMP OnLockGranted(DWORD dwLockFlags);
    STDMETHODIMP OnStartEditTransaction();
    STDMETHODIMP OnEndEditTransaction();

    // ITextStoreAnchorServices
    STDMETHODIMP Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream);
    STDMETHODIMP Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader);
    STDMETHODIMP CreateRange(IAnchor *paStart, IAnchor *paEnd, ITfRangeAnchor **ppRange);

    // ITfMouseTracker
    STDMETHODIMP AdviseMouseSink(ITfRange *range, ITfMouseSink *pSink, DWORD *pdwCookie);
    STDMETHODIMP UnadviseMouseSink(DWORD dwCookie);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // ITfContextRenderingMarkup
    STDMETHODIMP GetRenderingMarkup(TfEditCookie ec, DWORD dwFlags, ITfRange *pRangeCover, IEnumTfRenderingMarkup **ppEnum);
    STDMETHODIMP FindNextRenderingMarkup(TfEditCookie ec, DWORD dwFlags, ITfRange *pRangeQuery, TfAnchor tfAnchorQuery,
                                         ITfRange **ppRangeFound, TF_RENDERINGMARKUP *ptfRenderingMarkup);

    // ITfContext_P
    STDMETHODIMP MapAppProperty(REFGUID guidAppProp, REFGUID guidProp);
    STDMETHODIMP EnableLockRequestPosting(BOOL fEnable);


    HRESULT _Init(CThreadInputMgr *tim, CDocumentInputManager *dm, ITextStoreAnchor *ptsi, ITfContextOwnerCompositionSink *pOwnerComposeSink);

    void _Pushed();
    void _Popped();

    void _AdviseSinks();
    void _UnadviseSinks(CThreadInputMgr *tim);

    void _UpdateKeyEventFilter();
    HRESULT _UpdateKeyEventFilterCallback(TfEditCookie ec);

    HRESULT _GetProperty(REFGUID rguidProp, CProperty **ppv);

    BOOL _NotifyEndEdit(void);

    CProperty *_FindProperty(REFGUID rguidProp)
    {
        TfGuidAtom ga;

        if (MyRegisterGUID(rguidProp, &ga) != S_OK)
            return NULL;

        return _FindProperty(ga);
    }
    CProperty *_FindProperty(TfGuidAtom gaProp);

    void _PropertyTextUpdate(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd);
    CProperty *_GetFirstProperty() { return _pPropList; }

    CProperty *_pPropList;

    BOOL _IsCiceroTSI() { return _fCiceroTSI; }

    ITextStoreAnchor *_GetTSI() { return _ptsi; }
    ITextStoreAnchor *_GetAATSI() { return _pMSAAState ? _pMSAAState->pAADoc : NULL; }

    BOOL _IsInEditSession() { return (_dwEditSessionFlags & TF_ES_INEDITSESSION); }
    BOOL _IsConnected() { return _dm ? TRUE : FALSE; }

    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
    { 
        Assert(dwFlags & TF_ES_READ); // minimum access...

        if (ec == BACKDOOR_EDIT_COOKIE)
        {
            Assert(!(dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE))); // app is trying to use def ec with write operation
            return !(dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)); // app can read anything it wants
        }

        Assert(_ec != TF_INVALID_EDIT_COOKIE); // must always return FALSE for TF_INVALID_EDIT_COOKIE...
        Assert(!(_dwEditSessionFlags & TF_ES_WRITE) || (_dwEditSessionFlags & TF_ES_PROPERTY_WRITE)); // write implies property write 

        return (ec == _ec &&
                (_dwEditSessionFlags & TF_ES_INEDITSESSION) &&
                (!(dwFlags & TF_ES_WRITE) || (_dwEditSessionFlags & TF_ES_WRITE))) &&
                (!(dwFlags & TF_ES_PROPERTY_WRITE) || (_dwEditSessionFlags & TF_ES_PROPERTY_WRITE));
    }

    void _IncLastLockReleaseID() { _dwLastLockReleaseID++; /* Issue: handle wrap-around */ }
    DWORD _GetLastLockReleaseID() { return _dwLastLockReleaseID; }

    CDocumentInputManager *_GetDm() { return _dm; }

    CEditRecord *_GetEditRecord() { return _pEditRecord; }
    HRESULT _OnTextChangeInternal(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao);

    CProperty *GetTextOwnerProperty();

    TfClientId _GetClientInEditSession(TfEditCookie ec) { return ec == BACKDOOR_EDIT_COOKIE ? g_gaApp : _tidInEditSession; }
    TfClientId _SetRawClientInEditSession(TfClientId tid)
    {
        TfClientId tidTmp = _tidInEditSession;
        _tidInEditSession = tid;
        return tidTmp;
    }

    CStructArray<GENERICSINK> *_GetTextEditSinks() { return &_rgSinks[IC_SINK_ITfTextEditSink]; }
    CStructArray<GENERICSINK> *_GetTextLayoutSinks() { return &_rgSinks[IC_SINK_ITfTextLayoutSink]; }
    CStructArray<GENERICSINK> *_GetStatusSinks() { return &_rgSinks[IC_SINK_ITfStatusSink]; }
    CStructArray<GENERICSINK> *_GetStartReconversionNotifySinks() { return &_rgSinks[IC_SINK_ITfStartReconversionNotifySink]; }
    CStructArray<GENERICSINK> *_GetEditTransactionSink() { return &_rgSinks[IC_SINK_ITfEditTransactionSink]; }
    CStructArray<CLEANUPSINK> *_GetCleanupSinks() { return &_rgCleanupSinks; }

    BOOL _AppSupportsCompositions() { return _pCompositionList != NULL; }
    CComposition *_GetCompositionList() { return _pCompositionList; }
    CComposition **_GetCompositionListPtr() { return &_pCompositionList; }
    ITfContextOwnerCompositionSink *_GetOwnerCompositionSink() { return _pOwnerComposeSink; }
    BOOL _DoesAppSupportCompositions() { return _pOwnerComposeSink != NULL; }
    BOOL _EnterCompositionOp()
    {
        return (_fInCompositionOp ? FALSE : (_fInCompositionOp = TRUE));
    }
    void _LeaveCompositionOp()
    {
        Assert(_fInCompositionOp);
        _fInCompositionOp = FALSE;
    }

    HRESULT _StartComposition(TfEditCookie ecWrite, IAnchor *paStart, IAnchor *paEnd, ITfCompositionSink *pSink, CComposition **ppComposition);
    HRESULT _TerminateCompositionWithLock(ITfCompositionView *pComposition, TfEditCookie ec);
    void _AbortCompositions();

    static void _PostponeLockRequestCallback(SYSTHREAD *psfn, CInputContext *pic);

    HRESULT _DoPseudoSyncEditSession(DWORD dwFlags, ULONG uCode, void *pvState, HRESULT *phrSession)
    {
        TS_QUEUE_ITEM item;

        item.pfnCallback = _PseudoSyncEditSessionQiCallback;
        item.dwFlags = dwFlags | TF_ES_SYNC;
        item.state.pes.uCode = uCode;
        item.state.pes.pvState = pvState;

        return _QueueItem(&item, FALSE, phrSession);
    }
    HRESULT _QueueItem(TS_QUEUE_ITEM *pItem, BOOL fForceAsync, HRESULT *phrSession);

    BOOL _ContextNeedsCleanup(const GUID *pCatId, LANGID langid, CStructArray<TfClientId> **pprgClientIds);
    void _CleanupContext(CStructArray<TfClientId> *prgClientIds);

    HRESULT GetMappedAppProperty(REFGUID guidProp, CProperty **ppProp);

private:

    friend CThreadInputMgr;
    friend CRange;
    friend CProperty;
    friend CFunction;

    typedef struct _IAS_OBJ
    {
        enum { IAS_TEXT, IAS_DATAOBJ } type;
        union
        {
            struct
            {
                const WCHAR *pchText;
                LONG cch;
            } text;
            struct
            {
                IDataObject *pDataObject;
            } obj;
        } state;
    } IAS_OBJ;

    HRESULT _InsertXAtSelection(TfEditCookie ec, DWORD dwFlags, IAS_OBJ *pObj, ITfRange **ppRange);
    void _DoPostTextEditNotifications(CComposition *pComposition, TfEditCookie ec, DWORD dwFlags, ULONG cchInserted, IAnchor *paStart, IAnchor *paEnd, CRange *range);
    BOOL _InsertXAtSelectionAggressive(TfEditCookie ec, DWORD dwFlags, IAS_OBJ *pObj, IAnchor **ppaStart, IAnchor **ppaEnd);

    int _GetCleanupListIndex(TfClientId tid);

    HRESULT _UnadviseOwnerSink();

    HRESULT _GetStartOrEnd(TfEditCookie ec, BOOL fStart, ITfRange **ppStart);

    BOOL _SynchAppChanges(DWORD dwLockFlags);
    HRESULT _EmptyLockQueue(DWORD dwLockFlags, BOOL fAppChangesSent);
    void _AbortQueueItems();
    void _PostponeLockRequest(DWORD dwFlags);

    HRESULT _DispatchQueueItem(TS_QUEUE_ITEM *pItem)
    {
        return pItem->pfnCallback(this, pItem, QI_DISPATCH);
    }
    void _ReleaseQueueItem(TS_QUEUE_ITEM *pItem)
    {
        pItem->pfnCallback(this, pItem, QI_FREE);
    }
    void _AddRefQueueItem(TS_QUEUE_ITEM *pItem)
    {
        pItem->pfnCallback(this, pItem, QI_ADDREF);
    }

    HRESULT _DoEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags);
    static HRESULT _EditSessionQiCallback(CInputContext *pic, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);
    static HRESULT _PseudoSyncEditSessionQiCallback(CInputContext *pic, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);

    HRESULT _OnSelectionChangeInternal(BOOL fAppChange);
    HRESULT _OnLayoutChangeInternal(TsLayoutCode lcode, TsViewCookie vcView);
    HRESULT _OnStatusChangeInternal();

    void _MarkDirtyRanges(IAnchor *paStart, IAnchor *paEnd);
    TFPROPERTYSTYLE _GetPropStyle(REFGUID rguidProp);

    void _IncEditCookie()
    {
        _ec++;

        // avoid reserved values!
        if (_ec == 0)
        {
            _ec = EC_MIN;
        }
    }

    void _Dbg_AssertNoSyncQueueItems()
    {
#ifdef DEBUG
        for (int i=0; i<_rgLockQueue.Count(); i++)
        {
            Assert((_rgLockQueue.GetPtr(i)->dwFlags & TF_ES_SYNC) == 0);
        }
#endif // DEBUG
    }

    CDocumentInputManager *_dm;

    ITextStoreAnchor *_ptsi;
    BOOL _fCiceroTSI;

    DWORD _dwLastLockReleaseID;

    TfEditCookie _ec;
    int _cEditRef;
    DWORD _dwEditSessionFlags;
    BOOL _fLockHeld; // perf: redundant with _dwlt?
    DWORD _dwlt; // perf: only need 2 bits
    TfClientId _tidInEditSession;
    DWORD _dwPendingLockRequest; // perf: only need 2 bits

    CEditRecord *_pEditRecord;
    BOOL EnsureEditRecord()
    {
       if (!_pEditRecord)
           _pEditRecord = new CEditRecord(this);

       return  _pEditRecord ? TRUE : FALSE;
    }
    BOOL _fLayoutChanged;
    BOOL _fStatusChanged; // perf: redundant w/ _dwStatusChangedFlags?
    DWORD _dwStatusChangedFlags;

    // array of TIP guidatom for both left and right side of the caret.
    TfGuidAtom _gaKeyEventFilterTIP[2];
    BOOL _fInvalidKeyEventFilterTIP;

    ITfContextKeyEventSink *_pICKbdSink;

    DWORD _dwSysFuncPrvCookie; // system function provider cookie

    //
    // TextOwner Property cache
    //
    CProperty *_pPropTextOwner;

    static const GUID *_c_rgPropStyle[];

    CStructArray<TS_QUEUE_ITEM> _rgLockQueue;

    static const IID *_c_rgConnectionIIDs[IC_NUM_CONNECTIONPTS];
    CStructArray<GENERICSINK> _rgSinks[IC_NUM_CONNECTIONPTS];
    CStructArray<CLEANUPSINK> _rgCleanupSinks;

    CStructArray<SPAN> _rgAppTextChanges;

    CComposition *_pCompositionList;

    CRange *_pOnChangeRanges; // ranges with ITfRangeChange sinks

    CContextView *_pActiveView;

    ITfContextOwnerCompositionSink *_pOwnerComposeSink; // may be NULL, be careful

    LONG _cRefEditTransaction;

    BOOL _fInCompositionOp : 1; // TRUE if we're inside a write modification to a composition (ceate, terminate, etc.)
    BOOL _fInUnserialize : 1; // TRUE if we're inside a property _Unserialize

    //
    // App Property Map
    //
    typedef struct _APPPROPMAP
    {
        GUID guidAppProp;
        GUID guidProp;
    } APPPROPMAP;
    CStructArray<APPPROPMAP> _rgAppPropMap;
    APPPROPMAP *FindMapAppProperty(REFGUID guidAppProp);

    //
    // disable PostThreadMessage for LoackRequest.
    //
    ULONG _nLockReqPostDisableRef;

    // aa stuff
    //
    void _InitMSAAHook(IAccServerDocMgr *pAAAdaptor);
    void _UninitMSAAHook(IAccServerDocMgr *pAAAdaptor);

    typedef struct
    {
        ITextStoreAnchor *ptsiOrg; // the original, unwrapped ptsi
        ITextStoreAnchor *pAADoc;  // the wrapped ITextStoreAnchor passed to _pAAAdaptor
    } MSAA_STATE;

    MSAA_STATE *_pMSAAState; // use a struct since we rarely use msaa
    //
    // end aa stuff

#ifdef DEBUG
    BOOL _dbg_fInOnLockGranted;
#endif

    DBG_ID_DECLARE;
};

inline CInputContext *GetCInputContext(IUnknown *punk)
{
    CInputContext *pic;

    punk->QueryInterface(IID_PRIV_CINPUTCONTEXT, (void **)&pic);

    return pic;
}

//+---------------------------------------------------------------------------
//
// SafeRequestLock
//
// ITextStoreAnchor::RequestLock wrapper.
//
// Normally each CInputContext holds a ref to a text store in its _ptsi member.
// But, it's possible that some crazy tip will Pop the context inside a
// RequestLock call, which releases and clears _ptsi.  This will likely crash
// the ptsi code, since after OnLockGranted, the object will be freed.
// So we protect the app by AddRef'ing the ptsi before the RequestLock call.
//----------------------------------------------------------------------------

inline HRESULT SafeRequestLock(ITextStoreAnchor *ptsi, DWORD dwLockFlags, HRESULT *phrSession)
{
    HRESULT hr;

    ptsi->AddRef(); // protect pointer in case someone Pops this context inside the RequestLock

    hr = ptsi->RequestLock(dwLockFlags, phrSession);

    ptsi->Release();

    return hr;
}

#endif // IC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\imecls.cpp ===
//
// imecls.cpp
//

#include "private.h"
#include "imecls.h"

DBG_ID_INSTANCE(CSysImeClassWnd);
DBG_ID_INSTANCE(CSysImeClassWndArray);

#define IMECLASSNAME TEXT("ime")

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CheckExistingImeClassWnd
//
//----------------------------------------------------------------------------

BOOL CheckExistingImeClassWnd(SYSTHREAD *psfn)
{
#ifdef USE_IMECLASS_SUBCLASS
    if (!psfn->prgImeClassWnd)
    {
        HWND hwnd = NULL;
        DWORD dwCurThreadId = GetCurrentThreadId();

        while (hwnd = FindWindowEx(NULL, hwnd, IMECLASSNAME, NULL))
        {
            DWORD dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
            if (dwThreadId != dwCurThreadId)
                continue;

            CSysImeClassWnd *picw = new CSysImeClassWnd();
            picw->Init(hwnd);
        }
    }

    if (!psfn->prgImeClassWnd)
        return TRUE;

    if (GetFocus())
        psfn->prgImeClassWnd->StartSubclass();
#endif

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UninitImeClassWndOnProcess
//
//----------------------------------------------------------------------------

BOOL UninitImeClassWndOnProcess()
{
    HWND hwnd = NULL;
    DWORD dwCurProcessId = GetCurrentProcessId();

    while (hwnd = FindWindowEx(NULL, hwnd, IMECLASSNAME, NULL))
    {
        DWORD dwProcessId;
        DWORD dwThreadId = GetWindowThreadProcessId(hwnd, &dwProcessId);
        if (dwProcessId != dwCurProcessId)
            continue;

        //
        // Set the wndproc pointer back to original WndProc.
        //
        // some other subclass window may keep my WndProc pointer.
        // but msctf.dll may be unloaded from memory so we don't want to 
        // call him to set the wndproc pointer back to our Wndproc pointer.
        // The pointer will be bogus.
        //
        WNDPROC pfn = (WNDPROC)GetClassLongPtr(hwnd, GCLP_WNDPROC);
        if (pfn != (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC))
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)pfn);
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWnd
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSysImeClassWnd::CSysImeClassWnd()
{
    Dbg_MemSetThisNameID(TEXT("CSysImeClassWnd"));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSysImeClassWnd::~CSysImeClassWnd()
{
    if (IsWindow(_hwnd))
    {
        Stop();

        if (_pfn)
        {
            //
            // Set the wndproc pointer back to original WndProc.
            //
            // some other subclass window may keep my WndProc pointer.
            // but msctf.dll may be unloaded from memory so we don't want to 
            // call him to set the wndproc pointer back to our Wndproc pointer.
            // The pointer will be bogus.
            //
            WNDPROC pfnOrgImeWndProc;
            pfnOrgImeWndProc = (WNDPROC)GetClassLongPtr(_hwnd, GCLP_WNDPROC);
            SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR)pfnOrgImeWndProc);
            _pfn = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
// IsImeClassWnd
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWnd::IsImeClassWnd(HWND hwnd)
{
    char szCls[6];

    if (!GetClassName(hwnd, szCls, sizeof(szCls)))
        return FALSE;

    return lstrcmpi(szCls, IMECLASSNAME) ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWnd::Init(HWND hwnd)
{
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn == NULL)
        return FALSE;

    if (!psfn->prgImeClassWnd)
    {
        psfn->prgImeClassWnd = new CSysImeClassWndArray();
        if (!psfn->prgImeClassWnd)
            return FALSE;
    }

    CSysImeClassWnd **ppicw = psfn->prgImeClassWnd->Append(1);
    if (!ppicw)
        return FALSE;

    *ppicw = this;

    _hwnd = hwnd;
    _pfn = NULL;
    
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Start
//
//----------------------------------------------------------------------------

void CSysImeClassWnd::Start()
{
    Assert(IsWindow(_hwnd));
    if (_pfn)
        return;

    _pfn = (WNDPROC)SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR)WndProc);
}

//+---------------------------------------------------------------------------
//
// Stop
//
//----------------------------------------------------------------------------

void CSysImeClassWnd::Stop()
{
    Assert(IsWindow(_hwnd));
    WNDPROC pfnCur;
    if (!_pfn)
        return;

    //
    // unfortunately, we can not restore the wndproc pointer always.
    // someone else subclassed it after we did.
    //
    pfnCur = (WNDPROC)GetWindowLongPtr(_hwnd, GWLP_WNDPROC);
    if (pfnCur == WndProc)
    {
        SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR)_pfn);
        _pfn = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// WndProc
//
//----------------------------------------------------------------------------

LRESULT CSysImeClassWnd::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (!psfn || !psfn->prgImeClassWnd)
    {
        Assert(0);
        return 0;
    }

    CSysImeClassWnd *_this = psfn->prgImeClassWnd->Find(hwnd);
    if (!_this)
    {
#ifdef DEBUG
        if ((uMsg != WM_DESTROY) && (uMsg != WM_NCDESTROY))
        {
            Assert(0);
        }
#endif
        return 0;
    }

    WNDPROC pfn = _this->_pfn;
    if (!pfn)
    {
        Assert(0);
        return 0;
    }

    switch (uMsg)
    {
#if 0
        //
        // we have a fall back logic to set the original window proc back
        // if we can not restore the window proc correctly.
        // so we don't have to do paranoid subclassing here.
        //
        case WM_IME_SELECT:
        case WM_IME_SETCONTEXT:
             _this->Stop();
             lRet = CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
             _this->Start();
             return lRet;
#endif

        case WM_IME_NOTIFY:
            if ((wParam == IMN_SETOPENSTATUS) ||
                (wParam == IMN_SETCONVERSIONMODE))
                OnIMENotify();
             break;

        case WM_DESTROY:
             lRet = CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
             psfn->prgImeClassWnd->Remove(_this);
             return lRet;

    }

    return CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
}

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWndArray
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSysImeClassWndArray::CSysImeClassWndArray()
{
    Dbg_MemSetThisNameID(TEXT("CSysImeClassWndArray"));
}

//+---------------------------------------------------------------------------
//
// StartSubClass
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWndArray::StartSubclass()
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        picw->Start();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// StopSubClass
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWndArray::StopSubclass()
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        picw->Stop();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Find
//
//----------------------------------------------------------------------------

CSysImeClassWnd *CSysImeClassWndArray::Find(HWND hwnd)
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        if (picw->GetWnd() == hwnd)
            return picw;
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CSysImeClassWndArray::Remove(CSysImeClassWnd *picw)
{
    for (int i = 0; i < Count(); i++)
    {
        if (picw == Get(i))
        {
            CPtrArray<CSysImeClassWnd>::Remove(i, 1);
            delete picw;
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
// RemoveAll
//
//----------------------------------------------------------------------------

void CSysImeClassWndArray::RemoveAll()
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        delete picw;
    }
    Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\icclean.cpp ===
//
// icclean.cpp
//

#include "private.h"
#include "tim.h"
#include "ic.h"
#include "compose.h"
#include "assembly.h"

class CCleanupShared
{
public:
    CCleanupShared(POSTCLEANUPCALLBACK pfnPostCleanup, LONG_PTR lPrivate)
    {
        _cRef = 1;
        _pfnPostCleanup = pfnPostCleanup;
        _lPrivate = lPrivate;
    }

    ~CCleanupShared()
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (psfn == NULL)
            return;

        if (psfn->ptim != NULL)
        {
            psfn->ptim->_SendEndCleanupNotifications();
        }

        if (_pfnPostCleanup != NULL)
        {
            _pfnPostCleanup(FALSE, _lPrivate);
        }

        if (psfn->ptim != NULL)
        {
            psfn->ptim->_HandlePendingCleanupContext();
        }
    }

    void _AddRef()
    {
        _cRef++;
    }

    LONG _Release()
    {
        LONG cRef = --_cRef;

        if (_cRef == 0)
        {
            delete this;
        }

        return cRef;
    }

private:
    LONG _cRef;
    POSTCLEANUPCALLBACK _pfnPostCleanup;
    LONG_PTR _lPrivate;
};

class CCleanupQueueItem : public CAsyncQueueItem
{
public:
    CCleanupQueueItem(BOOL fSync, CCleanupShared *pcs, CStructArray<TfClientId> *prgClientIds) : CAsyncQueueItem(fSync)
    {
        _prgClientIds = prgClientIds;
        if (!fSync)
        {
            _pcs = pcs;
            _pcs->_AddRef();
        }
    }

    ~CCleanupQueueItem()
    {
        delete _prgClientIds;
        _CheckCleanupShared();
    }

    HRESULT DoDispatch(CInputContext *pic);

private:
    void _CheckCleanupShared()
    {
        // last queue item?
        if (_pcs != NULL)
        {
            _pcs->_Release();
            _pcs = NULL;
        }
    }

    CStructArray<TfClientId> *_prgClientIds;
    CCleanupShared *_pcs;
};

//+---------------------------------------------------------------------------
//
// DoDispatch
//
//----------------------------------------------------------------------------

HRESULT CCleanupQueueItem::DoDispatch(CInputContext *pic)
{
    pic->_CleanupContext(_prgClientIds);

    // if this was the last pending lock, let the caller know
    _CheckCleanupShared();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CleanupContext
//
//----------------------------------------------------------------------------

void CInputContext::_CleanupContext(CStructArray<TfClientId> *prgClientIds)
{
    int i;
    int j;
    CLEANUPSINK *pSink;

    Assert(!(_dwEditSessionFlags & TF_ES_INEDITSESSION)); // shouldn't get this far
    Assert(_tidInEditSession == TF_CLIENTID_NULL); // there should never be another session in progress -- this is not a reentrant func

    _dwEditSessionFlags = (TF_ES_INEDITSESSION | TF_ES_READWRITE | TF_ES_PROPERTY_WRITE);

    //
    // call any tips that want to cleanup
    //
    for (i=0; i<_rgCleanupSinks.Count(); i++)
    {
        pSink = _rgCleanupSinks.GetPtr(i);

        if (prgClientIds != NULL)
        {
            // we only want to call sinks with client ids on this list...
            for (j=0; j<prgClientIds->Count(); j++)
            {
                if (*prgClientIds->GetPtr(j) == pSink->tid)
                    break;
            }
            // if we didn't find the sink's tid, skip it
            if (j == prgClientIds->Count())
                continue;
        }

        _tidInEditSession = pSink->tid;

        pSink->pSink->OnCleanupContext(_ec, this);

        _NotifyEndEdit();
        _IncEditCookie(); // next edit cookie value
    }

    _dwEditSessionFlags = 0;
    _tidInEditSession = TF_CLIENTID_NULL;

    //
    // wipe any left over compositions
    //
    TerminateComposition(NULL);
    Assert(_pCompositionList == NULL);
}

//+---------------------------------------------------------------------------
//
// _GetCleanupListIndex
//
//----------------------------------------------------------------------------

int CInputContext::_GetCleanupListIndex(TfClientId tid)
{
    int i;

    for (i=0; i<_rgCleanupSinks.Count(); i++)
    {
        if (_rgCleanupSinks.GetPtr(i)->tid == tid)
            return i;
    }

    return -1;
}

//+---------------------------------------------------------------------------
//
// _ContextNeedsCleanup
//
//----------------------------------------------------------------------------

BOOL CInputContext::_ContextNeedsCleanup(const GUID *pCatId, LANGID langid, CStructArray<TfClientId> **pprgClientIds)
{
    int i;
    int j;
    CLEANUPSINK *pSink;
    SYSTHREAD *psfn;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pAsmItem;
    TfGuidAtom gaAsmItem;
    TfClientId *ptid;

    *pprgClientIds = NULL; // NULL means "all"

    // any cleanup sinks?
    if (pCatId == NULL)
        return (_pCompositionList != NULL || _rgCleanupSinks.Count() > 0);

    if ((psfn = GetSYSTHREAD()) == NULL)
        goto Exit;

    if ((pAsmList = EnsureAssemblyList(psfn)) == NULL)
        goto Exit;

    if ((pAsm = pAsmList->FindAssemblyByLangId(langid)) == NULL)
        goto Exit;

    // need to lookup each sink in the assembly list
    // if we can find a tip in the list with a matching
    // catid, then we need to lock this ic

    for (i=0; i<_rgCleanupSinks.Count(); i++)
    {
        pSink = _rgCleanupSinks.GetPtr(i);

        for (j=0; j<pAsm->Count(); j++)
        {
            pAsmItem = pAsm->GetItem(j);

            if ((MyRegisterGUID(pAsmItem->clsid, &gaAsmItem) == S_OK &&
                 gaAsmItem == pSink->tid) ||
                (g_gaApp == pSink->tid))
            {
                if (*pprgClientIds == NULL)
                {
                    // need to alloc the [out] array of client ids
                    if ((*pprgClientIds = new CStructArray<TfClientId>) == NULL)
                        return FALSE;
                }

                ptid = (*pprgClientIds)->Append(1);

                if (ptid != NULL)
                {
                    *ptid = pSink->tid;
                }

                break;
            }
        }
    }

Exit:
    return (_pCompositionList != NULL || *pprgClientIds != NULL);
}

//+---------------------------------------------------------------------------
//
// _HandlePendingCleanupContext
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_HandlePendingCleanupContext()
{
    Assert(_fPendingCleanupContext);
    _fPendingCleanupContext = FALSE;

    if (_pPendingCleanupContext == NULL)
        return;

    CLEANUPCONTEXT *pcc = _pPendingCleanupContext;

    _pPendingCleanupContext = NULL;
    _CleanupContextsWorker(pcc);

    cicMemFree(pcc);
}

//+---------------------------------------------------------------------------
//
// _CleanupContexts
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_CleanupContexts(CLEANUPCONTEXT *pcc)
{
    if (pcc->fSync && _fPendingCleanupContext)
    {
        // this can happen from Deactivate
        // can't interrupt another cleanup synchronously, abort the request
        if (pcc->pfnPostCleanup != NULL)
        {
            pcc->pfnPostCleanup(TRUE, pcc->lPrivate);
        }
        return;
    }

    if (_pPendingCleanupContext != NULL)
    {
        // abort the callback and free the pending cleanup
        if (_pPendingCleanupContext->pfnPostCleanup != NULL)
        {
            _pPendingCleanupContext->pfnPostCleanup(TRUE, _pPendingCleanupContext->lPrivate);
        }
        cicMemFree(_pPendingCleanupContext);
        _pPendingCleanupContext = NULL;
    }

    if (!_fPendingCleanupContext)
    {
        _CleanupContextsWorker(pcc);
        return;
    }

    // we've interrupted a cleanup in progress

    // allocate some space for the params
    if ((_pPendingCleanupContext = (CLEANUPCONTEXT *)cicMemAlloc(sizeof(CLEANUPCONTEXT))) == NULL)
    {
        if (pcc->pfnPostCleanup != NULL)
        {
            // abort the cleanup
            pcc->pfnPostCleanup(TRUE, pcc->lPrivate);
        }
        return;
    }

    *_pPendingCleanupContext = *pcc;
}

//+---------------------------------------------------------------------------
//
// _CleanupContexts
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_CleanupContextsWorker(CLEANUPCONTEXT *pcc)
{
    int iDim;
    int iContext;
    CDocumentInputManager *dim;
    CInputContext *pic;
    CCleanupQueueItem *pItem;
    HRESULT hr;
    CCleanupShared *pcs;
    CStructArray<TfClientId> *prgClientIds;

    _fPendingCleanupContext = TRUE;
    pcs = NULL;

    _CalcAndSendBeginCleanupNotifications(pcc);

    // enum all the ic's on this thread
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);

            if (!pic->_ContextNeedsCleanup(pcc->pCatId, pcc->langid, &prgClientIds))
                continue;

            if (!pcc->fSync && pcs == NULL)
            {
                // allocate a shared counter
                if ((pcs = new CCleanupShared(pcc->pfnPostCleanup, pcc->lPrivate)) == NULL)
                {
                    delete prgClientIds;
                    return;
                }
            }

            // queue an async callback
            if (pItem = new CCleanupQueueItem(pcc->fSync, pcs, prgClientIds))
            {
                pItem->_CheckReadOnly(pic);

                if (pic->_QueueItem(pItem->GetItem(), FALSE, &hr) != S_OK)
                {
                    Assert(0); // couldn't get app lock
                }

                pItem->_Release();
            }
        }
    }

    if (pcs == NULL)
    {
        // we didn't need to allocate any shared ref (either no ic's, or lock reqs were sync only)
        _SendEndCleanupNotifications();

        if (pcc->pfnPostCleanup != NULL)
        {
            pcc->pfnPostCleanup(FALSE, pcc->lPrivate);
        }
        _HandlePendingCleanupContext();
    }
    else
    {
        // release our ref
        pcs->_Release();
    }
}

//+---------------------------------------------------------------------------
//
// _CalcAndSendBeginCleanupNotifications
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_CalcAndSendBeginCleanupNotifications(CLEANUPCONTEXT *pcc)
{
    UINT i;
    int j;
    int iDim;
    int iContext;
    CDocumentInputManager *dim;
    CInputContext *pic;
    CTip *tip;
    CStructArray<TfClientId> *prgClientIds;

    // first clear the _fNeedCleanupCall for all tips
    for (i=0; i<_GetTIPCount(); i++)
    {
        _rgTip.Get(i)->_fNeedCleanupCall = FALSE;
    }

    // now set the flag where appropriate
    // enum all the ic's on this thread
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);

            if (!pic->_ContextNeedsCleanup(pcc->pCatId, pcc->langid, &prgClientIds))
                continue;

            for (i=0; i<_GetTIPCount(); i++)
            {
                tip = _rgTip.Get(i);

                if (tip->_pCleanupDurationSink == NULL)
                    continue; // no sink, no notification

                if (prgClientIds == NULL)
                {
                    // all sinks on this ic need callbacks
                    for (j=0; j<pic->_GetCleanupSinks()->Count(); j++)
                    {
                        if (pic->_GetCleanupSinks()->GetPtr(j)->tid == tip->_guidatom)
                        {
                            tip->_fNeedCleanupCall = TRUE;
                            break;
                        }
                    }
                }
                else
                {
                    // just the tips in prgClientIds need callbacks
                    for (j=0; j<prgClientIds->Count(); j++)
                    {
                        if (*prgClientIds->GetPtr(j) == tip->_guidatom)
                        {
                            tip->_fNeedCleanupCall = TRUE;
                            break;
                        }
                    }
                }
            }

            delete prgClientIds;
        }
    }

    // now send the notifications
    for (i=0; i<_GetTIPCount(); i++)
    {
        tip = _rgTip.Get(i);

        if (tip->_fNeedCleanupCall)
        {
            Assert(tip->_pCleanupDurationSink != NULL);
            tip->_pCleanupDurationSink->OnStartCleanupContext();
        }
    }
}

//+---------------------------------------------------------------------------
//
// _SendEndCleanupNotifications
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_SendEndCleanupNotifications()
{
    CTip *tip;
    UINT i;

    for (i=0; i<_GetTIPCount(); i++)
    {
        tip = _rgTip.Get(i);

        if (tip->_fNeedCleanupCall)
        {
            if (tip->_pCleanupDurationSink != NULL)
            {
                tip->_pCleanupDurationSink->OnEndCleanupContext();
            }
            tip->_fNeedCleanupCall = FALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\ics.cpp ===
//
// ics.cpp
//

#include "private.h"
#include "tim.h"
#include "dim.h"
#include "ic.h"
#include "emptyic.h"
#include "acp2anch.h"
#include "enumic.h"

//+---------------------------------------------------------------------------
//
// GetTop
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::GetTop(ITfContext **ppic)
{
    return _GetContext(_iStack, ppic);
}

//+---------------------------------------------------------------------------
//
// GetBase
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::GetBase(ITfContext **ppic)
{
    return _GetContext(0, ppic);
}

//+---------------------------------------------------------------------------
//
// _GetContext
//
//----------------------------------------------------------------------------

HRESULT CDocumentInputManager::_GetContext(int iStack, ITfContext **ppic)
{
    if (ppic == NULL)
        return E_INVALIDARG;

    *ppic = NULL;

    if (_iStack == -1)
    {
        Assert(iStack == 0 || iStack == -1); // caller should be GetBottom or internal using _iStack...
        if (!_peic)
        {
            _peic = new CEmptyInputContext(this);

            if (_peic == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(_peic->Init()))
            {
                SafeReleaseClear(_peic);
                return E_FAIL;
            }
        }

        *ppic = _peic;
    }
    else
    {
        Assert(iStack >= 0 && iStack <= _iStack);
        *ppic = _Stack[iStack];
    }
    Assert(*ppic);
    
    (*ppic)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreateContext
//
//----------------------------------------------------------------------------

// this is a constant we removed before cicero ship, but office10 still uses it
// it can be ignored, but it must be accepted as legal
#define TF_PLAINTEXTTSI 0x1

STDAPI CDocumentInputManager::CreateContext(TfClientId tid, DWORD dwFlags, IUnknown *punk, ITfContext **ppic, TfEditCookie *pecTextStore)
{
    CInputContext *pic;
    ITextStoreAnchor *ptsi;
    ITextStoreACP *ptsiACP;
    CThreadInputMgr *tim;
    ITfContextOwnerCompositionSink *pOwnerComposeSink;
    HRESULT hr;

    if (pecTextStore != NULL)
    {
        *pecTextStore = TF_INVALID_EDIT_COOKIE;
    }
    if (ppic != NULL)
    {
        *ppic = NULL;
    }

    if (ppic == NULL || pecTextStore == NULL)
        return E_INVALIDARG;

    if (dwFlags & ~TF_PLAINTEXTTSI)
        return E_INVALIDARG;

    if ((tim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    if (!tim->_IsValidTfClientId(tid))
        return E_INVALIDARG;

    ptsi = NULL;
    pOwnerComposeSink = NULL;

    if (punk != NULL)
    {
        if (g_fNoITextStoreAnchor ||
            punk->QueryInterface(IID_ITextStoreAnchor, (void **)&ptsi) != S_OK ||
            ptsi == NULL)
        {
            if (punk->QueryInterface(IID_ITextStoreACP, (void **)&ptsiACP) != S_OK || ptsiACP == NULL)
            {                
                ptsiACP = NULL;
            }
            else
            {
                ptsi = new CACPWrap(ptsiACP);
                ptsiACP->Release();

                if (ptsi == NULL)
                    return E_OUTOFMEMORY;
            }
        }

        if (punk->QueryInterface(IID_ITfContextOwnerCompositionSink, (void **)&pOwnerComposeSink) != S_OK)
        {
            pOwnerComposeSink = NULL;
        }
    }

    if ((pic = new CInputContext(tid)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (pic->_Init(tim, this, ptsi, pOwnerComposeSink) != S_OK)
    {
        pic->Release();
        hr = E_FAIL;
        goto Exit;
    }

    *ppic = pic;

    if (ptsi != NULL)
    {
        // caller is doing the ITextStore, so return a back door ec
        *pecTextStore = BACKDOOR_EDIT_COOKIE;
    }

    hr = S_OK;

Exit:
    SafeRelease(ptsi);
    SafeRelease(pOwnerComposeSink);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Push
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::Push(ITfContext *pic)
{
    CInputContext *pcic;

    if (pic == NULL)
        return E_INVALIDARG;

    if (_iStack == ICS_STACK_SIZE - 1)
        return TF_E_STACKFULL;

    pcic = GetCInputContext(pic);
    if (!pcic)
        return E_INVALIDARG;
    
    if (_fPoppingStack)
        return E_UNEXPECTED;

    // we don't need AddRef here, GetCInputContext did AddRef().
    _Stack[++_iStack] = pcic;

    pcic->_AdviseSinks();

    // if it's the first push, we call a notification.
    if (_iStack == 0)
    {
        CThreadInputMgr *tim;
        if ((tim = CThreadInputMgr::_GetThis()) == NULL)
            return E_FAIL;

        tim->_NotifyCallbacks(TIM_INITDIM, this, NULL);
    }

    pcic->_Pushed();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Pop
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::Pop(DWORD dwFlags)
{
    CThreadInputMgr *tim;
    if (dwFlags & ~TF_POPF_ALL)
        return E_INVALIDARG;

    if (_iStack == -1)
        return E_FAIL;

    if (_fPoppingStack)
        return E_UNEXPECTED;

    if ((tim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    if (!(dwFlags & TF_POPF_ALL))
    {
        if (!_iStack)
           return E_FAIL;

        _Pop(tim); 
    }
    else
    {
        while(_iStack >= 0)
        { 
            _Pop(tim);
        }

        // clear the focus if this guy has it
        if (tim->_GetFocusDocInputMgr() == this)
        {
            tim->_SetFocus(NULL, TRUE);
        }

        tim->_NotifyCallbacks(TIM_UNINITDIM, this, NULL);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _Pop
//
//----------------------------------------------------------------------------

BOOL CDocumentInputManager::_Pop(CThreadInputMgr *tim)
{
    CInputContext *pic;

    Assert(_iStack >= 0);

    pic = _Stack[_iStack];

    // don't let anyone mess with the stack while we adjust it
    _fPoppingStack = TRUE;

    // call _Popped() to release properties and compartments.
    // must do this before _UnadviseSinks while the ITextStore
    // has not yet been released
    pic->_Popped();

    pic->_UnadviseSinks(tim);
    pic->Release();

    _fPoppingStack = FALSE;

    _iStack--;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// EnumInputContexts
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::EnumContexts(IEnumTfContexts **ppEnum)
{
    CEnumInputContexts *pEnum;

    pEnum = new CEnumInputContexts();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetTopIC
//
//----------------------------------------------------------------------------

CInputContext *CDocumentInputManager::_GetTopIC()
{
    if (_iStack == -1)
        return NULL;

    return _Stack[_iStack];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\imecls.h ===
//
// imecls.h
//

#ifndef IMECLS_H
#define IMECLS_H

#include "private.h"
#include "globals.h"


//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

BOOL CheckExistingImeClassWnd(SYSTHREAD *psfn);
BOOL UninitImeClassWndOnProcess();

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWnd
//
//////////////////////////////////////////////////////////////////////////////

class CSysImeClassWnd
{
public:
    CSysImeClassWnd();
    ~CSysImeClassWnd();

    static BOOL CheclExistingImeClassWnd(SYSTHREAD *psfn);
    static BOOL IsImeClassWnd(HWND hwnd);
    BOOL Init(HWND hwnd);

    static LRESULT WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND GetWnd() {return _hwnd;}
    void Start();
    void Stop();


private:
    HWND    _hwnd;
    WNDPROC _pfn;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWndArray
//
//////////////////////////////////////////////////////////////////////////////

class CSysImeClassWndArray : public CPtrArray<CSysImeClassWnd>
{
public:
    CSysImeClassWndArray();

    BOOL StartSubclass();
    BOOL StopSubclass();
    CSysImeClassWnd *Find(HWND hwnd);
    void Remove(CSysImeClassWnd *picw);
    void RemoveAll();

private:
    DBG_ID_DECLARE;
};


#endif  // IMECLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\imelist.h ===
//
// imelist.h
//


#ifndef TFELIST_H
#define TFELIST_H

#include "globals.h"
#include "enumguid.h"
#include "sink.h"

HRESULT GetProfileIconInfo(REFCLSID rclsid,
                          LANGID langid,
                          REFGUID guidProfile,
                          WCHAR *pszFileName,
                          int cchFileNameMax,
                          ULONG *puIconIndex);

HRESULT EnableLanguageProfileForReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable);
BOOL IsEnabledLanguageProfileFromReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile);

//////////////////////////////////////////////////////////////////////////////
//
// CInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

class CInputProcessorProfiles : public ITfInputProcessorProfilesEx,
                                public ITfInputProcessorProfileSubstituteLayout,
                                public ITfSource,
                                public CComObjectRoot_CreateSingletonInstance<CInputProcessorProfiles>
{
public:
    CInputProcessorProfiles();
    ~CInputProcessorProfiles();

    BEGIN_COM_MAP_IMMX(CInputProcessorProfiles)
        COM_INTERFACE_ENTRY(ITfInputProcessorProfiles)
        COM_INTERFACE_ENTRY(ITfInputProcessorProfilesEx)
        COM_INTERFACE_ENTRY(ITfInputProcessorProfileSubstituteLayout)
        COM_INTERFACE_ENTRY(ITfSource)
    END_COM_MAP_IMMX()

    // ITfInputProcessorProfiles
    STDMETHODIMP Register(REFCLSID clsid);

    STDMETHODIMP Unregister(REFCLSID clsid);

    STDMETHODIMP AddLanguageProfile(REFCLSID rclsid,
                                    LANGID langid,
                                    REFGUID guidProfile,
                                    const WCHAR *pchProfile,
                                    ULONG cch,
                                    const WCHAR *pchFile,
                                    ULONG cchFile,
                                    ULONG uIconIndex);

    STDMETHODIMP RemoveLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile);

    STDMETHODIMP EnumInputProcessorInfo(IEnumGUID **ppEnum);

    STDMETHODIMP GetDefaultLanguageProfile(LANGID langid, 
                                           REFGUID catid, 
                                           CLSID *pclsid,
                                           GUID *pguidProfile);

    STDMETHODIMP SetDefaultLanguageProfile(LANGID langid, 
                                           REFCLSID rclsid, 
                                           REFGUID guidProfile);

    STDMETHODIMP ActivateLanguageProfile(REFCLSID rclsid, 
                                         LANGID langid, 
                                         REFGUID guidProfile);

    STDMETHODIMP GetActiveLanguageProfile(REFCLSID clsid, 
                                          LANGID *plangid, 
                                          GUID *pguidProfile);

    STDMETHODIMP GetLanguageProfileDescription(REFCLSID clsid, 
                                               LANGID langid, 
                                               REFGUID guidProfile,
                                               BSTR *pbstr);

    STDMETHODIMP GetCurrentLanguage(LANGID *plangid);

    STDMETHODIMP ChangeCurrentLanguage(LANGID langid);

    STDMETHODIMP GetLanguageList(LANGID **pplangid, ULONG *pulCount);

    STDMETHODIMP EnumLanguageProfiles(LANGID langid, 
                                      IEnumTfLanguageProfiles **ppEnum);

    STDMETHODIMP EnableLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile,
                                       BOOL fEnable);

    STDMETHODIMP IsEnabledLanguageProfile(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          BOOL *pfEnable);

    STDMETHODIMP EnableLanguageProfileByDefault(REFCLSID rclsid,
                                                LANGID langid,
                                                REFGUID guidProfile,
                                                BOOL fEnable);

    STDMETHODIMP SubstituteKeyboardLayout(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          HKL hKL);

    // ITfInputProcessorProfiles
    STDMETHODIMP SetLanguageProfileDisplayName(REFCLSID rclsid,
                                               LANGID langid,
                                               REFGUID guidProfile,
                                               const WCHAR *pchFile,
                                               ULONG cchFile,
                                               ULONG uResId);


    // ITfInputProcessorProfileSubstituteLayout
    STDMETHODIMP GetSubstituteKeyboardLayout(REFCLSID rclsid,
                                             LANGID langid,
                                             REFGUID guidProfile,
                                             HKL *phKL);


    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *puCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    BOOL _OnLanguageChange(BOOL fChanged, LANGID langid);

    static CInputProcessorProfiles *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;
        return psfn->pipp;
    }

    static BOOL _SetThis(CInputProcessorProfiles *_this)
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return FALSE;

        Assert(psfn->pipp == NULL || _this == NULL);
        psfn->pipp = _this;
        return TRUE;
    }

private:
    CStructArray<GENERICSINK> _rgNotifySinks; // ITfLanguageProfilesNotifySink
    BOOL _GetTIPRegister(CLSID **prgclsid, ULONG *pulCount);

    DBG_ID_DECLARE;
};

#endif // TFELIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\imelist.cpp ===
//
// immstat.cpp
//

#include "private.h"
#include "cregkey.h"
#include "imelist.h"
#include "regsvr.h"
#include "tim.h"
#include "immxutil.h"
#include "assembly.h"
#include "thdutil.h"
#include "internat.h"



DBG_ID_INSTANCE(CInputProcessorProfiles);

//+---------------------------------------------------------------------------
//
// MyGetTIPCategory
//
//----------------------------------------------------------------------------

BOOL MyGetTIPCategory(REFCLSID clsid, GUID *pcatid)
{
    IEnumGUID *pEnumCat;
    HRESULT hr;
    BOOL fFound = FALSE;

    *pcatid = GUID_NULL;

    hr = MyEnumItemsInCategory(GUID_TFCAT_CATEGORY_OF_TIP, &pEnumCat);
    if (SUCCEEDED(hr) && pEnumCat)
    {
        GUID guidCat;
        while (!fFound && (pEnumCat->Next(1, &guidCat, NULL) == S_OK))
        {
            IEnumGUID *pEnumTip;
            hr = MyEnumItemsInCategory(guidCat, &pEnumTip);
            if (SUCCEEDED(hr) && pEnumTip)
            {
                GUID guidTip;
                while (!fFound && (pEnumTip->Next(1, &guidTip, NULL) == S_OK))
                {
                    if (IsEqualGUID(clsid, guidTip))
                    {
                        *pcatid = guidCat;
                        fFound = TRUE;
                    }
                }
                pEnumTip->Release();
            }
        }
    
        pEnumCat->Release();
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
// GetProfileIconInfo
//
//----------------------------------------------------------------------------

HRESULT GetProfileIconInfo(REFCLSID rclsid,
                          LANGID langid,
                          REFGUID guidProfile,
                          WCHAR *pszFileName,
                          int cchFileNameMax,
                          ULONG *puIconIndex)
{
    CMyRegKey keyTmp;
    CMyRegKey key;
    char szTmp[256];

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    StringCchPrintf(szTmp + lstrlen(szTmp), ARRAYSIZE(szTmp)-lstrlen(szTmp), "0x%08x", langid);

    if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Open(keyTmp, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    key.QueryValueCchW(pszFileName, c_szIconFileW, cchFileNameMax);
    key.QueryValue((DWORD &)*puIconIndex, c_szIconIndex);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitProfileRegKeyStr
//
//----------------------------------------------------------------------------

BOOL InitProfileRegKeyStr(char *psz, ULONG cchMax, REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    ULONG cch;

    if (StringCchCopy(psz, cchMax, c_szCTFTIPKey) != S_OK)
        return FALSE;

    cch = lstrlen(psz);
    if (cch + CLSID_STRLEN + 1 >= cchMax)
        return FALSE;

    CLSIDToStringA(rclsid, psz + cch);

    psz += cch + CLSID_STRLEN;
    cchMax -= cch + CLSID_STRLEN;
    Assert(cchMax > 0);

    if (StringCchPrintf(psz, cchMax, "\\%s0x%08x\\", c_szLanguageProfileKey, langid) != S_OK)
        return FALSE;

    cch = lstrlen(psz);
    if (cch + CLSID_STRLEN + 1 >= cchMax)
        return FALSE;

    CLSIDToStringA(guidProfile, psz + cch);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// EnableLanguageProfileForReg
//
//----------------------------------------------------------------------------

HRESULT EnableLanguageProfileForReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    CMyRegKey key;
    char szTmp[256];

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Create(HKEY_CURRENT_USER, szTmp) != S_OK)
        return E_FAIL;

    if (key.SetValue((DWORD)(fEnable ? 1 : 0), c_szEnable) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsEnabledLanguageProfileFromReg
//
//----------------------------------------------------------------------------

BOOL IsEnabledLanguageProfileFromReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    CMyRegKey key;
    char szTmp[256];
    CMyRegKey keyLM;
    DWORD dw;

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return TRUE;

    //
    // we just check the Current User setting at first.
    //
    if (key.Open(HKEY_CURRENT_USER, szTmp, KEY_READ) == S_OK)
    {
        if (key.QueryValue(dw, c_szEnable) == S_OK)
         return dw ? TRUE : FALSE;
    }

    //
    // If this current user does not have a setting,
    // we just check the default value to see Local Machine setting.
    //
    if (keyLM.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
    {
        if (keyLM.QueryValue(dw, c_szEnable) == S_OK)
            return dw ? TRUE : FALSE;
    }
    else
    {
        //
        // Check a neutral language id.
        //
        if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, LOWORD(PRIMARYLANGID(langid)), guidProfile))
            return TRUE;

        if (keyLM.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
        {
            if (keyLM.QueryValue(dw, c_szEnable) == S_OK)
                return dw ? TRUE : FALSE;
        }
        else
        {
            //
            // Check a neutral language id.
            //
            if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, 0x0000ffff, guidProfile))
                return TRUE;

            if (keyLM.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
            {
                if (keyLM.QueryValue(dw, c_szEnable) == S_OK)
                    return dw ? TRUE : FALSE;
            }
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CInputProcessorProfiles::CInputProcessorProfiles()
{
    Assert(_GetThis() == NULL);
    _SetThis(this); // save a pointer to this in TLS
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CInputProcessorProfiles::~CInputProcessorProfiles()
{
    _SetThis(NULL); // clear pointer to this in TLS
}

//+---------------------------------------------------------------------------
//
// EnumInputProcessors
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnumInputProcessorInfo(IEnumGUID **ppEnum)
{
    CEnumGuid *pEnum;
    CLSID *pImxClsid;
    ULONG nNumImx;

    if (!ppEnum)
        return E_INVALIDARG;

    if (!_GetTIPRegister(&pImxClsid, &nNumImx))
        return E_FAIL;

    pEnum = new CEnumGuid;

    if (!pEnum)
    {
        delete pImxClsid;
        return E_OUTOFMEMORY;
    }

    if (pEnum->_Init(nNumImx, pImxClsid))
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    delete pImxClsid;

    return pEnum ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Register
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::Register(REFCLSID rclsid)
{
    CMyRegKey key;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    key.SetValueW(L"1", c_szEnableW);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Unregister
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::Unregister(REFCLSID rclsid)
{
    CMyRegKey key;
    TCHAR szKey[256];
    TCHAR szSubKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    CLSIDToStringA(rclsid, szSubKey);

    key.RecurseDeleteKey(szSubKey);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _UpdateTIPRegister
//
//----------------------------------------------------------------------------

BOOL CInputProcessorProfiles::_GetTIPRegister(CLSID **prgclsid, ULONG *pulCount)
{
    CMyRegKey key;
    CLSID *pImxClsid;
    ULONG nNumImx;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) != S_OK)
        return FALSE;

    nNumImx = (int)key.GetNumSubKeys();

    if ((pImxClsid = new CLSID[nNumImx]) == NULL)
        return FALSE;

    CLSID *pclsid = pImxClsid;
    DWORD dwIndex = 0;
    TCHAR achClsid[CLSID_STRLEN+1];
    while (key.EnumKey(dwIndex, achClsid, ARRAYSIZE(achClsid)) == S_OK)
    {
        StringAToCLSID(achClsid, pclsid);
        pclsid++;
        dwIndex++;
    }

    *prgclsid = pImxClsid;
    *pulCount = nNumImx;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// AddLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::AddLanguageProfile(REFCLSID rclsid,
                                                   LANGID langid,
                                                   REFGUID guidProfile,
                                                   const WCHAR *pchProfile,
                                                   ULONG cch,
                                                   const WCHAR *pchFile,
                                                   ULONG cchFile,
                                                   ULONG uIconIndex)
{
    CMyRegKey keyTmp;
    CMyRegKey key;
    char szTmp[256];

    if (!pchProfile)
       return E_INVALIDARG;

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    StringCchPrintf(szTmp + lstrlen(szTmp), ARRAYSIZE(szTmp)-lstrlen(szTmp), "0x%08x", langid);

    if (keyTmp.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Create(keyTmp, szTmp) != S_OK)
        return E_FAIL;

    key.SetValueW(WCHtoWSZ(pchProfile, cch), c_szDescriptionW);

    if (pchFile)
    {
        key.SetValueW(WCHtoWSZ(pchFile, cchFile), c_szIconFileW);
        key.SetValue(uIconIndex, c_szIconIndex);
    }

    CAssemblyList::InvalidCache();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetLanguageProfileDisplayName
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::SetLanguageProfileDisplayName(REFCLSID rclsid,
                                               LANGID langid,
                                               REFGUID guidProfile,
                                               const WCHAR *pchFile,
                                               ULONG cchFile,
                                               ULONG uResId)
{
    CMyRegKey keyTmp;
    CMyRegKey key;
    char szTmp[MAX_PATH];
    WCHAR wszTmp[MAX_PATH];
    WCHAR wszResId[MAX_PATH];

    if (!pchFile)
       return E_INVALIDARG;

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    StringCchPrintf(szTmp + lstrlen(szTmp), ARRAYSIZE(szTmp)-lstrlen(szTmp), "0x%08x", langid);

    if (keyTmp.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Create(keyTmp, szTmp) != S_OK)
        return E_FAIL;

    //
    // make "@[filename],-ResId" string 
    //
    StringCopyArrayW(wszTmp, L"@");
    StringCatArrayW(wszTmp, WCHtoWSZ(pchFile, cchFile));
    StringCatArrayW(wszTmp, L",-");
    StringCchPrintfW(wszResId, ARRAYSIZE(wszResId), L"%u", uResId);
    StringCatArrayW(wszTmp, wszResId);

    key.SetValueW(wszTmp, c_szMUIDescriptionW);

    CAssemblyList::InvalidCache();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RemoveLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::RemoveLanguageProfile(REFCLSID rclsid,
                                                      LANGID langid,
                                                      REFGUID guidProfile)
{
    CMyRegKey key;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));
    StringCatArray(szKey, "\\");
    StringCatArray(szKey, c_szLanguageProfileKey);
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey)-lstrlen(szKey), "0x%08x", langid);

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szKey);
    key.RecurseDeleteKey(szKey);


    CAssemblyList::InvalidCache();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDefaultLanguageProfile
//
// Which GetActiveLanguageProfile() or GetDefaultLanguageProfile() should
// we use?
//
// WARNING!!!
//
// This function is not FocusDIM sensetive. So we sould not call any function
// to check TIM or FocusDIM.
//
// If you want to care about TIM and FocusDIM, try GetActiveLanguageProfile.
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetDefaultLanguageProfile(LANGID langid, REFGUID catid, CLSID *pclsid, GUID *pguidProfile)
{
    CAssemblyList *pAsmList;
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    CAssembly *pAsm;
    int nCnt;
    int i;
    ASSEMBLYITEM *pItem;
    BOOL fFound;

    if (!pclsid)
        return E_INVALIDARG;

    *pclsid = CLSID_NULL;

    if (!pguidProfile)
        return E_INVALIDARG;

    *pguidProfile = GUID_NULL;

    if (!langid)
        return E_INVALIDARG;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
         return E_FAIL;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
         return E_FAIL;

    pItem = NULL;
    fFound = FALSE;
    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (pItem->fActive && IsEqualGUID(catid, pItem->catid))
        {
            *pclsid = pItem->clsid;
            *pguidProfile = pItem->guidProfile;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        return S_FALSE;
    }

    if (IsEqualCLSID(*pclsid, CLSID_NULL))
    {
        Assert(pItem);
        *((DWORD *)pguidProfile) =  (DWORD)(UINT_PTR)(HKL)(pItem->hkl);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetDefault
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::SetDefaultLanguageProfile(LANGID langid, REFCLSID rclsid, REFGUID guidProfile)
{
    GUID catid;

    if (IsEqualGUID(rclsid, GUID_NULL))
        return E_INVALIDARG;

    if (IsEqualGUID(guidProfile, GUID_NULL))
        return E_INVALIDARG;

    if (!MyGetTIPCategory(rclsid, &catid))
        return E_FAIL;

    if (!CAssemblyList::SetDefaultTIPInAssembly(langid, catid, rclsid, NULL, guidProfile))
        return E_FAIL;

    if (IsEqualGUID(catid, GUID_TFCAT_TIP_KEYBOARD))
    {
        HKL hklSystem;
        if (!SystemParametersInfo( SPI_GETDEFAULTINPUTLANG,
                                   0,
                                   (LPVOID)((LPDWORD)&hklSystem),
                                   0 ))
        {
            hklSystem = NULL;
        }

        HKL hkl = NULL;
        HRESULT hr;
        hr = GetSubstituteKeyboardLayout(rclsid, langid, guidProfile, &hkl);
        if ((hr == S_OK) && 
            (LANGIDFROMHKL(hklSystem) == LANGIDFROMHKL(hkl)) && 
            IsPureIMEHKL(hkl))
        {
            SetSystemDefaultHKL(hkl);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetLanguageProfileDescription
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetLanguageProfileDescription(REFCLSID clsid, 
                                                              LANGID langid,
                                                              REFGUID guidProfile,
                                                              BSTR *pbstr)
{
    CMyRegKey keyTmp;
    CRegKeyMUI key;
    char szTmp[256];
    UINT uTmpSize ;
    WCHAR  szProfile[MAX_PATH];

    if (!pbstr)
       return E_INVALIDARG;

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(clsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    uTmpSize = lstrlen(szTmp);
    StringCchPrintf(szTmp + uTmpSize, ARRAYSIZE(szTmp)-uTmpSize,"0x%08x", langid);

    if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
    {
        //
        // Check a neutral language id.
        //
        StringCchPrintf(szTmp + uTmpSize, ARRAYSIZE(szTmp)-uTmpSize, "0x%08x", LOWORD(PRIMARYLANGID(langid)));

        if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
        {
            //
            // Check a neutral language id.
            //
            StringCchPrintf(szTmp + uTmpSize, ARRAYSIZE(szTmp)-uTmpSize, "0x0000ffff");

            if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
                return E_FAIL;
        }
    }

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Open(keyTmp, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    if (key.QueryMUIValueW(szProfile, c_szDescriptionW, c_szMUIDescriptionW, ARRAYSIZE(szProfile)) != S_OK)
        return E_FAIL;

    *pbstr = SysAllocString(szProfile);
    return *pbstr != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// EnableLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnableLanguageProfile(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    HRESULT hr;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    SYSTHREAD *psfn = GetSYSTHREAD();
    int nCnt;
    int i;

    if (psfn == NULL)
        return E_FAIL;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
         return E_FAIL;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
         return E_FAIL;

    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);
        if (IsEqualGUID(guidProfile, pItem->guidProfile))
        {
#if 0
            //
            // we can not dsable the active profile.
            //
            if (pItem->fActive)
                return E_FAIL;
#endif

            break;
        }
    }

    hr = EnableLanguageProfileForReg(rclsid, langid, guidProfile, fEnable);

    return hr;
}

//+---------------------------------------------------------------------------
//
// IsEnabledLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::IsEnabledLanguageProfile(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL *pfEnable)
{
    if (!pfEnable)
        return E_INVALIDARG;

    *pfEnable = IsEnabledLanguageProfileFromReg(rclsid, langid, guidProfile);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnalbeLanguageprofileByDefault
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnableLanguageProfileByDefault(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    CMyRegKey key;
    char szTmp[256];

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    if (key.SetValue((DWORD)(fEnable ? 1 : 0), c_szEnable) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SubstituteKeyboardLayout
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::SubstituteKeyboardLayout(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, HKL hKL)
{
    CMyRegKey key;
    char szTmp[256];

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    StringCchPrintf(szTmp, ARRAYSIZE(szTmp), "0x%08x", (DWORD)(ULONG_PTR)hKL);
    if (key.SetValue(szTmp, c_szSubstitutehKL) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CInputProcessorProfiles::GetSubstituteKeyboardLayout
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetSubstituteKeyboardLayout(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, HKL *phKL)
{
    CMyRegKey key;
    char szTmp[256];

    if (!phKL)
        return E_INVALIDARG;

    *phKL = NULL;

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    if (key.QueryValueCch(szTmp, c_szSubstitutehKL, ARRAYSIZE(szTmp)) != S_OK)
    {
        //
        // some tips do not have SubstituteLayout.
        //
        return S_FALSE;
    }

    HKL hkl = NULL;
    if ((szTmp[0] == '0') && ((szTmp[1] == 'X') || (szTmp[1] == 'x')))
        hkl = (HKL)IntToPtr(AsciiToNum(&szTmp[2]));

    *phKL = hkl;

    return hkl ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "mui.h"

extern void ReleaseDelayedLibs();

//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    CicEnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 1)
        goto Exit;

    fRet = TFInitLib_PrivateForCiceroOnly(Internal_CoCreateInstance);

Exit:
    CicLeaveCriticalSection(GetServerCritSec());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process detach, like
// FreeLibrary calls, COM Releases, or mutexing.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    CicEnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 0)
        goto Exit;

    TFUninitLib();
    ReleaseDelayedLibs();
    MuiFlushDlls(g_hInst);

Exit:
    CicLeaveCriticalSection(GetServerCritSec());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\imemenu.h ===
//
// imemenu.h
//

#ifndef TFEMENU_H
#define TFEMENU_H

typedef struct _tagMENULIST {
    struct _tagMENULIST * pPrev;
    struct _tagMENULIST * pNext;
    DWORD dwNum;
} MENULIST;
typedef MENULIST *PMENULIST;

typedef struct _tagMYMENUITEM {
    IMEMENUITEMINFO imii;
    int nMenuID;
    struct _tagMENULIST * pmlSubMenu;
} MYMENUITEM;
typedef MYMENUITEM *PMYMENUITEM;

class CWin32ImeMenu 
{
public:
    CWin32ImeMenu() {}
    ~CWin32ImeMenu()
    {
        DestroyIMEMenu();
    }

    BOOL GetIMEMenu(HWND hWnd, HIMC hIMC, BOOL fRight);
    BOOL BuildIMEMenu(HMENU hMenu, BOOL fRight);
    UINT GetIMEMenuItemID(int nMenuID);
    DWORD GetIMEMenuItemData(int nImeMenuID);

private:
    BOOL GetImeMenuProp();
    BOOL AddMenuList(PMENULIST pMenu);
    void DeleteMenuList(PMENULIST pMenu);
    void DeleteAllMenuList();
    PMENULIST AllocMenuList(DWORD dwNum);
    void SetMyMenuItem(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpIme, BOOL fRight, PMYMENUITEM pMyMenuItem);
    PMENULIST CreateImeMenu(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpImeParentMenu, BOOL fRight);
    void FillMenuItemInfo(LPMENUITEMINFO lpmii, PMYMENUITEM pMyMenuItem, BOOL fRight);
    int GetDefaultImeMenuItem();
    BOOL BuildIMEMenuItems(HMENU hMenu, PMENULIST pMenu, BOOL fRight);
    void DestroyIMEMenu();

    PMENULIST _pMenuHdr;       // Header of pMenuList
    int _nMenuList;            // number of pMenuList
    int _nMenuCnt;             // Sequence Number for TFE Menu Items
};

#endif // TFEMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\internat.h ===
//
// internat.h
//

#ifndef INTERNAT_H
#define INTERNAT_H

#include "private.h"
#include "commctrl.h"
#include "regsvr.h"
#include "inatlib.h"
#include "cregkey.h"

void UninitINAT();

//-----------------------------------------------------------------------------
//
// INTERNAT Icon APIs
//
//-----------------------------------------------------------------------------

//
//  For Keyboard Layout info. NT4
//
typedef struct
{
    DWORD dwID;                     // numeric id
    UINT iSpecialID;                // i.e. 0xf001 for dvorak etc
    WCHAR wszText[64];

} LAYOUT, *LPLAYOUT;

typedef struct 
{
    UINT idx ;
    char chars[4];
} INATSYMBOL;


int GetLocaleInfoString(LCID lcid, LCTYPE lcType, char *psz, int cch);
ULONG GetLocaleInfoString(HKL hKL, WCHAR *pszRegText, int nSize);
int GetHKLDesctription(HKL hKL, WCHAR *pszDesc, int cchDesc, WCHAR *pszIMEFile, int cchIMEFile);
HICON InatCreateIcon(WORD langID );
HICON InatCreateIconBySize(WORD langID, int cxSmIcon, int cySmIcon, LOGFONT *plf);
HICON GetIconFromFile(int cx, int cy, WCHAR *lpszFileName, UINT uIconIndex);
HICON GetIconFromFileA(int cx, int cy, char *lpszFileName, UINT uIconIndex);

//-----------------------------------------------------------------------------
//
// MLNGINFO APIs
//
//-----------------------------------------------------------------------------

typedef struct
{
    HKL         hKL;
    BOOL        fInitDesc;
    BOOL        fInitIcon;

    void SetDesc(WCHAR *psz)
    {
        StringCchCopyW(szDesc, ARRAYSIZE(szDesc), psz);
    }

    WCHAR *GetDesc()
    {
        if (!fInitDesc)
            InitDesc();

        return szDesc;
    }

    int GetIconIndex()
    {
        if (!fInitIcon)
            InitIcon();

        return nIconIndex;
    }

    void ClearIconIndex()
    {
        fInitIcon = FALSE;
        nIconIndex = -1;
    }

    void InitDesc();
    void InitIcon();

private:
    int      nIconIndex;
    WCHAR    szDesc[128];
} MLNGINFO;

HIMAGELIST GetMlngImageList();
BOOL GetMlngInfo(int n, MLNGINFO *pmlInfo);
int GetMlngInfoByhKL(HKL hKL, MLNGINFO *pmlInfo);
void ClearMlngIconIndex();

//-----------------------------------------------------------------------------
//
// IconList APIs
//
//-----------------------------------------------------------------------------

BOOL EnsureIconImageList();
UINT InatAddIcon(HICON hIcon);
BOOL InatGetIconSize(int *pcx, int *pcy);
BOOL InatGetImageCount();
void InatRemoveAll();


//-----------------------------------------------------------------------------
//
// HKLAPIs
//
//-----------------------------------------------------------------------------

HKL GetSystemDefaultHKL();
BOOL SetSystemDefaultHKL(HKL hKL);
UINT GetPreloadListForNT(DWORD *pdw, UINT uBufSize);
DWORD GetSubstitute(HKL hKL);

#ifdef LATER_TO_CHECK_DUMMYHKL
void RemoveFEDummyHKLFromPreloadReg(HKL hkl, BOOL fDefaultUser);
void RemoveFEDummyHKLs();
#endif LATER_TO_CHECK_DUMMYHKL


/////////////////////////////////////////////////////////////////////////////
// 
// CRegUIName
// 
/////////////////////////////////////////////////////////////////////////////

class CRegKeyMUI : public CMyRegKey
{
public:
    LONG QueryValueCch(LPTSTR szValue, LPCTSTR lpszValueName, ULONG cchValue)
    {
        LONG lRes;
        LPTSTR lpValue;
        DWORD index;
        WCHAR szTmpW[MAX_PATH];

        lRes = CMyRegKey::QueryValueCch(szValue, lpszValueName, cchValue);

        if (lRes != S_OK || szValue[0] != '@')
            return lRes;

        lpValue = szValue;
        index = 0;

        while (*lpValue != '\0' && index < cchValue)
        {
            if (*lpValue == ',')
            {
                lRes = SHLoadRegUIStringW(m_hKey, AtoW(lpszValueName), szTmpW, ARRAYSIZE(szTmpW));
                StringCchCopy(szValue, cchValue, WtoA(szTmpW, ARRAYSIZE(szTmpW)));
                break;
            }

            lpValue++;
            index++;
        }

        return lRes;
    }

    LONG QueryValueCchW(WCHAR *szValue, const WCHAR *lpszValueName, ULONG cchValue)
    {
        LONG lRes;
        LPWSTR lpValue;
        DWORD index;

        lRes = CMyRegKey::QueryValueCchW(szValue, lpszValueName, cchValue);

        if (lRes != S_OK || szValue[0] != L'@')
            return lRes;
        
        lpValue = szValue;
        index = 0;

        while (*lpValue && index < cchValue)
        {
            if (*lpValue == L',')
            {
                lRes = SHLoadRegUIStringW(m_hKey, lpszValueName, szValue, cchValue);
                break;
            }

            lpValue++;
            index++;
        }

        return lRes;
    }

    LONG QueryMUIValueW(WCHAR *szValue, const WCHAR *lpszValueName, const WCHAR *lpszMUIName, ULONG cchValue)
    {
        LONG lRes;

        lRes = SHLoadRegUIStringW(m_hKey, lpszMUIName, szValue, cchValue);

        if (lRes == S_OK)
        {
            return lRes;
        }
        else
        {
            return CMyRegKey::QueryValueCchW(szValue, lpszValueName, cchValue);
        }
    }
};


#endif //  INTERNAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\ithdmshl.cpp ===
//
// ithdmshl.cpp
//
#include "private.h"
#include "globals.h"
#include "tim.h"
#include "immxutil.h"
#include "nuihkl.h"
#include "nuictrl.h"
#include "cicmutex.h"
#include "ithdmshl.h"
#include "marshal.h"
#include "mproxy.h"
#include "thdutil.h"

LRESULT MyMarshalInterface(REFIID riid, BOOL fSameThread, LPUNKNOWN punk);
HRESULT MyUnmarshalInterface(LRESULT ref, REFIID riid, BOOL fSameThread, void **ppvObject);

#define SZTHREADMIEVENT  __TEXT("CTF.ThreadMarshalInterfaceEvent.%08X.%08X.%08X")
#define SZTHREADMICEVENT  __TEXT("CTF.ThreadMIConnectionEvent.%08X.%08X.%08X")

#define MITYPE_LANGBARITEMMGR    1
#define MITYPE_TMQI              2

extern CCicMutex g_mutexTMD;

// --------------------------------------------------------------------------
//
//  GetTIMInterfaceFromTYPE
//
// --------------------------------------------------------------------------

HRESULT GetTIMInrterfaceFromTYPE(DWORD dwType, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    CThreadInputMgr *ptim;

    switch (dwType)
    {
        case MITYPE_LANGBARITEMMGR:
            hr = TF_CreateLangBarItemMgr((ITfLangBarItemMgr **)ppv);
            break;

        case MITYPE_TMQI:
            if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
                break;

            hr = ptim->QueryInterface(riid, ppv);
            break;
    }

    return hr;
}

// --------------------------------------------------------------------------
//
//  FindTmd
//
// --------------------------------------------------------------------------

int FindTmd()
{
    int nId;
    BOOL fFound = FALSE;

    if (g_mutexTMD.Enter())
    {
        for (nId = 0; nId < NUM_TMD; nId++)
        {
            if (!(GetSharedMemory()->tmd[nId].m_fInUse))
            {
                GetSharedMemory()->tmd[nId].m_fInUse = TRUE;
                fFound = TRUE;
                break;
            }
        }
        Assert(fFound);
        g_mutexTMD.Leave();
    }

    return fFound ? nId : -1;
}

// --------------------------------------------------------------------------
//
//  GetThreadMarshallInterface()
//
// --------------------------------------------------------------------------

HRESULT GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk)
{
    DWORD dwCurThreadId  = GetCurrentThreadId();
    HRESULT hr = E_FAIL;
    int nId = -1;
    CCicEvent event;
    CCicEvent eventc;
    SYSTHREAD *psfn;
    ULONG ulMshlCnt;
    CThreadMarshalWnd tmw;
    BOOL fSendReceiveConnection = FALSE;
    CCicSecAttr sa;

    *ppunk = NULL;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return E_FAIL;

    CModalLoop modalloop(psfn);

    ulMshlCnt = psfn->ulMshlCnt++;

    if (!EnsureMarshalWnd())
        return E_FAIL;

    if (dwCurThreadId == dwThreadId)
    {
        return GetTIMInrterfaceFromTYPE(dwType, riid, (void **)ppunk);
    }

    nId = FindTmd();
    if (nId == -1)
        goto Exit;

    wsprintf(GetSharedMemory()->tmd[nId].m_szName, SZTHREADMIEVENT, dwCurThreadId, nId, ulMshlCnt);
    wsprintf(GetSharedMemory()->tmd[nId].m_szNameConnection, SZTHREADMICEVENT, dwCurThreadId, nId, ulMshlCnt);

    GetSharedMemory()->tmd[nId].m_iid = riid;
    GetSharedMemory()->tmd[nId].m_dwThreadId = dwThreadId;
    GetSharedMemory()->tmd[nId].m_dwSrcThreadId = dwCurThreadId;
    GetSharedMemory()->tmd[nId].m_dwType = dwType;
    GetSharedMemory()->tmd[nId].m_ref = E_FAIL;

    tmw.Init(dwThreadId);

    if (!event.Create(sa, GetSharedMemory()->tmd[nId].m_szName))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!eventc.Create(sa, GetSharedMemory()->tmd[nId].m_szNameConnection))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!tmw.PostMarshalThreadMessage(g_msgThreadMarshal, 
                                      MP_MARSHALINTERFACE, 
                                      (LPARAM)nId))
    {
        GetSharedMemory()->tmd[nId].m_ref = E_FAIL;
        goto SkipWaiting;
    }

    if (GetSharedMemory()->tmd[nId].m_fInUse)
    {
        CCicTimer timer(10000);
        DWORD dwWaitFlags = QS_DEFAULTWAITFLAG;
        while (!timer.IsTimerAtZero())
        {
            if (!fSendReceiveConnection &&
                 timer.IsTimerPass(DEFAULTMARSHALCONNECTIONTIMEOUT))
            { 
                DWORD dwReason = eventc.EventCheck();
                if (dwReason != WAIT_OBJECT_0)
                {
                    hr = E_FAIL;
                    break;
                }
                fSendReceiveConnection = TRUE;
            }

            hr = modalloop.BlockFn(&event, dwThreadId, dwWaitFlags);
       
            if (hr == S_OK)
                goto SkipWaiting;

            if (FAILED(hr))
                break;
        }

        TraceMsg(TF_GENERAL, "ThreadMarshal Time Out");
        goto Exit;
    }

SkipWaiting:
    if (FAILED(GetSharedMemory()->tmd[nId].m_ref))
        goto Exit;

    hr = CicCoUnmarshalInterface(GetSharedMemory()->tmd[nId].m_iid, 
                                 dwThreadId, 
                                 GetSharedMemory()->tmd[nId].m_ulStubId, 
                                 GetSharedMemory()->tmd[nId].m_dwStubTime, 
                                 (void **)ppunk);

Exit:
    if (nId != -1)
        GetSharedMemory()->tmd[nId].m_fInUse = FALSE;

    return hr;
}


// --------------------------------------------------------------------------
//
//  ThreadMarshallInterfaceHandler()
//
// --------------------------------------------------------------------------

HRESULT ThreadMarshalInterfaceHandler(int nId)
{
    HRESULT hr;
    IUnknown *punk;

    if ((nId < 0) || (nId >= NUM_TMD))
        return E_FAIL;

    CCicEvent eventc;
    if (eventc.Open(GetSharedMemory()->tmd[nId].m_szNameConnection))
        eventc.Set();

    EnsureMarshalWnd();

    hr = GetTIMInrterfaceFromTYPE(GetSharedMemory()->tmd[nId].m_dwType, 
                                  GetSharedMemory()->tmd[nId].m_iid, (void **)&punk);
    if (FAILED(hr))
        goto Exit;

    hr = CicCoMarshalInterface(GetSharedMemory()->tmd[nId].m_iid, 
                               punk, 
                               &GetSharedMemory()->tmd[nId].m_ulStubId, 
                               &GetSharedMemory()->tmd[nId].m_dwStubTime,
                               GetSharedMemory()->tmd[nId].m_dwSrcThreadId);

    GetSharedMemory()->tmd[nId].m_ref = hr;

    punk->Release();
 
Exit:
    CCicEvent event;
    if (event.Open(GetSharedMemory()->tmd[nId].m_szName))
        event.Set();

    return hr;
}

// --------------------------------------------------------------------------
//
//  GetThreadUIManager
//
// --------------------------------------------------------------------------

HRESULT GetThreadUIManager(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId)
{
    if (!dwThreadId)
        dwThreadId = GetSharedMemory()->dwFocusThread;

    if (pdwThreadId)
        *pdwThreadId = dwThreadId;

    return GetThreadMarshalInterface(dwThreadId, 
                                        MITYPE_LANGBARITEMMGR, 
                                        IID_ITfLangBarItemMgr,
                                        (IUnknown **)pplbi);
}

// --------------------------------------------------------------------------
//
//  GetActivateInputProcessor
//
// --------------------------------------------------------------------------

HRESULT GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId)
{
    if (!dwThreadId)
        dwThreadId = GetSharedMemory()->dwFocusThread;

    if (pdwThreadId)
        *pdwThreadId = dwThreadId;

    return GetThreadMarshalInterface(dwThreadId, 
                                        MITYPE_TMQI, 
                                        IID_ITfInputProcessorProfiles,
                                        (IUnknown **)ppaip);
}

// --------------------------------------------------------------------------
//
//  ThreadUnMarshallInterfaceErrorHandler()
//
// --------------------------------------------------------------------------

HRESULT ThreadUnMarshalInterfaceErrorHandler(int nId)
{
    HRESULT hr;
    IUnknown *punk;

    hr = CicCoUnmarshalInterface(GetSharedMemory()->tmd[nId].m_iid, 
                                 GetSharedMemory()->tmd[nId].m_dwThreadId, 
                                 GetSharedMemory()->tmd[nId].m_ulStubId, 
                                 GetSharedMemory()->tmd[nId].m_dwStubTime, 
                                 (void **)&punk);
    if (SUCCEEDED(hr))
         punk->Release();
 
    GetSharedMemory()->tmd[nId].m_fInUse = FALSE;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\internat.cpp ===
#include "private.h"
#include "globals.h"
#include "internat.h"
#include "strary.h"
#include "xstring.h"
#include "immxutil.h"
#include "cregkey.h"
#include "cmydc.h"
#include "assembly.h"

CStructArray<MLNGINFO> *g_pMlngInfo = NULL;


const TCHAR c_szDefaultUserPreload[] = TEXT(".DEFAULT\\Keyboard Layout\\Preload");
const TCHAR c_szPreload[] = TEXT("Keyboard Layout\\Preload");
const TCHAR c_szSubst[] = TEXT("Keyboard Layout\\Substitutes");

//////////////////////////////////////////////////////////////////////////////
//
// CStaticIconList
//
//////////////////////////////////////////////////////////////////////////////

class CStaticIconList
{
public:
    void Init(int cx, int cy);
    void RemoveAll(BOOL fInUninit);

    BOOL IsInited()
    {
        return _cx != 0;
    }

    int AddIcon(HICON hicon);
    HICON ExtractIcon(int i);
    void GetIconSize(int *cx, int *cy);
    int GetImageCount();

private:
    static int _cx;
    static int _cy;
    static CStructArray<HICON> *_prgIcons;
};

CStaticIconList g_IconList;
int CStaticIconList::_cx = 0;
int CStaticIconList::_cy = 0;
CStructArray<HICON> *CStaticIconList::_prgIcons = NULL;


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

inline void CStaticIconList::Init(int cx, int cy)
{
    CicEnterCriticalSection(g_cs);
    _cx = cx;
    _cy = cy;
    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// RemoveAll
//
//----------------------------------------------------------------------------

void CStaticIconList::RemoveAll(BOOL fInUninit)
{
    int i;

    //
    // don't have to enter g_cs if we're in DllMain(PROCESS_DETATCH).
    //
    if (!fInUninit)
        CicEnterCriticalSection(g_cs);

    if (_prgIcons == NULL)
        goto Exit;

    for (i=0; i<_prgIcons->Count(); i++)
    {
        DestroyIcon(*_prgIcons->GetPtr(i));
    }

    delete _prgIcons;
    _prgIcons = NULL;

Exit:
    if (!fInUninit)
        CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// AddIcon
//
//----------------------------------------------------------------------------

inline int CStaticIconList::AddIcon(HICON hicon)
{
    HICON hIconCopy;
    HICON *pIconDst;
    int nRet = -1;

    CicEnterCriticalSection(g_cs);

    if (!_prgIcons)
        _prgIcons = new CStructArray<HICON>;

    if (!_prgIcons)
        goto Exit;

    if ((pIconDst = _prgIcons->Append(1)) == NULL)
        goto Exit;

    if ((hIconCopy = CopyIcon(hicon)) == 0)
    {
        _prgIcons->Remove(_prgIcons->Count()-1, 1);
        goto Exit;
    }

    *pIconDst = hIconCopy;

    nRet = _prgIcons->Count()-1;

Exit:
    CicLeaveCriticalSection(g_cs);

    return nRet;
}

//+---------------------------------------------------------------------------
//
// ExtractIcon
//
//----------------------------------------------------------------------------

inline HICON CStaticIconList::ExtractIcon(int i)
{
    HICON hIcon = NULL;

    CicEnterCriticalSection(g_cs);

    if (!_prgIcons)
        goto Exit;

    if (i >= _prgIcons->Count() || i < 0)
        goto Exit;

    hIcon =  CopyIcon(*_prgIcons->GetPtr(i));
Exit:
    CicLeaveCriticalSection(g_cs);

    return hIcon;
}

//+---------------------------------------------------------------------------
//
// GetIconSize
//
//----------------------------------------------------------------------------

inline void CStaticIconList::GetIconSize(int *cx, int *cy)
{
    CicEnterCriticalSection(g_cs);
    *cx = _cx;
    *cy = _cy;
    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// GetImageCount
//
//----------------------------------------------------------------------------

inline int CStaticIconList::GetImageCount()
{
    int nRet = 0;

    CicEnterCriticalSection(g_cs);

    if (_prgIcons == NULL)
        goto Exit;

    nRet =  _prgIcons->Count();

Exit:
    CicLeaveCriticalSection(g_cs);

    return nRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// UninitINAT
//
//////////////////////////////////////////////////////////////////////////////
    
void UninitINAT()
{
    g_IconList.RemoveAll(TRUE);

    if (g_pMlngInfo)
    {
        delete g_pMlngInfo;
        g_pMlngInfo = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// InterNAT icon APIs
//
//////////////////////////////////////////////////////////////////////////////

#if 0
//
// ISO 639:1988 Code.
//
//
// Under NT, we use GetLocaleInfoNTString(). It returns ISO 3166.
//
INATSYMBOL symInatSymbols[] = 
{
    {0x0436, "AF"},     // Afrikaans
    {0x041c, "SQ"},     // Albanian
    {0x0401, "AR"},     // Arabic
    {0x042d, "EU"},     // Basque
    {0x0423, "BE"},     // Byelorus
    {0x0402, "BG"},     // Bulgaria
    {0x0403, "CA"},     // Catalan
    {0x0404, "CH"},     // China #1
    {0x0804, "CH"},     // China #2
//#ifdef WINDOWS_PE
#if 1
    {0x041a, "HR"},     // Croatian
#else
    {0x041a, "SH"},     // Croatian
#endif
    {0x0405, "CZ"},     // Czech
    {0x0406, "DA"},     // Danish
    {0x0413, "NL"},     // Dutch
    {0x0813, "NL"},     // Dutch
    {0x0409, "EN"},     // English
    {0x0809, "EN"},     // English
    {0x0c09, "EN"},     // English
    {0x1009, "EN"},     // English
    {0x1409, "EN"},     // English
    {0x1809, "EN"},     // English
    {0x0425, "ET"},     // Estonian
    {0x0429, "FA"},     // Farsi
    {0x040b, "FI"},     // Finnish
    {0x040c, "FR"},     // French
    {0x080c, "FR"},     // French
    {0x0c0c, "FR"},     // French
    {0x0407, "DE"},     // German
    {0x0807, "DE"},     // German
    {0x0c07, "DE"},     // German
    {0x1007, "DE"},     // German
    {0x1407, "DE"},     // German
    {0x0408, "GR"},     // Greek
    {0x040d, "HE"},     // Hebrew
    {0x040e, "HU"},     // Hungary
    {0x040f, "IS"},     // Iceland
    {0x0421, "BA"},     // Indonesia
    {0x0410, "IT"},     // Italy
    {0x0810, "IT"},     // Italy
    {0x0411, "JA"},     // Japan
    {0x0412, "KO"},     // Korea
    {0x0426, "LV"},     // Latvian
    {0x0427, "LT"},     // Lithuanian
    {0x042f, "MK"},     // Former Yugoslav Republic of Macedonia
    {0x0414, "NO"},     // Norway
    {0x0814, "NO"},     // Norway
    {0x0415, "PL"},     // Poland
    {0x0416, "PT"},     // Portugal
    {0x0816, "PT"},     // Portugal
    {0x0417, "RM"},     // Rhaeto
    {0x0418, "RO"},     // Romanian
    {0x0818, "RO"},     // Romanian
    {0x0419, "RU"},     // Russian
    {0x0819, "RU"},     // Russian
    {0x081a, "SR"},     // Serbian
//#ifdef WINDOWS_PE
#if 1
    {0x0c1a, "SR"},     // Serbian
#endif
    {0x041b, "SK"},     // Slovakian
    {0x0424, "SL"},     // Slovenian
    {0x042e, "SB"},     // Sorbian
    {0x040a, "ES"},     // Spanish
    {0x080a, "ES"},     // Spanish
    {0x0c0a, "ES"},     // Spanish
    {0x041d, "SV"},     // Swedish
    {0x041e, "TH"},     // Thai
    {0x041f, "TR"},     // Turkish
    {0x0422, "UK"},     // Ukranian
    {0x0420, "UR"},     // Urdu
    {0x0033, "VE"},     // Venda
    {0x042a, "VN"},     // Vietnamese
    {0x0034, "XH"},     // Xhosa
    {0x0035, "ZU"},     // Zulu
    {0x002b, "ST"},     // Sutu
    {0x002e, "TS"},     // Tsona
    {0x002f, "TN"},     // Tswana
    {0x0000, "??"}
} ;

#define NSYMBOLS ((sizeof(symInatSymbols) / sizeof(INATSYMBOL))-1)
#endif

static const TCHAR c_szLayoutPath[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts");
static const TCHAR c_szLayoutText[] = TEXT("layout text");
static const TCHAR c_szLayoutID[]   = TEXT("layout id");

static const WCHAR c_szMUILayoutTextW[] = L"Layout Display Name";
static const WCHAR c_szLayoutTextW[] = L"layout text";

static const char c_szNamesPath[] = "system\\currentcontrolset\\control\\nls\\Locale";


//+---------------------------------------------------------------------------
//
// GetLocaleInfoString
//
// this is not a general wrapper for GetLocaleInfo!  
// LCTYPE must be LOCALE_SABBREVLANGNAME or LOCALE_SLANGUAGE.
//
//----------------------------------------------------------------------------

int GetLocaleInfoString(LCID lcid, LCTYPE lcType, char *psz, int cch)
{
    WCHAR achW[64];

    Assert((lcType & LOCALE_SLANGUAGE) || (lcType & LOCALE_SABBREVLANGNAME));

    if (IsOnNT())
    {
        if (GetLocaleInfoW(lcid, lcType, achW, ARRAYSIZE(achW)))
        {
            return WideCharToMultiByte(CP_ACP, 0, achW, -1, psz, cch, NULL, NULL);
        }
    }
    else
    {
        return GetLocaleInfo(lcid, lcType, psz, cch);
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
// InatCreateIcon
//
//+---------------------------------------------------------------------------

HICON InatCreateIcon(WORD langID)
{
    LOGFONT  lf;
    UINT cxSmIcon;
    UINT cySmIcon;

    cxSmIcon = GetSystemMetrics( SM_CXSMICON );
    cySmIcon = GetSystemMetrics( SM_CYSMICON );

    if( !SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
        return NULL;

    if (cySmIcon < GetPhysicalFontHeight(lf))
    {
        lf.lfHeight = 0 - ((int)cySmIcon * 7 / 10);
        lf.lfWidth = 0;
    }

    return InatCreateIconBySize(langID, cxSmIcon, cySmIcon, &lf);
}


//+---------------------------------------------------------------------------
//
// InatCreateIconBySize
//
//+---------------------------------------------------------------------------

HICON InatCreateIconBySize(WORD langID, int cxSmIcon, int cySmIcon, LOGFONT *plf)
{
    HBITMAP  hbmColour;
    HBITMAP  hbmMono;
    HBITMAP  hbmOld;
    HICON    hicon = NULL;
    ICONINFO ii;
    RECT     rc;
    DWORD    rgbText;
    DWORD    rgbBk = 0;
    HDC      hdc;
    HDC      hdcScreen;
    HFONT    hfont;
    HFONT hfontOld;
    TCHAR szData[20];


    //
    //  Get the indicator by using the first 2 characters of the
    //  abbreviated language name.
    //
    if (GetLocaleInfoString( MAKELCID(langID, SORT_DEFAULT),
                       LOCALE_SABBREVLANGNAME | LOCALE_NOUSEROVERRIDE,
                       szData,
                       sizeof(szData) / sizeof(TCHAR) ))
    {
        //
        //  Make Uppercase
        //
        if (!IsOnNT())
        {
            szData[0] -= 0x20;
            szData[1] -= 0x20;
        }
        //
        //  Only use the first two characters.
        //
        szData[2] = TEXT('\0');
    }
    else
    {
        //
        //  Id wasn't found.  Use question marks.
        //
        szData[0] = TEXT('?');
        szData[1] = TEXT('?');
        szData[2] = TEXT('\0');
    }

    if( (hfont = CreateFontIndirect(plf)) )
    {
        hdcScreen = GetDC(NULL);
        hdc       = CreateCompatibleDC(hdcScreen);
        hbmColour = CreateCompatibleBitmap(hdcScreen, cxSmIcon, cySmIcon);
        ReleaseDC( NULL, hdcScreen);
        if (hbmColour && hdc)
        {
            hbmMono = CreateBitmap(cxSmIcon, cySmIcon, 1, 1, NULL);
            if (hbmMono)
            {
                hbmOld    = (HBITMAP)SelectObject( hdc, hbmColour);
                rc.left   = 0;
                rc.top    = 0;
                rc.right  = cxSmIcon;
                rc.bottom = cySmIcon;
    
                rgbBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

                ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, "", 0, NULL);

                hfontOld = (HFONT)SelectObject( hdc, hfont);
                DrawText(hdc, 
                     szData,
                     2, 
                     &rc, 
                     DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject( hdc, hbmMono);
                PatBlt(hdc, 0, 0, cxSmIcon, cySmIcon, BLACKNESS);

                ii.fIcon    = TRUE;
                ii.xHotspot = 0;
                ii.yHotspot = 0;
                ii.hbmColor = hbmColour;
                ii.hbmMask  = hbmMono;
                hicon       = CreateIconIndirect(&ii);

                SelectObject(hdc, hbmOld);
                DeleteObject(hbmMono);
                SelectObject(hdc, hfontOld);
            }
        }
        DeleteObject(hbmColour);
        DeleteDC(hdc);
        DeleteObject(hfont);
    }

    return hicon;
}

//+---------------------------------------------------------------------------
//
// GetIconFromFile
//
//+---------------------------------------------------------------------------

HICON GetIconFromFile(int cx, int cy, WCHAR *lpszFileName, UINT uIconIndex)
{
    return GetIconFromFileA(cx, cy, WtoA(lpszFileName), uIconIndex);
}

//+---------------------------------------------------------------------------
//
// GetIconFromFileA
//
//+---------------------------------------------------------------------------

HICON GetIconFromFileA(int cx, int cy, char *lpszFileName, UINT uIconIndex)
{
    HICON hicon = NULL;

    if (cx > GetSystemMetrics(SM_CXSMICON))
    {
        ExtractIconEx(lpszFileName, uIconIndex, &hicon, NULL, 1);
    }
    else
    {
        ExtractIconEx(lpszFileName, uIconIndex, NULL, &hicon, 1);
    }

    return hicon;
}

//+---------------------------------------------------------------------------
//
// CLayoutsSharedMem
//
//+---------------------------------------------------------------------------

extern CCicMutex g_mutexLayouts;
extern char g_szLayoutsCache[];

class CLayoutsSharedMem : public CCicFileMappingStatic
{
public:
    void Init()
    {
        CCicFileMappingStatic::Init(g_szLayoutsCache, &g_mutexLayouts);
    }

    BOOL Start(UINT nNum)
    {
        BOOL fAlreadyExists;

        CCicSecAttr sa;
        if (Create(sa, sizeof(LAYOUT) * nNum, &fAlreadyExists) == NULL)
            return FALSE;

        return TRUE;
    }

    LAYOUT *GetPtr() { return (LAYOUT *)_pv; }
};

CLayoutsSharedMem g_smLayouts;

//+---------------------------------------------------------------------------
//
// UninitLayoutMappedFile();
//
//----------------------------------------------------------------------------

void UninitLayoutMappedFile()
{
    g_smLayouts.Uninit();
}

//+---------------------------------------------------------------------------
//
// LoadKeyboardLayouts
//
//----------------------------------------------------------------------------

BOOL LoadKeyboardLayouts()
{
    CMyRegKey key;
    DWORD dwIndex;
    BOOL bRet = FALSE;
    TCHAR szValue[MAX_PATH];           // language id (number)
    WCHAR szValueW[MAX_PATH];
    TCHAR szData[MAX_PATH];            // language name
    CStructArray<LAYOUT> *pLayouts = NULL;
    LAYOUT *pLayout;
    BOOL bLoadedLayout;

    pLayouts = new CStructArray<LAYOUT>;
    if (!pLayouts)
        return FALSE;

    //
    //  Now read all the locales from the registry.
    //
    if (key.Open(HKEY_LOCAL_MACHINE, c_szLayoutPath, KEY_READ) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    dwIndex = 0;
    szValue[0] = TEXT('\0');
    while (key.EnumKey(dwIndex, szValue, ARRAYSIZE(szValue)) == ERROR_SUCCESS)
    {
        CRegKeyMUI key1;

        pLayout = pLayouts->Append(1);
        if (!pLayout)
            goto Exit;

        pLayout->dwID = AsciiToNum(szValue);

        if (StringCchPrintf(szData, ARRAYSIZE(szData), "%s\\%s", c_szLayoutPath, szValue) != S_OK)
            goto Next;

        if (key1.Open(HKEY_LOCAL_MACHINE, szData, KEY_READ) == S_OK)
        {
            //
            //  Get the layout name.
            //
            szValue[0] = TEXT('\0');
            bLoadedLayout = FALSE;

            if (IsOnNT())
            {
                szValueW[0] = 0;

                if (key1.QueryValueCchW(szValueW,
                                     c_szMUILayoutTextW,
                                     ARRAYSIZE(szValueW)) == S_OK)
                {
                    bLoadedLayout = TRUE;
                }
                else if (key1.QueryValueCchW(szValueW,
                                          c_szLayoutTextW,
                                          ARRAYSIZE(szValueW)) == S_OK)
                {
                    bLoadedLayout = TRUE;
                }

                if (bLoadedLayout)
                {
                    wcsncpy(pLayout->wszText,
                            szValueW,
                            ARRAYSIZE(pLayout->wszText));
                }
            }
            else
            {
                if (key1.QueryValueCch(szValue,
                                    c_szLayoutText,
                                    ARRAYSIZE(szValue)) == S_OK)
                {
                    wcsncpy(pLayout->wszText,
                            AtoW(szValue),
                            ARRAYSIZE(pLayout->wszText));

                    bLoadedLayout = TRUE;
                }
            }

            if (bLoadedLayout)
            {
                szValue[0] = TEXT('\0');
                pLayout->iSpecialID = 0;

                if (key1.QueryValueCch(szValue,
                                    c_szLayoutID,
                                    ARRAYSIZE(szValue)) == S_OK)

                {
                    //
                    //  This may not exist!
                    //
                    pLayout->iSpecialID = (UINT)AsciiToNum(szValue);
                }
            }
        }
Next:
        dwIndex++;
        szValue[0] = TEXT('\0');
    } 

    pLayout = pLayouts->Append(1);
    if (!pLayout)
        goto Exit;

    memset(pLayout, 0, sizeof(LAYOUT));

    if (!g_smLayouts.Enter())
        goto Exit;

    g_smLayouts.Close();

    if (g_smLayouts.Start(pLayouts->Count()))
    {
        if (g_smLayouts.GetPtr())
        {
            memcpy(g_smLayouts.GetPtr(), 
                   pLayouts->GetPtr(0), 
                   pLayouts->Count() * sizeof(LAYOUT));
            bRet = TRUE;
        }
    }
    g_smLayouts.Leave();

Exit:

    if (pLayouts)
        delete pLayouts;

    return bRet;
}

//+---------------------------------------------------------------------------
//
//  FindLayoutEntry
//
//  Gets the name of the given layout.
//
//+---------------------------------------------------------------------------

UINT FindLayoutEntry( LAYOUT *pLayout, DWORD dwLayout )
{
    UINT ctr = 0;
    UINT id;
    WORD wLayout = HIWORD(dwLayout);
    BOOL bIsIME = ((HIWORD(dwLayout) & 0xf000) == 0xe000) ? TRUE : FALSE;

    //
    //  Find the layout in the global structure.
    //
    if ((wLayout & 0xf000) == 0xf000)
    {
        //
        //  Layout is special, need to search for the ID
        //  number.
        //
        id = wLayout & 0x0fff;
        ctr = 0;
        while (pLayout[ctr].dwID)
        {
            if (id == pLayout[ctr].iSpecialID)
            {
                break;
            }
            ctr++;
        }
    }
    else
    {
        ctr = 0;
        while (pLayout[ctr].dwID)
        {
            //
            // If it is IME, needs to be DWORD comparison.
            //
            if (IsOnFE() && bIsIME && (dwLayout == pLayout[ctr].dwID))
            {
                break;
            }
            else if (wLayout == LOWORD(pLayout[ctr].dwID))
            {
                break;
            }
            ctr++;
        }
    }

    return ctr;
}

//+---------------------------------------------------------------------------
//
//  GetKbdLayoutName
//
//  Gets the name of the given layout.
//
//+---------------------------------------------------------------------------

void GetKbdLayoutName( DWORD dwLayout, WCHAR *pBuffer, int nBufSize)
{
    UINT ctr;
    LAYOUT *pLayout;

    *pBuffer = L'\0';

    if (!g_smLayouts.Enter())
        return;

    g_smLayouts.Close();
    g_smLayouts.Init();
    if (!g_smLayouts.Open())
    {
        if (!LoadKeyboardLayouts())
        {
            Assert(0);
        }
    }

    pLayout = g_smLayouts.GetPtr();
    if (!pLayout)
        goto Exit;

    ctr = FindLayoutEntry( pLayout, dwLayout );

    //
    //  Make sure there is a match.  If not, then simply return without
    //  copying anything.
    //
    if (pLayout[ctr].dwID)
    {
        //
        //  Separate the Input Locale name and the Layout name with " - ".
        //
#ifdef ATTACH_LAYOUTNAME
        pBuffer[0] = L' ';
        pBuffer[1] = L'-';
        pBuffer[2] = L' ';

        wcsncpy(pBuffer + 3, pLayout[ctr].wszText, nBufSize - 3);
#else
        wcsncpy(pBuffer, pLayout[ctr].wszText, nBufSize);
#endif
    }

Exit:
    g_smLayouts.Leave();
}

//+---------------------------------------------------------------------------
//
//  GetKbdLayoutId
//
//  Gets the name of the given layout.
//
//+---------------------------------------------------------------------------

DWORD GetKbdLayoutId( DWORD dwLayout)
{
    UINT ctr;
    DWORD dwId = 0;
    LAYOUT *pLayout;

    if (!g_smLayouts.Enter())
        return 0;

    g_smLayouts.Close();
    g_smLayouts.Init();
    if (!g_smLayouts.Open())
        LoadKeyboardLayouts();

    pLayout = g_smLayouts.GetPtr();
    if (!pLayout)
        goto Exit;

    ctr = FindLayoutEntry( pLayout, dwLayout );

    //
    //  Make sure there is a match.  If not, then simply return without
    //  copying anything.
    //
    dwId = pLayout[ctr].dwID;

Exit:
    g_smLayouts.Leave();

    return dwId;
}

//+---------------------------------------------------------------------------
//
// GetLocaleInfoString
//
// this is not a general wrapper for GetLocaleInfo!  
// LCTYPE must be LOCALE_SABBREVLANGNAME or LOCALE_SLANGUAGE.
//
//----------------------------------------------------------------------------
ULONG GetLocaleInfoString(HKL hKL, WCHAR *pszRegText, int nSize)
{
    ULONG cb = 0;
    DWORD dwRegValue = (DWORD)((LONG_PTR)(hKL) & 0x0000FFFF);

    *pszRegText = L'\0';

    if (IsOnNT())
    {
        if (!GetLocaleInfoW(dwRegValue, LOCALE_SLANGUAGE, pszRegText, nSize))
        {
            *pszRegText = L'\0';
        }

        //
        //  Attach the Layout name if it's not the default.
        //
        if (HIWORD(hKL) != LOWORD(hKL))
        {
#ifdef ATTACH_LAYOUTNAME
            WCHAR *pszRT = pszRegText + wcslen(pszRegText);
            //
            // Pass DWORD value for IME.
            //
            GetKbdLayoutName((DWORD)(LONG_PTR)hKL, 
                              pszRT,
                              nSize - (DWORD)(pszRT - pszRegText));
#else
            GetKbdLayoutName((DWORD)(LONG_PTR)hKL, pszRegText, nSize);
#endif
        }

    }
    else
    {
        CMyRegKey key;
        char szRegKey[128];
        char szRegText[128];
        StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey),"%8.8lx", (DWORD)dwRegValue);

        *pszRegText = '\0';
        if(key.Open(HKEY_LOCAL_MACHINE,c_szNamesPath, KEY_READ)==ERROR_SUCCESS)
        {
            if(key.QueryValueCch(szRegText, szRegKey, ARRAYSIZE(szRegText)) == ERROR_SUCCESS)
            {
                DWORD dwLen = MultiByteToWideChar(CP_ACP, 
                                                  MB_ERR_INVALID_CHARS, 
                                                  szRegText, 
                                                  lstrlen(szRegText), 
                                                  pszRegText, 
                                                  nSize-1);
                pszRegText[dwLen] = L'\0';
            }
        }

    }

    return wcslen(pszRegText);
}

//+---------------------------------------------------------------------------
//
// GetHKLDescription
//
//
//----------------------------------------------------------------------------
int GetHKLDesctription(HKL hKL, WCHAR *pszDesc, int cchDesc, WCHAR *pszIMEFile, int cchIMEFile)
{
    DWORD dwIMEDesc = 0;

    if (IsIMEHKL(hKL))
    {
        HKEY hkey;
        DWORD dwIMELayout;
        TCHAR szIMELayout[MAX_PATH];
        TCHAR szIMELayoutPath[MAX_PATH];

        dwIMELayout = GetSubstitute(hKL);
        StringCchPrintf(szIMELayout, ARRAYSIZE(szIMELayout), "%8.8lx", dwIMELayout);

        StringCopyArray(szIMELayoutPath, c_szLayoutPath);
        StringCatArray(szIMELayoutPath, TEXT("\\"));
        StringCatArray(szIMELayoutPath, szIMELayout);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szIMELayoutPath, 0, KEY_READ, &hkey)
            == ERROR_SUCCESS)
        {
            if (SHLoadRegUIStringW(hkey,
                                   c_szMUILayoutTextW,
                                   pszDesc, cchDesc) == S_OK)
            {
                dwIMEDesc = wcslen(pszDesc);
            }
            RegCloseKey(hkey);
        }

        if (!dwIMEDesc)
        {
            dwIMEDesc = ImmGetDescriptionW(hKL,pszDesc,cchDesc);
            if (!dwIMEDesc)
                pszDesc[0] = L'\0';
        }
    }

    if (dwIMEDesc == 0)
    {
        GetLocaleInfoString(hKL, pszDesc, cchDesc);
        pszIMEFile[0] = L'\0';
    }
    else 
    {
        if (!ImmGetIMEFileNameW(hKL, pszIMEFile, cchIMEFile))
            pszIMEFile[0] = L'\0';
    }

    return wcslen(pszDesc);
}

//////////////////////////////////////////////////////////////////////////////
//
// MLNGINFO List
//
//////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
// MlngInfoCount()
//
//---------------------------------------------------------------------------
int WINAPI TF_MlngInfoCount()
{
    if (!g_pMlngInfo)
        return 0;

    return g_pMlngInfo->Count();
}

//---------------------------------------------------------------------------
//
// GetMlngInfo()
//
//---------------------------------------------------------------------------
BOOL GetMlngInfo(int n, MLNGINFO *pmlInfo)
{
    BOOL bRet = FALSE;
    MLNGINFO *pml;

    if (!g_pMlngInfo)
        return FALSE;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    if (n >= g_pMlngInfo->Count())
        goto Exit;

    pml = g_pMlngInfo->GetPtr(n);
    if (!pml)
        goto Exit;

    *pmlInfo = *pml;
    bRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);
    return bRet;
}

//---------------------------------------------------------------------------
//
// GetMlngInfoByhKL()
//
//---------------------------------------------------------------------------
int GetMlngInfoByhKL(HKL hKL, MLNGINFO *pmlInfo)
{
    int nRet = -1;
    MLNGINFO *pml;

    if (!g_pMlngInfo)
        return 0;

    CicEnterCriticalSection(g_cs);

    int nCnt = g_pMlngInfo->Count();
    int i; 

    for (i = 0; i < nCnt; i++)
    {
        pml = g_pMlngInfo->GetPtr(i);
        if (pml->hKL == hKL)
        {
            *pmlInfo = *pml;
            nRet = i;
            break;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return nRet;
}

//+---------------------------------------------------------------------------
//
// CheckMlngInfo
//
// return TRUE, if MlangInfo needs to be updated.
//
//----------------------------------------------------------------------------

BOOL CheckMlngInfo()
{
    int    iLangs;
    BOOL   bRet = FALSE;
    HKL    *pLanguages = NULL;

    if (!g_pMlngInfo)
        return TRUE;

    iLangs = GetKeyboardLayoutList((UINT)0, (HKL FAR *)NULL);

    if (iLangs != TF_MlngInfoCount())
        return TRUE;

    if (iLangs)
    {
        int i;
        pLanguages = (HKL *)cicMemAlloc(iLangs * sizeof(HKL));
        if (!pLanguages)
            goto Exit;

        GetKeyboardLayoutList(iLangs, (HKL FAR *)pLanguages);
        for (i = 0; i < iLangs; i++)
        {
            MLNGINFO *pMlngInfo =  g_pMlngInfo->GetPtr(i);
            if (pMlngInfo->hKL != pLanguages[i])
            {
                bRet = TRUE;
                goto Exit;
            }
        }
    }
Exit:
    if (pLanguages)
        cicMemFree(pLanguages);
    return bRet;
}

//---------------------------------------------------------------------------
//
// void DestroyMlngInfo()
//
//---------------------------------------------------------------------------

void DestroyMlngInfo()
{
    if (g_pMlngInfo)
    {
        while (g_pMlngInfo->Count())
        {
            g_pMlngInfo->Remove(0, 1);
        }
        delete g_pMlngInfo;
        g_pMlngInfo = NULL;
    }
}

//---------------------------------------------------------------------------
//
// void CreateMLlngInfo()
//
//---------------------------------------------------------------------------

void CreateMlngInfo()
{
    HKL         *pLanguages;
    UINT        uCount;
    UINT        uLangs;
    MLNGINFO    *pMlngInfo;
    BOOL        fNeedInd = FALSE;

    uLangs = GetKeyboardLayoutList((UINT)0, (HKL FAR *)NULL);

    if (!g_pMlngInfo)
        g_pMlngInfo = new CStructArray<MLNGINFO>;

    if (!g_pMlngInfo)
        return;

    if (!EnsureIconImageList())
    {
        return;
    }

    pLanguages = (HKL *)cicMemAllocClear(uLangs * sizeof(HKL));
    if (!pLanguages)
        return;

    GetKeyboardLayoutList(uLangs, (HKL FAR *)pLanguages);

    //
    // pLanguages contains all the HKLs in the system
    // Put everything together in the DPA and Image List
    //
    for (uCount = 0; uCount < uLangs; uCount++)
    {
        pMlngInfo = g_pMlngInfo->Append(1);
        if (pMlngInfo)
        {
            pMlngInfo->hKL = pLanguages[uCount];
            pMlngInfo->fInitIcon = FALSE;
            pMlngInfo->fInitDesc = FALSE;
        }

    }

    cicMemFree(pLanguages);
}

//---------------------------------------------------------------------------
//
// void InitDesc
//
//---------------------------------------------------------------------------

void MLNGINFO::InitDesc()
{
    MLNGINFO *pml;

    if (fInitDesc)
        return;

    WCHAR       szRegText[256];
    WCHAR       szIMEFile[256];

    GetHKLDesctription(hKL,
                       szRegText, ARRAYSIZE(szRegText),
                       szIMEFile, ARRAYSIZE(szIMEFile));

    fInitDesc = TRUE;
    SetDesc(szRegText);

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    int nCnt = g_pMlngInfo->Count();
    int i; 

    for (i = 0; i < nCnt; i++)
    {
        pml = g_pMlngInfo->GetPtr(i);
        if (pml->hKL == hKL)
        {
            pml->fInitDesc = TRUE;
            pml->SetDesc(szRegText);
            break;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return;
}

//---------------------------------------------------------------------------
//
// void InitIcon
//
//---------------------------------------------------------------------------

void MLNGINFO::InitIcon()
{
    HICON       hIcon;

    if (fInitIcon)
        return;

    WCHAR       szRegText[256];
    WCHAR       szIMEFile[256];

    GetHKLDesctription(hKL,
                       szRegText, ARRAYSIZE(szRegText),
                       szIMEFile, ARRAYSIZE(szIMEFile));

    fInitDesc = TRUE;
    SetDesc(szRegText);

    if (wcslen(szIMEFile))
    {
        int cx, cy;

        InatGetIconSize(&cx, &cy);
        if ((hIcon = GetIconFromFile(cx, cy, szIMEFile, 0)) == 0)
        {
            goto GetLangIcon;                
        }
    }
    else // for non-ime layout
    {
GetLangIcon:
        hIcon = InatCreateIcon(LOWORD((DWORD)(UINT_PTR)hKL));
    }

    if (hIcon)
    {
        nIconIndex = InatAddIcon(hIcon);
        DestroyIcon(hIcon);
    }

    MLNGINFO *pml;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    int nCnt = g_pMlngInfo->Count();
    int i; 

    for (i = 0; i < nCnt; i++)
    {
        pml = g_pMlngInfo->GetPtr(i);
        if (pml->hKL == hKL)
        {
            pml->fInitDesc = TRUE;
            pml->fInitIcon = TRUE;
            pml->nIconIndex = nIconIndex;
            pml->SetDesc(szRegText);
            break;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return;
}

//---------------------------------------------------------------------------
//
// void TF_InitMLlngInfo()
//
//---------------------------------------------------------------------------

void WINAPI TF_InitMlngInfo()
{
    CicEnterCriticalSection(g_cs);

    if (CheckMlngInfo())
    {
        DestroyMlngInfo();
        CreateMlngInfo();
    }

    CicLeaveCriticalSection(g_cs);
}

//---------------------------------------------------------------------------
//
// void TF_InitMLlngHKL()
//
//---------------------------------------------------------------------------

BOOL TF_GetMlngHKL(int nId, HKL *phkl, WCHAR *psz, UINT cch)
{
    BOOL bRet = FALSE;
    MLNGINFO *pml;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    if (nId >= g_pMlngInfo->Count())
        goto Exit;

    pml = g_pMlngInfo->GetPtr(nId);
    if (!pml)
        goto Exit;

    if (phkl)
        *phkl = pml->hKL;

    if (psz)
        wcsncpy(psz, pml->GetDesc(), cch);

    bRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);
    return bRet;
}

//---------------------------------------------------------------------------
//
// void TF_GetMlngIconIndex()
//
//---------------------------------------------------------------------------

UINT WINAPI TF_GetMlngIconIndex(int nId)
{
    UINT uIconIndex = (UINT)-1;
    MLNGINFO *pml;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    if (nId >= g_pMlngInfo->Count())
        goto Exit;

    pml = g_pMlngInfo->GetPtr(nId);
    if (!pml)
        goto Exit;

    uIconIndex = pml->GetIconIndex();

Exit:
    CicLeaveCriticalSection(g_cs);
    return uIconIndex;
}

//---------------------------------------------------------------------------
//
// void ClearMlngIconIndex()
//
//---------------------------------------------------------------------------

void ClearMlngIconIndex()
{
    int i;
    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    for (i = 0; i < g_pMlngInfo->Count(); i++)
    {
        MLNGINFO *pml;
        pml = g_pMlngInfo->GetPtr(i);
        if (!pml)
            goto Exit;

        pml->ClearIconIndex();
    }

Exit:
    CicLeaveCriticalSection(g_cs);
    return;
}

//////////////////////////////////////////////////////////////////////////////
//
// IconImageList
//
//////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
// EnsureIconImageList
//
//---------------------------------------------------------------------------

BOOL EnsureIconImageList()
{
    if (g_IconList.IsInited())
        return TRUE;

    g_IconList.Init(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON));

    return TRUE;
}

//---------------------------------------------------------------------------
//
// InatAddIcon
//
//---------------------------------------------------------------------------

UINT InatAddIcon(HICON hIcon)
{
    if (!EnsureIconImageList())
         return -1;

    return g_IconList.AddIcon(hIcon);
}

//---------------------------------------------------------------------------
//
// InatExtractIcon
//
//---------------------------------------------------------------------------

HICON WINAPI TF_InatExtractIcon(UINT uId)
{
    return g_IconList.ExtractIcon(uId);
}

//---------------------------------------------------------------------------
//
// InatGetIconSize
//
//---------------------------------------------------------------------------

BOOL InatGetIconSize(int *pcx, int *pcy)
{
    g_IconList.GetIconSize(pcx, pcy);
    return TRUE;
}

//---------------------------------------------------------------------------
//
// InatGetImageCount
//
//---------------------------------------------------------------------------

BOOL InatGetImageCount()
{
    return g_IconList.GetImageCount();
}

//---------------------------------------------------------------------------
//
// InatRemoveAll
//
//---------------------------------------------------------------------------

void InatRemoveAll()
{
    if (!g_IconList.IsInited())
         return;

    g_IconList.RemoveAll(FALSE);

    return;
}

//////////////////////////////////////////////////////////////////////////////
//
// HKL API
//
//////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// CPreloadRegKey
//
//-----------------------------------------------------------------------------

class CPreloadRegKey : public CMyRegKey
{
public:
    HRESULT Open(BOOL fDefaultUser = FALSE) 
    {
        if (fDefaultUser)
            return CMyRegKey::Open(HKEY_USERS, c_szDefaultUserPreload, KEY_ALL_ACCESS);
        else
            return CMyRegKey::Open(HKEY_CURRENT_USER, c_szPreload, KEY_ALL_ACCESS);
    }

    HKL Get(int n)
    {
        char szValue[16];
        char szValueName[16];
        StringCchPrintf(szValueName, ARRAYSIZE(szValueName), "%d", n);

        if (IsOnNT())
        {
            if (QueryValueCch(szValue, szValueName, ARRAYSIZE(szValue)) != S_OK)
                return NULL;
        }
        else
        {
            CMyRegKey keySub;
            if (keySub.Open(m_hKey, szValueName, KEY_READ) != S_OK)
                return NULL;

            if (keySub.QueryValueCch(szValue, NULL, ARRAYSIZE(szValue)) != S_OK)
                return NULL;
        }

        return (HKL)(LONG_PTR)AsciiToNum(szValue);
    }

    void Set(int n, HKL hkl)
    {
        char szValue[16];
        char szValueName[16];
        StringCchPrintf(szValueName, ARRAYSIZE(szValueName), "%d", n);
        NumToA((DWORD)(LONG_PTR)hkl, szValue);

        if (IsOnNT())
        {
            SetValue(szValue, szValueName);
        }
        else
        {
            CMyRegKey keySub;
            if (keySub.Open(m_hKey, szValueName, KEY_ALL_ACCESS) == S_OK)
                keySub.SetValue(szValue, (LPSTR)NULL);

        }
        return;
    }

    void Delete(int n)
    {
        char szValueName[16];
        StringCchPrintf(szValueName, ARRAYSIZE(szValueName), "%d", n);

        if (IsOnNT())
        {
            DeleteValue(szValueName);
        }
        else
        {
            DeleteSubKey(szValueName);

        }
        return;
    }
};


//+---------------------------------------------------------------------------
//
// GetSubstitute
//
//----------------------------------------------------------------------------

DWORD GetSubstitute(HKL hKL)
{
    CMyRegKey key;
    DWORD dwIndex = 0;
    TCHAR szValue[16];
    TCHAR szValueName[64];
    DWORD dwLayout = HandleToLong(hKL);

    //
    // it's IME.
    //
    if ((dwLayout & 0xf0000000) == 0xe0000000)
        return dwLayout;

    //
    // it's default layout.
    //
    if (HIWORD(dwLayout) == LOWORD(dwLayout))
        dwLayout &= 0x0000FFFF;
    else if ((dwLayout & 0xf0000000) == 0xf0000000)
        dwLayout = GetKbdLayoutId(dwLayout);

    if (key.Open(HKEY_CURRENT_USER, c_szSubst, KEY_READ) != S_OK)
        return dwLayout;

    if (IsOnNT())
    {
        while (key.EnumValue(dwIndex, szValueName, ARRAYSIZE(szValueName)) == S_OK)
        {
            if (key.QueryValueCch(szValue, szValueName, ARRAYSIZE(szValue)) == S_OK)
            {
                if ((dwLayout & 0x0FFFFFFF) == AsciiToNum(szValue))
                {
                    return AsciiToNum(szValueName);
                }
            }
            dwIndex++;
        }
    }
    else
    {
        while (key.EnumKey(dwIndex, szValueName, ARRAYSIZE(szValueName)) == S_OK)
        {
            CMyRegKey keySub;
            if (keySub.Open(key, szValueName, KEY_READ) == S_OK)
            {
                if (key.QueryValueCch(szValue, NULL, ARRAYSIZE(szValue)) == S_OK)
                {
                    if ((dwLayout & 0x0FFFFFFF) == AsciiToNum(szValue))
                    {
                        return AsciiToNum(szValueName);
                    }
                }
            }
            dwIndex++;
        }
    }

    return dwLayout;
}

//+---------------------------------------------------------------------------
//
// SetSystemDefaultHKL
//
//----------------------------------------------------------------------------

BOOL SetSystemDefaultHKL(HKL hkl)
{
    CPreloadRegKey key;
    int n;
    HKL hklFirst;
    BOOL bRet = FALSE;
    DWORD dwLayout;

    if (key.Open() != S_OK)
        return bRet;

    dwLayout = GetSubstitute(hkl);

    n = 1;
    while(1)
    {
        HKL hklCur;
        hklCur = key.Get(n);
        if (!hklCur)
            break;

        if (n == 1)
            hklFirst = hklCur;

        if (hklCur == LongToHandle(dwLayout))
        {
            bRet = TRUE;
            if (n != 1)
            {
                key.Set(n, hklFirst);
                key.Set(1, hklCur);

            }
            bRet = SystemParametersInfo( SPI_SETDEFAULTINPUTLANG,
                                         0,
                                         (LPVOID)((LPDWORD)&hkl),
                                         0 );

            Assert(bRet);
            break;
        }

        n++;
    }
 
    return bRet;
}

//+---------------------------------------------------------------------------
//
// GetPreloadListForNT()
//
//----------------------------------------------------------------------------

UINT GetPreloadListForNT(DWORD *pdw, UINT uBufSize)
{
    CMyRegKey key;
    CMyRegKey key1;
    char szValue[16];
    char szSubstValue[16];
    char szName[16];
    UINT uRet = 0;

    //
    // this function support only NT.
    // win9x has different formation for Preload registry. Each layout is key.
    //
    if (!IsOnNT())
        return 0;
 
    if (key.Open(HKEY_CURRENT_USER, c_szPreload, KEY_READ) != S_OK)
        return uRet;

    key1.Open(HKEY_CURRENT_USER, c_szSubst, KEY_READ);

    if (!pdw)
        uBufSize = 1000;

    while (uRet < uBufSize)
    {
        BOOL fUseSubst = FALSE;
        StringCchPrintf(szName, ARRAYSIZE(szName), "%d", uRet + 1);
        if (key.QueryValueCch(szValue, szName, ARRAYSIZE(szValue)) != S_OK)
            return uRet;

        if ((HKEY)key1)
        {
            if (key1.QueryValueCch(szSubstValue, szValue, ARRAYSIZE(szSubstValue)) == S_OK)
               fUseSubst = TRUE;

        }

        if (pdw)
        {
            *pdw = AsciiToNum(fUseSubst ? szSubstValue : szValue);
            pdw++;
        }

        uRet++;
    }

    return uRet;
}

#ifdef LATER_TO_CHECK_DUMMYHKL

//+---------------------------------------------------------------------------
//
// RemoveFEDummyHKLFromPreloadReg()
//
//----------------------------------------------------------------------------

void RemoveFEDummyHKLFromPreloadReg(HKL hkl, BOOL fDefaultUser)
{
    CPreloadRegKey key;
    BOOL fReset = FALSE;
    UINT uCount;
    UINT uMatch = 0;

    if (key.Open(fDefaultUser) != S_OK)
        return;

    uCount = 1;

    while(uCount < 1000)
    {
        HKL hklCur;
        hklCur = key.Get(uCount);
        if (!hklCur)
            break;

        if (hklCur == hkl)
        {
            uMatch++;
            uCount++;
            fReset = TRUE;
            continue;
        }

        if (fReset && uMatch)
        {
            if (uCount <= uMatch)
            {
                Assert(0);
                return;
            }

            //
            // reset the hkl orders from preload section
            //
            key.Set(uCount-uMatch, hklCur);
        }

        uCount++;
    }

    while (fReset && uMatch && uCount)
    {
        if  (uCount <= uMatch || (uCount - uMatch) <= 1)
        {
            Assert(0);
            return;
        }

        //
        // remove the dummy hkl from preload section
        //
        key.Delete(uCount - uMatch);

        uMatch--;
    }

    return;
}

//+---------------------------------------------------------------------------
//
// RemoveFEDummyHKLs
//
// This function cleans up the FE Dummy HKLs that were added on Win9x.
// This is called during update setup to Whistler.
//
//----------------------------------------------------------------------------

void RemoveFEDummyHKLs()
{
    CMyRegKey key;
    DWORD dwIndex;
    TCHAR szValue[MAX_PATH]; 

    //
    //  Now read all the locales from the registry.
    //
    if (key.Open(HKEY_LOCAL_MACHINE, c_szLayoutPath) != ERROR_SUCCESS)
    {
        return;
    }

    dwIndex = 0;
    szValue[0] = TEXT('\0');
    while (key.EnumKey(dwIndex, szValue, ARRAYSIZE(szValue)) == ERROR_SUCCESS)
    {
        BOOL fDelete = FALSE;
        CRegKeyMUI key1;

        if ((szValue[0] != 'e') && (szValue[0] != 'E'))
            goto Next;

        if (key1.Open(key, szValue) == S_OK)
        {
            TCHAR szValueLayoutText[MAX_PATH];

            //
            //  Get the layout text.
            //
            szValueLayoutText[0] = TEXT('\0');

            if (key1.QueryValueCch(szValueLayoutText, c_szLayoutText, ARRAYSIZE(szValueLayoutText)) == S_OK)
            {
                char szDummyProfile[256];
                DWORD dw = AsciiToNum(szValue);
                StringCchPrintf(szDummyProfile, ARRAYSIZE(szDummyProfile), "hkl%04x", LOWORD(dw));
                if (!lstrcmpi(szDummyProfile, szValueLayoutText))
                {
                    fDelete = TRUE;

                    //
                    // Remove dummy HKL from Preload of HKCU and HKU\.DEFAULT.
                    // We may need to enum all users in HKU\.DEFAULT. 
                    //
                    RemoveFEDummyHKLFromPreloadReg((HKL)LongToHandle(dw), TRUE);
                    RemoveFEDummyHKLFromPreloadReg((HKL)LongToHandle(dw), FALSE);
                }
            }

            key1.Close();
        }

        if (fDelete)
        {
            key.RecurseDeleteKey(szValue);
        }
        else
        {
Next:
            dwIndex++;
        }

        szValue[0] = TEXT('\0');
    } 

    return;
}

#endif LATER_TO_CHECK_DUMMYHKL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\imemenu.cpp ===
//------------------------------------------------------------------------
//
// imemenu.cpp
//
//------------------------------------------------------------------------

#include "private.h"
#include "resource.h"
#include "globals.h"
#include "imemenu.h"


#define GetpMyMenuItem(pMenu) ((PMYMENUITEM)((LPBYTE)pMenu + sizeof(MENULIST)))

typedef DWORD (WINAPI *PFNIMMGETIMEMENUITEMS)(HIMC, DWORD, DWORD, LPIMEMENUITEMINFO, LPIMEMENUITEMINFO, DWORD);

// since I don't have the memphis lib, do a load library

static const TCHAR c_szImmLib[] = TEXT("IMM32");
static const TCHAR c_szImmGetImeMenuItems[] = TEXT("ImmGetImeMenuItemsA");
PFNIMMGETIMEMENUITEMS g_pfnImmGetImeMenuItems = NULL; 

//
// Max and Min number of MYMENUITEM if our shared heap.
//

/**********************************************************************/
/*                                                                    */
/* GetImeMenuProc()                                                   */
/*                                                                    */
/**********************************************************************/

BOOL CWin32ImeMenu::GetImeMenuProp()
{
    if (g_pfnImmGetImeMenuItems)
        return TRUE;

    if (IsOnFE() || IsOnNT5())
    {
        HINSTANCE hInstImm;
        hInstImm = GetSystemModuleHandle(c_szImmLib);
        if (hInstImm)
            g_pfnImmGetImeMenuItems = (PFNIMMGETIMEMENUITEMS)GetProcAddress(hInstImm, c_szImmGetImeMenuItems);
    }

    return g_pfnImmGetImeMenuItems ? TRUE : FALSE;
}


/**********************************************************************/
/*                                                                    */
/* AddMenuList()                                                      */
/*                                                                    */
/**********************************************************************/

BOOL CWin32ImeMenu::AddMenuList(PMENULIST pMenu)
{
    PMENULIST pMenuPrev, pMenuNext;

    if (!_pMenuHdr)
    {        
        if ((_pMenuHdr = (PMENULIST)cicMemAllocClear(sizeof(MENULIST))) == NULL)
            return FALSE;
        _pMenuHdr->pPrev = _pMenuHdr;
        _pMenuHdr->pNext = _pMenuHdr;
    }

    pMenuPrev = _pMenuHdr->pPrev;
    pMenuNext = pMenuPrev->pNext;
    pMenu->pNext = pMenuPrev->pNext;
    pMenu->pPrev = pMenuNext->pPrev;
    pMenuPrev->pNext = pMenu;
    pMenuNext->pPrev = pMenu;

    _nMenuList++;
    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* DeleteMenuList()                                                   */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::DeleteMenuList(PMENULIST pMenu)
{
    PMENULIST pMenuPrev, pMenuNext;

    if (pMenu == _pMenuHdr) {
#ifdef DEBUG
        OutputDebugString("DeleteMenu: should not delete header");
#endif
        return;
    }
    pMenuPrev = pMenu->pPrev;
    pMenuNext = pMenu->pNext;
    pMenuPrev->pNext = pMenu->pNext;
    pMenuNext->pPrev = pMenu->pPrev;

    _nMenuList--;

    if (_nMenuList < 0)
    {
#ifdef DEBUG
        OutputDebugString("DeleteMenu: _nMenuList is zero");
#endif
        _nMenuList = 0;
    }

    cicMemFree(pMenu);
}

/**********************************************************************/
/*                                                                    */
/* DeleteAllMenuList()                                                */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::DeleteAllMenuList()
{
   PMENULIST pMenu, pMenuNext;

   if (!_pMenuHdr)
       return;

   pMenu = _pMenuHdr->pNext;

   if (pMenu == _pMenuHdr)
       return;

   while (pMenu != _pMenuHdr)
   {
       pMenuNext = pMenu->pNext;
       DeleteMenuList(pMenu);
       pMenu = pMenuNext;
   }

    if (_nMenuList > 0)
    {
#ifdef DEBUG
        OutputDebugString("DeleteAllMenu: _nMenuList is not zero");
#endif
        _nMenuList = 0;
    }

   return;
}


/**********************************************************************/
/*                                                                    */
/* AllocMenuList()                                                    */
/*                                                                    */
/**********************************************************************/
PMENULIST CWin32ImeMenu::AllocMenuList(DWORD dwNum)
{
    PMENULIST pMenu;

    pMenu = (PMENULIST)cicMemAllocClear(sizeof(MENULIST) + sizeof(MYMENUITEM) * dwNum);

    if (pMenu)
    {
        AddMenuList(pMenu);
        pMenu->dwNum = dwNum;
    }

    return pMenu;

}

/**********************************************************************/
/*                                                                    */
/* SetMyMenuItem()                                                    */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::SetMyMenuItem(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpIme, BOOL fRight, PMYMENUITEM pMyMenuItem)
{
    FillMemory((PVOID)pMyMenuItem, sizeof(MYMENUITEM), 0);

    pMyMenuItem->imii = *lpIme;

    if (lpIme->fType & IMFT_SUBMENU)
    {
        //
        // If lpIme has SubMenu, we need to create another MENULIST.
        //
        pMyMenuItem->pmlSubMenu = CreateImeMenu(hWnd, hIMC, lpIme, fRight);
    }

    pMyMenuItem->nMenuID = IDM_CUSTOM_MENU_START + _nMenuCnt;

}

/**********************************************************************/
/*                                                                    */
/* CreateImeMenu()                                                    */
/*                                                                    */
/**********************************************************************/
PMENULIST CWin32ImeMenu::CreateImeMenu(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpImeParentMenu, BOOL fRight)
{
    DWORD dwSize, dwNum, dwI;
    LPIMEMENUITEMINFO lpImeMenu;
    PMENULIST pMenu;
    PMYMENUITEM pMyMenuItem;
    
    if (!GetImeMenuProp())
        return NULL;

    dwNum = g_pfnImmGetImeMenuItems(hIMC, fRight ? IGIMIF_RIGHTMENU : 0, 
                                 IGIMII_CMODE |
                                 IGIMII_SMODE |
                                 IGIMII_CONFIGURE |
                                 IGIMII_TOOLS |
                                 IGIMII_HELP |
                                 IGIMII_OTHER,
                                 lpImeParentMenu, NULL, 0);

    if (!dwNum)
        return 0;

    pMenu = AllocMenuList(dwNum);

    if (!pMenu)
        return 0;

    pMyMenuItem = GetpMyMenuItem(pMenu);

    dwSize = dwNum * sizeof(IMEMENUITEMINFO);

    lpImeMenu = (LPIMEMENUITEMINFO)GlobalAlloc(GPTR, dwSize);

    if (!lpImeMenu)
        return 0;

    dwNum = g_pfnImmGetImeMenuItems(hIMC, fRight ? IGIMIF_RIGHTMENU : 0, 
                                 IGIMII_CMODE |
                                 IGIMII_SMODE |
                                 IGIMII_CONFIGURE |
                                 IGIMII_TOOLS |
                                 IGIMII_HELP |
                                 IGIMII_OTHER,
                                 lpImeParentMenu, lpImeMenu, dwSize);
    
    // Setup this MENULIST.
    for (dwI = 0 ; dwI < dwNum; dwI++)
    {
        SetMyMenuItem(hWnd, hIMC, lpImeMenu + dwI, fRight, pMyMenuItem + dwI);
        _nMenuCnt++;
    }

    GlobalFree((HANDLE)lpImeMenu);

    return pMenu;
}

/**********************************************************************/
/*                                                                    */
/* GetIMEMenu()                                                       */
/*                                                                    */
/**********************************************************************/
BOOL CWin32ImeMenu::GetIMEMenu(HWND hWnd, HIMC hIMC, BOOL fRight)
{
    // Init sequent number.
    _nMenuCnt = 0;

    CreateImeMenu(hWnd, hIMC, NULL, fRight);

    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* FillMenuItemInfo()                                                 */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::FillMenuItemInfo(LPMENUITEMINFO lpmii, PMYMENUITEM pMyMenuItem, BOOL fRight)
{
    FillMemory((PVOID)lpmii, sizeof(MENUITEMINFO), 0);
    lpmii->cbSize = sizeof(MENUITEMINFO);
    lpmii->fMask = 0;

    // Set fType;
    if (pMyMenuItem->imii.fType)
    {
        if (IsOnNT5())
           lpmii->fMask |= MIIM_FTYPE;
        else
           lpmii->fMask |= MIIM_TYPE;
        lpmii->fType = 0;

        if (pMyMenuItem->imii.fType & IMFT_RADIOCHECK)
            lpmii->fType |= MFT_RADIOCHECK;

        if (pMyMenuItem->imii.fType & IMFT_SEPARATOR)
            lpmii->fType |= MFT_SEPARATOR;

    }

    lpmii->fMask |= MIIM_ID;
    lpmii->wID = pMyMenuItem->nMenuID;

    if (pMyMenuItem->imii.fType & IMFT_SUBMENU)
    {
        //
        // If lpIme has SubMenu, we need to create another Popup Menu.
        //
        lpmii->fMask |= MIIM_SUBMENU;
        lpmii->hSubMenu = CreatePopupMenu();
        BuildIMEMenuItems(lpmii->hSubMenu, pMyMenuItem->pmlSubMenu, fRight);
    }

    lpmii->fMask |= MIIM_STATE;
    lpmii->fState = pMyMenuItem->imii.fState;

    if (pMyMenuItem->imii.hbmpChecked &&  pMyMenuItem->imii.hbmpUnchecked)
    {
       lpmii->fMask |= MIIM_CHECKMARKS;
       lpmii->hbmpChecked = pMyMenuItem->imii.hbmpChecked;
       lpmii->hbmpUnchecked = pMyMenuItem->imii.hbmpUnchecked;
    }
    

    lpmii->fMask |= MIIM_DATA;
    lpmii->dwItemData = pMyMenuItem->imii.dwItemData;

    if (pMyMenuItem->imii.hbmpItem)
    {
       lpmii->fMask |= MIIM_BITMAP;
       lpmii->hbmpItem = pMyMenuItem->imii.hbmpItem;
    }

    if (lstrlen(pMyMenuItem->imii.szString))
    {
        lpmii->fMask |= MIIM_STRING;
        lpmii->dwTypeData = pMyMenuItem->imii.szString;
        lpmii->cch = lstrlen(pMyMenuItem->imii.szString);
    }
}

/**********************************************************************/
/*                                                                    */
/* GetDefaultImeMenuItem()                                                     */
/*                                                                    */
/**********************************************************************/
int CWin32ImeMenu::GetDefaultImeMenuItem()
{
    PMENULIST pMenu;
    DWORD dwI;
    PMYMENUITEM pMyMenuItem;


    if (!_pMenuHdr)
        return 0;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        return 0;

    if (!pMenu->dwNum)
        return 0;

    pMyMenuItem = GetpMyMenuItem(pMenu);

    for (dwI = 0 ; dwI < pMenu->dwNum; dwI++)
    {
        if (pMyMenuItem->imii.fState & IMFS_DEFAULT)
            return pMyMenuItem->imii.wID;

        pMyMenuItem++;
    }
    return 0;

}

/**********************************************************************/
/*                                                                    */
/* BuildIMEMenuItems()                                                */
/*                                                                    */
/**********************************************************************/
BOOL CWin32ImeMenu::BuildIMEMenuItems(HMENU hMenu, PMENULIST pMenu, BOOL fRight)
{
    DWORD dwI;
    MENUITEMINFO mii;
    PMYMENUITEM pMyMenuItem;

    if (!pMenu || !pMenu->dwNum)
        return FALSE;

    pMyMenuItem = GetpMyMenuItem(pMenu);

    for (dwI = 0 ; dwI < pMenu->dwNum; dwI++)
    {
        FillMenuItemInfo(&mii, pMyMenuItem + dwI, fRight);
        InsertMenuItem(hMenu, dwI, TRUE, (MENUITEMINFO *)&mii);
    }

    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* BuildIMEMenu()                                                     */
/*                                                                    */
/**********************************************************************/
BOOL CWin32ImeMenu::BuildIMEMenu(HMENU hMenu, BOOL fRight)
{
    PMENULIST pMenu;

    if (!_pMenuHdr)
        return FALSE;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        return FALSE;

    return BuildIMEMenuItems(hMenu, pMenu, fRight);
}

/**********************************************************************/
/*                                                                    */
/* GetIMEMenuItemID()                                                 */
/*                                                                    */
/**********************************************************************/
UINT CWin32ImeMenu::GetIMEMenuItemID(int nMenuID)
{
    DWORD dwI;
    PMENULIST pMenu, pMenuNext;
    PMYMENUITEM pMyMenuItem;
    UINT uRet = 0;

    if (!_pMenuHdr)
        goto Exit;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        goto Exit;

    while (pMenu != _pMenuHdr)
    {
        pMenuNext = pMenu->pNext;
        pMyMenuItem = GetpMyMenuItem(pMenu);

        for (dwI = 0; dwI < pMenu->dwNum; dwI ++)
        {
            if (pMyMenuItem->nMenuID == nMenuID)
            {
                uRet = pMyMenuItem->imii.wID;
                goto Exit;
            }

            pMyMenuItem++;
        } 
        pMenu = pMenuNext;
    }

Exit:
    return uRet;
}

/**********************************************************************/
/*                                                                    */
/* GetIMEMenuItemData()                                               */
/*                                                                    */
/**********************************************************************/
DWORD CWin32ImeMenu::GetIMEMenuItemData(int nImeMenuID)
{
    DWORD dwI;
    PMENULIST pMenu, pMenuNext;
    PMYMENUITEM pMyMenuItem;
    DWORD dwRet = 0;

    if (!_pMenuHdr)
        goto Exit;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        goto Exit;

    while (pMenu != _pMenuHdr)
    {
        pMenuNext = pMenu->pNext;
        pMyMenuItem = GetpMyMenuItem(pMenu);

        for (dwI = 0; dwI < pMenu->dwNum; dwI ++)
        {
            if (pMyMenuItem->imii.wID == (UINT)nImeMenuID)
            {
                dwRet = pMyMenuItem->imii.dwItemData;
                goto Exit;
            }

            pMyMenuItem++;
        } 
        pMenu = pMenuNext;
    }

Exit:
    return dwRet;
}

/**********************************************************************/
/*                                                                    */
/* DestroyIMEMenu()                                                   */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::DestroyIMEMenu()
{
    DeleteAllMenuList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\ithdmshl.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef ITHDMSHL_H
#define ITHDMSHL_H

#define MP_MARSHALINTERFACE              0
#define MP_UNMARSHALINTERFACEERROR       1

HRESULT GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk);
HRESULT GetThreadUIManager(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId);
HRESULT GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId);
HRESULT ThreadMarshalInterfaceHandler(int nId);
HRESULT ThreadUnMarshalInterfaceErrorHandler(int nId);

#endif // ITHDMSHL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\lbaddin.h ===
//
// lbaddin.h
//

#ifndef LBADDIN_H
#define LBADDIN_H


BOOL ClearLangBarAddIns(SYSTHREAD *psfn, REFCLSID rclsid);
void InitLangBarAddInArray();
BOOL LoadLangBarAddIns(SYSTHREAD *psfn);
void UpdateLangBarAddIns();
void UninitLangBarAddIns(SYSTHREAD *psfn);


#endif LBADDIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\lbaddin.cpp ===
//
// lbaddin.cpp
//

#include "private.h"
#include "globals.h"
#include "ctflbui.h"
#include "regsvr.h"
#include "cregkey.h"
#include "tim.h"
#include "lbaddin.h"

const TCHAR c_szLangBarAddInKey[] =  TEXT("SOFTWARE\\Microsoft\\CTF\\LangBarAddIn\\");
const TCHAR c_szGuid[] =       TEXT("GUID");
const WCHAR c_wszFilePath[] =   L"FilePath";

typedef HRESULT (STDAPICALLTYPE* LPFNCTFGETLANGBARADDIN)(ITfLangBarAddIn **ppAddIn);


extern CPtrArray<SYSTHREAD> *g_rgSysThread;
    

//////////////////////////////////////////////////////////////////////////////
//
// LangBar AddIn service
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// TF_RegisterLangBarAddIn
//
//+---------------------------------------------------------------------------

HRESULT TF_RegisterLangBarAddIn(REFGUID rguidUISrv, const WCHAR *pwszFile, DWORD dwFlags)
{
    BOOL fLocalMachine = dwFlags & TF_RLBAI_LOCALMACHINE;

    if (IsEqualGUID(GUID_NULL, rguidUISrv))
        return E_INVALIDARG;

    if (!pwszFile)
        return E_INVALIDARG;

    CMyRegKey key;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szLangBarAddInKey);
    CLSIDToStringA(rguidUISrv, szKey + lstrlen(szKey));

    if (key.Create(fLocalMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, szKey) != S_OK)
        return E_FAIL;

    if (key.SetValueW(pwszFile, c_wszFilePath) != S_OK)
        return E_FAIL;

    if (key.SetValue((dwFlags & TF_RLBAI_ENABLE) ? 1 : 0, c_szEnable) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// TF_UnregisterLangBarAddIn
//
//+---------------------------------------------------------------------------

HRESULT TF_UnregisterLangBarAddIn(REFGUID rguidUISrv, DWORD dwFlags)
{
    CMyRegKey key;
    TCHAR szKey[256];
    TCHAR szSubKey[256];
    BOOL fLocalMachine = dwFlags & TF_RLBAI_LOCALMACHINE;

    if (IsEqualGUID(GUID_NULL, rguidUISrv))
        return E_INVALIDARG;

    StringCopyArray(szKey, c_szLangBarAddInKey);

    if (key.Open(fLocalMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    CLSIDToStringA(rguidUISrv, szSubKey);

    key.RecurseDeleteKey(szSubKey);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// TF_ClearLangBarAddIns
//
//+---------------------------------------------------------------------------

HRESULT TF_ClearLangBarAddIns(REFCLSID rclsid)
{
    int i;
    CicEnterCriticalSection(g_csInDllMain);

    if (g_rgSysThread)
    {
        int nCnt = g_rgSysThread->Count();
        for (i = 0; i < nCnt; i++)
        {
            SYSTHREAD *psfn = g_rgSysThread->Get(i);

            if (psfn)
            {
                ClearLangBarAddIns(psfn, rclsid);
            }
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);
    return S_OK;
}

BOOL ClearLangBarAddIns(SYSTHREAD *psfn, REFCLSID rclsid)
{
    int i;
    int nCnt;

    if (!psfn->prgLBAddIn)
        return TRUE;

    nCnt = psfn->prgLBAddIn->Count();

    for (i = nCnt - 1; i >= 0; i--)
    {
        LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);

        if (pAddIn)
        {
            if (pAddIn->_plbai)
            {
                if (IsEqualGUID(rclsid, CLSID_NULL) || 
                    IsEqualGUID(rclsid, pAddIn->_clsid))
                {
                    _try {
                        if (pAddIn->_fStarted)
                            pAddIn->_plbai->OnTerminate();

                        pAddIn->_plbai->Release();
                    }
                    _except(1) {
                        Assert(0);
                    }
                }
            }

            delete pAddIn;
        }

        psfn->prgLBAddIn->Remove(i, 1);
    }

    if (!psfn->prgLBAddIn->Count())
        UninitLangBarAddIns(psfn);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// InitLangBarAddInArray
//
//+---------------------------------------------------------------------------

void InitLangBarAddInArray()
{
    CMyRegKey key;
    DWORD dwIndex;
    char szKey[MAX_PATH];
    SYSTHREAD *psfn = GetSYSTHREAD();
    BOOL fLocalMachine = FALSE;

    if (!psfn)
        return;

    if (key.Open(HKEY_CURRENT_USER, c_szLangBarAddInKey, KEY_READ) != S_OK)
    {
        //
        // if there is no addin current user, try local machine.
        //
        goto StartInLocalmachine;
    }

TryAgainInLocalMachine:

    dwIndex = 0;
    while (key.EnumKey(dwIndex, szKey, ARRAYSIZE(szKey)) == S_OK)
    {
        CMyRegKey subkey;
        GUID guid;
        WCHAR wszFilePath[MAX_PATH];
        LANGBARADDIN **ppAddIn;

        if (subkey.Open(key, szKey, KEY_READ) != S_OK)
            goto Next;

        if (subkey.QueryValueCchW(wszFilePath, c_wszFilePath, ARRAYSIZE(wszFilePath)) != S_OK)
            goto Next;

        StringAToCLSID(szKey, &guid);

        if (psfn->prgLBAddIn)
        {
            int i;
            int nCnt = psfn->prgLBAddIn->Count();
            for (i = 0; i < nCnt; i++)
            {
                LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);
                if (pAddIn && IsEqualGUID(pAddIn->_guid, guid))
                    goto Next;
            }
        }
        else
        {
            psfn->prgLBAddIn = new CPtrArray<LANGBARADDIN>;
            if (!psfn->prgLBAddIn)
            {
                return;
            }
        }

        //
        // if there is no reg entry for Enable, the default is enabled.
        //
        DWORD dwRet;
        BOOL fEnabled = FALSE;
        if (subkey.QueryValue(dwRet, c_szEnable) == S_OK)
        {
            if (dwRet)
                fEnabled = TRUE;
        }

        ppAddIn = psfn->prgLBAddIn->Append(1);
        if (!ppAddIn)
            goto Next;

        *ppAddIn = new LANGBARADDIN;
        if (!*ppAddIn)
            goto Next;

        (*ppAddIn)->_guid = guid;
        (*ppAddIn)->_fEnabled = fEnabled ? TRUE : FALSE;
        StringCopyArrayW((*ppAddIn)->_wszFilePath, wszFilePath);
      
Next:
        dwIndex++;
    }

    key.Close();

    if (!fLocalMachine)
    {
StartInLocalmachine:
        fLocalMachine = TRUE;
        if (key.Open(HKEY_LOCAL_MACHINE, c_szLangBarAddInKey, KEY_READ) == S_OK)
        {
            //
            // it is time to try local machine.
            //
            goto TryAgainInLocalMachine;
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
// LoadLangBarAddIns
//
//+---------------------------------------------------------------------------

BOOL LoadLangBarAddIns(SYSTHREAD *psfn)
{
    int i;
    int nCnt;

    if (psfn->fLBAddInLoaded)
        return TRUE;

    psfn->fLBAddInLoaded = TRUE;

    if (!psfn->prgLBAddIn)
    {
        InitLangBarAddInArray();
        if (!psfn->prgLBAddIn)
            return FALSE;
    }

    if (!psfn->prgLBAddIn)
        return TRUE;

    nCnt = psfn->prgLBAddIn->Count();

    for (i = 0; i < nCnt; i++)
    {
        LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);
        LPFNCTFGETLANGBARADDIN pfn;
        ITfLangBarAddIn *plbai;

        if (!pAddIn)
            continue;

        if (pAddIn->_plbai)
            continue;

        if (!pAddIn->_fEnabled)
            continue;

        if (!pAddIn->_hInst)
        {
            if (IsOnNT())
                pAddIn->_hInst = LoadLibraryW(pAddIn->_wszFilePath);
            else
                pAddIn->_hInst = LoadLibrary(WtoA(pAddIn->_wszFilePath));
        }

        pfn = (LPFNCTFGETLANGBARADDIN)GetProcAddress(pAddIn->_hInst,
                                                     TEXT("CTFGetLangBarAddIn"));

        if (!pfn)
            continue;

   
        if (FAILED(pfn(&plbai)))
            continue;

        pAddIn->_plbai = plbai;

    }

    return psfn->prgLBAddIn->Count() ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// UpdateLangBarAddIns
//
//+---------------------------------------------------------------------------

void UpdateLangBarAddIns()
{
    int i;
    int nCnt;
    DWORD dwFlags = 0;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (!psfn)
        return;

    if (!LoadLangBarAddIns(psfn))
        return;

    if (!psfn->prgLBAddIn)
        return;

    if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr()) 
        dwFlags = 1;

    nCnt = psfn->prgLBAddIn->Count();

    for (i = 0; i < nCnt; i++)
    {
        LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);

        if (!pAddIn)
            continue;

        if (!pAddIn->_plbai)
            continue;

        if (!pAddIn->_fEnabled)
            continue;

        if (!pAddIn->_fStarted)
        {
           pAddIn->_fStarted = TRUE;
           HRESULT hr = E_FAIL;

           _try {
               hr = pAddIn->_plbai->OnStart(&pAddIn->_clsid);
           }
           _except(1) {
               Assert(0);
           }

           if (FAILED(hr))
           {
               pAddIn->_plbai->Release();
               pAddIn->_plbai = NULL;
               continue;
           }
        }

        _try {
            pAddIn->_plbai->OnUpdate(dwFlags);
        }
        _except(1) {
            Assert(0);
        }
    }
}

//+---------------------------------------------------------------------------
//
// TerminateLangBarAddIns
//
//+---------------------------------------------------------------------------

void UninitLangBarAddIns(SYSTHREAD *psfn)
{
    if (psfn->prgLBAddIn)
    {
        // Assert(!psfn->prgLBAddIn->Count());
        delete psfn->prgLBAddIn;
        psfn->prgLBAddIn = NULL;
    }

    psfn->fLBAddInLoaded = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\marshal.cpp ===
//
// marshal.cpp
//
#include "private.h"
#include "globals.h"
#include "marshal.h"
#include "thdutil.h"
#include "cicmutex.h"
#include "helpers.h"
#include "mstub.h"
#include "mproxy.h"
#include "ithdmshl.h"
#include "transmit.h"
#include "smblock.h"
#include "utb.h"
#include "nuimgr.h"
#include "timlist.h"

#define WIN9X_SRCTHREADID 0x0001

inline HRESULT MAKE_WIN32( HRESULT status )
{
    return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, status );
}

#ifdef DEBUG
ULONG g_ulMarshalTimeOut = DEFAULTMARSHALTIMEOUT;
#endif


//////////////////////////////////////////////////////////////////////////////
//
// CSendReceiveEvent
//
//////////////////////////////////////////////////////////////////////////////

class CSendReceiveEvent : public CCicEvent
{
public:
   CSendReceiveEvent(DWORD dwThreadId, ULONG ulBlockId) : CCicEvent()
   {
       if (SetName2(sz, ARRAYSIZE(sz), SZRPCSENDRECEIVEEVENT, dwThreadId, ulBlockId))
           _psz = sz;
   }
 
private:
    char sz[MAX_PATH];
};

//////////////////////////////////////////////////////////////////////////////
//
// CSendReceiveConnectionEvent
//
//////////////////////////////////////////////////////////////////////////////

class CSendReceiveConnectionEvent : public CCicEvent
{
public:
   CSendReceiveConnectionEvent(DWORD dwThreadId, ULONG ulBlockId) : CCicEvent()
   {
       if (SetName2(sz, ARRAYSIZE(sz), SZRPCSENDRECEIVECONNECTIONEVENT, dwThreadId, ulBlockId))
           _psz = sz;
   }
 
private:
    char sz[MAX_PATH];
};

//////////////////////////////////////////////////////////////////////////////
//
// CCheckThreadInputIdle
//
//////////////////////////////////////////////////////////////////////////////

#define SZCHECKTHREADINPUTIDLE     __TEXT("MSCTF.CheckThreadInptIdle.Event.")

class CCheckThreadInputIdle : public CCicEvent
{
public:
   CCheckThreadInputIdle(DWORD dwThreadId, DWORD dw) : CCicEvent()
   {
       if (SetName2(sz, ARRAYSIZE(sz), SZCHECKTHREADINPUTIDLE, dwThreadId, dw))
           _psz = sz;
   }

private:
    char sz[MAX_PATH];
};



//--------------------------------------------------------------------------
//
//  GetOleMainThreadWindow
//
//--------------------------------------------------------------------------

BOOL IsOleMainThreadWindow(HWND hwnd)
{
    char szClassName[32];

    if (!GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName)))
       return FALSE;

    if (!lstrcmp(szClassName, TEXT("OleMainThreadWndClass")))
       return TRUE;

    return FALSE;
}

HWND FindOleMainThredWindow(DWORD dwThreadId)
{
    HWND hwnd = FindWindowEx(IsOnNT5() ? HWND_MESSAGE : NULL, 
                             NULL, 
                             TEXT("OleMainThreadWndClass"), NULL);

    while (hwnd)
    {
        if (dwThreadId == GetWindowThreadProcessId(hwnd, NULL))
        {
            if (IsOleMainThreadWindow(hwnd))
                return hwnd;
        }

        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }

    return NULL;
}
  

HWND GetOleMainThreadWindow(SYSTHREAD *psfn)
{
    HWND hwndOle = NULL;

    if (psfn->hwndOleMainThread)
    {
        if (IsWindow(psfn->hwndOleMainThread) && 
            IsOleMainThreadWindow(psfn->hwndOleMainThread))
            return psfn->hwndOleMainThread;

        psfn->hwndOleMainThread = NULL;
    }


    hwndOle = FindOleMainThredWindow(GetCurrentThreadId());
    psfn->hwndOleMainThread = hwndOle;

    return hwndOle;
}

//--------------------------------------------------------------------------
//
//  FindStub
//
//--------------------------------------------------------------------------

int FindStub(CPtrArray<CStub> *prgStub, ULONG ulStubId)
{
    int nMin = 0;
    int nMax = prgStub->Count();
    int nMid = -1;

    while (nMin < nMax)
    {
         ULONG ulMidStubId;
         nMid = (nMin + nMax) / 2;
     
         ulMidStubId = prgStub->Get(nMid)->_ulStubId;

         if (ulMidStubId > ulStubId)
            nMax = nMid;
         else if (ulMidStubId < ulStubId)
            nMin = nMid + 1;
         else
            return nMid;
    }

    return -1;
}

//--------------------------------------------------------------------------
//
//  FindStubId
//
//--------------------------------------------------------------------------

BOOL FindStubId(SYSTHREAD *psfn, ULONG *pulStubId, ULONG *pulInsert)
{
    Assert(psfn->prgStub);
    int i;
    int nCnt = psfn->prgStub->Count();
    BOOL fFound;

    if (nCnt >= 0x7fffffff)
    {
        Assert(0);
        return FALSE;
    }
    
    *pulStubId = 0;
    *pulInsert = 0;

    if (!nCnt)
        return TRUE;

    //
    // max is 0x7ffffffff....
    //
    *pulStubId = 0x7fffffff;
    fFound = FALSE;

    for (i = nCnt - 1; i >= 0; i--)
    {
        CStub *pStub = psfn->prgStub->Get(i);
        if (*pulStubId > pStub->_ulStubId)
        {
            i++;
            *pulStubId = pStub->_ulStubId + 1;
            fFound = TRUE;
            break;
        }
        *pulStubId = pStub->_ulStubId - 1;
    }
 
    //
    // we should be able to find any number in 32bit value.
    //
    Assert(fFound); 
    Assert(*pulStubId <= 0x7fffffff); 

#ifdef DEBUG
    Assert(FindStub(psfn->prgStub, *pulStubId) == -1);
#endif
    *pulInsert = i;
    return fFound;
}

#ifdef DEBUG
void dbg_CheckStubIds(SYSTHREAD *psfn)
{
    Assert(psfn->prgStub);

    int i;
    int nCnt = psfn->prgStub->Count();

    CStub *pStubPrev = psfn->prgStub->Get(0);
    for (i = 1; i < nCnt; i++)
    {
        CStub *pStub = psfn->prgStub->Get(i);
        Assert(pStubPrev->_ulStubId < pStub->_ulStubId);
        pStubPrev = pStub;
    }
}
#else
#define dbg_CheckStubIds(psfn)
#endif


//--------------------------------------------------------------------------
//
//  CicCoMarshalInterface
//
//--------------------------------------------------------------------------

HRESULT CicCoMarshalInterface(REFIID riid, IUnknown *punk, ULONG *pulStubId, DWORD *pdwStubTime, DWORD dwSrcThreadId)
{
    HRESULT hr = E_OUTOFMEMORY;
    SYSTHREAD *psfn = GetSYSTHREAD();
    CStub *pStub = NULL;
    DWORD dwThreadId = GetCurrentThreadId();
    MARSHALINTERFACE *pmi = NULL;
    ULONG ulStubId;
    ULONG ulInsert;
    DWORD dwStubTime;
    CCicSecAttr sa;
    
    if (!psfn)
        return E_FAIL;

    if (!psfn->prgStub)
    {
        psfn->prgStub = new CPtrArray<CStub>;
        if (!psfn->prgStub)
        {
            goto Exit;
        }
    }

    if (!FindStubId(psfn, &ulStubId, &ulInsert))
    {
        Assert(0);
        hr = E_FAIL;
        goto Exit;
    }

    dwStubTime = GetTickCount();
    pStub = StubCreator(riid, punk, ulStubId, dwStubTime, psfn->dwThreadId, psfn->dwProcessId, dwSrcThreadId);
    if (!pStub)
    {
        Assert(0);
        goto Exit;
    }

    if (!psfn->prgStub->Insert(ulInsert, 1))
    {
        goto Exit;
    }

    psfn->prgStub->Set(ulInsert, pStub);
    dbg_CheckStubIds(psfn);

    pStub->_pfm = new CMarshalInterfaceFileMapping(dwThreadId, ulStubId, dwStubTime);

    if (pStub->_pfm == NULL)
    {
        goto Exit;
    }

    pmi = (MARSHALINTERFACE *)pStub->_pfm->Create(sa, sizeof(MARSHALINTERFACE), NULL);
    if (!pmi)
    {
        goto Exit;
    }

    pmi->iid = riid;
    pmi->dwStubTime = dwStubTime;

    *pulStubId = ulStubId;
    *pdwStubTime = dwStubTime;

    hr = S_OK;

Exit:
    if (hr != S_OK && pStub != NULL)
    {
        // pStub dtor will remove stub from psfn->prgStub
        pStub->_Release();
    }

    return hr;
}


//--------------------------------------------------------------------------
//
//  CicCoUnmarshalInterface
//
//--------------------------------------------------------------------------

HRESULT CicCoUnmarshalInterface(REFIID riid, DWORD dwStubThreadId, ULONG ulStubId, DWORD dwStubTime, void **ppv)
{
    HRESULT hr = E_FAIL;
    SYSTHREAD *psfn = GetSYSTHREAD();
    IUnknown *punkProxy = NULL;
    MARSHALINTERFACE *pmi;
    CMarshalInterfaceFileMapping fm(dwStubThreadId, ulStubId, dwStubTime);

    *ppv = NULL;

    if (!psfn)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pmi = (MARSHALINTERFACE *)fm.Open();
    if (!pmi)
    {
        // Assert(0);
        hr = MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE);
        goto Exit;
    }

    if (!IsEqualIID(pmi->iid, riid))
    {
        // Assert(0);
        hr = E_FAIL;
        goto Exit;
    }

    punkProxy = ProxyCreator(psfn,
                             pmi->iid, 
                             ulStubId, 
                             dwStubTime, 
                             dwStubThreadId, 
                             psfn->dwThreadId, 
                             psfn->dwProcessId);

    if (!punkProxy)
    {
        Assert(0);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *ppv = punkProxy;
    hr = S_OK;
Exit:
    fm.Close();
    return hr;
}

//--------------------------------------------------------------------------
//
//  HandleSendReceive
//
//--------------------------------------------------------------------------

void HandleSendReceiveMsg(DWORD dwSrcThreadId, ULONG ulBlockId)
{
    MARSHALMSG *pMsg = NULL;
    SYSTHREAD *psfn = GetSYSTHREAD();
    int nTarget;
    CStub *pStub = NULL;
    HRESULT hr;
    CSharedBlock *psb;

    if (!psfn)
    {
        Assert(0);
        return;
    }

    Assert(IsOnNT() || (dwSrcThreadId == WIN9X_SRCTHREADID));

    CSendReceiveEvent event(dwSrcThreadId, ulBlockId);
    CSendReceiveConnectionEvent eventc(dwSrcThreadId, ulBlockId);

    if (eventc.Open())
        eventc.Set();

    if (psfn->pti && (psfn->dwThreadId == psfn->pti->dwThreadId))
        psfn->pti->ulInMarshal++;
    else
        Assert(0);


    psb = EnsureSharedBlockForThread(psfn, dwSrcThreadId);
    if (!psb)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Shared Block Ptr");
        goto Exit;
    }

    pMsg = (MARSHALMSG *)psb->GetPtrFromBlockId(ulBlockId);
    if (!pMsg)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Msg Ptr");
        goto Exit;
    }

    if (!psfn->prgStub)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no more sink");
        goto Exit;
    }

    nTarget = FindStub(psfn->prgStub, pMsg->ulStubId);
    if (nTarget == -1)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Stub");
        goto Exit;
    }

    pStub = psfn->prgStub->Get(nTarget);
    if (!pStub)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Stub Ptr");
        goto Exit;
    }

    if (pStub->_dwStubTime != pMsg->dwStubTime)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive old proxy was used");
        goto Exit;
    }

    Assert(IsEqualIID(pStub->_iid, pMsg->iid));

#ifdef DEBUG
    TCHAR _szModule[MAX_PATH];
    ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
    TraceMsg(TF_EVENT, "%s HandleSendReceive Invoke", _szModule);
#endif

    //
    // we check the file map handle to marshal this interface itself.
    //
    pStub->ClearFileMap();

    _try 
    {
        hr = pStub->Invoke(pMsg, psb);
    }
    _except(1)
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s HandleSendReceive Except", _szModule);
#endif
        Assert(0);
        goto Exit;
    }

    if (FAILED(hr))
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s HandleSendReceive Error", _szModule);
#endif
        Assert(0);
        goto Exit;
    }

#ifdef DEBUG
    TraceMsg(TF_EVENT, "%s HandleSendReceive OK", _szModule);
#endif
 
#if 0
    if (IsOnNT5())
    {
        // 
        // for Office10 beta.
        // 
        // we want to allow SetForegroundWindow always when marshalling
        // call happens. Thus we may have non-necessary calls here. 
        // Needs to find a good place to call this.
        //
        ALLOWSETFOREGROUNDWINDOW fnAllowSetForeground;
        fnAllowSetForeground = EnsureAllowSetForeground();
        if (fnAllowSetForeground)
            fnAllowSetForeground(pMsg->dwSrcProcessId);
    }
#endif

Exit:
    if (psfn->pti && (psfn->dwThreadId == psfn->pti->dwThreadId))
        psfn->pti->ulInMarshal--;
    else
        Assert(0);

    if (event.Open())
        event.Set();

}

//////////////////////////////////////////////////////////////////////////////
//
// CModalLoop
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CModalLoop::CModalLoop(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    _wQuitCode =  0;
    _fQuitReceived = FALSE;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CModalLoop::~CModalLoop()
{
    if (_fQuitReceived)
        PostQuitMessage(_wQuitCode);
}

//--------------------------------------------------------------------------
//
//  WaitHandleWndMessage
//
//--------------------------------------------------------------------------

#define WRM_MARSHALWND         0x0001
#define WRM_DISPATCH           0x0002
#define WRM_OLEWINDOW          0x0004
#define WRM_MARSHALWNDDISPATCH (WRM_DISPATCH | WRM_MARSHALWND)

void CModalLoop::WaitHandleWndMessages(DWORD dwQueueFlags)
{

    // Try to clear the queue as best we can of any messages that
    // might be holding off some other modal loop from executing.
    // So we eat all mouse and key events.
    if (dwQueueFlags & QS_KEY)
    {
        WaitRemoveMessage(WM_KEYFIRST, WM_KEYLAST, 0);
    }

    // Clear mouse releated messages if there are any
    if (dwQueueFlags & QS_MOUSE)
    {
        WaitRemoveMessage(WM_MOUSEMOVE, WM_MOUSEMOVE, 0);
        WaitRemoveMessage(WM_NCMOUSEFIRST, WM_NCMOUSELAST, 0);
        WaitRemoveMessage(WM_QUEUESYNC, WM_QUEUESYNC, 0);
    }

    if (dwQueueFlags & QS_POSTMESSAGE)
    {
        WaitRemoveMessage(WM_DDE_FIRST, WM_DDE_LAST, WRM_DISPATCH);
        WaitRemoveMessage(g_msgThreadMarshal, 
                          g_msgThreadMarshal, 
                          WRM_MARSHALWNDDISPATCH);
        WaitRemoveMessage(g_msgCheckThreadInputIdel,
                          g_msgCheckThreadInputIdel,
                          WRM_MARSHALWNDDISPATCH);
#ifdef POINTER_MARSHAL
        WaitRemoveMessage(g_msgPointerMarshal, 
                          g_msgPointerMarshal, 
                          WRM_MARSHALWNDDISPATCH);
#endif
#ifdef DEBUG
        TCHAR _szModule[MAX_PATH];
        ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
        TraceMsg(TF_EVENT, "%s CModalLoop::WaitHandleWndMessage:: MSUIM.Msg.RpcSendReceive", _szModule);
#endif
        WaitRemoveMessage(g_msgRpcSendReceive, 
                          g_msgRpcSendReceive, 
                          WRM_MARSHALWNDDISPATCH);
        // WaitRemoveMessage(g_msgPrivate, g_msgPrivate, WRM_DISPATCH);
        WaitRemoveMessage(g_msgPrivate, g_msgPrivate, 0);
        if (!_psfn->fInmsgSetFocus)
            WaitRemoveMessage(g_msgSetFocus, g_msgSetFocus, 0);
        if (!_psfn->fInmsgThreadItemChange)
            WaitRemoveMessage(g_msgThreadItemChange, g_msgThreadItemChange, 0);
        if (!_psfn->fInmsgThreadTerminate)
            WaitRemoveMessage(g_msgThreadTerminate, g_msgThreadTerminate, 0);
        WaitRemoveMessage(g_msgLBarModal, g_msgLBarModal, 0);

        WaitRemoveMessage(WM_USER, (UINT)(-1), WRM_OLEWINDOW | WRM_DISPATCH);
    }

    // Get rid of paint message if we can as well -- this makes
    // the screen look so much better.
    if (dwQueueFlags & QS_PAINT)
    {
        WaitRemoveMessage(WM_PAINT, WM_PAINT, WRM_DISPATCH);
    }

}


//--------------------------------------------------------------------------
//
//  MyPeekMessage
//
//--------------------------------------------------------------------------

BOOL CModalLoop::MyPeekMessage(MSG *pMsg, HWND hwnd, UINT min, UINT max, WORD wFlag)
{
    BOOL fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);

    while (fRet)
    {
        if (pMsg->message != WM_QUIT)
        {
            break;
        }

        _wQuitCode = (ULONG)(pMsg->wParam);
        _fQuitReceived = TRUE;

        if (!(wFlag & PM_REMOVE)) 
        {
            // quit message is still on queue so pull it off
            PeekMessage(pMsg, hwnd, WM_QUIT, WM_QUIT, PM_REMOVE | PM_NOYIELD);
        }

        // peek again to see if there is another message
        fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);
    }

    return fRet;
}

//--------------------------------------------------------------------------
//
//  WaitRemoveMessage
//
//--------------------------------------------------------------------------

BOOL CModalLoop::WaitRemoveMessage(UINT uMsgFirst, UINT uMsgLast, DWORD dwFlags)
{
    MSG msg;
    HWND hwnd = NULL;
    BOOL fRet = FALSE;

    if (dwFlags & WRM_MARSHALWND)
    {
        hwnd = _psfn->hwndMarshal;
    }
    if (dwFlags & WRM_OLEWINDOW)
    {
        hwnd = GetOleMainThreadWindow(_psfn);
        if (!hwnd)
            return FALSE;
    }

    while (MyPeekMessage(&msg, hwnd, uMsgFirst, uMsgLast,
                       PM_REMOVE  | PM_NOYIELD))
    {
        if (dwFlags & WRM_DISPATCH)
            DispatchMessage(&msg);

        fRet = TRUE;
    }
    return fRet;
}

//--------------------------------------------------------------------------
//
//  BlockFn
//
//--------------------------------------------------------------------------

HRESULT CModalLoop::BlockFn(CCicEvent *pevent, DWORD dwWaitingThreadId, DWORD &dwWaitFlags)
{
    DWORD dwReason;
    HRESULT hr = S_FALSE;

    //
    // if the event is already set, we don't need to wait.
    //
    dwReason = pevent->EventCheck();
    if (dwReason == WAIT_OBJECT_0)
        return S_OK;

    if (dwReason == WAIT_TIMEOUT)
    {
        //
        // we just check the our target send marshaling message to
        // our thread. If so, just handle it.
        //
        DWORD dwStatus = GetQueueStatus(QS_POSTMESSAGE);
        WORD wNew = (WORD)dwStatus | HIWORD(dwStatus);

        if (wNew & QS_POSTMESSAGE)
        {
            //
            // handle ThreadMarshaling.
            //
            if (WaitRemoveMessage(g_msgThreadMarshal, 
                                  g_msgThreadMarshal, 
                                  WRM_MARSHALWNDDISPATCH))
                return S_FALSE;

            //
            // handle another rpc cal.
            //
#ifdef DEBUG
            TCHAR _szModule[MAX_PATH];
            ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
            TraceMsg(TF_EVENT, "%s CModalLoop::BlockFn:: MSUIM.Msg.RpcSendReceive", _szModule);
#endif
            if (WaitRemoveMessage(g_msgRpcSendReceive, 
                                  g_msgRpcSendReceive, 
                                  WRM_MARSHALWNDDISPATCH))
                return S_FALSE;

        }

        dwReason = pevent->MsgWait(500, dwWaitFlags);
    }

    if (dwReason == WAIT_OBJECT_0)
    {
        return S_OK;
    }
    else if (dwReason == WAIT_OBJECT_0 + 1)
    {
        //
        // now we handle only new messages.
        //
        DWORD dwStatus = GetQueueStatus(dwWaitFlags);
        WORD wNew = (WORD)dwStatus | HIWORD(dwStatus);

        WaitHandleWndMessages((DWORD)wNew);

        //
        // need to review this later.
        // we want to check the thread was terminated or not.
        //
        goto CheckThread;
    }
    else 
    {
        //
        // Cic#4516
        // 
        //  The target thread seems to be busy. Check the current queue to 
        //  see if we have a message sent. The target thread may be in
        //  SendMessage() and waiting for the reply of this thread.
        // 
        //
        DWORD dwStatus = GetQueueStatus(QS_SENDMESSAGE);
        WORD wNew = HIWORD(dwStatus);
        if (wNew & QS_SENDMESSAGE)
        {
            MSG msg;
            //
            // Maybe PeekMessage is better than ReplyMessage(). 
            //
            PeekMessage(&msg, NULL, 0, 0, 
                        ((IsOnNT5() || IsOn98()) ? PM_QS_SENDMESSAGE : 0) | PM_NOREMOVE);
        }

CheckThread:
        if (!g_timlist.IsThreadId(dwWaitingThreadId))
        {
            TraceMsg(TF_EVENT, "CProxy::SendReceive No Thread");
            hr = MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE);
            goto Exit;
        }
    }
Exit:
    return hr;
}


//+---------------------------------------------------------------------------
//
// FreeStubs
//
//+---------------------------------------------------------------------------

void FreeMarshaledStubs(SYSTHREAD *psfn)
{
    if (psfn->prgStub)
    {
        int nCnt = psfn->prgStub->Count();
        int i = 0;

        for (i = 0; i < nCnt; i++)
        {
            CStub *pStub = psfn->prgStub->Get(i);
            pStub->_fNoRemoveInDtor = TRUE;
            delete pStub;
        }
         
        psfn->prgStub->Clear();
        delete psfn->prgStub;
        psfn->prgStub = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// FreeStubsForThread
//
//+---------------------------------------------------------------------------

void FreeMarshaledStubsForThread(SYSTHREAD *psfn, DWORD dwThread)
{
    if (psfn->prgStub)
    {
        int nCnt = psfn->prgStub->Count();
        int i = 0;

        for (i = nCnt; i > 0; i--)
        {
            CStub *pStub = psfn->prgStub->Get(i - 1);

            if (!pStub)
                continue;

            if (pStub->_dwSrcThreadId == dwThread)
                delete pStub;
        }
         
    }
}



//--------------------------------------------------------------------------
//
//  StubCleanUp
//
//--------------------------------------------------------------------------

void StubCleanUp(DWORD dwStubTime, ULONG ulStubId)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CStub *pStub;
    int nRemove;

    if (psfn == NULL)
        return;

    // Assert(psfn->prgStub);
    if (!psfn->prgStub)
        return;

    dbg_CheckStubIds(psfn);

    nRemove = FindStub(psfn->prgStub, ulStubId);
    if (nRemove == -1)
        return;

    pStub = psfn->prgStub->Get(nRemove);

    //
    // check stub created time.
    //
    // Requested Stub ID seems to be destroyed long time ago and
    // newer stub is using same ID.
    //
    if (pStub->_dwStubTime != dwStubTime)
        return;
    
    psfn->prgStub->Remove(nRemove, 1);
    delete pStub;
}

//+---------------------------------------------------------------------------
//
// CicMarshalWndProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK CicMarshalWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn;

    if (uMsg == WM_DESTROY)
    {
        g_timlist.SetMarshalWnd(GetCurrentThreadId(), NULL);
        if (psfn = GetSYSTHREAD())
        {
            Assert(!psfn->hwndMarshal || (psfn->hwndMarshal == hWnd));
            psfn->hwndMarshal = NULL;

            //
            // #507248
            //
            // need to reset the dirty flag.
            //
            if (psfn->plbim)
                psfn->plbim->ResetDirtyUpdate();
        }
    }
    else if ((uMsg == WM_CLOSE) || (uMsg == WM_QUERYENDSESSION))
    {
        if (psfn = GetSYSTHREAD())
        {
            Assert(!psfn->hwndMarshal || (psfn->hwndMarshal == hWnd));
            DestroyWindow(hWnd);
            psfn->hwndMarshal = NULL;
        }
    }
    else if (uMsg == g_msgNuiMgrDirtyUpdate)
    {
        goto CallOnUpdateHandler;
    }
    else if (uMsg == WM_TIMER)
    {
        if (wParam == MARSHALWND_TIMER_UPDATEKANACAPS)
        {
            KillTimer(hWnd, MARSHALWND_TIMER_UPDATEKANACAPS);

            if (psfn = GetSYSTHREAD())
            {
                KanaCapsUpdate(psfn);
            }
        }
        else if (wParam == MARSHALWND_TIMER_NUIMGRDIRTYUPDATE)
        {
            KillTimer(hWnd, MARSHALWND_TIMER_NUIMGRDIRTYUPDATE);

CallOnUpdateHandler:
            if (IsCTFMONBusy() || IsInPopupMenuMode())
            {
TryOnUpdatehandlerAgain:
                SetTimer(hWnd, MARSHALWND_TIMER_NUIMGRDIRTYUPDATE, 100, NULL);
            }
            else 
            {
                if (psfn = GetSYSTHREAD())
                {
                    if (psfn->plbim)
                    {
                        if (psfn->plbim->IsInOnUpdateHandler())
                            goto TryOnUpdatehandlerAgain;

                        psfn->plbim->OnUpdateHandler();
                    }
                }
            }
        }
        else if (wParam == MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS)
        {
             KillTimer(hWnd, MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS);
             PostThreadMessage(GetCurrentThreadId(), g_msgSetFocus, 0, 0);
        }
    }
    else if (uMsg == g_msgRpcSendReceive)
    {
        HandleSendReceiveMsg((ULONG)wParam, (ULONG)lParam);
    }
#ifdef POINTER_MARSHAL
    else if (uMsg == g_msgPointerMarshal)
    {
        switch (LOWORD(wParam))
        {
            case MP_MARSHALINTERFACE:
                PointerMarshalInterfaceHandler(lParam);
                break;

            case MP_UNMARSHALINTERFACEERROR:
                PointerUnMarshalInterfaceErrorHandler(lParam);
                break;
        }
    }
#endif
    else if (uMsg == g_msgThreadMarshal)
    {
        switch (LOWORD(wParam))
        {
            case MP_MARSHALINTERFACE:
                ThreadMarshalInterfaceHandler((int)lParam);
                break;

            case MP_UNMARSHALINTERFACEERROR:
                ThreadUnMarshalInterfaceErrorHandler((int)lParam);
                break;
        }
    }
    else if (uMsg == g_msgStubCleanUp)
    {
        StubCleanUp((DWORD)wParam, (ULONG)lParam);
    }
    else if (uMsg == g_msgCheckThreadInputIdel)
    {
        DWORD dwThreadId = GetCurrentThreadId();
        CCheckThreadInputIdle event(dwThreadId, (DWORD)lParam);

        if (event.Open())
            event.Set();
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


ATOM g_atomMarshalClass = 0;

//+---------------------------------------------------------------------------
//
// EnsureMarshalWnd
//
//+---------------------------------------------------------------------------

HWND EnsureMarshalWnd()
{
    SYSTHREAD *psfn;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return NULL;

    if (!EnsureTIMList(psfn))
        return NULL;
    
    if (IsWindow(psfn->hwndMarshal))
    {
        if (psfn->hwndMarshal != g_timlist.GetMarshalWnd(psfn->dwThreadId))
        {
             g_timlist.SetMarshalWnd(psfn->dwThreadId, psfn->hwndMarshal);
        }
        return psfn->hwndMarshal;
    }

    //
    // we can not support marshaling after process detach.
    //
    if (g_fDllProcessDetached)
        return NULL;

    //
    // Win98 has a bug in FindWindow() with HWND_MESSAGE, so we need to have
    // unique windiw text for each thread.
    //
    char sz[MAX_PATH];
    if (!SetName(sz, ARRAYSIZE(sz), c_szCicMarshalWnd, GetCurrentThreadId()))
        return NULL;

    //
    // We want to hide this window from EnumWindow() API.
    // So we use HWND_MESSAGE for Win98 and NT5.
    //
    // For Beta.
    //
    // Under NT4, we destroy every time the popup window is destroyed in
    // WndProcHook. However we should
    //

    psfn->hwndMarshal = CreateWindowEx(0, 
                                       c_szCicMarshalClass, 
                                       sz,
                                       WS_DISABLED | WS_POPUP, 
                                       0,
                                       0, 
                                       0, 
                                       0, 
                                       IsOn98orNT5() ? HWND_MESSAGE : NULL, 
                                       0,
                                       g_hInst, 
                                       0);

    g_timlist.SetMarshalWnd(psfn->dwThreadId, psfn->hwndMarshal);

    Assert(psfn->hwndMarshal);

    return psfn->hwndMarshal;
}

//+---------------------------------------------------------------------------
//
// RegisterMarshalWndClass
//
//+---------------------------------------------------------------------------


void RegisterMarshalWndClass()
{
    WNDCLASSEX wndclass;

    memset(&wndclass, 0, sizeof(wndclass));
    wndclass.cbSize        = sizeof(wndclass);
    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.hInstance     = g_hInst;
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.lpfnWndProc   = CicMarshalWndProc;
    wndclass.lpszClassName = c_szCicMarshalClass;
    g_atomMarshalClass = RegisterClassEx(&wndclass);
}

//////////////////////////////////////////////////////////////////////////////
//
// CThreadMarshalWnd
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CThreadMarshalWnd::CThreadMarshalWnd()
{
    _dwThreadId = 0;
    _hwnd = 0;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CThreadMarshalWnd::~CThreadMarshalWnd()
{
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

BOOL CThreadMarshalWnd::Init(DWORD dwThreadId)
{
    HWND hwndTemp = NULL;

    _dwThreadId = dwThreadId;

    //
    // clear _hwnd out first.
    //
    _hwnd = NULL;

    if (hwndTemp = GetThreadMarshalWnd(dwThreadId))
    {
        if (GetWindowThreadProcessId(hwndTemp, NULL) == dwThreadId)
        {
            _hwnd = hwndTemp;
        }
    }

    return _hwnd ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// PostMarshalThreadMessage
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::PostMarshalThreadMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    Assert(g_atomMarshalClass);
    if (!_hwnd || !IsWindow())
    {
        //
        // Was the window destroyed? 
        //
        TraceMsg(TF_GENERAL, "CThreadmarshalWnd::PostMarshalThreadMessage  marshal window could not be found");
        return FALSE;
    }

#ifdef DEBUG
    TCHAR _szModule[MAX_PATH];
    ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
    TraceMsg(TF_EVENT, "%s CThreadMarshalWnd::PostMarshalThreadMessage hWnd - %x uMsg - %x wParam - %x lParam - %x", _szModule, _hwnd, uMsg, wParam, lParam);
#endif

    return PostMessage(_hwnd, uMsg, wParam, lParam);
}

//--------------------------------------------------------------------------
//
//  DestroyAll
//
//--------------------------------------------------------------------------

BOOL CThreadMarshalWnd::DestroyAll()
{
    ULONG ulNum;
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    EnsureTIMList(psfn);

    ulNum = g_timlist.GetNum();

    if (ulNum)
    {
        DWORD *pdw = new DWORD[ulNum + 1];
        if (pdw)
        {
            if (g_timlist.GetList(pdw, ulNum+1, &ulNum, 0, 0, FALSE))
            {
                ULONG ul;
                for (ul = 0; ul < ulNum; ul++)
                {
                    if (pdw[ul])
                        DestroyThreadMarshalWnd(pdw[ul]);
                }
            }
            delete [] pdw;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// DestroyThreadMarshalWnd
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::DestroyThreadMarshalWnd(DWORD dwThread)
{
    HWND hwndTemp;

    if (hwndTemp = GetThreadMarshalWnd(dwThread))
    {
        //
        // #425375.
        //
        // SendMessageTimeout() makes shut-down slower.
        // instead, we use SendNotifyMessage() and this is safer since
        // the queue of the thread does not miss WM_CLOSE message for the
        // window.
        //
        SendNotifyMessage(hwndTemp, WM_CLOSE, 0, 0);

    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ClearMarshalWndProc
//
//+---------------------------------------------------------------------------

void CThreadMarshalWnd::ClearMarshalWndProc(DWORD dwProcessId)
{
    ULONG ulNum;

    if (!g_timlist.IsInitialized())
        return;

    ulNum = g_timlist.GetNum();

    //
    // MSCTF.DLL will be unloaded so we may need to make all existing marshal 
    // windows in the current process a ghost. We wanted to destroy them
    // but we missed a chance to destroy them.
    //
    // It may be ok to call DestroyWindow() in process detach since
    // it is known window. But making them a ghost seems to be safer.
    //
    if (ulNum)
    {
        DWORD *pdw = new DWORD[ulNum + 1];
        if (pdw)
        {
            if (g_timlist.GetListInProcess(pdw, &ulNum, dwProcessId))
            {
                ULONG ul;
                for (ul = 0; ul < ulNum; ul++)
                {
                    if (pdw[ul])
                    {
                        HWND hwnd = GetThreadMarshalWnd(pdw[ul]);
                        if (hwnd)
                        {
                            SetWindowLongPtr(hwnd, 
                                             GWLP_WNDPROC,
                                             (LONG_PTR)DefWindowProc);
                        }
                    }
                }
            }
            delete [] pdw;
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetThreadMarshalWnd
//
//+---------------------------------------------------------------------------

HWND CThreadMarshalWnd::GetThreadMarshalWnd(DWORD dwThread)
{
    HWND hwnd = g_timlist.GetMarshalWnd(dwThread);

    if (::IsWindow(hwnd))
    {
         if (dwThread == GetWindowThreadProcessId(hwnd, NULL))
         {
              ATOM atomClass = (ATOM)GetClassLongPtr(hwnd, GCW_ATOM);
              if (g_atomMarshalClass == atomClass)
                  return hwnd;
         }
         g_timlist.SetMarshalWnd(dwThread, NULL);
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// EnumThreadWndProc
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::EnumThreadWndProc(HWND hwnd, LPARAM lParam)
{
    *(BOOL *)lParam = TRUE;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsThreadWindow
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::IsThreadWindow()
{
    BOOL fFound = FALSE;

    EnumThreadWindows(_dwThreadId,
                      EnumThreadWndProc,
                      (LPARAM)&fFound);

    return fFound;
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxy
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CProxy::CProxy(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    _ulProxyId = 0;
    _ulStubId = (ULONG)(-1);
    _dwStubThreadId = 0;
    _dwSrcThreadId = 0;
    _dwSrcProcessId = 0;
    _cRef = 1;
#ifdef DEBUG
    _fInLoop = FALSE;
#endif
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CProxy::~CProxy()
{
#ifdef DEBUG
    Assert(!_fInLoop);
#endif
    if (g_timlist.IsThreadId(_dwStubThreadId))
        _tmw.PostMarshalThreadMessage(g_msgStubCleanUp, _dwStubTime, _ulStubId);
}

ULONG CProxy::InternalAddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CProxy::InternalRelease()
{
    _cRef--;
    if (!_cRef)
    {
        delete this;
        return 0;
    }
    return _cRef;
}


//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

void CProxy::Init(REFIID riid, ULONG ulProxyId, ULONG ulStubId, DWORD dwStubTime, DWORD dwStubThreadId, DWORD dwCurThreadId, DWORD dwCurProcessId)
{
    _iid = riid;
    _ulProxyId = ulProxyId;
    _ulStubId = ulStubId;
    _dwStubTime = dwStubTime;
    _dwStubThreadId = dwStubThreadId;
    _dwSrcThreadId = dwCurThreadId;
    _dwSrcProcessId = dwCurProcessId;
    _tmw.Init(_dwStubThreadId);
}


//--------------------------------------------------------------------------
//
//  SendReceive
//
//--------------------------------------------------------------------------

HRESULT CProxy::SendReceive(MARSHALMSG *pMsg, ULONG ulBlockId)
{
    HRESULT hr = E_FAIL;
    CCicTimer timer(MARSHALTIMEOUT, FALSE);
    DWORD dwWaitFlags;
    DWORD dwThreadId = _dwStubThreadId;
    CModalLoop modalloop(_psfn);
    DWORD dwSrcThreadId;
    TL_THREADINFO *pti;
    DWORD dwPrevWaitingThread;
    CCicSecAttr sa;

#ifdef DEBUG
    TCHAR _szModule[MAX_PATH];
    ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
    TraceMsg(TF_EVENT, "%s CProxy::SendReceive Start _ThreadId - %x _uStubId - %x, msg size - %x", _szModule, _dwStubThreadId, _ulStubId, pMsg->cbSize);
#endif

    pti = g_timlist.IsThreadId(_dwStubThreadId);
    if (!pti)
    {
        TraceMsg(TF_EVENT, "CProxy::SendReceive Invalid ThreadId %x", _dwStubThreadId);
        return E_FAIL;
    }

    Assert(pti->dwThreadId ==  _dwStubThreadId);
    if (pti->dwFlags & TLF_INSFW)
    {
        TraceMsg(TF_EVENT, "CProxy::SendReceive  Thread is in SetForegroundWindow %08x", _dwStubThreadId);
        return E_FAIL;
    }


    //
    // for Win9x, we can identify the event and shared block by ulBlockId.
    //
    if (IsOnNT())
        dwSrcThreadId = pMsg->dwSrcThreadId;
    else
        dwSrcThreadId = WIN9X_SRCTHREADID;


    //
    // Event for marshaling
    //
    CSendReceiveEvent event(dwSrcThreadId, ulBlockId);
    if (!event.Create(sa))
        return E_FAIL;

    CSendReceiveConnectionEvent eventc(dwSrcThreadId, ulBlockId);
    BOOL fSendReceiveConnection = FALSE;

    if (!eventc.Create(sa))
        return E_FAIL;


    // Win98 QS_EVENT hack.
    // Win98's Event QueueItem could cause inter thread sendmessage
    // We want to clean up Event QueueItem before Marshaling happens.
    //
    // because CTFMON.EXE may call AttatchThreadInput() and this event
    // could be handled in CTFMON's thread and this make the event queue item 
    // to do inter thread SendMessage.
    //
    if (!IsOnNT())
    {
        MSG msg;
        PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD);
    }

    //
    // save previous waiting thread.
    //
    if (_psfn->pti)
    {
        dwPrevWaitingThread = _psfn->pti->dwMarshalWaitingThread;
        _psfn->pti->dwMarshalWaitingThread = _dwStubThreadId;
    }

    //
    // update marshal window handle from PTI.
    // the window handle in _tmw may be destroyed on NT4.
    //
    _tmw.SetMarshalWindow(pti->hwndMarshal);

    if (!_tmw.PostMarshalThreadMessage(g_msgRpcSendReceive,
                                       dwSrcThreadId,
                                       ulBlockId))
    {
         TraceMsg(TF_EVENT, "CProxy::SendReceive PostThreadMessage failed");
         goto Exit;
    }

#ifdef DEBUG
    _fInLoop = TRUE;
#endif
    timer.Start();
    dwWaitFlags = QS_DEFAULTWAITFLAG;
    while (!timer.IsTimerAtZero())
    {
        if (!fSendReceiveConnection &&
             timer.IsTimerPass(DEFAULTMARSHALCONNECTIONTIMEOUT))
        { 
            DWORD dwReason = eventc.EventCheck();
            if (dwReason != WAIT_OBJECT_0)
            {
                hr = E_FAIL;
                break;
            }
            fSendReceiveConnection = TRUE;
        }

        hr = modalloop.BlockFn(&event, dwThreadId, dwWaitFlags);
       
        if (hr == S_OK)
            goto EventOK;

        if (FAILED(hr))
            break;

        if (!_tmw.IsWindow())
        {
            hr = E_FAIL;
            break;
        }

        if (!_tmw.IsThreadWindow())
        {
            CThreadMarshalWnd::DestroyThreadMarshalWnd(_dwStubThreadId);
            hr = E_FAIL;
            break;
        }

    }

#ifdef DEBUG
    TraceMsg(TF_EVENT, "%s CProxy::SendReceive Time Out", _szModule);
#endif
    goto Exit;

EventOK:
#ifdef DEBUG
    TraceMsg(TF_EVENT, "%s CProxy::SendReceive OK", _szModule);
#endif
    hr = S_OK;

Exit:
#ifdef DEBUG
    _fInLoop = FALSE;
#endif

    //
    // restore previous waiting thread.
    //
    if (_psfn->pti)
        _psfn->pti->dwMarshalWaitingThread = dwPrevWaitingThread;

    return hr;
}


//--------------------------------------------------------------------------
//
//  proxy_Param
//
//--------------------------------------------------------------------------

HRESULT CProxy::proxy_Param(ULONG ulMethodId, ULONG ulParamNum, CPROXY_PARAM *pProxyParam)
{
    HRESULT hr = E_FAIL;
    ULONG i;
    MARSHALMSG *pMsgMap = NULL;
    ULONG cbBufSize;
    CMarshalParamCreator cparam;
    ULONG ulBlockId;
    HRESULT hrMarshalOutParam = S_OK;
    ULONG cbPadMemSize = 0;

    CSharedHeap *psheap = EnsureSharedHeap(_psfn);
    if (!psheap)
        return hr;

    InternalAddRef();

TryAgain:
    cbBufSize = sizeof(MARSHALMSG) + ulParamNum * sizeof(MARSHALPARAM);
    LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);
    cbBufSize += cbPadMemSize;
    LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);

    for (i = 0; i < ulParamNum; i++)
    {
        ULONG cbUnitSize = sizeof(ULONG_PTR);
        LENGTH_ALIGN(cbUnitSize, CIC_ALIGNMENT);

        if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
           cbUnitSize +=  sizeof(MARSHALINTERFACEPARAM);
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
           if (!(pProxyParam[i].dwFlags & MPARAM_IN))
           {
               cbUnitSize +=  0x2000;
           }
           else
           {
               Assert(pProxyParam[i].ulCount == 1);
               HICON *picon = (HICON *)pProxyParam[i].pv;
               cbUnitSize += Cic_HICON_UserSize(picon);
           }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
           if (!(pProxyParam[i].dwFlags & MPARAM_IN))
           {
               cbUnitSize +=  0x1000;
           }
           else
           {
               Assert(pProxyParam[i].ulCount == 1);
               HBITMAP *pbmp = (HBITMAP *)pProxyParam[i].pv;
               cbUnitSize += Cic_HBITMAP_UserSize(pbmp);
           }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
           cbUnitSize +=  0x1000;
        // else if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        //    cbUnitSize +=  0x1000;
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
           cbUnitSize +=  0x1000;
        else
           cbUnitSize += pProxyParam[i].cbUnitSize;

        LENGTH_ALIGN(cbUnitSize, CIC_ALIGNMENT);
        cbBufSize += (cbUnitSize * pProxyParam[i].ulCount);
        LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);
    }

    if (!psheap->GetBlock()->GetMutex()->Enter())
    {
        hr = E_FAIL;
        goto Exit;
    }

    pMsgMap = (MARSHALMSG *)psheap->Alloc(cbBufSize);

    if (!pMsgMap)
    {
        hr = E_OUTOFMEMORY;
        goto FinishParamCreation;
    }

    ulBlockId = psheap->GetBlockId(pMsgMap);

    cparam.Set(pMsgMap, cbBufSize);
    cparam.Init(_dwSrcThreadId, 
                _dwSrcProcessId, 
                _iid, 
                ulMethodId, 
                ulParamNum, 
                _ulStubId,
                _dwStubTime);

    hr = S_OK;

    for (i = 0; i < ulParamNum; i++)
    {
        if (!(pProxyParam[i].dwFlags & MPARAM_IN))
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                            pProxyParam[i].dwFlags,
                            NULL);
            if (FAILED(hr))
                goto FinishParamCreation;

            continue;
        }

        if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
        {
            if (pProxyParam[i].ulCount == 1)
            {
                MARSHALINTERFACEPARAM miparam;
                if ((IUnknown **)pProxyParam[i].pv &&
                    (*(IUnknown **)pProxyParam[i].pv))
                {
                    CicCoMarshalInterface(*pProxyParam[i].piid, 
                                      *(IUnknown **)pProxyParam[i].pv,
                                      &miparam.ulStubId,
                                      &miparam.dwStubTime,
                                      _dwStubThreadId);
                    miparam.fNULLPointer = FALSE;
                    miparam.fNULLStack = FALSE;
                }
                else
                {
                    miparam.ulStubId = 0;
                    miparam.fNULLPointer = TRUE;
                    if (!(IUnknown **)pProxyParam[i].pv)
                        miparam.fNULLStack = TRUE;
                    else
                        miparam.fNULLStack = FALSE;
                }
                hr = cparam.Add(sizeof(miparam),
                                pProxyParam[i].dwFlags,
                                &miparam);
            }
            else
            {
                MARSHALINTERFACEPARAM *pmiparam;
                pmiparam = new MARSHALINTERFACEPARAM[pProxyParam[i].ulCount];
                if (pmiparam)
                {
                    ULONG ul;
                    for (ul = 0; ul < pProxyParam[i].ulCount; ul++)
                    {
                        IUnknown **ppunk =  (IUnknown **)pProxyParam[i].pv;
                        if (ppunk && ppunk[ul])
                        {
                            CicCoMarshalInterface(*pProxyParam[i].piid, 
                                                  ppunk[ul],
                                                  &pmiparam[ul].ulStubId,
                                                  &pmiparam[ul].dwStubTime,
                                                  _dwStubThreadId);
                            pmiparam[ul].fNULLPointer = FALSE;
                            pmiparam[ul].fNULLStack = FALSE;
                        }
                        else
                        {
                            pmiparam[ul].ulStubId = 0;
                            pmiparam[ul].fNULLPointer = TRUE;
                            if (!ppunk)
                                pmiparam[ul].fNULLStack = TRUE;
                            else
                                pmiparam[ul].fNULLStack = FALSE;
                        }
                    }

                    hr = cparam.Add(sizeof(*pmiparam) * pProxyParam[i].ulCount,
                                    pProxyParam[i].dwFlags,
                                   pmiparam);
                    delete [] pmiparam;
                }
            }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                            pProxyParam[i].dwFlags,
                            pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_ULONG)
        {
            Assert(pProxyParam[i].ulCount == 1);
            hr = cparam.Add(pProxyParam[i].cbUnitSize,
                            pProxyParam[i].dwFlags,
                            &pProxyParam[i].ul);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
        {
            Assert(pProxyParam[i].ulCount == 1);
            hr = cparam.Add(pProxyParam[i].cbUnitSize,
                            pProxyParam[i].dwFlags,
                            pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_STRUCT)
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                            pProxyParam[i].dwFlags,
                            pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HICON *picon = (HICON *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HICON_UserSize(picon);
            BYTE *pBufOrg = NULL;
            BYTE *pBuf = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HICON_UserMarshal(pBuf, pBufEnd, picon))
            {
                hr = cparam.Add(cbSize,
                                pProxyParam[i].dwFlags,
                                pBuf);
                Cic_HICON_UserFree(picon);
            }
            else
            {
                hr = cparam.Add(0,
                                pProxyParam[i].dwFlags,
                                NULL);
            }

            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HBITMAP *pbmp = (HBITMAP *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HBITMAP_UserSize(pbmp);
            BYTE *pBufOrg = NULL;
            BYTE *pBuf = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HBITMAP_UserMarshal(pBuf, pBufEnd, pbmp))
            {
                hr = cparam.Add(cbSize,
                                pProxyParam[i].dwFlags,
                                pBuf);
                Cic_HBITMAP_UserFree(pbmp);
            }
            else
            {
                hr = cparam.Add(0,
                                pProxyParam[i].dwFlags,
                                NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
        {
            Assert(pProxyParam[i].ulCount == 1);
            TF_LBBALLOONINFO *pInfo = (TF_LBBALLOONINFO *)pProxyParam[i].pv;
            BYTE *pBufOrg = NULL;
            BYTE *pBuf = NULL;
            ULONG cbSize = Cic_TF_LBBALLOONINFO_UserSize(pInfo);

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
            }

            if (pBuf && Cic_TF_LBBALLOONINFO_UserMarshal(pBuf, pInfo))
            {
                hr = cparam.Add(cbSize,
                                pProxyParam[i].dwFlags,
                                pBuf);
                Cic_TF_LBBALLOONINFO_UserFree(pInfo);
            }
            else
            {
                hr = cparam.Add(0,
                                pProxyParam[i].dwFlags,
                                NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
            
        }
        else 
        {
            Assert(0);
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            Assert(0);
            goto FinishParamCreation;
        }
    }

FinishParamCreation:

    psheap->GetBlock()->GetMutex()->Leave();

    if (FAILED(hr))
    {
        Assert(0);
        goto Exit;
    }

    hr = cparam.SendReceive(this, ulBlockId);
    if (FAILED(hr))
        goto Exit;

    hrMarshalOutParam = pMsgMap->hrMarshalOutParam;
    if (hrMarshalOutParam != S_OK)
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!psheap->GetBlock()->GetMutex()->Enter())
    {
        hr = E_FAIL;
        goto Exit;
    }

    for (i = 0; i < ulParamNum; i++)
    {
        MARSHALPARAM *pParam;

        if (!(pProxyParam[i].dwFlags & MPARAM_OUT))
            continue;

        if (!pProxyParam[i].pv)
            continue;

        pParam = cparam.GetMarshalParam(i);
        hr = S_OK;

        if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        {
             if (pParam->cbBufSize)
             {
                 memcpy(pProxyParam[i].pv, 
                        ParamToBufferPointer(pParam), 
                        pProxyParam[i].GetBufSize());
             }
             else
             {
                 memset(pProxyParam[i].pv, 0, pProxyParam[i].GetBufSize());
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
        {
             MARSHALMSG *pMsg = cparam.Get();
             MARSHALINTERFACEPARAM *pmiparam = (MARSHALINTERFACEPARAM *)ParamToBufferPointer(pParam);
             ULONG ul;
             IUnknown **ppunk = (IUnknown **)pProxyParam[i].pv;
             if (ppunk)
             {
                 for (ul = 0; ul < pProxyParam[i].ulCount; ul++)
                 {
                     if (pmiparam->fNULLPointer)
                     {
                         *ppunk = NULL;

                     }
                     else
                     {
                         hr = CicCoUnmarshalInterface(*pProxyParam[i].piid,
                                                      pMsg->dwSrcThreadId, 
                                                      pmiparam->ulStubId,
                                                      pmiparam->dwStubTime,
                                                      (void **)ppunk);
                     }
                     ppunk++;
                     pmiparam++;
                 }
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
        {
             Assert(pProxyParam[i].ulCount == 1);
             if (pParam->cbBufSize)
             {
                 void *pv = ParamToBufferPointer(pParam);
                 if ((*(BSTR *)pProxyParam[i].pv = SysAllocString((BSTR)pv)) == NULL)
                 {
                     hr = E_OUTOFMEMORY;
                 }
             }
             else
             {
                 *(BSTR *)pProxyParam[i].pv = NULL;
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_STRUCT)
        {
             if (pParam->cbBufSize)
             {
                 memcpy(pProxyParam[i].pv, 
                        ParamToBufferPointer(pParam), 
                        pProxyParam[i].GetBufSize());
             }
             else
             {
                 memset(pProxyParam[i].pv, 0, pProxyParam[i].GetBufSize());
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
             Assert(pProxyParam[i].ulCount == 1);
             HICON hicon = NULL;
             if (pParam->cbBufSize)
             {
                  BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
                  Cic_HICON_UserUnmarshal(pBuf, &hicon);
             }
             *(HICON *)pProxyParam[i].pv = hicon;
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
             Assert(pProxyParam[i].ulCount == 1);
             HBITMAP hbmp = NULL;
             if (pParam->cbBufSize)
             {
                  BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
                  Cic_HBITMAP_UserUnmarshal(pBuf, &hbmp);
             }
             *(HBITMAP *)pProxyParam[i].pv = hbmp;
        }
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
        {
             Assert(pProxyParam[i].ulCount == 1);
             if (pParam->cbBufSize)
             {
                  BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
                  hr = Cic_TF_LBBALLOONINFO_UserUnmarshal(pBuf, (TF_LBBALLOONINFO *)pProxyParam[i].pv);
             }
        }
        else
        {
             Assert(0);
             hr = E_FAIL;
        }

        if (FAILED(hr))
             break;
    }

    if (SUCCEEDED(hr))
        hr = cparam.GetHresult();

    psheap->GetBlock()->GetMutex()->Leave();

Exit:
    if (pMsgMap)
        psheap->Free(pMsgMap);

    if ((cbPadMemSize == 0) && (hrMarshalOutParam == E_OUTOFMEMORY))
    {
        cbPadMemSize = cbBufSize * 2;
        cparam.Clear();
        goto TryAgain;
    }

    InternalRelease();
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CStub
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CStub::CStub()
{
    _pfm = NULL;
    _fNoRemoveInDtor = FALSE;
    _cRef = 1;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CStub::~CStub()  
{
    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (!DllShutdownInProgress())
    {
        if (_punk && !IsBadReadPtr(_punk, 1))
        {
            _try {
                _punk->Release();
                _punk = NULL;
            }     
            _except(1) 
            {
                //
                // Tips may not do DllAddRef() for LangBarItems so 
                // _punk could be bad pointer. We need to have a 
                // way to clean up CStub.
                //
                ; // TraceMsg(TF_GENERAL, "CStub punk is gone.");
            }
        }
    }

    ClearFileMap();

    if (_fNoRemoveInDtor)
    {
        //
        // we're in FreeMarshaledStubs() so we don't have to
        // remove itself. GetSYSTEMTHREAD() may not work when it is called
        // in UninitProcess().
        //
        return;
    }

    SYSTHREAD *psfn = GetSYSTHREAD();
    Assert(psfn != NULL && psfn->prgStub != NULL);
    if (psfn == NULL || psfn->prgStub == NULL)
        return;

    dbg_CheckStubIds(psfn);

    int i;
    int nCnt = psfn->prgStub->Count();
    for (i = 0; i < nCnt; i++)
    {
        if (this == psfn->prgStub->Get(i))
        {
            psfn->prgStub->Remove(i, 1);
            break;
        }
    }
}

//--------------------------------------------------------------------------
//
//  _AddRef
//
//--------------------------------------------------------------------------

ULONG CStub::_AddRef()
{
    _cRef++;
    return _cRef;
}


//--------------------------------------------------------------------------
//
//  _Release
//
//--------------------------------------------------------------------------

ULONG CStub::_Release()
{
    _cRef--;
    if (!_cRef)
    {
        delete this;
        return 0;
    }
    return _cRef;
}

//--------------------------------------------------------------------------
//
//  stub_OutParam
//
//--------------------------------------------------------------------------

HRESULT CStub::stub_OutParam(CStub *_this, MARSHALMSG *pMsg, ULONG ulMethodId, ULONG ulParamNum, CPROXY_PARAM *pProxyParam, CSharedBlock *psb)
{
    ULONG i;
    HRESULT hr = E_FAIL;

    CMarshalParamCreator cparam;

    if (!psb->GetMutex()->Enter())
    {
        Assert(0);
        return E_FAIL;
    }

    if (!CSharedHeap::IsValidBlock(psb, pMsg))
    {
        Assert(0);
        goto Exit;
    }

    if (!IsEqualIID(pMsg->iid, _this->_iid))
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->ulMethodId != ulMethodId)
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->ulParamNum != ulParamNum)
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->ulStubId != _this->_ulStubId)
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->dwStubTime != _this->_dwStubTime)
    {
        Assert(0);
        goto Exit;
    }
        
    hr = S_OK;

    cparam.Set(pMsg, pMsg->cbBufSize);
    cparam.Init(_this->_dwStubThreadId, 
                _this->_dwStubProcessId, 
                _this->_iid, 
                ulMethodId, 
                ulParamNum, 
                _this->_ulStubId,
                _this->_dwStubTime);

    for (i = 0; i < ulParamNum; i++)
    {
        if (!(pProxyParam[i].dwFlags & MPARAM_OUT))
        {
            cparam.Add(0, pProxyParam[i].dwFlags, NULL);
            continue;
        }

        if (!pProxyParam[i].pv && !(pProxyParam[i].dwFlags & MPARAM_INTERFACE))
        {
            cparam.Add(0, pProxyParam[i].dwFlags, NULL);
            continue;
        }

        if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
        {
#if 0
            MARSHALINTERFACEPARAM miparam;

            if (pProxyParam[i].pv)
            {
                CicCoMarshalInterface(*pProxyParam[i].piid, 
                                  *(IUnknown **)pProxyParam[i].pv,
                                  &miparam.ulStubId,
                                  &miparam.dwStubTime,
                                  _this->_dwSrcThreadId);
                miparam.fNULLPointer = FALSE;
            }
            else
            {
                miparam.ulStubId = 0;
                miparam.fNULLPointer = TRUE;
            }
            hr = cparam.Add(sizeof(miparam),
                       pProxyParam[i].dwFlags,
                       &miparam);

#else
            if (pProxyParam[i].ulCount == 1)
            {
                MARSHALINTERFACEPARAM miparam;
                if ((IUnknown **)pProxyParam[i].pv &&
                    (*(IUnknown **)pProxyParam[i].pv))
                {
                    CicCoMarshalInterface(*pProxyParam[i].piid, 
                                      *(IUnknown **)pProxyParam[i].pv,
                                      &miparam.ulStubId,
                                      &miparam.dwStubTime,
                                      _this->_dwSrcThreadId);
                    miparam.fNULLPointer = FALSE;
                    miparam.fNULLStack = FALSE;
                }
                else
                {
                    miparam.ulStubId = 0;
                    miparam.fNULLPointer = TRUE;
                    if (!(IUnknown **)pProxyParam[i].pv)
                        miparam.fNULLStack = TRUE;
                    else
                        miparam.fNULLStack = FALSE;
                }
                hr = cparam.Add(sizeof(miparam),
                           pProxyParam[i].dwFlags,
                           &miparam);
            }
            else
            {
                MARSHALINTERFACEPARAM *pmiparam;
                pmiparam = new MARSHALINTERFACEPARAM[pProxyParam[i].ulCount];
                if (pmiparam)
                {
                    ULONG ul;
                    for (ul = 0; ul < pProxyParam[i].ulCount; ul++)
                    {
                        IUnknown **ppunk =  (IUnknown **)pProxyParam[i].pv;
                        if (ppunk && ppunk[ul])
                        {
                            CicCoMarshalInterface(*pProxyParam[i].piid, 
                                                  ppunk[ul],
                                                  &pmiparam[ul].ulStubId,
                                                  &pmiparam[ul].dwStubTime,
                                                  _this->_dwSrcThreadId);
                            pmiparam[ul].fNULLPointer = FALSE;
                            pmiparam[ul].fNULLStack = FALSE;
                        }
                        else
                        {
                            pmiparam[ul].ulStubId = 0;
                            pmiparam[ul].fNULLPointer = TRUE;
                            if (!ppunk)
                                pmiparam[ul].fNULLStack = TRUE;
                            else
                                pmiparam[ul].fNULLStack = FALSE;
                        }
                    }

                    hr = cparam.Add(sizeof(*pmiparam) * pProxyParam[i].ulCount,
                               pProxyParam[i].dwFlags,
                               pmiparam);
                    delete [] pmiparam;
                }
            }
#endif
        }
        else if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                       pProxyParam[i].dwFlags,
                       pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_ULONG)
        {
            Assert(pProxyParam[i].ulCount == 1);
            hr = cparam.Add(pProxyParam[i].cbUnitSize,
                       pProxyParam[i].dwFlags,
                       &pProxyParam[i].ul);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
        {
            Assert(pProxyParam[i].ulCount == 1);
            if (pProxyParam[i].pv)
            {
                hr = cparam.Add(SysStringByteLen((BSTR)pProxyParam[i].pv) + 2, 
                           pProxyParam[i].dwFlags,
                           pProxyParam[i].pv);
                SysFreeString((BSTR)pProxyParam[i].pv);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HICON *picon = (HICON *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HICON_UserSize(picon);
            BYTE *pBuf = NULL;
            BYTE *pBufOrg = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HICON_UserMarshal(pBuf, pBufEnd, picon))
            {
                hr = cparam.Add(cbSize,
                           pProxyParam[i].dwFlags,
                           pBuf);
                Cic_HICON_UserFree(picon);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HBITMAP *pbmp = (HBITMAP *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HBITMAP_UserSize(pbmp);
            BYTE *pBuf = NULL;
            BYTE *pBufOrg = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HBITMAP_UserMarshal(pBuf, pBufEnd, pbmp))
            {
                hr = cparam.Add(cbSize,
                           pProxyParam[i].dwFlags,
                           pBuf);
                Cic_HBITMAP_UserFree(pbmp);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
        {
            Assert(pProxyParam[i].ulCount == 1);
            TF_LBBALLOONINFO *pInfo = (TF_LBBALLOONINFO *)pProxyParam[i].pv;
            ULONG cbSize = Cic_TF_LBBALLOONINFO_UserSize(pInfo);
            BYTE *pBuf = NULL;
            BYTE *pBufOrg = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
            }

            if (pBuf && Cic_TF_LBBALLOONINFO_UserMarshal(pBuf, pInfo))
            {
                hr = cparam.Add(cbSize,
                           pProxyParam[i].dwFlags,
                           pBuf);
                Cic_TF_LBBALLOONINFO_UserFree(pInfo);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else 
            Assert(0);

 
        if (hr != S_OK)
        {
            break;
        }
    }
    
Exit:
    pMsg->hrMarshalOutParam = hr;

    psb->GetMutex()->Leave();

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// TF_CCheckThreadInputIdle
//
//////////////////////////////////////////////////////////////////////////////

extern "C" DWORD WINAPI TF_CheckThreadInputIdle(DWORD dwThreadId, DWORD dwTimeOut)
{
    if (dwThreadId == GetCurrentThreadId())
        return 0;

    HWND hwndTemp = CThreadMarshalWnd::GetThreadMarshalWnd(dwThreadId);
    if (!hwndTemp)
    {
        return WAIT_FAILED;
    }


    DWORD dwTime = GetTickCount();
    CCheckThreadInputIdle event(dwThreadId, dwTime);
    CCicSecAttr sa;

    if (!event.Create(sa))
    {
        Assert(0);
        return WAIT_FAILED;
    }

    PostMessage(hwndTemp, g_msgCheckThreadInputIdel, 0, (LPARAM)dwTime);
    
    DWORD dwReason = event.EventCheck();
    if (dwReason == WAIT_OBJECT_0)
        return 0;

    if (event.Wait(dwTimeOut))
        return 0;

    return WAIT_TIMEOUT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\lqueue.cpp ===
//
// lqueue.cpp
//
// Lock queue code.
//

#include "private.h"
#include "ic.h"
#include "tim.h"
#include "dim.h"

//+---------------------------------------------------------------------------
//
// _EditSessionQiCallback
//
//----------------------------------------------------------------------------

HRESULT CAsyncQueueItem::_EditSessionQiCallback(CInputContext *pic, struct _TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode)
{
    switch (qiCode)
    {
        case QI_ADDREF:
            pItem->state.aqe.paqi->_AddRef();
            break;

        case QI_DISPATCH:
            return pItem->state.aqe.paqi->DoDispatch(pic);

        case QI_FREE:
            pItem->state.aqe.paqi->_Release();
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CheckReadOnly
//
//----------------------------------------------------------------------------

void CAsyncQueueItem::_CheckReadOnly(CInputContext *pic)
{
    TS_STATUS dcs;
    if (SUCCEEDED(pic->GetStatus(&dcs)))
    {
        if (dcs.dwDynamicFlags & TF_SD_READONLY)
            _item.dwFlags &= ~TF_ES_WRITE;
    }
}

//+---------------------------------------------------------------------------
//
// _QueueItem
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_QueueItem(TS_QUEUE_ITEM *pItem, BOOL fForceAsync, HRESULT *phrSession)
{
    TS_QUEUE_ITEM *pQueueItem;
    int iItem;
    HRESULT hr;
    HRESULT hrRet;
    BOOL fSync;
    BOOL fNeedWriteLock;
    BOOL fSyncLockFailed = FALSE;

    if (pItem->dwFlags & TF_ES_WRITE)
    {
        // write access implies property write access
        pItem->dwFlags |= TF_ES_PROPERTY_WRITE;
    }

    fSync = (pItem->dwFlags & TF_ES_SYNC);

    Assert(!(fSync && fForceAsync)); // doesn't make sense
    
    fNeedWriteLock = _fLockHeld ? (pItem->dwFlags & TF_ES_WRITE) && !(_dwlt & TF_ES_WRITE) : FALSE;

    if (fForceAsync)
        goto QueueItem;

    if (!fSync &&
        _rgLockQueue.Count() > 0)
    {
        // there's already something in the queue
        // so we can't handle an async request until later
        fForceAsync = TRUE;
        goto QueueItem;
    }

    if (_fLockHeld)
    {
        if (fSync)
        {
            // sync
            // we can't handle a sync write req while holding a read lock
            *phrSession = fNeedWriteLock ? TF_E_SYNCHRONOUS : _DispatchQueueItem(pItem);
        }
        else
        {
            // async
            if (fNeedWriteLock)
            {
                // we need a write lock we don't currently hold
                fForceAsync = TRUE;
                goto QueueItem;
            }

            *phrSession = _DispatchQueueItem(pItem);
        }

        return S_OK;
    }

QueueItem:
    if ((pQueueItem = _rgLockQueue.Append(1)) == NULL)
    {
        *phrSession = E_FAIL;
        return E_OUTOFMEMORY;
    }

    *pQueueItem = *pItem;
    _AddRefQueueItem(pQueueItem);

    hrRet = S_OK;
    *phrSession = TF_S_ASYNC;

    if (!fForceAsync)
    {
        Assert(!_fLockHeld);

        _fLockHeld = TRUE;
        _dwlt = pItem->dwFlags;

        hrRet = SafeRequestLock(_ptsi, pItem->dwFlags & ~TF_ES_PROPERTY_WRITE, phrSession);

        _fLockHeld = FALSE;

        // possibly this was a synch request, but the app couldn't grant it
        // now we need to make sure the queue item is cleared
        if ((iItem = _rgLockQueue.Count() - 1) >= 0)
        {
            TS_QUEUE_ITEM *pItemTemp;
            pItemTemp = _rgLockQueue.GetPtr(iItem);
            if (pItemTemp->dwFlags & TF_ES_SYNC)
            {
                Assert(*phrSession == TS_E_SYNCHRONOUS); // only reason why item is still in queue should be app lock rejection

                _ReleaseQueueItem(pItemTemp);
                _rgLockQueue.Remove(iItem, 1);

                fSyncLockFailed = TRUE;
            }
        }

        if (_ptsi == NULL)
        {
            // someone popped this ic during the RequestLock above
            goto Exit;
        }
    }

    // make sure synchronous edit session gets cleared off the queue no matter what after the lock request!
    _Dbg_AssertNoSyncQueueItems();

    // this shouldn't go reentrant, but just to be safe do it last
    if (_fLockHeld)
    {
        if (fForceAsync && fNeedWriteLock)
        {
            SafeRequestLock(_ptsi, TS_LF_READWRITE, &hr); // Issue: try to recover if app goes reentrant?
            Assert(hr == TS_S_ASYNC); // app should have granted this async
        }
    }
    else if (!fSyncLockFailed)
    {
        // we don't hold a lock currently
        if (fForceAsync || (fSync && _rgLockQueue.Count() > 0))
        {
            // ask for another lock later, if there are pending async items in the queue
            _PostponeLockRequest(pItem->dwFlags);
        }
    }

Exit:
    return hrRet;
}

//+---------------------------------------------------------------------------
//
// _EmptyLockQueue
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_EmptyLockQueue(DWORD dwLockFlags, BOOL fAppChangesSent)
{
    TS_QUEUE_ITEM *pItem;
    TS_QUEUE_ITEM item;
    int iItem;
    HRESULT hr;

    Assert(_fLockHeld); // what are we doing emptying the queue without a lock?!

    if ((iItem = _rgLockQueue.Count() - 1) < 0)
        return S_OK;

    //
    // special case: there may be a single synchronous es at the end of the queue
    //

    pItem = _rgLockQueue.GetPtr(iItem);

    if (pItem->dwFlags & TF_ES_SYNC)
    {
        item = *pItem;
        _rgLockQueue.Remove(iItem, 1);

        if (fAppChangesSent)
        {
            Assert(0); // this is suspicious...the app should not let this happen.
                       // What's happened: the app had some pending changes, but hadn't responed to
                       // our lock requests yet.  Then some TIP asked for a sync lock, which we just got.
                       // Normally, it is unlikely that an app would still have pending changes by the time
                       // a tip fires off -- the app should clear any pending changes before starting a
                       // transaction like a key event or reconversion.  However, another possibility is
                       // that a rogue TIP is using the sync flag for a private event, which is discouraged
                       // because it could fail here.
            // in any case, we won't continue until the app changes have been dealt with...must back out with an error.
            return E_UNEXPECTED;
        }

        if ((item.dwFlags & TF_ES_WRITE) && !(dwLockFlags & TF_ES_WRITE))
        {
            Assert(0); // app granted wrong access?
            return E_UNEXPECTED;
        }
        Assert(!(item.dwFlags & TF_ES_WRITE) || (item.dwFlags & TF_ES_PROPERTY_WRITE)); // write implies property write

        hr = _DispatchQueueItem(&item);
        _ReleaseQueueItem(&item);

        return hr;
    }

    //
    // handle any asynch requests
    //

    while (_rgLockQueue.Count() > 0)
    {
        pItem = _rgLockQueue.GetPtr(0);

        Assert(!(pItem->dwFlags & TF_ES_SYNC)); // should never see synch item here!

        // make sure the lock we've been given is good enough for the queued es
        if ((pItem->dwFlags & TF_ES_WRITE) && !(dwLockFlags & TF_ES_WRITE))
        {
            // ask for an upgrade anyways, to try to recover
            SafeRequestLock(_ptsi, TS_LF_READWRITE, &hr); // Issue: try to recover if app goes reentrant?
            Assert(hr == TS_S_ASYNC); // app should have granted this async
            break;
        }

        item = *pItem;
        _rgLockQueue.Remove(0, 1);
        _DispatchQueueItem(&item);
        _ReleaseQueueItem(&item);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _AbortQueueItems
//
//----------------------------------------------------------------------------

void CInputContext::_AbortQueueItems()
{
    TS_QUEUE_ITEM *pItem;
    int i;

    for (i=0; i<_rgLockQueue.Count(); i++)
    {
        pItem = _rgLockQueue.GetPtr(i);

        Assert(!(pItem->dwFlags & TF_ES_SYNC)); // should never see synch item here!

        _ReleaseQueueItem(pItem);
    }

    _rgLockQueue.Clear();

    if (_dwPendingLockRequest)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();

        if (psfn)
            psfn->_dwLockRequestICRef--;

        _dwPendingLockRequest = 0;
    }
}

//+---------------------------------------------------------------------------
//
// _PostponeLockRequest
//
//----------------------------------------------------------------------------

void CInputContext::_PostponeLockRequest(DWORD dwFlags)
{
    dwFlags &= TF_ES_READWRITE;

    Assert(dwFlags != 0);

    // we don't need to upgrade the req because we can do that inside the
    // lock grant more efficiently
    if (_dwPendingLockRequest == 0)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();

        if (!psfn)
            return;
   
        if (!_nLockReqPostDisableRef && !psfn->_fLockRequestPosted)
        {
            if (!PostThreadMessage(GetCurrentThreadId(), g_msgPrivate, TFPRIV_LOCKREQ, 0))
            {
                return;
            }

            psfn->_fLockRequestPosted = TRUE;
        }

        psfn->_dwLockRequestICRef++;
    }

    _dwPendingLockRequest |= dwFlags;
}


//+---------------------------------------------------------------------------
//
// _PostponeLockRequestCallback
//
//----------------------------------------------------------------------------

/* static */
void CInputContext::_PostponeLockRequestCallback(SYSTHREAD *psfn, CInputContext *pic)
{
    CThreadInputMgr *tim;
    CDocumentInputManager *dim;
    int iDim;
    int iContext;
    DWORD dwFlags;
    HRESULT hr;

    Assert(psfn);


    if (!psfn->_dwLockRequestICRef)
        return;

    // need to verify pic is still valid
    tim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!tim)
        return;

    for (iDim = 0; iDim < tim->_rgdim.Count(); iDim++)
    {
        dim = tim->_rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            CInputContext *picCur = dim->_GetIC(iContext);
            if (!pic || (picCur == pic))
            {
                // we found this ic, it's valid
                dwFlags = picCur->_dwPendingLockRequest;
                if (dwFlags)
                {
                    picCur->_dwPendingLockRequest = 0;

                    Assert(psfn->_dwLockRequestICRef > 0);
                    psfn->_dwLockRequestICRef--;

                    SafeRequestLock(picCur->_ptsi, dwFlags, &hr);
                }

                if (pic)
                    return;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
// EnableLockRequestPosting
//
//----------------------------------------------------------------------------

HRESULT CInputContext::EnableLockRequestPosting(BOOL fEnable)
{
    if (!fEnable)
    {
       _nLockReqPostDisableRef++;
    }
    else
    {
       if (_nLockReqPostDisableRef > 0)
           _nLockReqPostDisableRef--;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\memcache.cpp ===
//
// memcache.cpp
//

#include "private.h"
#include "memcache.h"

LONG g_lMemCacheMutex = -1;

//+---------------------------------------------------------------------------
//
// MemCache_New
//
//----------------------------------------------------------------------------

MEMCACHE *MemCache_New(ULONG uMaxPtrs)
{
    MEMCACHE *pmc;
    ULONG uSize;

    Assert(uMaxPtrs > 0);

    uSize = sizeof(MEMCACHE) + uMaxPtrs*sizeof(void *) - sizeof(void *);

    if ((pmc = (MEMCACHE *)cicMemAlloc(uSize)) == NULL)
        return NULL;

    pmc->uMaxPtrs = uMaxPtrs;
    pmc->iNextFree = 0;

    return pmc;
}

//+---------------------------------------------------------------------------
//
// MemCache_Delete
//
//----------------------------------------------------------------------------

void MemCache_Delete(MEMCACHE *pMemCache)
{ 
    while (pMemCache->iNextFree > 0)
    {
        cicMemFree(pMemCache->rgPtrs[--pMemCache->iNextFree]);
    }
    cicMemFree(pMemCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\ksmgr.cpp ===
//
// ksmgr.cpp
//

#include "private.h"
#include "dim.h"
#include "tim.h"
#include "ic.h"
#include "computil.h"

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncProcessKeyQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncProcessKeyQueueItem : public CAsyncQueueItem
{
public:
    CAsyncProcessKeyQueueItem(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten) : CAsyncQueueItem(dwFlags & TIM_AKH_SYNC ? TRUE : FALSE)
    {
        _wParam = wParam;
        _lParam = lParam;
        if ((dwFlags & TIM_AKH_SYNC) && pfEaten)
            _pfEaten = pfEaten;
        else
        {
            if (pfEaten)
                *pfEaten = TRUE;

            _pfEaten = &_fEaten;
        }

        _dwFlags = dwFlags;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
        if (!ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        if (HIWORD(_lParam) & KF_UP)
        {
            ptim->TestKeyUp(_wParam, _lParam, _pfEaten);
            if (*_pfEaten && !(_dwFlags & TIM_AKH_TESTONLY))
                ptim->KeyUp(_wParam, _lParam, _pfEaten);
        }
        else
        {
            ptim->TestKeyDown(_wParam, _lParam, _pfEaten);
            if (*_pfEaten && !(_dwFlags & TIM_AKH_TESTONLY))
                ptim->KeyDown(_wParam, _lParam, _pfEaten);
        }

        //
        // We needs to simulate keydown message because
        // we might return *pfEaten = TRUE;
        //    When it is async,
        //    When it was not eaten by keystroke mgr.
        //    When it has TIM_AKH_SIMULATEKEYMSG
        //
        if (!(_dwFlags & TIM_AKH_SYNC) &&
            !*_pfEaten && 
            (_dwFlags & TIM_AKH_SIMULATEKEYMSGS))
        {
            UINT uMsg = WM_KEYDOWN;

            // key up msg?
            if (HIWORD(_lParam) & KF_UP)
                uMsg++;

            // sys key msg?
            if (HIWORD(_lParam) & (KF_MENUMODE | KF_ALTDOWN))
                uMsg |= 0x04;

            PostMessage(GetFocus(), uMsg, _wParam, _lParam);
        }

        return S_OK;
    }

private:
    WPARAM _wParam;
    LPARAM _lParam;
    BOOL *_pfEaten;
    BOOL _fEaten;
    BOOL _dwFlags;
};

//+---------------------------------------------------------------------------
//
// _AsyncKeyHandler
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_AsyncKeyHandler(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten)
{
    CAsyncProcessKeyQueueItem *pAsyncProcessKeyQueueItem;
    BOOL bRet;
    HRESULT hr;

    if (!_pFocusDocInputMgr)
        return FALSE;

    if (_pFocusDocInputMgr->_GetCurrentStack() < 0)
        return FALSE;

    //
    // Issue:
    //
    // We don't know which IC in the focus DIM will handle the hotkey yet.
    // because the selection is changed by the application so we need to get ec
    // to update the current selection pos. We do call GetSelection
    // inside the root IC's lock. So it might be failed if hotkey's target
    // is TOP IC.
    //
    CInputContext *pic = _pFocusDocInputMgr->_GetIC(0);

    pAsyncProcessKeyQueueItem = new CAsyncProcessKeyQueueItem(wParam, lParam, dwFlags, pfEaten);
    if (!pAsyncProcessKeyQueueItem)
        return FALSE;
    
    hr = S_OK;

    bRet = TRUE;
    if ((pic->_QueueItem(pAsyncProcessKeyQueueItem->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
    {
        Assert(0);
        bRet = FALSE;
    }

    pAsyncProcessKeyQueueItem->_Release();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseKeyEventSink(TfClientId tid, ITfKeyEventSink *pSink, BOOL fForeground)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (ctip->_pKeyEventSink != NULL)
        return CONNECT_E_ADVISELIMIT;

    ctip->_pKeyEventSink = pSink;
    ctip->_pKeyEventSink->AddRef();
    ctip->_fForegroundKeyEventSink = fForeground;

    //
    // overwrite the foreground tip.
    //
    if (fForeground)
        _SetForeground(tid);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseKeyEventSink(TfClientId tid)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (ctip->_pKeyEventSink == NULL)
        return CONNECT_E_NOCONNECTION;

    SafeReleaseClear(ctip->_pKeyEventSink);

    if (_tidForeground == tid)
    {
        _SetForeground(TF_INVALID_GUIDATOM);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// GetForeground
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetForeground(CLSID *pclsid)
{
    if (!pclsid)
        return E_INVALIDARG;

    *pclsid = GUID_NULL;

    if (_tidForeground == TF_INVALID_GUIDATOM)
        return S_FALSE;

    return MyGetGUID(_tidForeground, pclsid);
}

//+---------------------------------------------------------------------------
//
// SetForeground
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_SetForeground(TfClientId tid)
{
    HRESULT hr;
    CTip *ctip;
    CTip *ctipForeground;

    ctip = NULL;

    if (tid != TF_INVALID_GUIDATOM)
    {
        _GetCTipfromGUIDATOM(tid, &ctip);
    }

    if (ctip)
    {
        if (ctip->_pKeyEventSink == NULL || !ctip->_fForegroundKeyEventSink)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }
    }
             
    hr = S_OK;

    if (_tidForeground != TF_INVALID_GUIDATOM)
    {
        if (_tidForeground == tid)
            goto Exit;

        _GetCTipfromGUIDATOM(_tidForeground, &ctipForeground);
        Assert(ctipForeground != NULL);

        if (ctipForeground->_pKeyEventSink != NULL) // might be NULL if we got here from ITfKeyEventMgr::Unadvise
        {
            ctipForeground->_pKeyEventSink->OnSetFocus(FALSE);
        }

        _tidForeground = 0;
    }

    if (ctip != NULL)
    {
        if (ctip->_pKeyEventSink == NULL || !ctip->_fForegroundKeyEventSink)
        {
            // highly unlikely, but the tip Unadvise'd when we called OnSetFocus(FALSE) on the old foreground tip
            hr = E_FAIL;
            goto Exit;
        }

        _tidForeground = tid;

        ctip->_pKeyEventSink->OnSetFocus(TRUE);
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// TestKeyDown
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::TestKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_StartStroke(PERF_STROKE_TESTDOWN);

    hr = _KeyStroke(KS_DOWN_TEST, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_TESTDOWN);

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyDown
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::KeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_IncCounter(PERF_KEYDOWN_COUNT);
    Perf_StartStroke(PERF_STROKE_DOWN);

    hr = _KeyStroke(KS_DOWN, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_DOWN);

    return hr;
}

//+---------------------------------------------------------------------------
//
// TestKeyUp
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::TestKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_StartStroke(PERF_STROKE_TESTUP);

    hr = _KeyStroke(KS_UP_TEST, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_TESTUP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyUp
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::KeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_StartStroke(PERF_STROKE_UP);

    hr = _KeyStroke(KS_UP, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_UP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyDownUpEx
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::KeyDownUpEx(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten)
{
    HRESULT hr;

    if (HIWORD(lParam) & KF_UP)
    {
        if (dwFlags & TF_KEY_TEST)
        {
            Perf_StartStroke(PERF_STROKE_TESTUP);
            hr = _KeyStroke(KS_UP_TEST, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_TESTUP);
        }
        else
        {
            Perf_StartStroke(PERF_STROKE_UP);
            hr = _KeyStroke(KS_UP, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_UP);
        }
    }
    else
    {
        if (dwFlags & TF_KEY_TEST)
        {
            Perf_StartStroke(PERF_STROKE_TESTDOWN);
            hr = _KeyStroke(KS_DOWN_TEST, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_TESTDOWN);
        }
        else
        {
            Perf_IncCounter(PERF_KEYDOWN_COUNT);
            Perf_StartStroke(PERF_STROKE_DOWN);
            hr = _KeyStroke(KS_DOWN, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_DOWN);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyStroke
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_KeyStroke(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, BOOL fSync, DWORD dwFlags)
{
    CInputContext *pic;
    int iStack;
    HRESULT hr;
    ITfDocumentMgr *pdim;
    int i;

    if (pfEaten == NULL)
        return E_INVALIDARG;

    hr = S_OK;
    *pfEaten = FALSE;

    if (_pFocusDocInputMgr == NULL) // no focus ic?
    {
        return S_OK;
    }

    pdim = _GetFocusDocInputMgr();

    if (!(dwFlags & TF_KEY_INTERNAL))
    {
        if (!(dwFlags & TF_KEY_MSCTFIME) && (pdim && _IsMsctfimeDim(pdim)))
        {
            return S_OK;
        }
    }

    if (_CheckPreservedKey(ksenum, wParam, lParam, fSync))
    {
        *pfEaten = TRUE;
        return S_OK;
    }

    iStack = _pFocusDocInputMgr->_GetCurrentStack();

    if (iStack < 0)
        goto Exit;

    while (iStack >= 0)
    {
        pic = _pFocusDocInputMgr->_GetIC(iStack);

        pic->_UpdateKeyEventFilter();

        // try left/right side of the selection.
        for (i=LEFT_FILTERTIP; i<=RIGHT_FILTERTIP; i++)
        {
            hr = _CallKeyEventSinkNotForeground(pic->_gaKeyEventFilterTIP[i], 
                                                pic, ksenum, wParam, lParam, pfEaten);

            if (hr == S_OK && *pfEaten)
                goto Exit;

            // _CallKeyEventSinkNotForeground returns "error" codes on valid input
            // this just means, keep going
            hr = S_OK; // keep trying other sinks if there's an error
            *pfEaten = FALSE;

            if (_pFocusDocInputMgr->_GetCurrentStack() < iStack)
                goto NextIC;
        }

        // try foreground tip.
        if (_tidForeground != TF_INVALID_GUIDATOM)
        {
            hr = _CallKeyEventSink(_tidForeground, 
                                   pic, ksenum, wParam, lParam, pfEaten);

            if (hr == S_OK && *pfEaten)
                break;

            hr = S_OK; // keep trying other sinks if there's an error
            *pfEaten = FALSE;

            if (_pFocusDocInputMgr == NULL)
            {
                // this can happen if the app is buggy and switches the focus
                // inside a SetText or whatever call (perhaps to bring up an
                // error dialog, etc.).
                hr = E_UNEXPECTED;
                goto Exit;
            }

            if (_pFocusDocInputMgr->_GetCurrentStack() < iStack)
               goto NextIC;
        }

        if (pic->_pICKbdSink)
        {
            switch (ksenum)
            {
                case KS_DOWN:
                    hr = pic->_pICKbdSink->OnKeyDown(wParam, lParam, pfEaten);
                    break;
                case KS_UP:
                    hr = pic->_pICKbdSink->OnKeyUp(wParam, lParam, pfEaten);
                    break;
                case KS_DOWN_TEST:
                    hr = pic->_pICKbdSink->OnTestKeyDown(wParam, lParam, pfEaten);
                    break;
                case KS_UP_TEST:
                    hr = pic->_pICKbdSink->OnTestKeyUp(wParam, lParam, pfEaten);
                    break;
            }

            if (hr == S_OK && *pfEaten)
                break;

            hr = S_OK; // keep trying other sinks if there's an error
            *pfEaten = FALSE;
        }

NextIC:
        iStack--;
        if (_pFocusDocInputMgr->_GetCurrentStack() < iStack)
        {
            iStack  = _pFocusDocInputMgr->_GetCurrentStack();
        }
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// CallKeyEventSinkNotForeground
//
//----------------------------------------------------------------------------
HRESULT CThreadInputMgr::_CallKeyEventSinkNotForeground(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    CTip *ctip;

    if (tid == _tidForeground)
        return E_INVALIDARG;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (ctip->_fForegroundKeyEventSink ||
        ctip->_pKeyEventSink == NULL)
    {
        return E_INVALIDARG;
    }

    return _CallKeyEventSink(tid, pic, ksenum, wParam, lParam, pfEaten);
}

//+---------------------------------------------------------------------------
//
// CallKeyEventSink
//
//----------------------------------------------------------------------------


HRESULT CThreadInputMgr::_CallKeyEventSink(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    ITfKeyEventSink *pSink;
    CTip *ctip;
    HRESULT hr;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (!(pSink = ctip->_pKeyEventSink))
        return S_FALSE;

    switch (ksenum)
    {
        case KS_DOWN:
            hr = pSink->OnKeyDown(pic, wParam, lParam, pfEaten);
            break;
        case KS_DOWN_TEST:
            hr = pSink->OnTestKeyDown(pic, wParam, lParam, pfEaten);
            break;
        case KS_UP:
            hr = pSink->OnKeyUp(pic, wParam, lParam, pfEaten);
            break;
        case KS_UP_TEST:
            hr = pSink->OnTestKeyUp(pic, wParam, lParam, pfEaten);
            break;
        default:
            Assert(0);
            hr = E_FAIL;
            break;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CheckPreservedKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_CheckPreservedKey(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL fSync)
{
    BOOL bRet = FALSE;
    switch (ksenum)
    {
        case KS_DOWN:
            if (!(lParam & 0x80000000))
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, FALSE, fSync);
            break;
        case KS_DOWN_TEST:
            if (!(lParam & 0x80000000))
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, TRUE, fSync);
            break;
        case KS_UP:
            if (lParam & 0x80000000)
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, FALSE, fSync);
            break;
        case KS_UP_TEST:
            if (lParam & 0x80000000)
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, TRUE, fSync);
            break;
        default:
            Assert(0);
            break;
    }

    return bRet;
}


//+---------------------------------------------------------------------------
//
// _NotifyKeyTraceEventSink
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_NotifyKeyTraceEventSink(WPARAM wParam, LPARAM lParam)
{
    CStructArray<GENERICSINK> *rgKeyTraceEventSinks;
    int i;

    rgKeyTraceEventSinks = _GetKeyTraceEventSinks();

    for (i=0; i<rgKeyTraceEventSinks->Count(); i++)
    {
        if (lParam & 0x80000000)
            ((ITfKeyTraceEventSink *)rgKeyTraceEventSinks->GetPtr(i)->pSink)->OnKeyTraceUp(wParam, lParam);
        else
            ((ITfKeyTraceEventSink *)rgKeyTraceEventSinks->GetPtr(i)->pSink)->OnKeyTraceDown(wParam, lParam);
    }
}


//+---------------------------------------------------------------------------
//
// _IsMsctfimeDim
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_IsMsctfimeDim(ITfDocumentMgr *pdim)
{
    // Get GUID_COMPARTMENT_CTFIME_DIMFLAGS from ..\msctfime\globals.cpp
    const GUID GUID_COMPARTMENT_CTFIME_DIMFLAGS = {0xa94c5fd2, 0xc471, 0x4031, {0x95, 0x46, 0x70, 0x9c, 0x17, 0x30, 0x0c, 0xb9}};

    HRESULT hr;
    DWORD dwFlags;

    hr = GetCompartmentDWORD(pdim, GUID_COMPARTMENT_CTFIME_DIMFLAGS,
                             &dwFlags, FALSE);
                
    if (SUCCEEDED(hr))
    {
        // Check COMPDIMFLAG_OWNEDDIM(0x0001).
        return (dwFlags & 0x0001) ? TRUE : FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\marshal.h ===
//
// marshal.h
//

#ifndef MARSHAL_H
#define MARSHAL_H

#include "private.h"
#include "globals.h"
#include "cicmutex.h"
#include "winuserp.h"
#include "systhrd.h"
#include "smblock.h"
#include "cregkey.h"

#define DEFAULTMARSHALTIMEOUT 30000
#define DEFAULTMARSHALCONNECTIONTIMEOUT 2000


#ifdef QS_RAWINPUT
#define QS_ALLINPUT400  (QS_ALLINPUT & ~QS_RAWINPUT)
#else
#define QS_ALLINPUT400  (QS_ALLINPUT)
#endif
#define QS_DEFAULTWAITFLAG (QS_ALLINPUT400 | QS_TRANSFER | QS_ALLPOSTMESSAGE)

#ifdef DEBUG
extern ULONG g_ulMarshalTimeOut;
#define MARSHALTIMEOUT g_ulMarshalTimeOut


const TCHAR c_szMarshal[] = TEXT("SOFTWARE\\Microsoft\\CTF\\Marshal\\");
const TCHAR c_szTimeOut[] = TEXT("TimeOut");
__inline void dbg_InitMarshalTimeOut()
{
    CMyRegKey key;
    DWORD dw;

    if (key.Open(HKEY_CURRENT_USER, c_szMarshal, KEY_READ) != S_OK)
       return;

    if (key.QueryValue(dw, c_szTimeOut) != S_OK)
       return;

    g_ulMarshalTimeOut = (ULONG)dw;
}

#else
#define MARSHALTIMEOUT DEFAULTMARSHALTIMEOUT
#define dbg_InitMarshalTimeOut()
#endif

#define SZMARSHALINTERFACEFILEMAP __TEXT("MSCTF.MarshalInterface.FileMap.")
#define SZRPCSENDRECEIVEEVENT     __TEXT("MSCTF.SendReceive.Event.")
#define SZRPCSENDRECEIVECONNECTIONEVENT     __TEXT("MSCTF.SendReceiveConection.Event.")

HRESULT CicCoMarshalInterface(REFIID riid, IUnknown *punk, ULONG *pulStubId, DWORD *pdwStubTime, DWORD dwSrcThreadId);
HRESULT CicCoUnmarshalInterface(REFIID riid, DWORD dwStubThreadId, ULONG ulStubId, DWORD dwStubTIme, void **ppv);
void HandleSendReceiveMsg(DWORD dwSrcThreadId, ULONG ulCnt);

void FreeMarshaledStubs(SYSTHREAD *psfn);
void FreeMarshaledStubsForThread(SYSTHREAD *psfn, DWORD dwThread);
void StubCleanUp(ULONG ulStubId);

//////////////////////////////////////////////////////////////////////////////
//
// MARSHALINTERFACE structure
//
//////////////////////////////////////////////////////////////////////////////

typedef struct tag_MARSHALINTERFACE 
{
    IID       iid;
    DWORD     dwStubTime;
} MARSHALINTERFACE;

//////////////////////////////////////////////////////////////////////////////
//
// MARSHALPARAM structure
//
//////////////////////////////////////////////////////////////////////////////

#define MPARAM_IN               0x000000001
#define MPARAM_OUT              0x000000002
#define MPARAM_INTERFACE        0x000010000
#define MPARAM_POINTER          0x000020000
#define MPARAM_ULONG            0x000040000
#define MPARAM_BSTR             0x000080000
#define MPARAM_STRUCT           0x000100000
#define MPARAM_HBITMAP          0x000200000
#define MPARAM_TF_LBBALLOONINFO      0x000400000
#define MPARAM_HICON            0x000800000

#define MPARAM_IN_POINTER         (MPARAM_IN | MPARAM_POINTER)
#define MPARAM_IN_INTERFACE       (MPARAM_IN | MPARAM_INTERFACE)
#define MPARAM_IN_ULONG           (MPARAM_IN | MPARAM_ULONG)
#define MPARAM_IN_STRUCT          (MPARAM_IN | MPARAM_STRUCT)
#define MPARAM_IN_HBITMAP         (MPARAM_IN | MPARAM_HBITMAP)
#define MPARAM_IN_HICON           (MPARAM_IN | MPARAM_HICON)

#define MPARAM_OUT_POINTER        (MPARAM_OUT | MPARAM_POINTER)
#define MPARAM_OUT_INTERFACE      (MPARAM_OUT | MPARAM_INTERFACE)
#define MPARAM_OUT_BSTR           (MPARAM_OUT | MPARAM_BSTR)
#define MPARAM_OUT_HBITMAP        (MPARAM_OUT | MPARAM_HBITMAP)
#define MPARAM_OUT_TF_LBBALLOONINFO    (MPARAM_OUT | MPARAM_TF_LBBALLOONINFO)
#define MPARAM_OUT_HICON          (MPARAM_OUT | MPARAM_HICON)

#define MPARAM_IN_OUT_INTERFACE   (MPARAM_IN | MPARAM_OUT | MPARAM_INTERFACE)

typedef struct tag_MARSHALPARAM 
{
    ULONG     cbBufSize;
    DWORD     dwFlags;
    // DWORD     buf[1];
} MARSHALPARAM;

typedef struct tag_MARSHALMSG
{
    ULONG        cbSize;
    ULONG        cbBufSize;
    IID          iid;
    ULONG        ulMethodId;
    ULONG        ulParamNum;
    union {
        HRESULT      hrRet;
        ULONG        ulRet;
    };
    DWORD        dwSrcThreadId;
    DWORD        dwSrcProcessId;
    ULONG        ulStubId;
    DWORD        dwStubTime;
    HRESULT      hrMarshalOutParam;
    ULONG        ulParamOffset[1];
} MARSHALMSG;

__inline MARSHALPARAM *GetMarshalParam(MARSHALMSG *pMsg, ULONG ulParam)
{
    return (MARSHALPARAM *)(((BYTE *)pMsg) + pMsg->ulParamOffset[ulParam]);
}


//////////////////////////////////////////////////////////////////////////////
//
// ParamExtractor
//
//////////////////////////////////////////////////////////////////////////////


__inline void *ParamToBufferPointer(MARSHALPARAM *pParam)
{
    return (void *)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline void *ParamToBufferPointer(MARSHALMSG *pMsg, ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    return (void *)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline void *ParamToPointer(MARSHALPARAM *pParam)
{
    return *(void **)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline void *ParamToPointer(MARSHALMSG *pMsg , ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    return *(void **)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline ULONG ParamToULONG(MARSHALMSG *pMsg , ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    return *(ULONG *)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

HBITMAP ParamToHBITMAP(MARSHALMSG *pMsg , ULONG ulParam);

//////////////////////////////////////////////////////////////////////////////
//
// CModalLoop
//
//////////////////////////////////////////////////////////////////////////////

class CModalLoop : public CSysThreadRef
{
public:
    CModalLoop(SYSTHREAD *psfn);
    ~CModalLoop();

    HRESULT BlockFn(CCicEvent *pevent, DWORD dwWaitingThreadId, DWORD &dwWaitFlags);

private:
    void WaitHandleWndMessages(DWORD dwQueueFlags);
    BOOL WaitRemoveMessage(UINT uMsgFirst, UINT uMsgLast, DWORD dwFlags);
    BOOL MyPeekMessage(MSG *pMsg, HWND hwnd, UINT min, UINT max, WORD wFlag);

    ULONG _wQuitCode;
    BOOL _fQuitReceived;
};

//////////////////////////////////////////////////////////////////////////////
//
// CThreadMarshalWnd
//
//////////////////////////////////////////////////////////////////////////////

class CThreadMarshalWnd
{
public:
    CThreadMarshalWnd();
    ~CThreadMarshalWnd();

    BOOL Init(DWORD dwThreadId);
    BOOL PostMarshalThreadMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    static BOOL DestroyAll();
    static BOOL DestroyThreadMarshalWnd(DWORD dwThread);
    static HWND GetThreadMarshalWnd(DWORD dwThread);
    static void ClearMarshalWndProc(DWORD dwProcessId);

    BOOL IsWindow()
    {
        return ::IsWindow(_hwnd);
    }

    BOOL IsThreadWindow();

    void SetMarshalWindow(HWND hwndMarshal)
    {
        _hwnd = hwndMarshal;
    }

private:
    static BOOL EnumThreadWndProc(HWND hwnd, LPARAM lParam);

    DWORD _dwThreadId;
    HWND  _hwnd;
};

void RegisterMarshalWndClass();
HWND EnsureMarshalWnd();

//////////////////////////////////////////////////////////////////////////////
//
// CProxy
//
//////////////////////////////////////////////////////////////////////////////
#define CPROXY_PARAM_START()      CPROXY_PARAM param[] = {

#define CPROXY_PARAM_ULONG_IN(ul)                                             \
              {MPARAM_IN_ULONG, NULL, ul, NULL, sizeof(ULONG), 1},

#define CPROXY_PARAM_WCHAR_IN(pch, cch)                                       \
              {MPARAM_IN_POINTER, (void *)(pch), 0, NULL, cch * sizeof(WCHAR), 1},

#define CPROXY_PARAM_POINTER_IN(p)                                            \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, sizeof(*p), 1},

#define CPROXY_PARAM_POINTER_ARRAY_IN(p, nCnt)                                \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, sizeof(*p), nCnt},

#define CPROXY_PARAM_INTERFACE_IN(p, iid)                                     \
              {MPARAM_IN_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CPROXY_PARAM_INTERFACE_ARRAY_IN(p, iid, nCnt)                         \
              {MPARAM_IN_INTERFACE, p, 0, &iid, sizeof(void *), nCnt},

#define CPROXY_PARAM_POINTER_OUT(p)                                           \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), 1},

#define CPROXY_PARAM_POINTER_ARRAY_OUT(p, nCnt)                               \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), nCnt},

#define CPROXY_PARAM_INTERFACE_OUT(p, iid)                                    \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CPROXY_PARAM_INTERFACE_ARRAY_OUT(p, iid, nCnt)                        \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), nCnt},

#define CPROXY_PARAM_INTERFACE_IN_OUT(p, iid)                                 \
              {MPARAM_IN_OUT_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CPROXY_PARAM_INTERFACE_ARRAY_IN_OUT(p, iid, nCnt)                     \
              {MPARAM_IN_OUT_INTERFACE, p, 0, &iid, sizeof(void *), nCnt},

#define CPROXY_PARAM_BSTR_OUT(p)                                              \
              {MPARAM_OUT_BSTR, p, 0, NULL, 0, 1},

#define CPROXY_PARAM_HBITMAP_OUT(p)                                           \
              {MPARAM_OUT_HBITMAP, p, 0, NULL, 0, 1},

#define CPROXY_PARAM_HICON_OUT(p)                                             \
              {MPARAM_OUT_HICON, p, 0, NULL, 0, 1},

#define CPROXY_PARAM_HBITMAP_IN(hbmp)                                         \
              {MPARAM_IN_HBITMAP, &hbmp, 0, NULL, 0, 1},

#define CPROXY_PARAM_HICON_IN(hicon)                                          \
              {MPARAM_IN_HICON, &hicon, 0, NULL, 0, 1},

#define CPROXY_PARAM_TF_LBBALLOONINFO_OUT(p)                                   \
              {MPARAM_OUT_TF_LBBALLOONINFO, (void *)p, 0, NULL, sizeof(*p), 1},

#define CPROXY_PARAM_STRUCT_IN(s)                                             \
              {MPARAM_IN_STRUCT, &s, 0, NULL, sizeof(s), 1},

#define CPROXY_PARAM_CALL(uMethodId)                                          \
              };                                                              \
              return proxy_Param(uMethodId, ARRAYSIZE(param), param);

#define CPROXY_PARAM_CALL_NOPARAM(x) return proxy_Param(x, 0, NULL);

typedef struct {
   DWORD        dwFlags;
   void         *pv;
   ULONG        ul;
   const IID    *piid;
   ULONG        cbUnitSize;
   ULONG        ulCount;          // if this is array, the number of unit.

   ULONG        GetBufSize() {return cbUnitSize * ulCount;}
} CPROXY_PARAM;
 

class CProxy : public CSysThreadRef
{
public:
    CProxy(SYSTHREAD *psfn);
    virtual ~CProxy();

    ULONG InternalAddRef();
    ULONG InternalRelease();
    void Init(REFIID riid, 
              ULONG ulProxyId, 
              ULONG ulIdStubId, 
              DWORD dwStubTime, 
              DWORD dwStubThreadId, 
              DWORD dwCurThreadId, 
              DWORD dwCurProcessId);

    //
    // IRpcChannelBuffer
    //
    HRESULT SendReceive( MARSHALMSG *pMsg , ULONG ulBlockId);
    ULONG GetStubId() {return _ulStubId;}
    DWORD GetStubThreadId() {return _dwStubThreadId;}


protected:
    HRESULT proxy_Param(ULONG ulMethodId, ULONG ulParamNum, CPROXY_PARAM *pProsyParam);


protected:
    IID   _iid;                 // interface id for this proxy.
    ULONG _cRef;

private:
    CThreadMarshalWnd _tmw;
    ULONG _ulProxyId;           // unique proxy id in src thread.
    ULONG _ulStubId;            // unique stub id in stub thread.
    DWORD _dwStubTime;          // stub created time stamp.
    DWORD _dwStubThreadId;      // stub thread id.
    DWORD _dwSrcThreadId;       // src thread id.
    DWORD _dwSrcProcessId;      // src process id.

#ifdef DEBUG
    BOOL _fInLoop;
#endif
};

//////////////////////////////////////////////////////////////////////////////
//
// CMarshalInterfaceFileMapping
//
//////////////////////////////////////////////////////////////////////////////

class CMarshalInterfaceFileMapping : public CCicFileMapping
{
public:
   CMarshalInterfaceFileMapping(DWORD dwThreadId, ULONG ulStubId, ULONG ulStubTime) : CCicFileMapping()
   {
       if (SetName2(szFileMap, ARRAYSIZE(szFileMap), SZMARSHALINTERFACEFILEMAP, dwThreadId, ulStubId, ulStubTime))
           _pszFile = szFileMap;
   }
 
private:
    char szFileMap[MAX_PATH];
};

//////////////////////////////////////////////////////////////////////////////
//
// CStub
//
//////////////////////////////////////////////////////////////////////////////

#define CSTUB_PARAM_START()      CPROXY_PARAM param[] = {

#define CSTUB_PARAM_ULONG_IN(ul)                                             \
              {MPARAM_IN_ULONG, NULL, ul, NULL, 0 /*sizeof(ULONG)*/, 1},

#define CSTUB_PARAM_POINTER_IN(p)                                            \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, 0 /*sizeof(*p)*/, 1},

#define CSTUB_PARAM_POINTER_ARRAY_IN(p, nCnt)                                \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, 0 /*sizeof(*p)*/, nCnt},

#define CSTUB_PARAM_INTERFACE_IN(p, iid)                                     \
              {MPARAM_IN_INTERFACE, p, 0, &iid, 0 /*sizeof(void *)*/, 1},

#define CSTUB_PARAM_INTERFACE_ARRAY_IN(p, iid, cnt)                          \
              {MPARAM_IN_INTERFACE, p, 0, &iid, 0 /*sizeof(void *)*/, cnt},

#define CSTUB_PARAM_POINTER_OUT(p)                                           \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), 1},

#define CSTUB_PARAM_POINTER_ARRAY_OUT(p, nCnt)                               \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), nCnt},

#define CSTUB_PARAM_INTERFACE_OUT(p, iid)                                    \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CSTUB_PARAM_INTERFACE_ARRAY_OUT(p, iid, cnt)                         \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), cnt},

#define CSTUB_PARAM_BSTR_OUT(p)                                              \
              {MPARAM_OUT_BSTR, p, 0, NULL, 0, 1},

#define CSTUB_PARAM_HBITMAP_OUT(p)                                           \
              {MPARAM_OUT_HBITMAP, p, 0, NULL, 0, 1},

#define CSTUB_PARAM_HICON_OUT(p)                                             \
              {MPARAM_OUT_HICON, p, 0, NULL, 0, 1},

#define CSTUB_PARAM_TF_LBBALLOONINFO_OUT(p)                                   \
              {MPARAM_OUT_TF_LBBALLOONINFO, (void *)p, 0, NULL, sizeof(*p), 1},

#define CSTUB_PARAM_HBITMAP_IN(hbmp)                                         \
              {MPARAM_IN_HBITMAP, &hbmp, 0, NULL, 0, 1},

#define CSTUB_PARAM_HICON_IN(hicon)                                         \
              {MPARAM_IN_HICON, &hicon, 0, NULL, 0, 1},


#define CSTUB_PARAM_END()                                                    \
              };

#define CSTUB_PARAM_INTERFACE_OUT_RELEASE(p)                                 \
              if (p) ((IUnknown *)p)->Release();

#define CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(p, ulCnt)                    \
              for (ULONG __ul = 0; __ul < ulCnt; __ul++)                     \
                   if (p[__ul]) ((IUnknown *)p[__ul])->Release();


#define CSTUB_PARAM_CALL(pMsg, hrRet, psb)                                 \
              stub_OutParam(_this, pMsg, pMsg->ulMethodId, ARRAYSIZE(param), param, psb); \
              pMsg->hrRet = hrRet;

#define CSTUB_PARAM_RETURN()                                                  \
              return S_OK;

#define CSTUB_NOT_IMPL()                                                      \
              Assert(0);                                                      \
              return S_OK;
class CStub
{
public:
    CStub();
    virtual ~CStub();
    ULONG _AddRef();
    ULONG _Release();
    ULONG GetStubId() {return _ulStubId;}
    virtual HRESULT Invoke(MARSHALMSG *pMsg, CSharedBlock *psb) = 0;

    void ClearFileMap()
    {
        if (_pfm)
        {
            _pfm->Close();
            delete _pfm;
            _pfm = NULL;
        }
    }

    static HRESULT stub_OutParam(CStub *_this, 
                                 MARSHALMSG *pMsg, 
                                 ULONG ulMethodId, 
                                 ULONG ulParamNum, 
                                 CPROXY_PARAM *pProxyParam, 
                                 CSharedBlock *psb);

    CMarshalInterfaceFileMapping *_pfm;

    IID      _iid;             // interface id for this stub.
    IUnknown *_punk;           // actual object.
    ULONG    _ulStubId;        // unique stubid of this thread.
    DWORD    _dwStubTime;      // stub created time stamp.
    DWORD    _dwStubThreadId;  // stub thread id.
    DWORD    _dwStubProcessId; // stub process id.
    DWORD    _dwSrcThreadId;   // src thread id.

    BOOL     _fNoRemoveInDtor; // this stub has been removed from list.
                               // so don't try at dtor.
    ULONG    _cRef;
};

#endif // MARSHAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\memcache.h ===
//
// memcache.h
//

#ifndef MEMCACHE_H
#define MEMCACHE_H

#include "mem.h"
#include "globals.h"

extern LONG g_lMemCacheMutex;

typedef struct _MEMCACHE
{
    ULONG uMaxPtrs;
    ULONG iNextFree;
    void *rgPtrs[1]; // 1 or more...
} MEMCACHE;

MEMCACHE *MemCache_New(ULONG uMaxPtrs);

void MemCache_Delete(MEMCACHE *pMemCache);

//+---------------------------------------------------------------------------
//
// MemCache_Add
//
//----------------------------------------------------------------------------

inline BOOL MemCache_Add(MEMCACHE *pMemCache, void *pv)
{
    BOOL fRet = FALSE;

    if (InterlockedIncrement(&g_lMemCacheMutex) != 0)
        goto Exit;

    if (pMemCache->iNextFree >= pMemCache->uMaxPtrs)
        goto Exit; // cache is full!

    pMemCache->rgPtrs[pMemCache->iNextFree++] = pv;

    fRet = TRUE;

Exit:
    InterlockedDecrement(&g_lMemCacheMutex);
    return fRet;
}

//+---------------------------------------------------------------------------
//
// MemCache_Remove
//
//----------------------------------------------------------------------------

inline void *MemCache_Remove(MEMCACHE *pMemCache)
{
    void *pv = NULL;

    if (InterlockedIncrement(&g_lMemCacheMutex) != 0)
        goto Exit;

    if (pMemCache->iNextFree == 0)
        goto Exit;

    pv = pMemCache->rgPtrs[--pMemCache->iNextFree];

Exit:
    InterlockedDecrement(&g_lMemCacheMutex);
    return pv;
}

//+---------------------------------------------------------------------------
//
// MemCache_NewOp
//
//----------------------------------------------------------------------------

#ifdef DEBUG
inline void *MemCache_NewOp(MEMCACHE *pMemCache, size_t nSize, const TCHAR *pszFile, int iLine)
#else
inline void *MemCache_NewOp(MEMCACHE *pMemCache, size_t nSize)
#endif
{
    void *pv = NULL;

    if (pMemCache != NULL)
    {
        if (pv = MemCache_Remove(pMemCache))
        {   // Issue: update debug mem track info
            memset(pv, 0, nSize);
        }
    }

    if (pv == NULL)
    {
#ifdef DEBUG
        pv = Dbg_MemAllocClear(nSize, pszFile, iLine);
#else
        pv = cicMemAllocClear(nSize);
#endif
    }

    return pv;
}

//+---------------------------------------------------------------------------
//
// MemCache_DeleteOp
//
//----------------------------------------------------------------------------

inline void MemCache_DeleteOp(MEMCACHE *pMemCache, void *pv)
{
    if (pMemCache == NULL ||
        !MemCache_Add(pMemCache, pv))
    {
        cicMemFree(pv);
    }
}

#ifdef DEBUG
#define DECLARE_CACHED_NEW                                                              \
    void *operator new(size_t nSize, const TCHAR *pszFile, int iLine) { return MemCache_NewOp(_s_pMemCache, nSize, pszFile, iLine); }  \
    void operator delete(void *pv) { MemCache_DeleteOp(_s_pMemCache, pv); }             \
    static _MEMCACHE *_s_pMemCache;

#else // !DEBUG
#define DECLARE_CACHED_NEW                                                              \
    void *operator new(size_t nSize) { return MemCache_NewOp(_s_pMemCache, nSize); }    \
    void operator delete(void *pv) { MemCache_DeleteOp(_s_pMemCache, pv); }             \
    static _MEMCACHE *_s_pMemCache;
#endif

#define DECLARE_CACHED_NEW_STATIC(the_class)   \
    MEMCACHE *the_class::_s_pMemCache = NULL;

#endif // MEMCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\msaa.cpp ===
//
// msaa.cpp
//
// AA stuff.
//

#include "private.h"
#include "ic.h"
#include "tim.h"
#include "dim.h"
#include "msaa.h"
#include "tlapi.h"

extern "C" HRESULT WINAPI TF_PostAllThreadMsg(WPARAM wParam, DWORD dwFlags);

//+---------------------------------------------------------------------------
//
// SystemEnableMSAA
//
// Called by msaa to kick cicero msaa support on the desktop.
//----------------------------------------------------------------------------

STDAPI CMSAAControl::SystemEnableMSAA()
{
    if (InterlockedIncrement(&GetSharedMemory()->cMSAARef) == 0)
    {
        TF_PostAllThreadMsg(TFPRIV_ENABLE_MSAA, TLF_TIMACTIVE);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SystemDisableMSAA
//
// Called by msaa to halt cicero msaa support on the desktop.
//----------------------------------------------------------------------------

STDAPI CMSAAControl::SystemDisableMSAA()
{
    if (InterlockedDecrement(&GetSharedMemory()->cMSAARef) == -1)
    {
        TF_PostAllThreadMsg(TFPRIV_DISABLE_MSAA, TLF_TIMACTIVE);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitMSAAHook
//
//----------------------------------------------------------------------------

void CInputContext::_InitMSAAHook(IAccServerDocMgr *pAAAdaptor)
{
    IDocWrap *pAADocWrapper;

    if (_pMSAAState != NULL)
        return; // already inited

    Assert(_ptsi != NULL);

    // try to allocate some space for the state we'll need to save
    // since we rarely use msaa, it's stored separately from the ic
    if ((_pMSAAState = (MSAA_STATE *)cicMemAlloc(sizeof(MSAA_STATE))) == NULL)
        return;

    // back up the original ptsi
    _pMSAAState->ptsiOrg = _ptsi;
    _ptsi = NULL;

    if (CoCreateInstance(CLSID_DocWrap, NULL, CLSCTX_INPROC_SERVER,
        IID_IDocWrap, (void **)&pAADocWrapper) != S_OK)
    {
        goto ExitError;
    }

    if (pAADocWrapper->SetDoc(IID_ITextStoreAnchor, _pMSAAState->ptsiOrg) != S_OK)
        goto ExitError;

    if (pAADocWrapper->GetWrappedDoc(IID_ITextStoreAnchor, (IUnknown **)&_pMSAAState->pAADoc) != S_OK)
        goto ExitError;

    if (pAADocWrapper->GetWrappedDoc(IID_ITextStoreAnchor, (IUnknown **)&_ptsi) != S_OK)
        goto ExitError;

    if (pAAAdaptor->NewDocument(IID_ITextStoreAnchor, _pMSAAState->pAADoc) != S_OK)
        goto ExitError;

    pAADocWrapper->Release();
    return;

ExitError:
    pAADocWrapper->Release();
    _UninitMSAAHook(pAAAdaptor);
}

//+---------------------------------------------------------------------------
//
// _UninitMSAAHook
//
//----------------------------------------------------------------------------

void CInputContext::_UninitMSAAHook(IAccServerDocMgr *pAAAdaptor)
{
    if (_pMSAAState == NULL)
        return; // not inited

    pAAAdaptor->RevokeDocument(_pMSAAState->pAADoc);
    SafeRelease(_pMSAAState->pAADoc);
    SafeRelease(_ptsi);
    // restore orig unwrapped doc
    _ptsi = _pMSAAState->ptsiOrg;
    // free msaa struct
    cicMemFree(_pMSAAState);
    _pMSAAState = NULL;
}

//+---------------------------------------------------------------------------
//
// _InitMSAA
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_InitMSAA()
{
    CDocumentInputManager *dim;
    CInputContext *pic;
    int iDim;
    int iContext;
    HRESULT hr;

    if (_pAAAdaptor != NULL)
        return; // already inited

    hr = CoCreateInstance(CLSID_AccServerDocMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IAccServerDocMgr, (void **)&_pAAAdaptor);

    if (hr != S_OK || _pAAAdaptor == NULL)
    {
        _pAAAdaptor = NULL;
        return;
    }

    // now wrap all existing ic's
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);
            // we need to reset our sinks, so msaa can wrap them
            // first, disconnect the sink
            pic->_GetTSI()->UnadviseSink(SAFECAST(pic, ITextStoreAnchorSink *));

            // now announce the ic
            pic->_InitMSAAHook(_pAAAdaptor);

            // now reset the sink on the wrapped _ptsi
            pic->_GetTSI()->AdviseSink(IID_ITextStoreAnchorSink, SAFECAST(pic, ITextStoreAnchorSink *), TS_AS_ALL_SINKS);
        }
    }
}

//+---------------------------------------------------------------------------
//
// _UninitMSAA
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_UninitMSAA()
{
    CDocumentInputManager *dim;
    CInputContext *pic;
    int iDim;
    int iContext;

    if (_pAAAdaptor == NULL)
        return; // already uninited

    // unwrap all existing ic's
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);
            // we need to reset our sinks
            // first, unadvise the wrapped sinks
            pic->_GetTSI()->UnadviseSink(SAFECAST(pic, ITextStoreAnchorSink *));

            // unwrap the ptsi
            pic->_UninitMSAAHook(_pAAAdaptor);

            // now reset the sink on the original _ptsi
            pic->_GetTSI()->AdviseSink(IID_ITextStoreAnchorSink, SAFECAST(pic, ITextStoreAnchorSink *), TS_AS_ALL_SINKS);
        }
    }

    _pAAAdaptor->Release();
    _pAAAdaptor = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\msgpump.cpp ===
//
// msgpump.cpp
//

#include "private.h"
#include "tim.h"

//+---------------------------------------------------------------------------
//
// PeekMessageA
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::PeekMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                     UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    *pfResult = ::PeekMessageA(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetMessageA
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                    UINT wMsgFilterMax, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    Perf_StartStroke(PERF_STROKE_GETMSG);

    *pfResult = ::GetMessageA(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax);

    Perf_EndStroke(PERF_STROKE_GETMSG);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// PeekMessageW
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::PeekMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                     UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    *pfResult = ::PeekMessageW(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetMessageW
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                    UINT wMsgFilterMax, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    Perf_StartStroke(PERF_STROKE_GETMSG);

    *pfResult = ::GetMessageW(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax);

    Perf_EndStroke(PERF_STROKE_GETMSG);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnableSystemKeystrokeFeed
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnableSystemKeystrokeFeed()
{
    if (_cDisableSystemKeystrokeFeedRef <= 0)
    {
        Assert(0); // bogus ref count!
        return E_UNEXPECTED;
    }

    _cDisableSystemKeystrokeFeedRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// DisableSystemKeystrokeFeed
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::DisableSystemKeystrokeFeed()
{
    _cDisableSystemKeystrokeFeedRef++;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsKeystrokeFeedEnabled
//
// nb: this method is on a private interface used by the aimm layer.
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::IsKeystrokeFeedEnabled(BOOL *pfEnabled)
{
    Assert(pfEnabled != NULL);

    *pfEnabled = _IsKeystrokeFeedEnabled();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\mproxy.cpp ===
//
// mproxy.cpp
//

#include "private.h"
#include "mproxy.h"
#include "ithdmshl.h"

/* 344E266C-FB48-4E81-9FD9-0CC8070F984A */
const IID IID_CPROXYPRIV = { 
    0x344E266C,
    0xFB48,
    0x4E81,
    {0x9F, 0xD9, 0x0C, 0xC8, 0x07, 0x0F, 0x98, 0x4A}
 };

DBG_ID_INSTANCE(CProxyIUnknown);
DBG_ID_INSTANCE(CProxyITfLangBarMgr);
DBG_ID_INSTANCE(CProxyITfLangBarItemMgr);
DBG_ID_INSTANCE(CProxyITfLangBarItemSink);
DBG_ID_INSTANCE(CProxyIEnumTfLangBarItems);
DBG_ID_INSTANCE(CProxyITfLangBarItem);
DBG_ID_INSTANCE(CProxyITfLangBarItemButton);
DBG_ID_INSTANCE(CProxyITfLangBarItemBitmapButton);
DBG_ID_INSTANCE(CProxyITfLangBarItemBitmap);
DBG_ID_INSTANCE(CProxyITfLangBarItemBalloon);
DBG_ID_INSTANCE(CProxyITfMenu);
DBG_ID_INSTANCE(CProxyITfInputProcessorProfiles);

//////////////////////////////////////////////////////////////////////////////
//
// ProxyCreator
//
//////////////////////////////////////////////////////////////////////////////

#define CREATENEWPROXY(interface_name)                                    \
    if (IsEqualIID(riid, IID_ ## interface_name ## ))                      \
    {                                                                      \
        CProxy ## interface_name ##  *pProxy =  new CProxy ## interface_name ## (psfn);\
        if (!pProxy)                                                       \
             return NULL;                                                  \
        pProxy->Init(riid, 0, ulStubId, dwStubTime, dwThreadId, dwCurThreadId, dwCurProcessId);                       \
        return SAFECAST(pProxy, ## interface_name ## *);                     \
    }                                                                      

IUnknown *ProxyCreator(SYSTHREAD *psfn, REFIID riid, ULONG ulStubId, DWORD dwStubTime, DWORD dwThreadId, DWORD dwCurThreadId, DWORD dwCurProcessId)
{
    CREATENEWPROXY(IUnknown)
    CREATENEWPROXY(ITfLangBarMgr)
    CREATENEWPROXY(ITfLangBarItemMgr)
    CREATENEWPROXY(ITfLangBarItemSink)
    CREATENEWPROXY(IEnumTfLangBarItems)
    CREATENEWPROXY(ITfLangBarItem)
    CREATENEWPROXY(ITfLangBarItemButton)
    CREATENEWPROXY(ITfLangBarItemBitmapButton)
    CREATENEWPROXY(ITfLangBarItemBitmap)
    CREATENEWPROXY(ITfLangBarItemBalloon)
    CREATENEWPROXY(ITfMenu)
    CREATENEWPROXY(ITfInputProcessorProfiles);
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyIUnknown
//
//////////////////////////////////////////////////////////////////////////////

CProxyIUnknown::CProxyIUnknown(SYSTHREAD *psfn) : CProxy(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyIUnknown"));
}

HRESULT CProxyIUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    TraceMsg(TF_FUNC, "CProxyIUnknown::QueryInterface");

    if (IsEqualIID(riid, IID_CPROXYPRIV))
    {
        *ppvObj = SAFECAST(this, CProxyIUnknown *);
        InternalAddRef();
        return S_OK;
    }

    HRESULT hr = _QueryInterface(riid, ppvObj);
    // if (SUCCEEDED(hr))
    //     InternalAddRef();

    return hr;
}

HRESULT CProxyIUnknown::_QueryInterface(REFIID riid, void **ppvObj)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(&riid)
    CPROXY_PARAM_INTERFACE_OUT(ppvObj, riid)
    CPROXY_PARAM_CALL(0)
}

STDAPI_(ULONG) CProxyIUnknown::AddRef()
{
#ifdef UNKNOWN_MARSHAL
    HRESULT hr;

    TraceMsg(TF_FUNC, "CProxyIUnknown::AddRef");

    CMarshalParamCreator cparam;
    cparam.Init(_iid, 1, 0);
    hr = cparam.SendReceiveULONG(this);
    if (FAILED(hr))
        return hr;
#endif

    return InternalAddRef();
}


STDAPI_(ULONG) CProxyIUnknown::Release()
{
#ifdef UNKNOWN_MARSHAL
    HRESULT hr;

    TraceMsg(TF_FUNC, "CProxyIUnknown::Release");

    CMarshalParamCreator cparam;
    cparam.Init(_iid, 2, 0);
    hr = cparam.SendReceiveULONG(this);
    if (FAILED(hr))
        return hr;
#endif

    return InternalRelease();
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarMgr::CProxyITfLangBarMgr(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarMgr"));
}

STDAPI CProxyITfLangBarMgr::AdviseEventSink(ITfLangBarEventSink *pSink, 
                                 HWND hwnd, 
                                 DWORD dwFlags, 
                                 DWORD *pdwCookie)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::UnadviseEventSink(DWORD dwCookie)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetThreadMarshalInterface(DWORD dwThreadId, 
                                           DWORD dwType, 
                                           REFIID riid, 
                                           IUnknown **ppunk)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetThreadLangBarItemMgr(DWORD dwThreadId, 
                                         ITfLangBarItemMgr **pplbi, 
                                         DWORD *pdwThreadId)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetInputProcessorProfiles(DWORD dwThreadId, 
                                           ITfInputProcessorProfiles **ppaip, 
                                           DWORD *pdwThreadId)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::SetModalInput(ITfLangBarEventSink *pSink, 
                                          DWORD dwThreadId,
                                          DWORD dwFlags)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::ShowFloating(DWORD dwFlags)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetShowFloatingStatus(DWORD *pdwFlags)
{
    Assert(0);
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemMgr::CProxyITfLangBarItemMgr(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemMgr"));
}

STDMETHODIMP CProxyITfLangBarItemMgr::EnumItems(IEnumTfLangBarItems **ppEnum)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::EnumItems");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_OUT(ppEnum, IID_IEnumTfLangBarItems)
    CPROXY_PARAM_CALL(3)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItem(REFGUID rguid,  ITfLangBarItem **ppItem)
{
#if 1
    Assert(0);
    return E_NOTIMPL;
#else
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItem");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(&rguid)
    CPROXY_PARAM_INTERFACE_OUT(ppItem, IID_ITfLangBarItem)
    CPROXY_PARAM_CALL(4)
#endif
}

STDMETHODIMP CProxyITfLangBarItemMgr::AddItem(ITfLangBarItem *punk)
{
#if 1
    Assert(0);
    return E_NOTIMPL;
#else
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AddItem");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&punk, IID_ITfLangBarItem)
    CPROXY_PARAM_CALL(5)
#endif
}

STDMETHODIMP CProxyITfLangBarItemMgr::RemoveItem(ITfLangBarItem *punk)
{
#if 1
    Assert(0);
    return E_NOTIMPL;
#else
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::RemoveItem");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&punk, IID_ITfLangBarItem)
    CPROXY_PARAM_CALL(6)
#endif
}

STDMETHODIMP CProxyITfLangBarItemMgr::AdviseItemSink(ITfLangBarItemSink *punk,  DWORD *pdwCookie,  REFGUID rguidItem)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AdviseItemSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&punk, IID_ITfLangBarItemSink)
    CPROXY_PARAM_POINTER_OUT(pdwCookie)
    CPROXY_PARAM_POINTER_IN(&rguidItem)
    CPROXY_PARAM_CALL(7)
}

STDMETHODIMP CProxyITfLangBarItemMgr::UnadviseItemSink(DWORD dwCookie)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::UnadviseItemSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(dwCookie)
    CPROXY_PARAM_CALL(8)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItemFloatingRect");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(dwThreadId)
    CPROXY_PARAM_POINTER_IN(&rguid)
    CPROXY_PARAM_POINTER_OUT(prc)
    CPROXY_PARAM_CALL(9)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItemsStatus");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_POINTER_ARRAY_IN(prgguid, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CPROXY_PARAM_CALL(10)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItemNum(ULONG *pulCount)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItemNum");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(pulCount)
    CPROXY_PARAM_CALL(11)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItems");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_INTERFACE_ARRAY_OUT(ppItem, IID_ITfLangBarItem, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pInfo, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CPROXY_PARAM_POINTER_OUT(pcFetched)
    CPROXY_PARAM_CALL(12)
}

STDMETHODIMP CProxyITfLangBarItemMgr::AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AdviseItemsSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_INTERFACE_ARRAY_IN(ppunk, IID_ITfLangBarItemSink, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_IN(pguidItem, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pdwCookie, ulCount)
    CPROXY_PARAM_CALL(13)
}

STDMETHODIMP CProxyITfLangBarItemMgr::UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AdviseItemsSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_POINTER_ARRAY_IN(pdwCookie, ulCount)
    CPROXY_PARAM_CALL(14)
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemSink::CProxyITfLangBarItemSink(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemSink"));
}

HRESULT CProxyITfLangBarItemSink::OnUpdate(DWORD dwFlags)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemSink:OnUpdate");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_CALL(3)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyIEnumTfLangBarItems
//
//////////////////////////////////////////////////////////////////////////////

CProxyIEnumTfLangBarItems::CProxyIEnumTfLangBarItems(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyIEnumTfLangBarItems"));
}


HRESULT CProxyIEnumTfLangBarItems::Clone(IEnumTfLangBarItems **ppEnum)
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Clone");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_OUT(ppEnum, IID_IEnumTfLangBarItems)
    CPROXY_PARAM_CALL(3)
}

HRESULT CProxyIEnumTfLangBarItems::Next(ULONG ulCount, 
                                   ITfLangBarItem **ppItem, 
                                   ULONG *pcFetched)
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Next");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_INTERFACE_ARRAY_OUT(ppItem, IID_ITfLangBarItem, ulCount)
    CPROXY_PARAM_POINTER_OUT(pcFetched)
    CPROXY_PARAM_CALL(4)
}

HRESULT CProxyIEnumTfLangBarItems::Reset()
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Reset");
    CPROXY_PARAM_CALL_NOPARAM(5)
}

HRESULT CProxyIEnumTfLangBarItems::Skip(ULONG ulCount)
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Skip");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_CALL(6)
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItem::CProxyITfLangBarItem(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItem"));
}

HRESULT CProxyITfLangBarItem::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::GetInfo");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(pInfo)
    CPROXY_PARAM_CALL(3)
}

HRESULT CProxyITfLangBarItem::GetStatus(DWORD *pdwStatus)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::GetStatus");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(pdwStatus)
    CPROXY_PARAM_CALL(4)
}

HRESULT CProxyITfLangBarItem::Show(BOOL fShow)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::Show");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(fShow)
    CPROXY_PARAM_CALL(5)
}

HRESULT CProxyITfLangBarItem::GetTooltipString(BSTR *pbstrToolTip)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::GetTooltipString");
    CPROXY_PARAM_START()
    CPROXY_PARAM_BSTR_OUT(pbstrToolTip)
    CPROXY_PARAM_CALL(6)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemButton::CProxyITfLangBarItemButton(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemButton"));
}

STDAPI CProxyITfLangBarItemButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemButton::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemButton::InitMenu(ITfMenu *pMenu)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&pMenu, IID_ITfMenu)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemButton::OnMenuSelect(UINT wID)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(wID)
    CPROXY_PARAM_CALL(9)
}

STDAPI CProxyITfLangBarItemButton::GetIcon(HICON *phIcon)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_HICON_OUT(phIcon)
    CPROXY_PARAM_CALL(10)
}

STDAPI CProxyITfLangBarItemButton::GetText(BSTR *pbstrText)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_BSTR_OUT(pbstrText)
    CPROXY_PARAM_CALL(11)
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemBitmapButton::CProxyITfLangBarItemBitmapButton(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemBitmapButton"));
}

STDAPI CProxyITfLangBarItemBitmapButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemBitmapButton::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemBitmapButton::InitMenu(ITfMenu *pMenu)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&pMenu, IID_ITfMenu)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemBitmapButton::OnMenuSelect(UINT wID)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(wID)
    CPROXY_PARAM_CALL(9)
}

STDAPI CProxyITfLangBarItemBitmapButton::GetPreferredSize(const SIZE *pszDefault,SIZE *psz)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(pszDefault)
    CPROXY_PARAM_POINTER_OUT(psz)
    CPROXY_PARAM_CALL(10)
}

STDAPI CProxyITfLangBarItemBitmapButton::DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(bmWidth)
    CPROXY_PARAM_ULONG_IN(bmHeight)
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_HBITMAP_OUT(phbmp)
    CPROXY_PARAM_HBITMAP_OUT(phbmpMask)
    CPROXY_PARAM_CALL(11)
}

STDAPI CProxyITfLangBarItemBitmapButton::GetText(BSTR *pbstrText)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_BSTR_OUT(pbstrText)
    CPROXY_PARAM_CALL(12)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemBitmap::CProxyITfLangBarItemBitmap(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemBitmap"));
}

STDAPI CProxyITfLangBarItemBitmap::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemBitmap::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemBitmap::GetPreferredSize(const SIZE *pszDefault,SIZE *psz)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(pszDefault)
    CPROXY_PARAM_POINTER_OUT(psz)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemBitmap::DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(bmWidth)
    CPROXY_PARAM_ULONG_IN(bmHeight)
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_HBITMAP_OUT(phbmp)
    CPROXY_PARAM_HBITMAP_OUT(phbmpMask)
    CPROXY_PARAM_CALL(9)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemBalloon::CProxyITfLangBarItemBalloon(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemBalloon"));
}

STDAPI CProxyITfLangBarItemBalloon::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemBalloon::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemBalloon::GetPreferredSize(const SIZE *pszDefault,SIZE *psz)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(pszDefault)
    CPROXY_PARAM_POINTER_OUT(psz)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemBalloon::GetBalloonInfo(TF_LBBALLOONINFO *pInfo)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_TF_LBBALLOONINFO_OUT(pInfo)
    CPROXY_PARAM_CALL(9)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfMenu::CProxyITfMenu(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfMenu"));
}

STDAPI CProxyITfMenu::AddMenuItem(UINT uId,
                                             DWORD dwFlags,
                                             HBITMAP hbmp,
                                             HBITMAP hbmpMask,
                                             const WCHAR *pch,
                                             ULONG cch,
                                             ITfMenu **ppMenu)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(uId)
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_HBITMAP_IN(hbmp)
    CPROXY_PARAM_HBITMAP_IN(hbmpMask)
    CPROXY_PARAM_WCHAR_IN(pch, cch)
    CPROXY_PARAM_ULONG_IN(cch)
    CPROXY_PARAM_INTERFACE_IN_OUT(ppMenu, IID_ITfMenu)
    CPROXY_PARAM_CALL(3)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfInputProcessorProfiles::CProxyITfInputProcessorProfiles(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfInputProcessorProfiles"));
}

STDAPI CProxyITfInputProcessorProfiles::Register(REFCLSID rclsid)
{
    // 3
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::Unregister(REFCLSID rclsid)
{
    // 4
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::AddLanguageProfile(REFCLSID rclsid,
                               LANGID langid,
                               REFGUID guidProfile,
                               const WCHAR *pchDesc,
                               ULONG cchDesc,
                               const WCHAR *pchIconFile,
                               ULONG cchFile,
                               ULONG uIconIndex)
{
    // 5
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::RemoveLanguageProfile(REFCLSID rclsid,
                                  LANGID langid,
                                  REFGUID guidProfile)
{
    // 6
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnumInputProcessorInfo(IEnumGUID **ppEnum)
{
    // 7
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetDefaultLanguageProfile(LANGID langid,
                                      REFGUID catid,
                                      CLSID *pclsid,
                                      GUID *pguidProfile)
{
    // 9
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::SetDefaultLanguageProfile(LANGID langid,
                                      REFCLSID rclsid,
                                      REFGUID guidProfiles)
{
    // 11
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::ActivateLanguageProfile(REFCLSID rclsid, 
                                    LANGID langid, 
                                    REFGUID guidProfiles)
{
    // 12
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetActiveLanguageProfile(REFCLSID rclsid, 
                                     LANGID *plangid, 
                                     GUID *pguidProfile)
{
    // 13
    Assert(0);
    return E_NOTIMPL;
}

HRESULT CProxyITfInputProcessorProfiles::GetLanguageProfileDescription(REFCLSID rclsid, 
                                          LANGID langid, 
                                          REFGUID guidProfile,
                                          BSTR *pbstrProfile)
{
    // 14
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetCurrentLanguage(LANGID *plangid)
{
    // 15
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(plangid)
    CPROXY_PARAM_CALL(14)
}

STDAPI CProxyITfInputProcessorProfiles::ChangeCurrentLanguage(LANGID langid)
{
    // 16
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetLanguageList(LANGID **ppLangId,
                            ULONG *pulCount)
{
    // 17
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnumLanguageProfiles(LANGID langid, 
                                 IEnumTfLanguageProfiles **ppEnum)
{
    // 18
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnableLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile,
                                       BOOL fEnable)
{
    // 19
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::IsEnabledLanguageProfile(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          BOOL *pfEnable)
{
    // 20
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnableLanguageProfileByDefault(REFCLSID rclsid,
                                                LANGID langid,
                                                REFGUID guidProfile,
                                                BOOL fEnable)
{
    // 21
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::SubstituteKeyboardLayout(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          HKL hKL)
{
    // 22
    Assert(0);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\mproxy.h ===
//
// mproxy.h
//

#ifndef MPROXY_H
#define MPROXY_H

#include "private.h"
#include "marshal.h"
#include "mstub.h"
#include "ptrary.h"
#include "strary.h"
#include "transmit.h"

IUnknown *ProxyCreator(SYSTHREAD *psfn, REFIID riid, ULONG ulStubId, DWORD dwStubTime, DWORD dwThreadId, DWORD dwCurThreadId, DWORD dwCurProcessId);

typedef struct tag_MARSHALINTERFACEPARAM 
{
    ULONG  ulStubId;
    ULONG  dwStubTime;
    BOOL   fNULLPointer;
    BOOL   fNULLStack;
} MARSHALINTERFACEPARAM;

#define MSGMAPSIZE  0x100

//////////////////////////////////////////////////////////////////////////////
//
// CMarshalParamCreator
//
//////////////////////////////////////////////////////////////////////////////

class CMarshalParamCreator
{
public:
    CMarshalParamCreator()
    {
        _ulCur = 0;
        _ulParamNum = 0;
        _pMsg = NULL;
        _fMsgCreated = FALSE;
    }

    ~CMarshalParamCreator()
    {
        if (_fMsgCreated)
            cicMemFree(_pMsg);
    }

    void Clear()
    {
        if (_fMsgCreated)
            cicMemFree(_pMsg);

        _ulCur = 0;
        _ulParamNum = 0;
        _pMsg = NULL;
        _fMsgCreated = FALSE;
    }

    BOOL Set(MARSHALMSG *pMsg, ULONG cbSize)
    {
        _pMsg = pMsg;
        _pMsg->cbBufSize = cbSize;
        return TRUE;
    }

    BOOL Init(DWORD dwSrcThreadId, DWORD dwSrcProcessId, REFIID riid, ULONG ulMethodId, ULONG ulParamNum, ULONG ulStubId, DWORD dwStubTime, BOOL fUseulRet = FALSE)
    {
        _ulParamNum = ulParamNum;
        ULONG cbSize = sizeof(MARSHALMSG) + ulParamNum * sizeof(MARSHALPARAM *);

        if (!_pMsg)
        {
            _pMsg = (MARSHALMSG *)cicMemAllocClear(MSGMAPSIZE);
            if (!_pMsg)
                return FALSE;

            _fMsgCreated = TRUE;
            _pMsg->cbBufSize = MSGMAPSIZE;
        }

        LENGTH_ALIGN(cbSize, CIC_ALIGNMENT);
        _pMsg->cbSize = cbSize;
        _pMsg->iid = riid;
        _pMsg->ulMethodId = ulMethodId;
        _pMsg->ulParamNum = 0;
        _pMsg->dwSrcThreadId = dwSrcThreadId;
        _pMsg->dwSrcProcessId = dwSrcProcessId;
        _pMsg->ulStubId = ulStubId;
        _pMsg->dwStubTime = dwStubTime;
        if (!fUseulRet)
            _pMsg->hrRet = E_FAIL;
            
        return TRUE;
    }

    HRESULT Add(ULONG cbBufSize, DWORD dwFlags, const void *pv)
    {
        ULONG cbOrgBufSize = cbBufSize;
        LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);
        ULONG cbMsgSize = _pMsg->cbSize + cbBufSize + sizeof(MARSHALPARAM);
        LENGTH_ALIGN(cbMsgSize, CIC_ALIGNMENT);
        MARSHALPARAM *pParam;

        if (_pMsg->cbBufSize < cbMsgSize)
        {
            Assert(0);
            return E_OUTOFMEMORY;
        }

        pParam  = (MARSHALPARAM *)((BYTE *)_pMsg + _pMsg->cbSize);
        _pMsg->ulParamOffset[_ulCur] = _pMsg->cbSize;
        pParam->cbBufSize = cbBufSize;
        pParam->dwFlags = dwFlags;

        if (cbBufSize)
        {
            if (pv)
            {
                BYTE *pb = (BYTE *)ParamToBufferPointer(pParam);
                memcpy(pb, pv, cbOrgBufSize);
                if (cbBufSize - cbOrgBufSize)
                    memset(pb + cbOrgBufSize, 0, cbBufSize - cbOrgBufSize);
            }
            else
            {
                memset(ParamToBufferPointer(pParam), 0, cbBufSize);
            }
        }

        _pMsg->cbSize = cbMsgSize;
        _pMsg->ulParamNum++;

        _ulCur++;
        return S_OK;
    }

    MARSHALMSG *Get() {return _pMsg;}
    HRESULT GetHresult() {return _pMsg->hrRet;}

    MARSHALPARAM *GetMarshalParam(ULONG ulParam)
    {
        return (MARSHALPARAM *)(((BYTE *)_pMsg) + _pMsg->ulParamOffset[ulParam]);
    }

    HRESULT _RealSendReceive(CProxy *pProxy, ULONG ulBlockId)
    {
        HRESULT hr = pProxy->SendReceive(_pMsg, ulBlockId);
        return hr;
    }

    HRESULT SendReceive(CProxy *pProxy, ULONG ulBlockId)
    {
        HRESULT hr = _RealSendReceive(pProxy, ulBlockId);
        if (FAILED(hr))
            return hr;
        return _pMsg->hrRet;
    }

#ifdef UNKNOWN_MARSHAL
    HRESULT SendReceiveULONG(CProxy *pProxy, ULONG ulBlockId)
    {
        HRESULT hr = _RealSendReceive(pProxy, ulBlockId);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }
#endif


private:
    MARSHALMSG *_pMsg;
    ULONG _ulParamNum;
    ULONG _ulCur;
    BOOL  _fMsgCreated;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyIUnknown
//
//////////////////////////////////////////////////////////////////////////////

class CProxyIUnknown : public IUnknown,
                       public CProxy
{
public:
    CProxyIUnknown(SYSTHREAD *psfn);

    virtual ~CProxyIUnknown()
    {
        Assert(!_cRef);
    }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT _QueryInterface(REFIID riid, void **ppvObj);

private:
    DBG_ID_DECLARE;
};

extern const IID IID_CPROXYPRIV;
inline CProxyIUnknown *GetCProxyIUnknown(IUnknown *punk)
{
    CProxyIUnknown *pv;

    punk->QueryInterface(IID_CPROXYPRIV, (void **)&pv);

    return pv;
}

#define CPROXYIUNKOWNIMPL()                                      \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)      \
    {                                                            \
        return CProxyIUnknown::QueryInterface(riid, ppvObj);     \
    }                                                            \
    STDMETHODIMP_(ULONG) AddRef(void)                            \
    {                                                            \
        return CProxyIUnknown::AddRef();                         \
    }                                                            \
    STDMETHODIMP_(ULONG) Release(void)                           \
    {                                                            \
        return CProxyIUnknown::Release();                        \
    }

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarMgr : public CProxyIUnknown,
                            public ITfLangBarMgr
{
public:
    CProxyITfLangBarMgr(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()

    //
    // ITfLangBarMgr methods
    //
    STDMETHODIMP AdviseEventSink(ITfLangBarEventSink *pSink, 
                                 HWND hwnd, 
                                 DWORD dwFlags, 
                                 DWORD *pdwCookie);

    STDMETHODIMP UnadviseEventSink(DWORD dwCookie);

    STDMETHODIMP GetThreadMarshalInterface(DWORD dwThreadId, 
                                           DWORD dwType, 
                                           REFIID riid, 
                                           IUnknown **ppunk);

    STDMETHODIMP GetThreadLangBarItemMgr(DWORD dwThreadId, 
                                         ITfLangBarItemMgr **pplbi, 
                                         DWORD *pdwThreadId) ;

    STDMETHODIMP GetInputProcessorProfiles(DWORD dwThreadId, 
                                           ITfInputProcessorProfiles **ppaip, 
                                           DWORD *pdwThreadId) ;

    STDMETHODIMP RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev);

    STDMETHODIMP SetModalInput(ITfLangBarEventSink *pSink, 
                               DWORD dwThreadId,
                               DWORD dwFlags);

    STDMETHODIMP ShowFloating(DWORD dwFlags);

    STDMETHODIMP GetShowFloatingStatus(DWORD *pdwFlags);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemMgr : public ITfLangBarItemMgr,
                                public CProxyIUnknown
{
public:
    CProxyITfLangBarItemMgr(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()

    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum);

    STDMETHODIMP GetItem(REFGUID rguid, 
                    ITfLangBarItem **ppItem);

    STDMETHODIMP AddItem(ITfLangBarItem *punk);

    STDMETHODIMP RemoveItem(ITfLangBarItem *punk);

    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, 
                           DWORD *pdwCookie, 
                           REFGUID rguidItem);

    STDMETHODIMP UnadviseItemSink(DWORD dwCookie);

    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus);

    STDMETHODIMP GetItemNum(ULONG *pulCount);

    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched);

    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie);

    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie);

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemSink : public ITfLangBarItemSink,
                                 public CProxyIUnknown
{
public:
    CProxyITfLangBarItemSink(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP OnUpdate(DWORD dwFlags);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyIEnumEnumTfLangBarItems
//
//////////////////////////////////////////////////////////////////////////////

class CProxyIEnumTfLangBarItems : public IEnumTfLangBarItems,
                                  public CProxyIUnknown
{
public:
    CProxyIEnumTfLangBarItems(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP Clone(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, 
                      ITfLangBarItem **ppItem, 
                      ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItem : public ITfLangBarItem,
                             public CProxyIUnknown
{
public:
    CProxyITfLangBarItem(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);
    DBG_ID_DECLARE;
};

#define CPROXYLANGBARITEMIMPL()                                              \
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo)                          \
                 {return CProxyITfLangBarItem::GetInfo(pInfo);}              \
    STDMETHODIMP GetStatus(DWORD *pdwStatus)                                 \
                 {return CProxyITfLangBarItem::GetStatus(pdwStatus);}        \
    STDMETHODIMP Show(BOOL fShow)                                            \
                 {return CProxyITfLangBarItem::Show(fShow);}                 \
    STDMETHODIMP GetTooltipString(BSTR *pbstr)                               \
                 {return CProxyITfLangBarItem::GetTooltipString(pbstr);}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemButton : public ITfLangBarItemButton,
                                   public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemButton(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemBitmapButton : public ITfLangBarItemBitmapButton,
                                         public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemBitmapButton(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault,SIZE *psz);
    STDMETHODIMP DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask);
    STDMETHODIMP GetText(BSTR *pbstrText);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemBitmap : public ITfLangBarItemBitmap,
                                   public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemBitmap(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault,SIZE *psz);
    STDMETHODIMP DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemBalloon : public ITfLangBarItemBalloon,
                                   public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemBalloon(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault,SIZE *psz);
    STDMETHODIMP GetBalloonInfo(TF_LBBALLOONINFO *pInfo);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfMenu : public ITfMenu,
                                 public CProxyIUnknown
{
public:
    CProxyITfMenu(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP AddMenuItem(UINT uId,
                             DWORD dwFlags,
                             HBITMAP hbmp,
                             HBITMAP hbmpMask,
                             const WCHAR *pch,
                             ULONG cch,
                             ITfMenu **ppMenu);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfInputProcessorProfiles : public ITfInputProcessorProfiles,
                                        public CProxyIUnknown
{
public:
    CProxyITfInputProcessorProfiles(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP Register(REFCLSID rclsid);

    STDMETHODIMP Unregister(REFCLSID rclsid);

    STDMETHODIMP AddLanguageProfile(REFCLSID rclsid,
                               LANGID langid,
                               REFGUID guidProfile,
                               const WCHAR *pchDesc,
                               ULONG cchDesc,
                               const WCHAR *pchIconFile,
                               ULONG cchFile,
                               ULONG uIconIndex);

    STDMETHODIMP RemoveLanguageProfile(REFCLSID rclsid,
                                  LANGID langid,
                                  REFGUID guidProfile);

    STDMETHODIMP EnumInputProcessorInfo(IEnumGUID **ppEnum);

    STDMETHODIMP GetDefaultLanguageProfile(LANGID langid,
                                      REFGUID catid,
                                      CLSID *pclsid,
                                      GUID *pguidProfile);

    STDMETHODIMP SetDefaultLanguageProfile(LANGID langid,
                                      REFCLSID rclsid,
                                      REFGUID guidProfiles);

    STDMETHODIMP ActivateLanguageProfile(REFCLSID rclsid, 
                                    LANGID langid, 
                                    REFGUID guidProfiles);

    STDMETHODIMP GetActiveLanguageProfile(REFCLSID rclsid, 
                                     LANGID *plangid, 
                                     GUID *pguidProfile);

    STDMETHODIMP GetLanguageProfileDescription(REFCLSID rclsid, 
                                          LANGID langid, 
                                          REFGUID guidProfile,
                                          BSTR *pbstrProfile);

    STDMETHODIMP GetCurrentLanguage(LANGID *plangid);

    STDMETHODIMP ChangeCurrentLanguage(LANGID langid);

    STDMETHODIMP GetLanguageList(LANGID **ppLangId,
                            ULONG *pulCount);

    STDMETHODIMP EnumLanguageProfiles(LANGID langid, 
                                 IEnumTfLanguageProfiles **ppEnum);

    STDMETHODIMP EnableLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile,
                                       BOOL fEnable);

    STDMETHODIMP IsEnabledLanguageProfile(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          BOOL *pfEnable);

    STDMETHODIMP EnableLanguageProfileByDefault(REFCLSID rclsid,
                                                LANGID langid,
                                                REFGUID guidProfile,
                                                BOOL fEnable);

    STDMETHODIMP SubstituteKeyboardLayout(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          HKL hKL);

    DBG_ID_DECLARE;
};

#endif // MPROXY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\msaa.h ===
//
// msaa.h
//

#ifndef MSAA_H
#define MSAA_H

// when we ditch atl, this should be a static class!  we don't need to allocate any memory!
class CMSAAControl : public ITfMSAAControl,
                     public CComObjectRoot_CreateInstance<CMSAAControl>
{
public:
    CMSAAControl() {}

    BEGIN_COM_MAP_IMMX(CMSAAControl)
        COM_INTERFACE_ENTRY(ITfMSAAControl)
    END_COM_MAP_IMMX()

    // ITfMSAAControl
    STDMETHODIMP SystemEnableMSAA();
    STDMETHODIMP SystemDisableMSAA();
};

#endif // MSAA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\mstub.cpp ===
//
// mstub.cpp
//

#include "private.h"
#include "mstub.h"
#include "mproxy.h"
#include "ithdmshl.h"
#include "transmit.h"


//////////////////////////////////////////////////////////////////////////////
//
// StubCreator
//
//////////////////////////////////////////////////////////////////////////////

#define CREATENEWSTUB(interface_name)                                      \
    if (IsEqualIID(riid, IID_ ## interface_name ## ))                      \
    {                                                                      \
        CStub *pStub =  new CStub ## interface_name ## ;                   \
        if (!pStub)                                                        \
             return NULL;                                                  \
        pStub->_iid = riid;                                                \
        pStub->_ulStubId = ulStubId;                                       \
        pStub->_dwStubTime = dwStubTime;                                   \
        pStub->_dwStubThreadId = dwCurThreadId;                            \
        pStub->_dwStubProcessId = dwCurProcessId;                          \
        pStub->_dwSrcThreadId = dwSrcThreadId;                             \
        pStub->_punk = punk;                                               \
        pStub->_punk->AddRef();                                            \
        return pStub;                                                      \
    }                                                                      

CStub *StubCreator(REFIID riid, IUnknown *punk, ULONG ulStubId, DWORD dwStubTime, DWORD dwCurThreadId, DWORD dwCurProcessId, DWORD dwSrcThreadId)
{
    Assert(dwCurThreadId != dwSrcThreadId);

    CREATENEWSTUB(ITfLangBarMgr);
    CREATENEWSTUB(ITfLangBarItemMgr);
    CREATENEWSTUB(ITfLangBarItemSink);
    CREATENEWSTUB(IEnumTfLangBarItems);
    CREATENEWSTUB(ITfLangBarItem);
    CREATENEWSTUB(ITfLangBarItemButton);
    CREATENEWSTUB(ITfLangBarItemBitmapButton);
    CREATENEWSTUB(ITfLangBarItemBitmap);
    CREATENEWSTUB(ITfLangBarItemBalloon);
    CREATENEWSTUB(ITfMenu);
    CREATENEWSTUB(ITfInputProcessorProfiles);
    return NULL;
}


void StubPointerToParam(MARSHALPARAM *pParam, void *pv)
{
    Assert(pParam->dwFlags & MPARAM_OUT);
    Assert(pParam->cbBufSize >= sizeof(void *));
    void **ppv = (void **)ParamToBufferPointer(pParam);
    *ppv = pv;
}

void StubParamPointerToParam(MARSHALPARAM *pParam, void *pv)
{
    Assert(pParam->dwFlags & MPARAM_OUT);
    Assert(pParam->cbBufSize >= sizeof(void *));
    void *pBuf = ParamToBufferPointer(pParam);
    memcpy(pBuf, pv, pParam->cbBufSize);
}

void *ParamToMarshaledPointer(MARSHALMSG *pMsg, REFIID riid, ULONG ulParam, BOOL *pfNULLStack = NULL)
{
    MARSHALINTERFACEPARAM *pmiparam = (MARSHALINTERFACEPARAM *)ParamToBufferPointer(pMsg, ulParam);
    void *pv = NULL;

    Assert(pfNULLStack || !pmiparam->fNULLStack);
    if (pfNULLStack)
       *pfNULLStack = pmiparam->fNULLStack;

    if (pmiparam->fNULLPointer)
        return NULL;
   
    CicCoUnmarshalInterface(riid, pMsg->dwSrcThreadId, pmiparam->ulStubId, pmiparam->dwStubTime, &pv);
    return pv;
}

BOOL ParamToArrayMarshaledPointer(ULONG ulCount, void **ppv, MARSHALMSG *pMsg, REFIID riid, ULONG ulParam, BOOL *pfNULLStack = NULL)
{
    MARSHALINTERFACEPARAM *pmiparam = (MARSHALINTERFACEPARAM *)ParamToBufferPointer(pMsg, ulParam);

    Assert(pfNULLStack || !pmiparam->fNULLStack);
    if (pfNULLStack)
       *pfNULLStack = pmiparam->fNULLStack;

    if (pmiparam->fNULLPointer)
        return FALSE;
   
    ULONG ul;
    for (ul = 0; ul < ulCount; ul++)
    {
        CicCoUnmarshalInterface(riid, pMsg->dwSrcThreadId, pmiparam->ulStubId, pmiparam->dwStubTime, ppv);
        ppv++;
        pmiparam++;
    }
    return TRUE;
}

void ClearMarshaledPointer(IUnknown *punk)
{
    if (!punk)
        return;

    CProxyIUnknown *pProxy = GetCProxyIUnknown(punk);
    if (!pProxy)
        return;

    if (pProxy->InternalRelease())
        pProxy->InternalRelease();
    else
        Assert(0);
}

HBITMAP ParamToHBITMAP(MARSHALMSG *pMsg , ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    HBITMAP hbmp = NULL;
    if (pParam->cbBufSize)
    {
        BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
        Cic_HBITMAP_UserUnmarshal(pBuf, &hbmp);
    }
    return hbmp;
}

#define PREPARE_PARAM_START()                             \
    if (!psb->GetMutex()->Enter())                        \
        return E_FAIL;                                    \
    _try                                                  \
    {

#define PREPARE_PARAM_END()                               \
    }                                                     \
    _except(1)                                            \
    {                                                     \
        Assert(0);                                        \
        psb->GetMutex()->Leave();                         \
        return E_FAIL;                                    \
    }                                                     \
    psb->GetMutex()->Leave();

//////////////////////////////////////////////////////////////////////////////
//
// CStubIUnknown
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubIUnknown::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release
};

HRESULT CStubIUnknown::stub_QueryInterface(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    IID iid;
    void *pv;

    Assert(pMsg->ulParamNum == 2);

    PREPARE_PARAM_START()

    iid = *(IID *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = _this->_punk->QueryInterface(iid, &pv);

    if (SUCCEEDED(hrRet))
    {
        _this->_AddRef();
    }
    else
    {
        pv = NULL;
    }

    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&iid)
    CSTUB_PARAM_INTERFACE_OUT(&pv, iid)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_OUT_RELEASE(pv)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubIUnknown::stub_AddRef(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    Assert(pMsg->ulParamNum == 0);
    pMsg->ulRet = _this->_punk->AddRef();
    _this->_AddRef();
    return S_OK;
}

HRESULT CStubIUnknown::stub_Release(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    Assert(pMsg->ulParamNum == 0);
    pMsg->ulRet = _this->_punk->Release();

    if (!pMsg->ulRet)
        _this->_punk = NULL;
        
    _this->_Release();
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarMgr::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_AdviseEventSink,
    stub_UnadviseEventSink,
    stub_GetThreadMarshalInterface,
    stub_GetThreadLangBarItemMgr,
    stub_GetInputProcessorProfiles,
    stub_RestoreLastFocus,
    stub_SetModalInput,
    stub_ShowFloating,
    stub_GetShowFloatingStatus,
};

HRESULT CStubITfLangBarMgr::stub_AdviseEventSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_UnadviseEventSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetThreadMarshalInterface(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetThreadLangBarItemMgr(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetInputProcessorProfiles(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_RestoreLastFocus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_SetModalInput(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_ShowFloating(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetShowFloatingStatus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemMgr::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_EnumItems,
    stub_GetItem,
    stub_AddItem,
    stub_RemoveItem,
    stub_AdviseItemSink,
    stub_UnadviseItemSink,
    stub_GetItemFloatingRect,
    stub_GetItemsStatus,
    stub_GetItemNum,
    stub_GetItems,
    stub_AdviseItemsSink,
    stub_UnadviseItemsSink,
};

HRESULT CStubITfLangBarItemMgr::stub_EnumItems(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    void *pv = NULL;

    Assert(pMsg->ulParamNum == 1);
    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->EnumItems((IEnumTfLangBarItems **)&pv);

    CSTUB_PARAM_START()
    CSTUB_PARAM_INTERFACE_OUT(&pv, IID_IEnumTfLangBarItems)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_OUT_RELEASE(pv)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_GetItem(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfLangBarItemMgr::stub_AddItem(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfLangBarItemMgr::stub_RemoveItem(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfLangBarItemMgr::stub_AdviseItemSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TraceMsg(TF_FUNC, "CStubITfLangbarItemMgr::AdviseItemSink");
    ITfLangBarItemSink *punk = NULL;
    DWORD dwCookie = 0;
    GUID guid = {0};

    PREPARE_PARAM_START()

    punk = (ITfLangBarItemSink *)ParamToMarshaledPointer(pMsg, IID_ITfLangBarItemSink, 0);
    guid = *(GUID *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemMgr *)_this->_punk)->AdviseItemSink(punk, &dwCookie, (REFGUID)guid);

    ClearMarshaledPointer(punk);
    CSTUB_PARAM_START()
    CSTUB_PARAM_INTERFACE_IN(NULL, IID_ITfLangBarItemSink)
    CSTUB_PARAM_POINTER_OUT(&dwCookie)
    CSTUB_PARAM_POINTER_IN(&guid)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_UnadviseItemSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    DWORD dwCookie = 0;

    PREPARE_PARAM_START()

    dwCookie = (DWORD)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemMgr *)_this->_punk)->UnadviseItemSink(dwCookie);
    return S_OK;
}

HRESULT CStubITfLangBarItemMgr::stub_GetItemFloatingRect(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    DWORD dwThreadId = 0;
    GUID guid = {0};

    PREPARE_PARAM_START()

    dwThreadId = (DWORD)ParamToULONG(pMsg, 0);
    guid = *(GUID *)ParamToBufferPointer(pMsg, 1);

    PREPARE_PARAM_END()

    RECT rc;
    HRESULT hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItemFloatingRect(dwThreadId, guid, &rc);
    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(dwThreadId)
    CSTUB_PARAM_POINTER_IN(&guid)
    CSTUB_PARAM_POINTER_OUT(&rc)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
    return S_OK;
}

HRESULT CStubITfLangBarItemMgr::stub_GetItemsStatus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount = 0;
    GUID *pguid = NULL;

    PREPARE_PARAM_START()

    ulCount = (ULONG)ParamToULONG(pMsg, 0);
    pguid = new GUID[ulCount];

    if (pguid)
        memcpy(pguid, ParamToBufferPointer(pMsg, 1), sizeof(GUID) * ulCount);

    PREPARE_PARAM_END()

    if (!pguid)
        return E_OUTOFMEMORY;

    DWORD *pdwStatus;

    pdwStatus = new DWORD[ulCount];
    if (!pdwStatus)
    {
        delete pguid;
        return E_OUTOFMEMORY;
    }

    HRESULT hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItemsStatus(ulCount, pguid, pdwStatus);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_POINTER_ARRAY_IN(pguid, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    delete pdwStatus;
    delete pguid;
    CSTUB_PARAM_RETURN()
    return S_OK;
}

HRESULT CStubITfLangBarItemMgr::stub_GetItemNum(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    DWORD dw;
    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItemNum(&dw);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&dw)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_GetItems(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount;
    ULONG ulFetched;
    HRESULT hrRet;
    IUnknown **ppunk;
    TF_LANGBARITEMINFO *pInfo;
    DWORD *pdwStatus;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    ppunk = new IUnknown*[ulCount];
    if (!ppunk)
         return E_OUTOFMEMORY;

    pInfo = new TF_LANGBARITEMINFO[ulCount];
    if (!pInfo)
    {
        delete ppunk;
        return E_OUTOFMEMORY;
    }

    pdwStatus = new DWORD[ulCount];
    if (!pdwStatus)
    {
        delete ppunk;
        delete pInfo;
        return E_OUTOFMEMORY;
    }

    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItems(ulCount, (ITfLangBarItem **)ppunk, pInfo, pdwStatus, &ulFetched);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_INTERFACE_ARRAY_OUT(ppunk, IID_ITfLangBarItem, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pInfo, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CSTUB_PARAM_POINTER_OUT(&ulFetched)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(ppunk, ulFetched)

    delete ppunk;
    delete pInfo;
    delete pdwStatus;
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_AdviseItemsSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount = 0;
    HRESULT hrRet;
    IUnknown **ppunk = NULL;
    DWORD *pdwCookie = NULL;
    GUID *pguid = NULL;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);


    ppunk = new IUnknown*[ulCount];

    if (ppunk)
        ParamToArrayMarshaledPointer(ulCount, (void **)ppunk, pMsg, IID_ITfLangBarItemSink, 1);

    pguid = new GUID[ulCount];
    if (pguid)
        memcpy(pguid, ParamToBufferPointer(pMsg, 2), sizeof(GUID) * ulCount);

    PREPARE_PARAM_END()

    if (!ppunk)
    {
        if (pguid)
            delete pguid;
        return E_OUTOFMEMORY;
    }

    if (!pguid)
    {
        delete ppunk;
        return E_OUTOFMEMORY;
    }

    pdwCookie = new DWORD[ulCount];
    if (!pdwCookie)
    {
        delete ppunk;
        delete pguid;
        return E_OUTOFMEMORY;
    }

    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->AdviseItemsSink(ulCount, (ITfLangBarItemSink **)ppunk, pguid, pdwCookie);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_INTERFACE_ARRAY_IN(NULL, IID_ITfLangBarItemSink, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_IN(pguid, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pdwCookie, ulCount)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);

    CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(ppunk, ulCount)

    delete ppunk;
    delete pdwCookie;
    delete pguid;
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_UnadviseItemsSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount;
    HRESULT hrRet;
    DWORD *pdwCookie;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);

    pdwCookie = new DWORD[ulCount];
    if (pdwCookie)
        memcpy(pdwCookie,ParamToBufferPointer(pMsg, 1), sizeof(DWORD) * ulCount);

    PREPARE_PARAM_END()

    if (!pdwCookie)
        return E_OUTOFMEMORY;

    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->UnadviseItemsSink(ulCount, pdwCookie);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_POINTER_ARRAY_IN(pdwCookie, ulCount)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);

    delete pdwCookie;
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemSink::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_OnUpdate,
};

HRESULT CStubITfLangBarItemSink::stub_OnUpdate(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    DWORD dw = 0;

    PREPARE_PARAM_START()

    dw = (DWORD)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemSink *)_this->_punk)->OnUpdate(dw);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubIEnumTfLangBarItems
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubIEnumTfLangBarItems::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_Clone,
    stub_Next,
    stub_Reset,
    stub_Skip,
};

HRESULT CStubIEnumTfLangBarItems::stub_Clone(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubIEnumTfLangBarItems::stub_Next(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount;
    ULONG ulFetched;
    HRESULT hrRet;
    IUnknown **ppunk;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    ppunk = new IUnknown*[ulCount];
    if (!ppunk)
         return E_OUTOFMEMORY;

    hrRet = ((IEnumTfLangBarItems *)_this->_punk)->Next(ulCount, (ITfLangBarItem **)ppunk, &ulFetched);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_INTERFACE_ARRAY_OUT(ppunk, IID_ITfLangBarItem, ulCount)
    CSTUB_PARAM_POINTER_OUT(&ulFetched)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(ppunk, ulFetched)

    delete ppunk;
    CSTUB_PARAM_RETURN()
}

HRESULT CStubIEnumTfLangBarItems::stub_Reset(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubIEnumTfLangBarItems::stub_Skip(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItem::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString
};

HRESULT CStubITfLangBarItem::stub_GetInfo(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    TF_LANGBARITEMINFO info;
    hrRet = ((ITfLangBarItem *)_this->_punk)->GetInfo(&info);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&info)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItem::stub_GetStatus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    DWORD dw;
    hrRet = ((ITfLangBarItem *)_this->_punk)->GetStatus(&dw);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&dw)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItem::stub_Show(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BOOL fShow = FALSE;

    PREPARE_PARAM_START()

    fShow = (BOOL)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItem *)_this->_punk)->Show(fShow);
    return S_OK;
}

HRESULT CStubITfLangBarItem::stub_GetTooltipString(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BSTR bstr = NULL;
    HRESULT hrRet = ((ITfLangBarItem *)_this->_punk)->GetTooltipString(&bstr);
    CSTUB_PARAM_START()
    CSTUB_PARAM_BSTR_OUT(bstr)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemButton::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_InitMenu,
    stub_OnMenuSelect,
    stub_GetIcon,
    stub_GetText,
};

HRESULT CStubITfLangBarItemButton::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemButton *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemButton::stub_InitMenu(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ITfMenu *punk = NULL;

    PREPARE_PARAM_START()

    punk = (ITfMenu *)ParamToMarshaledPointer(pMsg, IID_ITfMenu, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemButton *)_this->_punk)->InitMenu(punk);

    CSTUB_PARAM_INTERFACE_OUT_RELEASE(punk)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemButton::stub_OnMenuSelect(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulId;

    PREPARE_PARAM_START()

    ulId = (ULONG)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemButton *)_this->_punk)->OnMenuSelect(ulId);
    return S_OK;
}

HRESULT CStubITfLangBarItemButton::stub_GetIcon(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HICON hIcon;
    HRESULT hrRet = ((ITfLangBarItemButton *)_this->_punk)->GetIcon(&hIcon);
    CSTUB_PARAM_START()
    CSTUB_PARAM_HICON_OUT(&hIcon)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemButton::stub_GetText(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BSTR bstr = NULL;
    HRESULT hrRet = ((ITfLangBarItemButton *)_this->_punk)->GetText(&bstr);
    CSTUB_PARAM_START()
    CSTUB_PARAM_BSTR_OUT(bstr)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemBitmapButton::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_InitMenu,
    stub_OnMenuSelect,
    stub_GetPreferredSize,
    stub_DrawBitmap,
    stub_GetText,
};

HRESULT CStubITfLangBarItemBitmapButton::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemBitmapButton::stub_InitMenu(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ITfMenu *punk;

    PREPARE_PARAM_START()

    punk = (ITfMenu *)ParamToMarshaledPointer(pMsg, IID_ITfMenu, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->InitMenu(punk);

    CSTUB_PARAM_INTERFACE_OUT_RELEASE(punk)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmapButton::stub_OnMenuSelect(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulId;

    PREPARE_PARAM_START()

    ulId = (ULONG)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->OnMenuSelect(ulId);
    return S_OK;
}

HRESULT CStubITfLangBarItemBitmapButton::stub_GetPreferredSize(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    SIZE size;
    SIZE sizeOut;

    PREPARE_PARAM_START()

    size = *(SIZE *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->GetPreferredSize(&size, &sizeOut);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&size)
    CSTUB_PARAM_POINTER_OUT(&sizeOut)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmapButton::stub_DrawBitmap(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG bmWidth;
    ULONG bmHeight;
    DWORD dwFlags;

    PREPARE_PARAM_START()

    bmWidth = (ULONG)ParamToULONG(pMsg, 0);
    bmHeight = (ULONG)ParamToULONG(pMsg, 1);
    dwFlags = (DWORD)ParamToULONG(pMsg, 2);

    PREPARE_PARAM_END()

    HBITMAP hbmp;
    HBITMAP hbmpMask;
    HRESULT hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->DrawBitmap(bmWidth, bmHeight, dwFlags, &hbmp, &hbmpMask);
    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(bmWidth)
    CSTUB_PARAM_ULONG_IN(bmHeight)
    CSTUB_PARAM_ULONG_IN(dwFlags)
    CSTUB_PARAM_HBITMAP_OUT(&hbmp)
    CSTUB_PARAM_HBITMAP_OUT(&hbmpMask)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmapButton::stub_GetText(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BSTR bstr = NULL;
    HRESULT hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->GetText(&bstr);
    CSTUB_PARAM_START()
    CSTUB_PARAM_BSTR_OUT(bstr)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemBitmap::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_GetPreferredSize,
    stub_DrawBitmap,
};

HRESULT CStubITfLangBarItemBitmap::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmap *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemBitmap::stub_GetPreferredSize(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    SIZE size;
    SIZE sizeOut;

    PREPARE_PARAM_START()

    size = *(SIZE *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemBitmap *)_this->_punk)->GetPreferredSize(&size, &sizeOut);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&size)
    CSTUB_PARAM_POINTER_OUT(&sizeOut)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmap::stub_DrawBitmap(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG bmWidth;
    ULONG bmHeight;
    DWORD dwFlags;

    PREPARE_PARAM_START()

    bmWidth = (ULONG)ParamToULONG(pMsg, 0);
    bmHeight = (ULONG)ParamToULONG(pMsg, 1);
    dwFlags = (DWORD)ParamToULONG(pMsg, 2);

    PREPARE_PARAM_END()

    HBITMAP hbmp;
    HBITMAP hbmpMask;
    HRESULT hrRet = ((ITfLangBarItemBitmap *)_this->_punk)->DrawBitmap(bmWidth, bmHeight, dwFlags, &hbmp, &hbmpMask);
    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(bmWidth)
    CSTUB_PARAM_ULONG_IN(bmHeight)
    CSTUB_PARAM_ULONG_IN(dwFlags)
    CSTUB_PARAM_HBITMAP_OUT(&hbmp)
    CSTUB_PARAM_HBITMAP_OUT(&hbmpMask)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemBalloon::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_GetPreferredSize,
    stub_GetBalloonInfo,
};

HRESULT CStubITfLangBarItemBalloon::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBalloon *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemBalloon::stub_GetPreferredSize(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    SIZE size;
    SIZE sizeOut;

    PREPARE_PARAM_START()

    size = *(SIZE *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemBalloon *)_this->_punk)->GetPreferredSize(&size, &sizeOut);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&size)
    CSTUB_PARAM_POINTER_OUT(&sizeOut)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBalloon::stub_GetBalloonInfo(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TF_LBBALLOONINFO info;
    HRESULT hrRet = ((ITfLangBarItemBalloon *)_this->_punk)->GetBalloonInfo(&info);
    CSTUB_PARAM_START()
    CSTUB_PARAM_TF_LBBALLOONINFO_OUT(&info)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfMenu
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfMenu::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_AddItemMenu,
};

HRESULT CStubITfMenu::stub_AddItemMenu(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    UINT uId = 0;
    DWORD dwFlags = 0;
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    WCHAR *pchTemp = NULL;
    ULONG cch = 0;
    WCHAR *pch = NULL;
    BOOL fNULLStack;
    ITfMenu *pMenu = NULL;

    PREPARE_PARAM_START()

    uId = (ULONG)ParamToULONG(pMsg, 0);
    dwFlags = (ULONG)ParamToULONG(pMsg, 1);
    hbmp = ParamToHBITMAP(pMsg, 2);
    hbmpMask = ParamToHBITMAP(pMsg, 3);
    pchTemp = (WCHAR *)ParamToBufferPointer(pMsg, 4);
    cch = (ULONG)ParamToULONG(pMsg, 5);
    pch = new WCHAR[cch + 1];
    if (pch)
        wcsncpy(pch, pchTemp, cch);

    pMenu = (ITfMenu *)ParamToMarshaledPointer(pMsg, IID_ITfMenu, 6, &fNULLStack);

    PREPARE_PARAM_END()

    if (!pch)
        return E_OUTOFMEMORY;


    HRESULT hrRet = ((ITfMenu *)_this->_punk)->AddMenuItem(uId,
                                             dwFlags,
                                             hbmp,
                                             hbmpMask,
                                             pch,
                                             cch,
                                             !fNULLStack ? &pMenu : NULL);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(uId)
    CSTUB_PARAM_ULONG_IN(dwFlags)
    CSTUB_PARAM_HBITMAP_IN(hbmp)
    CSTUB_PARAM_HBITMAP_IN(hbmpMask)
    CSTUB_PARAM_POINTER_IN(pch)
    CSTUB_PARAM_ULONG_IN(cch)
    CSTUB_PARAM_INTERFACE_OUT(&pMenu, IID_ITfMenu)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_INTERFACE_OUT_RELEASE(pMenu)

    delete pch;

    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfInputProcessorProfiles::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_Register,
    stub_Unregister,
    stub_AddLanguageProfile,
    stub_RemoveLanguageProfile,
    stub_EnumInputProcessorInfo,
    stub_GetDefaultLanguageProfile,
    stub_SetDefaultLanguageProfile,
    stub_ActivateLanguageProfile,
    stub_GetActiveLanguageProfile,
    stub_GetCurrentLanguage,
    stub_ChangeCurrentLanguage,
    stub_GetLanguageList,
    stub_EnumLanguageProfiles,
    stub_EnableLanguageProfile,
    stub_IsEnabledLanguageProfile,
    stub_EnableLanguageProfileByDefault,
    stub_SubstituteKeyboardLayout,
};


HRESULT CStubITfInputProcessorProfiles::stub_Register(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_Unregister(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_AddLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_RemoveLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnumInputProcessorInfo(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetDefaultLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_SetDefaultLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_ActivateLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetActiveLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetLanguageProfileDescription(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetCurrentLanguage(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    LANGID langid;
    HRESULT hrRet = ((ITfInputProcessorProfiles *)_this->_punk)->GetCurrentLanguage(&langid);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&langid)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfInputProcessorProfiles::stub_ChangeCurrentLanguage(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetLanguageList(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnumLanguageProfiles(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnableLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_IsEnabledLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnableLanguageProfileByDefault(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_SubstituteKeyboardLayout(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\mstub.h ===
//
// mstub.h
//

#ifndef MSTUB_H
#define MSTUB_H

#include "private.h"
#include "marshal.h"
#include "ptrary.h"
#include "strary.h"
#include "cicmutex.h"
#include "smblock.h"

typedef HRESULT (*MSTUBCALL)(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb);

CStub *StubCreator(REFIID riid, IUnknown *punk, ULONG ulStubId, DWORD dwStubTime, DWORD dwCurThreadId, DWORD dwCurProcessId, DWORD dwSrcThreadId);

#define STUBINVOKE_IMPL(interface_name)                                       \
    public:                                                                   \
        HRESULT Invoke(MARSHALMSG *pMsg, CSharedBlock *psb)                   \
        {                                                                     \
            TraceMsg(TF_FUNC,                                                 \
                     "Stub " #interface_name " ulMethodId - %x",              \
                     pMsg->ulMethodId);                                       \
            return _StubTbl[pMsg->ulMethodId](this, pMsg, psb);               \
        }                                                                     \
    private:                                                                  \
        static MSTUBCALL _StubTbl[]; 

#define STUBFUNC_DEF(method_name)                                             \
    static HRESULT stub_ ## method_name ## (CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb);

//////////////////////////////////////////////////////////////////////////////
//
// CStubIUnknown
//
//////////////////////////////////////////////////////////////////////////////

class CStubIUnknown : public CStub
{
    STUBINVOKE_IMPL(IUnknwon);
protected:
    STUBFUNC_DEF(QueryInterface)
    STUBFUNC_DEF(AddRef)
    STUBFUNC_DEF(Release)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarMgr : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarMgr);
private:
    STUBFUNC_DEF(AdviseEventSink)
    STUBFUNC_DEF(UnadviseEventSink)
    STUBFUNC_DEF(GetThreadMarshalInterface)
    STUBFUNC_DEF(GetThreadLangBarItemMgr)
    STUBFUNC_DEF(GetInputProcessorProfiles)
    STUBFUNC_DEF(RestoreLastFocus)
    STUBFUNC_DEF(SetModalInput)
    STUBFUNC_DEF(ShowFloating)
    STUBFUNC_DEF(GetShowFloatingStatus)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemMgr : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarItemMgr);
private:
    STUBFUNC_DEF(EnumItems)
    STUBFUNC_DEF(GetItem)
    STUBFUNC_DEF(AddItem)
    STUBFUNC_DEF(RemoveItem)
    STUBFUNC_DEF(AdviseItemSink)
    STUBFUNC_DEF(UnadviseItemSink)
    STUBFUNC_DEF(GetItemFloatingRect)
    STUBFUNC_DEF(GetItemsStatus)
    STUBFUNC_DEF(GetItemNum)
    STUBFUNC_DEF(GetItems)
    STUBFUNC_DEF(AdviseItemsSink)
    STUBFUNC_DEF(UnadviseItemsSink)

};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemSink : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarItemSink);

public:
    STUBFUNC_DEF(OnUpdate)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubIEnumTfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CStubIEnumTfLangBarItems : public CStubIUnknown
{
    STUBINVOKE_IMPL(IEnumTfLangBarItems);

public:
    STUBFUNC_DEF(Clone)
    STUBFUNC_DEF(Next)
    STUBFUNC_DEF(Reset)
    STUBFUNC_DEF(Skip)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItem : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarItem);

public:
    STUBFUNC_DEF(GetInfo)
    STUBFUNC_DEF(GetStatus)
    STUBFUNC_DEF(Show)
    STUBFUNC_DEF(GetTooltipString)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemButton : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemButton);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(InitMenu)
    STUBFUNC_DEF(OnMenuSelect)
    STUBFUNC_DEF(GetIcon)
    STUBFUNC_DEF(GetText)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemBitmapButton : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemBitmapButton);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(InitMenu)
    STUBFUNC_DEF(OnMenuSelect)
    STUBFUNC_DEF(GetPreferredSize)
    STUBFUNC_DEF(DrawBitmap)
    STUBFUNC_DEF(GetText)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemBitmap : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemBitmap);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(GetPreferredSize)
    STUBFUNC_DEF(DrawBitmap)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemBalloon : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemBalloon);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(GetPreferredSize)
    STUBFUNC_DEF(GetBalloonInfo)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfMenu : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfMenu);

public:
    STUBFUNC_DEF(AddItemMenu)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfInputProcessorProfiles : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfInputProcessorProfiles);
public:
    STUBFUNC_DEF(Register)
    STUBFUNC_DEF(Unregister)
    STUBFUNC_DEF(AddLanguageProfile)
    STUBFUNC_DEF(RemoveLanguageProfile)
    STUBFUNC_DEF(EnumInputProcessorInfo)
    STUBFUNC_DEF(GetDefaultLanguageProfile)
    STUBFUNC_DEF(SetDefaultLanguageProfile)
    STUBFUNC_DEF(ActivateLanguageProfile)
    STUBFUNC_DEF(GetActiveLanguageProfile)
    STUBFUNC_DEF(GetLanguageProfileDescription)
    STUBFUNC_DEF(GetCurrentLanguage)
    STUBFUNC_DEF(ChangeCurrentLanguage)
    STUBFUNC_DEF(GetLanguageList)
    STUBFUNC_DEF(EnumLanguageProfiles)
    STUBFUNC_DEF(EnableLanguageProfile)
    STUBFUNC_DEF(IsEnabledLanguageProfile)
    STUBFUNC_DEF(EnableLanguageProfileByDefault)
    STUBFUNC_DEF(SubstituteKeyboardLayout)
};

#endif MSTUB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\normal.cpp ===
//
// normal.cpp
//

#include "private.h"
#include "normal.h"
#include "txtcache.h"

//+---------------------------------------------------------------------------
//
// GetTextComplete
//
// Wrapper for GetText that keeps asking until the input buffers are full.
//----------------------------------------------------------------------------

HRESULT GetTextComplete(ITextStoreACP *ptsi, LONG acpStart, LONG acpEnd,
                        WCHAR *pchPlain, ULONG cchPlainReq,
                        ULONG *pcchPlainOut, TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                        LONG *pacpNext)
{
    ULONG cchPlainOut;
    ULONG ulRunInfoOut;
    BOOL fNoMoreSpace;
    HRESULT hr;

    fNoMoreSpace = FALSE;

    *pcchPlainOut = 0;
    *pulRunInfoOut = 0;

    while (TRUE)
    {
        Perf_IncCounter(PERF_NORM_GETTEXTCOMPLETE);

        hr = CProcessTextCache::GetText(ptsi, acpStart, acpEnd, pchPlain, cchPlainReq, &cchPlainOut,
                                        prgRunInfo, ulRunInfoReq, &ulRunInfoOut, pacpNext);

        if (hr != S_OK)
            break;

        if (cchPlainOut == 0 && ulRunInfoOut == 0)
            break; // eod

        if (cchPlainReq > 0 && cchPlainOut > 0)
        {
            cchPlainReq -= cchPlainOut;
            *pcchPlainOut += cchPlainOut;

            if (cchPlainReq == 0)
            {
                fNoMoreSpace = TRUE;
            }
            else
            {
                pchPlain += cchPlainOut;
            }
        }
        if (ulRunInfoReq > 0)
        {
            Assert(ulRunInfoOut > 0 && prgRunInfo->uCount > 0); // app bug?

            if (ulRunInfoOut == 0)
                break; // woah, app bug, avoid infinite loop

            ulRunInfoReq -= ulRunInfoOut;
            *pulRunInfoOut += ulRunInfoOut;

            if (ulRunInfoReq == 0)
            {
                fNoMoreSpace = TRUE;
            }
            else
            {
                prgRunInfo += ulRunInfoOut;
            }
        }

        if (fNoMoreSpace)
            break; // buffers full

        if (*pacpNext == acpEnd)
            break; // got it all

        acpStart = *pacpNext;
        Assert(acpStart < acpEnd);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// PlainTextOffset
//
// NB: current implementation always skips hidden text.
//----------------------------------------------------------------------------

HRESULT PlainTextOffset(ITextStoreACP *ptsi, LONG ichAppBase, LONG iAppOffset, LONG *piPlainOffset)
{
    BOOL fNeg;
    HRESULT hr;
    ULONG uRunInfoLen;
    ULONG cch;
    ULONG cchPlain;
    TS_RUNINFO *pri;
    TS_RUNINFO *priStop;
    TS_RUNINFO rgRunInfo[32];

    *piPlainOffset = 0;

    if (iAppOffset == 0)
        return S_OK;

    fNeg = FALSE;

    if (iAppOffset < 0)
    {
        fNeg = TRUE;
        ichAppBase += iAppOffset;
        iAppOffset = -iAppOffset;
    }

    cchPlain = 0;

    do
    {
        Perf_IncCounter(PERF_PTO_GETTEXT);

        hr = CProcessTextCache::GetText(ptsi, ichAppBase, ichAppBase + iAppOffset, NULL, 0, &cch,
                                        rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &ichAppBase);

        if (hr != S_OK)
            goto Exit;

        if (uRunInfoLen == 0 || rgRunInfo[0].uCount == 0)
        {
            Assert(0); // this should never happen, it means cicero is referencing a position past end-of-doc
            hr = E_UNEXPECTED;
            goto Exit;
        }

        cch = 0;
        pri = rgRunInfo;
        priStop = rgRunInfo + uRunInfoLen;

        while (pri < priStop)
        {
            if (pri->type == TS_RT_PLAIN)
            {
                cchPlain += pri->uCount;
            }
            iAppOffset -= pri->uCount;
            pri++;
        }

    } while (iAppOffset > 0);

    *piPlainOffset = fNeg ? -(LONG)cchPlain : cchPlain;

    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// AppTextOffsetForward
//
// piAppOffset, on return, points just past the iPlainOffset plain char or eod.
// Use AppTextOffsetNorm for a normalized return value!
//
// Returns S_FALSE if clipped due to bod or eod.
//----------------------------------------------------------------------------

inline IsPlainRun(TS_RUNINFO *pri, BOOL fSkipHidden)
{
    return (pri->type == TS_RT_PLAIN ||
            (!fSkipHidden && pri->type == TS_RT_HIDDEN));
}

HRESULT AppTextOffsetForward(ITextStoreACP *ptsi, LONG ichAppBase, LONG iPlainOffset, LONG *piAppOffset, DWORD dwFlags)
{
    LONG acpStart;
    LONG acpEnd;
    HRESULT hr;
    ULONG uRunInfoLen;
    ULONG cch;
    ULONG cchRead;
    ULONG cchACP;
    TS_RUNINFO *pri;
    TS_RUNINFO *priStop;
    ULONG i;
    WCHAR *pch;
    TS_RUNINFO rgRunInfo[32];
    WCHAR ach[256];
    BOOL fIgnoreRegions = (dwFlags & ATO_IGNORE_REGIONS);
    BOOL fSkipHidden = (dwFlags & ATO_SKIP_HIDDEN);

    Perf_IncCounter(PERF_ATOF_COUNTER);

    Assert(iPlainOffset > 0);
    Assert(*piAppOffset == 0);

    cchACP = 0;
    // Issue: use TsSF_REGIONS
    cchRead = (ULONG)(fIgnoreRegions ? 0 : ARRAYSIZE(ach)); // we only need text if looking for regions

    do
    {        
        acpStart = ichAppBase;
        acpEnd = (ichAppBase + iPlainOffset) < 0 ? LONG_MAX : ichAppBase + iPlainOffset;
        Assert(acpEnd >= acpStart);

        Perf_IncCounter(PERF_ATOF_GETTEXT_COUNTER);

        hr = CProcessTextCache::GetText(ptsi, acpStart, acpEnd, ach, cchRead, &cch,
                                        rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &acpEnd);

        if (hr != S_OK)
        {
            Assert(0);
            goto Exit;
        }

        if (uRunInfoLen == 0) // hit eod?
        {
            hr = S_FALSE;
            break;
        }

        pri = rgRunInfo;
        priStop = rgRunInfo + uRunInfoLen;
        pch = &ach[0];

        while (pri != priStop)
        {
            Assert(pri->uCount > 0); // runs should always be at least one char long

            // scan for region boundary if necessary
            if (!fIgnoreRegions && pri->type != TS_RT_OPAQUE)
            {
                if (IsPlainRun(pri, fSkipHidden))
                {
                    // run is plain or hidden text (and we want to count hidden text)
                    for (i=0; i<pri->uCount; i++)
                    {
                        if (*pch == TS_CHAR_REGION)
                        {
                            // we hit a region boundary, pull out!
                            cchACP += i;
                            hr = S_FALSE; // for normalization
                            goto ExitOK;
                        }
                        pch++;
                    }
                }
                else
                {
                    // run is hidden text, which we want to skip over
                    pch += pri->uCount;
                }       
            }

            cchACP += pri->uCount;
            if (IsPlainRun(pri, fSkipHidden))
            {
                iPlainOffset -= pri->uCount;
            }
            ichAppBase += pri->uCount;
            pri++;
        }
    }
    while (iPlainOffset != 0);

ExitOK:
    *piAppOffset = cchACP;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// AppTextOffsetBackward
//
// piAppOffset, on return, points just past the iPlainOffset plain char or eod.
// Use AppTextOffsetNorm for a normalized return value!
//
// Returns S_FALSE if clipped due to bod or eod.
//----------------------------------------------------------------------------

HRESULT AppTextOffsetBackward(ITextStoreACP *ptsi, LONG ichAppBase, LONG iPlainOffset, LONG *piAppOffset, DWORD dwFlags)
{
    LONG acpStart;
    LONG acpEnd;
    LONG acpEndOut;
    HRESULT hr;
    ULONG uRunInfoLen;
    ULONG cch;
    ULONG cchRead;
    ULONG cchACP;
    TS_RUNINFO *pri;
    TS_RUNINFO *priStop;
    ULONG i;
    TS_RUNINFO rgRunInfo[32];
    WCHAR *pch;
    WCHAR ach[256];
    BOOL fIgnoreRegions = (dwFlags & ATO_IGNORE_REGIONS);
    BOOL fSkipHidden = (dwFlags & ATO_SKIP_HIDDEN);

    Assert(iPlainOffset < 0);
    Assert(*piAppOffset == 0);

    cchACP = 0;
    // Issue: use TsSF_REGIONS
    cchRead = (ULONG)(fIgnoreRegions ? 0 : ARRAYSIZE(ach)); // we only need text if looking for regions

    do
    {
        Assert(iPlainOffset < 0); // if this is >= 0, we or the app messed up the formatting run count

        acpStart = ichAppBase + (fIgnoreRegions ? iPlainOffset : max(iPlainOffset, -(LONG)ARRAYSIZE(ach)));
        acpStart = max(acpStart, 0); // handle top-of-doc collisions
        acpEnd = ichAppBase;
        Assert(acpEnd >= acpStart);

        hr = GetTextComplete(ptsi, acpStart, acpEnd, ach, cchRead, &cch,
                             rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &acpEndOut);

        if (hr != S_OK)
        {
            Assert(0);
            goto Exit;
        }

        if (uRunInfoLen == 0) // hit eod?
        {
            hr = S_FALSE;
            break;
        }

        // it's possible the GetText above didn't return everything we asked for....
        // this happens when our format buffer isn't large enough
        if (acpEndOut != acpEnd)
        {
            // so let's be conservative and ask for something we know should succeed
            acpStart = ichAppBase - ARRAYSIZE(rgRunInfo);

            Assert(acpStart >= 0); // the prev GetText should have succeeded if there were fewer chars than we're asking for now....
            Assert(acpEnd - acpStart < -iPlainOffset); // again, we shouldn't get this far if we already asked for fewer chars
            Assert(ARRAYSIZE(rgRunInfo) < ARRAYSIZE(ach)); // want to ask for the max we can handle in the worst case
            Assert(acpEnd == ichAppBase);

            hr = GetTextComplete(ptsi, acpStart, acpEnd, ach, cchRead, &cch,
                                 rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &acpEndOut);

            if (hr != S_OK)
            {
                Assert(0);
                goto Exit;
            }

            if (uRunInfoLen == 0) // hit eod?
            {
                Assert(0); // this should never happen, because the original call for more chars returned non-zero!
                goto Exit;
            }

            Assert(acpEnd == acpEndOut);
        }

        pri = rgRunInfo + uRunInfoLen - 1;
        priStop = rgRunInfo - 1;
        pch = &ach[cch-1];

        while (pri != priStop)
        {
            Assert(pri->uCount > 0); // runs should always be at least one char long

            // scan for region boundary if necessary
            if (!fIgnoreRegions && pri->type != TS_RT_OPAQUE)
            {
                if (IsPlainRun(pri, fSkipHidden))
                {
                    // run is plain or hidden text (and we want to count hidden text)
                    for (i=0; i<pri->uCount; i++)
                    {
                        if (*pch == TS_CHAR_REGION)
                        {
                            // we hit a region boundary, pull out!
                            cchACP += i;
                            hr = S_FALSE; // for normalization
                            goto ExitOK;
                        }
                        pch--;
                    }
                }
                else
                {
                    // run is hidden text, which we want to skip over
                    pch -= pri->uCount;
                }       
            }

            cchACP += pri->uCount;
            if (IsPlainRun(pri, fSkipHidden))
            {
                iPlainOffset += (LONG)pri->uCount;
            }
            ichAppBase -= (LONG)pri->uCount;
            pri--;
        }

        // also check for top-of-doc
        if (ichAppBase == 0)
        {
            hr = S_FALSE;
            break;
        }

    } while (iPlainOffset != 0);

ExitOK:
    *piAppOffset = -(LONG)cchACP;

Exit:
    return hr;
}

#ifdef UNUSED
//+---------------------------------------------------------------------------
//
// AppTextOffsetNorm
//
// Returns a normalized acp offset that spans the specificed number of plain chars --
// so the return offset is just short of (lPlainOffset + 1), or at eod.  Returns
// S_FALSE if the initial call to AppTextOffset gets clipped because of eod.
//----------------------------------------------------------------------------

HRESULT AppTextOffsetNorm(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset)
{
    HRESULT hr;

    Perf_IncCounter(PERF_ATON_COUNTER);

    // if caller wants a neg offset, return value is already
    // guarenteed normalized -- just before a plain text char.
    // Otherwise, ask for the offset of the next char, then
    // step back one char.
    if ((lPlainOffset < LONG_MAX) && (lPlainOffset >= 0))
    {
        lPlainOffset++;
    }

    hr = AppTextOffset(ptsi, acpAppBase, lPlainOffset, plAppOffset, FALSE);

    if (*plAppOffset > 0)
    {
        if ((lPlainOffset < LONG_MAX) && (hr == S_OK)) // could be S_FALSE if hit eod
        {
            // step back, and we're normalized
            (*plAppOffset)--;
        }
    }
    else if (*plAppOffset < 0)
    {
        // if we moved backwards there's only one case to
        // worry about: if we hit a region boundary.  Then
        // we need to normalize.
        if (hr == S_FALSE)
        {
            *plAppOffset = Normalize(ptsi, acpAppBase + *plAppOffset) - acpAppBase;
        }
    }

#ifndef PERF_DUMP
    Assert(*plAppOffset == Normalize(ptsi, acpAppBase + *plAppOffset) - acpAppBase);
#endif

    return hr;
}
#endif // UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\nuictrl.cpp ===
//depot/Lab06_N/windows/AdvCore/ctf/uim/nuictrl.cpp#50 - edit change 9353 (text)
//
// nui.cpp
//

#include "private.h"
#include "globals.h"
#include "nuictrl.h"
#include "xstring.h"
#include "immxutil.h"
#include "tim.h"
#include "profiles.h"
#include "ctffunc.h"
#include "slbarid.h"
#include "cregkey.h"
#include "cmydc.h"
#include "nuihkl.h"
#include "cresstr.h"
#include "slbarid.h"
#include "iconlib.h"


DBG_ID_INSTANCE(CLBarItemCtrl);
DBG_ID_INSTANCE(CLBarItemHelp);

#define SHOW_BRANDINGICON 1

//---------------------------------------------------------------------------
//
// TF_RunInputCPL
//
//---------------------------------------------------------------------------

HRESULT WINAPI TF_RunInputCPL()
{
    CicSystemModulePath fullpath;
    TCHAR szRunInputCPLCmd[MAX_PATH * 2];
    UINT uLen = 0;
    HRESULT hr = E_FAIL;

    if (IsOnNT51())
        fullpath.Init(c_szRunInputCPLOnNT51);
    else if (IsOn98() || IsOn95())
        fullpath.Init(c_szRunInputCPLOnWin9x);
    else
        fullpath.Init(c_szRunInputCPL);

    if (!fullpath.GetLength())
        return hr;

    StringCchPrintf(szRunInputCPLCmd,
                    ARRAYSIZE(szRunInputCPLCmd),
                    c_szRunInputCPLCmdLine,
                    fullpath.GetPath());

    if (RunCPLSetting(szRunInputCPLCmd))
        hr = S_OK;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCtrl
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemCtrl::CLBarItemCtrl(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemCtrl"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM,  
                GUID_LBI_CTRL, 
                TF_LBI_STYLE_BTN_MENU | 
                TF_LBI_STYLE_HIDDENSTATUSCONTROL | 
                TF_LBI_STYLE_SHOWNINTRAY, 
                0,
                CRStr(IDS_NUI_LANGUAGE_TEXT));

    SetToolTip(CRStr(IDS_NUI_LANGUAGE_TOOLTIP));
    _meEto = 0;
    _Init();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemCtrl::~CLBarItemCtrl()
{
    HICON hIcon = GetIcon();
    SetIcon(NULL);
    if (hIcon)
        DestroyIcon(hIcon);
}

//----------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

#define NLS_RESOURCE_LOCALE_KEY   TEXT("Control Panel\\desktop\\ResourceLocale")
void CLBarItemCtrl::_Init()
{
    if (GetSystemMetrics(SM_MIDEASTENABLED))
    {
        char sz[10];
        long cb = sizeof(sz);

        //
        // as we are releasing an enabled version, we need to check the
        // resource locale as well.
        //
        sz[0] = '\0';
        if( RegQueryValue( HKEY_CURRENT_USER, 
                           NLS_RESOURCE_LOCALE_KEY, sz, &cb) == ERROR_SUCCESS)
            if ((cb == 9) && 
                (sz[6] == '0') && 
                ((sz[7] == '1') || (sz[7] == 'd') || (sz[7] == 'D')))
                _meEto = ETO_RTLREADING;
    }

    TF_InitMlngInfo();

    _AsmListUpdated(FALSE);
}


//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCtrl::InitMenu(ITfMenu *pMenu)
{
    CThreadInputMgr *ptim;
    CAssemblyList *pAsmList;
    int i;
    int nCnt;
    INT cxSmIcon;
    INT cySmIcon;
    LOGFONT lf;
    int nMenuFontHeight;

    cxSmIcon = cySmIcon = GetMenuIconHeight(&nMenuFontHeight);

    if( !SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
        return E_FAIL;

    lf.lfHeight = nMenuFontHeight;
    lf.lfWidth  = 0;
    lf.lfWeight = FW_NORMAL;

    if ((pAsmList = EnsureAssemblyList(_psfn)) == NULL)
        return E_FAIL;

    nCnt = pAsmList->Count();
    Assert(nCnt > 0);

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);

    for (i = 0; i < nCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);

        if (pAsm->IsEnabled(_psfn))
        {
            BOOL bChecked = (pAsm->GetLangId() == GetCurrentAssemblyLangId(_psfn));

            HICON hIcon = InatCreateIconBySize(pAsm->GetLangId(), cxSmIcon, cySmIcon, &lf);
            HBITMAP hbmp = NULL;
            HBITMAP hbmpMask = NULL;
            if (hIcon)
            {
                SIZE size = {cxSmIcon, cySmIcon};

                if (!GetIconBitmaps(hIcon, &hbmp, &hbmpMask, &size))
                    return E_FAIL;

                if (hIcon)
                    DestroyIcon(hIcon);
            }

            pMenu->AddMenuItem(IDM_ASM_MENU_START + i, 
                               bChecked ? TF_LBMENUF_CHECKED : 0,
                               hbmp,
                               hbmpMask,
                               pAsm->GetLangName(),
                               wcslen(pAsm->GetLangName()),
                               NULL);

        }

    }

    DWORD dwFlags;
    if (SUCCEEDED(CLangBarMgr::s_GetShowFloatingStatus(&dwFlags)))
    {
        if (dwFlags & (TF_SFT_MINIMIZED | TF_SFT_DESKBAND))
        {
            LangBarInsertSeparator(pMenu);
            LangBarInsertMenu(pMenu, IDM_SHOWLANGBAR, CRStr(IDS_SHOWLANGBAR));
#if 0
            if (dwFlags & TF_SFT_EXTRAICONSONMINIMIZED) 
                LangBarInsertMenu(pMenu, 
                                  IDM_NONOTIFICATIONICONS, 
                                  CRStr(IDS_NOTIFICATIONICONS),
                                  TRUE);
            else
                LangBarInsertMenu(pMenu, 
                                  IDM_NOTIFICATIONICONS, 
                                  CRStr(IDS_NOTIFICATIONICONS),
                                  FALSE);
            LangBarInsertMenu(pMenu, IDM_SHOWINPUTCPL, CRStr(IDS_SHOWINPUTCPL));
#endif
        }
    }


    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCtrl::OnMenuSelect(UINT uID)
{
    CAssemblyList *pAsmList = EnsureAssemblyList(_psfn);
    switch (uID)
    {
        case IDM_SHOWLANGBAR:
            CLangBarMgr::s_ShowFloating(TF_SFT_SHOWNORMAL);
            break;

        case IDM_NOTIFICATIONICONS:
            CLangBarMgr::s_ShowFloating(TF_SFT_EXTRAICONSONMINIMIZED);
            break;

        case IDM_NONOTIFICATIONICONS:
            CLangBarMgr::s_ShowFloating(TF_SFT_NOEXTRAICONSONMINIMIZED);
            break;

        case IDM_SHOWINPUTCPL:
            TF_RunInputCPL();
            break;

        default:
            if (uID >= IDM_ASM_MENU_START)
            {
                Assert((uID - IDM_ASM_MENU_START) < (UINT)pAsmList->Count());
                CAssembly *pAsm = pAsmList->GetAssembly(uID - IDM_ASM_MENU_START);
                if (pAsm && (pAsm->GetLangId() != GetCurrentAssemblyLangId(_psfn)))
                    ActivateAssembly(pAsm->GetLangId(), ACTASM_NONE);
            }
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnShellLanguage
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::OnShellLanguage(HKL hKL)
{
    _UpdateLangIcon(hKL, FALSE);
}

//+---------------------------------------------------------------------------
//
// UpdateLangIcon
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::_UpdateLangIcon(HKL hKL, BOOL fNotify)
{
    CLBarItemDeviceType *plbiDT = NULL;
    BOOL fIsPureIME;
    CThreadInputMgr *ptim;
    int nCnt;
    int i;

    if (!hKL)
        hKL = GetKeyboardLayout(NULL);

    _UpdateLangIconForCic(fNotify);

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);

    if (ptim && ptim->_GetFocusDocInputMgr()) 
    {
        CAssembly *pAsm = GetCurrentAssembly(_psfn);
        if (!pAsm)
            return;
        fIsPureIME = pAsm->IsFEIMEActive();
    }
    else
    {
        fIsPureIME = IsPureIMEHKL(hKL);
    }


    if (fIsPureIME)
    {
        if (_psfn->plbim != NULL)
        {
            _psfn->plbim->_AddWin32IMECtrl(fNotify);
        }
    }
    else
    {
        if (_psfn->plbim != NULL)
        {
            _psfn->plbim->_RemoveWin32IMECtrl();
        }
    }


#ifdef SHOW_BRANDINGICON
    if (_psfn->plbim && _psfn->plbim->_GetLBarItemDeviceTypeArray())
    {
        nCnt = _psfn->plbim->_GetLBarItemDeviceTypeArray()->Count();

        for (i = 0; i < nCnt; i++)
        {
            plbiDT = _psfn->plbim->_GetLBarItemDeviceTypeArray()->Get(i);
            if (!plbiDT)
                continue;

            if (plbiDT->IsKeyboardType())
            {
                plbiDT->SetBrandingIcon(hKL, fNotify);
                break;
            }
        }
    }
#endif SHOW_BRANDINGICON

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON);
}

//+---------------------------------------------------------------------------
//
// AsmListUpdated
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::_AsmListUpdated(BOOL fNotify)
{
    CAssemblyList *pAsmList;
    int i;
    int nCntShowInMenu = 0;
    int nCnt;

    if ((pAsmList = EnsureAssemblyList(_psfn)) == NULL)
        return;

    nCnt = pAsmList->Count();
    Assert(nCnt > 0);

    for (i = 0; i < nCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);

        if (pAsm->IsEnabled(_psfn))
        {
            nCntShowInMenu++;
        }
    }

    ShowInternal((nCntShowInMenu > 1), fNotify);
}

//+---------------------------------------------------------------------------
//
// UpdateLangIconForCic
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::_UpdateLangIconForCic(BOOL fNotify)
{
    HICON hIcon;
    LANGID langid = GetCurrentAssemblyLangId(_psfn);

    if (langid == _langidForIcon)
        return;

    _langidForIcon = langid;

    hIcon = GetIcon();
    SetIcon(NULL);

    if (hIcon)
        DestroyIcon(hIcon);

    hIcon = InatCreateIcon(_langidForIcon);
    SetIcon(hIcon);
    if (hIcon)
    {
        CAssembly *pAsm = GetCurrentAssembly(_psfn);
        if (pAsm != NULL)
        {
            SetToolTip(pAsm->GetLangName());
            SetText(pAsm->GetLangName());
        }
    }

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);
}

//+---------------------------------------------------------------------------
//
// OnSysColorChanged
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::OnSysColorChanged()
{
    HICON hIcon = GetIcon();
    SetIcon(NULL);
    if (hIcon)
        DestroyIcon(hIcon);

    hIcon = InatCreateIcon(_langidForIcon);
    SetIcon(hIcon);

#ifdef WHISTLER_LATER
    if (_plbiSink && GetFocus())
        _plbiSink->OnUpdate(TF_LBI_ICON);
#endif
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemHelp
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemHelp::CLBarItemHelp(SYSTHREAD *psfn) :  CLBarItemSystemButtonBase(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemHelp"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM2,  
                GUID_LBI_HELP, 
                TF_LBI_STYLE_BTN_MENU | 
                // TF_LBI_STYLE_HIDDENSTATUSCONTROL | 
                TF_LBI_STYLE_HIDEONNOOTHERITEMS, 
                HELPBTN_ORDER,
                CRStr(IDS_IMEHELP));

    SetToolTip(CRStr(IDS_NUI_HELP));

    if (!IsInteractiveUserLogon())
        SetStatusInternal(TF_LBI_STATUS_DISABLED);

}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemHelp::InitMenu(ITfMenu *pMenu)
{
    int nCnt = 0;
    CThreadInputMgr *ptim;

    UINT nTipCurMenuID = IDM_CUSTOM_MENU_START;

    ptim = _psfn->ptim;


    if (!_InsertCustomMenus(pMenu, &nTipCurMenuID))
        goto InsertSysHelpItem;

    //
    // Insert separator.
    //
    if (nTipCurMenuID > IDM_CUSTOM_MENU_START)
        LangBarInsertSeparator(pMenu);

    if (ptim && ptim->_GetFocusDocInputMgr())
    {
        int i = 0;
        BOOL fInsert = FALSE;
        nCnt = ptim->_GetTIPCount();
    
        for (i = 0; i < nCnt; i++)
        {
            const CTip *ptip = ptim->_GetCTip(i);
    
            ITfFnShowHelp *phelp;
    
            if (nCnt >= IDM_CUSTOM_MENU_START)
            {
                Assert(0);
                break;
            }
    
            if (!ptip->_pFuncProvider)
                continue;
    
            if (SUCCEEDED(ptip->_pFuncProvider->GetFunction(GUID_NULL, 
                                                            IID_ITfFnShowHelp, 
                                                            (IUnknown **)&phelp)))
            {
    
                BSTR bstr;
                if (SUCCEEDED(phelp->GetDisplayName(&bstr)))
                {
                    LangBarInsertMenu(pMenu, i, bstr, FALSE);
                    fInsert = TRUE;
                    SysFreeString(bstr);
                }
                phelp->Release();
            }
        }
    
        if (fInsert)
            LangBarInsertSeparator(pMenu);
    }

InsertSysHelpItem:
    LangBarInsertMenu(pMenu, nCnt, CRStr(IDS_LANGBARHELP), FALSE);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemHelp::OnMenuSelect(UINT uID)
{
    HRESULT hr = E_FAIL;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    UINT ulCnt = 0;

    if (ptim)
        ulCnt = ptim->_GetTIPCount();

    if (uID >= IDM_CUSTOM_MENU_START)
    {
        int nMenuMapoCnt = _pMenuMap->Count();
        int i;
        for (i = 0; i < nMenuMapoCnt; i++)
        {
            TIPMENUITEMMAP *ptmm;
            ptmm = _pMenuMap->GetPtr(i);
            if (ptmm->nTmpID == (UINT)uID)
            {
                hr = ptmm->plbSink->OnMenuSelect(ptmm->nOrgID);
                break;
            }
        }
    }
    else if (uID > ulCnt)
    {
        hr = E_UNEXPECTED;
    }
    else if (uID == ulCnt)
    {
        //
        //  show Langbar help
        //
        InvokeCicHelp();
        hr = S_OK;
    }
    else
    {
        Assert(ptim);
        const CTip *ptip = ptim->_GetCTip(uID);

        if (ptip->_pFuncProvider)
        {
            ITfFnShowHelp *phelp;
            if (SUCCEEDED(ptip->_pFuncProvider->GetFunction(GUID_NULL, 
                                                            IID_ITfFnShowHelp, 
                                                            (IUnknown **)&phelp)))
            {
                hr = phelp->Show(GetActiveWindow());
                phelp->Release();
            }
        }
    }

    ClearMenuMap();
    return hr;
}

//+---------------------------------------------------------------------------
//
// InvokeCicHelp
//
//----------------------------------------------------------------------------

BOOL CLBarItemHelp::InvokeCicHelp()
{
    return FullPathExec(c_szHHEXE, c_szHHEXELANGBARCHM, SW_SHOWNORMAL, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemHelp::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_HELP));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\normal.h ===
//
// normal.h
//

#ifndef NORMAL_H
#define NORMAL_H

#include "globals.h"

HRESULT PlainTextOffset(ITextStoreACP *ptsi, LONG acpAppBase, LONG lAppOffset, LONG *plPlainOffset);
HRESULT AppTextOffsetForward(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset, DWORD dwFlags);
HRESULT AppTextOffsetBackward(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset, DWORD dwFlags);

#define ATO_IGNORE_REGIONS  1
#define ATO_SKIP_HIDDEN     2

inline HRESULT AppTextOffset(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset, DWORD dwFlags)
{
    *plAppOffset = 0;

    if (lPlainOffset == 0)
        return S_OK;

    return (lPlainOffset >= 0) ? AppTextOffsetForward(ptsi, acpAppBase, lPlainOffset, plAppOffset, dwFlags) :
                                 AppTextOffsetBackward(ptsi, acpAppBase, lPlainOffset, plAppOffset, dwFlags);
}

#define NORM_SKIP_HIDDEN    ATO_SKIP_HIDDEN

inline int Normalize(ITextStoreACP *ptsi, LONG acp, DWORD dwFlags = 0)
{
    LONG iNextPlain;
    HRESULT hr;

    Perf_IncCounter(PERF_NORMALIZE_COUNTER);

    // if we hit eod, AppTextOffset will return S_FALSE
    // and iNextPlain will be the offset to eod
    if (FAILED(hr = AppTextOffset(ptsi, acp, 1, &iNextPlain, dwFlags)))
    {
        Assert(0);
        return acp;
    }

    if (hr == S_OK)
    {
        // need to back up behind the plain text char
        iNextPlain--;
    }

    return (acp + iNextPlain);
}

// Returns a normalized acp offset that spans the specificed number of plain chars --
// so the return offset is just short of (lPlainOffset + 1), or at eod.  Returns
// S_FALSE if the initial call to AppTextOffset gets clipped because of eod.
#ifdef UNUSED
HRESULT AppTextOffsetNorm(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset);
#endif // UNUSED

#endif // NORMAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\nuihkl.cpp ===
//
// nui.cpp
//

#include "private.h"
#include "globals.h"
#include "nuihkl.h"
#include "xstring.h"
#include "tim.h"
#include "dim.h"
#include "immxutil.h"
#include "internat.h"
#include "ctffunc.h"
#include "imemenu.h"
#include "ic.h"
#include "imelist.h"
#include "computil.h"
#include "funcprv.h"
#include "nuictrl.h"
#include "profiles.h"
#include "lbmenu.h"
#include "slbarid.h"
#include "cresstr.h"
#include "fnrecon.h"

DBG_ID_INSTANCE(CLBarItemWin32IME);
DBG_ID_INSTANCE(CLBarItemReconv);
DBG_ID_INSTANCE(CLBarItemDeviceType);

extern "C" DWORD WINAPI TF_CheckThreadInputIdle(DWORD dwThreadId, DWORD dwTimeOut);

#define LBBASE_NUM_CONNECTIONPTS 1

//////////////////////////////////////////////////////////////////////////////
//
// utility functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef WM_IME_SYSTEM
#define WM_IME_SYSTEM 0x287
#endif

// wParam for WM_IME_SYSTEM
#define TFS_DESTROYWINDOW               0x0001
#define TFS_IME31COMPATIBLE             0x0002
#define TFS_SETOPENSTATUS               0x0003
#define TFS_SETACTIVECONTEXT            0x0004
#define TFS_CHANGE_SHOWSTAT             0x0005
#define TFS_WINDOWPOS                   0x0006
#define TFS_SENDIMEMSG                  0x0007
#define TFS_SENDIMEMSGEX                0x0008
#define TFS_SETCANDIDATEPOS             0x0009
#define TFS_SETCOMPOSITIONFONT          0x000A
#define TFS_SETCOMPOSITIONWINDOW        0x000B
#define TFS_CHECKENABLE                 0x000C
#define TFS_CONFIGUREIME                0x000D
#define TFS_CONTROLIMEMSG               0x000E
#define TFS_SETOPENCLOSE                0x000F
#define TFS_ISACTIVATED                 0x0010
#define TFS_UNLOADTHREADLAYOUT          0x0011
#define TFS_LCHGREQUEST                 0x0012
#define TFS_SETSOFTKBDONOFF             0x0013
#define TFS_GETCONVERSIONMODE           0x0014
#define TFS_IMEHELP                     0x0015          // ;Internal


//+---------------------------------------------------------------------------
//
// GetIMEShowStatus
//
//----------------------------------------------------------------------------

static char szInputMethod[]="control panel\\input method" ;
static TCHAR szInputMethodNT[] = TEXT("Control Panel\\Input Method");
static char szValueName[]="show status";
BOOL GetIMEShowStatus()
{
    char  szValueText[16];
    ULONG cb;
    HKEY  hkey;
    BOOL fReturn = IsOnNT() ? TRUE : FALSE;

    if(RegOpenKey(HKEY_CURRENT_USER, IsOnNT() ? szInputMethodNT : szInputMethod,&hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(szValueText);

        if(RegQueryValueEx(hkey, szValueName, NULL, NULL, (BYTE *)szValueText, &cb) != ERROR_SUCCESS)
        {
             szValueText[0] = '\0';
        }
        RegCloseKey(hkey);
        if(lstrcmp(szValueText, IsOnNT() ? "0" : "1") == 0)
           fReturn = !fReturn;
    }

    return fReturn;
}

//+---------------------------------------------------------------------------
//
// SetIMEShowStatus
//
//----------------------------------------------------------------------------

BOOL SetIMEShowStatus(HWND hwnd, BOOL fShow)
{
    char  szValueText[16];
    ULONG cb;
    HKEY  hkey;

    szValueText[0] = fShow ? '1' : '0';
    szValueText[1] = 0;

    if(RegOpenKey(HKEY_CURRENT_USER,szInputMethod,&hkey)==ERROR_SUCCESS)
    {
        cb = lstrlen(szValueText)+1;
        if(RegSetValueEx(hkey, szValueName, 0L, REG_SZ, (BYTE *)szValueText, cb) == ERROR_SUCCESS)
        {
            if (IsOnNT())
            {
                hwnd = ImmGetDefaultIMEWnd(hwnd);
                if (IsWindow(hwnd))
                    goto SendShowMsg;
            }
            else
            {
SendShowMsg:
             SendMessage(hwnd, WM_IME_SYSTEM, TFS_CHANGE_SHOWSTAT, (LPARAM)(DWORD)fShow);
            }
        }
        RegCloseKey(hkey);
        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CallIMEHelp
//
//----------------------------------------------------------------------------

BOOL CallIMEHelp(HWND hwnd, BOOL fCallWinHelp)
{
    if(hwnd)
    {
        return (BOOL)SendMessage(hwnd, WM_IME_SYSTEM, TFS_IMEHELP, 
                           (LPARAM)fCallWinHelp);

    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
// CallConfigureIME
//
//----------------------------------------------------------------------------

void CallConfigureIME(HWND hwnd, HKL dwhkl)
{
    if (IsWindow(hwnd))
    {
        hwnd = ImmGetDefaultIMEWnd(hwnd);

        if(IsWindow(hwnd))
        {
            SendMessage(hwnd, WM_IME_SYSTEM, TFS_CONFIGUREIME, (LPARAM)dwhkl);
        }
    }
}

//---------------------------------------------------------------------------
//
// GetFontSig()
//
//---------------------------------------------------------------------------

BOOL GetFontSig(HWND hwnd, HKL hKL)
{
    LOCALESIGNATURE ls;
    BOOL bFontSig = 0;

    //
    // 4th param is TCHAR count but we call GetLocaleInfoA()
    //                                                   ~
    // so we pass "sizeof(LOCALESIGNATURE) / sizeof(char)".
    //
    if( GetLocaleInfoA( (DWORD)(LOWORD(hKL)), 
                        LOCALE_FONTSIGNATURE, 
                        (LPSTR)&ls, 
                        sizeof(LOCALESIGNATURE) / sizeof(char)))
    {
        CHARSETINFO cs;
        HDC hdc = GetDC(hwnd);
        TranslateCharsetInfo((LPDWORD)UIntToPtr(GetTextCharsetInfo(hdc,NULL,0)), 
                             &cs, TCI_SRCCHARSET);
        DWORD fsShell = cs.fs.fsCsb[0];
        ReleaseDC(hwnd, hdc);
        if (fsShell & ls.lsCsbSupported[0])
            bFontSig = 1;
    }
    return bFontSig;
}

//+---------------------------------------------------------------------------
//
// CanActivateKeyboardLayout
//
//----------------------------------------------------------------------------

BOOL CanActivateKeyboardLayout(HKL hkl)
{
    if (!IsIMEHKL(hkl))
        return TRUE;

    //
    // ActivateKeyboardLayout() does not call ImeSelct() if default ime window
    // is destroyed.
    //
    HWND hDefImeWnd = ImmGetDefaultIMEWnd(NULL);
    if (!hDefImeWnd)
        return FALSE;

    if (!IsWindow(hDefImeWnd))
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// PostInputLangRequest
//
//----------------------------------------------------------------------------

void PostInputLangRequest(SYSTHREAD *psfn, HKL hkl, BOOL fUsePost)
{
    if (!psfn->hklBeingActivated)
    {
        if (hkl == GetKeyboardLayout(0))
            return;
    }
    else if (psfn->hklBeingActivated == hkl)
    {
        return;
    }

    psfn->hklBeingActivated = hkl;

    //
    // Issue:
    //
    // we want to call ActivateKeybaordLayout() at the beginning of Thread
    // start. But is it safe to call it? There is no window created so
    // PostMessage() can not be used.
    // 
    // We need to take care of rejecting WM_INPUTLANGAGEREQUEST.
    //
    if (!fUsePost)
    {
        //
        // make sure we already updated the current assmelby lang id.
        // If not, we will call ActivateAssembly() in ShellHook again
        // and may cause recursion call of ActivateAssembly().
        //
        Assert((LOWORD(hkl) == GetCurrentAssemblyLangId(psfn)));

        if (g_dwAppCompatibility & CIC_COMPAT_DELAYFIRSTACTIVATEKBDLAYOUT)
        {
            static s_fFirstPostInput = FALSE;
            if (!s_fFirstPostInput)
            {
                s_fFirstPostInput = TRUE;
                goto TryPostMessage;
            }
        }

        //
        // #613953
        //
        // ActivateKeyboardLayout() does SendMessage() to the focus window.
        // If the focus window is in another thread, we like to check 
        // the thread is not busy.
        //
        HWND hwndFocus = GetFocus();
        DWORD dwFocusThread = 0;

        if (hwndFocus)
             dwFocusThread = GetWindowThreadProcessId(hwndFocus, NULL);

        if (dwFocusThread && (dwFocusThread != GetCurrentThreadId()))
        {
            if (TF_CheckThreadInputIdle(dwFocusThread, 0x100))
            {
                Assert(0);
                goto TryPostMessage;
            }
        }

        if (CanActivateKeyboardLayout(hkl))
        {
            if (!ActivateKeyboardLayout(hkl, 0))
            {
                psfn->hklDelayActive = hkl;
            }
        }
        else
        {
            //
            // There is no workaround here. The keyboard layout will be
            // restored correctly when this thread gets a visible window back.
            //
            Assert(0);
        }
    }
    else
    {
TryPostMessage:
        HWND hwndForLang = GetFocus();

        if (hwndForLang != NULL)
        {
            BOOL bFontSig = GetFontSig(hwndForLang, hkl);
            PostMessage(hwndForLang, 
                        WM_INPUTLANGCHANGEREQUEST, 
                        (WPARAM)bFontSig, 
                        (LPARAM)hkl);
        }
        else
        {
            psfn->hklDelayActive = hkl;
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetIconIndexFromhKL
//
//----------------------------------------------------------------------------

ULONG GetIconIndexFromhKL(HKL hKL)
{
    MLNGINFO   mlInfo;
    BOOL       bFound;
    int nCnt = TF_MlngInfoCount();
    int i;

    bFound = FALSE;
    for (i = 0; i < nCnt; i++)
    {
        if (!GetMlngInfo(i, &mlInfo))
           continue;

        if (mlInfo.hKL == hKL)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        if (!GetMlngInfo(0, &mlInfo))
            return -1;
    }

    return mlInfo.GetIconIndex();
}

//+---------------------------------------------------------------------------
//
// GetIconIndex
//
//----------------------------------------------------------------------------

ULONG GetIconIndex(LANGID langid, ASSEMBLYITEM *pItem)
{
   ULONG uIconIndex = -1;

   if ((pItem->uIconIndex != -1) || pItem->fInitIconIndex)
       return pItem->uIconIndex;

   if (!IsEqualGUID(pItem->clsid, GUID_NULL))
   {
       int cx, cy;
       ULONG uFileIconIndex;
       WCHAR szFileName[MAX_PATH];

       InatGetIconSize(&cx, &cy);

       //
       // Get Icon filename from registry.
       //
       // At first, we try the given langid's icon.
       // Then we try just primary language.
       // At last we try 0xffff complete neutral language.
       //
TryAgain:
       if (SUCCEEDED(GetProfileIconInfo(pItem->clsid,
                                        langid,
                                        pItem->guidProfile,
                                        szFileName, ARRAYSIZE(szFileName),
                                        &uFileIconIndex)))
       {
           HICON hIcon = GetIconFromFile(cx, cy, szFileName, uFileIconIndex);

           if (hIcon)
           {
               uIconIndex = InatAddIcon(hIcon);
               DestroyIcon(hIcon);
           }
       }
       else if (langid != 0xffff) 
       {
           if (langid & 0xfc00)
           {
              langid = PRIMARYLANGID(langid);
           }
           else
           {
              langid = 0xffff;
           }
           goto TryAgain;
       }

   }
   else
   {
       uIconIndex = GetIconIndexFromhKL(pItem->hkl);
   }

   pItem->fInitIconIndex = TRUE;
   pItem->uIconIndex = uIconIndex;
   return uIconIndex;
}

//+---------------------------------------------------------------------------
//
// FlushIconIndex
//
//----------------------------------------------------------------------------

void FlushIconIndex(SYSTHREAD *psfn)
{
    int i,j;
    CAssemblyList *pAsmList;
    int nAsmCnt;

    //
    // reset icon of Language Button
    //
    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->OnSysColorChanged();

    //
    // clear icon list cache.
    //
    pAsmList = psfn->pAsmList;
    if (!pAsmList)
        return;

    nAsmCnt = pAsmList->Count();
    if (!nAsmCnt)
        return;

    for (i = 0; i < nAsmCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);
        int nItemCnt = pAsm->Count();
        for (j = 0; j < nItemCnt; j++)
        {
            ASSEMBLYITEM *pItem;
            pItem= pAsm->GetItem(j);
            pItem->fInitIconIndex = FALSE;
            pItem->uIconIndex = (ULONG)(-1);
        }
    }

    //
    // check icon list
    // And clean up all icon list if there is the impage icon list.
    //
    if (InatGetImageCount())
    {
        ClearMlngIconIndex();
        InatRemoveAll();
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemWin32IME
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------
static const TCHAR c_szNuiWin32IMEWndClass[] = "NuiWin32IMEDummyWndClass";

CLBarItemWin32IME::CLBarItemWin32IME()
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemWin32IME"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD,  
                GUID_LBI_WIN32IME, 
                TF_LBI_STYLE_BTN_BUTTON | 
                TF_LBI_STYLE_HIDDENSTATUSCONTROL |
                TF_LBI_STYLE_SHOWNINTRAY |
                TF_LBI_STYLE_SHOWNINTRAYONLY, 
                WIN32IME_ORDER,
                CRStr(IDS_NUI_IME_TEXT));

    WNDCLASSEX wc;

    memset(&wc, 0, sizeof(wc));
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_HREDRAW | CS_VREDRAW ;
    wc.hInstance     = g_hInst;
    wc.lpfnWndProc   = _WndProc;
    wc.lpszClassName = c_szNuiWin32IMEWndClass;
    RegisterClassEx(&wc);

    UpdateIMEIcon();

    SetText(CRStr(IDS_NUI_IME_TEXT));
    SetToolTip(CRStr(IDS_NUI_IME_TOOLTIP));
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK CLBarItemWin32IME::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_CREATE:
            SetThis(hWnd, lParam);
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemWin32IME::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    HWND hWnd;
    hWnd = CreateMyWnd();
    ShowIMELeftMenu(hWnd, pt.x, pt.y);
    DestroyWindow(hWnd);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemWin32IME::OnRButtonUp(const POINT pt, const RECT *prcArea)
{
    HWND hWnd;
    hWnd = CreateMyWnd();
    ShowIMERightMenu(hWnd, pt.x, pt.y);
    DestroyWindow(hWnd);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShowIMELeftMenu
//
//----------------------------------------------------------------------------

void CLBarItemWin32IME::ShowIMELeftMenu(HWND hWnd, LONG xPos, LONG yPos)
{
    HKL   hKL;
    HMENU hMenu;
    HIMC  hIMC;
    HWND  hFocusWnd;
    int cmd;
    int nIds;
    int nIdsSoftKbd;
    DWORD fdwConversion;
    DWORD fdwSentence;
    BOOL fShow;
    CWin32ImeMenu *pWin32Menu = NULL;

    hKL = GetKeyboardLayout(0);

    hMenu = CreatePopupMenu();
    if (!hMenu)
        return;

    hFocusWnd = GetFocus();
    hIMC = ImmGetContext(hFocusWnd);

    if (IsOn98orNT5())
    {
        if ((pWin32Menu = new CWin32ImeMenu) == NULL)
            goto Exit;

        pWin32Menu->GetIMEMenu(hFocusWnd, hIMC, FALSE);
        pWin32Menu->BuildIMEMenu(hMenu, FALSE);
    }
    else
    {
        nIds = 0;
        // If Korean TFE, don't show OPEN/CLOSE menu
        if (((DWORD)(UINT_PTR)hKL & 0xF000FFFF) != 0xE0000412)
        {
            BOOL bOpen = ImmGetOpenStatus(hIMC);
            nIds= (bOpen ? IDS_IMECLOSE : IDS_IMEOPEN);
    
            InsertMenu(hMenu, (UINT)-1, MF_BYPOSITION, 
                                        IDM_IME_OPENCLOSE, CRStr(nIds));
        }
    
        // open or close the soft keyboard
        nIdsSoftKbd = 0;
        if (ImmGetProperty(hKL, IGP_CONVERSION) & IME_CMODE_SOFTKBD)
        {
            ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);
    
            nIdsSoftKbd = ((fdwConversion & IME_CMODE_SOFTKBD)?
                                            IDS_SOFTKBDOFF:IDS_SOFTKBDON);
    
            InsertMenu(hMenu, (UINT)-1, MF_BYPOSITION,
                                        IDM_IME_SOFTKBDONOFF, (LPCSTR)CRStr(nIdsSoftKbd));
        }
    
        if (nIds || nIdsSoftKbd) 
        {
            InsertMenu(hMenu, (UINT)-1, MF_SEPARATOR, 0, 0);
        }
    
        InsertMenu(hMenu, (UINT)-1, MF_BYPOSITION,
                                    IDM_IME_SHOWSTATUS, (LPCSTR)CRStr(IDS_IMESHOWSTATUS));
    
    
        if((fShow = GetIMEShowStatus()) == TRUE)
            CheckMenuItem(hMenu, IDM_IME_SHOWSTATUS, MF_CHECKED);
    }

    cmd = TrackPopupMenuEx(hMenu,
            TPM_VERTICAL | TPM_BOTTOMALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                xPos, yPos, hWnd, NULL);

    switch (cmd)
    {
        case IDM_IME_OPENCLOSE:
            if (hIMC)
                ImmSetOpenStatus(hIMC, (nIds == IDS_IMEOPEN));
            break;
    
        case IDM_IME_SOFTKBDONOFF:
            ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);
            if (nIdsSoftKbd == IDS_SOFTKBDOFF)
                fdwConversion &= ~IME_CMODE_SOFTKBD;
            else
                fdwConversion |= IME_CMODE_SOFTKBD;
            ImmSetConversionStatus(hIMC, fdwConversion, fdwSentence);
            break;

        case IDM_IME_SHOWSTATUS:
             SetIMEShowStatus(GetFocus(), !fShow);
             break;
    
        default:
             if (IsOn98orNT5() && 
                 pWin32Menu && 
                 (cmd >= IDM_CUSTOM_MENU_START))
             {
                   UINT uID = pWin32Menu->GetIMEMenuItemID(cmd);
                   DWORD dwData = pWin32Menu->GetIMEMenuItemData(uID);
                   ImmNotifyIME(hIMC, NI_IMEMENUSELECTED, uID, dwData);
             }
             break;
    }

Exit:
    DestroyMenu(hMenu);

    ImmReleaseContext(hFocusWnd, hIMC);

    if (pWin32Menu)
        delete pWin32Menu;
}

//+---------------------------------------------------------------------------
//
// ShowIMERightMenu
//
//----------------------------------------------------------------------------

void CLBarItemWin32IME::ShowIMERightMenu(HWND hWnd, LONG xPos, LONG yPos)
{
    HMENU       hMenu;
    int         cmd;
    HKL         hKL;
    HIMC        hIMC;
    HWND        hFocusWnd;
    CWin32ImeMenu *pWin32Menu = NULL;

    hFocusWnd = GetFocus();

    if (!(hIMC = ImmGetContext(hFocusWnd)))
        return;

    hMenu = CreatePopupMenu();

    if (hMenu == 0)
        goto ExitNoMenu;

    if (IsOn98orNT5())
    {
        if ((pWin32Menu = new CWin32ImeMenu) == NULL)
            goto Exit;

        pWin32Menu->GetIMEMenu(hFocusWnd, hIMC, TRUE);
        pWin32Menu->BuildIMEMenu(hMenu, TRUE);
    }
    else
    {
        InsertMenu(hMenu, (UINT)-1, MF_STRING | MF_BYPOSITION,
                          IDM_RMENU_PROPERTIES, (LPCSTR)CRStr(IDS_CONFIGUREIME));
    }

    cmd = TrackPopupMenuEx(hMenu,
            TPM_VERTICAL | TPM_BOTTOMALIGN | TPM_RETURNCMD,
                xPos, yPos, hWnd, NULL);

    if (cmd && (cmd != -1))
    {
        switch (cmd)
        {
            case IDM_RMENU_PROPERTIES:
                hKL = GetKeyboardLayout(0);

                if ((HIWORD(hKL) & 0xF000) == 0xE000)
                    CallConfigureIME(hFocusWnd, hKL);

                break;

            case IDM_RMENU_IMEHELP:
                CallIMEHelp(hFocusWnd, TRUE);
                break;

            default:
                if (IsOn98orNT5() && 
                    pWin32Menu && 
                    (cmd >= IDM_CUSTOM_MENU_START))
                {
                      UINT uID = pWin32Menu->GetIMEMenuItemID(cmd);
                      DWORD dwData = pWin32Menu->GetIMEMenuItemData(uID);
                      ImmNotifyIME(hIMC, NI_IMEMENUSELECTED, uID, dwData);
                }
                break;
        }
    }

Exit:
    DestroyMenu(hMenu);
ExitNoMenu:
    ImmReleaseContext(hFocusWnd, hIMC);

    if (pWin32Menu)
        delete pWin32Menu;
}

//+---------------------------------------------------------------------------
//
// UpdateIMEIcon
//
//----------------------------------------------------------------------------

void CLBarItemWin32IME::UpdateIMEIcon()
{
    HWND hWnd;
    HIMC hIMC;
    DWORD fdwConversion;
    DWORD fdwSentence;
    BOOL bOpen;
    HKL hKL = GetKeyboardLayout(0);

    if (!IsPureIMEHKL(hKL))
    {
        _nIconId = 0;
        goto Exit;
    }

    hWnd = GetFocus();
    hIMC = ImmGetContext(hWnd);
    bOpen = ImmGetOpenStatus(hIMC);
    ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);

    if (((DWORD)(UINT_PTR)hKL & 0xF000FFFFL) == 0xE0000412L)
    {
        if (!hIMC)
            _nIconId = ID_ICON_IMEDISAB;
        else if (!bOpen)
            _nIconId = ID_ICON_IMEE_H;
        else
        {
            _nIconId = (fdwConversion & IME_CMODE_NATIVE) ? 
                                     ID_ICON_IMEH_H : ID_ICON_IMEE_H;
            if (fdwConversion & IME_CMODE_FULLSHAPE)
                _nIconId++;
        }
    }
    else
    {
        if (!hIMC)
            _nIconId = ID_ICON_IMEDISAB;
        else
            _nIconId = bOpen ? ID_ICON_IMEOPEN : ID_ICON_IMECLOSE;

    }

    ImmReleaseContext(hWnd, hIMC);

Exit:
    SetStatusInternal(_nIconId ? 0 : TF_LBI_STATUS_HIDDEN | TF_LBI_STATUS_DISABLED);
    if (_plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_STATUS);

}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemWin32IME::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(_nIconId));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncReconvQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncReconvQueueItem : public CAsyncQueueItem
{
public:
    CAsyncReconvQueueItem() {}
    HRESULT DoDispatch(CInputContext *pic);
};

HRESULT CAsyncReconvQueueItem::DoDispatch(CInputContext *pic)
{
    CThreadInputMgr *ptim;
    ITfRange *pRangeSel = NULL;
    ITfRange *pRangeReconv = NULL;
    ITfFunctionProvider *psysFuncPrv = NULL;
    ITfFnReconversion *psysReconv = NULL;
    HRESULT hr;
    GETSELECTIONQUEUEITEM qItemGS;
    BOOL fConvertable;
    CStructArray<GENERICSINK> *prgSinks;
    int i;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    //
    // AIMM12 hack!
    //
    // If the target IC is aimm12, we mak a notifycation to AIMM
    //
    prgSinks = pic->_GetStartReconversionNotifySinks();

    for (i = 0; i < prgSinks->Count(); i++)
        ((ITfStartReconversionNotifySink *)prgSinks->GetPtr(i)->pSink)->StartReconversion();


    hr = S_OK;
    qItemGS.ppRange = &pRangeSel;

    if (pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_GETSELECTION, &qItemGS, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
        goto Exit;
    }

    psysFuncPrv = ptim->GetSystemFunctionProvider();
    if (!psysFuncPrv)
        goto Exit;

    if (FAILED(psysFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, 
                                        (IUnknown **)&psysReconv)))
        goto Exit;

    if (psysReconv->QueryRange(pRangeSel, &pRangeReconv, &fConvertable) != S_OK)
        goto Exit;

    if (fConvertable)
        psysReconv->Reconvert(pRangeReconv);

    SafeRelease(pRangeReconv);

Exit:
    for (i = 0; i < prgSinks->Count(); i++)
        ((ITfStartReconversionNotifySink *)prgSinks->GetPtr(i)->pSink)->EndReconversion();

    SafeRelease(pRangeSel);
    SafeRelease(psysFuncPrv);
    SafeRelease(psysReconv);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AsyncReconversion
//
//----------------------------------------------------------------------------

HRESULT AsyncReconversion()
{
    CThreadInputMgr *ptim;
    CDocumentInputManager *pdim;
    CInputContext *pic;
    CAsyncReconvQueueItem *paReconv;
    HRESULT hr = E_FAIL;
    TF_STATUS dcs;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        goto Exit;

    if ((pdim = ptim->_GetFocusDocInputMgr()) == NULL)
        goto Exit;

    if (!(pic = pdim->_GetTopIC()))
        goto Exit;

    if (SUCCEEDED(pic->GetStatus(&dcs)))
    {
        //
        // Korean AIMM1.2 don't support the corrention button.
        //
        if ((dcs.dwStaticFlags & TF_SS_TRANSITORY) &&
            (PRIMARYLANGID(GetCurrentAssemblyLangId(GetSYSTHREAD()))) == LANG_KOREAN)
        {
            goto Exit;
        }
    }

    paReconv = new CAsyncReconvQueueItem();
    if (!paReconv)
        goto Exit;
    
    hr = S_OK;

    if ((pic->_QueueItem(paReconv->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
    {
        Assert(0);
    }

    paReconv->_Release();
Exit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemReconv
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemReconv::CLBarItemReconv(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemReconv"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM,  
                GUID_LBI_RECONV, 
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_HIDDENBYDEFAULT,
                0,
                CRStr(IDS_NUI_CORRECTION_TEXT));

    SetText(CRStr(IDS_NUI_CORRECTION_TEXT));
    SetToolTip(CRStr(IDS_NUI_CORRECTION_TOOLTIP));

    _fAddedBefore = FALSE;
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemReconv::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_RECONVERSION));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// LButtonUpHandler
//
//----------------------------------------------------------------------------

HRESULT CLBarItemReconv::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    return AsyncReconversion();
}

//+---------------------------------------------------------------------------
//
// ShowOrHide
//
//----------------------------------------------------------------------------

void CLBarItemReconv::ShowOrHide(BOOL fNotify)
{
    CThreadInputMgr *ptim = _psfn->ptim;
    CDocumentInputManager *pdim;
    CInputContext *pic;
    BOOL bShow = FALSE;
    DWORD dwOldStatus = _dwStatus;

    //
    // If the real IME is running, we don't show the correction button.
    //
    if (!IsPureIMEHKL(GetKeyboardLayout(0)))
    {
        //
        // If there is no focus dim, we don't show the correction button.
        //
        if (ptim && (pdim = ptim->_GetFocusDocInputMgr()))
        {
            pic = pdim->_GetIC(0);
            if (pic)
            {
                LANGID langid = GetCurrentAssemblyLangId(_psfn);
                TF_STATUS dcs;
                CAssemblyList *pAsmList;
                CAssembly *pAsm;
                BOOL fTransitory = FALSE;
                BOOL fIsTipActive = FALSE;

                if (pAsmList = EnsureAssemblyList(_psfn))
                {
                    if (pAsm = pAsmList->FindAssemblyByLangId(langid))
                    {
                        int i;
                        for (i = 0; i < pAsm->Count(); i++)
                        {
                            ASSEMBLYITEM *pItem = pAsm->GetItem(i);

                            if (!pItem)
                                continue;

                            if (!pItem->fEnabled)
                                continue;

                            if (!pItem->fActive)
                                continue;

                            if (!IsEqualGUID(pItem->clsid, GUID_NULL))
                            {
                                fIsTipActive = TRUE;
                                break;
                            }
                        }
                    }
                }

                //
                // if there is no Tip, we won't show correction button.
                //
                if (!fIsTipActive)
                    goto Exit;

                if (SUCCEEDED(pic->GetStatus(&dcs)))
                {
                    //
                    // Don't show the corrention button on AIMM1.2 non EA.
                    // And Korean AIMM1.2 also don't show the corrention button.
                    //
                    if (dcs.dwStaticFlags & TF_SS_TRANSITORY)
                        fTransitory = TRUE;
                }

                if (!fTransitory || (IsFELangId(langid) && langid != 0x0412))
                {
                    bShow = TRUE;
                    SetOrClearStatus(TF_LBI_STATUS_DISABLED, FALSE);
                }
            }
            else
            {
                //
                // if it is shown, we don't remove it. Just disable it.
                //
                if (!(_dwStatus & TF_LBI_STATUS_HIDDEN))
                {
                    bShow = TRUE;
                    SetOrClearStatus(TF_LBI_STATUS_DISABLED, TRUE);
                }
            }
        }
    }

Exit:

    if (bShow)
    {
        if (_fAddedBefore)
        {
            SetOrClearStatus(TF_LBI_STATUS_DISABLED, FALSE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);
        }
        else
        {
            _psfn->plbim->AddItem(this);
            SetOrClearStatus(TF_LBI_STATUS_HIDDEN, FALSE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);

            _fAddedBefore = TRUE;
        }
    }
    else
    {
        if (_fAddedBefore)
        {
            SetOrClearStatus(TF_LBI_STATUS_DISABLED, TRUE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);
        }
        else
        {
            SetOrClearStatus(TF_LBI_STATUS_HIDDEN, TRUE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);
            _psfn->plbim->RemoveItem(*this->GetGuidItem());
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSystemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }
    else if (IsEqualIID(riid, IID_ITfSystemLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfSystemLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfSystemDeviceTypeLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfSystemDeviceTypeLangBarItem *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::AddRef()
{
    return CLBarItemButtonBase::AddRef();
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::Release()
{
    return CLBarItemButtonBase::Release();
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::CLBarItemSystemButtonBase(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    _dwIconMode = 0;
}

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::~CLBarItemSystemButtonBase()
{
    if (_pMenuMap)
        delete _pMenuMap;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr = CLBarItemButtonBase::AdviseSink(riid, punk, pdwCookie);

    if (hr == S_OK)
       return hr;

    const IID *rgiid = &IID_ITfSystemLangBarItemSink;
    hr = GenericAdviseSink(riid, punk, &rgiid, &_rgEventSinks, 1, pdwCookie);
    if (hr != S_OK)
        return hr;

    // adjust the cookie so we don't overlap with idle detector sinks
    *pdwCookie = GenericChainToCookie(*pdwCookie, LBBASE_NUM_CONNECTIONPTS);

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::UnadviseSink(DWORD dwCookie)
{
    HRESULT hr =  CLBarItemButtonBase::UnadviseSink(dwCookie);
    if (hr == S_OK)
       return hr;

    dwCookie = GenericUnchainToCookie(dwCookie, LBBASE_NUM_CONNECTIONPTS);
    return GenericUnadviseSink(&_rgEventSinks, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemButtonBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::Show(BOOL fShow)
{
    return CLBarItemButtonBase::Show(fShow);
}

//----------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetIcon(HICON hIcon)
{
    CLBarItemButtonBase::SetIcon(hIcon);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetTooltipString(WCHAR *pchToolTip, ULONG cch)
{
    SetToolTip(pchToolTip, cch);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetIconMode()
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetIconMode(DWORD dwFlags)
{
    _dwIconMode = dwFlags;

    if (_dwIconMode & TF_DTLBI_USEPROFILEICON)
        SetBrandingIcon(NULL, TRUE);
    else
        SetDefaultIcon(TRUE);


    return S_OK;
}
//----------------------------------------------------------------------------
//
// GetIconMode()
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::GetIconMode(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_INVALIDARG;

    *pdwFlags = _dwIconMode;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InsertCustomMenus
//
//----------------------------------------------------------------------------

BOOL CLBarItemSystemButtonBase::_InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID)
{
    int nCntEventSink;
    int i;
    BOOL bRet = FALSE;

    //
    // Insert Custom item to menu
    //
    ClearMenuMap();

    nCntEventSink = _rgEventSinks.Count();
    for (i = 0; i < nCntEventSink; i++)
    {
         CCicLibMenu *pMenuTmp;
         GENERICSINK *pSink;
         ITfSystemLangBarItemSink *plbSink;

         if (i >= IDM_CUSTOM_MENU_START - IDM_ASM_MENU_START)
         {
             Assert(0);
             break;
         }
         
         if (!_pMenuMap)
             _pMenuMap = new CStructArray<TIPMENUITEMMAP>;

         if (!_pMenuMap)
         {
             Assert(0);
             goto Exit;
         }


         pMenuTmp = new CCicLibMenu;
         if (!pMenuTmp)
         {
             goto Exit;
         }

         pSink = _rgEventSinks.GetPtr(i);

         if (SUCCEEDED(pSink->pSink->QueryInterface(
                                      IID_ITfSystemLangBarItemSink,
                                      (void **)&plbSink)))
         {
             if (SUCCEEDED(plbSink->InitMenu(pMenuTmp)))
             {
                 if (*pnTipCurMenuID > IDM_CUSTOM_MENU_START)
                     LangBarInsertSeparator(pMenu);

                 *pnTipCurMenuID = _MergeMenu(pMenu, 
                                            pMenuTmp, 
                                            plbSink, 
                                            _pMenuMap, 
                                            *pnTipCurMenuID);
             }
             plbSink->Release();
         }
         else
         {
             Assert(0);
         }

         pMenuTmp->Release();
    }

    bRet = TRUE;
Exit:
    return bRet;
}

//+---------------------------------------------------------------------------
//
// _MergeMenu
//
//----------------------------------------------------------------------------
#define MIIM_ALL  ( MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_STRING | MIIM_BITMAP | MIIM_FTYPE )

UINT CLBarItemSystemButtonBase::_MergeMenu(ITfMenu *pMenu, 
                                     CCicLibMenu *pMenuTip, 
                                     ITfSystemLangBarItemSink *plbSink, 
                                     CStructArray<TIPMENUITEMMAP> *pMenuMap, 
                                     UINT &nCurID)
{
    int i;
    int nMenuCnt = pMenuTip->GetItemCount();
    HRESULT hr;

    if (nMenuCnt <= 0)
        return nCurID;

    for (i = 0; i < nMenuCnt; i++)
    {
        CCicLibMenuItem *pItem = pMenuTip->GetItem(i);
        if (!pItem)
            continue;

        TIPMENUITEMMAP *ptmm;
        ptmm = pMenuMap->Append(1);
        if (!ptmm)
            continue;

        ptmm->plbSink = plbSink;
        ptmm->nOrgID = pItem->GetId();
        ptmm->nTmpID = nCurID++;

        hr = E_FAIL;

        if (pItem->GetSubMenu())
        {
            ITfMenu *pSubMenu = NULL;
            hr = pMenu->AddMenuItem((UINT)-1,
                                    pItem->GetFlags(),
                                    pItem->GetBitmap(),
                                    pItem->GetBitmapMask(),
                                    pItem->GetText(),
                                    wcslen(pItem->GetText()),
                                    &pSubMenu);

            if (SUCCEEDED(hr))
            {
                _MergeMenu(pSubMenu, 
                           pItem->GetSubMenu(), 
                           plbSink, 
                           pMenuMap, 
                           nCurID);

                pSubMenu->Release();
            }
        }
        else
        {
            hr = pMenu->AddMenuItem(ptmm->nTmpID,
                                    pItem->GetFlags(),
                                    pItem->GetBitmap(),
                                    pItem->GetBitmapMask(),
                                    pItem->GetText(),
                                    wcslen(pItem->GetText()),
                                    NULL);
        }

        if (SUCCEEDED(hr))
            pItem->ClearBitmaps();
    }

    return nCurID;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDeviceType
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemDeviceType::CLBarItemDeviceType(SYSTHREAD *psfn, REFGUID rguid) : CLBarItemSystemButtonBase(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemDeviceType"));
    DWORD dwNuiStyle = TF_LBI_STYLE_BTN_MENU | 
                       TF_LBI_STYLE_HIDDENSTATUSCONTROL;



    _guid = rguid;
    _nType = -1;
    _fHideOrder = FALSE;

    if (IsEqualGUID(_guid, GUID_TFCAT_TIP_KEYBOARD))
    {
        _nType = ID_TYPE_KEYBOARD;
        dwNuiStyle |= TF_LBI_STYLE_SHOWNINTRAY;
        _dwIconMode = TF_DTLBI_USEPROFILEICON;
    }
    else if (IsEqualGUID(_guid, GUID_TFCAT_TIP_HANDWRITING))
    {
        _nType = ID_TYPE_HANDWRITING;
    }
    else if (IsEqualGUID(_guid, GUID_TFCAT_TIP_SPEECH))
    {
        _nType = ID_TYPE_SPEECH;
    }

    if (_nType != -1)
    {
        InitNuiInfo(CLSID_SYSTEMLANGBARITEM, 
                    rguid, 
                    dwNuiStyle, 
                    0,
                    CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
    }
    else
    {
        BSTR bstr = NULL;
        MyGetGUIDDescription(rguid, &bstr);
        InitNuiInfo(CLSID_SYSTEMLANGBARITEM, 
                    rguid, 
                    dwNuiStyle, 
                    0,
                    bstr ? bstr : L"");
        if (bstr)
           SysFreeString(bstr);
    }

    _pif = NULL;

}

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemDeviceType::~CLBarItemDeviceType()
{
    if (_pif)
       delete _pif;

    if (_pces)
    {
       _pces->_Unadvise();
       _pces->Release();
    }
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

static const TCHAR c_szNuiDeviceTypeWndClass[] = "NuiDeviceTypeDummyWndClass";
void CLBarItemDeviceType::Init()
{

    if (_nType != -1)
    {
        SetText(CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
        SetToolTip(CRStr(IDS_NUI_DEVICE_TIP_START + _nType));
    }
    else
    {
        SetText(_lbiInfo.szDescription);
        SetToolTip(_lbiInfo.szDescription);
    }


    ShowOrHide(FALSE);
}

//+---------------------------------------------------------------------------
//
// Uninit
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::Uninit()
{
    if (_pces)
    {
       _pces->_Unadvise();
       SafeReleaseClear(_pces);
    }
}

//+---------------------------------------------------------------------------
//
// InitTipArray
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::InitTipArray(BOOL fInitIconIndex)
{
    CAssembly *pAsm;
    int i;
    int nCnt;
    LANGID langid = 0;

    _rgGuidatomHkl.Clear();

    pAsm = GetCurrentAssembly();
    if (!pAsm)
        goto Exit;

    if (_psfn->plbim && _psfn->plbim->_GetLBarItemCtrl())
        langid = GetCurrentAssemblyLangId(_psfn);

    nCnt = pAsm->Count();

    if (_psfn->ptim && _psfn->ptim->_GetFocusDocInputMgr())
        pAsm->RebuildSubstitutedHKLList();
    else
        pAsm->ClearSubstitutedHKLList();

    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (IsEqualGUID(pItem->catid, _guid))
        {
            GUIDATOMHKL gahkl;
            BOOL fInsert = FALSE;

            if (!IsEqualGUID(pItem->clsid, GUID_NULL))
            {
                if (_psfn->ptim && _psfn->ptim->_GetFocusDocInputMgr())
                {
                    TfGuidAtom guidatom;
                    MyRegisterGUID(pItem->clsid, &guidatom);
                    gahkl.guidatom = guidatom;
                    gahkl.hkl = pItem->hkl;
                    gahkl.pItem = pItem;
                    fInsert = TRUE;
                }
            }
            else 
            {
                Assert(pItem->hkl);
                BOOL bSkip = FALSE;

                if (pAsm->IsSubstitutedHKL(pItem->hkl) ||
                    ((!_psfn->ptim || !_psfn->ptim->_GetFocusDocInputMgr()) &&
                      CAssemblyList::IsFEDummyKL(pItem->hkl)))
                {
                    bSkip = TRUE;
                }

                if (!bSkip) 
                {
                    gahkl.guidatom = TF_INVALID_GUIDATOM;
                    gahkl.hkl = pItem->hkl;
                    gahkl.pItem = pItem;
                    fInsert = TRUE;
                }
            }

            if (fInsert)
            {
                GUIDATOMHKL *pgahkl;
                int nCurId;
                int nMaxId = _rgGuidatomHkl.Count();

                for (nCurId = 0; nCurId < nMaxId; nCurId++)
                {
                    GUIDATOMHKL *pgahklCur;
                    int nCmp;
                    pgahklCur = _rgGuidatomHkl.GetPtr(nCurId);

                    if (!pgahklCur)
                        continue;

                    nCmp = CompareGUIDs(pgahklCur->pItem->clsid, 
                                        gahkl.pItem->clsid);
                    if (nCmp > 0)
                        break;

                    if (nCmp < 0)
                        continue;

                    if (CompareGUIDs(pgahklCur->pItem->guidProfile, 
                                     gahkl.pItem->guidProfile) > 0)
                        break;
                }

                if (_rgGuidatomHkl.Insert(nCurId, 1) &&
                    (pgahkl = _rgGuidatomHkl.GetPtr(nCurId)))
                {
                    gahkl.uIconIndex = fInitIconIndex ? GetIconIndex(langid, pItem) : (ULONG)-1;
                    *pgahkl = gahkl;
                }
            }
        }
    }

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
// ShowOrHide
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::ShowOrHide(BOOL fNotify)
{
    BOOL bShow = TRUE;
    int nCnt;

    //
    // if _fHideOrder is TRUE, someone asked not to show this category icon.
    // we do nothing.
    //
    if (_fHideOrder)
    {
        Assert(_dwStatus & TF_LBI_STATUS_HIDDEN);
        return;
    }

    InitTipArray(FALSE);
    nCnt = _rgGuidatomHkl.Count();

    if (_nType != ID_TYPE_KEYBOARD)
    {
        CAssembly *pAsm = GetCurrentAssembly();

        if (pAsm && pAsm->IsFEIMEActive())
        {
            ShowInternal(FALSE, fNotify);
            return;
        }
    }

    if (!nCnt)
    {
        bShow = FALSE;
    }
    else if (nCnt == 1) 
    {
        if (_nType == ID_TYPE_KEYBOARD)
        {
            GUIDATOMHKL *pgahkl;
            pgahkl = _rgGuidatomHkl.GetPtr(0);
            bShow = pgahkl->guidatom ? TRUE : FALSE;
        }
        else
        {
            bShow = FALSE;
        }
    }

    ShowInternal(bShow, fNotify);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::Show(BOOL fShow)
{
    _fHideOrder = fShow ? FALSE : TRUE;
    return CLBarItemSystemButtonBase::Show(fShow);
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

#if IDM_CUSTOM_MENU_START <= IDM_ASM_MENU_START
#erroe IDM_CUSTOM_MENU_START is smaller than IDM_ASM_MENU_START
#endif
#if IDM_ASM_MENU_START <= IDM_LANG_MENU_START
#erroe IDM_ASM_MENU_START is smaller than IDM_LANG_MENU_START
#endif

STDAPI CLBarItemDeviceType::InitMenu(ITfMenu *pMenu)
{
    CThreadInputMgr *ptim = NULL;
    CDocumentInputManager *pdim = NULL;
    CInputContext *pic;
    int nCntGuidatomHkl;
    int i;
    CLSID clsid;
    UINT nTipCurMenuID = IDM_CUSTOM_MENU_START;
    LANGID langid = 0;
    BOOL bMenuChecked = FALSE;
    GUIDATOMHKL *pgahkl;
    BOOL fTransitory = FALSE;

    ptim = _psfn->ptim;

    InitTipArray(TRUE);
    nCntGuidatomHkl = _rgGuidatomHkl.Count();
    if (!ptim)
        goto SetHKLMenu;

    if (!(pdim = ptim->_GetFocusDocInputMgr()))
        goto SetHKLMenu;

    pic = pdim->_GetTopIC();
    if (pic)
    {
        TF_STATUS dcs;
        if (SUCCEEDED(pic->GetStatus(&dcs)) &&
            (dcs.dwStaticFlags & TF_SS_TRANSITORY))
            fTransitory = TRUE;
    }


    if (!_InsertCustomMenus(pMenu, &nTipCurMenuID))
        goto Exit;

    //
    // Insert separator.
    //
    if (nCntGuidatomHkl && (nTipCurMenuID > IDM_CUSTOM_MENU_START))
        LangBarInsertSeparator(pMenu);

    if (_psfn->plbim && _psfn->plbim->_GetLBarItemCtrl())
        langid = GetCurrentAssemblyLangId(_psfn);

    //
    // Insert TIPs to menu
    //
    for (i = 0; i < nCntGuidatomHkl; i++)
    {
        BOOL bCheckThis;

        pgahkl = _rgGuidatomHkl.GetPtr(i);
        

        if (i >= IDM_CUSTOM_MENU_START - IDM_ASM_MENU_START)
        {
            Assert(0);
            break;
        }

        if (!pgahkl->guidatom)
            continue;

        MyGetGUID(pgahkl->guidatom, &clsid);
        if (!CAssemblyList::CheckLangSupport(clsid, langid))
            continue;

        bCheckThis = (pgahkl->pItem->fActive) ? TRUE : FALSE;

        if (fTransitory && pgahkl->pItem->fDisabledOnTransitory)
            LangBarInsertGrayedMenu(pMenu, 
                                    pgahkl->pItem->szProfile,
                                    TF_InatExtractIcon(pgahkl->uIconIndex));
        else
            LangBarInsertMenu(pMenu, 
                              IDM_ASM_MENU_START + i,
                              pgahkl->pItem->szProfile,
                              bCheckThis,
                              TF_InatExtractIcon(pgahkl->uIconIndex));

        if (bCheckThis)
        {
             bMenuChecked = TRUE;
        }
    }

SetHKLMenu:
    //
    // Insert HKLs to menu
    //
    for (i = 0; i < nCntGuidatomHkl; i++)
    {
        BOOL bCheckIt = FALSE;
        pgahkl = _rgGuidatomHkl.GetPtr(i);

        if (i >= IDM_CUSTOM_MENU_START - IDM_ASM_MENU_START)
        {
            Assert(0);
            break;
        }

        if (pgahkl->guidatom)
            continue;

        if (!bMenuChecked  && pgahkl->hkl == GetKeyboardLayout(0))
        {
            if (pdim)
                bCheckIt = (pgahkl->pItem->fActive) ? TRUE : FALSE;
            else
                bCheckIt = TRUE;
        }
        
        LangBarInsertMenu(pMenu, 
                          IDM_LANG_MENU_START + i,
                          pgahkl->pItem->szProfile,
                          bCheckIt,
                          IsPureIMEHKL(pgahkl->hkl) ? TF_InatExtractIcon(pgahkl->uIconIndex) : NULL);
        if (bCheckIt)
        {
            bMenuChecked = TRUE;
        }
    }


    //
    // If the lbiCtrl is hidden (there is only one language available) and
    // the floating toolbar is minimized, the keyboard langbar item
    // has a "Show Langbar" menu item.
    //
    if ((_nType == ID_TYPE_KEYBOARD) && _psfn->plbim)
    {
        CLBarItemCtrl *plbiCtrl = _psfn->plbim->_GetLBarItemCtrl();
        if (plbiCtrl)
        {
            DWORD dwFlags;
            DWORD dwStatus;
            dwStatus = plbiCtrl->GetStatusInternal();
            if ((dwStatus & TF_LBI_STATUS_HIDDEN) &&
                SUCCEEDED(CLangBarMgr::s_GetShowFloatingStatus(&dwFlags)) &&
                (dwFlags & (TF_SFT_MINIMIZED | TF_SFT_DESKBAND)))
            {
                LangBarInsertSeparator(pMenu);
                LangBarInsertMenu(pMenu, 
                                  IDM_SHOWLANGBAR, 
                                  CRStr(IDS_SHOWLANGBAR));
            }
        }
    }

Exit:
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::OnMenuSelect(UINT uID)
{
    CThreadInputMgr *ptim;
    int i;
    GUIDATOMHKL *pgahkl;

    ptim = _psfn->ptim;

    if (uID == IDM_SHOWLANGBAR)
    {
        CLangBarMgr::s_ShowFloating(TF_SFT_SHOWNORMAL);
    }
    else if (uID >= IDM_CUSTOM_MENU_START)
    {
        Assert(ptim);
        int nMenuMapoCnt = _pMenuMap->Count();
        for (i = 0; i < nMenuMapoCnt; i++)
        {
            TIPMENUITEMMAP *ptmm;
            ptmm = _pMenuMap->GetPtr(i);
            if (ptmm->nTmpID == (UINT)uID)
            {
                ptmm->plbSink->OnMenuSelect(ptmm->nOrgID);
                break;
            }
        }
    }
    else if (uID >= IDM_ASM_MENU_START)
    {
        Assert(ptim);
        pgahkl = _rgGuidatomHkl.GetPtr(uID - IDM_ASM_MENU_START);
        Assert(pgahkl);
        Assert(pgahkl->guidatom);

        ASSEMBLYITEM *pItem = pgahkl->pItem;

        if (!pgahkl->pItem->fActive)
        {
             LANGID langid = GetCurrentAssemblyLangId(_psfn);
             ActivateAssemblyItem(_psfn, 
                                  langid,
                                  pItem,  
                                  AAIF_CHANGEDEFAULT);

             CAssemblyList *pAsmList = EnsureAssemblyList(_psfn);
             if (pAsmList)
             {
                 CAssembly *pAsm = pAsmList->FindAssemblyByLangId(langid);
                 if (pAsm)
                 {
                     pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, 
                                                               pItem,
                                                               TRUE);
                 }
             }
        }

// #ifdef HANDWRITINGAUTOSHOW
        if (_nType == ID_TYPE_HANDWRITING)
        {
            MySetCompartmentDWORD(g_gaSystem,
                                  ptim,
                                  GUID_COMPARTMENT_HANDWRITING_OPENCLOSE,
                                  TRUE);

        }
// #endif

    }
    else if (uID >= IDM_LANG_MENU_START)
    {
        pgahkl = _rgGuidatomHkl.GetPtr(uID - IDM_LANG_MENU_START);
        Assert(pgahkl);
        Assert(pgahkl->hkl);
        ActivateAssemblyItem(_psfn, 
                             GetCurrentAssemblyLangId(_psfn), 
                             pgahkl->pItem,
                             AAIF_CHANGEDEFAULT);
    }

    ClearMenuMap();
    return S_OK;
}
 

//----------------------------------------------------------------------------
//
// CompEventSinkCallback (static)
//
//----------------------------------------------------------------------------

HRESULT CLBarItemDeviceType::CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CLBarItemDeviceType *_this = (CLBarItemDeviceType *)pv;

    if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
    {
        _this->SetSpeechButtonState(_this->_psfn->ptim);
    }
    return S_FALSE;
}

//----------------------------------------------------------------------------
//
// SetSpeechButtonState
//
//----------------------------------------------------------------------------

HRESULT CLBarItemDeviceType::SetSpeechButtonState(CThreadInputMgr *ptim)
{
    DWORD dw = 0;
    MyGetCompartmentDWORD(ptim->GetGlobalComp(), GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw);

    SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, dw);
    if (_plbiSink)
        _plbiSink->OnUpdate(TF_LBI_STATUS);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::SetIcon(HICON hIcon)
{
    CLBarItemButtonBase::SetIcon(hIcon);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::GetIcon(HICON *phIcon)
{
    if (CLBarItemButtonBase::GetIcon())
    {
        return CLBarItemButtonBase::GetIcon(phIcon); 
    }

    HICON hIcon = NULL;

    if (_nType != -1)
    {
        hIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_DEVICE_START + _nType));
    }
    else
    {
       int cx, cy;
       InatGetIconSize(&cx, &cy);

       if (!_pif)
       {
           BSTR bstr;
           HRESULT hr;
           ICONFILE *pif;

           pif = new ICONFILE;
           if (!pif)
               goto Exit;

           if (FAILED(hr = MyGetGUIDValue(_guid, c_szIconIndexW, &bstr)))
           {
               delete pif;
               goto Exit;
           }

           pif->uIconIndex = WToNum(bstr);
           SysFreeString(bstr);

           if (FAILED(hr = MyGetGUIDValue(_guid, c_szIconFileW, &bstr)))
           {
               delete pif;
               goto Exit;
           }

           wcsncpy(pif->szFile, bstr, ARRAYSIZE(pif->szFile));

           SysFreeString(bstr);

           _pif = pif;
       }

       hIcon = GetIconFromFile(cx, cy, _pif->szFile, _pif->uIconIndex);
    }

Exit:
    *phIcon = hIcon;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::SetTooltipString(WCHAR *pchToolTip, ULONG cch)
{
    if (!pchToolTip)
    {
        SetToolTip(CRStr(IDS_NUI_DEVICE_TIP_START + _nType));
    }
    else
        SetToolTip(pchToolTip, cch);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UpdateLangIcon
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::SetBrandingIcon(HKL hKL, BOOL fNotify)
{
    CThreadInputMgr *ptim;
    HICON hIcon;
    ULONG uIconIndex = -1;
    ASSEMBLYITEM *pItem = NULL;
    CAssembly *pAsm;
    WCHAR szDesc[128];

    if (!hKL)
        hKL = GetKeyboardLayout(0);

    if (!(_dwIconMode & TF_DTLBI_USEPROFILEICON))
        return;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);

    pAsm = GetCurrentAssembly(_psfn);
    if (!pAsm)
        return;

#ifdef USE_ASM_ISFEIMEACTIVE
    BOOL fIsPureIME = FALSE;

    if (_nType == ID_TYPE_KEYBOARD)
    {
        if (ptim && ptim->_GetFocusDocInputMgr()) 
        {
            fIsPureIME = pAsm->IsFEIMEActive();
        }
        else
        {
            fIsPureIME = IsPureIMEHKL(hKL);
        }
    }
#endif USE_ASM_ISFEIMEACTIVE

    hIcon = NULL;

    szDesc[0] = L'\0';

#ifdef USE_ASM_ISFEIMEACTIVE
    if (fIsPureIMEHKL)
#else
    if (IsPureIMEHKL(hKL))
#endif USE_ASM_ISFEIMEACTIVE
    {
        pItem = pAsm->FindKeyboardLayoutItem(hKL);

        uIconIndex = GetIconIndexFromhKL(hKL);
        if (uIconIndex != -1)
            hIcon = TF_InatExtractIcon(uIconIndex);
    }
    else if (ptim && ptim->_GetFocusDocInputMgr())
    {
        pItem = pAsm->FindActiveKeyboardItem();

        //
        // if it is Cicero item, we will show the branding Icon.
        //
        if (pItem && !IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            uIconIndex = GetIconIndex(LOWORD(HandleToLong(hKL)), pItem);
            if (uIconIndex != -1)
                hIcon = TF_InatExtractIcon(uIconIndex);
        }
    }
    else
    {
        MLNGINFO mlInfo;
        if (GetMlngInfoByhKL(hKL, &mlInfo) != -1)
        { 
            wcsncpy(szDesc, mlInfo.GetDesc(), ARRAYSIZE(szDesc));
        }
    }


    HICON hIconOld = GetIcon();
    SetIcon(hIcon);
    if (hIconOld)
        DestroyIcon(hIconOld);

    if (pItem)
    {
        SetText(pItem->szProfile);
        SetToolTip(pItem->szProfile);
    }
    else if (szDesc[0])
    {
        SetText(szDesc);
        SetToolTip(szDesc);
    }
    else if (_nType != -1)
    {
        SetText(CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
        SetToolTip(CRStr(IDS_NUI_DEVICE_TIP_START + _nType));
    }

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);
}

//+---------------------------------------------------------------------------
//
// SetDefaultIcon
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::SetDefaultIcon(BOOL fNotify)
{
    HICON hIconOld = GetIcon();
    SetIcon(NULL);
    if (hIconOld)
        DestroyIcon(hIconOld);

    if (_nType != -1)
    {
        SetToolTip(CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
        SetText(_szToolTip);
    }

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\nuihkl.h ===
//
// nuihkl.h
//

#ifndef NUIHKL_H
#define NUIHKL_H

#include "private.h"
#include "strary.h"
#include "commctrl.h"
#include "internat.h"
#include "nuibase.h"
#include "sink.h"
#include "assembly.h"
#include "lbmenu.h"
#include "systhrd.h"

ULONG GetIconIndexFromhKL(HKL hKL);
ULONG GetIconIndex(LANGID langid, ASSEMBLYITEM *pItem);
HRESULT AsyncReconversion();

extern const TCHAR c_szNuiWin32IMEWndClass[];
class CCompartmentEventSink;


typedef struct tag_TIPMENUITEMMAP {
    ITfSystemLangBarItemSink *plbSink;
    UINT nOrgID;
    UINT nTmpID;
} TIPMENUITEMMAP;

typedef struct tag_GUIDATOMHKL {
    TfGuidAtom guidatom;
    HKL        hkl;
    ULONG      uIconIndex;
    ASSEMBLYITEM *pItem;
} GUIDATOMHKL;

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemWin32IME
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemWin32IME : public CLBarItemButtonBase
{
public:
    CLBarItemWin32IME();
    ~CLBarItemWin32IME() {}

    STDMETHODIMP GetIcon(HICON *phIcon);

    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    void UpdateIMEIcon();

private:
    void ShowIMELeftMenu(HWND hWnd, LONG xPos, LONG yPos);
    void ShowIMERightMenu(HWND hWnd, LONG xPos, LONG yPos);

    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND CreateMyWnd()
    {
         return CreateWindow(c_szNuiWin32IMEWndClass,
                                     "",
                                     WS_POPUP | WS_DISABLED,
                                     0,0,0,0,
                                     NULL, 0, g_hInst, this);
    }

    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, GWLP_USERDATA,
                      (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
    }

    static CLBarItemWin32IME *GetThis(HWND hWnd)
    {
        CLBarItemWin32IME *p = (CLBarItemWin32IME *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
        Assert(p != NULL);
        return p;
    }

    int _nIconId;
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemReconv
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemReconv : public CLBarItemButtonBase,
                        public CSysThreadRef
{
public:
    CLBarItemReconv(SYSTHREAD *psfn);

    STDMETHODIMP GetIcon(HICON *phIcon);
    void ShowOrHide(BOOL fNotify);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);

    BOOL _fAddedBefore;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDeviceType
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemSystemButtonBase : public CLBarItemButtonBase,
                                  public ITfSystemLangBarItem,
                                  public ITfSystemDeviceTypeLangBarItem,
                                  public CSysThreadRef
{
public:
    CLBarItemSystemButtonBase(SYSTHREAD *psfn);
    ~CLBarItemSystemButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP Show(BOOL fShow);

    //
    // ITfSystemLangBarItem
    //
    STDMETHODIMP SetIcon(HICON hIcon);
    STDMETHODIMP SetTooltipString(WCHAR *pchToolTip, ULONG cch);

    //
    // ITfSystemDeviceTypeLangBarItem,
    //
    STDMETHODIMP SetIconMode(DWORD dwFlags);
    STDMETHODIMP GetIconMode(DWORD *pdwFlags);

protected:
    BOOL _InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID);
    UINT _MergeMenu(ITfMenu *pMenu, CCicLibMenu *pMenuTip, ITfSystemLangBarItemSink *plbSink, CStructArray<TIPMENUITEMMAP> *pMenuMap, UINT &nCurID);

    CStructArray<TIPMENUITEMMAP> *_pMenuMap;
    void ClearMenuMap()
    {
        if (_pMenuMap)
            _pMenuMap->Clear();
    }

    virtual void SetBrandingIcon(HKL hKL, BOOL fNotify) {return;}
    virtual void SetDefaultIcon(BOOL fNotify) {return;}

    CStructArray<GENERICSINK> _rgEventSinks; // ITfSystemLangBarItemSink

    DWORD _dwIconMode;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDeviceType
//
//////////////////////////////////////////////////////////////////////////////

#define ID_TYPE_KEYBOARD    0
#define ID_TYPE_HANDWRITING 1
#define ID_TYPE_SPEECH      2

class CLBarItemDeviceType : public CLBarItemSystemButtonBase
{
public:
    CLBarItemDeviceType(SYSTHREAD *psfn, REFGUID rguid);
    ~CLBarItemDeviceType();

    //
    // IUnknown methods
    //
    // STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    // STDMETHODIMP_(ULONG) AddRef(void);
    // STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    // STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    // STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    // STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetIcon(HICON *phIcon);

    //
    // ITfSystemLangBarItem
    //
    STDMETHODIMP SetIcon(HICON hIcon);
    STDMETHODIMP SetTooltipString(WCHAR *pchToolTip, ULONG cch);

    void Init();
    void Uninit();
    void ShowOrHide(BOOL fNotify);
    void InitTipArray(BOOL fInitIconIndex);

    BOOL IsKeyboardType() {return (_nType == ID_TYPE_KEYBOARD) ? TRUE : FALSE;}

    HICON GetIcon()
    {
        return CLBarItemSystemButtonBase::GetIcon();
    }

    void SetBrandingIcon(HKL hKL, BOOL fNotify);
    void SetDefaultIcon(BOOL fNotify);

    GUID *GetDeviceTypeGUID() {return &_guid;}

private:
    BOOL _StringFromMenuId(int nMenuId, BSTR *pbstr);

    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

    GUID _guid;
    int _nType;

    CStructArray<GUIDATOMHKL> _rgGuidatomHkl;

    CCompartmentEventSink *_pces;

    static HRESULT CompEventSinkCallback(void *pv, REFGUID rguid);
    HRESULT SetSpeechButtonState(CThreadInputMgr *ptim);

    typedef struct tag_ICONFILE {
        int uIconIndex;
        WCHAR szFile[MAX_PATH];
    } ICONFILE;
    ICONFILE *_pif;

    //
    // When someone else calls Show(FALSE), we hide the button forcefully.
    // If this is TRUE, we never clear TF_LBI_STATUS_HIDDEN flag.
    //
    BOOL _fHideOrder;


    DBG_ID_DECLARE;
};

#endif // NUIHKL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\nuictrl.h ===
//
// nuihkl.h
//

#ifndef NUICTRLL_H
#define NUICTRLL_H

#include "private.h"
#include "strary.h"
#include "commctrl.h"
#include "internat.h"
#include "nuihkl.h"
#include "assembly.h"
#include "systhrd.h"

extern HRESULT WINAPI TF_RunInputCPL();

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCtrl
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemCtrl : public CLBarItemButtonBase,
                      public CSysThreadRef
{
public:
    CLBarItemCtrl(SYSTHREAD *psfn);
    ~CLBarItemCtrl();

    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    void OnShellLanguage(HKL hKL);

    void _UpdateLangIcon(HKL hKL, BOOL fNotify);
    void _UpdateLangIconForCic(BOOL fNotify);
    void _AsmListUpdated(BOOL fNotify);
    void OnSysColorChanged();

private:
    void _Init();

    void _ShowLanguageMenu(HWND hwnd, LONG xPos, LONG yPos, RECT *prcArea);
    BOOL _HandleLangMenuMeasure(HWND hwnd, LPMEASUREITEMSTRUCT lpmi);
    BOOL _HandleLangMenuDraw(HWND hwnd, LPDRAWITEMSTRUCT lpdi);
    void _ShowAssemblyMenu(HWND hwnd, const LONG xPos, const LONG yPos, const RECT *prcArea);

    int _meEto;
    LANGID _langidForIcon;
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemHelp
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemHelp : public CLBarItemSystemButtonBase
{
public:
    CLBarItemHelp(SYSTHREAD *psfn);
    ~CLBarItemHelp() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

private:
    BOOL InvokeCicHelp();

    DBG_ID_DECLARE;
};

#endif // NUICTRLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\nuimgr.cpp ===
//
// nuimgr.cpp
//

#include "private.h"
#include "tim.h"
#include "nuimgr.h"
#include "nuictrl.h"
#include "marshal.h"
#include "timlist.h"
#include "lbaddin.h"
#include "hotkey.h"

DBG_ID_INSTANCE(CLBarItemSink);
DBG_ID_INSTANCE(CLBarItemSinkProxy);
DBG_ID_INSTANCE(CLangBarItemMgr);
DBG_ID_INSTANCE(CEnumLBItem);

//////////////////////////////////////////////////////////////////////////////
//
// marshalling misc func
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// FreeStubForThis
//
// this function clean up all marshaling stubs for the LangBarItem.
//
//+---------------------------------------------------------------------------

void FreeMarshaledStubOfItem(SYSTHREAD *psfn, REFGUID rguid)
{
    ITfLangBarItem *pItem;
    if (!psfn->prgStub)
        return;

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        return;

    int nCnt = psfn->prgStub->Count();
    int i = 0;

    for (i = 0; i < nCnt; i++)
    {
TryThisIdAgain:
        CStub *pStub = psfn->prgStub->Get(i);
        HRESULT hr;
        TF_LANGBARITEMINFO info;


        //
        //  Win98-J and Satori cause exception at the sutdown of notepad.
        //  we need to make sure this exception handler is not hiding any
        //  potential problems.
        //
        _try {
            if (FAILED(pStub->_punk->QueryInterface(IID_ITfLangBarItem, (void **)&pItem)))
               continue;
        } 
        _except (1) {
            continue;
        }
       
        hr = pItem->GetInfo(&info);
        pItem->Release();

        if (SUCCEEDED(hr) && IsEqualGUID(info.guidItem, rguid))
        {
            pStub->_fNoRemoveInDtor = TRUE;
            psfn->prgStub->Remove(i, 1);
            delete pStub;
            nCnt--;
            if (i < nCnt)
               goto TryThisIdAgain;

            return;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarItemMgr::CLangBarItemMgr(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLangBarItemMgr"));

    Assert(_GetThis() == NULL);
    _SetThis(this);

    _dwCurCookie = 0;
    _ulInAssemblyChange = 0;
    _fHandleOnUpdate = TRUE;

    EnsureMarshalWnd();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarItemMgr::~CLangBarItemMgr()
{
    g_timlist.ClearFlags(_psfn->dwThreadId, TLF_LBIMGR);
    _RemoveSystemItems(_psfn);
    CleanUp();
    _SetThis(NULL);
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_ITfLangBarItemMgr) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemMgr *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLangBarItemMgr::AddRef()
{
    //
    // we don't have ref count.
    // Keep this class in psfn and delete at the end of thread.
    //
    return 2;
}

STDAPI_(ULONG) CLangBarItemMgr::Release()
{
    //
    // we don't have ref count.
    // Keep this class in psfn and delete at the end of thread.
    //
    return 1;
}

//+---------------------------------------------------------------------------
//
// _RemoveSystemItems
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::_RemoveSystemItems(SYSTHREAD *psfn)
{
    int i;
    CLBarItemDeviceType *plbiDT;
    DWORD dwThreadId = GetCurrentThreadId();

    if (_plbiCtrl != NULL)
    {
        RemoveItem(*_plbiCtrl->GetGuidItem());

        if (_plbiCtrl->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiCtrl;
            }
        }

        _plbiCtrl = NULL;
    }

    if (_plbiReconv != NULL)
    {
        RemoveItem(*_plbiReconv->GetGuidItem());

        if (_plbiReconv->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiReconv;
            }
        }

        _plbiReconv = NULL;
    }

    if (_plbiWin32IME != NULL)
    {
        RemoveItem(*_plbiWin32IME->GetGuidItem());

        if (_plbiWin32IME->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiWin32IME;
            }
        }

        _plbiWin32IME = NULL;
    }

    if (_plbiHelp != NULL)
    {
        RemoveItem(*_plbiHelp->GetGuidItem());

        if (_plbiHelp->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiHelp;
            }
        }

        _plbiHelp = NULL;
    }

    for (i = 0; i < _rglbiDeviceType.Count(); i++)
    {
        plbiDT = _rglbiDeviceType.Get(i);
        if (plbiDT)
        {
            RemoveItem(*plbiDT->GetGuidItem());

            if (plbiDT->Release() > 0)
            {
                if (psfn && (psfn->dwThreadId == dwThreadId))
                {
                    // Clean up a pointer that is marshalled to UTB.
                    delete plbiDT;
                }
            }
        }
    }
    _rglbiDeviceType.Clear();
}

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
HRESULT CLangBarItemMgr::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CLangBarItemMgr *plbim;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    if (plbim = _GetThis())
    {
        return plbim->QueryInterface(riid, ppvObj);
    }

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_OUTOFMEMORY;

    if ((plbim = new CLangBarItemMgr(psfn)) == NULL)
        return E_OUTOFMEMORY;

    if (!plbim->_Init())
    {
        plbim->Release();
        return E_FAIL;
    }

    hr = plbim->QueryInterface(riid, ppvObj);

    plbim->Release();

#ifdef WINLOGON_LANGBAR
    ExecuteLoader();
#endif

    return hr;
}

//+---------------------------------------------------------------------------
//
// FindDeviceTypeItem
//
//----------------------------------------------------------------------------

CLBarItemDeviceType *CLangBarItemMgr::FindDeviceTypeItem(REFGUID guid)
{
    int i;
    CLBarItemDeviceType *plbiDT;
    for (i = 0; i < _rglbiDeviceType.Count(); i++)
    {
        plbiDT = _rglbiDeviceType.Get(i);
        if (plbiDT)
        {
            if (IsEqualGUID(*plbiDT->GetDeviceTypeGUID(), guid))
            {
                return plbiDT;
            }
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CLangBarItemMgr::_Init()
{
    CLBarItemDeviceType **pplbiDT;
    GUID guid;

    //
    // set TLF_LBIMGR flag for this thread of timlist.
    //
    if (EnsureTIMList(_psfn))
    {
        g_timlist.SetFlags(_psfn->dwThreadId, TLF_LBIMGR);

        InitLangChangeHotKey();
    }

    // init the system default ctls
    if (!_plbiCtrl && (_plbiCtrl = new CLBarItemCtrl(_psfn)) == NULL)
        return FALSE;

    AddItem(_plbiCtrl);

    // 
    // I want to hide a help button on Winlogon.
    // But IMJP8 causes av, if we don't have Help button...
    // 
    // if (!IsInWinLogOnDesktop())
    {
        if (!_plbiHelp && (_plbiHelp = new CLBarItemHelp(_psfn)) != NULL)
        {
            AddItem(_plbiHelp);
        }
    }

    if (CThreadInputMgr::_GetThis())
    {
        if (!_plbiReconv && (_plbiReconv = new CLBarItemReconv(_psfn)))
        {
            AddItem(_plbiReconv);
            _plbiReconv->ShowOrHide(FALSE);
        }

        IEnumGUID *pEnum;
        if (SUCCEEDED(CCategoryMgr::s_EnumItemsInCategory(
                                               GUID_TFCAT_CATEGORY_OF_TIP,
                                               &pEnum)))
        {
            while (pEnum->Next(1, &guid, NULL) == S_OK)
            {
                if (FindDeviceTypeItem(guid))
                    continue;

                pplbiDT = _rglbiDeviceType.Append(1);
    
                if (pplbiDT)
                {
                    *pplbiDT = new CLBarItemDeviceType(_psfn, guid);
                    if (*pplbiDT)
                    {
                        (*pplbiDT)->Init();
                        AddItem(*pplbiDT);
                    }
                    else
                    {
                        int nCnt = _rglbiDeviceType.Count();
                        if (nCnt)
                           _rglbiDeviceType.Remove(nCnt - 1, 1);
                    }
                }
                
            }
            pEnum->Release();
        }
    }
    else
    {
        if (!FindDeviceTypeItem(GUID_TFCAT_TIP_KEYBOARD))
        {
            pplbiDT = _rglbiDeviceType.Append(1);
            if (pplbiDT)
            {
                *pplbiDT = new CLBarItemDeviceType(_psfn, GUID_TFCAT_TIP_KEYBOARD);
                if (*pplbiDT)
                {
                    (*pplbiDT)->Init();
                    AddItem(*pplbiDT);
                }
                else
                {
                    int nCnt = _rglbiDeviceType.Count();
                    if (nCnt)
                       _rglbiDeviceType.Remove(nCnt - 1, 1);
                }
            }
        }
    }

    if (_plbiCtrl)
    {
        _plbiCtrl->_UpdateLangIcon(NULL, FALSE);
    }

    UpdateLangBarAddIns();

    MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CleanUp
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::CleanUp()
{

    // 
    //  we can not call COM in PROCESS_DETACH. we just make sure 
    //  if someone forget to call UnRegister.
    // 
#if 1
    // Assert(!_rglbiProxy.Count());
#else
    int i;
    int nCnt;

    nCnt = _rglbiProxy.Count();
    for (i = 0; i < nCnt; i++)
    {
         CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);
         pProxy->Clear();
         pProxy->Release();
    }

#endif

    _rglbiProxy.Clear();

    int i;
    int nCnt = _rgSink.Count();
    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink  *pSink = _rgSink.Get(i);
        Assert(pSink);

        TraceMsg(TF_GENERAL, "NuiMgr clean up ItemSink - 0x%x08", (UINT_PTR)pSink);

        //
        // Issue: This is a pointer that is marshalled from UTB.
        //         If this is called in DllMain(THREAD_DETACH).
        //         calling Release() cause dead lock....
        //
        pSink->_pItemSink->Release();
        pSink->_pItemSink = NULL;
        delete pSink;
    }
    _rgSink.Clear();
}

//+---------------------------------------------------------------------------
//
// AddItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::AddItem(ITfLangBarItem *pItem)
{
    ITfSource *pSource = NULL;
    HRESULT hr = E_FAIL;
    CLBarItemSinkProxy *pProxy;
    TF_LANGBARITEMINFO info;

    if (pItem == NULL)
        return E_INVALIDARG;

    if (FAILED(pItem->QueryInterface(IID_ITfSource, (void **)&pSource)))
    {
        goto Exit;
    }

    if (SUCCEEDED(pItem->GetInfo(&info)))
    {
       int i;
       int nCnt = _rglbiProxy.Count();
       for (i = 0; i < nCnt; i++)
       {
            pProxy = _rglbiProxy.Get(i);
   
            if (IsEqualGUID(pProxy->_info.guidItem, info.guidItem))
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
       }
    }
    else
    {
        goto Exit;
    }

    pProxy = new CLBarItemSinkProxy();
    if (!pProxy)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pProxy->Init(this, pItem, &info))
    {
        goto Exit;
    }

    if (FAILED(pSource->AdviseSink(IID_ITfLangBarItemSink, 
                                   pProxy, &pProxy->_dwCookie)))
    {
        pProxy->Clear();
        pProxy->Release();
    }
    else
    {
        int nCnt = _rglbiProxy.Count();
        if (!_rglbiProxy.Insert(nCnt, 1))
        {
            pSource->UnadviseSink(pProxy->_dwCookie);
            pProxy->Clear();
            pProxy->Release();

            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        _rglbiProxy.Set(nCnt, pProxy);

        if (!_ulInAssemblyChange)
             MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
        _fItemChanged = TRUE;

        hr = S_OK;
    }

Exit:
    SafeRelease(pSource);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RemoveItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::RemoveItem(ITfLangBarItem *pItem)
{
    TF_LANGBARITEMINFO info;

    if (!pItem)
        return E_INVALIDARG;

    if (FAILED(pItem->GetInfo(&info)))
        return E_FAIL;

    return RemoveItem(info.guidItem);
}

//+---------------------------------------------------------------------------
//
// RemoveItem
//
//----------------------------------------------------------------------------

HRESULT CLangBarItemMgr::RemoveItem(REFGUID rguid)
{
    int nCnt;
    int i;

    nCnt = _rglbiProxy.Count();
    for (i = 0; i < nCnt; i++)
    {
         CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);

         if (IsEqualGUID(pProxy->_info.guidItem, rguid))
         {
             ITfSource *pSource;
             if (SUCCEEDED(pProxy->_plbi->QueryInterface(IID_ITfSource, 
                                                         (void **)&pSource)))
             {
                 pSource->UnadviseSink(pProxy->_dwCookie);
                 pSource->Release();
             }
             _rglbiProxy.Remove(i, 1);
             pProxy->Clear();
             pProxy->Release();

             if (!_ulInAssemblyChange)
             {
                 MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
             }
             SYSTHREAD *psfn = FindSYSTHREAD();
             if (psfn && (psfn->dwThreadId == _psfn->dwThreadId))
                 FreeMarshaledStubOfItem(psfn, rguid);

             _fItemChanged = TRUE;
             break;
         }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RegisterItemSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguidItem)
{
    CLBarItemSinkProxy *pProxy;
    CLBarItemSink *pSink;
    int nCnt;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_POINTER;

    *pdwCookie = 0;

    if (punk == NULL)
        return E_POINTER;

    pProxy = GetItemSinkProxy(rguidItem);
    if (!pProxy)
        return E_INVALIDARG;

    pSink = new CLBarItemSink();
    if (!pSink)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *pdwCookie = _GetCookie();
    if (!pSink->Init(punk, &pProxy->_info, *pdwCookie))
    {
        hr = E_FAIL;
        goto Exit;
    }

    nCnt = _rgSink.Count();
    if (!_rgSink.Insert(nCnt, 1))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    _rgSink.Set(nCnt, pSink);

    hr = S_OK;
Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterItemSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::UnadviseItemSink(DWORD dwCookie)
{
    int i;
    int nCnt = _rgSink.Count();

    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink  *pSink = _rgSink.Get(i);
        if (pSink->_dwCookie == dwCookie)
        {
#ifdef DEBUG
            pSink->_fUnadvised = TRUE;
#endif
            _rgSink.Remove(i, 1);


            delete pSink;
            break;
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItemFloatingRect
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    if (!prc)
       return E_INVALIDARG;

    if (!dwThreadId)
       dwThreadId = GetCurrentThreadId();

    memset(prc, 0, sizeof(*prc));

    return ThreadGetItemFloatingRect(dwThreadId, rguid, prc);
}

//+---------------------------------------------------------------------------
//
// GetItemsStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
{
    ULONG ul;

    for (ul = 0; ul < ulCount; ul++)
    {
        int i;
        BOOL fFound = FALSE;
        for (i = 0; i < _rglbiProxy.Count(); i++)
        {
            CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);
            if (IsEqualGUID(pProxy->_info.guidItem, *prgguid))
            {
                if (FAILED(pProxy->_plbi->GetStatus(pdwStatus)))
                    return E_FAIL;

                pdwStatus++;
                prgguid++;
                fFound = TRUE;
                break;
            }
        }

        if (!fFound)
            return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItemNum
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItemNum(ULONG *pulCount)
{
    if (!pulCount)
        return E_INVALIDARG;

    *pulCount = _rglbiProxy.Count();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItems
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
{
    int i;
    ULONG ulFetched = 0;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    BOOL fHasFocusDIM;

    if (!ulCount)
        return S_FALSE;

    fHasFocusDIM = (ptim && ptim->_GetFocusDocInputMgr()) ? TRUE : FALSE;

    for (i = 0; i < _rglbiProxy.Count(); i++)
    {
        CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);

        if (!fHasFocusDIM && pProxy->_fCicTip)
            continue;

        if (FAILED(pProxy->_plbi->GetInfo(pInfo)))
        return E_FAIL;
        pInfo++;

        if (FAILED(pProxy->_plbi->GetStatus(pdwStatus)))
            return E_FAIL;
        pdwStatus++;

        *ppItem = pProxy->_plbi;
        pProxy->_plbi->AddRef();
        ppItem++;

        ulFetched++;

        if (ulFetched >= ulCount)
            break;
    }

    if (pcFetched)
        *pcFetched = ulFetched;

    return (ulFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// AdviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CLangBarItemMgr::AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
{
    ULONG ul;
    for ( ul = 0; ul < ulCount; ul++)
    {
        if (FAILED(AdviseItemSink(ppunk[ul], &pdwCookie[ul], pguidItem[ul])))
            return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CLangBarItemMgr::UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
{
    ULONG ul;
    for ( ul = 0; ul < ulCount; ul++)
    {
        if (FAILED(UnadviseItemSink(pdwCookie[ul])))
            return E_FAIL;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumLBItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::EnumItems(IEnumTfLangBarItems **ppEnum)
{
    CEnumLBItem *pEnum = new CEnumLBItem(_psfn);
    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItem(REFGUID rguid, ITfLangBarItem **ppItem)
{
    if (!ppItem)
        return E_INVALIDARG;

    *ppItem = NULL;

    CLBarItemSinkProxy *pProxy = GetItemSinkProxy(rguid);
    if (pProxy)
    {
        *ppItem = pProxy->_plbi;
        (*ppItem)->AddRef();
    }

    return *ppItem ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// _AddWin32IMECtrl
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::_AddWin32IMECtrl(BOOL fNotify)
{
    if (_plbiWin32IME != NULL)
        return;

    if (_plbiWin32IME = new CLBarItemWin32IME)
    {
        AddItem(_plbiWin32IME);
        _plbiWin32IME->ShowInternal(TRUE, fNotify);
    }
}

//+---------------------------------------------------------------------------
//
// _RemoveWin32IMECtrl
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::_RemoveWin32IMECtrl()
{
    if (_plbiWin32IME == NULL)
        return;

    RemoveItem(_plbiWin32IME);
}

//+---------------------------------------------------------------------------
//
// GetItemSinkProxy
//
//----------------------------------------------------------------------------

CLBarItemSinkProxy *CLangBarItemMgr::GetItemSinkProxy(REFGUID rguid)
{
    CLBarItemSinkProxy *pProxy = NULL;
    int nCnt = _rglbiProxy.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
         CLBarItemSinkProxy *pProxyTemp = _rglbiProxy.Get(i);
         if (IsEqualGUID(pProxyTemp->_info.guidItem, rguid))
         {
             pProxy = pProxyTemp;
             break;
         }
    }

    return pProxy;
}

//+---------------------------------------------------------------------------
//
// UpdateIcon
//
//----------------------------------------------------------------------------

HRESULT CLangBarItemMgr::OnUpdate(ITfLangBarItem *plbi, DWORD dwFlags)
{
    int i;
    int nCnt;
    HRESULT hr;
    TF_LANGBARITEMINFO info;
    BOOL fFound;

    //
    // Toolbar will be being updated. So no need to handle OnUpdate.
    // Toolbar will ask icons, bitmaps no matter what.
    //
    if (!_fHandleOnUpdate)
         return S_OK;

    hr = plbi->GetInfo(&info);
    if (FAILED(hr))
         return hr;
    
    fFound = FALSE;
    nCnt = _rgSink.Count();
    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink *pSink = _rgSink.Get(i);

#ifdef DEBUG
        Assert(!pSink->_fUnadvised);
#endif

        if (IsEqualGUID(pSink->_info.guidItem, info.guidItem))
        {
            pSink->_dwDirtyUpdateFlags |= dwFlags;
            fFound = TRUE;
        }
    }

    if (_fDirtyUpdateHandling)
    {
        //
        // #509783
        //
        // Some apps (Adobe PhotoShop) call PeekMessage() to eat the message
        // from queue but it does not call DispatchMessage() sometimes.
        // We need a way to restore _fDirtyUpdateHandling flag.
        //
        if (GetTickCount() - dwDirtyUpdateHandlingTime > 1000)
        {
            _fDirtyUpdateHandling = 0;
        }
    }

    if (fFound && !_fDirtyUpdateHandling)
    {
        HWND hwnd = EnsureMarshalWnd();
        if (hwnd)
        {
            PostMessage(hwnd, g_msgNuiMgrDirtyUpdate, 0, 0);
            _fDirtyUpdateHandling = TRUE;
            dwDirtyUpdateHandlingTime = GetTickCount();
         
            //
            // we need to check Kana-Caps status every time the langbar item
            // is updated.
            //
            SYSTHREAD *psfn = FindSYSTHREAD();
            if (psfn)
                StartKanaCapsUpdateTimer(psfn);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUpdateHandler
//
//----------------------------------------------------------------------------

HRESULT CLangBarItemMgr::OnUpdateHandler()
{
    int i;
    int nCnt;

    _fDirtyUpdateHandling = FALSE;
    _fInOnUpdateHandler = TRUE;

    nCnt = _rgSink.Count();

    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink *pSink = _rgSink.Get(i);

        DWORD dwFlags = pSink->_dwDirtyUpdateFlags;

        if (!dwFlags)
            continue;

        pSink->_dwDirtyUpdateFlags = 0;
        pSink->_pItemSink->OnUpdate(dwFlags);

        int nCntNew = _rgSink.Count();
        if (nCnt > nCntNew)
        {
            nCnt = nCntNew;
            i--;
        }
    }

    _fInOnUpdateHandler = FALSE;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSinkProxy
//
//////////////////////////////////////////////////////////////////////////////

BOOL CLBarItemSinkProxy::Init(CLangBarItemMgr *plbiMgr, ITfLangBarItem *plbi, TF_LANGBARITEMINFO *pinfo)
{ 

    _plbiMgr = plbiMgr; // don't AddRef, because this obj is contained in the mgr's life
                        // we'd create a circular ref if we did, and we don't need to

    _plbi = plbi;
    _plbi->AddRef();
    _fCicTip = FALSE;

    _info = *pinfo;

    CTip *ptip;
    TfGuidAtom guidatom;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    if (ptim && SUCCEEDED(MyRegisterGUID(_info.clsidService, &guidatom)))
    {
         _fCicTip = ptim->_GetCTipfromGUIDATOM(guidatom, &ptip);
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumLBItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumLBItem::CEnumLBItem(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CEnumLBItem"));

    CThreadInputMgr *ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);
    if (ptim)
        _fHasFocusDIM = ptim->_GetFocusDocInputMgr() ? TRUE : FALSE;

    _nCur = 0;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumLBItem::~CEnumLBItem()
{
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Clone(IEnumTfLangBarItems **ppEnum)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Next(ULONG ulCount, ITfLangBarItem **ppLBItem, ULONG *pcFetched)
{
    int nCnt;
    ULONG cFetched;

    CLangBarItemMgr *plbim = _psfn->plbim;
    if (!plbim)
        return E_FAIL;

    nCnt = plbim->_rglbiProxy.Count();
    cFetched = 0;

    if (!ppLBItem)
         return E_INVALIDARG;

    *ppLBItem = NULL;

    while (cFetched < ulCount)
    {
        *ppLBItem = NULL;

        CLBarItemSinkProxy *pProxy;
        if (nCnt <= _nCur)
            break;

        pProxy = plbim->_rglbiProxy.Get(_nCur);
        if (!pProxy)
            break;

        if (_fHasFocusDIM || !pProxy->_fCicTip)
        {
           *ppLBItem = pProxy->_plbi;
           (*ppLBItem)->AddRef();

           ppLBItem++;
           cFetched++;
        }
        _nCur++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Reset()
{
    _nCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Skip(ULONG ulCount)
{
    int nCnt;
    CLangBarItemMgr *plbim = _psfn->plbim;
    if (!plbim)
        return E_FAIL;

    nCnt = plbim->_rglbiProxy.Count();


    while (ulCount)
    {
        if (nCnt <= _nCur)
            break;

        _nCur++;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\nuimgr.h ===
//
// nuimgr.h
//

#ifndef NUIMGR_H
#define NUIMGR_H

#include "private.h"
#include "ptrary.h"
#include "helpers.h"
#include "systhrd.h"

class CThreadInputMgr;
class CLBarItemSinkProxy;
class CLangBarItemMgr;

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemSink
{
public:
    CLBarItemSink()
    {
#ifdef DEBUG
        _fUnadvised = FALSE;
#endif
    }

    ~CLBarItemSink()
    {
        SafeRelease(_pItemSink);
    }

    BOOL Init(ITfLangBarItemSink *pItemSink, 
              TF_LANGBARITEMINFO *pinfo,
              DWORD dwCookie)
    {
        _pItemSink = pItemSink;
        _pItemSink->AddRef();
        _dwCookie = dwCookie;
        _info = *pinfo;
        return TRUE;
    }


    ITfLangBarItemSink *_pItemSink;
    TF_LANGBARITEMINFO _info;
    DWORD _dwCookie;

    DWORD _dwDirtyUpdateFlags;

#ifdef DEBUG
    BOOL _fUnadvised;
#endif

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CLangBarItemMgr : public ITfLangBarItemMgr,
                        public CSysThreadRef
{
public:
    CLangBarItemMgr(SYSTHREAD *psfn);
    ~CLangBarItemMgr();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    BOOL _Init();

    //
    // ITfLangBarItemMgr
    //
    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP GetItem(REFGUID rguid, ITfLangBarItem **ppItem);
    STDMETHODIMP AddItem(ITfLangBarItem *punk);
    STDMETHODIMP RemoveItem(ITfLangBarItem *punk);
    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguidItem);
    STDMETHODIMP UnadviseItemSink(DWORD dwCookie);
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus);
    STDMETHODIMP GetItemNum(ULONG *pulCount);
    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched);
    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie);
    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie);

    HRESULT RemoveItem(REFGUID rguid);
    HRESULT OnUpdate(ITfLangBarItem *plbi, DWORD dwFlags);
    BOOL IsInOnUpdateHandler() {return _fInOnUpdateHandler ? TRUE : FALSE;}

    HRESULT OnUpdateHandler();

    CLBarItemDeviceType *FindDeviceTypeItem(REFGUID guid);
    void CleanUp();

    CPtrArray<CLBarItemSinkProxy> _rglbiProxy;

    static CLangBarItemMgr *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;

        return psfn->plbim;
    }

    BOOL _SetThis(CLangBarItemMgr *_this)
    { 
        if (!_psfn)
            return FALSE;

        _psfn->plbim = _this;

        return TRUE;
    }

    void EnterAssemblyChange()
    {
        _ulInAssemblyChange++;
        _fItemChanged = FALSE;
    }

    BOOL LeaveAssemblyChange()
    {
        Assert(_ulInAssemblyChange);
        _ulInAssemblyChange--;

        return (_fItemChanged && (_ulInAssemblyChange == 0)) ? TRUE : FALSE;
    }

    BOOL InAssemblyChange()
    {
        return _ulInAssemblyChange ? TRUE : FALSE;
    }
   
    void SetItemChange()
    {
        _fItemChanged = TRUE;
    }

    void StopHandlingOnUpdate() {_fHandleOnUpdate = FALSE;}
    void StartHandlingOnUpdate() {_fHandleOnUpdate = TRUE;}
    
    CLBarItemCtrl *_GetLBarItemCtrl() { return _plbiCtrl; }
    CLBarItemReconv *_GetLBarItemReconv() { return _plbiReconv; }
    CLBarItemWin32IME *_GetLBarItemWin32IME() { return _plbiWin32IME; }
    //CLBarItemHelp *_GetLBarItemHelp() { return _plbiHelp; } // unused
    CPtrArray<CLBarItemDeviceType> *_GetLBarItemDeviceTypeArray() { return &_rglbiDeviceType; }

    void _AddWin32IMECtrl(BOOL fNotify);
    void _RemoveWin32IMECtrl();

    void _RemoveSystemItems(SYSTHREAD *psfn);

    void ResetDirtyUpdate()
    {
        _fDirtyUpdateHandling = FALSE;
    }

private:

    CLBarItemSinkProxy *GetItemSinkProxy(REFGUID rguid);
    DWORD _GetCookie() {_dwCurCookie++; return _dwCurCookie;} // Issue: need to prevent wrap-around
    DWORD _dwCurCookie;

    CPtrArray<CLBarItemSink> _rgSink;

    ULONG _ulInAssemblyChange;
    BOOL _fItemChanged : 1;
    BOOL _fHandleOnUpdate : 1;
    BOOL _fDirtyUpdateHandling : 1;
    BOOL _fInOnUpdateHandler  : 1;

    DWORD dwDirtyUpdateHandlingTime;

    // system ctls
    CLBarItemCtrl       *_plbiCtrl;
    CLBarItemReconv     *_plbiReconv;
    CLBarItemWin32IME   *_plbiWin32IME;
    CLBarItemHelp       *_plbiHelp;
    CPtrArray<CLBarItemDeviceType> _rglbiDeviceType;

    DBG_ID_DECLARE;
};

// wrapper for CoCreateInstance calls, unlike CLangBarItemMgr this
// class calls DllAddRef/Release
class CLangBarItemMgr_Ole : public ITfLangBarItemMgr,
                            public CComObjectRootImmx
{
public:
    BEGIN_COM_MAP_IMMX(CLangBarItemMgr_Ole)
        COM_INTERFACE_ENTRY(ITfLangBarItemMgr)
    END_COM_MAP_IMMX()

    CLangBarItemMgr_Ole()
    {
        _plbim = NULL;
    }

    ~CLangBarItemMgr_Ole()
    {
        SafeRelease(_plbim);
    }

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        CLangBarItemMgr_Ole *pLangBarItemMgr_Ole;
        HRESULT hr;

        if (ppvObj == NULL)
            return E_INVALIDARG;

        *ppvObj = NULL;

        if (pUnkOuter != NULL)
            return CLASS_E_NOAGGREGATION;

        pLangBarItemMgr_Ole = new CLangBarItemMgr_Ole;

        if (pLangBarItemMgr_Ole == NULL)
            return E_OUTOFMEMORY;

        hr = pLangBarItemMgr_Ole->QueryInterface(riid, ppvObj);

        pLangBarItemMgr_Ole->Release();

        if (hr == S_OK)
        {
            hr = CLangBarItemMgr::CreateInstance(pUnkOuter, IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr_Ole->_plbim);

            if (hr != S_OK) // only reason I can think of would be E_OUTOFMEMORY, but be careful
            {
                pLangBarItemMgr_Ole->Release();
                *ppvObj = NULL;
                hr = E_FAIL;
            }
        }

        return hr;
    }

    // ITfLangBarItemMgr
    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum)
    {
        return _plbim->EnumItems(ppEnum);
    }
    STDMETHODIMP GetItem(REFGUID rguid, ITfLangBarItem **ppItem)
    {
        return _plbim->GetItem(rguid, ppItem);
    }
    STDMETHODIMP AddItem(ITfLangBarItem *punk)
    {
        return _plbim->AddItem(punk);
    }
    STDMETHODIMP RemoveItem(ITfLangBarItem *punk)
    {
        return _plbim->RemoveItem(punk);
    }
    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguidItem)
    {
        return _plbim->AdviseItemSink(punk, pdwCookie, rguidItem);
    }
    STDMETHODIMP UnadviseItemSink(DWORD dwCookie)
    {
        return _plbim->UnadviseItemSink(dwCookie);
    }
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
    {
        return _plbim->GetItemFloatingRect(dwThreadId, rguid, prc);
    }
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
    {
        return _plbim->GetItemsStatus(ulCount, prgguid, pdwStatus);
    }
    STDMETHODIMP GetItemNum(ULONG *pulCount)
    {
        return _plbim->GetItemNum(pulCount);
    }
    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
    {
        return _plbim->GetItems(ulCount,  ppItem,  pInfo, pdwStatus, pcFetched);
    }
    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
    {
        return _plbim->AdviseItemsSink(ulCount, ppunk,  pguidItem, pdwCookie);
    }
    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
    {
        return _plbim->UnadviseItemsSink(ulCount, pdwCookie);
    }

private:
    ITfLangBarItemMgr *_plbim;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSinkProxy
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemSinkProxy : public ITfLangBarItemSink,
                           public CComObjectRootImmx_NoDllAddRef
{
public:
    CLBarItemSinkProxy()
    {
    }

    ~CLBarItemSinkProxy()
    {
        Clear();
    }

    BOOL Init(CLangBarItemMgr *plbiMgr, ITfLangBarItem *plbi, TF_LANGBARITEMINFO *pinfo);

    void Clear()
    {
        _plbiMgr = NULL; // not AddRef'd
        SafeReleaseClear(_plbi);
    }

    BEGIN_COM_MAP_IMMX(CLBarItemSinkProxy)
        COM_INTERFACE_ENTRY(ITfLangBarItemSink)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfLangBarItemSink
    //
    STDMETHODIMP OnUpdate(DWORD dwFlags) 
    {
        if (!_plbiMgr || !_plbi)
             return E_FAIL;

        return _plbiMgr->OnUpdate(_plbi, dwFlags);
    }


    CLangBarItemMgr *_plbiMgr;
    ITfLangBarItem *_plbi;
    DWORD _dwCookie;
    BOOL _fCicTip;
    TF_LANGBARITEMINFO _info;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CEnumLBItem
//
//////////////////////////////////////////////////////////////////////////////

// Issue: this class should copy all data in ctor
// and derive from CEnumUnknown base
class CEnumLBItem : public IEnumTfLangBarItems,
                    public CSysThreadRef,
                    public CComObjectRootImmx
{
public:
    CEnumLBItem(SYSTHREAD *psfn);
    ~CEnumLBItem();

    BEGIN_COM_MAP_IMMX(CEnumLBItem)
        COM_INTERFACE_ENTRY(IEnumTfLangBarItems)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // IEnumTfLBItem
    //
    STDMETHODIMP Clone(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfLangBarItem **ppNUI, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    int _nCur;
    BOOL _fHasFocusDIM;
    DBG_ID_DECLARE;
};


#endif // NUIMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\perfct.cpp ===
//
// perfct.cpp
//

#include "private.h"
#include "perfct.h"

#ifdef DEBUG

extern DBG_MEMSTATS s_Dbg_MemStats;

DBG_MEM_COUNTER g_rgPerfObjCounters[] =
{
    { TEXT("CAnchorRef:          "), 0 },
    { TEXT("CRange:              "), 0 },
    { TEXT("CLoaderACP:          "), 0 },
    { TEXT("CACPWrap:            "), 0 },
    { TEXT("CAnchorList:         "), 0 },
    { TEXT("CAnchor:             "), 0 },
    { TEXT("CEnumAppPropRanges:  "), 0 },
    { TEXT("CAppProperty:        "), 0 },
    { TEXT("CEnumUberRanges:     "), 0 },
    { TEXT("CUberProperty:       "), 0 },
    { TEXT("CEnumProperties:     "), 0 },
    { TEXT("CProperty:           "), 0 },
    { TEXT("CCategoryMgr:        "), 0 },
    { TEXT("CEnumCategories:     "), 0 },
    { TEXT("CCompartmentMgr:     "), 0 },
    { TEXT("CEnumCompartment:    "), 0 },
    { TEXT("CCompartment:        "), 0 },
    { TEXT("CGlobalCompartment:  "), 0 },
    { TEXT("CCompartmentSub:     "), 0 },
    { TEXT("CEditRecord:         "), 0 },
    { TEXT("CEnumPropertyRanges: "), 0 },
    { TEXT("CInputContext:       "), 0 },
    { TEXT("CSpanSet:            "), 0 },
    { TEXT("PROPERTYLIST:        "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("CACPWrap::GetText    "), 0 },
    { TEXT("CACPWrap:GetText:loop"), 0 },
    { TEXT("ShiftRegion:GetText  "), 0 },
    { TEXT("GetTextComp:GetText  "), 0 },
    { TEXT("PlainTextOff:GetText "), 0 },
    { TEXT("ATOF GetText calls:  "), 0 },
    { TEXT("ShiftCond:GetText    "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("ATOF calls:          "), 0 },
    { TEXT("ATON calls:          "), 0 },
    { TEXT("Normalize calls:     "), 0 },
    { TEXT("ShiftRegion calls:   "), 0 },
    { TEXT("Renormalize calls:   "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("CreateRangeACP       "), 0 },
    { TEXT("Lazy:Norm            "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("ITfRange::ShiftStart "), 0 },
    { TEXT("ITfRange::ShiftEnd   "), 0 },
    { TEXT("ITfRange::GetText    "), 0 },
    { TEXT("ITfRange::SetText    "), 0 },
    { TEXT("CAnchorRef::Shift    "), 0 },
    { TEXT("key down events      "), 0 },
};

#endif // DEBUG

#ifdef PERF_DUMP

LARGE_INTEGER g_liPerfFreq = { 0 };

ULONG g_cStrokes = 0;

struct
{
    LARGE_INTEGER liStart[PERF_STROKE_ARRAYSIZE];
    LARGE_INTEGER liEnd[PERF_STROKE_ARRAYSIZE];
}
g_rgPerfStrokes[2048] = { 0 };

BOOL Perf_Init()
{
    QueryPerformanceFrequency(&g_liPerfFreq);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Perf_GetTicks
//
//----------------------------------------------------------------------------

LARGE_INTEGER GetTicks()
{
    LARGE_INTEGER li;

    if (g_liPerfFreq.QuadPart != 0)
    {
        QueryPerformanceCounter(&li);
    }
    else
    {
        li.LowPart =  GetTickCount();
        li.HighPart = 0;
    }

    return li;
}

//+---------------------------------------------------------------------------
//
// Perf_GetTickDifference
//
//----------------------------------------------------------------------------

ULONG GetTickDifference(LARGE_INTEGER liStartTicks, LARGE_INTEGER liEndTicks)
{
    liEndTicks.QuadPart -= liStartTicks.QuadPart;

    if (g_liPerfFreq.QuadPart != 0)
    {
        liEndTicks.QuadPart /= (g_liPerfFreq.QuadPart / 1000);
    }

    return liEndTicks.LowPart;
}

//+---------------------------------------------------------------------------
//
// Perf_StartStroke
//
//----------------------------------------------------------------------------

void Perf_StartStroke(UINT iIndex)
{
    LARGE_INTEGER liPrevTotal;

    if (g_cStrokes < ARRAYSIZE(g_rgPerfStrokes))
    {
        liPrevTotal.QuadPart = g_rgPerfStrokes[g_cStrokes].liEnd[iIndex].QuadPart - g_rgPerfStrokes[g_cStrokes].liStart[iIndex].QuadPart;
        g_rgPerfStrokes[g_cStrokes].liStart[iIndex].QuadPart = GetTicks().QuadPart - liPrevTotal.QuadPart;
    }
}

//+---------------------------------------------------------------------------
//
// Perf_EndStroke
//
//----------------------------------------------------------------------------

void Perf_EndStroke(UINT iIndex)
{
    if (g_cStrokes < ARRAYSIZE(g_rgPerfStrokes))
    {
        g_rgPerfStrokes[g_cStrokes].liEnd[iIndex] = GetTicks();
    }

    if (iIndex == PERF_STROKE_DOWN)
    {
        g_cStrokes++;
    }
}

#include <stdio.h>

//+---------------------------------------------------------------------------
//
// Perf_DumpStats
//
//----------------------------------------------------------------------------

void Perf_DumpStats()
{
    //
    // add the application name to check the cicero's performance.
    //
    static const TCHAR *c_rgPerfProcesses[] =
    {
        TEXT("notepad.exe"),
    };

    FILE *file;
    TCHAR ach[MAX_PATH];
    DWORD cch;
    DWORD cchTest;
    LONG i;

    //
    // only dump perf info for certain processes
    //
    for (i=0; i<ARRAYSIZE(c_rgPerfProcesses); i++)
    {
        cchTest = lstrlen(c_rgPerfProcesses[i]);

        if ((cch = GetModuleFileName(0, ach, ARRAYSIZE(ach))) < cchTest)
            continue;

        if (lstrcmpi(ach+cch-cchTest, c_rgPerfProcesses[i]) != 0)
            continue;

        break;
    }
    if (i == ARRAYSIZE(c_rgPerfProcesses))
        return;

    file = fopen("c:\\perf.txt", "w");

    fprintf(file, "****************************************************************\n");
    fprintf(file, "Cicero Perf Counters (%s)\n", c_rgPerfProcesses[i]);
    fprintf(file, "****************************************************************\n");
    fprintf(file, "\n\n");

#ifdef DEBUG
    for (i=0; i<ARRAYSIZE(g_rgPerfObjCounters); i++)
    {
        fprintf(file, "%s %d\n", g_rgPerfObjCounters[i].pszDesc, g_rgPerfObjCounters[i].uCount);
    }

    fprintf(file, "\n\n");
    fprintf(file, "cicMemAlloc:      %d\n", s_Dbg_MemStats.uTotalMemAllocCalls);
    fprintf(file, "cicMemAllocClear: %d\n", s_Dbg_MemStats.uTotalMemAllocClearCalls);
    fprintf(file, "cicMemReAlloc:    %d\n", s_Dbg_MemStats.uTotalMemReAllocCalls);
#endif // DEBUG

    fprintf(file, "\n\n");
    for (i=0; i<(int)min(g_cStrokes, ARRAYSIZE(g_rgPerfStrokes)); i++)
    {
        ULONG ulElapsedDn = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_DOWN], g_rgPerfStrokes[i].liEnd[PERF_STROKE_DOWN]);
        ULONG ulElapsedUp = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_UP], g_rgPerfStrokes[i].liEnd[PERF_STROKE_UP]);
        ULONG ulElapsedTestDn = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_TESTDOWN], g_rgPerfStrokes[i].liEnd[PERF_STROKE_TESTDOWN]);
        ULONG ulElapsedTestUp = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_TESTUP], g_rgPerfStrokes[i].liEnd[PERF_STROKE_TESTUP]);
        ULONG ulElapsedGetMessage = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_GETMSG], g_rgPerfStrokes[i].liEnd[PERF_STROKE_GETMSG]);

        ULONG ulPrev = (i == 0) ? 0 : GetTickDifference(g_rgPerfStrokes[i-1].liEnd[PERF_STROKE_DOWN], g_rgPerfStrokes[i].liEnd[PERF_STROKE_DOWN]);
        ULONG ulPercent = (i == 0) ? 0 : (ulElapsedDn+ulElapsedUp+ulElapsedTestUp+ulElapsedTestDn)*100/ulPrev;

        fprintf(file, "KeyDown %d: %d/%d/%d/%d (%d) (%d%% of %d)\n", i,
                ulElapsedDn, ulElapsedUp, ulElapsedTestDn, ulElapsedTestUp, ulElapsedGetMessage, ulPercent, ulPrev);
    }

    fclose(file);
}

#endif // PERF_DUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\prop.h ===
//
// prop.h
//

#ifndef PROP_H
#define PROP_H

#include "sunka.h"

class CInputContext;
class CProperty;

class CEnumProperties : public IEnumTfProperties,
                        public CEnumUnknown,
                        public CComObjectRootImmx
{
public:
    CEnumProperties()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumProperties"), PERF_ENUMPROP_COUNTER);
    }

    BOOL _Init(CInputContext *pic);

    BEGIN_COM_MAP_IMMX(CEnumProperties)
        COM_INTERFACE_ENTRY(IEnumTfProperties)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfProperties, CEnumProperties, ITfProperty)

private:
    DBG_ID_DECLARE;
};

#endif // PROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for immx project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define OEMRESOURCE

#undef WINVER 
#define WINVER 0x500

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <immp.h>
#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <olectl.h>
#include <limits.h>
#include <initguid.h>
#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h> 
#include "msctf.h"
#include "msctfp.h"
#include "helpers.h"

#include "docwrap.h"
#include "msaadptr.h"
#include "cicmsaa.h"

#include "delay.h"

#ifdef __cplusplus
#include "combase.h"
#endif

#include "mem.h"  // put this last because it macros "new" in DEBUG
#include "dbgid.h"
#include "osver.h"

#include "chkobj.h"

#include "perfct.h"

#ifdef __cplusplus
#include "immxutil.h"
#include "template.h"
#endif

//
// Cic #4580: enable this to support SmartVoice 4.0
//
#define CHECKFEIMESELECTED 1

#define SCALE_ICON 1

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\prop.cpp ===
//
// prop.cpp
//

#include "private.h"
#include "prop.h"
#include "ic.h"

//////////////////////////////////////////////////////////////////////////////
//
// CEnumProperties
//
//////////////////////////////////////////////////////////////////////////////

DBG_ID_INSTANCE(CEnumProperties);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumProperties::_Init(CInputContext *pic)
{
    ULONG i;
    CProperty *prop;
    
    // get a count of the number of properties
    for (i=0, prop = pic->_GetFirstProperty(); prop != NULL; prop = prop->_pNext)
    {
        i++;
    }

    // alloc an array
    _prgUnk = SUA_Alloc(i);

    if (_prgUnk == NULL)
        return FALSE;

    // copy the data
    for (i=0, prop = pic->_GetFirstProperty(); prop != NULL; prop = prop->_pNext)
    {
        _prgUnk->rgUnk[i] = prop;
        _prgUnk->rgUnk[i]->AddRef();
        i++;
    }

    _prgUnk->cRef = 1;
    _prgUnk->cUnk = i;

    _iCur = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\perfct.h ===
//
// perfct.h
//
// Profiling counters.
//

#ifndef PERFCOUNT_H
#define PERFCOUNT_H

//#define PERF_DUMP

// offsets into s_rgPerfCounters
#define PERF_ANCHORREF_COUNTER      0
#define PERF_RANGE_COUNTER          1
#define PERF_LOADERACP_COUNTER      2
#define PERF_ACPWRAP_COUNTER        3
#define PERF_ANCHORLIST_COUNTER     4
#define PERF_ANCHOR_COUNTER         5
#define PERF_ENUMAPPPROP_COUNTER    6
#define PERF_APPPROP_COUNTER        7
#define PERF_ENUMUBERPROP_COUNTER   8
#define PERF_UBERPROP_COUNTER       9
#define PERF_ENUMPROP_COUNTER       10
#define PERF_PROP_COUNTER           11
#define PERF_CATMGR_COUNTER         12
#define PERF_ENUMCAT_COUNTER        13
#define PERF_COMPARTMGR_COUNTER     14
#define PERF_ENUMCOMPART_COUNTER    15
#define PERF_COMPART_COUNTER        16
#define PERF_GLOBCOMPART_COUNTER    17
#define PERF_COMPARTSUB_COUNTER     18
#define PERF_EDITREC_COUNTER        19
#define PERF_ENUMPROPRANGE_COUNTER  20
#define PERF_CONTEXT_COUNTER        21
#define PERF_SPANSET_COUNTER        22
#define PERF_PROPERTYLIST_COUNTER   23

#define PERF_BREAK0                 24

#define PERF_ACPWRAP_GETTEXT        25
#define PERF_ACPWRAP_GETTEXT_LOOP   26
#define PERF_ANCHOR_REGION_GETTEXT  27
#define PERF_NORM_GETTEXTCOMPLETE   28
#define PERF_PTO_GETTEXT            29
#define PERF_ATOF_GETTEXT_COUNTER   30
#define PERF_SHIFTCOND_GETTEXT      31

#define PERF_BREAK1                 32

#define PERF_ATOF_COUNTER           33
#define PERF_ATON_COUNTER           34
#define PERF_NORMALIZE_COUNTER      35
#define PERF_SHIFTREG_COUNTER       36
#define PERF_RENORMALIZE_COUNTER    37

#define PERF_BREAK2                 38

#define PERF_CREATERANGE_ACP        39
#define PERF_LAZY_NORM              40

#define PERF_BREAK3                 41

#define PERF_SHIFTSTART_COUNT       42
#define PERF_SHIFTEND_COUNT         43
#define PERF_RGETTEXT_COUNT         44
#define PERF_RSETTEXT_COUNT         45
#define PERF_ANCHOR_SHIFT           46
#define PERF_KEYDOWN_COUNT          47

#ifdef PERF_DUMP

BOOL Perf_Init();
void Perf_DumpStats();

#define PERF_STROKE_DOWN            0
#define PERF_STROKE_UP              1
#define PERF_STROKE_TESTDOWN        2
#define PERF_STROKE_TESTUP          3
#define PERF_STROKE_GETMSG          4
#define PERF_STROKE_ARRAYSIZE       5

void Perf_StartStroke(UINT iIndex);
void Perf_EndStroke(UINT iIndex);

#else 

#define Perf_Init()
#define Perf_DumpStats()
#define Perf_StartStroke(iIndex)
#define Perf_EndStroke(iIndex)

#endif // PERF_DUMP

#ifdef DEBUG

//
// debug
//

extern DBG_MEM_COUNTER g_rgPerfObjCounters[];

__inline void Perf_IncCounter(int iCounter) { g_rgPerfObjCounters[iCounter].uCount++; }

#else

//
// retail
//

#define Perf_IncCounter(iCounter)

#endif // DEBUG
#endif // PERFCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\propstru.h ===
#ifndef PROPSTRU_H
#define PROPSTRU_H

//
// Magic values for PROPERTYSTREAMxxx structures.
//
#define MAGIC_PROPSTREAMHEADER  0xbeef0001
#define MAGIC_PROPSTREAMITEM    0xbeef0002
#define MAGIC_PROPSTREAMFOOTER  0xbeefffff

typedef struct tag_PROPERTYSTREAMHEADER
{
  DWORD _dwMagic;
  long _lTextCheckSum;
  GUID _guidProp;
  long _lPropSize;
} PROPERTYSTREAMHEADER;

typedef struct tag_PROPERTYSTREAMITEM
{
  DWORD _dwMagic;
  long _lBufSize;
} PROPERTYSTREAMITEM;

typedef struct tag_PROPERTYSTREAMITEM_CHAR
{
  long _lAnchor;
  long _lSize;
} PROPERTYSTREAMITEM_CHAR;

typedef struct tag_PROPERTYSTREAMITEM_RANGE
{
  long _lAnchor;
  long _lSize;
  CLSID _clsidIME;
} PROPERTYSTREAMITEM_RANGE;

typedef struct tag_PROPERTYSTREAMFOOTER
{
  DWORD _dwMagic;
} PROPERTYSTREAMFOOTER;


#endif //  PROPSTRU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\profiles.cpp ===
//
// profiles.cpp
//

#include "private.h"
#include "tim.h"
#include "ic.h"
#include "dim.h"
#include "assembly.h"
#include "nuictrl.h"
#include "nuihkl.h"
#include "imelist.h"
#include "xstring.h"
#include "profiles.h"
#include "lbaddin.h"

BOOL MyGetTIPCategory(REFCLSID clsid, GUID *pcatid);

DBG_ID_INSTANCE(CEnumLanguageProfiles);

typedef struct _PENDING_ASSEMBLY_ITEM
{
    LANGID langid;
    HKL hkl;
    CLSID clsid;
    GUID guidProfile;
    DWORD dwFlags;
} PENDING_ASSEMBLY_ITEM;


//////////////////////////////////////////////////////////////////////////////
//
// static functions
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// UpdateSystemLangBarItems()
//
//----------------------------------------------------------------------------

void UpdateSystemLangBarItems(SYSTHREAD *psfn, HKL hNewKL, BOOL fNotify)
{
    if (psfn->plbim == NULL)
        return;

    if (psfn->plbim->_GetLBarItemDeviceTypeArray())
    {
        int nCnt = psfn->plbim->_GetLBarItemDeviceTypeArray()->Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            CLBarItemDeviceType *plbi = psfn->plbim->_GetLBarItemDeviceTypeArray()->Get(i);
            plbi->ShowOrHide(fNotify);
        }
    }

    if (psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->_UpdateLangIcon(hNewKL, fNotify);

    if (psfn->plbim->_GetLBarItemReconv())
        psfn->plbim->_GetLBarItemReconv()->ShowOrHide(fNotify);

    //
    // If this function is called, someone needs to make
    // notification later.
    //
    if (psfn->plbim->InAssemblyChange())
    {
        Assert(!fNotify);
        psfn->plbim->SetItemChange();
    }

    UpdateLangBarAddIns();
}

//+---------------------------------------------------------------------------
//
// ActivateAssemblyPostCleanupCallback
//
//----------------------------------------------------------------------------

void ActivateAssemblyPostCleanupCallback(BOOL fAbort, LONG_PTR lPrivate)
{
    SYSTHREAD *psfn;
    LANGID langid = HIWORD(lPrivate);
    ACTASM actasm = (ACTASM)LOWORD(lPrivate);

    if (fAbort)
        return; // nothing to cleanup...

    if (psfn = GetSYSTHREAD())
    {
        SyncActivateAssembly(psfn, langid, actasm);
    }
}

//+---------------------------------------------------------------------------
//
// DeactivateRemovedTipinAssembly
//
// Deactivate active TIPs that are not in the assembly list. This can happen
// someone remove the profile from the control panel during the tip is 
// running on some application.
//
//----------------------------------------------------------------------------

void DeactivateRemovedTipInAssembly(CThreadInputMgr *ptim, CAssembly *pAsm)
{
    int nAsmCnt = pAsm->Count();
    TfGuidAtom *patom;
    int i; 
    UINT j;

    if (!ptim)
        return;

    if (!nAsmCnt)
        return;

    patom = new TfGuidAtom[nAsmCnt];
    if (!patom)
        return;

    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);
        patom[i] = TF_INVALID_GUIDATOM;
        if (pItem && pItem->fEnabled && !IsEqualGUID(pItem->clsid, GUID_NULL))
            MyRegisterGUID(pItem->clsid, &patom[i]);
    }
  
    for (j = 0; j < ptim->_GetTIPCount(); j++)
    {
        const CTip *ptip = ptim->_GetCTip(j);
        if (ptip && ptip->_fActivated)
        {
            BOOL fFound = FALSE;

            for (i = 0; i < nAsmCnt; i++)
            {
                if (ptip->_guidatom == patom[i])
                    fFound = TRUE;
            }

            if (!fFound)
            {
                CLSID clsid;
                if (SUCCEEDED(MyGetGUID(ptip->_guidatom, &clsid)))
                    ptim->ActivateInputProcessor(clsid, 
                                                 GUID_NULL,
                                                 NULL,
                                                 FALSE);
            }
        }
    }

    delete patom;
}

//+---------------------------------------------------------------------------
//
// GetAssemblyChangeHKL
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//  GetAssemblyChangeHKL and SyncActivateAssembly must have exactly
//  same logic. Otherwise HKL will be corrupted.
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//----------------------------------------------------------------------------

HKL GetAssemblyChangeHKL(SYSTHREAD *psfn, LANGID langid, BOOL fTimActivateLayout)
{
    CThreadInputMgr *ptim;
    BOOL fRet = FALSE;
    ULONG ul;
    ULONG ulCount = 0;
    int nAsmCnt;
    int i;
    BOOL fActivated = FALSE;
    BOOL fActiveNoCic = FALSE;
    BOOL fActivateFEIMEHKLOnCic = FALSE;
    BOOL fCiceroClient= FALSE;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    HKL hNewKL = NULL;
    HKL hCurrKL = GetKeyboardLayout(0);

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return NULL;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return NULL;

    nAsmCnt = pAsm->Count();
    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // Check if we're in Cicero aware focus.
    //
    if (ptim && ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    fActivateFEIMEHKLOnCic = pAsm->IsFEIMEActive();

TryAgain:
    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (fActiveNoCic)
        {
           if (fCiceroClient)
           {
              if (!pItem->fActiveNoCic)
                 continue;
           }
           else
           { 
              if (fActivated)
                 break;
           }
        }
        else
        {
           if (!pItem->fActive)
              continue;
        }


        if (!IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            BOOL fFound = FALSE;
            ul = 0;

            //
            // if fTimActivateLayout is true, we load TIPs.
            //
            if (!fCiceroClient && !fTimActivateLayout)
               continue;

            //
            // skip to activate cicero tip because we will activate
            // FEIMEHKL.
            //
            if (fActivateFEIMEHKLOnCic)
               continue;

            if (pItem->hkl)
            {
                HKL hKL = pItem->hkl;

                //
                // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
                //
                if (hKL != hCurrKL)
                    hNewKL = hKL;
            }

            fActivated = TRUE;
        }
        else if (pItem->hkl)
        {
            HKL hKL = pItem->hkl;

            //
            // skip substituted hKL on Cicero aware control.
            //
            if (fCiceroClient && pAsm->GetSubstituteItem(hKL))
                continue;

            //
            // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
            //
            if (hKL != hCurrKL)
                hNewKL = hKL;

            fActivated = TRUE;
        }
    }

    if (!fActivated && !fActiveNoCic)
    {
        fActiveNoCic = TRUE;
        goto TryAgain;
    }
 
    return hNewKL;
}

//+---------------------------------------------------------------------------
//
// ActivateAssembly
//
//----------------------------------------------------------------------------

BOOL ActivateAssembly(LANGID langid, ACTASM actasm)
{
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;
    LONG_PTR lParam;
    CLEANUPCONTEXT cc;
    BOOL bRet = FALSE;
    BOOL fTimActivateLayout = (actasm == ACTASM_ONTIMACTIVE) ? TRUE : FALSE;
    BOOL fOnShellLangChange = (actasm == ACTASM_ONSHELLLANGCHANGE) ? TRUE : FALSE;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    if (psfn->fInActivateAssembly)
        return FALSE;

    psfn->fInActivateAssembly = TRUE;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // if the client is no Cicero aware, we just post 
    // WM_INPUTLANGCHANGEREQUEST.
    //
    if (!ptim || (!fTimActivateLayout && !ptim->_GetFocusDocInputMgr()))
    {
        //
        // If we don't requires any hKL change to activate this new
        // assembly, we can call SyncActivateAssembly now.
        // Otherwise we need to wait until WM_INPUTLANGUAGECHANGEREQUEST
        // is processed.
        //
        HKL hKL = GetAssemblyChangeHKL(psfn, langid, fTimActivateLayout);
        if (fOnShellLangChange || !hKL || (hKL == GetKeyboardLayout(0)))
            SyncActivateAssembly(psfn, langid, actasm);
        else
            PostInputLangRequest(psfn, hKL, TRUE);

        goto Exit;
    }

    lParam = ((DWORD)langid << 16);
    lParam |= actasm;

    cc.fSync = fTimActivateLayout;
    cc.pCatId = NULL;
    cc.langid = langid;
    cc.pfnPostCleanup = ActivateAssemblyPostCleanupCallback;
    cc.lPrivate = lParam;

    ptim->_CleanupContexts(&cc);

    bRet = TRUE;
Exit:
    psfn->fInActivateAssembly = FALSE;
    return bRet;
}

//+---------------------------------------------------------------------------
//
// SyncActivateAssembly
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//  GetAssemblyChangeHKL and SyncActivateAssembly must have exactly
//  same logic. Otherwise HKL will be corrupted.
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//----------------------------------------------------------------------------

BOOL SyncActivateAssembly(SYSTHREAD *psfn, LANGID langid, ACTASM actasm)
{
    CThreadInputMgr *ptim;
    BOOL fRet = FALSE;
    ULONG ul;
    ULONG ulCount = 0;
    int nAsmCnt;
    int i;
    BOOL fActivated = FALSE;
    BOOL fActiveNoCic = FALSE;
    BOOL fIconUpdated = FALSE;
    BOOL fActivateFEIMEHKLOnCic = FALSE;
    BOOL fCallLeaveAssembly = FALSE;
    BOOL fCiceroClient= FALSE;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    HKL hNewKL = NULL;
    BOOL fTimActivateLayout = (actasm == ACTASM_ONTIMACTIVE) ? TRUE : FALSE;
    BOOL fOnShellLangChange = (actasm == ACTASM_ONSHELLLANGCHANGE) ? TRUE : FALSE;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return FALSE;

#ifdef CHECKFEIMESELECTED
    pAsm->_fUnknownFEIMESelected = FALSE;
#endif CHECKFEIMESELECTED

    if (psfn->pipp)
    {
        if (!psfn->pipp->_OnLanguageChange(FALSE, pAsm->GetLangId()))
            return TRUE;
    }

    //
    // Enter assembly change notification section.
    // We delay the notificaiton untill LeaveAssemblyChange() is called.
    //
    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

    nAsmCnt = pAsm->Count();
    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // Check if we're in Cicero aware focus.
    //
    if (ptim && ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);
        pItem->fSkipToActivate = FALSE;
        pItem->fSkipToNotify = FALSE;
    }

    if (ptim)
    {
        CAssembly *pAsmCur;
        pAsmCur = GetCurrentAssembly(psfn);
        if (pAsmCur)
        {
            int nAsmCurCnt = pAsmCur->Count();
    
            DeactivateRemovedTipInAssembly(ptim, pAsmCur);
    
            //
            // check if we will activate FEIMEHKL. If so, we will disable 
            // all Cicero tip.
            //
            fActivateFEIMEHKLOnCic = pAsm->IsFEIMEActive();
    
            for (int j = 0; j < nAsmCurCnt; j++)
            {
                ASSEMBLYITEM *pItemCur = pAsmCur->GetItem(j);
    
                if (!pItemCur->fEnabled)
                    continue;
    
                BOOL fSkipToActivate = FALSE;
                BOOL fSkipToNotify = FALSE;
    
                if (ptim->_IsActiveInputProcessor(pItemCur->clsid) != S_OK)
                    continue;
    
                for (i = 0; i < nAsmCnt; i++)
                {
                    ASSEMBLYITEM *pItem = pAsm->GetItem(i);
    
                    if (!pItem->fEnabled)
                        continue;
    
                    if (pItem->fActive && 
                        !fActivateFEIMEHKLOnCic &&
                        IsEqualCLSID(pItem->clsid, pItemCur->clsid))
                    {
                        if (IsEqualCLSID(pItem->guidProfile, pItemCur->guidProfile))
                        {
                            pItem->fSkipToNotify = TRUE;
                            fSkipToNotify = TRUE;
                        }
                        pItem->fSkipToActivate = TRUE;
                        fSkipToActivate = TRUE;
                        break;
                    }
                }
       
                if (!fSkipToNotify)
                {
                    if (fSkipToActivate)
                        ptim->NotifyActivateInputProcessor(pItemCur->clsid, pItemCur->guidProfile, FALSE);
                    else
                        ptim->ActivateInputProcessor(pItemCur->clsid, pItemCur->guidProfile, pItemCur->hklSubstitute, FALSE);
                }
            }
        }
        else
        {
            //
            // if the current assembly is gone, we deactivate all tips.
            //
            for (ul = 0; ul < ptim->_GetTIPCount(); ul++)
            {
                const CTip *ptip = ptim->_GetCTip(ul);
                if (ptip->_fActivated)
                {
                    CLSID clsid;
                    if (SUCCEEDED(MyGetGUID(ptip->_guidatom, &clsid)))
                       ptim->ActivateInputProcessor(clsid, GUID_NULL, NULL, FALSE);
                }
            }
        }
    }

    SetCurrentAssemblyLangId(psfn, pAsm->GetLangId());

TryAgain:
    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem)
        {
            Assert(0);
            continue;
        }

        if (!pItem->fEnabled)
            continue;

        if (fActiveNoCic)
        {
           if (fCiceroClient)
           {
              if (!pItem->fActiveNoCic)
                 continue;
           }
           else
           { 
              if (fActivated)
                 break;
           }
        }
        else
        {
           if (!pItem->fActive)
              continue;
        }


        if (!IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            BOOL fFound = FALSE;
            ul = 0;

            //
            // if fTimActivateLayout is true, we load TIPs.
            //
            if (!fCiceroClient && !fTimActivateLayout)
               continue;

            //
            // skip to activate cicero tip because we will activate
            // FEIMEHKL.
            //
            if (fActivateFEIMEHKLOnCic)
               continue;

            if (pItem->hkl)
            {
                HKL hKL = pItem->hkl;
                HKL hCurrKL = GetKeyboardLayout(0);

                //
                // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
                //
                if (hKL != hCurrKL)
                {
                    //
                    // If we're not on Cicero aware focus,
                    // we won't set AssemblyLangId here 
                    // but we post WM_INPUTLANGCHANGEREQUEST.
                    //
                    if (!fOnShellLangChange)
                        PostInputLangRequest(psfn, hKL, 
                                             !fTimActivateLayout && !fCiceroClient);
                    hNewKL = hKL;
                }
            }

            //
            // check if this TIP is already activated.
            //
            if (pItem->fSkipToActivate)
            {
                if (!pItem->fSkipToNotify)
                    ptim->NotifyActivateInputProcessor(pItem->clsid, pItem->guidProfile, TRUE);
                pItem->fSkipToActivate = FALSE;
                pItem->fSkipToNotify = FALSE;
            }
            else
                ptim->ActivateInputProcessor(pItem->clsid, pItem->guidProfile, pItem->hklSubstitute, TRUE);

            fActivated = TRUE;
        }
        else if (pItem->hkl)
        {
            HKL hKL = pItem->hkl;
            HKL hCurrKL = GetKeyboardLayout(0);

            //
            // skip substituted hKL on Cicero aware control.
            //
            if (fCiceroClient && pAsm->GetSubstituteItem(hKL))
                continue;

            //
            // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
            //
            if (hKL != hCurrKL)
            {
                //
                // If we're not on Cicero aware focus,
                // we won't set AssemblyLangId here 
                // but we post WM_INPUTLANGCHANGEREQUEST.
                //
                if (!fOnShellLangChange)
                    PostInputLangRequest(psfn, hKL,
                                         !fTimActivateLayout && !fCiceroClient);
                hNewKL = hKL;
                MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
            }

            //
            // Notify to profile.
            //
            if (ptim)
            {
                 ptim->NotifyActivateInputProcessor(pItem->clsid, 
                                                        pItem->guidProfile, 
                                                        TRUE);
            }

            // 
            // Now we activated this pItem.
            // 
            fActivated = TRUE;
        }

    }

    if (!fActivated && !fActiveNoCic)
    {
        fActiveNoCic = TRUE;
        goto TryAgain;
    }
 
    UpdateSystemLangBarItems(psfn, hNewKL, FALSE);


    fRet = TRUE;

    if (psfn->pipp)
    {
        psfn->pipp->_OnLanguageChange(TRUE, 0);
    }

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// ActivateNextAssembly
//
//----------------------------------------------------------------------------

BOOL ActivateNextAssembly(BOOL bPrev)
{
    SYSTHREAD *psfn;
    CAssemblyList *pAsmList;
    CAssembly *pAsmNext = NULL;
    BOOL bRet = FALSE;
    LANGID langidCur;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return FALSE;

    if ((pAsmList = EnsureAssemblyList(psfn)) == NULL)
        return FALSE;

    int i;
    int nCnt = pAsmList->Count();
    Assert(nCnt > 0);

    langidCur = GetCurrentAssemblyLangId(psfn);

    for (i = 0; i < nCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);
        if (pAsm->GetLangId() == langidCur)
        {
            int nNext;
            int nCur = i;

CheckNext:
            if (bPrev)
            {
                nNext = i - 1;
                if (nNext < 0)
                   nNext = nCnt - 1;
            }
            else
            {
                nNext = i + 1;
                if (nNext >= nCnt)
                   nNext = 0;
            }

            pAsmNext = pAsmList->GetAssembly(nNext);
            if (!pAsmNext->IsEnabled(psfn))
            {
                i = nNext;

                if (i == nCur)
                {
                    //
                    // we cound not find Asm.
                    // we don't have to change the assembly.
                    //
                    pAsmNext = NULL;
                    break;
                }

                goto CheckNext;
            }
            break;
        }
    }

    if (pAsmNext && pAsmNext->GetLangId() != langidCur)
    {
        bRet = ActivateAssembly(pAsmNext->GetLangId(), ACTASM_NONE);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// ActivateNextKeyTip
//
//----------------------------------------------------------------------------

BOOL ActivateNextKeyTip(BOOL bPrev)
{
    SYSTHREAD *psfn;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItemFirst = NULL;
    ASSEMBLYITEM *pItemCur = NULL;
    ASSEMBLYITEM *pItemNext = NULL;
    BOOL bCatchNext = FALSE;
    int i;
    BOOL fTransitory = FALSE;
    BOOL fCiceroClient = FALSE;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return FALSE;

    if ((pAsm = GetCurrentAssembly(psfn)) == NULL)
        return FALSE;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim && ptim->_GetFocusDocInputMgr())
    {
        pAsm->RebuildSubstitutedHKLList();
        CInputContext *pic = ptim->_GetFocusDocInputMgr()->_GetTopIC();
        if (pic)
        {
            TF_STATUS dcs;
            if (SUCCEEDED(pic->GetStatus(&dcs)) &&
                (dcs.dwStaticFlags & TF_SS_TRANSITORY))
                fTransitory = TRUE;
        }
        fCiceroClient = TRUE;
    }
    else
        pAsm->ClearSubstitutedHKLList();

    HKL hkl = GetKeyboardLayout(0);
    int nCnt = pAsm->Count();

    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTemp;

        if (!bPrev)
            pItemTemp = pAsm->GetItem(i);
        else
            pItemTemp = pAsm->GetItem(nCnt - i - 1);

        if (!pItemTemp->fEnabled)
            continue;

        if (pItemTemp->fDisabledOnTransitory && fTransitory)
            continue;

        if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
        {
            if (!fCiceroClient)
            {
                if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                    continue;
            }
            else
            {
                if (IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                {
                    if (pAsm->IsSubstitutedHKL(pItemTemp->hkl))
                        continue;
                }
            }

            if (!pItemFirst)
                pItemFirst = pItemTemp;

            if (bCatchNext)
            {
                pItemNext = pItemTemp;
                break;
            }

            if (pItemTemp->fActive ||
               ((!fCiceroClient || IsPureIMEHKL(hkl)) && (hkl == pItemTemp->hkl)))
            {
                pItemCur = pItemTemp;
                bCatchNext = TRUE;
            }
        }
    }

    if (!pItemNext)
    {
        pItemNext = pItemFirst;
    }

    if (pItemNext)
    {
        ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItemNext, AAIF_CHANGEDEFAULT);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetCurrentAssembly
//
//+---------------------------------------------------------------------------

CAssembly *GetCurrentAssembly(SYSTHREAD *psfn)
{
    LANGID langid = 0;

    if (!psfn)
    {
        if ((psfn = GetSYSTHREAD()) == NULL)
            return NULL;
    }

    CAssemblyList *pAsmList = EnsureAssemblyList(psfn);

    if (!pAsmList)
        return NULL;

    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        langid = GetCurrentAssemblyLangId(psfn);

    return pAsmList->FindAssemblyByLangId(langid);
}


//+---------------------------------------------------------------------------
//
// ActivateAssemblyItemPostCleanupCallback
//
//----------------------------------------------------------------------------

void ActivateAssemblyItemPostCleanupCallback(BOOL fAbort, LONG_PTR lPrivate)
{
    PENDING_ASSEMBLY_ITEM *pas = (PENDING_ASSEMBLY_ITEM *)lPrivate;
    SYSTHREAD *psfn;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItem;
    int i;

    if (fAbort) // just a cleanup?
        goto Exit;

    if ((psfn = GetSYSTHREAD()) == NULL)
        goto Exit;

    if ((pAsmList = EnsureAssemblyList(psfn)) == NULL)
    {
        Assert(0);
        goto Exit;
    }

    if ((pAsm = pAsmList->FindAssemblyByLangId(pas->langid)) == NULL)
    {
        Assert(0);
        goto Exit;
    }

    //
    // we need to make sure the pItem is valid.
    //
    for (i = 0; i < pAsm->Count(); i++)
    {
        pItem = pAsm->GetItem(i);

        if (pItem->IsEqual(pas->hkl, pas->clsid, pas->guidProfile))
        {
            SyncActivateAssemblyItem(psfn, pas->langid, pItem, pas->dwFlags);
            break;
        }
    }
    Assert(i < pAsm->Count()); // should have found the item we were looking for...

Exit:
    cicMemFree(pas);
}

//+---------------------------------------------------------------------------
//
// ActivateAssemblyItem
//
//----------------------------------------------------------------------------

BOOL ActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags)
{
    CThreadInputMgr *ptim;
    PENDING_ASSEMBLY_ITEM *pas;
    CLEANUPCONTEXT cc;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim == NULL)
    {
        return SyncActivateAssemblyItem(psfn, langid, pItem, dwFlags);
    }

    if ((pas = (PENDING_ASSEMBLY_ITEM *)cicMemAlloc(sizeof(PENDING_ASSEMBLY_ITEM))) == NULL)
        return FALSE;

    pas->langid = langid;
    pas->hkl = pItem->hkl;
    pas->clsid = pItem->clsid;
    pas->guidProfile = pItem->guidProfile;
    pas->dwFlags = dwFlags;

    cc.fSync = FALSE;
    cc.pCatId = &pItem->catid;
    cc.langid = langid;
    cc.pfnPostCleanup = ActivateAssemblyItemPostCleanupCallback;
    cc.lPrivate = (LONG_PTR)pas;

    ptim->_CleanupContexts(&cc);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SyncActivateAssemblyItem
//
//----------------------------------------------------------------------------

BOOL SyncActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags)
{
    int i;
    int nCnt;
    BOOL fActivateFEIMEHKL = FALSE;
    BOOL fPrevActivateFEIMEHKL = FALSE;
    BOOL fCallLeaveAssembly = FALSE;
    BOOL fSkipActivate = FALSE;
    BOOL fSkipNotify = FALSE;
    BOOL fCiceroClient = FALSE;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    HKL hNewKL = NULL;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return FALSE;

    ptim = psfn->ptim;

    //
    // Check if we're in Cicero aware focus.
    //
    if (ptim && ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    if (IsEqualGUID(pItem->clsid, GUID_NULL))
    {
        if (IsPureIMEHKL(pItem->hkl))
        {
            fActivateFEIMEHKL = TRUE;
        }
    }
    else if (!fCiceroClient)
    {
        //
        // we should not activate TIPs in the focus is already changed to
        // non cicero aware DIM.
        //
        return TRUE;
    }

    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

#ifdef CHECKFEIMESELECTED
    if (pAsm->_fUnknownFEIMESelected)
    {
        pAsm->_fUnknownFEIMESelected = FALSE;
        fPrevActivateFEIMEHKL = TRUE;
    }
#endif CHECKFEIMESELECTED

    //
    // deactivate all tip in the same category or diactivate all tips
    // when FE-IME is activated.
    //
    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

        if (!pItemTemp->fActive)
            continue;

        if (IsEqualGUID(pItem->catid, pItemTemp->catid))
        {
            if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
            {
                if (ptim)
                {
                    if (IsEqualGUID(pItemTemp->clsid, pItem->clsid))
                    {
                        if (IsEqualGUID(pItemTemp->guidProfile, pItem->guidProfile))
                            fSkipNotify = TRUE;

                        if (!fSkipNotify)
                            ptim->NotifyActivateInputProcessor(pItemTemp->clsid, pItemTemp->guidProfile, FALSE);
                        fSkipActivate = TRUE;
                    }
                    else
                        ptim->ActivateInputProcessor(pItemTemp->clsid, pItemTemp->guidProfile, pItemTemp->hklSubstitute, FALSE);
                }
            }
            else
            {
                if (IsPureIMEHKL(pItemTemp->hkl))
                    fPrevActivateFEIMEHKL = TRUE;

                if (ptim)
                    ptim->NotifyActivateInputProcessor(pItemTemp->clsid, 
                                                       pItemTemp->guidProfile, 
                                                       FALSE);
            }

            pItemTemp->fActive = FALSE;
        }
        else if (fActivateFEIMEHKL)
        { 
            //
            // FEIMEHKL will be activated so deactivate all tips.
            //
            if (ptim)
            {
                if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                    ptim->ActivateInputProcessor(pItemTemp->clsid, 
                                                 pItemTemp->guidProfile, 
                                                 pItemTemp->hklSubstitute, 
                                                 FALSE);
                else
                    ptim->NotifyActivateInputProcessor(pItemTemp->clsid, 
                                                       pItemTemp->guidProfile, 
                                                       FALSE);
            }
        }
    }

    pItem->fActive = TRUE;

    if (pItem->hkl && (pItem->hkl != GetKeyboardLayout(0)))
    {
        //
        // If we're not on Cicero aware focus,
        // we won't set AssemblyLangId here 
        // but we post WM_INPUTLANGCHANGEREQUEST.
        //
        PostInputLangRequest(psfn, pItem->hkl, !fCiceroClient);
        hNewKL = pItem->hkl;
    }

    //
    // Update assembly reg before making notify.
    //
    pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, pItem, dwFlags & AAIF_CHANGEDEFAULT);

    if (!fActivateFEIMEHKL)
    {
        if (ptim)
        {
            if (!fSkipNotify)
            {
                if (fSkipActivate || IsEqualGUID(pItem->clsid, GUID_NULL))
                    ptim->NotifyActivateInputProcessor(pItem->clsid, pItem->guidProfile, TRUE);
                else
                    ptim->ActivateInputProcessor(pItem->clsid, pItem->guidProfile, pItem->hklSubstitute, TRUE);
            }
        }

        //
        // if the previous activated item was FEIMEHKL,
        // restore all tips in the other categories.
        //
        if (fPrevActivateFEIMEHKL)
        {
            nCnt = pAsm->Count();
            for (i = 0; i < nCnt; i++)
            {
                ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

                if (!pItemTemp->fEnabled)
                    continue;

                if (!pItemTemp->fActive)
                    continue;

                if (ptim && !IsEqualGUID(pItem->catid, pItemTemp->catid))
                {
                    ptim->ActivateInputProcessor(pItemTemp->clsid, pItemTemp->guidProfile, pItemTemp->hklSubstitute, TRUE);
                }
            }
        }
    }
    else
    {
        if (ptim)
            ptim->NotifyActivateInputProcessor(pItem->clsid, 
                                               pItem->guidProfile, 
                                               TRUE);
    }

    UpdateSystemLangBarItems(psfn, hNewKL, FALSE);

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  SetFocusDIMForAssembly
//
//----------------------------------------------------------------------------

BOOL SetFocusDIMForAssembly(BOOL fSetFocus)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    int nCnt;
    int i;
    HKL hNewKL = NULL;
    BOOL fCallLeaveAssembly = FALSE;

    if (!psfn)
    {
        Assert(0);
        return FALSE;
    }

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!ptim)
    {
        Assert(0);
        return FALSE;
    }

    pAsm = GetCurrentAssembly(psfn);
    if (!pAsm)
    {
        Assert(0);
        return FALSE;
    }

    if (fSetFocus)
    {
        //
        // If the substitute hKL is activated now, we move to Cicero mode
        // completely.
        //
        HKL hKL = GetKeyboardLayout(0);

        ActivateAssembly(LOWORD(hKL), ACTASM_NONE);

        //
        // make sure the substituing item will be activated.
        // we need to use hKL that was before calling ActivateAssembly().
        //
        ASSEMBLYITEM *pItem = pAsm->GetSubstituteItem(hKL);
        if (pItem)
        {
            if (!ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItem, 0))
                return FALSE;

            ptim->NotifyActivateInputProcessor(pItem->clsid, 
                                               pItem->guidProfile, 
                                               TRUE);
        }
    }
    else
    {
        if (pAsm->IsEnabled(psfn))
        {
            //
            // if the crruent active TIP has a substitute hKL, we activate it.
            //
            nCnt = pAsm->Count();
            for (i = 0; i < nCnt; i++)
            {
                ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

                Assert(!pItemTemp->hkl || (LOWORD((HKL)pItemTemp->hkl) == pAsm->GetLangId()));

                if (!pItemTemp->fEnabled)
                    continue;
    
                if (!pItemTemp->fActive)
                    continue;
    
                if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
                {
                    //
                    // we activate the substitute hkl.
                    //
                    if (pItemTemp->hklSubstitute)
                    {
                        PostInputLangRequest(psfn, pItemTemp->hklSubstitute, FALSE);
                        ptim->NotifyActivateInputProcessor(GUID_NULL,
                                                           GUID_NULL,
                                                           TRUE);
                        hNewKL = pItemTemp->hklSubstitute;
                    }

                    break;
                }
            }
        }
        else
        {
#if 0
            //
            // If the current language does not have an Item can run
            // under non-Cicero control, we need to swtich the languiage to
            // system default input locale.
            //

            CAssembly *pAsmTemp;
            CAssemblyList *pAsmList;

            pAsmList = EnsureAssemblyList(psfn);
            pAsmTemp = pAsmList->GetDefaultAssembly();
            if (pAsmTemp)
                ActivateAssembly(pAsmTemp->GetLangId(), ACTASM_NONE);
#endif
        }
    }

    //
    // Enter assembly change notification section.
    // We delay the notificaiton untill LeaveAssemblyChange() is called.
    //
    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

    UpdateSystemLangBarItems(psfn, hNewKL, FALSE);

    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->_AsmListUpdated(FALSE);

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetKeyboardItemNum
//
//----------------------------------------------------------------------------

UINT GetKeyboardItemNum()
{
    SYSTHREAD *psfn;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    int i;

    psfn = GetSYSTHREAD();

    if (psfn == NULL)
        return 0;

    pAsm = GetCurrentAssembly(psfn);

    if (!pAsm)
        return 0;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim && ptim->_GetFocusDocInputMgr())
        pAsm->RebuildSubstitutedHKLList();
    else
        pAsm->ClearSubstitutedHKLList();

    int nCnt = 0;

    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItemTemp;

        pItemTemp = pAsm->GetItem(i);

        if (!pItemTemp->fEnabled)
            continue;

        if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
        {
            if (!ptim || !ptim->_GetFocusDocInputMgr())
            {
                if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                    continue;
            }
             
            if (IsEqualGUID(pItemTemp->clsid, GUID_NULL))
            {
                if (pAsm->IsSubstitutedHKL(pItemTemp->hkl))
                    continue;
            }
            nCnt++;
        }
    }

    return nCnt;
}

#ifdef CHECKFEIMESELECTED
//+---------------------------------------------------------------------------
//
// UnknownFEIMESelectedPostCleanupCallback
//
//----------------------------------------------------------------------------

void UnknownFEIMESelectedPostCleanupCallback(BOOL fAbort, LONG_PTR lPrivate)
{
    SYSTHREAD *psfn;
    LANGID langid = (LANGID)lPrivate;

    if (fAbort)
        return; // nothing to cleanup...

    if (psfn = GetSYSTHREAD())
    {
        SyncUnknownFEIMESelected(psfn, langid);
    }
}


//+---------------------------------------------------------------------------
//
// UnknownFEIMESelected
//
//----------------------------------------------------------------------------

BOOL UnknownFEIMESelected(LANGID langid)
{
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;
    CLEANUPCONTEXT cc;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim == NULL)
        return TRUE;

    cc.fSync = FALSE;
    cc.pCatId = NULL;
    cc.langid = langid;
    cc.pfnPostCleanup = UnknownFEIMESelectedPostCleanupCallback;
    cc.lPrivate = langid;

    ptim->_CleanupContexts(&cc);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SyncUnknownFEIMESelected
//
//----------------------------------------------------------------------------

BOOL SyncUnknownFEIMESelected(SYSTHREAD *psfn, LANGID langid)
{
    int i;
    int nCnt;
    // BOOL fActivateFEIMEHKL = FALSE;
    // BOOL fPrevActivateFEIMEHKL = FALSE;
    BOOL fCallLeaveAssembly = FALSE;
    // BOOL fSkipActivate = FALSE;
    // BOOL fSkipNotify = FALSE;
    // BOOL fCiceroClient = FALSE;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return FALSE;

    ptim = psfn->ptim;

    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

    pAsm->_fUnknownFEIMESelected = TRUE;
    //
    // deactivate all tip in the same category or diactivate all tips
    // when FE-IME is activated.
    //
    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

        if (!pItemTemp->fActive)
            continue;

        //
        // FEIMEHKL will be activated so deactivate all tips.
        //
        if (ptim && !IsEqualGUID(pItemTemp->clsid, GUID_NULL))
            ptim->ActivateInputProcessor(pItemTemp->clsid, 
                                         pItemTemp->guidProfile, 
                                         pItemTemp->hklSubstitute, 
                                         FALSE);

        if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
            pItemTemp->fActive = FALSE;
    }

    UpdateSystemLangBarItems(psfn, NULL, FALSE);

    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->_AsmListUpdated(FALSE);

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}
#endif CHECKFEIMESELECTED


//////////////////////////////////////////////////////////////////////////////
//
// CEnumLanguageProfiles
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumLanguageProfiles::CEnumLanguageProfiles()
{
    _langid = 0;
    _iCur = 0;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumLanguageProfiles::~CEnumLanguageProfiles()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
// !!!WARNING WARNING WARNING!!!
//
// LanguageProfile enumrator is not focus DIM sensitive. Some caller
// want to know which TIP will be activated if the focus is moved to
// Cicero aware (or AIMM12). 
// Don't check the current focus or patch fActive flag.
//
//----------------------------------------------------------------------------

BOOL CEnumLanguageProfiles::Init(LANGID langid)
{
    CAssemblyList *pAsmList;
    int nCntAsm;
    int i;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn == NULL)
        return FALSE;

    pAsmList = EnsureAssemblyList(psfn);

    if (pAsmList == NULL)
        return FALSE;

    nCntAsm = pAsmList->Count();
    if (!nCntAsm)
        return FALSE;

    for (i = 0;i < nCntAsm; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);
        if (!pAsm)
            continue;

        if (!langid || langid == pAsm->GetLangId())
        {
            int j;
            int nCntList = pAsm->Count();
            BOOL fActivateFEIMEHKLOnCic = pAsm->IsFEIMEActive();

            for (j = 0; j < nCntList; j++)
            {
                ASSEMBLYITEM *pItem;
                TF_LANGUAGEPROFILE *pprofile;
                pItem = pAsm->GetItem(j);

                if (!pItem)
                    continue;

                if (IsEqualCLSID(pItem->clsid, GUID_NULL))
                    continue;

                pprofile = _rgProfiles.Append(1);
                if (!pprofile)
                    continue;

                pprofile->clsid = pItem->clsid;
                pprofile->langid = pAsm->GetLangId();
                pprofile->guidProfile = pItem->guidProfile;
                pprofile->catid = pItem->catid;

                if (fActivateFEIMEHKLOnCic)
                    pprofile->fActive = FALSE;
                else
                {
                    //
                    // we need to return TRUE even if the current focus is 
                    // not Cicero aware as above comments.
                    //
                    pprofile->fActive = pItem->fActive;
                }
            }
        }
    }
 
    _langid = langid;
 
    return _rgProfiles.Count() ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Clone(IEnumTfLanguageProfiles **ppEnum)
{
    CEnumLanguageProfiles *pEnum = NULL;

    if (!ppEnum)
        return E_INVALIDARG;

    *ppEnum = NULL;

    pEnum = new CEnumLanguageProfiles();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->Init(_langid))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return  S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Next(ULONG ulCount, TF_LANGUAGEPROFILE *rgLanguageProfiles, ULONG *pcFetched)
{
    ULONG cFetched;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;

    while (_iCur < _rgProfiles.Count() && *pcFetched < ulCount)
    {
        TF_LANGUAGEPROFILE *pprofile;
        pprofile = _rgProfiles.GetPtr(_iCur);
        *rgLanguageProfiles = *pprofile;
        rgLanguageProfiles++;
        *pcFetched = *pcFetched + 1;
        _iCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _rgProfiles.Count()) ? S_FALSE : S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// GetLanguageList
//
// This function is not TIM sensitive.
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetLanguageList(LANGID **ppLangId, ULONG *pulCount)
{
    CAssemblyList *pAsmList;
    int i;
    SYSTHREAD *psfn = GetSYSTHREAD();
    
    if (pulCount != NULL)
    {
        *pulCount = 0;
    }
    if (ppLangId != NULL)
    {
        *ppLangId = NULL;
    }

    if (!pulCount)
        return E_INVALIDARG;
    if (!ppLangId)
        return E_INVALIDARG;

    if (psfn == NULL)
        return E_FAIL;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_FAIL;

    if (!pAsmList->Count())
        return S_OK;

    *ppLangId = (LANGID *)CoTaskMemAlloc(sizeof(LANGID) * pAsmList->Count());
    if (!*ppLangId)
    {
        *pulCount = 0;
        return E_OUTOFMEMORY;
    }

    for (i = 0;i < pAsmList->Count(); i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);

        //
        // At least one keyboard Item must be enabled to be in the list.
        //
        if (pAsm->IsEnabledKeyboardItem(psfn))
        {
            (*ppLangId)[*pulCount] = pAsm->GetLangId();
            (*pulCount)++;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumLanguageProfiles
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnumLanguageProfiles(LANGID langid, IEnumTfLanguageProfiles **ppEnum)
{
    CEnumLanguageProfiles *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    *ppEnum = NULL;

    pEnum = new CEnumLanguageProfiles();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->Init(langid))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return  S_OK;
}

//+---------------------------------------------------------------------------
//
// ActivateLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::ActivateLanguageProfile(REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    CThreadInputMgr *ptim;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    SYSTHREAD *psfn;
    BOOL fFound = FALSE;
    BOOL fNoCategory = FALSE;
    GUID catid;
    BOOL fSkipActivate = FALSE;

    if (!langid)
        return E_INVALIDARG;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    if (!(ptim = psfn->ptim))
        return E_UNEXPECTED;

    if (langid != GetCurrentAssemblyLangId(psfn))
        return E_INVALIDARG;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_OUTOFMEMORY;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return E_FAIL;

    fNoCategory = MyGetTIPCategory(rclsid, &catid) ? FALSE : TRUE;

    int nCntList = pAsm->Count();
    int i;
    ASSEMBLYITEM *pItemActivate = NULL;
    for (i = 0; i < nCntList; i++)
    {
        ASSEMBLYITEM *pItem;
        pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (fNoCategory || IsEqualGUID(catid, pItem->catid))
        {
            if (IsEqualGUID(pItem->guidProfile, guidProfile) &&
                IsEqualGUID(rclsid, pItem->clsid))
            {
               if (pItem->fActive)
               {
                   fSkipActivate = TRUE;
               }
               pItemActivate = pItem;
               break;
            }
        }
    }

    //
    // we could not find the given profile in the assembly.
    //
    if (!pItemActivate)
        return E_INVALIDARG;

    if (fSkipActivate)
    {
        //
        // the clsid is now activated. We skip to call activate 
        // but make a notification.
        //
        ptim->NotifyActivateInputProcessor(pItemActivate->clsid, pItemActivate->guidProfile, FALSE);

        for (i = 0; i < nCntList; i++)
        {
            ASSEMBLYITEM *pItem;
            pItem = pAsm->GetItem(i);

            if (!pItem->fEnabled)
                continue;

            if (!pItem->fActive)
                continue;

            if (!fNoCategory && !IsEqualGUID(catid, pItem->catid))
                continue;

            if (IsEqualGUID(rclsid, pItem->clsid))
            {
                pItem->fActive = FALSE;
            }
        }

        pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, pItemActivate, TRUE);
        pItemActivate->fActive = TRUE;
        ptim->NotifyActivateInputProcessor(pItemActivate->clsid, pItemActivate->guidProfile, TRUE);

        UpdateSystemLangBarItems(psfn, NULL, FALSE);

        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
    }
    else if (!pItemActivate->fActive)
    {
        if (!IsEqualGUID(pItemActivate->clsid, GUID_NULL) &&
            !ptim->_GetFocusDocInputMgr())
        {
            //
            // We don't want to support this. It is better to return ERROR.
            // However TIP and Apps may want to call this method
            // on Non-Cicero aware control such as DialogBox.
            //
            pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, pItemActivate, TRUE);
            ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItemActivate, AAIF_CHANGEDEFAULT);
            if (IsEqualGUID(pItemActivate->catid, GUID_TFCAT_TIP_KEYBOARD))
            {
                pItemActivate->fActive = TRUE;
                SetFocusDIMForAssembly(FALSE);
            }
        }
        else
        {
            ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItemActivate, AAIF_CHANGEDEFAULT);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetActiveLanguageProfile
//
// WARNING!!!
//
// Which GetActiveLanguageProfile() or GetDefaultLanguageProfile() should
// we use?
//
// This function is FocusDIM sensetive. So we can call any function
// to check TIM or FocusDIM.
//
// If you don't want to care about TIM and FocusDIM, try 
// GetDefaultLanguageProfile.
//
// if clsid is TIP's category ID, this returns the activated profiles in the
// category. 
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetActiveLanguageProfile(REFCLSID clsid, LANGID *plangid, GUID *pguid)
{
    CThreadInputMgr *ptim;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    SYSTHREAD *psfn;
    LANGID langid;
    BOOL fFound = FALSE;

    if (!plangid)
        return E_INVALIDARG;

    if (!pguid)
        return E_INVALIDARG;

    *plangid = 0;
    *pguid = GUID_NULL;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!ptim || !ptim->_GetFocusDocInputMgr()) 
    {
        //
        // Special Service!
        //
        // GetActiveLanguageProfile(GUID_TFCAT_TIP_KEYBOARD) works
        // without TIM, it can returns, the current keyboard layout.
        //
        if (IsEqualGUID(clsid, GUID_TFCAT_TIP_KEYBOARD))
        {
            HKL hkl;

            if (psfn->hklBeingActivated)
                hkl = psfn->hklBeingActivated;
            else
                hkl = GetKeyboardLayout(0);

            *plangid = LOWORD((DWORD)(UINT_PTR)hkl);
            *((DWORD *)pguid) =  (DWORD)(UINT_PTR)hkl;
            return S_OK;
        }

        return E_UNEXPECTED;
    }

    langid = GetCurrentAssemblyLangId(psfn);

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_OUTOFMEMORY;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return E_FAIL;

    int nCntList = pAsm->Count();
    int i;
    for (i = 0; i < nCntList; i++)
    {
        ASSEMBLYITEM *pItem;
        pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (pItem->fActive)
        {
            if (IsEqualGUID(clsid, pItem->catid) ||
                IsEqualGUID(clsid, pItem->clsid))
            {
                fFound = TRUE;
                *plangid = langid;
                if (!IsEqualCLSID(pItem->clsid, CLSID_NULL))
                    *pguid = pItem->guidProfile;
                else
                    *((DWORD *)pguid) =  (DWORD)(UINT_PTR)(HKL)(pItem->hkl);
            }
        }
    }

    return fFound ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
// GetCurrentLanguage
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetCurrentLanguage(LANGID *plangid)
{
    if (!plangid)
        return E_INVALIDARG;

    *plangid = GetCurrentAssemblyLangId(NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ChangeCurrentLanguage
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::ChangeCurrentLanguage(LANGID langid)
{
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    SYSTHREAD *psfn;

    if (CThreadInputMgr::_GetThis() == NULL)
        return E_UNEXPECTED;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    if (langid == GetCurrentAssemblyLangId(psfn))
        return S_OK;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_OUTOFMEMORY;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return E_INVALIDARG;

    return ActivateAssembly(pAsm->GetLangId(), ACTASM_NONE) ? S_OK : E_FAIL;
}


//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid = &IID_ITfLanguageProfileNotifySink;

    return GenericAdviseSink(riid, punk, &rgiid, &_rgNotifySinks, 1, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(&_rgNotifySinks, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// _OnLanguageChange
//
//----------------------------------------------------------------------------

BOOL CInputProcessorProfiles::_OnLanguageChange(BOOL fChanged, LANGID langid)
{
    int i;

    for (i = 0; i < _rgNotifySinks.Count(); i++)
    {
        HRESULT hr;

        if (!fChanged)
        {
            BOOL fAccept;
            hr = ((ITfLanguageProfileNotifySink *)_rgNotifySinks.GetPtr(i)->pSink)->OnLanguageChange(langid, &fAccept);
            if (SUCCEEDED(hr) && !fAccept)
                return FALSE;
        }
        else
        {
            ((ITfLanguageProfileNotifySink *)_rgNotifySinks.GetPtr(i)->pSink)->OnLanguageChanged();
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\profiles.h ===
//
// profiles.h
//

#ifndef PROFILES_H
#define PROFILES_H

#include "private.h"
#include "strary.h"
#include "assembly.h"
#include "ic.h"

class CThreadInputMgr;

//
// profiles.cpp
//
void UpdateSystemLangBarItems(SYSTHREAD *psfn, HKL hkl, BOOL fNotify);

#define ACTASM_NONE              0
#define ACTASM_ONTIMACTIVE       1
#define ACTASM_ONSHELLLANGCHANGE 2
typedef WORD ACTASM;

BOOL ActivateAssembly(LANGID langid, ACTASM actasm);
BOOL SyncActivateAssembly(SYSTHREAD *psfn, LANGID langid, ACTASM actasm);
BOOL ActivateNextAssembly(BOOL bPrev);
BOOL ActivateNext(BOOL bPrev);
BOOL ActivateNextKeyTip(BOOL bPrev);
CAssembly *GetCurrentAssembly(SYSTHREAD *psfn = NULL);

#ifdef CHECKFEIMESELECTED
BOOL UnknownFEIMESelected(LANGID langid);
BOOL SyncUnknownFEIMESelected(SYSTHREAD *psfn, LANGID langid);
#endif CHECKFEIMESELECTED

#define AAIF_CHANGEDEFAULT              0x00000001
BOOL ActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags);
BOOL SyncActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags);

BOOL SetFocusDIMForAssembly(BOOL fSetFocus);
UINT GetKeyboardItemNum();

//////////////////////////////////////////////////////////////////////////////
//
// CEnumLanguageProfile
//
//////////////////////////////////////////////////////////////////////////////

class CEnumLanguageProfiles : public IEnumTfLanguageProfiles,
                        public CComObjectRootImmx
{
public:
    CEnumLanguageProfiles();
    ~CEnumLanguageProfiles();

    BEGIN_COM_MAP_IMMX(CEnumLanguageProfiles)
        COM_INTERFACE_ENTRY(IEnumTfLanguageProfiles)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // IEnumTfRangeDeltas
    //
    STDMETHODIMP Clone(IEnumTfLanguageProfiles **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, TF_LANGUAGEPROFILE *rgLanguageProfiles, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

    BOOL Init(LANGID langid);

private:
    LANGID _langid;
    int _iCur;

    CStructArray<TF_LANGUAGEPROFILE> _rgProfiles;

    DBG_ID_DECLARE;
};

#endif // PROFILES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\ptrack.cpp ===
//
// ptrack.cpp
//

#include "private.h"
#include "ic.h"
#include "saa.h"
#include "attr.h"
#include "immxutil.h"
#include "erfa.h"
#include "epval.h"
#include "range.h"

//+---------------------------------------------------------------------------
//
// CalcCicPropertyTrackerAnchors
//
//----------------------------------------------------------------------------

CSharedAnchorArray *CalcCicPropertyTrackerAnchors(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ULONG cGUIDATOMs, const TfGuidAtom *prgGUIDATOMs)
{
    CProperty *pProperty;
    CSharedAnchorArray *prgAnchors;
    CSharedAnchorArray **prgAnchorArrays;
    ULONG i;
    LONG iStartEdge;
    LONG iEndEdge;
    LONG iSpan;
    PROPERTYLIST *pPropList;
    IAnchor **ppa;
    ULONG cArrays;
    BOOL fExactEndMatch;
    ULONG cMaxElems;

    if ((prgAnchorArrays = (CSharedAnchorArray **)cicMemAlloc(sizeof(CSharedAnchorArray *)*(cGUIDATOMs+1))) == NULL)
        return NULL;

    cArrays = 0;

    //
    // shove in the range start and end pts
    //
    if ((prgAnchors = new CSharedAnchorArray) == NULL)
        goto ErrorExit;

    if (!prgAnchors->Insert(0, 2))
        goto ErrorExit;

    if (paStart->Clone(prgAnchors->GetPtr(0)) != S_OK)
        goto ErrorExit;

    if (IsEqualAnchor(paStart, paEnd))
    {
        // empty range, we just want a single anchor at the range pos
        prgAnchors->SetCount(1);
        goto Exit;
    }

    if (paEnd->Clone(prgAnchors->GetPtr(1)) != S_OK)
        goto ErrorExit;

    prgAnchorArrays[0] = prgAnchors;

    //
    // assemble a list of all the points between start, end
    //
    cArrays = 1; // 1 for the start, end anchors array
    for (i=0; i<cGUIDATOMs; i++)
    {
        if ((pProperty = pic->_FindProperty(prgGUIDATOMs[i])) == NULL)
            continue; // no instances of this property

        // find the start, end points
        pProperty->Find(paStart, &iStartEdge, FALSE);
        fExactEndMatch = (pProperty->Find(paEnd, &iEndEdge, TRUE) != NULL);

        if (iEndEdge < iStartEdge)
            continue; // start, end are in the same property span, so value is constant over range

        // alloc memory for all the new anchors
        if ((prgAnchors = new CSharedAnchorArray) == NULL)
            goto ErrorExit;

        // alloc for max anchors
        cMaxElems = (iEndEdge - iStartEdge + 1)*2;

        if ((ppa = prgAnchors->Append(cMaxElems)) == NULL)
            goto ErrorExit;
        // prep for failure
        memset(ppa, 0, sizeof(IAnchor *)*cMaxElems);

        // add all the covered anchors for this prop to the list
        if (iStartEdge < 0)
        {
            iSpan = 0;
        }
        else
        {
            iSpan = iStartEdge;

            // if paStart is to the right of the span, skip it
            pPropList = pProperty->GetPropList(iStartEdge);
            if (CompareAnchors(paStart, pPropList->_paEnd) >= 0)
            {
                // we don't cover this span at all, or we just touch the right edge
                // so skip it
                iSpan++;
            }
        }

        while (iSpan <= iEndEdge)
        {
            // shove in this span's anchors
            pPropList = pProperty->GetPropList(iSpan);

            if (iSpan != iStartEdge)
            {
                // filter out dups
                // perf: we could elim the dup check for static compact props
                if (ppa == prgAnchors->GetPtr(0) || !IsEqualAnchor(*(ppa-1), pPropList->_paStart))
                {
                    if (pPropList->_paStart->Clone(ppa++) != S_OK)
                        goto ErrorExit;
                }
            }

            Assert(!IsEqualAnchor(pPropList->_paStart, pPropList->_paEnd)); // no zero-len properties!

            if (iSpan != iEndEdge ||
                (!fExactEndMatch && (iStartEdge < iEndEdge || CompareAnchors(paStart, pPropList->_paEnd) < 0)))
            {                
                if (pPropList->_paEnd->Clone(ppa++) != S_OK)
                    goto ErrorExit;
            }

            iSpan++;
        }
        // may also want the start anchor of the next span
        if (!fExactEndMatch &&
            pProperty->GetPropNum() > iEndEdge+1)
        {
            pPropList = pProperty->GetPropList(iEndEdge+1);

            if (CompareAnchors(paEnd, pPropList->_paStart) > 0) 
            {
                // start of this span may be same as end of prev for non-compact property, check for dup
                if (ppa == prgAnchors->GetPtr(0) || !IsEqualAnchor(*(ppa-1), pPropList->_paStart))
                {
                    // don't need a dup check w/ paEnd because we would have set fExactEndMatch in that case
                    if (pPropList->_paStart->Clone(ppa++) != S_OK)
                        goto ErrorExit;
                }
            }
        }

        // need to resize the array since we may have over-alloc'd
        Assert((int)cMaxElems >= ppa - prgAnchors->GetPtr(0));
        prgAnchors->SetCount((int)(ppa - prgAnchors->GetPtr(0)));
        prgAnchorArrays[cArrays++] = prgAnchors;
    }

    //
    // sort the list
    //
    if (cArrays > 1)
    {
        // mergesort will free all the arrays in prgAnchorArrays
        prgAnchors = CSharedAnchorArray::_MergeSort(prgAnchorArrays, cArrays);
    }
    else
    {
        Assert(prgAnchors == prgAnchorArrays[0]);
    }

    // shrink the array down to size, it won't be modified again
    if (prgAnchors)
        prgAnchors->CompactSize();

Exit:
    cicMemFree(prgAnchorArrays);
    return prgAnchors;

ErrorExit:
    for (i=0; i<cArrays; i++)
    {
        prgAnchorArrays[i]->_Release();
    }
    prgAnchors = NULL;
    goto Exit;
}

//+---------------------------------------------------------------------------
//
// FillCicValueArray
//
//----------------------------------------------------------------------------

void FillCicValueArray(CInputContext *pic, CRange *range, TF_PROPERTYVAL *rgPropVal, ULONG cGUIDATOMs, const TfGuidAtom *prgGUIDATOMs)
{
    ULONG i;
    CProperty *pProperty;

    for (i=0; i<cGUIDATOMs; i++)
    {
        Assert(rgPropVal[i].varValue.vt == VT_EMPTY);

        if (MyGetGUID(prgGUIDATOMs[i], &rgPropVal[i].guidId) != S_OK)
        {
            Assert(0); // this shouldn't happen, we registered the GUID when caller created the property
            rgPropVal[i].guidId = GUID_NULL;
            continue;
        }

        if ((pProperty = pic->_FindProperty(prgGUIDATOMs[i])) != NULL)
        {
            pProperty->_GetDataInternal(range->_GetStart(), range->_GetEnd(), &rgPropVal[i].varValue);
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumUberRanges
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumUberRanges : public CEnumRangesFromAnchorsBase
{
public:
    CEnumUberRanges()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumUberRanges"), PERF_ENUMUBERPROP_COUNTER);
    }
    BOOL _Init(CInputContext *pic, ITfRange *rangeSuper, ULONG cCicGUIDs, const TfGuidAtom *prgCicGUIDATOMs, ULONG cAppGUIDs, const GUID *prgAppGUIDs);

private:
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumUberRanges);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumUberRanges::_Init(CInputContext *pic, ITfRange *rangeSuper, ULONG cCicGUIDATOMs, const TfGuidAtom *prgCicGUIDATOMs, ULONG cAppGUIDs, const GUID *prgAppGUIDs)
{
    CRange *range;
    CSharedAnchorArray *prgSrcAnchorArrays[2];

    Assert(_iCur == 0);
    Assert(_pic == NULL);
    Assert(_prgAnchors == NULL);

    // find the app property transitions
    prgSrcAnchorArrays[0] = CalcAppPropertyTrackerAnchors(pic->_GetTSI(), rangeSuper, cAppGUIDs, prgAppGUIDs);

    if (prgSrcAnchorArrays[0] == NULL)
        return FALSE;

    // find the cicero property transitions
    if ((range = GetCRange_NA(rangeSuper)) == NULL)
        goto ErrorExit;

    prgSrcAnchorArrays[1] = CalcCicPropertyTrackerAnchors(pic, range->_GetStart(), range->_GetEnd(), cCicGUIDATOMs, prgCicGUIDATOMs);

    if (prgSrcAnchorArrays[1] == NULL)
        goto ErrorExit;

    // now combine the two lists
    _prgAnchors = CSharedAnchorArray::_MergeSort(prgSrcAnchorArrays, 2);

    if (_prgAnchors == NULL)
        return FALSE;

    _pic = pic;
    _pic->AddRef();

    return TRUE;

ErrorExit:
    prgSrcAnchorArrays[0]->_Release();
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CUberProperty
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CUberProperty : public ITfReadOnlyProperty, // perf: share base clas with CAppProperty
                      public CComObjectRootImmx
{
public:
    CUberProperty(CInputContext *pic);
    ~CUberProperty();

    BEGIN_COM_MAP_IMMX(CUberProperty)
        COM_INTERFACE_ENTRY(ITfReadOnlyProperty)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    BOOL _Init(ULONG cCicGUIDs, const GUID **prgCicGUIDs, ULONG cAppGUIDs, const GUID **prgAppGUIDs);

    // ITfReadOnlyProperty
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange);
    STDMETHODIMP GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue);
    STDMETHODIMP GetContext(ITfContext **ppContext);

private:
    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
    {
        return _pic->_IsValidEditCookie(ec, dwFlags);
    }

    CInputContext *_pic;

    ULONG _cCicGUIDATOMs;
    TfGuidAtom *_prgCicGUIDATOMs;

    ULONG _cAppGUIDs;
    GUID *_prgAppGUIDs;

    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CUberProperty);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CUberProperty::CUberProperty(CInputContext *pic)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CUberProperty"), PERF_UBERPROP_COUNTER);

    _pic = pic;
    _pic->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CUberProperty::~CUberProperty()
{
    _pic->Release();
    cicMemFree(_prgCicGUIDATOMs);
    cicMemFree(_prgAppGUIDs);
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CUberProperty::_Init(ULONG cCicGUIDs, const GUID **prgCicGUIDs, ULONG cAppGUIDs, const GUID **prgAppGUIDs)
{
    ULONG i;

    if ((_prgCicGUIDATOMs = (TfGuidAtom *)cicMemAlloc(cCicGUIDs*sizeof(TfGuidAtom))) == NULL)
        return FALSE;

    for (i=0; i<cCicGUIDs; i++)
    {
        if (MyRegisterGUID(*prgCicGUIDs[i], &_prgCicGUIDATOMs[i]) != S_OK)
            goto ExitError;
    }

    if ((_prgAppGUIDs = (GUID *)cicMemAlloc(cAppGUIDs*sizeof(GUID))) == NULL)
        goto ExitError;

    _cCicGUIDATOMs = cCicGUIDs;

    _cAppGUIDs = cAppGUIDs;
    for (i=0; i<cAppGUIDs; i++)
    {
        _prgAppGUIDs[i] = *prgAppGUIDs[i];
    }

    return TRUE;

ExitError:
    cicMemFree(_prgCicGUIDATOMs);
    _prgCicGUIDATOMs = NULL; // no funny business in the dtor please
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// EnumRanges
//
//----------------------------------------------------------------------------

STDAPI CUberProperty::EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange)
{
    CEnumUberRanges *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (pTargetRange == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, pTargetRange))
        return E_INVALIDARG;
    
    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pEnum = new CEnumUberRanges;

    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pic, pTargetRange, _cCicGUIDATOMs, _prgCicGUIDATOMs, _cAppGUIDs, _prgAppGUIDs))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CUberProperty::GetType(GUID *pguid)
{
    if (pguid != NULL)
    {
        // tracker's don't support GetType
        *pguid = GUID_NULL;
    }

    return E_NOTIMPL; // by design
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

STDAPI CUberProperty::GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue)
{
    CEnumPropertyValue *pEnumVal;
    CRange *range;
    SHARED_TFPROPERTYVAL_ARRAY *pPropVal;
    HRESULT hr;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (pRange == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = E_FAIL;

    if ((pPropVal = SAA_New(_cCicGUIDATOMs + _cAppGUIDs)) == NULL)
        goto Exit;

    // get an array of app values
    if (FillAppValueArray(_pic->_GetTSI(), range, pPropVal->rgAttrVals, _cAppGUIDs, _prgAppGUIDs) != S_OK)
        goto Exit;

    // get an array of cic values
    FillCicValueArray(_pic, range, pPropVal->rgAttrVals + _cAppGUIDs, _cCicGUIDATOMs, _prgCicGUIDATOMs);

    // stick them in an enum
    if ((pEnumVal = new CEnumPropertyValue(pPropVal)) == NULL)
        goto Exit;

    pvarValue->vt = VT_UNKNOWN;
    pvarValue->punkVal = pEnumVal;

    hr = S_OK;

Exit:
    if (pPropVal != NULL)
    {
        SAA_Release(pPropVal);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
// perf: identical to CAppProperty::GetContext....move to base class?
//----------------------------------------------------------------------------

STDAPI CUberProperty::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    (*ppContext)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// TrackProperties
//
//----------------------------------------------------------------------------

STDAPI CInputContext::TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX)
{
    CUberProperty *pup;

    if (ppPropX == NULL)
        return E_INVALIDARG;

    *ppPropX = NULL;

    if (pguidProp == NULL && cProp > 0)
        return E_INVALIDARG;

    if (pguidAppProp == NULL && cAppProp > 0)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if ((pup = new CUberProperty(this)) == NULL)
        return E_OUTOFMEMORY;

    if (!pup->_Init(cProp, pguidProp, cAppProp, pguidAppProp))
    {
        pup->Release();
        return E_OUTOFMEMORY;
    }

    *ppPropX = pup;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rangebk.h ===
//
// perange.h
//

#ifndef PERANGE_H
#define PERANGE_H

#include "private.h"
#include "ptrary.h"

class CInputContext;
class CRange;
class CRangeBackup;
class CProperty;

typedef struct tag_PERSISTPROPERTYRANGE
{
  ULONG achStart;
  ULONG achEnd;
  ITfPropertyStore *_pPropStore;
} PERSISTPROPERTYRANGE;

class CRangeBackupProperty
{
public:
    CRangeBackupProperty(CRangeBackup *ppr, CProperty *pProp);
    ~CRangeBackupProperty();

    BOOL Init(TfEditCookie ec);
    BOOL Restore(TfEditCookie ec);

private:
    BOOL _StoreOneRange(TfEditCookie ec, CRange *pCRange);
    int _GetOffset(TfEditCookie ec, IAnchor *pa);
    CRangeBackup *_ppr;
    CProperty *_pProp;

    CStructArray<PERSISTPROPERTYRANGE> _rgPropRanges;
};

class CRangeBackup : public ITfRangeBackup,
                     public CComObjectRootImmx
{
public:
    CRangeBackup(CInputContext *pic);
    ~CRangeBackup();

    BEGIN_COM_MAP_IMMX(CRangeBackup)
        COM_INTERFACE_ENTRY(ITfRangeBackup)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    STDMETHODIMP Restore(TfEditCookie ec, ITfRange *pRange);

    void Clear();

    HRESULT Init(TfEditCookie ec, CRange *pRange);

private:
    friend CRangeBackupProperty;

    CPtrArray<CRangeBackupProperty> _rgProp;

    // temp text buffer.
    WCHAR *_psz;
    ULONG _cch;

    CInputContext *_pic;
    CRange *_pRange; // perf: we don't need this really

    DBG_ID_DECLARE;
};

#endif // PERANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\range.h ===
//
// range.h
//

#ifndef RANGE_H
#define RANGE_H

#include "private.h"
#include "anchor.h"
#include "sink.h"
#include "ic.h"

#define IGNORE_LAST_LOCKRELEASED    0xffffffff

class CInputContext;
class CEnumOwnedRanges;

extern const IID IID_PRIV_CRANGE;

inline TfGravity DCGToIMG(TsGravity dcg) { return dcg == TS_GR_FORWARD ? TF_GRAVITY_FORWARD : TF_GRAVITY_BACKWARD; }

typedef enum { RINIT_DEF_GRAVITY, RINIT_GRAVITY, RINIT_NO_GRAVITY } RInit;

class CRange : public ITfRangeACP,
               public ITfRangeAnchor,
               public ITfSource
{
public:
// work around for new #define in mem.h
#undef new
    DECLARE_CACHED_NEW;
// retore mem.h trick
#ifdef DEBUG
#define new new(TEXT(__FILE__), __LINE__)
#endif // DEBUG

    CRange()
    {
        Dbg_MemSetThisNameIDCounter(TEXT("CRange"), PERF_RANGE_COUNTER);
        _cRef = 1;
    }
    ~CRange();

    // NB: caller must be certain that paStart <= paEnd before calling _InitWithDefaultGravity!
    BOOL _InitWithDefaultGravity(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd)
    {
        return _Init(pic, ao, paStart, paEnd, RINIT_DEF_GRAVITY);
    }
    BOOL _InitWithAnchorGravity(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd)
    {
        return _Init(pic, ao, paStart, paEnd, RINIT_GRAVITY);
    }

    static void _InitClass();
    static void _UninitClass();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfRange
    STDMETHODIMP GetText(TfEditCookie ec, DWORD dwFlags, WCHAR *pchText, ULONG cchMax, ULONG *pcch);
    STDMETHODIMP SetText(TfEditCookie ec, DWORD dwFlags, const WCHAR *pchText, LONG cch);
    STDMETHODIMP GetFormattedText(TfEditCookie ec, IDataObject **ppDataObject);
    STDMETHODIMP GetEmbedded(TfEditCookie ec, REFGUID rguidService, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP InsertEmbedded(TfEditCookie ec, DWORD dwFlags, IDataObject *pDataObject);
    STDMETHODIMP ShiftStart(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt);
    STDMETHODIMP ShiftEnd(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt);
    STDMETHODIMP ShiftStartToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos);
    STDMETHODIMP ShiftEndToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos);
    STDMETHODIMP ShiftStartRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion);
    STDMETHODIMP ShiftEndRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion);
    STDMETHODIMP IsEmpty(TfEditCookie ec, BOOL *pfEmpty);
    STDMETHODIMP Collapse(TfEditCookie ec, TfAnchor aPos);
    STDMETHODIMP IsEqualStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual);
    STDMETHODIMP IsEqualEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual);
    STDMETHODIMP CompareStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult);
    STDMETHODIMP CompareEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult);
    STDMETHODIMP AdjustForInsert(TfEditCookie ec, ULONG cchInsert, BOOL *pfInsertOk);
    STDMETHODIMP GetGravity(TfGravity *pgStart, TfGravity *pgEnd);
    STDMETHODIMP SetGravity(TfEditCookie ec, TfGravity gStart, TfGravity gEnd);
    STDMETHODIMP Clone(ITfRange **ppClone);
    STDMETHODIMP GetContext(ITfContext **ppContext);

    // ITfRangeACP
    STDMETHODIMP GetExtent(LONG *pacpAnchor, LONG *pcch);
    STDMETHODIMP SetExtent(LONG acpAnchor, LONG cch);

    // ITfRangeAnchor
    STDMETHODIMP GetExtent(IAnchor **ppaStart, IAnchor **ppaEnd);
    STDMETHODIMP SetExtent(IAnchor *paStart, IAnchor *paEnd);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    CRange *_Clone()
    { 
        CRange *rangeClone;

        if ((rangeClone = new CRange) == NULL)
            return NULL;

        if (!rangeClone->_Init(_pic, COPY_ANCHORS, _paStart, _paEnd, RINIT_NO_GRAVITY))
        {
            rangeClone->Release();
            return NULL;
        }

        rangeClone->_dwLastLockReleaseID = _dwLastLockReleaseID;

        return rangeClone;
    }

    CRange *_GetNextOnChangeRangeInIcsub() { return _nextOnChangeRangeInIcsub; }

    IAnchor *_GetStart() { return _paStart; }
    IAnchor *_GetEnd() { return _paEnd; }

    CInputContext *_GetContext() { return _pic; }

    CStructArray<GENERICSINK> *_GetChangeSinks() { return _prgChangeSinks; }

    void _QuickCheckCrossedAnchors()
    {
        if (_dwLastLockReleaseID != IGNORE_LAST_LOCKRELEASED)
        {
            _CheckCrossedAnchors();
        }
    }

#if 0
    HRESULT _SnapToRegion(DWORD dwFlags);
#endif

    BOOL _IsDirty() { return _fDirty; }
    void _SetDirty() { _fDirty = TRUE; }
    void _ClearDirty() { _fDirty = FALSE; }

private:
    BOOL _Init(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd, RInit rinit);

    HRESULT _SetGravity(TfGravity gStart, TfGravity gEnd, BOOL fCheckCrossedAnchors);

    void _CheckCrossedAnchors();

    HRESULT _PreEditCompositionCheck(TfEditCookie ec, CComposition **ppComposition, BOOL *pfNewComposition);

    HRESULT _ShiftConditional(IAnchor *paStart, IAnchor *paLimit, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt);

    HRESULT _IsEqualX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual);
    HRESULT _CompareX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, LONG *plResult);

    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags);

    void _InitLastLockReleaseId(TsGravity gStart, TsGravity gEnd)
    {
        if (gStart == TF_GRAVITY_FORWARD && gEnd == TF_GRAVITY_BACKWARD)
        {
            // this range has the potential for crossed anchors, need to monitor
            // since the range may have just been cloned from a crossed range, need to
            // init _dwLastLockReleaseID with something that will guarantee a check
            _dwLastLockReleaseID = _pic->_GetLastLockReleaseID() - 1;
        }
        else
        {
            // don't bother checking for crossed anchors, since it can't happen
            _dwLastLockReleaseID = IGNORE_LAST_LOCKRELEASED;
        }
    }

    CStructArray<GENERICSINK> *_prgChangeSinks; // ITfRangeChangeSink sinks

    IAnchor *_paStart;
    IAnchor *_paEnd;

    CInputContext *_pic;
    CRange *_nextOnChangeRangeInIcsub; // perf: could use an array in the pic to save space

    DWORD _dwLastLockReleaseID;

    BOOL _fDirty : 1;

    long _cRef;

    DBG_ID_DECLARE;
};


// this call doesn't AddRef the object!
inline CRange *GetCRange_NA(IUnknown *range)
{
    CRange *prange;

    range->QueryInterface(IID_PRIV_CRANGE, (void **)&prange);

    return prange;
}

// returns TRUE if range is in the same context
inline BOOL VerifySameContext(CRange *pRange1, CRange *pRange2)
{
    Assert((pRange1->_GetContext() == pRange2->_GetContext()));
    return (pRange1->_GetContext() == pRange2->_GetContext());
}
// returns TRUE if range is in the same context
inline BOOL VerifySameContext(CInputContext *pContext, CRange *pRange)
{
    Assert((pRange->_GetContext() == pContext));
    return (pRange->_GetContext() == pContext);
}
// returns TRUE if range is in the same context
inline BOOL VerifySameContext(CInputContext *pContext, ITfRange *pTargetRange)
{
    CRange *pRange = GetCRange_NA(pTargetRange);

    Assert((pRange != NULL) && (pRange->_GetContext() == pContext));
    return (pRange != NULL) && (pRange->_GetContext() == pContext);
}


#endif // RANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\resource.h ===
//+---------------------------------------------------------------------------
//
//  File:       resource.h
//
//----------------------------------------------------------------------------

#ifndef RESOURCE_H
#define RESOURCE_H

#define DEVICE_TYPE_KBD  0
#define DEVICE_TYPE_PEN  1
#define DEVICE_TYPE_MIC  2
#define DEVICE_TYPE_NUM  3

//---------------------------------------------------------------------------
//  Strings
//---------------------------------------------------------------------------
#define IDS_UNKNOWN                 200
#define IDS_IMECLOSE                201
#define IDS_IMEOPEN                 202
#define IDS_SOFTKBDOFF              203
#define IDS_SOFTKBDON               204
#define IDS_IMESHOWSTATUS           205
#define IDS_CONFIGUREIME            206
#define IDS_IMEHELP                 207

#define IDS_NUI_DEVICE_NAME_START   208
#define IDS_NUI_DEVICE_NAME_KBD     208
#define IDS_NUI_DEVICE_NAME_PEN     209
#define IDS_NUI_DEVICE_NAME_MIC     210
#define IDS_NUI_DEVICE_TIP_START    211
#define IDS_NUI_DEVICE_TIP_KBD      211
#define IDS_NUI_DEVICE_TIP_PEN      212
#define IDS_NUI_DEVICE_TIP_MIC      213

#define IDS_NUI_CORRECTION_TOOLTIP  220
#define IDS_NUI_CORRECTION_TEXT     221
#define IDS_NUI_IME_TEXT            222
#define IDS_NUI_IME_TOOLTIP         223
#define IDS_NUI_LANGUAGE_TEXT       224
#define IDS_NUI_LANGUAGE_TOOLTIP    225
#define IDS_NUI_HELP                226

#define IDS_LANGBARHELP             228
#define IDS_SHOWLANGBAR             229
#define IDS_NOTIFICATIONICONS       230
#define IDS_SHOWINPUTCPL            231

#define IDS_CPL_WIN_KBDCPLNAME      240
#define IDS_CPL_WIN9X_KBDCPLTITLE   241
#define IDS_CPL_WINNT_INTLCPLNAME   242
#define IDS_CPL_WINNT_KBDCPLTITLE   243
#define IDS_CPL_INPUT_DISABLED      244
#define IDS_CPL_INPUT_GROUPBOX      245
#define IDS_CPL_INPUT_CHAANGE_BTN   246

#define IDS_PROP_ATTRIBUTE          250

#define IDS_TFCAT_TIP_KEYBOARD      251
#define IDS_TFCAT_TIP_SPEECH        252
#define IDS_TFCAT_TIP_HANDWRITING   253
#define IDS_TFCAT_TIP_REFERENCE     254
#define IDS_TFCAT_TIP_PROOFING      255
#define IDS_TFCAT_TIP_SMARTTAG      256
//---------------------------------------------------------------------------
// Icon
//---------------------------------------------------------------------------
#define ID_ICON_RECONVERSION        300

#define ID_ICON_IMEOPEN             350
#define ID_ICON_IMECLOSE            351
#define ID_ICON_IMEDISAB            352
#define ID_ICON_IMEE_H              353
#define ID_ICON_IMEE_F              354
#define ID_ICON_IMEH_H              355
#define ID_ICON_IMEH_F              356

#define ID_ICON_DEVICE_START        357
#define ID_ICON_DEVICE_KBD          357
#define ID_ICON_DEVICE_PEN          358
#define ID_ICON_DEVICE_MIC          359

#define ID_ICON_TEXT_SERVICE        360

#define ID_ICON_HELP                400

//---------------------------------------------------------------------------
//  Menu
//---------------------------------------------------------------------------

#define IDM_IME_OPENCLOSE           5000
#define IDM_IME_SOFTKBDONOFF        5001
#define IDM_IME_SHOWSTATUS          5002
#define IDM_RMENU_WHATSTHIS         5003
#define IDM_RMENU_HELPFINDER        5004
#define IDM_RMENU_PROPERTIES        5005
#define IDM_RMENU_IMEHELP           5006
#define IDM_SHOWLANGBAR             5007
#define IDM_NOTIFICATIONICONS       5008
#define IDM_NONOTIFICATIONICONS     5009
#define IDM_SHOWINPUTCPL            5010


#define IDM_LANG_MENU_START         6000
#define IDM_ASM_MENU_START          6500
#define IDM_CUSTOM_MENU_START       7000


#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\range.cpp ===
//
// range.cpp
//

#include "private.h"
#include "range.h"
#include "ic.h"
#include "immxutil.h"
#include "rprop.h"
#include "tim.h"
#include "anchoref.h"
#include "compose.h"

/* b68832f0-34b9-11d3-a745-0050040ab407 */
const IID IID_PRIV_CRANGE = { 0xb68832f0,0x34b9, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };

DBG_ID_INSTANCE(CRange);

MEMCACHE *CRange::_s_pMemCache = NULL;

//+---------------------------------------------------------------------------
//
// _InitClass
//
//----------------------------------------------------------------------------

/* static */
void CRange::_InitClass()
{
    _s_pMemCache = MemCache_New(32);
}

//+---------------------------------------------------------------------------
//
// _UninitClass
//
//----------------------------------------------------------------------------

/* static */
void CRange::_UninitClass()
{
    if (_s_pMemCache == NULL)
        return;

    MemCache_Delete(_s_pMemCache);
    _s_pMemCache = NULL;
}

//+---------------------------------------------------------------------------
//
// _Init
//
// NB: If fSetDefaultGravity == TRUE, make certain paStart <= paEnd, or you
// will break something!
//----------------------------------------------------------------------------

BOOL CRange::_Init(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd, RInit rinit)
{
    TsGravity gStart;
    TsGravity gEnd;

    // can't check the anchors because we may be cloned from a range with crossed anchors
    // can't do anything about crossed anchors until we know we have a doc lock
    //Assert(CompareAnchors(paStart, paEnd) <= 0);

    Assert(_paStart == NULL);
    Assert(_paEnd == NULL);
    Assert(_fDirty == FALSE);
    Assert(_nextOnChangeRangeInIcsub == NULL);

    if (ao == OWN_ANCHORS)
    {
        _paStart = paStart;
        _paEnd = paEnd;
    }
    else
    {
        Assert(ao == COPY_ANCHORS);
        if (paStart->Clone(&_paStart) != S_OK || _paStart == NULL)
            goto ErrorExit;
        if (paEnd->Clone(&_paEnd) != S_OK || _paEnd == NULL)
            goto ErrorExit;
    }

    _pic = pic;

    switch (rinit)
    {
        case RINIT_DEF_GRAVITY:
            Assert(CompareAnchors(paStart, paEnd) <= 0); // Issue: this is only a safe assert for acp implementations

            if (_SetGravity(TF_GRAVITY_BACKWARD, TF_GRAVITY_FORWARD, FALSE) != S_OK)
                goto ErrorExit;
            break;

        case RINIT_GRAVITY:
            if (_paStart->GetGravity(&gStart) != S_OK)
                goto ErrorExit;
            if (_paEnd->GetGravity(&gEnd) != S_OK)
                goto ErrorExit;

            _InitLastLockReleaseId(gStart, gEnd);
            break;

        default:
            // caller must init _dwLastLockReleaseID!
            break;
    }

    _pic->AddRef();

    return TRUE;

ErrorExit:
    Assert(0);
    if (ao == COPY_ANCHORS)
    {
        SafeReleaseClear(_paStart);
        SafeReleaseClear(_paEnd);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CRange::~CRange()
{
    _paStart->Release();
    _paEnd->Release();

    _pic->Release();

    Assert(_prgChangeSinks == NULL || _prgChangeSinks->Count() == 0); // all ITfRangeChangeSink's should have been unadvised
    delete _prgChangeSinks;
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CRange::QueryInterface(REFIID riid, void **ppvObj)
{
    CAnchorRef *par;

    if (&riid == &IID_PRIV_CRANGE ||
        IsEqualIID(riid, IID_PRIV_CRANGE))
    {
        *ppvObj = SAFECAST(this, CRange *);
        return S_OK; // No AddRef for IID_PRIV_CRANGE!  this is a private IID....
    }

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_ITfRange) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, ITfRangeAnchor *);
    }
    else if (IsEqualIID(riid, IID_ITfRangeACP))
    {
        if ((par = GetCAnchorRef_NA(_paStart)) != NULL) // just a test to see if we're wrapping
        {
            *ppvObj = SAFECAST(this, ITfRangeACP *);
        }
    }
    else if (IsEqualIID(riid, IID_ITfRangeAnchor))
    {
        if ((par = GetCAnchorRef_NA(_paStart)) == NULL) // just a test to see if we're wrapping
        {
            *ppvObj = SAFECAST(this, ITfRangeAnchor *);
        }
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CRange::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CRange::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// _IsValidEditCookie
//
//----------------------------------------------------------------------------

BOOL CRange::_IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
{
    // any time someone is about to access the doc, we also need
    // to verify the last app edit didn't cross this range's anchors
    _QuickCheckCrossedAnchors();

    return _pic->_IsValidEditCookie(ec, dwFlags);
}

//+---------------------------------------------------------------------------
//
// _CheckCrossedAnchors
//
//----------------------------------------------------------------------------

void CRange::_CheckCrossedAnchors()
{
    DWORD dw;

    Assert(_dwLastLockReleaseID != IGNORE_LAST_LOCKRELEASED); // use _QuickCheckCrossedAnchors first!

#ifdef DEBUG
    // we shold only make is this far if this range has TF_GRAVITY_FORWARD,
    // TF_GRAVITY_BACKWARD otherwise we should never be able to get crossed
    // anchors.
    TsGravity gStart;
    TsGravity gEnd;

    _paStart->GetGravity(&gStart);
    _paEnd->GetGravity(&gEnd);

    Assert(gStart == TS_GR_FORWARD && gEnd == TS_GR_BACKWARD);
#endif // DEBUG

    dw = _pic->_GetLastLockReleaseID();
    Assert(dw != IGNORE_LAST_LOCKRELEASED);

    if (_dwLastLockReleaseID == dw)
        return;

    _dwLastLockReleaseID = dw;

    if (CompareAnchors(_paStart, _paEnd) > 0)
    {
        // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
        _paStart->ShiftTo(_paEnd);
    }
}


//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CRange::GetText(TfEditCookie ec, DWORD dwFlags, WCHAR *pch, ULONG cchMax, ULONG *pcch)
{
    HRESULT hr;
    BOOL fMove;

    Perf_IncCounter(PERF_RGETTEXT_COUNT);

    if (pcch == NULL)
        return E_INVALIDARG;

    *pcch = 0;

    if (dwFlags & ~(TF_TF_MOVESTART | TF_TF_IGNOREEND))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    fMove = (dwFlags & TF_TF_MOVESTART);

    hr = _pic->_ptsi->GetText(0, _paStart, (dwFlags & TF_TF_IGNOREEND) ? NULL : _paEnd, pch, cchMax, pcch, fMove);

    if (hr != S_OK)
    {
        hr = E_FAIL;
    }

    // don't let the start advance past the end
    if (fMove && CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paEnd->ShiftTo(_paStart);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetText
//
//----------------------------------------------------------------------------

STDAPI CRange::SetText(TfEditCookie ec, DWORD dwFlags, const WCHAR *pchText, LONG cch)
{
    CComposition *pComposition;
    HRESULT hr;
    BOOL fNewComposition;

    Perf_IncCounter(PERF_RSETTEXT_COUNT);

    if (pchText == NULL && cch != 0)
        return E_INVALIDARG;

    if ((dwFlags & ~TF_ST_CORRECTION) != 0)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _PreEditCompositionCheck(ec, &pComposition, &fNewComposition);

    if (hr != S_OK)
        return hr;

    if (cch < 0)
    {
        cch = wcslen(pchText);
    }

#ifdef DEBUG
    for (LONG i=0; i<cch; i++)
    {        
        Assert(pchText[i] != TF_CHAR_EMBEDDED); // illegal to insert TF_CHAR_EMBEDDED!
        Assert(pchText[i] != TS_CHAR_REGION); // illegal to insert TS_CHAR_REGION!
    }
#endif

    //
    // set the text
    //

    hr = _pic->_ptsi->SetText(dwFlags, _paStart, _paEnd, pchText ? pchText : L"", cch);

    if (hr == S_OK)
    {
        _pic->_DoPostTextEditNotifications(pComposition, ec, dwFlags, cch, NULL, NULL, this);
    }

    // terminate the default composition, if there is one
    if (fNewComposition)
    {
        Assert(pComposition != NULL);
        pComposition->EndComposition(ec);
        pComposition->Release(); // don't need Release if !fNewComposition
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetEmbedded
//
//----------------------------------------------------------------------------

STDAPI CRange::GetEmbedded(TfEditCookie ec, REFGUID rguidService, REFIID riid, IUnknown **ppunk)
{
    if (ppunk == NULL)
        return E_INVALIDARG;

    *ppunk = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return _pic->_ptsi->GetEmbedded(0, _paStart, rguidService, riid, ppunk);
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CRange::InsertEmbedded(TfEditCookie ec, DWORD dwFlags, IDataObject *pDataObject)
{
    CComposition *pComposition;
    BOOL fNewComposition;
    HRESULT hr;

    if ((dwFlags & ~TF_IE_CORRECTION) != 0)
        return E_INVALIDARG;

    if (pDataObject == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _PreEditCompositionCheck(ec, &pComposition, &fNewComposition);

    if (hr != S_OK)
        return hr;

    hr = _pic->_ptsi->InsertEmbedded(dwFlags, _paStart, _paEnd, pDataObject);

    if (hr == S_OK)
    {
        _pic->_DoPostTextEditNotifications(pComposition, ec, dwFlags, 1, NULL, NULL, this);
    }

    // terminate the default composition, if there is one
    if (fNewComposition)
    {
        Assert(pComposition != NULL);
        pComposition->EndComposition(ec);
        pComposition->Release(); // don't need Release if !fNewComposition
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetFormattedText
//
//----------------------------------------------------------------------------

STDAPI CRange::GetFormattedText(TfEditCookie ec, IDataObject **ppDataObject)
{
    if (ppDataObject == NULL)
        return E_INVALIDARG;

    *ppDataObject = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return _pic->_ptsi->GetFormattedText(_paStart, _paEnd, ppDataObject);
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CRange::Clone(ITfRange **ppClone)
{
    if (ppClone == NULL)
        return E_INVALIDARG;

    return (*ppClone = (ITfRangeAnchor *)_Clone()) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CRange::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    if (*ppContext)
    {
       (*ppContext)->AddRef();
       return S_OK;
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// ShiftStart
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftStart(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt)
{
    CRange *pRangeP;
    IAnchor *paLimit;
    IAnchor *paShift;
    HRESULT hr;

    Perf_IncCounter(PERF_SHIFTSTART_COUNT);

    if (pcch == NULL)
        return E_INVALIDARG;

    *pcch = 0;

    if (pHalt != NULL && (pHalt->dwFlags & ~TF_HF_OBJECT))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    paLimit = NULL;

    if (pHalt != NULL && pHalt->pHaltRange != NULL)
    {
        if ((pRangeP = GetCRange_NA(pHalt->pHaltRange)) == NULL)
            return E_FAIL;

        paLimit = (pHalt->aHaltPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd();
    }

    if (pHalt == NULL || pHalt->dwFlags == 0)
    {
        // caller doesn't care about special chars, so we can do it the easy way
        hr = _paStart->Shift(0, cchReq, pcch, paLimit);
    }
    else
    {
        // caller wants us to halt for special chars, need to read text
        if (_paStart->Clone(&paShift) != S_OK)
            return E_FAIL;

        hr = _ShiftConditional(paShift, paLimit, cchReq, pcch, pHalt);

        if (hr == S_OK)
        {
            hr = _paStart->ShiftTo(paShift);
        }
        paShift->Release();
    }

    if (hr != S_OK)
        return E_FAIL;

    // don't let the start advance past the end
    if (cchReq > 0 && CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paEnd->ShiftTo(_paStart);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShiftEnd
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftEnd(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt)
{
    CRange *pRangeP;
    IAnchor *paLimit;
    IAnchor *paShift;
    HRESULT hr;

    Perf_IncCounter(PERF_SHIFTEND_COUNT);

    if (pcch == NULL)
        return E_INVALIDARG;

    *pcch = 0;

    if (pHalt != NULL && (pHalt->dwFlags & ~TF_HF_OBJECT))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    paLimit = NULL;

    if (pHalt != NULL && pHalt->pHaltRange != NULL)
    {
        if ((pRangeP = GetCRange_NA(pHalt->pHaltRange)) == NULL)
            return E_FAIL;

        paLimit = (pHalt->aHaltPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd();
    }

    if (pHalt == NULL || pHalt->dwFlags == 0)
    {
        // caller doesn't care about special chars, so we can do it the easy way
        hr = _paEnd->Shift(0, cchReq, pcch, paLimit);
    }
    else
    {
        // caller wants us to halt for special chars, need to read text
        if (_paEnd->Clone(&paShift) != S_OK)
            return E_FAIL;

        hr = _ShiftConditional(paShift, paLimit, cchReq, pcch, pHalt);

        if (hr == S_OK)
        {
            hr = _paEnd->ShiftTo(paShift);
        }
        paShift->Release();
    }

    if (hr != S_OK)
        return E_FAIL;

    // don't let the start advance past the end
    if (cchReq < 0 && CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paStart->ShiftTo(_paEnd);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _ShiftConditional
//
//----------------------------------------------------------------------------

HRESULT CRange::_ShiftConditional(IAnchor *paStart, IAnchor *paLimit, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt)
{
    HRESULT hr;
    ITextStoreAnchor *ptsi;
    LONG cchRead;
    LONG cch;
    LONG i;
    LONG iStop;
    LONG delta;
    BOOL fHaltObj;
    WCHAR ach[64];

    Assert(*pcch == 0);
    Assert(pHalt && pHalt->dwFlags);

    hr = S_OK;
    ptsi = _pic->_ptsi;
    fHaltObj = pHalt->dwFlags & TF_HF_OBJECT;
    delta = (cchReq > 0) ? +1 : -1;

    while (cchReq != 0)
    {
        if (cchReq > 0)
        {
            cch = (LONG)min(cchReq, ARRAYSIZE(ach));
        }
        else
        {
            // going backwards is tricky!
            cch = max(cchReq, -(LONG)ARRAYSIZE(ach));
            hr = paStart->Shift(0, cch, &cchRead, paLimit);

            if (hr != S_OK)
                break;

            if (cchRead == 0)
                break; // at top of doc or hit paLimit

            cch = -cchRead; // must read text forward
        }

        Perf_IncCounter(PERF_SHIFTCOND_GETTEXT);

        hr = ptsi->GetText(0, paStart, paLimit, ach, cch, (ULONG *)&cchRead, (cchReq > 0));

        if (hr != S_OK)
            break;

        if (cchRead == 0)
            break; // end of doc

        if (fHaltObj)
        {
            // scan for special chars
            if (cchReq > 0)
            {
                // scan left-to-right
                i = 0;
                iStop = cchRead;
            }
            else
            {
                // scan right-to-left
                i = cchRead - 1;
                iStop = -1;
            }

            for (; i != iStop; i += delta)
            {
                if (ach[i] == TS_CHAR_EMBEDDED)
                {
                    if (cchReq > 0)
                    {
                        hr = paStart->Shift(0, i - cchRead, &cch, NULL);
                        cchReq = cchRead = i;
                    }
                    else
                    {
                        hr = paStart->Shift(0, i + 1, &cch, NULL);
                        cchRead -= i + 1;
                        cchReq = -cchRead;
                    }
                    goto ExitLoop;
                }
            }
        }

ExitLoop:
        if (cchReq < 0)
        {
            cchRead = -cchRead;
        }
        cchReq -= cchRead;
        *pcch += cchRead;
    }

    if (hr != S_OK)
    {
        *pcch = 0;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftStartToRange
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftStartToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos)
{
    CRange *pRangeP;
    HRESULT hr;

    if (pRange == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((pRangeP = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pRangeP))
        return E_INVALIDARG;

    pRangeP->_QuickCheckCrossedAnchors();

    hr = _paStart->ShiftTo((aPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd());

    // don't let the start advance past the end
    if (CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paEnd->ShiftTo(_paStart);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftEndToRange
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftEndToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos)
{
    CRange *pRangeP;
    HRESULT hr;

    if (pRange == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((pRangeP = GetCRange_NA(pRange)) == NULL)
        return E_FAIL;

    if (!VerifySameContext(this, pRangeP))
        return E_INVALIDARG;

    pRangeP->_QuickCheckCrossedAnchors();

    hr = _paEnd->ShiftTo((aPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd());

    // don't let the end advance past the start
    if (CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paStart->ShiftTo(_paEnd);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftStartRegion
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftStartRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion)
{
    HRESULT hr;

    if (pfNoRegion == NULL)
        return E_INVALIDARG;

    *pfNoRegion = TRUE;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _paStart->ShiftRegion(0, (TsShiftDir)dir, pfNoRegion);

    if (hr == S_OK && dir == TF_SD_FORWARD && !*pfNoRegion)
    {
        // don't let the start advance past the end
        if (CompareAnchors(_paStart, _paEnd) > 0)
        {
            _paEnd->ShiftTo(_paStart);
        }
    }
    else if (hr == E_NOTIMPL)
    {
        // app doesn't support regions, so we can still succeed
        // it's just that there's no region to shift over
        *pfNoRegion = TRUE; // be paranoid, the app could be wacky
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftEndRegion
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftEndRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion)
{
    HRESULT hr;

    if (pfNoRegion == NULL)
        return E_INVALIDARG;

    *pfNoRegion = TRUE;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _paEnd->ShiftRegion(0, (TsShiftDir)dir, pfNoRegion);

    if (hr == S_OK && dir == TF_SD_BACKWARD && !*pfNoRegion)
    {
        // don't let the end advance past the start
        if (CompareAnchors(_paStart, _paEnd) > 0)
        {
            _paStart->ShiftTo(_paEnd);
        }
    }
    else if (hr == E_NOTIMPL)
    {
        // app doesn't support regions, so we can still succeed
        // it's just that there's no region to shift over
        *pfNoRegion = TRUE; // be paranoid, the app could be wacky
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _SnapToRegion
//
//----------------------------------------------------------------------------

#if 0

HRESULT CRange::_SnapToRegion(DWORD dwFlags)
{
    ITfRange *range;
    TF_HALTCOND hc;
    LONG cch;
    HRESULT hr;

    if (Clone(&range) != S_OK)
        return E_OUTOFMEMORY;

    hc.pHaltRange = (ITfRangeAnchor *)this;
    hc.dwFlags = 0;

    if (dwFlags & TF_GS_SNAPREGION_START)
    {
        if ((hr = range->Collapse(BACKDOOR_EDIT_COOKIE, TF_ANCHOR_START)) != S_OK)
            goto Exit;

        hc.aHaltPos = TF_ANCHOR_END;

        do
        {
            if ((hr = range->ShiftEnd(BACKDOOR_EDIT_COOKIE, LONG_MAX, &cch, &hc)) != S_OK)
                goto Exit;
        }
        while (cch >= LONG_MAX); // just in case this is a _really_ huge doc

        hr = ShiftEndToRange(BACKDOOR_EDIT_COOKIE, range, TF_ANCHOR_END);
    }
    else
    {
        Assert(dwFlags & TF_GS_SNAPREGION_END);

        if ((hr = range->Collapse(BACKDOOR_EDIT_COOKIE, TF_ANCHOR_END)) != S_OK)
            goto Exit;

        hc.aHaltPos = TF_ANCHOR_START;

        do
        {
            if ((hr = range->ShiftStart(BACKDOOR_EDIT_COOKIE, LONG_MIN, &cch, &hc)) != S_OK)
                goto Exit;
        }
        while (cch <= LONG_MIN); // just in case this is a _really_ huge doc

        hr = ShiftStartToRange(BACKDOOR_EDIT_COOKIE, range, TF_ANCHOR_START);
    }

Exit:
    if (hr != S_OK)
    {
        hr = E_FAIL;
    }

    range->Release();

    return hr;
}

#endif // 0

//+---------------------------------------------------------------------------
//
// IsEmpty
//
//----------------------------------------------------------------------------

STDAPI CRange::IsEmpty(TfEditCookie ec, BOOL *pfEmpty)
{
    return IsEqualStart(ec, (ITfRangeAnchor *)this, TF_ANCHOR_END, pfEmpty);
}

//+---------------------------------------------------------------------------
//
// Collapse
//
//----------------------------------------------------------------------------

STDAPI CRange::Collapse(TfEditCookie ec, TfAnchor aPos)
{
    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return (aPos == TF_ANCHOR_START) ? _paEnd->ShiftTo(_paStart) : _paStart->ShiftTo(_paEnd);
}

//+---------------------------------------------------------------------------
//
// IsEqualStart
//
//----------------------------------------------------------------------------

STDAPI CRange::IsEqualStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual)
{
    return _IsEqualX(ec, TF_ANCHOR_START, pWith, aPos, pfEqual);
}

//+---------------------------------------------------------------------------
//
// IsEqualEnd
//
//----------------------------------------------------------------------------

STDAPI CRange::IsEqualEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual)
{
    return _IsEqualX(ec, TF_ANCHOR_END, pWith, aPos, pfEqual);
}

//+---------------------------------------------------------------------------
//
// _IsEqualX
//
//----------------------------------------------------------------------------

HRESULT CRange::_IsEqualX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual)
{
    LONG lComp;
    HRESULT hr;

    if (pfEqual == NULL)
        return E_INVALIDARG;

    *pfEqual = FALSE;

    // perf: we could check TS_SS_NOHIDDENTEXT for better perf
    hr = _CompareX(ec, aPosThisRange, pWith, aPos, &lComp);

    if (hr != S_OK)
        return hr;

    *pfEqual = (lComp == 0);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CompareStart
//
//----------------------------------------------------------------------------

STDAPI CRange::CompareStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult)
{
    return _CompareX(ec, TF_ANCHOR_START, pWith, aPos, plResult);
}

//+---------------------------------------------------------------------------
//
// CompareEnd
//
//----------------------------------------------------------------------------

STDAPI CRange::CompareEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult)
{
    return _CompareX(ec, TF_ANCHOR_END, pWith, aPos, plResult);
}

//+---------------------------------------------------------------------------
//
// _CompareX
//
//----------------------------------------------------------------------------

HRESULT CRange::_CompareX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, LONG *plResult)
{
    CRange *pRangeP;
    IAnchor *paThis;
    IAnchor *paWith;
    IAnchor *paTest;
    LONG lComp;
    LONG cch;
    BOOL fEqual;
    HRESULT hr;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (pWith == NULL)
        return E_INVALIDARG;

    if ((pRangeP = GetCRange_NA(pWith)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pRangeP))
        return E_INVALIDARG;

    pRangeP->_QuickCheckCrossedAnchors();

    paWith = (aPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd();
    paThis = (aPosThisRange == TF_ANCHOR_START) ? _paStart : _paEnd;

    if (paThis->Compare(paWith, &lComp) != S_OK)
        return E_FAIL;

    if (lComp == 0) // exact match
    {
        Assert(*plResult == 0);
        return S_OK;
    }

    // we need to account for hidden text, so we actually have to do a shift
    // perf: we could check TS_SS_NOHIDDENTEXT for better perf

    if (paThis->Shift(TS_SHIFT_COUNT_ONLY, (lComp < 0) ? 1 : -1, &cch, paWith) != S_OK)
        return E_FAIL;

    if (cch == 0)
    {
        // nothing but hidden text between the two anchors?
        // one special case: we might have hit a region boundary
        if (paThis->Clone(&paTest) != S_OK || paTest == NULL)
            return E_FAIL;

        hr = E_FAIL;

        // if we're not at paWith after the shift, we must have hit a region
        if (paTest->Shift(0, (lComp < 0) ? 1 : -1, &cch, paWith) != S_OK)
            goto ReleaseTest;

        Assert(cch == 0);

        if (paTest->IsEqual(paWith, &fEqual) != S_OK)
            goto ReleaseTest;

        hr = S_OK;

ReleaseTest:
        paTest->Release();

        if (hr != S_OK)
            return E_FAIL;

        if (fEqual)
        {
            Assert(*plResult == 0);
            return S_OK;
        }
    }

    *plResult = lComp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGravity
//
//----------------------------------------------------------------------------

STDAPI CRange::AdjustForInsert(TfEditCookie ec, ULONG cchInsert, BOOL *pfInsertOk)
{
    TfGravity gStart;
    TfGravity gEnd;
    IAnchor *paStartResult;
    IAnchor *paEndResult;
    HRESULT hr;

    if (pfInsertOk == NULL)
        return E_INVALIDARG;

    *pfInsertOk = FALSE;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _pic->_ptsi->QueryInsert(_paStart, _paEnd, cchInsert, &paStartResult, &paEndResult);

    if (hr == E_NOTIMPL)
    {
        // ok, just allow the request
        goto Exit;
    }
    else if (hr != S_OK)
    {
        Assert(*pfInsertOk == FALSE);
        return E_FAIL;
    }
    else if (paStartResult == NULL || paEndResult == NULL)
    {
        Assert(paEndResult == NULL);
        // NULL out params means no insert possible
        Assert(*pfInsertOk == FALSE);
        return S_OK;
    }

    // all set, just swap anchors and make sure gravity doesn't change
    GetGravity(&gStart, &gEnd);

    _paStart->Release();
    _paEnd->Release();
    _paStart = paStartResult;
    _paEnd = paEndResult;

    _SetGravity(gStart, gEnd, TRUE);

Exit:
    *pfInsertOk = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGravity
//
//----------------------------------------------------------------------------

STDAPI CRange::GetGravity(TfGravity *pgStart, TfGravity *pgEnd)
{
    TsGravity gStart;
    TsGravity gEnd;

    if (pgStart == NULL || pgEnd == NULL)
        return E_INVALIDARG;

    _paStart->GetGravity(&gStart);
    _paEnd->GetGravity(&gEnd);
    
    *pgStart = (gStart == TS_GR_BACKWARD) ? TF_GRAVITY_BACKWARD : TF_GRAVITY_FORWARD;
    *pgEnd = (gEnd == TS_GR_BACKWARD) ? TF_GRAVITY_BACKWARD : TF_GRAVITY_FORWARD;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetGravity
//
//----------------------------------------------------------------------------

STDAPI CRange::SetGravity(TfEditCookie ec, TfGravity gStart, TfGravity gEnd)
{
    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return _SetGravity(gStart, gEnd, TRUE);
}

//+---------------------------------------------------------------------------
//
// _SetGravity
//
//----------------------------------------------------------------------------

HRESULT CRange::_SetGravity(TfGravity gStart, TfGravity gEnd, BOOL fCheckCrossedAnchors)
{
    if (fCheckCrossedAnchors)
    {
        // make sure we're not crossed in case we're switching away from inward gravity
        _QuickCheckCrossedAnchors();
    }

    if (_paStart->SetGravity((TsGravity)gStart) != S_OK)
        return E_FAIL;
    if (_paEnd->SetGravity((TsGravity)gEnd) != S_OK)
        return E_FAIL;

    _InitLastLockReleaseId((TsGravity)gStart, (TsGravity)gEnd);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CRange::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid = &IID_ITfRangeChangeSink;
    HRESULT hr;

    if (_prgChangeSinks == NULL)
    {
        // we delay allocate our sink container
        if ((_prgChangeSinks = new CStructArray<GENERICSINK>) == NULL)
            return E_OUTOFMEMORY;
    }

    hr = GenericAdviseSink(riid, punk, &rgiid, _prgChangeSinks, 1, pdwCookie);

    if (hr == S_OK && _prgChangeSinks->Count() == 1)
    {
        // add this range to the list of ranges with sinks in the icsub
        _nextOnChangeRangeInIcsub = _pic->_pOnChangeRanges;
        _pic->_pOnChangeRanges = this;

        // start tracking anchor collapses
        //_paStart->TrackCollapse(TRUE);
        //_paEnd->TrackCollapse(TRUE);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CRange::UnadviseSink(DWORD dwCookie)
{
    CRange *pRange;
    CRange **ppRange;
    HRESULT hr;

    if (_prgChangeSinks == NULL)
        return CONNECT_E_NOCONNECTION;

    hr = GenericUnadviseSink(_prgChangeSinks, 1, dwCookie);

    if (hr == S_OK && _prgChangeSinks->Count() == 0)
    {
        // remove this range from the list of ranges in its icsub
        ppRange = &_pic->_pOnChangeRanges;
        while (pRange = *ppRange)
        {
            if (pRange == this)
            {
                *ppRange = pRange->_nextOnChangeRangeInIcsub;
                break;
            }
            ppRange = &pRange->_nextOnChangeRangeInIcsub;
        }

        // stop tracking anchor collapses
        //_paStart->TrackCollapse(FALSE);
        //_paEnd->TrackCollapse(FALSE);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::GetExtent(LONG *pacpAnchor, LONG *pcch)
{
    CAnchorRef *par;
    HRESULT hr = E_FAIL;

    if (pacpAnchor == NULL || pcch == NULL)
        return E_INVALIDARG;

    *pacpAnchor = 0;
    *pcch = 0;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if ((par = GetCAnchorRef_NA(_paStart)) != NULL)
    {
        // we have a wrapped ACP impl, this is easy

        *pacpAnchor = par->_GetACP();

        if ((par = GetCAnchorRef_NA(_paEnd)) == NULL)
            goto ErrorExit;

        *pcch = par->_GetACP() - *pacpAnchor;

        hr = S_OK;
    }
    else
    {
        Assert(0); // who's doing this?
        // we fail if someone tries to do GetExtentACP on a
        // non-acp text store.  Users of this method should
        // be aware of whether or not they are using an acp
        // store.
    }

    return hr;

ErrorExit:
    *pacpAnchor = 0;
    *pcch = 0;
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::GetExtent(IAnchor **ppaStart, IAnchor **ppaEnd)
{
    if (ppaStart == NULL || ppaEnd == NULL)
        return E_INVALIDARG;

    *ppaStart = NULL;
    *ppaEnd = NULL;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if (_paStart->Clone(ppaStart) != S_OK)
        return E_FAIL;

    if (_paEnd->Clone(ppaEnd) != S_OK)
    {
        SafeReleaseClear(*ppaStart);
        return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::SetExtent(LONG acpAnchor, LONG cch)
{
    CAnchorRef *par;
    IAnchor *paStart;
    IAnchor *paEnd;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if (acpAnchor < 0 || cch < 0)
        return E_INVALIDARG;

    paStart = paEnd = NULL;

    if ((par = GetCAnchorRef_NA(_paStart)) != NULL)
    {
        // we have a wrapped ACP impl, this is easy

        // need to work with Clones to handle failure gracefully
        if (FAILED(_paStart->Clone(&paStart)))
            goto ErrorExit;

        if ((par = GetCAnchorRef_NA(paStart)) == NULL)
            goto ErrorExit;

        if (!par->_SetACP(acpAnchor))
            goto ErrorExit;

        if (FAILED(_paEnd->Clone(&paEnd)))
            goto ErrorExit;

        if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
            goto ErrorExit;

        if (!par->_SetACP(acpAnchor + cch))
            goto ErrorExit;
    }
    else
    {
        Assert(0); // who's doing this?
        // we fail if someone tries to do SetExtentACP on a
        // non-acp text store.  Users of this method should
        // be aware of whether or not they are using an acp
        // store.
        goto ErrorExit;
    }

    SafeRelease(_paStart);
    SafeRelease(_paEnd);
    _paStart = paStart;
    _paEnd = paEnd;

    return S_OK;

ErrorExit:
    SafeRelease(paStart);
    SafeRelease(paEnd);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// SetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::SetExtent(IAnchor *paStart, IAnchor *paEnd)
{
    IAnchor *paStartClone;
    IAnchor *paEndClone;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if (paStart == NULL || paEnd == NULL)
        return E_INVALIDARG;

    if (CompareAnchors(paStart, paEnd) > 0)
        return E_INVALIDARG;
        
    if (paStart->Clone(&paStartClone) != S_OK)
        return E_FAIL;

    if (paEnd->Clone(&paEndClone) != S_OK)
    {
        paStartClone->Release();
        return E_FAIL;
    }

    SafeRelease(_paStart);
    SafeRelease(_paEnd);

    _paStart = paStartClone;   
    _paEnd = paEndClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _PreEditCompositionCheck
//
//----------------------------------------------------------------------------

HRESULT CRange::_PreEditCompositionCheck(TfEditCookie ec, CComposition **ppComposition, BOOL *pfNewComposition)
{
    IRC irc;

    // any active compositions?
    *pfNewComposition = FALSE;
    irc = CComposition::_IsRangeCovered(_pic, _pic->_GetClientInEditSession(ec), _paStart, _paEnd, ppComposition);

    if (irc == IRC_COVERED)
    {
        // this range is within an owned composition
        Assert(*ppComposition != NULL);
        return S_OK;
    }
    else if (irc == IRC_OUTSIDE)
    {
        // the caller owns compositions, but this range isn't wholly within them
        return TF_E_RANGE_NOT_COVERED;
    }
    else
    {
        Assert(irc == IRC_NO_OWNEDCOMPOSITIONS);
    }

    // not covered, need to create a default composition
    if (_pic->_StartComposition(ec, _paStart, _paEnd, NULL, ppComposition) != S_OK)
        return E_FAIL;

    if (*ppComposition != NULL)
    {
        *pfNewComposition = TRUE;
        return S_OK;
    }

    return TF_E_COMPOSITION_REJECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rangebk.cpp ===
//
// perange.cpp
//

#include "private.h"
#include "helpers.h"
#include "ic.h"
#include "range.h"
#include "rangebk.h"
#include "rprop.h"
#include "immxutil.h"

//////////////////////////////////////////////////////////////////////////////
//
// CRangeBackup
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CRangeBackupProperty::CRangeBackupProperty(CRangeBackup *ppr, CProperty *pProp)
{
    _ppr = ppr;
    _pProp = pProp;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CRangeBackupProperty::~CRangeBackupProperty()
{
    int i;
    int nCnt = _rgPropRanges.Count();

    for (i = 0; i < nCnt; i++)
    {
        PERSISTPROPERTYRANGE *pPropRange;
        pPropRange = _rgPropRanges.GetPtr(i);

        Assert(pPropRange);
        Assert(pPropRange->_pPropStore);

        pPropRange->_pPropStore->Release();
        pPropRange->_pPropStore = NULL;
    }
    
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CRangeBackupProperty::Init(TfEditCookie ec)
{
    IEnumTfRanges *pEnum;
    ITfRange *pRange;
    HRESULT hr;

    hr = _pProp->EnumRanges(ec, &pEnum, (ITfRangeAnchor *)_ppr->_pRange);
    if (FAILED(hr) || !pEnum)
        return FALSE;

    while (pEnum->Next(1, &pRange, NULL) == S_OK)
    {
        CRange *pCRange;
        pCRange = GetCRange_NA(pRange);
        if (pCRange)
        {
            _StoreOneRange(ec, pCRange);
        }
        pRange->Release();
    }

    pEnum->Release();
    
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// StoreOneRange
//
//----------------------------------------------------------------------------

BOOL CRangeBackupProperty::_StoreOneRange(TfEditCookie ec, CRange *pCRange)
{
    PROPERTYLIST *pPropList;
    ULONG achStart = 0;
    ULONG achEnd = 0;

    if (CompareAnchors(pCRange->_GetStart(), _ppr->_pRange->_GetStart()) < 0)
    {
        if (CompareAnchors(pCRange->_GetEnd(), _ppr->_pRange->_GetEnd()) > 0)
        {
           pPropList = _pProp->_FindPropListAndDivide(_ppr->_pRange->_GetStart(), _ppr->_pRange->_GetEnd());

           achStart = _GetOffset(ec, _ppr->_pRange->_GetStart());
           achEnd = _GetOffset(ec, _ppr->_pRange->_GetEnd());
        }
        else
        {
           pPropList = _pProp->_FindPropListAndDivide(_ppr->_pRange->_GetStart(), pCRange->_GetEnd());
           achStart = _GetOffset(ec, _ppr->_pRange->_GetStart());
           achEnd = _GetOffset(ec, pCRange->_GetEnd());
        }
    }
    else if (CompareAnchors(pCRange->_GetEnd(), _ppr->_pRange->_GetEnd()) > 0)
    {
        pPropList = _pProp->_FindPropListAndDivide(pCRange->_GetStart(), _ppr->_pRange->_GetEnd());
        achStart = _GetOffset(ec, pCRange->_GetStart());
        achEnd = _GetOffset(ec, _ppr->_pRange->_GetEnd());
    }
    else
    {
        pPropList = _pProp->_FindPropListAndDivide(pCRange->_GetStart(), pCRange->_GetEnd());
        achStart = _GetOffset(ec, pCRange->_GetStart());
        achEnd = _GetOffset(ec, pCRange->_GetEnd());
    }

    if (pPropList)
    {
        if (!pPropList->_pPropStore)
            _pProp->LoadData(pPropList);

        if (pPropList->_pPropStore)
        {
             HRESULT hr;
             PERSISTPROPERTYRANGE *pPropRange;
             ITfPropertyStore *pPropStore = NULL;
             int nCnt;
             
             hr = pPropList->_pPropStore->Clone(&pPropStore);
             if (FAILED(hr) || !pPropStore)
                 return FALSE;

             nCnt = _rgPropRanges.Count();

             if (!_rgPropRanges.Insert(nCnt, 1))
             { 
                 pPropStore->Release();
                 return FALSE;
             }

             pPropRange = _rgPropRanges.GetPtr(nCnt);
             pPropRange->achStart = achStart;
             pPropRange->achEnd = achEnd;
             pPropRange->_pPropStore = pPropStore;
        }
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _GetOffset
//
//----------------------------------------------------------------------------

int CRangeBackupProperty::_GetOffset(TfEditCookie ec, IAnchor *pa)
{
    CRange *pCRange;
    CRange *pCRangeTmp = NULL;
    ULONG cch = 0;
    HRESULT hr;
    BOOL fEmpty;

    pCRange = new CRange;
    if (!pCRange)
        goto Exit;

    if (!pCRange->_InitWithDefaultGravity(_ppr->_pic, COPY_ANCHORS, pa, pa))
        goto Exit;

    pCRangeTmp = _ppr->_pRange->_Clone();
    if (!pCRangeTmp)
        goto Exit;

    hr = pCRangeTmp->ShiftEndToRange(ec, (ITfRangeAnchor *)pCRange, TF_ANCHOR_START);
    if (FAILED(hr))
        goto Exit;

    
    fEmpty = FALSE;
    while ((pCRangeTmp->IsEmpty(ec, &fEmpty) == S_OK) && !fEmpty)
    {
        WCHAR sz[256];
        ULONG cchTmp;

        pCRangeTmp->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz), &cchTmp);
        cch += cchTmp;
    }

Exit:
    SafeRelease(pCRangeTmp);
    SafeRelease(pCRange);

    return cch;
}

//+---------------------------------------------------------------------------
//
// Restore
//
//----------------------------------------------------------------------------

BOOL CRangeBackupProperty::Restore(TfEditCookie ec)
{
    int i;
    HRESULT hr;
    int nCnt;
    CRange *pCRange;

    nCnt = _rgPropRanges.Count();
    if (!nCnt)
        return FALSE;

    pCRange = _ppr->_pRange->_Clone();
    if (!pCRange)
        return FALSE;

    for (i = 0; i < nCnt; i++)
    {
        PERSISTPROPERTYRANGE *pPropRange;
        LONG cchStart, cchEnd;
        pPropRange = _rgPropRanges.GetPtr(i);

        Assert(pPropRange);
        Assert(pPropRange->_pPropStore);

        hr = pCRange->ShiftStartToRange(ec, (ITfRangeAnchor *)_ppr->_pRange,
                                        TF_ANCHOR_START);
        if (FAILED(hr))
            goto Next;

        hr = pCRange->Collapse(ec, TF_ANCHOR_START);
        if (FAILED(hr))
            goto Next;

        // shift End first.
        hr = pCRange->ShiftEnd(ec, pPropRange->achEnd, &cchEnd, NULL);
        if (FAILED(hr))
            goto Next;

        hr = pCRange->ShiftStart(ec, pPropRange->achStart, &cchStart, NULL);
        if (FAILED(hr))
            goto Next;

        _pProp->_SetStoreInternal(ec, pCRange, pPropRange->_pPropStore, TRUE);
Next:
        pPropRange->_pPropStore->Release();
        pPropRange->_pPropStore = NULL;
    }

    pCRange->Release();
    _rgPropRanges.Clear();

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CRangeBackup
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CRangeBackup::CRangeBackup(CInputContext *pic)
{
    _pic = pic;
    Assert(!_pRange);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CRangeBackup::~CRangeBackup()
{
    Clear();
}

//+---------------------------------------------------------------------------
//
// Clear
//
//----------------------------------------------------------------------------

void CRangeBackup::Clear()
{
    _pic = NULL;
    SafeReleaseClear(_pRange);

    delete _psz;
    _psz = NULL;

    int nCnt = _rgProp.Count();
    for (int i = 0; i < nCnt; i++)
    {
        CRangeBackupProperty *pprp = _rgProp.Get(i);
        delete pprp;
    }
    _rgProp.Clear();
}


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

HRESULT CRangeBackup::Init(TfEditCookie ec, CRange *pRange)
{
    ITfRange *pRangeTmp = NULL;
    ULONG cch, cchCur;
    BOOL fEmpty;
    CProperty *pProp;
    HRESULT hr;
    WCHAR *pszTmp;

    Assert(!_pRange);
    Assert(!_psz);

    _pRange = pRange->_Clone();

    hr = _pRange->Clone(&pRangeTmp);
    if (FAILED(hr) || !pRangeTmp)
        return E_FAIL;

    hr = E_FAIL;

    //
    // Save text.
    //
    fEmpty = FALSE;
    cchCur = 0;
    cch = 31;
    while ((pRangeTmp->IsEmpty(ec, &fEmpty) == S_OK) && !fEmpty)
    {
        if (!_psz)
        {
            Assert(cchCur == 0);
            _psz = (WCHAR *)cicMemAlloc((cch + 1) * sizeof(WCHAR));
        }
        else
        {
            Assert(cchCur);
            pszTmp = (WCHAR *)cicMemReAlloc(_psz, (cchCur + cch + 1) * sizeof(WCHAR));
            if (pszTmp != NULL)
            {
                _psz = pszTmp;
            }
            else
            {
                cicMemFree(_psz);
                _psz = NULL;
            }
        }

        if (_psz == NULL)
            goto Exit;

        pRangeTmp->GetText(ec, TF_TF_MOVESTART, _psz + cchCur, cch, &cch);

        cchCur += cch;
        cch *= 2;
    }

    if (!cchCur)
    {
        hr = S_FALSE;
        _cch = 0;
    
        if (_psz)
        {
            cicMemFree(_psz);
            _psz = NULL;
        }

        goto Exit;
    }

    _cch = cchCur;
    _psz[_cch] = L'\0';

    //
    // Save property.
    //
    pProp = _pic->_pPropList;
    while (pProp)
    {
        CRangeBackupProperty *pPropRange;
        int nCnt = _rgProp.Count();

        pPropRange = new CRangeBackupProperty(this, pProp);
        if (!pPropRange)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if (!pPropRange->Init(ec))
        {
            delete pPropRange;
            goto Next;
        }

        if (!_rgProp.Insert(nCnt, 1))
        {
            hr = E_OUTOFMEMORY;
            delete pPropRange;
            goto Next;
        }

        _rgProp.Set(nCnt, pPropRange);

Next:
        pProp = pProp->_pNext;
    }

    hr = S_OK;
Exit:
    SafeRelease(pRangeTmp);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Restore
//
//----------------------------------------------------------------------------

STDAPI CRangeBackup::Restore(TfEditCookie ec, ITfRange *pRange)
{
    HRESULT hr = E_FAIL;
    int i;
    int nCnt;
    CRange *range;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }
   
    if (pRange)
    {
        SafeReleaseClear(_pRange);
        range = GetCRange_NA(pRange);
        if (range == NULL)
            return E_INVALIDARG;

        if (!VerifySameContext(_pic, range))
            return E_INVALIDARG;

        range->_QuickCheckCrossedAnchors();

        _pRange = range->_Clone();      
    }

    Assert(_pRange);
    Assert(_psz || !_cch);

    if (!_pic)
        return S_OK;

    Assert(_pRange);

    _pRange->SetText(ec, 0, _psz, _cch);

    nCnt = _rgProp.Count();
    for (i = 0; i < nCnt; i++)
    {
        CRangeBackupProperty *pPropRange = _rgProp.Get(i);

        Assert(pPropRange);
        pPropRange->Restore(ec);
        delete pPropRange;
    }
    _rgProp.Clear();

    hr = S_OK;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rmcoll.cpp ===
//
// rmcoll.cpp
//
// Render markup/collections.
//

#include "private.h"
#include "dam.h"
#include "saa.h"
#include "strary.h"
#include "ic.h"
#include "attr.h"
#include "range.h"
#include "immxutil.h"
#include "rprop.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CRenderMarkupCollection
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CRenderMarkupCollection::CRenderMarkupCollection()
{
    // always add GUID_PROP_ATTRIBUTE at index 0

    if (!_rgGUIDAtom.Append(1))
        return;
    if (!_rgOther.Append(1))
    {
        _rgGUIDAtom.Clear();
        return;
    }

    MyRegisterGUID(GUID_PROP_ATTRIBUTE, _rgGUIDAtom.GetPtr(0));
    _rgOther.GetPtr(0)->uPriority = TF_DA_PRIORITY_HIGHEST;
    _rgOther.GetPtr(0)->gaTip = g_gaSystem;
}

//+---------------------------------------------------------------------------
//
// _Advise
//
//----------------------------------------------------------------------------

void CRenderMarkupCollection::_Advise(ITfTextInputProcessor *tip, TfGuidAtom gaTip)
{
    ITfDisplayAttributeCollectionProvider *pProvider;
    ULONG uCount;
    TF_DA_PROPERTY rgProperty[8];
    int i;
    int iOldCount;
    int iOld;
    int iNew;

    if (tip->QueryInterface(IID_ITfDisplayAttributeCollectionProvider, (void **)&pProvider) != S_OK)
        return;

    if (pProvider->GetCollection(ARRAYSIZE(rgProperty), rgProperty, &uCount) != S_OK || uCount == 0)
        goto Exit;

    iOldCount = _rgGUIDAtom.Count();
    Assert(iOldCount == _rgOther.Count());

    if (!_rgGUIDAtom.Append(uCount))
        goto Exit;
    if (!_rgOther.Append(uCount))
    {
        _rgGUIDAtom.Remove(iOldCount, uCount);
        goto Exit;
    }

    // merge the new guids with the old
    // nb: we assume rgProperty is sorted
    iNew = uCount-1;
    iOld = iOldCount-1;

    for (i=iNew + iOld + 1; i>=0; i--)
    {
        // nb: we put new GUIDs with same priority as existing GUIDs lower in the list
        // this makes sure that GUID_PROP_ATTRIBUTE is always at index 0, and keeps
        // existing rendering consistent (no change on screen of existing markup)
        if (iNew >= 0 &&
            rgProperty[iNew].uPriority >= _rgOther.GetPtr(iOld)->uPriority)
        {
            MyRegisterGUID(rgProperty[iNew].guidProperty, _rgGUIDAtom.GetPtr(i));
            _rgOther.GetPtr(i)->uPriority = rgProperty[iNew].uPriority;
            _rgOther.GetPtr(i)->gaTip = gaTip;
            iNew--;
        }
        else
        {
            *_rgGUIDAtom.GetPtr(i) = *_rgGUIDAtom.GetPtr(iOld);
            *_rgOther.GetPtr(i) = *_rgOther.GetPtr(iOld);
            iOld--;
        }
    }

Exit:
    pProvider->Release();
}

//+---------------------------------------------------------------------------
//
// _Unadvise
//
//----------------------------------------------------------------------------

void CRenderMarkupCollection::_Unadvise(TfGuidAtom gaTip)
{
    int iOldCount;
    int iNewCount;
    int i;
    int iDst;
    iOldCount = _rgGUIDAtom.Count();
    iNewCount = 0;

    iDst = -1;

    for (i=0; i<iOldCount; i++)
    {
        if (_rgOther.GetPtr(i)->gaTip == gaTip)
        {
            if (iDst == -1)
            {
                iDst = i;
            }
        }
        else if (iDst != -1)
        {
            *_rgGUIDAtom.GetPtr(iDst) = *_rgGUIDAtom.GetPtr(i);
            *_rgOther.GetPtr(iDst) = *_rgOther.GetPtr(i);
            iDst++;
            iNewCount++;
        }
    }

    if (iDst != -1)
    {
        _rgGUIDAtom.Remove(iDst, iOldCount - iDst);
        _rgOther.Remove(iDst, iOldCount - iDst);
    }
    Assert(_rgGUIDAtom.Count() == _rgOther.Count());
}

//+---------------------------------------------------------------------------
//
// _IsInCollection
//
//----------------------------------------------------------------------------

BOOL CRenderMarkupCollection::_IsInCollection(REFGUID rguidProperty)
{
    TfGuidAtom tfGuidAtom;
    int i;

    if (_rgGUIDAtom.Count() == 0)
        return FALSE;

    MyRegisterGUID(rguidProperty, &tfGuidAtom);

    for (i=0; i<_rgGUIDAtom.Count(); i++)
    {
        if (*_rgGUIDAtom.GetPtr(i) == tfGuidAtom)
            return TRUE;
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumRenderingMarkup
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumRenderingMarkup : public IEnumTfRenderingMarkup,
                             public CComObjectRootImmx
{
public:
    CEnumRenderingMarkup()
    {
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumRenderingMarkup"), PERF_UBERPROP_COUNTER);
    }
    ~CEnumRenderingMarkup();

    BEGIN_COM_MAP_IMMX(CEnumRenderingMarkup)
        COM_INTERFACE_ENTRY(IEnumTfRenderingMarkup)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    BOOL _Init(DWORD dwFlags, CRange *pRangeCover, CInputContext *pContext);

    // IEnumTfRenderingMarkup
    STDMETHODIMP Clone(IEnumTfRenderingMarkup **ppClone);
    STDMETHODIMP Next(ULONG ulCount, TF_RENDERINGMARKUP *rgMarkup, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    int _iCur;
    CSharedAnchorArray *_prgAnchors;
    CSharedStructArray<TF_DISPLAYATTRIBUTE> *_prgValues;
    CInputContext *_pContext;

    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumRenderingMarkup);

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumRenderingMarkup::~CEnumRenderingMarkup()
{
    if (_prgAnchors != NULL)
    {
        _prgAnchors->_Release();
    }
    if (_prgValues != NULL)
    {
        _prgValues->_Release();
    }
    _pContext->Release();
}

//+---------------------------------------------------------------------------
//
// LookupProperty
//
//----------------------------------------------------------------------------

BOOL LookupProperty(CInputContext *pContext, ITfDisplayAttributeMgr *pDisplayAttrMgr,
                   TfGuidAtom tfGuidAtom, IAnchor *paStart, IAnchor *paEnd, TF_DISPLAYATTRIBUTE *ptfAttrInfoNext)
{
    CProperty *pProperty;
    ITfDisplayAttributeInfo *pDisplayAttrInfo;
    VARIANT varValue;
    GUID guidValue;
    BOOL fRet;

    // get the property matching the GUID
    if ((pProperty = pContext->_FindProperty(tfGuidAtom)) == NULL)
        return FALSE;

    // get the GUID value of the property
    if (pProperty->_GetDataInternal(paStart, paEnd, &varValue) != S_OK) // perf: don't really need paEnd
        return FALSE;

    Assert(varValue.vt == VT_I4); // should be a GUIDATOM

    if (MyGetGUID(varValue.lVal, &guidValue) != S_OK)
        return FALSE;

    // translate the GUID to a display attribute
    if (pDisplayAttrMgr->GetDisplayAttributeInfo(guidValue, &pDisplayAttrInfo, NULL) != S_OK)
        return FALSE;

    fRet = (pDisplayAttrInfo->GetAttributeInfo(ptfAttrInfoNext) == S_OK);

    pDisplayAttrInfo->Release();
    return fRet;
}


//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumRenderingMarkup::_Init(DWORD dwFlags, CRange *pRangeCover, CInputContext *pContext)
{
    CDisplayAttributeMgr *pDisplayAttrMgr;
    CRenderMarkupCollection *pMarkupCollection;
    int i;
    int j;
    TF_DISPLAYATTRIBUTE *ptfAttrInfo;
    TF_DISPLAYATTRIBUTE tfAttrInfoNext;
    BOOL fNeedLine;
    BOOL fNeedText;
    BOOL fRet;
    ULONG uCount;
    const TfGuidAtom *pAtoms;

    Assert(_iCur == 0);
    Assert(_pContext == NULL);
    Assert(_prgAnchors == NULL);
    Assert(_prgValues == NULL);

    pDisplayAttrMgr = CDisplayAttributeMgr::_GetThis();
    if (pDisplayAttrMgr == NULL)
    {
        Assert(0); // ITfThreadMgr::Activate should ensure the singleton is initialized in tls
        return FALSE;
    }

    fRet = FALSE;

    pMarkupCollection = pDisplayAttrMgr->_GetMarkupCollection();

    // find the cicero property transitions
    if (dwFlags & TF_GRM_INCLUDE_PROPERTY)
    {
        uCount = pMarkupCollection->_Count();
        pAtoms = pMarkupCollection->_GetAtoms();
    }
    else
    {
        // skip GUID_PROP_ATTRIBUTE at index 0
        Assert(pMarkupCollection->_Count() >= 1);
        uCount = pMarkupCollection->_Count() - 1;
        pAtoms = pMarkupCollection->_GetAtoms() + 1;
    }
    _prgAnchors = CalcCicPropertyTrackerAnchors(pContext, pRangeCover->_GetStart(), pRangeCover->_GetEnd(),
                                                pMarkupCollection->_Count(), pMarkupCollection->_GetAtoms());

    if (_prgAnchors == NULL)
        goto Exit;

    Assert(_prgAnchors->Count() > 0); // we should get at least the pRangeCover start anchor

    if ((_prgValues = new CSharedStructArray<TF_DISPLAYATTRIBUTE>) == NULL)
        goto Exit;

    if (_prgAnchors->Count() > 1) // Append(0) will return NULL if the array is empty
    {                             // which is fine, but we don't want to return failure in that case (empty range => empty enum)
        if (!_prgValues->Append(_prgAnchors->Count()-1))
            goto Exit;
    }

    // now calculate the TF_DISPLAYATTRIBUTE for each span
    for (i=0; i<_prgAnchors->Count()-1; i++)
    {
        ptfAttrInfo = _prgValues->GetPtr(i);

        memset(ptfAttrInfo, 0, sizeof(*ptfAttrInfo));
        ptfAttrInfo->bAttr = TF_ATTR_OTHER;

        fNeedLine = TRUE;
        fNeedText = TRUE;

        // examine property values over the single span
        // index 0 is always GUID_PROP_ATTRIBUTE, only include it if the TF_GRM_INCLUDE_PROPERTY is set
        j = (dwFlags & TF_GRM_INCLUDE_PROPERTY) ? 0 : 1;
        for (; j<pMarkupCollection->_Count(); j++)
        {
            // get the property matching the GUID
            if (!LookupProperty(pContext, pDisplayAttrMgr, pMarkupCollection->_GetAtom(j), _prgAnchors->Get(i), _prgAnchors->Get(i+1), &tfAttrInfoNext))
                continue;

            // we got one
            if (fNeedText &&
                (tfAttrInfoNext.crText.type != TF_CT_NONE || tfAttrInfoNext.crBk.type != TF_CT_NONE))
            {
                ptfAttrInfo->crText = tfAttrInfoNext.crText;
                ptfAttrInfo->crBk = tfAttrInfoNext.crBk;
                fNeedText = FALSE;
            }
            if (fNeedLine &&
                tfAttrInfoNext.lsStyle != TF_LS_NONE)
            {
                ptfAttrInfo->lsStyle = tfAttrInfoNext.lsStyle;
                ptfAttrInfo->crLine = tfAttrInfoNext.crLine;
                ptfAttrInfo->fBoldLine = tfAttrInfoNext.fBoldLine;
                fNeedLine = FALSE;
            }

            // we can stop looking at this span if everything lower in the z-order is blocked
            if (j == 0 && (!fNeedText || !fNeedLine))
                break; // GUID_PROP_ATTRIBUTE is never masked with anything else
            if (!fNeedText && !fNeedLine)
                break; // couldn't mask in any more attributes
        }
    }

    _pContext = pContext;
    _pContext->AddRef();

    fRet = TRUE;

Exit:
    return fRet;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Clone(IEnumTfRenderingMarkup **ppEnum)
{
    CEnumRenderingMarkup *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumRenderingMarkup) == NULL)
        return E_OUTOFMEMORY;

    pClone->_iCur = _iCur;

    pClone->_prgAnchors = _prgAnchors;
    pClone->_prgAnchors->_AddRef();

    pClone->_prgValues = _prgValues ;
    pClone->_prgValues->_AddRef();

    pClone->_pContext = _pContext;
    pClone->_pContext->AddRef();

    *ppEnum = pClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Next(ULONG ulCount, TF_RENDERINGMARKUP *rgMarkup, ULONG *pcFetched)
{
    ULONG cFetched;
    CRange *range;
    IAnchor *paPrev;
    IAnchor *pa;
    int iCurOld;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    iCurOld = _iCur;

    if (ulCount > 0 && rgMarkup == NULL)
        return E_INVALIDARG;

    // we should always have at least one anchor (one anchor => empty range for enum, nothing to enum)
    Assert(_prgAnchors->Count() >= 1);

    paPrev = _prgAnchors->Get(_iCur);

    while (_iCur < _prgAnchors->Count()-1 && *pcFetched < ulCount)
    {
        pa = _prgAnchors->Get(_iCur+1);

        if ((range = new CRange) == NULL)
            break;
        if (!range->_InitWithDefaultGravity(_pContext, COPY_ANCHORS, paPrev, pa))
        {
            range->Release();
            break;
        }

        // we should never be returning empty ranges, since currently this base
        // class is only used for property enums and property spans are never
        // empty.
        // Similarly, paPrev should always precede pa.
        Assert(CompareAnchors(paPrev, pa) < 0);

        rgMarkup->pRange = (ITfRangeAnchor *)range;
        rgMarkup->tfDisplayAttr = *_prgValues->GetPtr(_iCur);
        rgMarkup++;

        *pcFetched = *pcFetched + 1;
        _iCur++;
        paPrev = pa;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _prgValues->Count()) ? S_FALSE : S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CDisplayAttributeMgr
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// EnumCollections
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeMgr::EnumCollections(IEnumTfCollection **ppEnum)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// GetRenderingMarkup
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetRenderingMarkup(TfEditCookie ec, DWORD dwFlags,
                                         ITfRange *pRangeCover,
                                         IEnumTfRenderingMarkup **ppEnum)
{
    CEnumRenderingMarkup *pEnum;
    CRange *range;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
        return TF_E_NOLOCK;

    if (dwFlags & ~TF_GRM_INCLUDE_PROPERTY)
        return E_INVALIDARG;

    if (pRangeCover == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRangeCover)) == NULL)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if ((pEnum = new CEnumRenderingMarkup) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(dwFlags, range, this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindNextRenderingMarkup
//
//----------------------------------------------------------------------------

STDAPI CInputContext::FindNextRenderingMarkup(TfEditCookie ec, DWORD dwFlags,
                                              ITfRange *pRangeQuery,
                                              TfAnchor tfAnchorQuery,
                                              ITfRange **ppRangeFound,
                                              TF_RENDERINGMARKUP *ptfRenderingMarkup)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rngsink.cpp ===
//
// readrng.cpp
//

#include "private.h"
#include "globals.h"
#include "rngsink.h"
#include "immxutil.h"
#include "catmgr.h"
#include "rprop.h"
#include "proputil.h"

/* f66ee5c0-fe8c-11d2-8ded-00105a2799b5 */
static const IID IID_CGeneralPropStore = { 
    0xf66ee5c0,
    0xfe8c,
    0x11d2,
    {0x8d, 0xed, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

DBG_ID_INSTANCE(CGeneralPropStore);
DBG_ID_INSTANCE(CStaticPropStore);

//////////////////////////////////////////////////////////////////////////////
//
// CGeneralPropStore
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CGeneralPropStore::_Init(TfGuidAtom guidatom, const VARIANT *pvarValue, DWORD dwPropFlags)
{
    _guidatom = guidatom;

    _dwPropFlags  = dwPropFlags;

    return (VariantToTfProp(&_prop, 
                    pvarValue, 
                    ADDREF, 
                    (dwPropFlags & PROPF_VTI4TOGUIDATOM))
            == S_OK);
}

BOOL CGeneralPropStore::_Init(TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags)
{
    _guidatom = guidatom;
    _dwPropFlags  = dwPropFlags;

    _prop = *ptfp;

    switch (_prop.type)
    {
        case TF_PT_UNKNOWN:
            _prop.punk->AddRef();
            break;

        case TF_PT_BSTR:
            if ((_prop.bstr = SysAllocString(ptfp->bstr)) == NULL)
                return FALSE;
            break;

        case TF_PT_PROXY:
            if ((_prop.blob = PROXY_BLOB::Clone(ptfp->blob)) == NULL)
                return FALSE;
            break;
    }

    return TRUE;
}

BOOL CGeneralPropStore::_Init(TfGuidAtom guidatom, int iDataSize, TfPropertyType proptype, IStream *pStream, DWORD dwPropFlags)
{
    GUID guid;
    TfGuidAtom gaTmp;
    BOOL fRet;

    _guidatom = guidatom;
    _dwPropFlags  = dwPropFlags;
    _prop.type = proptype;

    fRet = FALSE; // failure

    switch (proptype)
    {
        case TF_PT_DWORD:
            if (iDataSize != sizeof(DWORD))
                break;

            fRet = SUCCEEDED(pStream->Read((void *)&_prop.dw, iDataSize, NULL));
            break;

        case TF_PT_GUID:
            if (iDataSize != sizeof(GUID))
                break;

            if (FAILED(pStream->Read((void *)&guid, iDataSize, NULL)))
                break;

            CCategoryMgr::s_RegisterGUID(guid, &gaTmp);
            _prop.guidatom = gaTmp;

            fRet = TRUE;
            break;

        case TF_PT_BSTR:
            _prop.bstr = SysAllocStringLen(NULL, iDataSize / sizeof(WCHAR));

            if (_prop.bstr == NULL)
                break;

            if (FAILED(pStream->Read((void *)_prop.bstr, iDataSize, NULL)))
            {
                SysFreeString(_prop.bstr);
                _prop.bstr = NULL;
                break;
            }

            fRet = TRUE;
            break;

        case TF_PT_PROXY:
            // just copy the bytes blindly, we won't do anything with them
            if ((_prop.blob = PROXY_BLOB::Alloc(iDataSize)) == NULL)
                break;

            if (FAILED(pStream->Read(_prop.blob->rgBytes, iDataSize, NULL)))
            {
                cicMemFree(_prop.blob);
                _prop.blob = NULL;
            }

            _prop.blob->cb = iDataSize;

            fRet = TRUE;
            break;

        case TF_PT_NONE:
            Assert(0);
            break;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CGeneralPropStore::~CGeneralPropStore()
{
    switch (_prop.type)
    {
        case TF_PT_UNKNOWN:
            SafeRelease(_prop.punk);
            break;

        case TF_PT_BSTR:
            SysFreeString(_prop.bstr);
            break;

        case TF_PT_PROXY:
            PROXY_BLOB::Free(_prop.blob);
            break;
    }
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetType(GUID *pguid)
{
    return MyGetGUID(_guidatom, pguid);
}

//+---------------------------------------------------------------------------
//
// GetDataType
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetDataType(DWORD *pdwReserved)
{
    if (pdwReserved == NULL)
        return E_INVALIDARG;

    *pdwReserved = _prop.type;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetData(VARIANT *pvarValue)
{
    if (pvarValue == NULL)
        return E_INVALIDARG;

    return TfPropToVariant(pvarValue, &_prop, ADDREF);
}

//+---------------------------------------------------------------------------
//
// OnTextUpdated
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    // This PropStore does not support TextUpdate.
    // leave the ink alone if it's a correction
    if (_dwPropFlags & PROPF_ACCEPTCORRECTION)
        *pfAccept = (dwFlags & TF_TU_CORRECTION);
    else
        *pfAccept = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Shrink
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Shrink(ITfRange *pRange, BOOL *pfFree)
{
    // This PropStore does not support Shrink.
    *pfFree = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Divide
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{
    //
    // This PropStore does not support Divide.
    //
    *ppPropStore = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Clone(ITfPropertyStore **ppPropStore)
{
    CGeneralPropStore *pStore;

    if (ppPropStore == NULL)
        return E_INVALIDARG;

    *ppPropStore = NULL;

    //
    // we can't clone a Unknown prop.
    //
    if (_prop.type == TF_PT_UNKNOWN)
        return E_FAIL;

    if ((pStore = new CGeneralPropStore) == NULL)
        return E_OUTOFMEMORY;

    if (!pStore->_Init(_guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pStore;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetpropertyRangeCreator
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetPropertyRangeCreator(CLSID *pclsid)
{
    memset(pclsid, 0, sizeof(*pclsid));
    return TF_S_GENERALPROPSTORE;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Serialize(IStream *pStream, ULONG *pcb)
{
    GUID guid;
    ULONG ulSize;
    HRESULT hr = E_FAIL;

    if (!pcb)
        return E_INVALIDARG;
    *pcb = 0;

    if (!pStream)
        return E_INVALIDARG;

    switch (_prop.type)
    {
        case TF_PT_DWORD:
            if (SUCCEEDED(hr = pStream->Write(&_prop.dw, sizeof(DWORD), NULL)))
                *pcb = sizeof(DWORD);
            break;

        case TF_PT_GUID:
            if (SUCCEEDED(MyGetGUID(_prop.guidatom, &guid)) &&
                SUCCEEDED(hr = pStream->Write(&guid, sizeof(GUID), NULL)))
            {
                *pcb = sizeof(GUID);
            }
            break;

        case TF_PT_BSTR:
            ulSize = SysStringLen(_prop.bstr) * sizeof(WCHAR);

            if (SUCCEEDED(pStream->Write(_prop.bstr, ulSize, NULL)))
            {
                *pcb =  ulSize;
            }
            hr = *pcb ? S_OK : S_FALSE;
            break;

        case TF_PT_PROXY:
            if (SUCCEEDED(pStream->Write(_prop.blob->rgBytes, _prop.blob->cb, pcb)))
            {
                hr = (*pcb == _prop.blob->cb) ? S_OK : E_FAIL;
            }
            break;

        case TF_PT_UNKNOWN:
            hr = S_FALSE;
            break;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CPropStoreProxy
//
// CPropStore is for keeping the persistent data when the owner TFE
// is not available.
//
// GetPropertyRangeCreator() returns the real owner TFE of this data.
// So next time the application may be able to find the real owner if it is
// available.
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CPropStoreProxy::_Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, int iDataSize, IStream *pStream, DWORD dwPropFlags)
{
    if (!CGeneralPropStore::_Init(guidatom, iDataSize, TF_PT_PROXY,  pStream, dwPropFlags))
        return FALSE;

    _clsidTIP = *pclsidTIP;

    return TRUE;
}

BOOL CPropStoreProxy::_Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags)
{
    if (!CGeneralPropStore::_Init(guidatom, ptfp, dwPropFlags))
        return FALSE;

    _clsidTIP = *pclsidTIP;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetpropertyRangeCreator
//
//----------------------------------------------------------------------------

STDAPI CPropStoreProxy::GetPropertyRangeCreator(CLSID *pclsid)
{
    *pclsid = _clsidTIP;
    return TF_S_PROPSTOREPROXY;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CPropStoreProxy::Clone(ITfPropertyStore **ppPropStore)
{
    CPropStoreProxy *pStore;

    if (ppPropStore == NULL)
        return E_INVALIDARG;

    *ppPropStore = NULL;

    //
    // we can't clone a Unknown prop.
    //
    if (_prop.type == TF_PT_UNKNOWN)
        return E_FAIL;

    if ((pStore = new CPropStoreProxy) == NULL)
        return E_OUTOFMEMORY;

    if (!pStore->_Init(&_clsidTIP, _guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pStore;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CStaticPropStore
//
// CStaticPropStore works like character property. We keep same raw data 
// even if the range is devided or changed.
//
// So the range data should not contain the information that is associated
// with cch.
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// Shrink
//
//----------------------------------------------------------------------------

STDAPI CStaticPropStore::Shrink(ITfRange *pRange, BOOL *pfFree)
{
    // we don't change any raw data.
    *pfFree = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Divide
//
//----------------------------------------------------------------------------

STDAPI CStaticPropStore::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{
    CStaticPropStore *pss;

    *ppPropStore = NULL;

    if ((pss = new CStaticPropStore) == NULL)
        return E_OUTOFMEMORY;

    if (!pss->_Init(_guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pss;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CStaticPropStore::Clone(ITfPropertyStore **ppPropStore)
{
    CStaticPropStore *pStore;

    if (ppPropStore == NULL)
        return E_INVALIDARG;

    *ppPropStore = NULL;

    //
    // we can't clone a Unknown prop.
    //
    if (_prop.type == TF_PT_UNKNOWN)
        return E_FAIL;

    if ((pStore = new CStaticPropStore) == NULL)
        return E_OUTOFMEMORY;

    if (!pStore->_Init(_guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pStore;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rngsink.h ===
//
// rngsink.h
//

#ifndef RNGSINK_H
#define RNGSINK_H

#include "tfprop.h"

#define BUF_SIZE 16

#define TF_PT_PROXY ((TfPropertyType)-1)  // private property type used for CPropStoreProxy data

extern const IID IID_CGeneralPropStore;

class CGeneralPropStore : public ITfPropertyStore,
                          public CComObjectRootImmx
{
public:
    CGeneralPropStore()
    {
        Dbg_MemSetThisNameID(TEXT("CGeneralPropStore"));
    }
    ~CGeneralPropStore();

    BOOL _Init(TfGuidAtom guidatom, const VARIANT *pvarValue, DWORD dwPropFlags);
    BOOL _Init(TfGuidAtom guidatom, int iDataSize, TfPropertyType type, IStream *pStream, DWORD dwPropFlags);

    BEGIN_COM_MAP_IMMX(CGeneralPropStore)
        COM_INTERFACE_ENTRY_IID(IID_CGeneralPropStore, CGeneralPropStore)
        COM_INTERFACE_ENTRY(ITfPropertyStore)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfPropertyStore
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

protected:
    BOOL _Init(TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags);

    TFPROPERTY _prop;
    DWORD _dwPropFlags;
    TfGuidAtom _guidatom;

    DBG_ID_DECLARE;
};

class CPropStoreProxy : public CGeneralPropStore
{
public:
    CPropStoreProxy()
    {
        Dbg_MemSetThisNameID(TEXT("CPropStoreProxy"));
    }

    BOOL _Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, int iDataSize, IStream *pStream, DWORD dwPropFlags);

    //
    // ITfPropertyStore
    //
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);

private:
    BOOL _Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags);

    CLSID _clsidTIP;
};

class CStaticPropStore : public CGeneralPropStore
{
public:
    CStaticPropStore()
    {
        Dbg_MemSetThisNameID(TEXT("CStaticPropStore"));
    }

    //
    // ITfPropertyStore
    //
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);

private:
    DBG_ID_DECLARE;
};

#endif // RNGSINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rprop.cpp ===
//
// rprop.cpp
//

#include "private.h"
#include "rprop.h"
#include "rngsink.h"
#include "immxutil.h"
#include "varutil.h"
#include "ic.h"
#include "tim.h"
#include "enumprop.h"
#include "tfprop.h"
#include "range.h"
#include "anchoref.h"

/* ccaefd20-38a6-11d3-a745-0050040ab407 */
const IID IID_PRIV_CPROPERTY = { 0xccaefd20, 0x38a6, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };
    

//
// By using this fake CLSID, the StaticProperty pretends 
// to be an TFE for persistent data.
//
/* b6a4bc60-0749-11d3-8def-00105a2799b5 */
static const CLSID CLSID_IME_StaticProperty = { 
    0xb6a4bc60,
    0x0749,
    0x11d3,
    {0x8d, 0xef, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };


DBG_ID_INSTANCE(CProperty);

inline void CheckCrossedAnchors(PROPERTYLIST *pProp)
{
    if (CompareAnchors(pProp->_paStart, pProp->_paEnd) > 0)
    {
        // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
        pProp->_paStart->ShiftTo(pProp->_paEnd);
    }
}

//+---------------------------------------------------------------------------
//
// IsEqualPropertyValue
//
//----------------------------------------------------------------------------

BOOL IsEqualPropertyValue(ITfPropertyStore *pStore1, ITfPropertyStore *pStore2)
{
    BOOL fEqual;
    VARIANT varValue1;
    VARIANT varValue2;

    if (pStore1->GetData(&varValue1) != S_OK)
        return FALSE;

    if (pStore2->GetData(&varValue2) != S_OK)
    {
        VariantClear(&varValue1);
        return FALSE;
    }

    if (varValue1.vt != varValue2.vt)
    {
        Assert(0); // shouldn't happen for property of same type
        VariantClear(&varValue1);
        VariantClear(&varValue2);
        return FALSE;
    }

    switch (varValue1.vt)
    {
        case VT_I4:
            fEqual = varValue1.lVal == varValue2.lVal;
            break;

        case VT_UNKNOWN:
            fEqual = IdentityCompare(varValue1.punkVal, varValue2.punkVal);
            varValue1.punkVal->Release();
            varValue2.punkVal->Release();
            break;

        case VT_BSTR:
            fEqual = (wcscmp(varValue1.bstrVal, varValue2.bstrVal) == 0);
            SysFreeString(varValue1.bstrVal);
            SysFreeString(varValue2.bstrVal);
            break;

        case VT_EMPTY:
            fEqual = TRUE;
            break;

        default:
            Assert(0); // invalid type
            fEqual = FALSE;
            VariantClear(&varValue1);
            VariantClear(&varValue2);
            break;
    }

    return fEqual;
}


//////////////////////////////////////////////////////////////////////////////
//
// CProperty
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CProperty::CProperty(CInputContext *pic, REFGUID guidProp, TFPROPERTYSTYLE propStyle, DWORD dwAuthority, DWORD dwPropFlags)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CProperty"), PERF_PROP_COUNTER);

    _dwAuthority = dwAuthority;
    _propStyle = propStyle;
    _pic = pic; // don't need to AddRef because we are contained in the ic
                // CPropertySub, otoh, must AddRef the owner ic
    MyRegisterGUID(guidProp, &_guidatom);

    _dwPropFlags = dwPropFlags;
    _dwCookie = 0;

    Assert(_pss == NULL);

#ifdef DEBUG
    _dbg_guid = guidProp;
#endif // DEBUG
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CProperty::~CProperty()
{
    int nCnt = GetPropNum();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        PROPERTYLIST *pProp = GetPropList(i);
        Assert(pProp);
        _FreePropertyList(pProp);
    }

    _rgProp.Clear();

    if (_pss != NULL)
    {
        delete _pss;
    }

    Assert(!GetPropNum());
}

//+---------------------------------------------------------------------------
//
// _FreePropertyList
//
//----------------------------------------------------------------------------

void CProperty::_FreePropertyList(PROPERTYLIST *pProp)
{
    SafeRelease(pProp->_pPropStore);

    if (pProp->_pPropLoad)
    {
        delete pProp->_pPropLoad;
    }

    SafeRelease(pProp->_paStart);
    SafeRelease(pProp->_paEnd);

    cicMemFree(pProp);
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

HRESULT CProperty::GetType(GUID *pguid)
{
    return MyGetGUID(_guidatom, pguid);
}


//+---------------------------------------------------------------------------
//
// _FindComplex
//
// If piOut != NULL then it is set to the index where ich was found, or the
// index of the next lower ich if ich isn't in the array.
// If there is no element in the array with a lower ich, returns offset -1.
//
// If fTextUpdate == TRUE, the expectation is that this method is being called
// from _PropertyTextUpdate and we have to worry about empty or crossed spans.
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindComplex(IAnchor *pa, LONG *piOut, BOOL fEnd, BOOL fTextUpdate)
{
    PROPERTYLIST *pProp;
    PROPERTYLIST *pPropMatch;
    int iMin;
    int iMax;
    int iMid;
    LONG l;

    pPropMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgProp.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        pProp = _rgProp.Get(iMid);
        Assert(pProp != NULL);

        if (fTextUpdate)
        {
            // after an edit, the anchors may be crossed
            CheckCrossedAnchors(pProp);
        }

        l = CompareAnchors(pa, fEnd ? pProp->_paEnd : pProp->_paStart);

        if (l < 0)
        {
            iMax = iMid;
        }
        else if (l > 0)
        {
            iMin = iMid + 1;
        }
        else // pa == paPropStart
        {
            pPropMatch = pProp;
            break;
        }
    }

    if (fTextUpdate &&
        pPropMatch != NULL &&
        iMid != -1)
    {
        // we have to account for empty spans during a textupdate
        pPropMatch = _FindUpdateTouchup(pa, &iMid, fEnd);
    }

    if (piOut != NULL)
    {
        if (pPropMatch == NULL && iMid >= 0)
        {
            PROPERTYLIST *pPropTmp = _rgProp.Get(iMid);
            // couldn't find a match, return the next lowest ich
            // this assert won't work because the previous property list might have crossed anchors (which is ok)
            //Assert(iMid == 0 || CompareAnchors(fEnd ? GetPropList(iMid - 1)->_paEnd : GetPropList(iMid - 1)->_paStart, pa) < 0);
            if (CompareAnchors(fEnd ? pProp->_paEnd : pPropTmp->_paStart, pa) > 0)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return pPropMatch;
}

//+---------------------------------------------------------------------------
//
// _FindUpdateTouchup
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindUpdateTouchup(IAnchor *pa, int *piMid, BOOL fEnd)
{
    PROPERTYLIST *pPropertyList;
    int iTmp;

    // we may have empty spans after a text update, because of a text delete.
    // in this case, return the last empty span.
    // We'll do a O(n) scan instead of anything tricky, because in this case
    // we'll soon touch every empty span again just so we can delete it.

    // if we testing vs. the span end, we want the first empty span, otherwise we want the last one
    for (iTmp = fEnd ? *piMid-1 : *piMid+1; iTmp >= 0 && iTmp < _rgProp.Count(); iTmp += fEnd ? -1 : +1)
    {
        pPropertyList = _rgProp.Get(iTmp);

        if (CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd) < 0) // use Compare instead of IsEqual to handle crossed anchors
            break;

        *piMid = iTmp;
    }

    // was the next/prev span truncated? we want it if it matches the original search criteria
    if (fEnd)
    {
        if (iTmp >= 0 && IsEqualAnchor(pa, pPropertyList->_paEnd))
        {
            *piMid = iTmp;
        }
    }
    else
    {
        if (iTmp < _rgProp.Count() && IsEqualAnchor(pa, pPropertyList->_paStart))
        {
            *piMid = iTmp;
        }
    }

    return _rgProp.Get(*piMid);
}

//+---------------------------------------------------------------------------
//
// Set
//
//----------------------------------------------------------------------------

HRESULT CProperty::Set(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore)
{
    BOOL bRet;

    Assert(pPropStore != NULL);

    bRet = _InsertPropList(paStart, paEnd, pPropStore, NULL);

    if (bRet)
        PropertyUpdated(paStart, paEnd);

    _Dbg_AssertProp();

    return bRet ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// SetLoader
//
//----------------------------------------------------------------------------

HRESULT CProperty::SetLoader(IAnchor *paStart, IAnchor *paEnd, CPropertyLoad *pPropLoad)
{
    BOOL bRet;
    bRet = _InsertPropList(paStart, paEnd, NULL, pPropLoad);

    if (bRet)
        PropertyUpdated(paStart, paEnd);

    return bRet ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// ForceLoad
//
//----------------------------------------------------------------------------

HRESULT CProperty::ForceLoad()
{
    int nCnt = GetPropNum();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        PROPERTYLIST *pProp = GetPropList(i);
        if (!pProp->_pPropStore)
        {
            HRESULT hr;
            if (FAILED(hr = LoadData(pProp)))
                return hr;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clear
//
// Removes property spans from paStart to paEnd.
//----------------------------------------------------------------------------

void CProperty::Clear(IAnchor *paStart, IAnchor *paEnd, DWORD dwFlags, BOOL fTextUpdate)
{
    PROPERTYLIST *pPropertyList;
    LONG iEnd;
    LONG iStart;
    LONG iRunSrc;
    LONG iRunDst;
    LONG iBogus;
    LONG lResult;
    BOOL fStartMatchesSpanEnd;
    BOOL fEndMatchesSpanStart;
    BOOL fSkipNextOnTextUpdate;

    if (_rgProp.Count() == 0)
        return; // no props

    fEndMatchesSpanStart = (_FindComplex(paEnd, &iEnd, FALSE /* fFindEndEdge */, fTextUpdate) != NULL);

    if (iEnd < 0)
        return; // no props covered -- delta preceeds all spans

    fStartMatchesSpanEnd = (_FindComplex(paStart, &iStart, TRUE /* fFindEndEdge */, fTextUpdate) != NULL);

    if (!fStartMatchesSpanEnd)
    {
        // we can skip this span, it's end edge is to the left of paStart
        iStart++;
    }

    if (iEnd < iStart)
        return; // no props covered -- delta is between two spans

    //
    // first span is special, since it may be partially covered
    //

    // just one span?
    if (iStart == iEnd)
    {
        _ClearOneSpan(paStart, paEnd, iStart, fStartMatchesSpanEnd, fEndMatchesSpanStart, dwFlags, fTextUpdate);
        return;
    }

    // first span may be truncated
    pPropertyList = _rgProp.Get(iStart);

    if (!_ClearFirstLastSpan(TRUE /* fFirst */, fStartMatchesSpanEnd, paStart, paEnd, pPropertyList, dwFlags, fTextUpdate, &fSkipNextOnTextUpdate))
    {
        // we're not going clear the first span, so skip past it
        iStart++;
    }

    //
    // handle all the totally covered spans
    //

    iBogus = iStart-1; // a sentinel
    iRunSrc = iBogus;
    iRunDst = iBogus;

    if (!fTextUpdate)
    {
        // we don't need a loop for non-text updates
        // everything will be deleted, and we don't have
        // to worry about crossed anchors or change histories
        // we just need to some extra checking on the last span
        if (iStart < iEnd)
        {
            iRunDst = iStart;
        }
        iStart = iEnd;
    }

    for (; iStart <= iEnd; iStart++)
    {
        pPropertyList = _rgProp.Get(iStart);

        if (iStart == iEnd)
        {
            // last span is special, since it may be partially covered
            if (_ClearFirstLastSpan(FALSE /* fFirst */, fEndMatchesSpanStart, paStart, paEnd,
                                    pPropertyList, dwFlags, fTextUpdate, &fSkipNextOnTextUpdate))
            {
                goto ClearSpan;
            }
            else
            {
                goto SaveSpan;
            }
        }

        // make sure we handle any crossed anchors
        lResult = CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd);

        if (lResult >= 0)
        {
            if (lResult > 0)
            {
                // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
                pPropertyList->_paStart->ShiftTo(pPropertyList->_paEnd);
            }
            // don't do OnTextUpdated for empty spans!
            fSkipNextOnTextUpdate = TRUE;
        }

        // give the property owner a chance to ignore text updates
        if (fSkipNextOnTextUpdate ||
            !_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
        {
ClearSpan:
            // this span is going to die
            fSkipNextOnTextUpdate = FALSE;

            if (iRunDst == iBogus)
            {
                iRunDst = iStart;
            }
            else if (iRunSrc > iRunDst)
            {
                // time to move this run
                _MovePropertySpans(iRunDst, iRunSrc, iStart - iRunSrc);
                // and update the pointers
                iRunDst += iStart - iRunSrc;
                iRunSrc = iBogus;
            }
        }
        else
        {
            // make sure we clear the history for this span
            pPropertyList->_paStart->ClearChangeHistory();
            pPropertyList->_paEnd->ClearChangeHistory();
SaveSpan:
            // this span will live
            if (iRunSrc == iBogus && iRunDst != iBogus)
            {
                iRunSrc = iStart;
            }
        }
    }

    // handle the final run
    if (iRunDst > iBogus)
    {
        // if iRunSrc == iBogus, then we want to delete every span we saw
        if (iRunSrc == iBogus)
        {
            _MovePropertySpans(iRunDst, iStart, _rgProp.Count()-iStart);
        }
        else
        {
            _MovePropertySpans(iRunDst, iRunSrc, _rgProp.Count()-iRunSrc);
        }
    }

    _Dbg_AssertProp();
}

//+---------------------------------------------------------------------------
//
// _ClearOneSpan
//
// Handle a clear that intersects just one span.
//----------------------------------------------------------------------------

void CProperty::_ClearOneSpan(IAnchor *paStart, IAnchor *paEnd, int iIndex,
                              BOOL fStartMatchesSpanEnd, BOOL fEndMatchesSpanStart, DWORD dwFlags, BOOL fTextUpdate)
{
    PROPERTYLIST *pPropertyList;
    ITfPropertyStore *pPropertyStore;
    IAnchor *paTmp;
    LONG lResult;
    DWORD dwStartHistory;
    DWORD dwEndHistory;
    LONG lStartDeltaToStartSpan;
    LONG lEndDeltaToEndSpan;
    HRESULT hr;

    pPropertyList = _rgProp.Get(iIndex);
    lResult = 0;

    // empty or crossed span?
    if (fTextUpdate)
    {
        if ((lResult = CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd)) >= 0)
            goto ClearSpan; // we shouldn't call OnTextUpdated for empty/crossed spans
    }
    else
    {
        // we should never see an empty span outside a text update
        Assert(!IsEqualAnchor(pPropertyList->_paStart, pPropertyList->_paEnd));
    }

    if (fTextUpdate)
    {
        // make sure we clear the history for this span in case it isn't cleared
        _ClearChangeHistory(pPropertyList, &dwStartHistory, &dwEndHistory);
    }

    // handle edge case first, if the clear range just touches an edge of the property span
    if (fStartMatchesSpanEnd || fEndMatchesSpanStart)
    {
        // if this is not a text update, then the ranges don't intersect
        if (!fTextUpdate)
            return;

        // some of the text at either end of the span might have been deleted
        if (fStartMatchesSpanEnd)
        {
            if (!(dwEndHistory & TS_CH_PRECEDING_DEL))
                return;

            if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
                return;

            goto ShrinkLeft; // we can avoid the CompareAnchors calls below
        }
        else
        {
            Assert(fEndMatchesSpanStart);

            if (!(dwStartHistory & TS_CH_FOLLOWING_DEL))
                return;

            if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
                return;

            goto ShrinkRight; // we can avoid the CompareAnchors calls below
        }
    }

    if (fTextUpdate &&
        _OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
    {
        // property owner is ok with the clear
        return;
    }

    lStartDeltaToStartSpan = CompareAnchors(paStart, pPropertyList->_paStart);
    lEndDeltaToEndSpan = CompareAnchors(paEnd, pPropertyList->_paEnd);

    if (lStartDeltaToStartSpan > 0)
    {
        if (lEndDeltaToEndSpan < 0)
        {
            //
            // divide, we're clearing in the middle of the span
            //
            if (pPropertyList->_paEnd->Clone(&paTmp) != S_OK)
                goto ClearSpan; // give up

            hr = _Divide(pPropertyList, paStart, paEnd, &pPropertyStore);

            if (hr == S_OK)
            {
                _CreateNewProp(paEnd, paTmp, pPropertyStore, NULL);
                pPropertyStore->Release();

                PropertyUpdated(paStart, paEnd);
            }

            paTmp->Release();

            if (hr != S_OK)
                goto ClearSpan;
        }
        else
        {
            //
            // shrink to the left, we're clearing the right edge of this span
            //
ShrinkLeft:
            if (pPropertyList->_paEnd->Clone(&paTmp) != S_OK)
                goto ClearSpan;

            hr = _SetNewExtent(pPropertyList, pPropertyList->_paStart, paStart, FALSE);

            PropertyUpdated(paStart, paTmp);

            paTmp->Release();

            if (hr != S_OK)
                goto ClearSpan;
        }
    }
    else if (lEndDeltaToEndSpan < 0)
    {
        //
        // shrink to the right, we're clearing the left edge of this span
        //
ShrinkRight:
        if (pPropertyList->_paStart->Clone(&paTmp) != S_OK)
            goto ClearSpan;

        hr = _SetNewExtent(pPropertyList, paEnd, pPropertyList->_paEnd, FALSE);

        PropertyUpdated(paTmp, paEnd);

        paTmp->Release();

        if (hr != S_OK)
            goto ClearSpan;
    }
    else
    {
        // we're wiping the whole span
ClearSpan:
        if (lResult <= 0)
        {
            PropertyUpdated(pPropertyList->_paStart, pPropertyList->_paEnd);
        }
        else
        {
            // we found a crossed span above, report as if empty
            PropertyUpdated(pPropertyList->_paEnd, pPropertyList->_paEnd);
        }
        _FreePropertyList(pPropertyList);
        _rgProp.Remove(iIndex, 1);
    }
}

//+---------------------------------------------------------------------------
//
// _OnTextUpdate
//
// Make a ITfPropertyStore::OnTextUpdate callback.
// Returns FALSE if the property should be freed.
//----------------------------------------------------------------------------

BOOL CProperty::_OnTextUpdate(DWORD dwFlags, PROPERTYLIST *pPropertyList, IAnchor *paStart, IAnchor *paEnd)
{
    CRange *pRange;
    BOOL fRet;
    BOOL fAccept;

    if (pPropertyList->_pPropStore == NULL)
    {
        // need to load data to make a change notification
        if (LoadData(pPropertyList) != S_OK)
            return FALSE;
        Assert(pPropertyList->_pPropStore != NULL);
    }

    // perf: can we cache the range for the notification?
    if ((pRange = new CRange) == NULL)
        return FALSE; // out of memory, give up

    fRet = FALSE;

    if (!pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paStart, paEnd))
        goto Exit;

    if (pPropertyList->_pPropStore->OnTextUpdated(dwFlags, (ITfRangeAnchor *)pRange, &fAccept) != S_OK)
        goto Exit;
    
    fRet = fAccept;

Exit:
    pRange->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _MovePropertySpans
//
// Shift PROPERTYLISTs from iSrc to iDst, and shrink the array if we move
// anything that touches the very end.
//----------------------------------------------------------------------------

void CProperty::_MovePropertySpans(int iDst, int iSrc, int iCount)
{
    PROPERTYLIST *pPropertyList;
    PROPERTYLIST **pSrc;
    PROPERTYLIST **pDst;
    LONG i;
    LONG iHalt;
    int cb;
    BOOL fLastRun;

    Assert(iCount >= 0);
    Assert(iDst < iSrc);
    Assert(iDst >= 0);
    Assert(iSrc + iCount <= _rgProp.Count());

    fLastRun = (iSrc + iCount == _rgProp.Count());

    if (!fLastRun)
    {
        // free all the spans that are going to be clobbered
        iHalt = min(iSrc, iDst + iCount);
    }
    else
    {
        // on the last call, cleanup everything that never got clobbered
        iHalt = iSrc;
    }

    for (i=iDst; i<iHalt; i++)
    {
        pPropertyList = _rgProp.Get(i);

        if (pPropertyList == NULL)
            continue; // already freed this guy

        if (CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd) <= 0)
        {
            PropertyUpdated(pPropertyList->_paStart, pPropertyList->_paEnd);
        }
        else
        {
            // crossed anchors
            PropertyUpdated(pPropertyList->_paEnd, pPropertyList->_paEnd);
        }
        *_rgProp.GetPtr(i) = NULL; // NULL before the callbacks in _FreePropertyList
        _FreePropertyList(pPropertyList);
    }

    // shift the moving spans down

    pSrc = _rgProp.GetPtr(iSrc);
    pDst = _rgProp.GetPtr(iDst);

    memmove(pDst, pSrc, iCount*sizeof(PROPERTYLIST *));

    // this method is called from Clear as we shift through an array of spans
    // to remove.  On the last call only, we want to re-size the array.

    if (fLastRun)
    {
        // free any unused memory at the end of the array
        _rgProp.Remove(iDst + iCount, _rgProp.Count() - (iDst + iCount));
    }
    else
    {
        // mark vacated spans so we don't try to free them a second time
        // nb: we don't do this on the last call, which can be a big win since
        // in the case of delete there is only one single call
        pDst = _rgProp.GetPtr(max(iSrc, iDst + iCount));
        cb = sizeof(PROPERTYLIST *)*(iSrc+iCount - max(iSrc, iDst + iCount));
        memset(pDst, 0, cb);
    }
}

//+---------------------------------------------------------------------------
//
// _ClearFirstLastSpan
//
// Returns TRUE if the span should be cleared.
//----------------------------------------------------------------------------

BOOL CProperty::_ClearFirstLastSpan(BOOL fFirst, BOOL fMatchesSpanEdge,
                                    IAnchor *paStart, IAnchor *paEnd, PROPERTYLIST *pPropertyList,
                                    DWORD dwFlags, BOOL fTextUpdate, BOOL *pfSkipNextOnTextUpdate)
{
    DWORD dwStartHistory;
    DWORD dwEndHistory;
    BOOL fCovered;
    LONG lResult;

    *pfSkipNextOnTextUpdate = FALSE;

    if (fTextUpdate)
    {
        lResult = CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd);

        if (lResult == 0)
        {
            // empty span, nix it
            goto Exit;
        }

        // make sure we clear the history for this span in case it isn't cleared
        _ClearChangeHistory(pPropertyList, &dwStartHistory, &dwEndHistory);
        // make sure we handle any crossed anchors
        if (lResult > 0)
        {
            // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
            pPropertyList->_paStart->ShiftTo(pPropertyList->_paEnd);
        }
    }

    // completely covered?
    if (fFirst)
    {
        fCovered = (CompareAnchors(pPropertyList->_paStart, paStart) >= 0);
    }
    else
    {
        fCovered = (CompareAnchors(pPropertyList->_paEnd, paEnd) <= 0);
    }

    if (fCovered)
    {
        // this span is covered, so we're going to clear it unless it's a text update
        // and the store is cool with it
        if (!fTextUpdate)
            return TRUE;

        if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
            return FALSE;

        goto Exit; // return TRUE, and make sure we don't call OnTextUpdate again
    }

    // start of span matches end of clear range? (or vice-versa)
    if (fMatchesSpanEdge)
    {
        // if no text was deleted, then there really is no overlap
        if (!fTextUpdate)
            return FALSE;

        // otherwise, we may have just deleted text at the edge of the property span
        if (fFirst)
        {
            if (!(dwEndHistory & TS_CH_PRECEDING_DEL))
                return FALSE;
        }
        else
        {
            if (!(dwStartHistory & TS_CH_FOLLOWING_DEL))
                return FALSE;
        }
    }

    // if we made it here we're going to clear some of the property span

    if (fTextUpdate)
    {
        if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
        {
            // property owner is ok with the text edit
            return FALSE;
        }
    }

    if (fFirst)
    {
        if (_SetNewExtent(pPropertyList, pPropertyList->_paStart, paStart, FALSE) == S_OK)
            return FALSE;
    }
    else
    {
        if (_SetNewExtent(pPropertyList, paEnd, pPropertyList->_paEnd, FALSE) == S_OK)
            return FALSE;
    }

Exit:
    // property owner is not ok with the shink, kill this span
    *pfSkipNextOnTextUpdate = TRUE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CreateNewProp
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_CreateNewProp(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad)
{
    PROPERTYLIST *pProp;
    LONG iProp;

    Assert(!IsEqualAnchor(paStart, paEnd));

    if (Find(paStart, &iProp, FALSE))
    {
        Assert(0);
    }
    iProp++;

    pProp = (PROPERTYLIST *)cicMemAllocClear(sizeof(PROPERTYLIST));

    if (pProp == NULL)
        return NULL;

    Dbg_MemSetNameIDCounter(pProp, TEXT("PROPERTYLIST"), (DWORD)-1, PERF_PROPERTYLIST_COUNTER);

    if (!_rgProp.Insert(iProp, 1))
    {
        cicMemFree(pProp);
        return NULL;
    }

    _rgProp.Set(iProp, pProp);

    pProp->_pPropStore = pPropStore;
    pProp->_pPropLoad = pPropLoad;

    if (pPropStore)
        pPropStore->AddRef();

    Assert(pProp->_paStart == NULL);
    Assert(pProp->_paEnd == NULL);
    Assert(pProp->_pPropStore || pProp->_pPropLoad);

    _SetNewExtent(pProp, paStart, paEnd, TRUE);

    pProp->_paStart->SetGravity(TS_GR_FORWARD);
    pProp->_paEnd->SetGravity(TS_GR_BACKWARD); // End must be LEFT, too. Because we don't want to stratch this property.

    if (GetPropStyle() == TFPROPSTYLE_STATICCOMPACT ||
        GetPropStyle() == TFPROPSTYLE_CUSTOM_COMPACT)
    {
        _DefragAfterThis(iProp);
    }

    return pProp;
}

//+---------------------------------------------------------------------------
//
// _SetNewExtent
//
// return S_FALSE, if tip wants to free the property.
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetNewExtent(PROPERTYLIST *pProp, IAnchor *paStart, IAnchor *paEnd, BOOL fNew)
{
    HRESULT hr;
    BOOL fFree;
    CRange *pRange = NULL;

    Assert(!IsEqualAnchor(paStart, paEnd));

    ShiftToOrClone(&pProp->_paStart, paStart);
    ShiftToOrClone(&pProp->_paEnd, paEnd);

    // we don't load actual data or send a resize event for new data
    if (fNew)
        return S_OK;

    Assert(pProp);

    if (!pProp->_pPropStore)
    {
        //
        // need to load data to make a change notification.
        //
        // perf:   we may skip and delete Loader if this property is not
        //         custom property.
        //
        if (FAILED(LoadData(pProp)))
            return E_FAIL;
    }

    hr = E_FAIL;

    if ((pRange = new CRange) != NULL)
    {
        if (pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pProp->_paStart, pProp->_paEnd))
        {
            hr = pProp->_pPropStore->Shrink((ITfRangeAnchor *)pRange, &fFree);

            if (hr != S_OK || fFree)
            {
                SafeReleaseClear(pProp->_pPropStore); // caller will free this property when it see S_FALSE return
                hr = S_FALSE;
            }
        }
        pRange->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Divide
//
// return S_FALSE, if tip wants to free the property.
//
//----------------------------------------------------------------------------

HRESULT CProperty::_Divide(PROPERTYLIST *pProp, IAnchor *paBreakPtStart, IAnchor *paBreakPtEnd, ITfPropertyStore **ppStore)
{
    HRESULT hr = E_FAIL;
    CRange *pRangeThis = NULL;
    CRange *pRangeNew = NULL;

    Assert(CompareAnchors(pProp->_paStart, paBreakPtStart) <= 0);
    Assert(CompareAnchors(paBreakPtStart, paBreakPtEnd) <= 0);
    Assert(CompareAnchors(paBreakPtEnd, pProp->_paEnd) <= 0);

    if ((pRangeThis = new CRange) == NULL)
        goto Exit;
    if (!pRangeThis->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pProp->_paStart, paBreakPtStart))
        goto Exit;
    if ((pRangeNew = new CRange) == NULL)
        goto Exit;
    if (!pRangeNew->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paBreakPtEnd, pProp->_paEnd))
        goto Exit;

    if (!pProp->_pPropStore)
    {
        //
        // we need to load data to make a change notification.
        //
        // perf: we may skip and delete Loader if this property is not
        //       custom property.
        //
        if (FAILED(LoadData(pProp)))
            goto Exit;
    }

    hr = pProp->_pPropStore->Divide((ITfRangeAnchor *)pRangeThis, (ITfRangeAnchor *)pRangeNew, ppStore);

    if ((hr == S_OK) && *ppStore)
    {
        ShiftToOrClone(&pProp->_paEnd, paBreakPtStart);
    }
    else
    {
        *ppStore = NULL;
        hr = S_FALSE;
    }

Exit:
    SafeRelease(pRangeThis);
    SafeRelease(pRangeNew);

    return hr;
}

//+---------------------------------------------------------------------------
//
// DestroyProp
//
//----------------------------------------------------------------------------

void CProperty::_RemoveProp(LONG iIndex, PROPERTYLIST *pProp)
{
#ifdef DEBUG
    LONG iProp;

    Assert(Find(pProp->_paStart, &iProp, FALSE) == pProp);
    Assert(iProp == iIndex);
#endif // DEBUG

    _rgProp.Remove(iIndex, 1);
    _FreePropertyList(pProp);
}

//+---------------------------------------------------------------------------
//
// _InsertPropList
//
//----------------------------------------------------------------------------

BOOL CProperty::_InsertPropList(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad)
{
    PROPERTYLIST *pProp;
    IAnchor *paTmpEnd = NULL;
    LONG nCnt = GetPropNum();
    LONG nCur;

    Assert(!IsEqualAnchor(paStart, paEnd));

    if (!nCnt)
    {
        //
        // we create the first PropList.
        //
        _CreateNewProp(paStart, paEnd, pPropStore, pPropLoad);
        goto End;
    }
    
    nCur = 0;
    Find(paStart, &nCur, FALSE);
    if (nCur <= 0)
        nCur = 0;

    pProp = QuickGetPropList(nCur);

    while (nCur < nCnt)
    {
        Assert(pProp);
        SafeReleaseClear(paTmpEnd);
        pProp->_paEnd->Clone(&paTmpEnd);

        if (CompareAnchors(paStart, paTmpEnd) >= 0)
            goto Next;

        if (CompareAnchors(paEnd, pProp->_paStart) <= 0)
        {
            //
            // we insert new PropList just before pProp.
            //
            if (!_AddIntoProp(nCur - 1, paStart, paEnd, pPropStore))
                _CreateNewProp(paStart, paEnd, pPropStore, pPropLoad);
            goto End;
        }


        if (CompareAnchors(paStart, pProp->_paStart) > 0)
        {
            //
            // Now need to split pProp to insert new Prop.
            //
            Assert(pProp->_pPropStore);

            if (CompareAnchors(paTmpEnd, paEnd) > 0)
            {
                ITfPropertyStore *pNewPropStore = NULL;

                if (S_OK != _Divide(pProp, paStart, paEnd, &pNewPropStore))
                {
                    _RemoveProp(nCur, pProp);
                    nCnt--;
                    goto DoAgain;
                }
                else if (pNewPropStore)
                {
                    _CreateNewProp(paEnd, paTmpEnd, pNewPropStore, pPropLoad);
                    pNewPropStore->Release();
                    pProp = GetPropList(nCur);
                    nCnt++;
                }
            }
            else
            {
                if (S_OK != _SetNewExtent(pProp, pProp->_paStart, paStart, FALSE))
                {
                    _RemoveProp(nCur, pProp);
                    nCnt--;
                    goto DoAgain;
                }
            }

            //
            // next time, new Prop will be inserted.
            //
            goto Next;
        }

        Assert(CompareAnchors(paStart, pProp->_paStart) <= 0);

        if (CompareAnchors(pProp->_paStart, paEnd) < 0)
        {
            if (CompareAnchors(paTmpEnd, paEnd) <= 0)
            {
                //
                // pProp is completely overlapped by new Prop.
                // so we delete this pProp.
                //
                _RemoveProp(nCur, pProp);
                nCnt--;
            }
            else
            {
                //
                // A part of pProp is overlapped by new Prop.
                //
                if (S_OK != _SetNewExtent(pProp, paEnd, paTmpEnd, FALSE))
                {
                    _RemoveProp(nCur, pProp);
                    nCnt--;
                }
            }

            goto DoAgain;
        }

        Assert(0);
Next:
        nCur++;
DoAgain:
        pProp = SafeGetPropList(nCur);
    }

    if (!_AddIntoProp(nCur - 1, paStart, paEnd, pPropStore))
        _CreateNewProp(paStart, paEnd, pPropStore, pPropLoad);

End:
    _Dbg_AssertProp();
    SafeRelease(paTmpEnd);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Defrag
//
// paStart, paEnd == NULL will defrag everything.
//----------------------------------------------------------------------------

BOOL CProperty::Defrag(IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pProp;
    LONG nCnt = GetPropNum();
    LONG nCur;
    BOOL fSamePropIndex;
    BOOL fDone = FALSE;

    if (GetPropStyle() != TFPROPSTYLE_STATICCOMPACT &&
        GetPropStyle() != TFPROPSTYLE_CUSTOM_COMPACT)
    {
        return fDone;
    }

    if (!nCnt)
        return fDone;
   
    pProp = GetFirstPropList();
    nCur = 0;
    if (paStart != NULL)
    {
        if (Find(paStart, &nCur, FALSE))
            nCur--;
        if (nCur <= 0)
            nCur = 0;
    }

    pProp = GetPropList(nCur);

    while (nCur < nCnt - 1) // Issue: shouldn't this terminate at paEnd?
    {
        PROPERTYLIST *pPropNext = GetPropList(nCur + 1);

        if (paEnd != NULL && CompareAnchors(pProp->_paStart, paEnd) > 0)
            break;

        fSamePropIndex = FALSE;

        if (CompareAnchors(pProp->_paEnd, pPropNext->_paStart) == 0)
        {
            if (!pProp->_pPropStore)
            {
                if (FAILED(LoadData(pProp)))
                    return FALSE;
            }
            if (!pPropNext->_pPropStore)
            {
                if (FAILED(LoadData(pPropNext)))
                    return FALSE;
            }

            // compare the value of each property instance

            if (IsEqualPropertyValue(pProp->_pPropStore, pPropNext->_pPropStore))
            {
                //
                // pPropNext is next to pProp and has same data.
                // So we merge them.
                // We should never fail this.
                //
                _SetNewExtent(pProp, pProp->_paStart, pPropNext->_paEnd, FALSE);
                Assert(pProp->_pPropStore);
                _RemoveProp(nCur+1, pPropNext);
                nCnt = GetPropNum();
                pProp = GetPropList(nCur);

                fDone = TRUE;

                //
                // Do same pProp again because _pNext was changed.
                //
                fSamePropIndex = TRUE;
            }
        }
        if (!fSamePropIndex)
        {
            nCur++;
        }
        pProp = GetPropList(nCur);
    }

    _Dbg_AssertProp();
    return fDone;
}

//+---------------------------------------------------------------------------
//
// _AddIntoProp
//
//----------------------------------------------------------------------------

BOOL CProperty::_AddIntoProp(int nCur, IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore)
{
    PROPERTYLIST *pProp;
    BOOL bRet = FALSE;

    Assert(!IsEqualAnchor(paStart, paEnd));

    if (GetPropStyle() != TFPROPSTYLE_STATICCOMPACT &&
        GetPropStyle() != TFPROPSTYLE_CUSTOM_COMPACT)
    {
        return FALSE;
    }

    if (!pPropStore)
        return FALSE;

    if (nCur < 0)
        return FALSE;

    if (!(pProp = GetPropList(nCur)))
        return FALSE;

    if (CompareAnchors(pProp->_paStart, paStart) <= 0 && // Issue: why do we need 2 compares? isn't CompareAnchors(pProp->_paEnd, paStart) >= 0 enough?
        CompareAnchors(pProp->_paEnd, paStart) >= 0)
    {
        if (CompareAnchors(paEnd, pProp->_paEnd) > 0)
        {
            if (!pProp->_pPropStore)
            {
                if (FAILED(LoadData(pProp)))
                    return FALSE;
            }

            if (IsEqualPropertyValue(pProp->_pPropStore, pPropStore))
            {
                HRESULT hr;
                hr = _SetNewExtent(pProp, pProp->_paStart, paEnd, FALSE);

                //
                // Our static property store should never fail.
                //
                Assert(hr == S_OK);
                Assert(pProp->_pPropStore);
                bRet = TRUE;
            }
        }
    }

    if (bRet)
       _DefragAfterThis(nCur);

    _Dbg_AssertProp();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// DefragThis
//
//----------------------------------------------------------------------------

void CProperty::_DefragAfterThis(int nCur)
{

    nCur++;
    while (1)
    {
        IAnchor *paTmpStart = NULL;
        IAnchor *paTmpEnd = NULL;
        PROPERTYLIST *pProp;
        int nCnt = GetPropNum();
        BOOL bRet;

        if (nCur >= nCnt)
            goto Exit;

        if (!(pProp = GetPropList(nCur)))
            goto Exit;

        pProp->_paStart->Clone(&paTmpStart);
        pProp->_paEnd->Clone(&paTmpEnd);

        bRet = Defrag(paTmpStart, paTmpEnd);

        SafeRelease(paTmpStart);
        SafeRelease(paTmpEnd);

        if (!bRet)
            goto Exit;
    }
Exit:
    return;
}

//+---------------------------------------------------------------------------
//
// FindPropertyListByPos
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::FindPropertyListByPos(IAnchor *paPos, BOOL fEnd)
{
    PROPERTYLIST *pPropList = NULL;
    BOOL fFound = FALSE;
    LONG nCnt;

    Find(paPos, &nCnt, fEnd);
    if (nCnt >= 0)
        pPropList = GetPropList(nCnt);
 
    if (pPropList)
    {
        if (!fEnd)
        {
            if (CompareAnchors(pPropList->_paStart, paPos) <= 0 &&
                CompareAnchors(paPos, pPropList->_paEnd) < 0)
            {
                fFound = TRUE;
            }
        }
        else
        {
            if (CompareAnchors(pPropList->_paStart, paPos) < 0 &&
                CompareAnchors(paPos, pPropList->_paEnd) <= 0)
            {
                fFound = TRUE;
            }
        }
    }

    return fFound ? pPropList : NULL;
}

//+---------------------------------------------------------------------------
//
// LoadData
//
//----------------------------------------------------------------------------

HRESULT CProperty::LoadData(PROPERTYLIST *pPropList)
{
    HRESULT hr = E_FAIL;
    ITfPropertyStore *pStore;
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *ph;
    IStream *pStream = NULL;
    CRange *pRange = NULL;
    
    Assert(!pPropList->_pPropStore);
    Assert(pPropList->_pPropLoad);

    //
    // Update ichAnchor and cch of TF_PERSISTENT_PROPERTY_HEADER_ACP.
    // As text may be updated, the original value is
    // obsolete.
    //
    ph = &pPropList->_pPropLoad->_hdr;

    ShiftToOrClone(&ph->paStart, pPropList->_paStart);
    ShiftToOrClone(&ph->paEnd, pPropList->_paEnd);

    if (FAILED(pPropList->_pPropLoad->_pLoader->LoadProperty(ph, &pStream)))
        goto Exit;

    if ((pRange = new CRange) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    if (!pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, ph->paStart, ph->paEnd))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (FAILED(_GetPropStoreFromStream(ph, pStream, pRange, &pStore)))
        goto Exit;

    pPropList->_pPropStore = pStore;
    delete pPropList->_pPropLoad;
    pPropList->_pPropLoad = NULL;

    hr = S_OK;

Exit:
    SafeRelease(pStream);
    SafeRelease(pRange);
    return hr;
}

//+---------------------------------------------------------------------------
//
// _Dbg_AssertProp
//
//----------------------------------------------------------------------------

#ifdef DEBUG
void CProperty::_Dbg_AssertProp()
{
    LONG nCnt = GetPropNum();
    LONG n;
    IAnchor *paEndLast = NULL;

    for (n = 0; n < nCnt; n++)
    {
        PROPERTYLIST *pProp = GetPropList(n);

        Assert(paEndLast == NULL || CompareAnchors(paEndLast, pProp->_paStart) <= 0);
        Assert(CompareAnchors(pProp->_paStart, pProp->_paEnd) < 0);
        Assert(pProp->_pPropStore || pProp->_pPropLoad);

        paEndLast = pProp->_paEnd;
    }

}
#endif

//+---------------------------------------------------------------------------
//
// PropertyUpdated
//
//----------------------------------------------------------------------------

void CProperty::PropertyUpdated(IAnchor *paStart, IAnchor *paEnd)
{
    CSpanSet *pss;
    CProperty *pDisplayAttrProperty;

    if (pss = _CreateSpanSet()) 
    {
        pss->Add(0, paStart, paEnd, COPY_ANCHORS);
    }

    if (_dwPropFlags & PROPF_MARKUP_COLLECTION)
    {
        // we also need to update the display attribute property
        if (_pic->_GetProperty(GUID_PROP_ATTRIBUTE, &pDisplayAttrProperty) == S_OK)
        {
            Assert(!(pDisplayAttrProperty->_dwPropFlags & PROPF_MARKUP_COLLECTION)); // don't allow infinite recursion!
            pDisplayAttrProperty->PropertyUpdated(paStart, paEnd);
            pDisplayAttrProperty->Release();
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetPropStoreFromStream
//
//----------------------------------------------------------------------------

HRESULT CProperty::_GetPropStoreFromStream(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, CRange *pRange, ITfPropertyStore **ppStore)
{
    ITfTextInputProcessor *pIME = NULL;
    CTip                  *ptip = NULL;

    ITfCreatePropertyStore *pCreateStore = NULL;
    ITfPropertyStore *pPropStore = NULL;
    CRange *pRangeTmp = NULL;
    GUID guidProp;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    HRESULT hr = E_FAIL;
    LARGE_INTEGER li;
    TfGuidAtom guidatom;

    Assert(!IsEqualAnchor(pHdr->paStart, pHdr->paEnd));

    GetCurrentPos(pStream, &li);

    if (!ptim)
        goto Exit;

    if (FAILED(GetType(&guidProp)))
        goto Exit;

    if (!IsEqualGUID(guidProp, pHdr->guidType))
        goto Exit;

    //
    // Try QI.
    //
    if (FAILED(MyRegisterGUID(pHdr->clsidTIP, &guidatom)))
        goto Exit;

    if (ptim->_GetCTipfromGUIDATOM(guidatom, &ptip))
        pIME = ptip->_pTip;

    if (pIME && ptip->_fActivated) 
    {
        if (FAILED(hr = pIME->QueryInterface(IID_ITfCreatePropertyStore,
                                             (void **)&pCreateStore)))
            goto Exit;

        if ((pRangeTmp = new CRange) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        if (!pRangeTmp->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pHdr->paStart, pHdr->paEnd))
        {
            hr = E_FAIL;
            goto Exit;
        }
        
        if (FAILED(hr = pCreateStore->CreatePropertyStore(guidProp,
                                                          (ITfRangeAnchor *)pRangeTmp,
                                                          pHdr->cb,
                                                          pStream,
                                                          &pPropStore)))
            goto Exit;
    }
    else
    {
        if (IsEqualCLSID(pHdr->clsidTIP, CLSID_IME_StaticProperty))
        {
            //
            // Unserialize Static properties.
            //
            CGeneralPropStore *pStore;

            // GUID_PROP_READING is TFPROPSTYLE_CUSTOM ==> uses a general prop store
            if (_propStyle == TFPROPSTYLE_CUSTOM)
            {
                // general prop stores are thrown away if their text is edited
                pStore =  new CGeneralPropStore;
            }
            else
            {
                // static prop stores are per char, and simply clone themselves in response to any edit
                pStore =  new CStaticPropStore;
            }
    
            if (!pStore)
                goto Exit;

            if (!pStore->_Init(GetPropGuidAtom(),
                              pHdr->cb,
                              (TfPropertyType)pHdr->dwPrivate,
                              pStream,
                              _dwPropFlags))
            {
                goto Exit;
            }

            pPropStore = pStore;
            hr = S_OK;
        }
        else
        {
            //
            // There is no TFE installed in this system. So we use 
            // PropStoreProxy to hold the data.
            // Temporarily we use ITfIME_APP. But original TFE that owns this
            // data is kept in CPropStoreProxy.
            //
            CPropStoreProxy *pStoreProxy = new CPropStoreProxy;
    
            if (!pStoreProxy)
                goto Exit;

            if (!pStoreProxy->_Init(&pHdr->clsidTIP,
                                    GetPropGuidAtom(),
                                    pHdr->cb,
                                    pStream,
                                    _dwPropFlags))
            {
                goto Exit;
            }

            pPropStore = pStoreProxy;
            hr = S_OK;
        }
    }


Exit:

    // make sure the stream seek ptr is in a consistent state -- don't count
    // on any tip to do it right!
    if (SUCCEEDED(hr))
    {
        li.QuadPart += pHdr->cb;
    }
    pStream->Seek(li, STREAM_SEEK_SET, NULL);

    *ppStore = pPropStore;
    SafeRelease(pRangeTmp);
    SafeRelease(pCreateStore);

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CProperty::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    if (*ppContext)
    {
       (*ppContext)->AddRef();
       return S_OK;
    }

    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
// Clear
//
//----------------------------------------------------------------------------

STDAPI CProperty::Clear(TfEditCookie ec, ITfRange *pRange)
{
    CRange *pCRange = NULL;
    IAnchor *paStart = NULL;
    IAnchor *paEnd = NULL;
    HRESULT hr;

    if (!_IsValidEditCookie(ec, TF_ES_READ_PROPERTY_WRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    paStart = NULL;
    paEnd = NULL;

    if (pRange != NULL)
    {
        pCRange = GetCRange_NA(pRange);
        if (!pCRange)
             return E_INVALIDARG;

        if (!VerifySameContext(_pic, pCRange))
            return E_INVALIDARG;

        pCRange->_QuickCheckCrossedAnchors();

        paStart = pCRange->_GetStart();
        paEnd = pCRange->_GetEnd();
    }

    if ((hr = _CheckValidation(ec, pCRange)) != S_OK)
        return hr;

    return _ClearInternal(ec, paStart, paEnd);
}

//+---------------------------------------------------------------------------
//
// _CheckValidation
//
//----------------------------------------------------------------------------

HRESULT CProperty::_CheckValidation(TfEditCookie ec, CRange *range)
{
    CProperty *prop;
    BOOL fExactEndMatch;
    LONG iStartEdge;
    LONG iEndEdge;
    LONG iSpan;
    PROPERTYLIST *pPropList;
    TfClientId tid;
    IAnchor *paStart;

    //
    // There is no validation. Return TRUE;
    //
    if (_dwAuthority == PROPA_NONE)
        return S_OK;

    if (_dwAuthority & PROPA_READONLY)
        return TF_E_READONLY;

    tid = _pic->_GetClientInEditSession(ec);

    if (range == NULL)
        return (tid == _pic->_GetTIPOwner()) ? S_OK : TF_E_NOTOWNEDRANGE;

    if (!(_dwAuthority & PROPA_FOCUSRANGE))
    {
        Assert(_dwAuthority & PROPA_TEXTOWNER);
        return _CheckOwner(tid, range->_GetStart(), range->_GetEnd());
    }

    //
    // If the validation is PROPA_FOCUSTEXTOWNER, we check the focus range
    // first. If the range is not focus range, we allow tip to
    // update the property.
    //
    if ((prop = _pic->_FindProperty(GUID_PROP_COMPOSING)) == NULL)
        return S_OK; // no focus spans, so must be valid

    // for each focus span covered by the range, we need to make sure
    // this tip is the owner
    prop->Find(range->_GetStart(), &iStartEdge, FALSE);
    fExactEndMatch = (prop->Find(range->_GetEnd(), &iEndEdge, TRUE) != NULL);

    for (iSpan = max(iStartEdge, 0); iSpan <= iEndEdge; iSpan++)
    {
        pPropList = prop->GetPropList(iSpan);

        if (iSpan == iStartEdge)
        {
            // this span may not be covered, need to check
            // only relivent case: are we entirely to the right of the span?
            if (CompareAnchors(range->_GetStart(), pPropList->_paEnd) >= 0)
                continue;

            paStart = range->_GetStart();
        }
        else
        {
            paStart = pPropList->_paStart;
        }

        if (_CheckOwner(tid, paStart, pPropList->_paEnd) == TF_E_NOTOWNEDRANGE)
            return TF_E_NOTOWNEDRANGE;
    }
    // might also need to check the next span, since we rounded down
    if (!fExactEndMatch && prop->GetPropNum() > iEndEdge+1)
    {
        pPropList = prop->GetPropList(iEndEdge+1);

        IAnchor *paMaxStart;

        if (CompareAnchors(range->_GetStart(), pPropList->_paStart) >= 0)
            paMaxStart = range->_GetStart();
        else
            paMaxStart = pPropList->_paStart;

        if (CompareAnchors(range->_GetEnd(), pPropList->_paStart) > 0)
        {
            return _CheckOwner(tid, paMaxStart, range->_GetEnd());
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CheckOwner
//
//----------------------------------------------------------------------------

HRESULT CProperty::_CheckOwner(TfClientId tid, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *prop;
    BOOL fExactEndMatch;
    LONG iStartEdge;
    LONG iEndEdge;
    LONG iSpan;
    PROPERTYLIST *pPropList;
    VARIANT var;

    if ((prop = _pic->GetTextOwnerProperty()) == NULL)
        return S_OK; // no owned spans, so must be valid

    // for each owner span covered by the range, we need to make sure
    // this tip is the owner
    prop->Find(paStart, &iStartEdge, FALSE);
    fExactEndMatch = (prop->Find(paEnd, &iEndEdge, TRUE) != NULL);

    for (iSpan = max(iStartEdge, 0); iSpan <= iEndEdge; iSpan++)
    {
        pPropList = prop->QuickGetAndLoadPropList(iSpan);

        if (pPropList == NULL)
        {
            // this probably means we couldn't unserialize the data
            // just skip it
            continue;
        }

        if (iSpan == iStartEdge)
        {
            // this span may not be covered, need to check
            // only relivent case: are we entirely to the right of the span?
            if (CompareAnchors(paStart, pPropList->_paEnd) >= 0)
                continue;
        }

        if (pPropList->_pPropStore->GetData(&var) == S_OK)
        {
            Assert(var.vt == VT_I4); // this is the text owner property!
            if ((TfClientId)var.lVal != tid)
            {
                return TF_E_NOTOWNEDRANGE;
            }
        }
    }
    // might also need to check the next span, since we rounded down
    if (!fExactEndMatch && prop->GetPropNum() > iEndEdge+1)
    {
        pPropList = prop->QuickGetAndLoadPropList(iEndEdge+1);

        if (pPropList == NULL)
        {
            // this probably means we couldn't unserialize the data
            goto Exit;
        }

        if (CompareAnchors(paEnd, pPropList->_paStart) > 0)
        {
            if (pPropList->_pPropStore->GetData(&var) == S_OK)
            {
                Assert(var.vt == VT_I4); // this is the text owner property!
                if ((TfClientId)var.lVal != tid)
                {
                    return TF_E_NOTOWNEDRANGE;
                }
            }
        }
    }

Exit:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CheckTextOwner
//
//----------------------------------------------------------------------------

BOOL CProperty::_IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
{ 
    return _pic->_IsValidEditCookie(ec, dwFlags);
}

//+---------------------------------------------------------------------------
//
// SetValue
//
//----------------------------------------------------------------------------

STDAPI CProperty::SetValue(TfEditCookie ec, ITfRange *pRange, const VARIANT *pvarValue)
{
    CRange *pCRange;
    HRESULT hr;

    if (pRange == NULL)
        return E_INVALIDARG;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    if (!IsValidCiceroVarType(pvarValue->vt))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ_PROPERTY_WRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pCRange = GetCRange_NA(pRange);
    if (!pCRange)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pCRange))
        return E_INVALIDARG;

    pCRange->_QuickCheckCrossedAnchors();

    if ((hr = _CheckValidation(ec, pCRange)) != S_OK)
        return hr;

    if (IsEqualAnchor(pCRange->_GetStart(), pCRange->_GetEnd()))
        return E_INVALIDARG;

    return _SetDataInternal(ec, pCRange->_GetStart(), pCRange->_GetEnd(), pvarValue);
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

STDAPI CProperty::GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue)
{
    CRange *pCRange;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (pRange == NULL)
        return E_INVALIDARG;

    if ((pCRange = GetCRange_NA(pRange)) == NULL)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pCRange))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pCRange->_QuickCheckCrossedAnchors();

    return _GetDataInternal(pCRange->_GetStart(), pCRange->_GetEnd(), pvarValue);
}

//+---------------------------------------------------------------------------
//
// SetValueStore
//
//----------------------------------------------------------------------------

STDAPI CProperty::SetValueStore(TfEditCookie ec, ITfRange *pRange, ITfPropertyStore *pPropStore)
{
    CRange *pCRange;

    if (pRange == NULL || pPropStore == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ_PROPERTY_WRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pCRange = GetCRange_NA(pRange);
    if (!pCRange)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pCRange))
        return E_INVALIDARG;

    pCRange->_QuickCheckCrossedAnchors();

    return _SetStoreInternal(ec, pCRange, pPropStore, FALSE);
}

//+---------------------------------------------------------------------------
//
// FindRange
//
//----------------------------------------------------------------------------

STDAPI CProperty::FindRange(TfEditCookie ec, ITfRange *pRange, ITfRange **ppv, TfAnchor aPos)
{
    CRange *pCRange;
    CRange *range;
    HRESULT hr;

    if (!ppv)
        return E_INVALIDARG;

    *ppv = NULL;

    if (pRange == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    range->_QuickCheckCrossedAnchors();

    if (SUCCEEDED(hr = _InternalFindRange(range, &pCRange, aPos, FALSE)))
    {
        *ppv = (ITfRangeAnchor *)pCRange;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// FindRange
//
//----------------------------------------------------------------------------

HRESULT CProperty::_InternalFindRange(CRange *pRange, CRange **ppv, TfAnchor aPos, BOOL fEnd)
{
    PROPERTYLIST *pPropList;
    CRange *pCRange;

    //
    // Issue: need to defrag for STATICCOMPACT property.
    //
    if (pRange)
    {
        pPropList = FindPropertyListByPos((aPos == TF_ANCHOR_START) ? pRange->_GetStart() : pRange->_GetEnd(), fEnd);
    }
    else
    {
        // if pRange is NULL, we returns the first or last property.

        if (aPos == TF_ANCHOR_START)
            pPropList = GetFirstPropList();
        else
            pPropList = GetLastPropList();
    }

    *ppv = NULL;

    if (!pPropList)
        return S_FALSE;

    if ((pCRange = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!pCRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pPropList->_paStart, pPropList->_paEnd))
    {
        pCRange->Release();
        return E_FAIL;
    }

    *ppv = pCRange;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumRanges
//
//----------------------------------------------------------------------------

STDAPI CProperty::EnumRanges(TfEditCookie ec, IEnumTfRanges **ppv, ITfRange *pTargetRange)
{
    CRange *range;
    CEnumPropertyRanges *pEnum;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    range = NULL;

    if (pTargetRange != NULL)
    {
        if ((range = GetCRange_NA(pTargetRange)) == NULL)
            return E_INVALIDARG;

        if (!VerifySameContext(_pic, range))
            return E_INVALIDARG;

        range->_QuickCheckCrossedAnchors();
    }

    if ((pEnum = new CEnumPropertyRanges) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pic, range ? range->_GetStart() : NULL, range ? range->_GetEnd() : NULL, this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppv = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _Serialize
//
//----------------------------------------------------------------------------

HRESULT CProperty::_Serialize(CRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream)
{
    HRESULT hr = E_FAIL;
    CLSID clsidTIP;
    LARGE_INTEGER li;
    GUID guidProp;
    PROPERTYLIST *pPropList;

    memset(pHdr, 0, sizeof(*pHdr));

    if (_dwAuthority & PROPA_WONT_SERIALZE)
        return S_FALSE;

    // nb: this call ignores any property spans following the leftmost span covered by pRange
    // callers are expected to call for each span (which is goofy, but that's the way it is)
    pPropList = _FindPropListAndDivide(pRange->_GetStart(), pRange->_GetEnd());

    if (pPropList == NULL)
    {
        //
        // There is no actual property data.
        //
        hr = S_FALSE;
        goto Exit;
    }

    //
    // perf: we have to tell the application that the data is not 
    //       unserialized yet. maybe we don't have to load it.
    //
    if (!pPropList->_pPropStore)
    {
        if (FAILED(THR(LoadData(pPropList))))
            return E_FAIL;
    }

    Assert(pPropList->_pPropStore);

    if (FAILED(GetType(&guidProp)))
        goto Exit;

    //
    // If the request range does not match the PROPERTYLIST,
    // we can not serialize STATIC and CUSTOM correctly.
    //
    // STATICCOMPACT property does not care about boundary, so
    // let it serialize.
    //
    if (CompareAnchors(pRange->_GetStart(), pPropList->_paStart) != 0 ||
        CompareAnchors(pRange->_GetEnd(), pPropList->_paEnd) != 0)
    {
        if (_propStyle != TFPROPSTYLE_STATICCOMPACT &&
            _propStyle != TFPROPSTYLE_CUSTOM_COMPACT)
        {
            hr = S_FALSE;
            goto Exit;
        }

        pRange->_GetStart()->Clone(&pHdr->paStart);
        pRange->_GetEnd()->Clone(&pHdr->paEnd);
    }
    else
    {
        pPropList->_paStart->Clone(&pHdr->paStart);
        pPropList->_paEnd->Clone(&pHdr->paEnd);
    }

    hr = pPropList->_pPropStore->GetPropertyRangeCreator(&clsidTIP);

    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (hr == S_OK)
    {
        if (IsEqualGUID(clsidTIP, GUID_NULL)) // NULL owner means "I don't want to be serialized"
        {
            hr = S_FALSE;
            goto Exit;
        }

        //
        // Check if clsid has ITfCreatePropertyStore interface.
        //
        CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
        ITfTextInputProcessor *pIME;
        ITfCreatePropertyStore *pCreateStore;
        TfGuidAtom guidatom;

        hr = E_FAIL;

        if (FAILED(MyRegisterGUID(clsidTIP, &guidatom)))
            goto Exit;

        if (!ptim->_GetITfIMEfromGUIDATOM(guidatom, &pIME))
            goto Exit;

        if (FAILED(pIME->QueryInterface(IID_ITfCreatePropertyStore,
                                        (void **)&pCreateStore)))
        {
            hr = S_FALSE;
            goto Exit;
        }

        BOOL fSerializable = FALSE;

        Assert(pRange != NULL);

        if (FAILED(pCreateStore->IsStoreSerializable(guidProp,
                                                 (ITfRangeAnchor *)pRange, 
                                                 pPropList->_pPropStore, 
                                                 &fSerializable)))
        {
             fSerializable = FALSE;
        }

        pCreateStore->Release();

        if (!fSerializable)
        {
            hr = S_FALSE;
            goto Exit;
        }

        pHdr->clsidTIP = clsidTIP;
    }
    else if (hr == TF_S_PROPSTOREPROXY)
    {
        //
        // the data is held by our PropertyStoreProxy.
        // we don't have to check this.
        //
        pHdr->clsidTIP = clsidTIP;
    }
    else if (hr == TF_S_GENERALPROPSTORE)
    {
        //
        // the data is held by our GeneralPropertyStore.
        // we don't have to check this.
        //
        pHdr->clsidTIP = CLSID_IME_StaticProperty;
    }
    else 
    {
        Assert(0);
        hr = E_FAIL;
        goto Exit;
    }

    pHdr->guidType = guidProp;

    if (FAILED(hr = THR(pPropList->_pPropStore->GetDataType(&pHdr->dwPrivate))))
    {
        goto Exit;
    }

    GetCurrentPos(pStream, &li);

    hr = THR(pPropList->_pPropStore->Serialize(pStream, &pHdr->cb));

    // make sure the stream seek ptr is in a consistent state -- don't count
    // on any tip to do it right!
    if (hr == S_OK)
    {
        li.QuadPart += pHdr->cb;
    }
    pStream->Seek(li, STREAM_SEEK_SET, NULL);

Exit:
    if (hr != S_OK)
    {
        SafeRelease(pHdr->paStart);
        SafeRelease(pHdr->paEnd);
        memset(pHdr, 0, sizeof(*pHdr));
    }

    _Dbg_AssertProp();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

HRESULT CProperty::_Unserialize(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader)
{
    HRESULT hr = E_FAIL;
    CRange *pRange;

    if (pStream)
    {
        if (pRange = new CRange)
        {
            if (pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pHdr->paStart, pHdr->paEnd))
            {
                ITfPropertyStore *pPropStore;
                if (SUCCEEDED(hr = _GetPropStoreFromStream(pHdr, pStream, pRange, &pPropStore)))
                {
                    hr = _SetStoreInternal(BACKDOOR_EDIT_COOKIE, pRange, pPropStore, TRUE);
                    pPropStore->Release();
                }
            }
            pRange->Release();
        }
    }
    else if (pLoader)
    {
        if (pRange = new CRange)
        {
            if (pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pHdr->paStart, pHdr->paEnd))
            {
                CPropertyLoad *pPropLoad = new CPropertyLoad;

                if (pPropLoad != NULL)
                {
                    hr = E_FAIL;
                    if (pPropLoad->_Init(pHdr, pLoader))
                    {
                        hr = _SetPropertyLoaderInternal(BACKDOOR_EDIT_COOKIE, pRange, pPropLoad);
                    }

                    if (FAILED(hr))
                    {
                        delete pPropLoad;
                    }
                }
            }
            pRange->Release();
        }
    }

    _Dbg_AssertProp();

    return hr;
}
//+---------------------------------------------------------------------------
//
// _ClearChangeHistory
//
//----------------------------------------------------------------------------

void CProperty::_ClearChangeHistory(PROPERTYLIST *prop, DWORD *pdwStartHistory, DWORD *pdwEndHistory)
{
    if (prop->_paStart->GetChangeHistory(pdwStartHistory) != S_OK)
    {
        *pdwStartHistory = 0;
    }
    if (prop->_paEnd->GetChangeHistory(pdwEndHistory) != S_OK)
    {
        *pdwEndHistory = 0;
    }

    // need to clear the history so we don't deal with the after-effects
    // of a SetText more than once
    if (*pdwStartHistory != 0)
    {
        prop->_paStart->ClearChangeHistory();
    }
    if (*pdwEndHistory != 0)
    {
        prop->_paEnd->ClearChangeHistory();
    }
}

//+---------------------------------------------------------------------------
//
// _ClearChangeHistory
//
//----------------------------------------------------------------------------

#ifdef DEBUG
void CProperty::_Dbg_AssertNoChangeHistory()
{
    int i;
    PROPERTYLIST *prop;
    DWORD dwHistory;

    // all the history bits should have been cleared immediately following the text change notification
    for (i=0; i<_rgProp.Count(); i++)
    {
        prop = _rgProp.Get(i);

        prop->_paStart->GetChangeHistory(&dwHistory);
        Assert(dwHistory == 0);
        prop->_paEnd->GetChangeHistory(&dwHistory);
        Assert(dwHistory == 0);
    }
}
#endif // DEBUG

//+---------------------------------------------------------------------------
//
// FindNextValue
//
//----------------------------------------------------------------------------

STDAPI CProperty::FindNextValue(TfEditCookie ec, ITfRange *pRangeQueryIn, TfAnchor tfAnchorQuery,
                                DWORD dwFlags, BOOL *pfContained, ITfRange **ppRangeNextValue)
{
    CRange *pRangeQuery;
    CRange *pRangeNextValue;
    IAnchor *paQuery;
    PROPERTYLIST *pPropertyList;
    LONG iIndex;
    BOOL fSearchForward;
    BOOL fContained;
    BOOL fExactMatch;

    if (pfContained != NULL)
    {
        *pfContained = FALSE;
    }
    if (ppRangeNextValue != NULL)
    {
        *ppRangeNextValue = NULL;
    }
    if (pfContained == NULL || ppRangeNextValue == NULL)
         return E_INVALIDARG;

    if (pRangeQueryIn == NULL)
         return E_INVALIDARG;

    if (dwFlags & ~(TF_FNV_BACKWARD | TF_FNV_NO_CONTAINED))
         return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
        return TF_E_NOLOCK;

    if ((pRangeQuery = GetCRange_NA(pRangeQueryIn)) == NULL)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pRangeQuery))
        return E_INVALIDARG;

    fSearchForward = !(dwFlags & TF_FNV_BACKWARD);

    pRangeQuery->_QuickCheckCrossedAnchors();

    paQuery = (tfAnchorQuery == TF_ANCHOR_START) ? pRangeQuery->_GetStart() : pRangeQuery->_GetEnd();

    fExactMatch = (Find(paQuery, &iIndex, fSearchForward) != NULL);

    if (fSearchForward)
    {
        if (++iIndex >= _rgProp.Count())
            return S_OK; // no next value
    }
    else
    {
        if (fExactMatch)
        {
            --iIndex;
        }
        if (iIndex < 0)
            return S_OK; // no prev value
    }

    pPropertyList = _rgProp.Get(iIndex);
    Assert(pPropertyList != NULL);

    fContained = (CompareAnchors(pPropertyList->_paStart, paQuery) <= 0) &&
                 (CompareAnchors(pPropertyList->_paEnd, paQuery) >= 0);

    if (fContained && (dwFlags & TF_FNV_NO_CONTAINED))
    {
        // caller wants to skip any contained value span
        if (fSearchForward)
        {
            if (++iIndex >= _rgProp.Count())
                return S_OK; // no next value
        }
        else
        {
            if (--iIndex == -1)
                return S_OK; // no prev value
        }

        pPropertyList = _rgProp.Get(iIndex);
        Assert(pPropertyList != NULL);

        fContained = FALSE;
    }

    if ((pRangeNextValue = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!pRangeNextValue->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pPropertyList->_paStart, pPropertyList->_paEnd))
    {
        pRangeNextValue->Release();
        return E_FAIL;
    }

    *pfContained = fContained;
    *ppRangeNextValue = (ITfRangeAnchor *)pRangeNextValue;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rprange.cpp ===
//
// rprange.cpp
//

#include "private.h"
#include "ic.h"
#include "rprop.h"
#include "range.h"
#include "tim.h"
#include "rngsink.h"
#include "immxutil.h"

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

HRESULT CProperty::_GetDataInternal(IAnchor *paStart, IAnchor *paEnd, VARIANT *pvarValue)
{
    HRESULT hr;
    PROPERTYLIST *pPropList;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    pPropList = _FindPropList(paStart, paEnd);

    if (pPropList)
    {
        if (!pPropList->_pPropStore)
        {
            if (FAILED(hr = LoadData(pPropList)))
                goto Exit;
        }

        hr = pPropList->_pPropStore->GetData(pvarValue);
    }
    else
    {
        // property has no value over the range
        hr = S_FALSE;
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// _SetStoreInternal
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetStoreInternal(TfEditCookie ec, CRange *pRange, ITfPropertyStore *pPropStore, BOOL fInternal)
{
    GUID guidStore;

    if (pPropStore == NULL)
        return E_INVALIDARG;

    if (!fInternal)
    {
        //
        // Make sure this property is not using System's StaticPropStore.
        //
        if (GetPropStyle() != TFPROPSTYLE_CUSTOM && GetPropStyle() != TFPROPSTYLE_CUSTOM_COMPACT)
            return E_FAIL;
    }

    if (IsEqualAnchor(pRange->_GetStart(), pRange->_GetEnd()))
        return E_INVALIDARG;

    //
    // Check type of PropertyStore.
    //
    if (FAILED(pPropStore->GetType(&guidStore)))
        return E_FAIL;

    if (!MyIsEqualTfGuidAtom(GetPropGuidAtom(), guidStore))
        return E_FAIL;

    return Set(pRange->_GetStart(), pRange->_GetEnd(), pPropStore);
}


//+---------------------------------------------------------------------------
//
// _SetDataInternal
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetDataInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd, const VARIANT *pvarValue)
{
    CGeneralPropStore *store;
    HRESULT hr;

    Assert(!IsEqualAnchor(paStart, paEnd)); // caller should have checked

    switch (GetPropStyle())
    {
        case TFPROPSTYLE_STATIC:
        case TFPROPSTYLE_STATICCOMPACT:
            if ((store = new CStaticPropStore) == NULL)
                return E_OUTOFMEMORY;

            break;

        case TFPROPSTYLE_CUSTOM:
        case TFPROPSTYLE_CUSTOM_COMPACT:
            //
            // This property is not using System's StaticPropStore.
            // so we use a default range property sink.
            //
            if ((store = new CGeneralPropStore) == NULL)
                return E_OUTOFMEMORY;

            break;

        default:
            Assert(0); // bogus style!
            return E_UNEXPECTED;
    }

    if (!store->_Init(GetPropGuidAtom(), pvarValue, _dwPropFlags))
    {
        store->Release();
        return E_FAIL;
    }

    hr = Set(paStart, paEnd, store);
    store->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
// ClearInternal
//
//----------------------------------------------------------------------------

HRESULT CProperty::_ClearInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pPropertyList;
    LONG nCur;

    if (paStart != NULL)
    {
        Assert(paEnd != NULL);

        if (IsEqualAnchor(paStart, paEnd))
            return S_OK;

        Clear(paStart, paEnd, 0, FALSE);

        Find(paStart, &nCur, FALSE);
        if (nCur >= 0)
            _DefragAfterThis(nCur);
    }
    else
    {
        // Clear(NULL, NULL) means wipe all instances
        for (nCur=0; nCur<_rgProp.Count(); nCur++)
        {
            pPropertyList = _rgProp.Get(nCur);

            if (CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd) <= 0)
            {
                PropertyUpdated(pPropertyList->_paStart, pPropertyList->_paEnd);
            }
            else
            {
                // crossed anchors
                PropertyUpdated(pPropertyList->_paEnd, pPropertyList->_paEnd);
            }
            _FreePropertyList(pPropertyList);
        }
        _rgProp.Clear();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _FindPropList
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindPropList(IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pPropList;
    LONG nCur;

    if (CompareAnchors(paStart, paEnd) == 0)
        return NULL;

    //
    // The range does not have to be exactly matched.
    // we can return pPropList covers the given range.
    //

    Find(paStart, &nCur, FALSE);
    if (nCur < 0)
        return NULL;

    pPropList = SafeGetPropList(nCur);
    if (!pPropList)
    {
        Assert(0);
        return NULL;
    }

    Assert(CompareAnchors(paStart, pPropList->_paStart) >= 0);
    if (CompareAnchors(paEnd, pPropList->_paEnd) <= 0)
        return pPropList;

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _FindPropListAndDivide
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindPropListAndDivide(IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pPropList = NULL;
    LONG nCur;
    ITfPropertyStore *pNewPropStore;
    IAnchor *paTmp = NULL;
    BOOL fExactMatch;
    HRESULT hr;

    if (CompareAnchors(paStart, paEnd) == 0)
        return NULL;

    fExactMatch = (Find(paStart, &nCur, FALSE) != NULL);
    if (nCur < 0)
        goto Exit;

    pPropList = SafeGetPropList(nCur);
    if (!pPropList)
    {
        Assert(0);
        goto Exit;
    }

    if (_propStyle == TFPROPSTYLE_STATICCOMPACT ||
        _propStyle == TFPROPSTYLE_CUSTOM_COMPACT)
    {
        Assert(CompareAnchors(paStart, pPropList->_paStart) >= 0);
        if (CompareAnchors(paEnd, pPropList->_paEnd) <= 0)
            return pPropList;

        pPropList = NULL;
        goto Exit;
    }

    if (!fExactMatch)
    {
        if (CompareAnchors(paStart, pPropList->_paEnd) >= 0)
        {
            // query span begins at or after pPropList end-of-span
        
            // is there a following property?
            if ((pPropList = SafeGetPropList(nCur+1)) == NULL)
                goto Exit;
        
            // there is, does the query span cover it?
            if (CompareAnchors(paEnd, pPropList->_paStart) <= 0)
            {
                pPropList = NULL;
                goto Exit; // nope
            }

            // okay, our left edge will be the start of the following property
        }
        else
        {
            Assert(CompareAnchors(paStart, pPropList->_paStart) > 0);

            pNewPropStore = NULL;
            hr = pPropList->_paEnd->Clone(&paTmp);
            if (FAILED(hr) || !paTmp)
            {
                pPropList = NULL;
                goto Exit;
            }

            hr = _Divide(pPropList, paStart, paStart, &pNewPropStore);
            if ((hr == S_OK) && pNewPropStore)
            {
                _CreateNewProp(paStart, 
                               paTmp, 
                               pNewPropStore, 
                               NULL);

                pNewPropStore->Release();
            }
            else
            {
                pPropList = NULL;
                goto Exit;
            }

            pPropList = Find(paStart, NULL, FALSE);
            if (!pPropList)
            {
                Assert(0);
                goto Exit;
            }
        }
    }
    Assert(CompareAnchors(paStart, pPropList->_paStart) == 0);

    SafeReleaseClear(paTmp);

    if (CompareAnchors(paEnd, pPropList->_paEnd) < 0)
    {
        pNewPropStore = NULL;
        hr = pPropList->_paEnd->Clone(&paTmp);
        if (FAILED(hr) || !paTmp)
        {
            pPropList = NULL;
            goto Exit;
        }

        hr = _Divide(pPropList, paEnd, paEnd, &pNewPropStore);
        if ((hr == S_OK) && pNewPropStore)
        {
            _CreateNewProp(paEnd, 
                           paTmp, 
                           pNewPropStore, 
                           NULL);

            pNewPropStore->Release();
        }
        else
        {
            pPropList = NULL;
            goto Exit;
        }

        pPropList = Find(paStart, NULL, FALSE);
        if (!pPropList)
        {
            Assert(0);
            goto Exit;
        }
    }

    Assert(CompareAnchors(paStart, pPropList->_paStart) == 0);
    Assert(CompareAnchors(paEnd, pPropList->_paEnd) == 0);

Exit:
    SafeRelease(paTmp);
    return pPropList;
}

//+---------------------------------------------------------------------------
//
// SetPropertyLoader
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetPropertyLoaderInternal(TfEditCookie ec, CRange *pRange, CPropertyLoad *pPropLoad)
{
    if (IsEqualAnchor(pRange->_GetStart(), pRange->_GetEnd()))
        return S_OK;

    return SetLoader(pRange->_GetStart(), pRange->_GetEnd(), pPropLoad);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\saa.cpp ===
//
// saa.cpp
//
// CSharedAnchorArray
//

#include "private.h"
#include "saa.h"
#include "immxutil.h"

//+---------------------------------------------------------------------------
//
// _MergeSort
//
// NB: rgArrays is freed before the method exits.
//     Caller must release the out array.
//
// perf: some possible optimizations:
//       quick check if the arrays don't overlap
//       find some way to anticipate dups
//----------------------------------------------------------------------------

/* static */
CSharedAnchorArray *CSharedAnchorArray::_MergeSort(CSharedAnchorArray **rgArrays, ULONG cArrays)
{
    LONG l;
    IAnchor *pa;
    IAnchor **ppaDst;
    IAnchor **ppa1;
    IAnchor **ppaEnd1;
    IAnchor **ppa2;
    IAnchor **ppaEnd2;
    CSharedAnchorArray *prgAnchors1 = NULL;
    CSharedAnchorArray *prgAnchors2 = NULL;
    CSharedAnchorArray *prgAnchors = NULL;
    BOOL fRet = FALSE;
    
    // recursion
    if (cArrays > 2)
    {
        if (cArrays == 3)
        {
            // avoid unnecessary mem alloc here
            prgAnchors1 = rgArrays[0];
        }
        else
        {
            prgAnchors1 =  _MergeSort(rgArrays, cArrays / 2);
        }
        prgAnchors2 = _MergeSort(rgArrays + cArrays / 2, cArrays - cArrays / 2);
    }
    else
    {
        Assert(cArrays == 2);
        prgAnchors1 = rgArrays[0];
        prgAnchors2 = rgArrays[1];
    }

    // check for out-of-mem after the recursion, so we at least free the entire source array
    if (prgAnchors1 == NULL || prgAnchors2 == NULL)
        goto Exit;

    // allocate some memory
    // perf: we could do something complicated and do everything in place
    if ((prgAnchors = new CSharedAnchorArray) == NULL)
        goto Exit;

    if (prgAnchors1->Count() + prgAnchors2->Count() == 0)
    {
        Assert(!prgAnchors->Count());
        fRet = TRUE;
        goto Exit;
    }

    if (!prgAnchors->Append(prgAnchors1->Count() + prgAnchors2->Count()))
        goto Exit;

    // the actual combination
    ppaDst = prgAnchors->GetPtr(0);
    ppa1 = prgAnchors1->GetPtr(0);
    ppa2 = prgAnchors2->GetPtr(0);
    ppaEnd1 = prgAnchors1->GetPtr(prgAnchors1->Count());
    ppaEnd2 = prgAnchors2->GetPtr(prgAnchors2->Count());

    // do a one pass merge sort -- both prgAnchors1 and prgAnchors2 are sorted already
    while (ppa1 < ppaEnd1 ||
           ppa2 < ppaEnd2)
    {
        if (ppa1 < ppaEnd1)
        {
            if (ppa2 < ppaEnd2)
            {
                l = CompareAnchors(*ppa1, *ppa2);
                if (l < 0)
                {
                    pa = *ppa1++;
                }
                else if (l > 0)
                {
                    pa = *ppa2++;
                }
                else // equal
                {
                    pa = *ppa1++;
                    (*ppa2++)->Release();
                }
            }
            else
            {
                pa = *ppa1++;
            }
        }
        else // ppa2 < ppaEnd2
        {
            pa = *ppa2++;
        }

        *ppaDst++ = pa;
    }

    // taking ownership, so no AddRef
    // clear the elems counts so we don't Release in the destructors
    prgAnchors1->SetCount(0);
    prgAnchors2->SetCount(0);
    // we might have removed dups, so calc a new size
    prgAnchors->SetCount((int)(ppaDst - prgAnchors->GetPtr(0)));

    fRet = TRUE;

Exit:
    if (prgAnchors1 != NULL)
    {
        prgAnchors1->_Release();
    }
    if (prgAnchors2 != NULL)
    {
        prgAnchors2->_Release();
    }
    if (!fRet)
    {
        if (prgAnchors != NULL)
        {
            prgAnchors->_Release();
        }
        prgAnchors = NULL;
    }

    return prgAnchors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "cresstr.h"
#include "tim.h"
#include "imelist.h"
#include "utb.h"
#include "dam.h"
#include "catmgr.h"
#include "nuimgr.h"
#include "profiles.h"
#include "msaa.h"

//
//  DWORD value for TIP Categories.
//  This will be an sort order of UI.
//
#define ORDER_TFCAT_TIP_KEYBOARD      10
#define ORDER_TFCAT_TIP_SPEECH        11
#define ORDER_TFCAT_TIP_HANDWRITING   12
#define ORDER_TFCAT_TIP_REFERENCE     13
#define ORDER_TFCAT_TIP_PROOFING      14
#define ORDER_TFCAT_TIP_SMARTTAG      15

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_ThreadMgr, CThreadInputMgr, TEXT("TF_ThreadMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_InputProcessorProfiles, CInputProcessorProfiles, TEXT("TF_InputProcessorProfiles"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_LangBarMgr, CLangBarMgr, TEXT("TF_LangBarMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_DisplayAttributeMgr, CDisplayAttributeMgr, TEXT("TF_DisplayAttributeMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_CategoryMgr, CCategoryMgr, TEXT("TF_CategoryMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_LangBarItemMgr, CLangBarItemMgr_Ole, TEXT("TF_LangBarItemMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_MSAAControl, CMSAAControl, TEXT("TF_MSAAControl"))
END_COCLASSFACTORY_TABLE

//+---------------------------------------------------------------------------
//
//  DllGetClassObject
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    return COMBase_DllGetClassObject(rclsid, riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  DllCanUnloadNow
//
//----------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    return COMBase_DllCanUnloadNow();
}

//+---------------------------------------------------------------------------
//
//  DllRegisterServer
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
    HRESULT hr = COMBase_DllRegisterServer();

    if (hr == S_OK)
    {
        MyRegisterCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY, GUID_PROP_ATTRIBUTE);
        MyRegisterGUIDDescription(GUID_PROP_ATTRIBUTE, CRStr(IDS_PROP_ATTRIBUTE));

        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_KEYBOARD);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SPEECH);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_HANDWRITING);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_REFERENCE);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_PROOFING);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SMARTTAG);
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_KEYBOARD, CRStr(IDS_TFCAT_TIP_KEYBOARD));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_SPEECH, CRStr(IDS_TFCAT_TIP_SPEECH));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_HANDWRITING, CRStr(IDS_TFCAT_TIP_HANDWRITING));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_REFERENCE, CRStr(IDS_TFCAT_TIP_REFERENCE));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_PROOFING, CRStr(IDS_TFCAT_TIP_PROOFING));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_SMARTTAG, CRStr(IDS_TFCAT_TIP_SMARTTAG));
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_KEYBOARD, ORDER_TFCAT_TIP_KEYBOARD);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_SPEECH, ORDER_TFCAT_TIP_SPEECH);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_HANDWRITING, ORDER_TFCAT_TIP_HANDWRITING);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_REFERENCE, ORDER_TFCAT_TIP_REFERENCE);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_PROOFING, ORDER_TFCAT_TIP_PROOFING);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_SMARTTAG, ORDER_TFCAT_TIP_SMARTTAG);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = COMBase_DllUnregisterServer();

    if (hr == S_OK)
    {
        MyUnregisterCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY, GUID_PROP_ATTRIBUTE);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_KEYBOARD);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SPEECH);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_HANDWRITING);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_REFERENCE);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_PROOFING);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SMARTTAG);

        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_KEYBOARD);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_SPEECH);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_HANDWRITING);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_REFERENCE);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_PROOFING);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_SMARTTAG);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_KEYBOARD);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_SPEECH);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_HANDWRITING);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_REFERENCE);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_PROOFING);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_SMARTTAG);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\saa.h ===
//
// saa.h
//
// CSharedAnchorArray
//

#ifndef SAA_H
#define SAA_H

#include "ptrary.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CSharedAnchorArray
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CSharedAnchorArray : public CPtrArray<IAnchor>
{
public:
    CSharedAnchorArray() : CPtrArray<IAnchor>() { _cRef = 1; };

    void _AddRef()
    { 
        _cRef++;
    }

    void _Release()
    {   
        int i;

        Assert(_cRef > 0);

        if (--_cRef == 0)
        {
            for (i=0; i<Count(); i++)
            {
                SafeRelease(Get(i));
            }
            delete this;
        }
    }

    static CSharedAnchorArray *_MergeSort(CSharedAnchorArray **rgArrays, ULONG cArrays);

private:
    ULONG _cRef;
};

#endif // SAA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\rprop.h ===
//
// rprop.h
//

#ifndef RPROP_H
#define RPROP_H

#include "private.h"
#include "strary.h"
#include "spans.h"
#include "tfprop.h"
#include "ptrary.h"

// for dwPropFlags of CProperty and CGeneralPropStore
#define PROPF_ACCEPTCORRECTION   0x00000001
#define PROPF_VTI4TOGUIDATOM     0x00000002
#define PROPF_MARKUP_COLLECTION  0x00000004 // property is member of a display attr markup collection

class CRange;
class CEnumProperties;

class CPropertyLoad
{
public:
    CPropertyLoad() {}

    ~CPropertyLoad()
    {
        SafeRelease(_pLoader);
        SafeRelease(_hdr.paStart);
        SafeRelease(_hdr.paEnd);
    }

    BOOL _Init(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phdr, ITfPersistentPropertyLoaderAnchor *pLoader)
    {
        _hdr = *phdr;

        _hdr.paStart = NULL;
        _hdr.paEnd = NULL;
        Assert(_pLoader == NULL);

        if (phdr->paStart->Clone(&_hdr.paStart) != S_OK)
        {
            _hdr.paStart = NULL;
            return FALSE;
        }
        if (phdr->paEnd->Clone(&_hdr.paEnd) != S_OK)
        {
            _hdr.paEnd = NULL;
            return FALSE;
        }

        _pLoader = pLoader;
        _pLoader->AddRef();

        return TRUE;
    }

    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR _hdr;
    ITfPersistentPropertyLoaderAnchor *_pLoader;
};

typedef struct tag_PROPERTYLIST
{
  IAnchor *_paStart;
  IAnchor *_paEnd;
  ITfPropertyStore *_pPropStore;
  CPropertyLoad *_pPropLoad;
} PROPERTYLIST;

const DWORD PROPA_NONE          =  0;
const DWORD PROPA_TEXTOWNER     =  1;
const DWORD PROPA_FOCUSRANGE    =  2;
const DWORD PROPA_READONLY      =  4;
const DWORD PROPA_WONT_SERIALZE =  8;

// 
// Property Styles
//
typedef enum { 
    TFPROPSTYLE_NULL = 0x0, 
    TFPROPSTYLE_STATIC = 0x1, 
    TFPROPSTYLE_STATICCOMPACT = 0x2, 
    TFPROPSTYLE_CUSTOM = 0x3,
    TFPROPSTYLE_CUSTOM_COMPACT = 0x4
} TFPROPERTYSTYLE;

class CInputContext;
class CPropertySub;

// nb: if anything else derived from ITfProperty ever supports
// Unserialize, we'll need to have a shared abstract base class
// to that privately exposed the Unserialize method (or something
// equivalent...)
extern const IID IID_PRIV_CPROPERTY;

class CProperty : public ITfProperty2,
                  public CComObjectRootImmx
{
public:
    CProperty(CInputContext *pic, REFGUID guidProp, TFPROPERTYSTYLE propStyle, DWORD  dwAuthority, DWORD dwPropFlags);
    ~CProperty();

    BEGIN_COM_MAP_IMMX(CProperty)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CPROPERTY, CProperty)
        COM_INTERFACE_ENTRY(ITfReadOnlyProperty)
        COM_INTERFACE_ENTRY(ITfProperty)
        COM_INTERFACE_ENTRY(ITfProperty2)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfProperty2
    STDMETHODIMP EnumRanges(TfEditCookie ec, IEnumTfRanges **ppv, ITfRange *pTargetRange);
    STDMETHODIMP FindRange(TfEditCookie ec, ITfRange *pRange, ITfRange **ppv, TfAnchor aPos);
    STDMETHODIMP GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue);
    STDMETHODIMP SetValueStore(TfEditCookie ec, ITfRange *pRange, ITfPropertyStore *pPropStore);
    STDMETHODIMP SetValue(TfEditCookie ec, ITfRange *pRange, const VARIANT *pvarValue);
    STDMETHODIMP Clear(TfEditCookie ec, ITfRange *pRange);
    STDMETHODIMP GetContext(ITfContext **ppContext);
    STDMETHODIMP FindNextValue(TfEditCookie ec, ITfRange *pRangeQuery, TfAnchor tfAnchorQuery, DWORD dwFlags, BOOL *pfContained, ITfRange **ppRangeNextValue);

    //
    // ITfPropertyCommon
    //
    STDMETHODIMP GetType(GUID *pType);
    STDMETHODIMP GetStyle(TFPROPERTYSTYLE *propStyle);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    HRESULT ForceLoad();
    void Clear(IAnchor *paStart, IAnchor *paEnd, DWORD dwFlags, BOOL fTextUpdate);

    HRESULT SetLoader(IAnchor *paStart, IAnchor *paEnd, CPropertyLoad *pPropLoad);

    TFPROPERTYSTYLE GetPropStyle() {return _propStyle;}

    BOOL Defrag(IAnchor *paStart, IAnchor *paEnd);

    TfGuidAtom GetPropGuidAtom() {return _guidatom;}

    CProperty *_pNext;
    CInputContext *_pic;
    TFPROPERTYSTYLE _propStyle;

    int GetPropNum() 
    {
        return _rgProp.Count();
    }
    PROPERTYLIST * GetFirstPropList() 
    {
        if (_rgProp.Count())
            return _rgProp.Get(0);
        return NULL;
    }
    PROPERTYLIST * GetLastPropList() 
    {
        int nCnt;
        if (nCnt = _rgProp.Count())
            return _rgProp.Get(nCnt - 1);
        return NULL;
    }
    PROPERTYLIST *QuickGetPropList(int iIndex)
    {
        return _rgProp.Get(iIndex);
    }
    PROPERTYLIST * GetPropList(int nCnt) 
    {
        if (nCnt < 0)
            return NULL;
        return _rgProp.Get(nCnt);
    }

    PROPERTYLIST *SafeGetPropList(int nCur)
    {
        int nCnt = _rgProp.Count();

        if (nCur >= nCnt)
        {
            return NULL;
        }
        else if (nCur > 0)
        {
            return _rgProp.Get(nCur);
        }
        else
        {
            return _rgProp.Get(0);
        }
    }

    // return the property list, or NULL if the data cannot be loaded
    PROPERTYLIST *QuickGetAndLoadPropList(int iIndex)
    {
        PROPERTYLIST *pPropList = _rgProp.Get(iIndex);
        
        if (pPropList->_pPropStore != NULL)
            return pPropList;

        LoadData(pPropList);

        return (pPropList->_pPropStore != NULL) ? pPropList : NULL;
    }

    PROPERTYLIST *Find(IAnchor *pa, LONG *piOut, BOOL fEnd)
    {
        return _FindComplex(pa, piOut, fEnd, FALSE /* fTextUpdate */);
    }
    PROPERTYLIST *FindPropertyListByPos(IAnchor *paPos, BOOL fEnd);
    HRESULT LoadData(PROPERTYLIST *pPropList);

    DWORD GetValidation() {return _dwAuthority;}

    HRESULT _SetDataInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd, const VARIANT *pvarValue);
    HRESULT _ClearInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd);

    HRESULT _Serialize(CRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream);
    HRESULT _Unserialize(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader);

    HRESULT _InternalFindRange(CRange *pRange, CRange **ppv, TfAnchor aPos, BOOL fEnd);

    PROPERTYLIST *_FindPropList(IAnchor *paStart, IAnchor *paEnd);
    PROPERTYLIST *_FindPropListAndDivide(IAnchor *paStart, IAnchor *paEnd);
    HRESULT _SetStoreInternal(TfEditCookie ec, CRange *pRange, ITfPropertyStore *pPropStore, BOOL fInternal);

    CSpanSet *_GetSpanSet() { return _pss; }
    void _ClearSpanSet() { _pss = NULL; }
    void _ResetSpanSet() { _pss->Reset(); }

    HRESULT _GetDataInternal(IAnchor *paStart, IAnchor *paEnd, VARIANT *pvarValue);

#ifdef DEBUG
    void _Dbg_AssertNoChangeHistory();
    GUID _dbg_guid;
#else
    void _Dbg_AssertNoChangeHistory() {}
#endif // DEBUG

private:

    PROPERTYLIST *_FindComplex(IAnchor *pa, LONG *piOut, BOOL fEnd, BOOL fTextUpdate);
    PROPERTYLIST *_FindUpdateTouchup(IAnchor *pa, int *piMid, BOOL fEnd);

    void _ClearOneSpan(IAnchor *paStart, IAnchor *paEnd, int iIndex, BOOL fStartMatchesSpanEnd, BOOL fEndMatchesSpanStart, DWORD dwFlags, BOOL fTextUpdate);
    BOOL _OnTextUpdate(DWORD dwFlags, PROPERTYLIST *pPropertyList, IAnchor *paStart, IAnchor *paEnd);
    void _MovePropertySpans(int iDst, int iSrc, int iCount);
    BOOL _ClearFirstLastSpan(BOOL fFirst, BOOL fMatchesSpanEdge,
                             IAnchor *paStart, IAnchor *paEnd, PROPERTYLIST *pPropertyList,
                             DWORD dwFlags, BOOL fTextUpdate, BOOL *pfSkipNextOnTextUpdate);

    void _ClearChangeHistory(PROPERTYLIST *prop, DWORD *pdwStartHistory, DWORD *pdwEndHistory);

    HRESULT Set(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore);

    CSpanSet *_CreateSpanSet()
    {
        if (_pss == NULL)
        {
            _pss = new CSpanSet;
        }
        return _pss;
    }

    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags);

    PROPERTYLIST *_CreateNewProp(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad);
    void _FreePropertyList(PROPERTYLIST *pProp);
    HRESULT _SetNewExtent(PROPERTYLIST *pProp, IAnchor *paStart, IAnchor *paEnd, BOOL fNew);
    HRESULT _Divide(PROPERTYLIST *pProp, IAnchor *paBreakPtStart, IAnchor *paBreakPtEnd, ITfPropertyStore **ppStore);
    void _RemoveProp(LONG iIndex, PROPERTYLIST *pProp);
    BOOL _InsertPropList(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad);
    BOOL _AddIntoProp(int nCur, IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore);
    void _DefragAfterThis(int nCur);

    HRESULT _SetPropertyLoaderInternal(TfEditCookie ec, CRange *pRange, CPropertyLoad *pPropLoad);

    HRESULT _GetPropStoreFromStream(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, CRange *pRange, ITfPropertyStore **ppStore);

    HRESULT _CheckValidation(TfEditCookie ec, CRange *pRange);

    HRESULT _CheckOwner(TfClientId tid, IAnchor *paStart, IAnchor *paEnd);

    TfGuidAtom _guidatom;

    CPtrArray<PROPERTYLIST> _rgProp;

    //
    // if we use CSpanSet to record the deltas.
    //
    void PropertyUpdated(IAnchor *paStart, IAnchor *paEnd);
    CSpanSet *_pss;

    DWORD _dwCookie;
    DWORD _dwAuthority;
    DWORD _dwPropFlags;

#ifdef DEBUG
    void _Dbg_AssertProp();
#else
    void _Dbg_AssertProp() {}
#endif
    DBG_ID_DECLARE;
};


inline CProperty *GetCProperty(IUnknown *pProp)
{
    CProperty *pPropP;

    pProp->QueryInterface(IID_PRIV_CPROPERTY, (void **)&pPropP);

    return pPropP;
}

#endif // RPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\smblock.cpp ===
//
// smblock.cpp
//

#include "private.h"
#include "globals.h"
#include "marshal.h"
#include "smblock.h"
#include "osver.h"

#define MAXHEAPSIZE      0x00080000
#define INITIALHEAPSIZE  0x00002000
#define RESETHEAPSIZE    0x00008000

const char c_szShared[] = "MSCTF.Shared.";

//////////////////////////////////////////////////////////////////////////////
//
// func
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  EnsureSharedHeap
//
//--------------------------------------------------------------------------

CSharedHeap *EnsureSharedHeap(SYSTHREAD *psfn)
{
    Assert(psfn);

    if (psfn->psheap)
        return psfn->psheap;

    DWORD dwThread = GetCurrentThreadId();

    psfn->psheap = new CSharedHeap(dwThread);
    if (!psfn->psheap)
        return NULL;

    if (FAILED(psfn->psheap->Init(NULL, INITIALHEAPSIZE, MAXHEAPSIZE)))
    {
        delete psfn->psheap;
        psfn->psheap = NULL;
    }

    return psfn->psheap;
}

//--------------------------------------------------------------------------
//
//  DestroySharedHeap
//
//--------------------------------------------------------------------------

void DestroySharedHeap(SYSTHREAD *psfn)
{
    Assert(psfn);

    if (!psfn->psheap)
        return;

    delete psfn->psheap;
    psfn->psheap = NULL;
}

//--------------------------------------------------------------------------
//
//  EnsureSharedBlockForThread
//
//--------------------------------------------------------------------------

#define MAX_THREAD_NUM 15

CSharedBlock *EnsureSharedBlockForThread(SYSTHREAD *psfn, DWORD dwThreadId)
{
    int nCnt;
    int i;
    CSharedBlock *psb = NULL;
    Assert(psfn);

    if (!psfn->prgThreadMem)
        psfn->prgThreadMem = new CPtrArray<CSharedBlock>;

    if (!psfn->prgThreadMem)
        return NULL;


    nCnt = psfn->prgThreadMem->Count();
    for (i = 0; i < nCnt; i++)
    {
        psb = psfn->prgThreadMem->Get(i);
        if (psb->GetThreadId() == dwThreadId)
        {
            //
            // this thread mem was found in the 2nd half of this list.
            // we don't have to reorder this entry.
            //
            if (nCnt < (MAX_THREAD_NUM) / 2 || (i >= (nCnt / 2)))
                goto Exit;

            //
            // reorder this entry.
            //
            psfn->prgThreadMem->Remove(i,1);
            goto SetPSB;
        }
    }

#ifndef _WIN64
    if (!IsOnNT())
        psb = new CSharedBlock9x(c_szShared, dwThreadId);
    else
#endif
        psb = new CSharedBlockNT(c_szShared, dwThreadId, FALSE);

    if (!psb)
        return NULL;

    if (FAILED(psb->Init(NULL, 0, 0, NULL, FALSE)))
    {
        delete psb;
        return NULL;
    }

SetPSB:
    if (psfn->prgThreadMem->Count() >= MAX_THREAD_NUM)
    {
        //
        // delete the oldest thread mem entry.
        //
        CSharedBlock *psbTemp = psfn->prgThreadMem->Get(0);
        psfn->prgThreadMem->Remove(0, 1);
        delete psbTemp;
    }

    CSharedBlock **ppsb = psfn->prgThreadMem->Append(1);
    if (!ppsb)
    {
        delete psb;
        return NULL;
        
    }

    *ppsb = psb;
Exit:
    return psb;
}

//--------------------------------------------------------------------------
//
//  DestroySharedBlocks
//
//--------------------------------------------------------------------------

void DestroySharedBlocks(SYSTHREAD *psfn)
{
    int nCnt;
    int i;
    CSharedBlock *psb = NULL;
    Assert(psfn);

    if (!psfn->prgThreadMem)
        return;

    nCnt = psfn->prgThreadMem->Count();
    for (i = 0; i < nCnt; i++)
    {
        psb = psfn->prgThreadMem->Get(i);
        delete psb;
    }

    delete psfn->prgThreadMem;
    psfn->prgThreadMem = NULL;
    return;
}


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlockNT
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CSharedBlockNT::CSharedBlockNT(const char *pszPrefix, DWORD dwThread, BOOL fUseUniqueName) : CSharedBlock(pszPrefix, dwThread)
{
    _fUseUniqueName = fUseUniqueName;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CSharedBlockNT::~CSharedBlockNT()
{
    if (_pvBase)
        UnmapViewOfFile(_pvBase);

    if (_hfm)
        CloseHandle(_hfm);

    TraceMsg(TF_GENERAL, "CSharedBlock dtor");
    TraceMsg(TF_GENERAL, "    _dwThread           0x%08x", _dwThread);
    TraceMsg(TF_GENERAL, "    _ulInitCommitSize   0x%08x", _ulInitCommitSize);
    TraceMsg(TF_GENERAL, "    _ulCommitSize       0x%08x", _ulCommitSize);
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

HRESULT CSharedBlockNT::Init(SECURITY_DESCRIPTOR *pSecDes,
                           ULONG ulSize,
                           ULONG ulCommitSize,
                           void *pvBase,
                           BOOL fCreate,
                           BOOL *pfAlreadyExists)
{
    char szName[MAX_PATH];
    char szObjName[MAX_PATH];
    StringCopyArray(szName, _pszPrefix);
    int nLen = lstrlen(szName);

    if (!SetName(&szName[nLen], ARRAYSIZE(szName) - nLen, SZSHAREDMUTEX, _dwThread))
        return E_FAIL;

    if (_fUseUniqueName)
    {
        GetDesktopUniqueNameArray(szName, szObjName);
    }
    else
        StringCchCopy(szObjName, ARRAYSIZE(szObjName), szName);

    CCicSecAttr sa;
    if (!_mutex.Init(sa, szObjName))
        return E_FAIL;

    if (!SetName(&szName[nLen], ARRAYSIZE(szName) - nLen, SZSHAREDFILEMAP, _dwThread))
        return E_FAIL;

    if (_fUseUniqueName)
    {
        GetDesktopUniqueNameArray(szName, szObjName);
    }
    else
        StringCchCopy(szObjName, ARRAYSIZE(szObjName), szName);

    if (fCreate)
    {
        CCicSecAttr saFileMapping;
        _hfm = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                 saFileMapping, 
                                 PAGE_READWRITE | SEC_RESERVE,
                                 0, 
                                 ulSize, 
                                 szObjName);

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = (GetLastError() == ERROR_ALREADY_EXISTS);
        }

    }
    else
    {
        _hfm = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, szObjName);

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = _hfm ? TRUE : FALSE;
        }
    }

    if (_hfm == NULL)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Init: Open/CreateFileMapping failed");
        Assert(!fCreate);

        return E_OUTOFMEMORY;
    }

    _pvBase = (void *)MapViewOfFile(_hfm, 
                                    FILE_MAP_WRITE, 
                                    0, 
                                    0, 
                                    0);

    if (!_pvBase)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Init: MapVieOfFile failed");
        return E_OUTOFMEMORY;
    }


    if (fCreate)
    {
        void *pvResult;
        pvResult = VirtualAlloc(_pvBase, 
                                ulCommitSize, 
                                MEM_COMMIT, 
                                PAGE_READWRITE);

        if (!pvResult)
        {
            TraceMsg(TF_GENERAL, "CSharedBlock Init: VirtualAlloc failed");
            CloseHandle(_hfm);
            _hfm = NULL;
            return E_OUTOFMEMORY;
        }
    }

    _ulCommitSize = ulCommitSize;
    _ulInitCommitSize = ulCommitSize;

    return S_OK;
}


//--------------------------------------------------------------------------
//
//  GetPtrFromBlockId
//
//--------------------------------------------------------------------------

void *CSharedBlockNT::GetPtrFromBlockId(ULONG ulBlockId) 
{
    if (((CSharedHeap::HEAPHDR *)_pvBase)->ulSize <= ulBlockId)
    {
        Assert(0);
        return NULL;
    }

    return GetPtr(ulBlockId);
}

//--------------------------------------------------------------------------
//
//  Commit
//
//--------------------------------------------------------------------------

HRESULT CSharedBlockNT::Commit(ULONG ulNewSize)
{
    void *pv;


    Assert(ulNewSize >= _ulCommitSize);
    if (ulNewSize == _ulCommitSize)   
        return S_OK;

    pv = VirtualAlloc(_pvBase, ulNewSize, MEM_COMMIT, PAGE_READWRITE);

    if (!pv)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Commit: VirtualAlloc failed");
        return E_OUTOFMEMORY;
    }

    _ulCommitSize = ulNewSize;
    return S_OK;
}

//--------------------------------------------------------------------------
//
//  Reset
//
//--------------------------------------------------------------------------

HRESULT CSharedBlockNT::Reset()
{
    void *pv;

    Assert(_ulCommitSize >= _ulInitCommitSize);
    if (_ulCommitSize == _ulInitCommitSize)   
        return S_FALSE;

    VirtualFree(_pvBase, _ulCommitSize, MEM_DECOMMIT);

    pv = VirtualAlloc(_pvBase, _ulInitCommitSize, MEM_COMMIT, PAGE_READWRITE);

    if (!pv)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Reset: VirtualAlloc failed");
        return E_OUTOFMEMORY;
    }

    TraceMsg(TF_GENERAL, "CSharedBlock Reset");
    TraceMsg(TF_GENERAL, "    Old _ulCommitSize  0x%08x", _ulCommitSize);
    TraceMsg(TF_GENERAL, "    New _ulCommitSize  0x%08x", _ulInitCommitSize);

    _ulCommitSize = _ulInitCommitSize;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlock9x
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _WIN64

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CSharedBlock9x::CSharedBlock9x(const char *pszPrefix, DWORD dwThread) : CSharedBlock(pszPrefix, dwThread)
{
    _hsheap = NULL;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CSharedBlock9x::~CSharedBlock9x()
{
    if (_pvBase)
        HeapFree(_hsheap, 0, _pvBase);

    if (_hsheap)
        HeapDestroy(_hsheap);

    TraceMsg(TF_GENERAL, "CSharedBlock 9x dtor");
    TraceMsg(TF_GENERAL, "    _dwThread           0x%08x", _dwThread);
    TraceMsg(TF_GENERAL, "    _ulInitCommitSize   0x%08x", _ulInitCommitSize);
    TraceMsg(TF_GENERAL, "    _ulCommitSize       0x%08x", _ulCommitSize);
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

HRESULT CSharedBlock9x::Init(SECURITY_DESCRIPTOR *pSecDes,
                             ULONG ulSize,
                             ULONG ulCommitSize,
                             void *pvBase,
                             BOOL fCreate,
                             BOOL *pfAlreadyExists)
{
    char szName[MAX_PATH];
    StringCopyArray(szName, _pszPrefix);
    UINT uLen = lstrlen(szName);

    if (!SetName(&szName[uLen], ARRAYSIZE(szName) - uLen, SZSHAREDMUTEX, _dwThread))
        return E_FAIL;

    CCicSecAttr sa;
    if (!_mutex.Init(sa, szName))
        return E_FAIL;

    if (fCreate)
    {
        _hsheap = HeapCreate(0x04000000, ulCommitSize + 0x100, 0);

        if ( _hsheap == NULL )
            return E_FAIL;

        _pvBase = HeapAlloc(_hsheap, 0, ulCommitSize);

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = TRUE;
        }
    }
    else
    {
        _hsheap = NULL;
        _pvBase = NULL;

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = FALSE;
        }
    }

    _ulCommitSize = ulCommitSize;
    _ulInitCommitSize = ulCommitSize;
    return S_OK;
}


//--------------------------------------------------------------------------
//
//  Commit
//
//--------------------------------------------------------------------------

HRESULT CSharedBlock9x::Commit(ULONG ulNewSize)
{
    void *pvNew;
    pvNew = HeapReAlloc(_hsheap, 0, _pvBase, ulNewSize);

    if (!pvNew)
    {
        HeapFree(_hsheap, 0, _pvBase);
        _pvBase = NULL;
        return E_OUTOFMEMORY;
    }

    TraceMsg(TF_GENERAL, "Commit  0x%08x", ulNewSize);
    _pvBase = pvNew;
    _ulCommitSize = ulNewSize;
    return S_OK;
}

//--------------------------------------------------------------------------
//
//  Reset
//
//--------------------------------------------------------------------------

HRESULT CSharedBlock9x::Reset()
{
    Assert(_ulCommitSize >= _ulInitCommitSize);
    if (_ulCommitSize == _ulInitCommitSize)   
        return S_FALSE;

    HeapFree(_hsheap, 0, _pvBase);
    _pvBase = HeapAlloc(_hsheap, 0, _ulInitCommitSize);
    if (!_pvBase)
        return E_OUTOFMEMORY;

    _ulCommitSize = _ulInitCommitSize;

    return S_OK;
}
#endif // !_WIN64


//////////////////////////////////////////////////////////////////////////////
//
// CSharedHeap
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CSharedHeap::CSharedHeap(DWORD dwThread)
{
    _dwThread = dwThread;
    _psb = NULL;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CSharedHeap::~CSharedHeap()
{
#ifdef DEBUG
    if (_psb->GetBase())
    {
        HEAPHDR *phhdr = (HEAPHDR *)_psb->GetPtr(0);
        BLOCKHDR *pbhdr = (BLOCKHDR *)_psb->GetPtr(phhdr->ulList);
        Assert(pbhdr->IsFree());
        Assert(pbhdr->ulNext == (-1));
    }
#endif

    if (_psb)
        delete _psb;
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

HRESULT CSharedHeap::Init(SECURITY_DESCRIPTOR *pSecDes,
                          ULONG ulInitSize,
                          ULONG ulMaxSize)
{
    HRESULT hr;

#ifndef _WIN64
    if (!IsOnNT())
        _psb = new CSharedBlock9x(c_szShared, _dwThread);
    else
#endif
        _psb = new CSharedBlockNT(c_szShared, _dwThread, FALSE);

    if (!_psb)
        return E_OUTOFMEMORY;

    hr = _psb->Init(pSecDes, ulMaxSize, ulInitSize, NULL, TRUE);
    if (FAILED(hr))
        return E_FAIL;

    InitHeap(ulInitSize);
    return S_OK;
}

//--------------------------------------------------------------------------
//
//  InitHeap
//
//--------------------------------------------------------------------------

void CSharedHeap::InitHeap(ULONG ulInitSize)
{
    BYTE *pb;
    HEAPHDR *phhdr;
    BLOCKHDR *pbhdr;

    //
    // init heap header.
    //
    pb = (BYTE *)_psb->GetPtr(0);
    phhdr = (HEAPHDR *)pb;
    phhdr->ulList = _psb->GetOffset(pb + sizeof(HEAPHDR));
    phhdr->ulSize = ulInitSize;

    //
    // init first block
    //
    pb = (BYTE *)_psb->GetPtr(phhdr->ulList);
    pbhdr = (BLOCKHDR *)pb;
    pbhdr->ulPrev = 0;
    pbhdr->ulNext = -1;
    pbhdr->SetFree(TRUE);
    pbhdr->SetSize(ulInitSize - _psb->GetOffset(pb + sizeof(BLOCKHDR)) & ~0x1f);

    _dbg_HeapCheck();
}

//--------------------------------------------------------------------------
//
//  Alloc
//
//--------------------------------------------------------------------------

void *CSharedHeap::Alloc(ULONG ulSize)
{
    BYTE *pb;
    HEAPHDR *phhdr;
    BLOCKHDR *pbhdr = NULL;
    ULONG ulCur;
    BOOL fFound = FALSE;
    BOOL fHeapIncreased = FALSE;
    void *pvRet = NULL;
    
    if (!GetBlock()->GetMutex()->Enter())
        return NULL;

    _dbg_HeapCheck();

    ulSize += 0x0000001F;
    ulSize &= (ULONG)(-0x20);

    pb = (BYTE *)_psb->GetPtr(0);
    phhdr = (HEAPHDR *)pb;

TryAgain:
    ulCur = phhdr->ulList;

    while (ulCur != -1)
    {
        pbhdr = (BLOCKHDR *)_psb->GetPtr(ulCur);
        if (pbhdr->IsFree() && (pbhdr->GetSize() >= ulSize))
        {
            fFound = TRUE;
            break;
        }
        ulCur = pbhdr->ulNext;
    }

    if (!fFound)
    {
        if (!pbhdr)
        {
            pvRet = NULL;
            goto Exit;
        }

        Assert(pbhdr->ulNext == (-1));

        if (fHeapIncreased)
        {
            pvRet = NULL;
            goto Exit;
        }

        if (FAILED(_psb->Commit(_psb->GetCommitSize() + ulSize)))
        {
            pvRet = NULL;
            goto Exit;
        }

        phhdr->ulSize += ulSize;
        pbhdr->SetSize(pbhdr->GetSize() + ulSize);
        fHeapIncreased = TRUE;
        goto TryAgain;
    }

    Assert(pbhdr->GetSize() >= ulSize);
    if (pbhdr->GetSize() < (ulSize + 32 + sizeof(BLOCKHDR)))
    {
        pbhdr->SetFree(FALSE);
    }
    else
    {
        pbhdr->SetFree(FALSE);
        pbhdr->SetSize(ulSize);
    
        BLOCKHDR *pbhdrNext = (BLOCKHDR *)((BYTE *)pbhdr->GetPtr() + ulSize);
        pbhdrNext->ulNext = pbhdr->ulNext;
        pbhdrNext->ulPrev = _psb->GetOffset(pbhdr);
        pbhdr->ulNext = _psb->GetOffset(pbhdrNext);
        ULONG ulNewSize;
        if (pbhdrNext->ulNext != (-1))
             ulNewSize = pbhdrNext->ulNext - pbhdr->ulNext - sizeof(BLOCKHDR);
        else
             ulNewSize = (_psb->GetCommitSize() - 
                          _psb->GetOffset((BYTE*)pbhdrNext + sizeof(BLOCKHDR))) & ~0x1f;

        pbhdrNext->SetSize(ulNewSize);
        pbhdrNext->SetFree(TRUE);
        BLOCKHDR *pbhdrNextNext = (BLOCKHDR *)((BYTE *)pbhdrNext->GetPtr() + ulNewSize);
        pbhdrNextNext->ulPrev = _psb->GetOffset(pbhdrNext);

    }

    _dbg_HeapCheck();

    pvRet = pbhdr->GetPtr();
Exit:
    GetBlock()->GetMutex()->Leave();
    return pvRet;
}

//--------------------------------------------------------------------------
//
//  Realloc
//
//--------------------------------------------------------------------------

#ifdef LATER
void *CSharedHeap::Realloc(void *pv, ULONG ulSize)
{
    if (!_psb->IsValidPtr(pv))
    {
        Assert(0);
        return NULL;
    }

    if (!GetBlock()->GetMutex()->Enter())
        return NULL;

    void *pvRet = NULL;

    BLOCKHDR *pbhdr = (BLOCKHDR *)((BYTE *)pv - sizeof(BLOCKHDR));
    if (pbhdr->GetSize() >= ulSize)
    {
        pvRet = pv;
        goto Exit;
    }

    //
    // perf: This should be smart!!
    //
    pvRet = Alloc(ulSize);
    if (pvRet)
    {
        memcpy(pvRet, pv, pbhdr->GetSize());
    }
    Free(pv);

Exit:
    GetBlock()->GetMutex()->Leave();
    return pvRet;
}
#endif


//--------------------------------------------------------------------------
//
//  Free
//
//--------------------------------------------------------------------------

BOOL CSharedHeap::Free(void *pv)
{
    if (!_psb->IsValidPtr(pv))
    {
        Assert(0);
        return FALSE;
    }

    if (!GetBlock()->GetMutex()->Enter())
        return FALSE;

    BOOL bRet = FALSE;
    _dbg_HeapCheck();

    HEAPHDR *phhdr;
    BLOCKHDR *pbhdr = (BLOCKHDR *)((BYTE *)pv - sizeof(BLOCKHDR));

    //
    // do nothing for free block.
    //
    if (pbhdr->IsFree())
    {
        Assert(0);
        goto Exit;
    }

    pbhdr->SetFree(TRUE);
    MergeFreeBlock(pbhdr);

    if (pbhdr->ulPrev)
    {
        BLOCKHDR *pbhdrPrev = (BLOCKHDR *)_psb->GetPtr(pbhdr->ulPrev);
        if (pbhdrPrev->IsFree())
            MergeFreeBlock(pbhdrPrev);
    }

    //
    // if we don't have any mem block, it is time to recommit the block.
    //
    phhdr = (HEAPHDR *)_psb->GetPtr(0);
    pbhdr = (BLOCKHDR *)_psb->GetPtr(phhdr->ulList);
    if (pbhdr->ulNext == (-1))
    {
        if (_psb->GetCommitSize() > RESETHEAPSIZE)
        {
            HRESULT hr = _psb->Reset();
            if (FAILED(hr))
            {
                Assert(0);
                goto Exit;
            }

            if (hr == S_OK)
                InitHeap(_psb->GetInitCommitSize());
        }
    }

    bRet = TRUE;
Exit:
    _dbg_HeapCheck();

    GetBlock()->GetMutex()->Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  MergeFreeBlock
//
//--------------------------------------------------------------------------

void CSharedHeap::MergeFreeBlock(BLOCKHDR *pbhdr)
{
    BLOCKHDR *pbhdrNext = (BLOCKHDR *)_psb->GetPtr(pbhdr->ulNext);
    BLOCKHDR *pbhdrNewNext = NULL;


    if (pbhdrNext->IsFree())
    {
        ULONG ulNewSize;
        pbhdr->ulNext = pbhdrNext->ulNext;

        if (pbhdr->ulNext != (-1))
        {
            pbhdrNewNext = (BLOCKHDR *)_psb->GetPtr(pbhdr->ulNext);
            // ulNewSize = pbhdrNewNext->ulNext - pbhdr->ulNext - sizeof(BLOCKHDR);
            ulNewSize = ((DWORD)(DWORD_PTR)((BYTE *)pbhdrNewNext - (BYTE *)pbhdr) - sizeof(BLOCKHDR));
            pbhdrNewNext->ulPrev = _psb->GetOffset(pbhdr);
        }
        else
        {
            ulNewSize = (_psb->GetCommitSize() - 
                          _psb->GetOffset((BYTE*)pbhdrNext + sizeof(BLOCKHDR))) & ~0x1f;
        }

        pbhdr->SetSize(ulNewSize);
    }

}

//--------------------------------------------------------------------------
//
//  IsValidBlock
//
//--------------------------------------------------------------------------

BOOL CSharedHeap::IsValidBlock(CSharedBlock *psb, void *pv)
{
    BOOL fFound = FALSE;

    //
    // On Win9x, we use system shared heap _psb does not have a pointer..
    // How can we valid the block??
    //
    if (!IsOnNT())
        return TRUE;

    _try 
    {
        BLOCKHDR *pbhdr = (BLOCKHDR *)((BYTE *)pv - sizeof(BLOCKHDR));
        BYTE *pb;
        HEAPHDR *phhdr;
        ULONG ulCur;
    
        pb = (BYTE *)psb->GetPtr(0);
        phhdr = (HEAPHDR *)pb;
        ulCur = phhdr->ulList;
    
        while (ulCur != -1)
        {
            BLOCKHDR *pbhdrTmp = (BLOCKHDR *)psb->GetPtr(ulCur);
    
            if (pbhdrTmp == pbhdr)
            {
                fFound = TRUE;
                break;
            }
            ulCur = pbhdrTmp->ulNext;
        }
    }
    _except(1)
    {
        Assert(0);
    }

    return fFound;

}


//--------------------------------------------------------------------------
//
//  _dbg_HeapCheck()
//
//--------------------------------------------------------------------------

#ifdef DEBUG
void CSharedHeap::_dbg_HeapCheck()
{
    HEAPHDR *phhdr = (HEAPHDR *)_psb->GetPtr(0);
    BLOCKHDR *pbhdr = NULL;
    BLOCKHDR *pbhdrPrev = NULL;
    ULONG ulCur = phhdr->ulList;

    while (ulCur != -1)
    {
        Assert(!(ulCur & CIC_ALIGNMENT));

        pbhdr = (BLOCKHDR *)_psb->GetPtr(ulCur);

        if (pbhdrPrev)
        {
            Assert(_psb->GetOffset(pbhdrPrev) == pbhdr->ulPrev);
            Assert(_psb->GetPtr(pbhdrPrev->ulNext) == pbhdr);
            Assert(pbhdrPrev->ulSize == 
                   ((BYTE *)pbhdr - (BYTE *)pbhdrPrev - sizeof(BLOCKHDR)));

            Assert(!pbhdrPrev->IsFree() || !pbhdr->IsFree());
        }
        else
        {
            Assert(!pbhdr->ulPrev);
        }

        pbhdrPrev = pbhdr;
        ulCur = pbhdr->ulNext;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\smblock.h ===
//
// smblock.h
//

#ifndef SMBLOCK_H
#define SMBLOCK_H

#include "private.h"
#include "cicmutex.h"

#define SZSHAREDFILEMAP    __TEXT("SFM.")
#define SZSHAREDMUTEX      __TEXT("MUTEX.")

class CSharedHeap9x;

//////////////////////////////////////////////////////////////////////////////
//
// instead of wsprintf
//
//////////////////////////////////////////////////////////////////////////////

#define ONEDWORDCCHFORSETNAME 9

__inline BOOL SetName(TCHAR *pszDst, UINT cchDst, const TCHAR *pszSrc, DWORD dw)
{
    TCHAR *psz;
    StringCchCopy(pszDst, cchDst, pszSrc);
    psz = pszDst + lstrlen(pszDst);

    if (cchDst < (UINT)(psz - pszDst)/sizeof(TCHAR) + ONEDWORDCCHFORSETNAME)
    {
        Assert(0);
        return FALSE;
    }

    while (dw)
    {
        *psz = 'A' + ((char)dw & 0x0F);
        dw >>= 4;
        psz++;
    }

    *psz = '\0';
    return TRUE;
}

__inline BOOL SetName2(TCHAR *pszDst, UINT cchDst, const TCHAR *pszSrc, DWORD dw, DWORD dw2, DWORD dw3 = 0)
{
    TCHAR *psz;
    StringCchCopy(pszDst, cchDst, pszSrc);
    psz = pszDst + lstrlen(pszDst);

    if (cchDst < (UINT)(psz - pszDst)/sizeof(TCHAR) + 
                 ONEDWORDCCHFORSETNAME * 2 + 
                 (dw3 ? ONEDWORDCCHFORSETNAME : 0))
    {
        Assert(0);
        return FALSE;
    }
    
    while (dw)
    {
        *psz = 'A' + ((char)dw & 0x0F);
        dw >>= 4;
        psz++;
    }

    *psz = '.';
    psz++;

    while (dw2)
    {
        *psz = 'A' + ((char)dw2 & 0x0F);
        dw2 >>= 4;
        psz++;
    }

    if (dw3)
    {
        *psz = '.';
        psz++;

        while (dw3)
        {
            *psz = 'A' + ((char)dw3 & 0x0F);
            dw3 >>= 4;
            psz++;
        }
    }

    *psz = '\0';
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//
// func
//
//////////////////////////////////////////////////////////////////////////////

CSharedHeap *EnsureSharedHeap(SYSTHREAD *psfn);
void DestroySharedHeap(SYSTHREAD *psfn);
CSharedBlock *EnsureSharedBlockForThread(SYSTHREAD *psfn, DWORD dwThreadId);
void DestroySharedBlocks(SYSTHREAD *psfn);

//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlock
//
//////////////////////////////////////////////////////////////////////////////

class CSharedBlock
{
public:
    CSharedBlock(const char *pszPrefix, DWORD dwThread) 
    {
        _pszPrefix = pszPrefix; 
        _dwThread = dwThread; 
    }

    virtual ~CSharedBlock() 
    {
        _mutex.Uninit();
    }

    virtual HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                         ULONG ulSize,
                         ULONG ulCommitSize,
                         void *pvBase,
                         BOOL fCreate,
                         BOOL *pfAlreadyExists = NULL) = 0;
    virtual HRESULT Commit(ULONG ulNewSize) = 0;
    virtual HRESULT Reset() = 0;

    void *GetBase() {return _pvBase;}
    virtual void *GetPtr(ULONG ulOffset)  = 0;
    virtual void *GetPtrFromBlockId(ULONG ulBlockId)  = 0;
    virtual BOOL IsValidPtr(void *pv) = 0;

    ULONG GetOffset(void *pv)
    {
        return (ULONG)((BYTE *)pv - (BYTE *)_pvBase);
    }

    ULONG GetCommitSize()
    {
        return _ulCommitSize;
    }

    ULONG GetInitCommitSize()
    {
        return _ulInitCommitSize;
    }
    DWORD GetThreadId()
    {
        return _dwThread;
    }

    CCicMutex *GetMutex()
    {
        return &_mutex;
    }

protected:
    void *_pvBase;
    ULONG _ulCommitSize;
    ULONG _ulInitCommitSize;
    CCicMutex _mutex;
    DWORD _dwThread;
    const char *_pszPrefix;
};


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlockNT
//
//////////////////////////////////////////////////////////////////////////////

class CSharedBlockNT : public CSharedBlock
{
public:
    CSharedBlockNT(const char *pszPrefix, DWORD dwThread, BOOL fUseUniqueName);
    ~CSharedBlockNT();

    HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                 ULONG ulSize,
                 ULONG ulCommitSize,
                 void *pvBase,
                 BOOL fCreate,
                 BOOL *pfAlreadyExists);

    HRESULT Commit(ULONG ulNewSize);
    HRESULT Reset();

    void *GetPtrFromBlockId(ULONG ulBlockId);

    void *GetPtr(ULONG ulOffset) 
    {
        return (void *)(((BYTE *)_pvBase) + ulOffset);
    }
  
    BOOL IsValidPtr(void *pv)
    {
        if (pv < _pvBase)
            return FALSE;

        if (pv > (BYTE *)_pvBase + _ulCommitSize)
            return FALSE;

        return TRUE;
    }


private:
    HANDLE _hfm;
    BOOL _fUseUniqueName;
};


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlock9x
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _WIN64
class CSharedBlock9x : public CSharedBlock
{
public:
    CSharedBlock9x(const char *pszPrefix, DWORD dwThread);
    ~CSharedBlock9x();

    HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                 ULONG ulSize,
                 ULONG ulCommitSize,
                 void *pvBase,
                 BOOL fCreate,
                 BOOL *pfAlreadyExists);

    HRESULT Commit(ULONG ulNewSize);
    HRESULT Reset();

    void *GetPtrFromBlockId(ULONG ulOffset) 
    {
        Assert(ulOffset >= 0x80000000);
        return (void *)ulOffset;
    }

    void *GetPtr(ULONG ulOffset) 
    {
        return (void *)(((BYTE *)_pvBase) + ulOffset);
    }

private:
friend CSharedHeap9x;
    BOOL IsValidPtr(void *pv)
    {
         if (!_hsheap || !pv)
             return FALSE;
         // return HeapValid(_hsheap, 0, pv);
         return TRUE;
    }
    HANDLE _hsheap;
};
#endif // !_WIN64

//////////////////////////////////////////////////////////////////////////////
//
// CShraedHeap
//
//////////////////////////////////////////////////////////////////////////////

#define BLK_FREE   0x01

class CSharedHeap 
{
public:
    CSharedHeap(DWORD dwThread);
    ~CSharedHeap();


    HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                 ULONG ulSize,
                 ULONG ulCommitSize);

    void *Alloc(ULONG ulSize);
#ifdef LATER
    void *Realloc(void *pv, ULONG ulSize);
#endif
    BOOL Free(void *pv);

    ULONG GetBlockId(void *pv)
    {
#ifndef _WIN64
        if (!IsOnNT())
            return (ULONG)pv;
#endif
        return _psb->GetOffset(pv);
    }

    CSharedBlock *GetBlock()
    {
        return _psb;
    }

    static BOOL IsValidBlock(CSharedBlock *psb, void *pv);

    typedef struct tag_HEAPHDR {
        ULONG ulList;
        ULONG ulSize;
    } HEAPHDR;

private:
    void InitHeap(ULONG ulInitSize);

    typedef struct tag_BLOCKHDR {
        ULONG ulPrev;
        ULONG ulNext;
        ULONG ulSize;
        ULONG ulFlags;
        ULONG u[4];

        ULONG GetSize() 
        {
            return ulSize;
        }

        void SetSize(ULONG ulNewSize) 
        {
            Assert(!(ulNewSize & 0x001f));
            ulSize = ulNewSize;
        }

        void SetFree(BOOL fFree)
        {
            if (fFree)
                ulFlags |= BLK_FREE;
            else
                ulFlags &= ~BLK_FREE;
        }

        BOOL IsFree()
        {
            return (ulFlags & BLK_FREE) ? TRUE : FALSE;
        }

        void *GetPtr()
        {
            BYTE *pb = (BYTE *)this;
            return pb + sizeof(tag_BLOCKHDR);
        }

    } BLOCKHDR;

    void MergeFreeBlock(BLOCKHDR *pbhdr);

#ifdef DEBUG
    void _dbg_HeapCheck();
#else
    void _dbg_HeapCheck() {};
#endif

    CSharedBlock *_psb;
    DWORD _dwThread;
};

#endif // SMBLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\systhrd.h ===
//
// systhrd.h
//

#ifndef SYSTHRD_H
#define SYSTHRD_H

#include "globals.h"

class CSysThreadRef
{
public:
    CSysThreadRef(SYSTHREAD *psfn)
    {
        Assert(psfn);
        _psfn = psfn;
    }


protected:
    SYSTHREAD *_psfn;
};

#endif // SYSTHRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\sunka.h ===
//
// sunka.h
//
// CSharedUnknownArray/CEnumUnknown
//

#ifndef SUNKA_H
#define SUNKA_H

// I would love to make this a class,
// but I can't get the compiler to accept a run-time template arg
typedef struct _SHARED_UNKNOWN_ARRAY
{
    ULONG cRef;
    ULONG cUnk;
    IUnknown *rgUnk[1]; // one or more...
} SHARED_UNKNOWN_ARRAY;

inline void SUA_AddRef(SHARED_UNKNOWN_ARRAY *pua)
{
    pua->cRef++;
}

void SUA_Release(SHARED_UNKNOWN_ARRAY *pua);

SHARED_UNKNOWN_ARRAY *SUA_Init(ULONG cUnk, IUnknown **prgUnk);

inline SHARED_UNKNOWN_ARRAY *SUA_Alloc(ULONG cUnk)
{
    return (SHARED_UNKNOWN_ARRAY *)cicMemAlloc(sizeof(SHARED_UNKNOWN_ARRAY)+sizeof(IUnknown)*cUnk-sizeof(IUnknown));
}

inline BOOL SUA_ReAlloc(SHARED_UNKNOWN_ARRAY **ppua, ULONG cUnk)
{
    SHARED_UNKNOWN_ARRAY *pua;

    pua = (SHARED_UNKNOWN_ARRAY *)cicMemReAlloc(*ppua, sizeof(SHARED_UNKNOWN_ARRAY)+sizeof(IUnknown)*cUnk-sizeof(IUnknown));
    
    if (pua != NULL)
    {
        *ppua = pua;
        return TRUE;
    }

    return FALSE;
}

class __declspec(novtable) CEnumUnknown
{
public:
    CEnumUnknown() {}
    virtual ~CEnumUnknown();

    // derived class supplies an _Init() method here
    // It must initialize:
    //      _iCur
    //      _prgUnk
    //
    // the default dtor will clean these guys up.

    void Clone(CEnumUnknown *pClone);
    HRESULT Next(ULONG ulCount, IUnknown **ppUnk, ULONG *pcFetched);
    HRESULT Reset();
    HRESULT Skip(ULONG ulCount);

protected:
    SHARED_UNKNOWN_ARRAY *_prgUnk;
    int _iCur;
};

#define DECLARE_SUNKA_ENUM(sunka_enum_iface, sunka_enumerator_class, sunka_enumed_iface)    \
    STDMETHODIMP Clone(sunka_enum_iface **ppEnum)                                           \
    {                                                                                       \
        sunka_enumerator_class *pClone;                                                     \
                                                                                            \
        if (ppEnum == NULL)                                                                 \
            return E_INVALIDARG;                                                            \
                                                                                            \
        *ppEnum = NULL;                                                                     \
                                                                                            \
        if ((pClone = new sunka_enumerator_class) == NULL)                                  \
            return E_OUTOFMEMORY;                                                           \
                                                                                            \
        CEnumUnknown::Clone(pClone);                                                        \
                                                                                            \
        *ppEnum = pClone;                                                                   \
        return S_OK;                                                                        \
    }                                                                                       \
    STDMETHODIMP Next(ULONG ulCount, sunka_enumed_iface **ppClass, ULONG *pcFetched)        \
    {                                                                                       \
        return CEnumUnknown::Next(ulCount, (IUnknown **)ppClass, pcFetched);                \
    }                                                                                       \
    STDMETHODIMP Reset()                                                                    \
    {                                                                                       \
        return CEnumUnknown::Reset();                                                       \
    }                                                                                       \
    STDMETHODIMP Skip(ULONG ulCount)                                                        \
    {                                                                                       \
        return CEnumUnknown::Skip(ulCount);                                                 \
    }

#endif // SUNKA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\sunka.cpp ===
//
// sunka.cpp
//
// CEnumUnknown
//

#include "private.h"
#include "sunka.h"


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// SHARED_UNKNOWN_ARRAY
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// SUA_Init
//
//----------------------------------------------------------------------------

SHARED_UNKNOWN_ARRAY *SUA_Init(ULONG cUnk, IUnknown **prgUnk)
{
    SHARED_UNKNOWN_ARRAY *pua;

    pua = (SHARED_UNKNOWN_ARRAY *)cicMemAlloc(sizeof(SHARED_UNKNOWN_ARRAY)+sizeof(IUnknown)*cUnk-sizeof(IUnknown));

    if (pua == NULL)
        return NULL;

    pua->cRef = 1;
    pua->cUnk = cUnk;

    while (cUnk-- > 0)
    {
        pua->rgUnk[cUnk] = prgUnk[cUnk];
        pua->rgUnk[cUnk]->AddRef();
    }

    return pua;
}

//+---------------------------------------------------------------------------
//
// SUA_Release
//
//----------------------------------------------------------------------------

void SUA_Release(SHARED_UNKNOWN_ARRAY *pua)
{
    ULONG i;

    Assert(pua->cRef > 0);
    if (--pua->cRef == 0)
    {
        for (i=0; i<pua->cUnk; i++)
        {
            SafeRelease(pua->rgUnk[i]);
        }
        cicMemFree(pua);
    }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumUnknown
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumUnknown::~CEnumUnknown()
{
    if (_prgUnk != NULL)
    {
        SUA_Release(_prgUnk);
    }
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

void CEnumUnknown::Clone(CEnumUnknown *pClone)
{
    pClone->_iCur = _iCur;
    pClone->_prgUnk = _prgUnk;
    SUA_AddRef(pClone->_prgUnk);
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumUnknown::Next(ULONG ulCount, IUnknown **ppUnk, ULONG *pcFetched)
{
    ULONG cFetched;

    if (ulCount > 0 && ppUnk == NULL)
        return E_INVALIDARG;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }

    *pcFetched = 0;

    while ((ULONG)_iCur < _prgUnk->cUnk && *pcFetched < ulCount)
    {
        *ppUnk = _prgUnk->rgUnk[_iCur];
        (*ppUnk)->AddRef();

        ppUnk++;
        *pcFetched = *pcFetched + 1;
        _iCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumUnknown::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumUnknown::Skip(ULONG ulCount)
{
    _iCur += ulCount;

    if ((ULONG)_iCur >= _prgUnk->cUnk)
    {
        _iCur = _prgUnk->cUnk; // prevent overflow for repeated calls
        return S_FALSE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tfprop.h ===
//
// tfprop.h
//

#ifndef TFPROP_H
#define TFPROP_H

#include "mem.h"

typedef struct _PROXY_BLOB
{
    ULONG cb;
    BYTE rgBytes[1]; // 0 or more...

    static struct _PROXY_BLOB *Alloc(ULONG cb)
    {
        return (struct _PROXY_BLOB *)cicMemAlloc(sizeof(ULONG)+cb);
    }

    static struct _PROXY_BLOB *Clone(struct _PROXY_BLOB *blobOrg)
    {
        struct _PROXY_BLOB *blobNew;

        if ((blobNew = Alloc(blobOrg->cb)) == NULL)
            return FALSE;

        blobNew->cb = blobOrg->cb;
        memcpy(blobNew->rgBytes, blobOrg->rgBytes, blobOrg->cb);

        return blobNew;
    }

    static void Free(struct _PROXY_BLOB *blob)
    {
        cicMemFree(blob);
    }

} PROXY_BLOB;

typedef enum
{
    TF_PT_NONE               = 0,
    TF_PT_UNKNOWN            = 1,
    TF_PT_DWORD              = 2,
    TF_PT_GUID               = 3,
    TF_PT_BSTR               = 4
} TfPropertyType;

typedef struct tagTFPROPERTY
{
    TfPropertyType type;
    union
    {
        IUnknown *           punk;
        DWORD                dw;
        TfGuidAtom           guidatom;
        BSTR                 bstr;
        PROXY_BLOB *         blob;
    };
} TFPROPERTY;

inline BOOL IsValidCiceroVarType(VARTYPE vt)
{
    return (vt == VT_I4 || vt == VT_UNKNOWN || vt == VT_EMPTY || vt == VT_BSTR);
}

typedef enum { ADDREF, NO_ADDREF } AddRefCmd;

inline HRESULT VariantToTfProp(TFPROPERTY *ptfp, const VARIANT *pvar, AddRefCmd arc, BOOL fVTI4ToGuidAtom)
{
    HRESULT hr = S_OK;

    switch (pvar->vt)
    {
        case VT_I4:
            if (fVTI4ToGuidAtom)
                ptfp->type = TF_PT_GUID;
            else
                ptfp->type = TF_PT_DWORD;
            ptfp->dw = pvar->lVal;
            break;

        case VT_UNKNOWN:
            ptfp->type = TF_PT_UNKNOWN;
            ptfp->punk = pvar->punkVal;
            if (arc == ADDREF)
            {
                if (ptfp->punk)
                    ptfp->punk->AddRef();
            }
            break;

        case VT_BSTR:
            ptfp->type = TF_PT_BSTR;
            ptfp->bstr = SysAllocString(pvar->bstrVal);
            if (ptfp->bstr == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            break;

        default:
            Assert(pvar->vt == VT_EMPTY); // only valid value left
            ptfp->type = TF_PT_NONE;
            ptfp->dw = 0;
            break;
    }

    return hr;
}

inline HRESULT TfPropToVariant(VARIANT *pvar, TFPROPERTY *ptfp, AddRefCmd arc)
{
    HRESULT hr = S_OK;

    QuickVariantInit(pvar);

    switch (ptfp->type)
    {
        case TF_PT_DWORD:
        case TF_PT_GUID:
            pvar->vt = VT_I4;
            pvar->lVal = ptfp->dw;
            break;

        case TF_PT_UNKNOWN:
            pvar->vt = VT_UNKNOWN;
            pvar->punkVal = ptfp->punk;
            if (arc == ADDREF)
            {
                if (pvar->punkVal)
                    pvar->punkVal->AddRef();
            }
            break;

        case TF_PT_BSTR:
            pvar->vt = VT_BSTR;
            if (arc == ADDREF)
            {
                pvar->bstrVal = SysAllocString(ptfp->bstr);
                if (pvar->bstrVal == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
                pvar->bstrVal = ptfp->bstr;
            break;

        default:
            Assert(ptfp->type == TF_PT_NONE);
            pvar->lVal = 0;
            break;
    }

    return hr;
}

inline VARTYPE TfPropTypeToVarType(TfPropertyType tftype)
{
    switch (tftype)
    {
        case TF_PT_DWORD:
        case TF_PT_GUID:
            return VT_I4;

        case TF_PT_UNKNOWN:
            return VT_UNKNOWN;

        case TF_PT_BSTR:
            return VT_BSTR;

        default:
            Assert(tftype == TF_PT_NONE);
            return VT_EMPTY;
    }
}

#endif // TFPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\spans.h ===
//
// spans.h
//
// CSpanSet
//

#ifndef SPANS_H
#define SPANS_H

#include "private.h"
#include "strary.h"
#include "globals.h"

typedef struct
{
    IAnchor *paStart;
    IAnchor *paEnd;
    DWORD dwFlags;
} SPAN;

class CSpanSet
{
public:
    CSpanSet()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CSpanSet"), PERF_SPANSET_COUNTER);
    }
    virtual ~CSpanSet() 
    { 
        Clear();
    }

    void Add(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao);    
    int GetCount() { return _rgSpans.Count(); }
    SPAN *GetSpans() { return _rgSpans.GetPtr(0); }
    void Clear()
    {
        _AnchorsAway();
        _rgSpans.Clear();
    }
    void Reset()
    {
        _AnchorsAway();
        _rgSpans.Reset(4);
    }

    BOOL Normalize(ITextStoreAnchor *ptsi);

protected:

    SPAN *_Find(IAnchor *pa, int *piOut);

    BOOL _AllSpansCovered()
    {
        BOOL fRet = (_rgSpans.Count() == 1 &&
                     _rgSpans.GetPtr(0)->paStart == NULL);

        // paStart == NULL implies paEnd == NULL
        Assert(!fRet || _rgSpans.GetPtr(0)->paEnd == NULL);

        return fRet;
    }

    SPAN *_InsertNewSpan(int iIndex);

    CStructArray<SPAN> _rgSpans;

private:
    void _AnchorsAway();

    DBG_ID_DECLARE;
};


#endif // SPANS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\spans.cpp ===
//
// spans.cpp
//
// CSpanSet
//

#include "private.h"
#include "spans.h"
#include "immxutil.h"

DBG_ID_INSTANCE(CSpanSet);

//+---------------------------------------------------------------------------
//
// _InsertNewSpan
//
//----------------------------------------------------------------------------

SPAN *CSpanSet::_InsertNewSpan(int iIndex)
{
    if (!_rgSpans.Insert(iIndex, 1))
        return NULL;

    return _rgSpans.GetPtr(iIndex);
}

//+---------------------------------------------------------------------------
//
// Add
//
//----------------------------------------------------------------------------

void CSpanSet::Add(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao)
{
    int iStart;
    int iEnd;
    SPAN *psStart;
    SPAN *psEnd;
    IAnchor *paLowerBound;
    IAnchor *paUpperBound;
    IAnchor *paClone;
    BOOL fReleaseStart;
    BOOL fReleaseEnd;

    fReleaseStart = fReleaseEnd = (ao == OWN_ANCHORS);

    if (_AllSpansCovered())
    {
        // if we already cover the entire doc, nothing to do
        goto ExitRelease;
    }

    if (paStart == NULL)
    {        
        Assert(paEnd == NULL);

        // NULL, NULL means "the whole doc"
        // so this new span automatically eats all pre-existing ones

        dwFlags = 0; // don't accept corrections for the entire doc
        iStart = 0;
        iEnd = _rgSpans.Count();

        if (iEnd == 0)
        {
            if ((psStart = _InsertNewSpan(0)) == NULL)
                return; // out-of-memory!

            memset(psStart, 0, sizeof(*psStart));
        }
        else
        {
            // need to free the anchors in the first span
            psStart = _rgSpans.GetPtr(0);
            SafeReleaseClear(psStart->paStart);
            SafeReleaseClear(psStart->paEnd);
            psStart->dwFlags = 0;
        }

        goto Exit;
    }

    Assert(CompareAnchors(paStart, paEnd) <= 0);

    psStart = _Find(paStart, &iStart);
    psEnd = _Find(paEnd, &iEnd);

    if (iStart == iEnd)
    {
        if (psStart == NULL)
        {
            // this span doesn't overlap with anything else
            iStart++;

            if ((psStart = _InsertNewSpan(iStart)) == NULL)
                goto ExitRelease; // out-of-memory!

            if (ao == OWN_ANCHORS)
            {
                psStart->paStart = paStart;
                fReleaseStart = FALSE;
                psStart->paEnd = paEnd;
                fReleaseEnd = FALSE;
            }
            else
            {
                if (paStart->Clone(&psStart->paStart) != S_OK)
                {
                    _rgSpans.Remove(iStart, 1);
                    goto ExitRelease;
                }
                if (paEnd->Clone(&psStart->paEnd) != S_OK)
                {
                    psStart->paStart->Release();
                    _rgSpans.Remove(iStart, 1);
                    goto ExitRelease;
                }
            }
            psStart->dwFlags = dwFlags;
        }
        else if (psEnd != NULL)
        {
            Assert(psStart == psEnd);
            // the new span is a subset of an existing span
            psStart->dwFlags &= dwFlags;
        }
        else
        {
            // this spans overlaps with an existing one, but extends further to the right
            // just swap out the end anchor, since we know (iStart == iEnd) that we only
            // cover just this one span
            if (ao == OWN_ANCHORS)
            {
                psStart->paEnd->Release();
                psStart->paEnd = paEnd;
                fReleaseEnd = FALSE;
            }
            else
            {
                if (paEnd->Clone(&paClone) != S_OK || paClone == NULL)
                    goto ExitRelease;
                psStart->paEnd->Release();
                psStart->paEnd = paClone;
            }
        }

        goto ExitRelease;
    }    

    // delete all but one of the covered spans
    if (psStart == NULL)
    {
        iStart++;
        psStart = _rgSpans.GetPtr(iStart);
        Assert(psStart != NULL);

        if (ao == OWN_ANCHORS)
        {
            paLowerBound = paStart;
            fReleaseStart = FALSE;
        }
        else
        {
            if (FAILED(paStart->Clone(&paLowerBound)))
                goto ExitRelease;
        }
    }
    else
    {
        paLowerBound = psStart->paStart;
        paLowerBound->AddRef();
    }
    if (psEnd == NULL)
    {
        if (ao == OWN_ANCHORS)
        {
            paUpperBound = paEnd;
            fReleaseEnd = FALSE;
        }
        else
        {
            if (FAILED(paEnd->Clone(&paUpperBound)))
                goto ExitRelease;
        }
    }
    else
    {
        paUpperBound = psEnd->paEnd;
        paUpperBound->AddRef();
    }

    // psStart grows to cover the entire span
    psStart->paStart->Release();
    psStart->paEnd->Release();
    psStart->paStart = paLowerBound;
    psStart->paEnd = paUpperBound;

Exit:
    // then delete the covered spans
    for (int i=iStart + 1; i <= iEnd; i++)
    {
        SPAN *ps = _rgSpans.GetPtr(i);
        dwFlags &= ps->dwFlags;
        ps->paStart->Release();
        ps->paEnd->Release();
    }

    psStart->dwFlags &= dwFlags; // only set correction bit if all spans were corrections

    //Remove all spans we just cleared out
    if (iEnd - iStart > 0)
    {
        _rgSpans.Remove(iStart+1, iEnd - iStart);
    }

ExitRelease:
    if (fReleaseStart)
    {
        SafeRelease(paStart);
    }
    if (fReleaseEnd)
    {
        SafeRelease(paEnd);
    }
}

//+---------------------------------------------------------------------------
//
// _Find
//
//----------------------------------------------------------------------------

SPAN *CSpanSet::_Find(IAnchor *pa, int *piOut)
{
    SPAN *ps;
    SPAN *psMatch;
    int iMin;
    int iMax;
    int iMid;

    psMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgSpans.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        ps = _rgSpans.GetPtr(iMid);
        Assert(ps != NULL);

        if (CompareAnchors(pa, ps->paStart) < 0)
        {
            iMax = iMid;
        }
        else if (CompareAnchors(pa, ps->paEnd) > 0)
        {
            iMin = iMid + 1;
        }
        else // anchor is in the span
        {
            psMatch = ps;
            break;
        }
    }

    if (piOut != NULL)
    {
        if (psMatch == NULL && iMid >= 0)
        {
            // couldn't find a match, return the next lowest span
            Assert(iMid == 0 || CompareAnchors(_rgSpans.GetPtr(iMid-1)->paEnd, pa) < 0);
            if (CompareAnchors(_rgSpans.GetPtr(iMid)->paStart, pa) > 0)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return psMatch;
}

//+---------------------------------------------------------------------------
//
// AnchorsAway
//
// Note we don't zero-out the IAnchors pointers!  Be careful.
//----------------------------------------------------------------------------

void CSpanSet::_AnchorsAway()
{ 
    SPAN *span;
    int i;

    for (i=0; i<_rgSpans.Count(); i++)
    {
        span = _rgSpans.GetPtr(i);
        SafeRelease(span->paStart);
        SafeRelease(span->paEnd);
    }
}

//+---------------------------------------------------------------------------
//
// Normalize
//
// Replaces (NULL, NULL) spans with actual anchor values for start, end of doc
//----------------------------------------------------------------------------

BOOL CSpanSet::Normalize(ITextStoreAnchor *ptsi)
{
    SPAN *span;

    if (!_AllSpansCovered())
        return TRUE;

    // if we get here, we have a single span with NULL/NULL anchors
    span = _rgSpans.GetPtr(0);

    if (ptsi->GetStart(&span->paStart) != S_OK || span->paStart == NULL)
        return FALSE;

    // Issue: need a GetEnd wrapper that handle unimplemented case! DON'T USE GetEnd!
    if (ptsi->GetEnd(&span->paEnd) != S_OK || span->paEnd == NULL)
    {
        SafeReleaseClear(span->paStart);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\transmit.cpp ===
#include "private.h"
#include "globals.h"
#include "osver.h"
#include "transmit.h"
#include "cmydc.h"


#define MAXFILEMAPSIZE  0x1000


#define DATA_MARKER     0x0001
#define HANDLE_MARKER   0x0002
#define IS_DATA_MARKER( x) (x == DATA_MARKER)
#define IS_HANDLE_MARKER( x) (x == HANDLE_MARKER)

#define GDI_DATA_PASSING() (IsOnNT())
#define POINTER_CAST(x) *(x **)&

#define ICON_DATA_PASSING() (IsOnNT())


//+---------------------------------------------------------------------------
//
// GetIconBitmaps
//
//----------------------------------------------------------------------------

BOOL Cic_GetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize)
{
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcMask(TRUE);
    SIZE size;

    size = *psize;

    hdcSrc.SetDIB(size.cx, size.cy);
    hdcMask.SetBitmap(size.cx, size.cy, 1, 1);
    RECT rc = {0, 0, size.cx, size.cy};
    FillRect(hdcSrc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    DrawIconEx(hdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
    DrawIconEx(hdcMask, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);
    *phbmp = hdcSrc.GetBitmapAndKeep();
    *phbmpMask = hdcMask.GetBitmapAndKeep();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CreateDIB
//
//----------------------------------------------------------------------------

HBITMAP CreateDIB(int cx, int cy, int nWidthByte, BYTE *pMyBits, ULONG_PTR nBitsSize)
{
    CBitmapDC hdc(TRUE);

    HBITMAP hBmp;
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    BYTE *pDibBits;
    hBmp = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (void**)&pDibBits, NULL, 0);

    if (hBmp)
    {
        int y;
        for (y = 0; y < cy; y++)
        {
            int nyDibBites = (cy - y - 1) * nWidthByte;
            int nyMyBites = y * nWidthByte;
            memcpy(&pDibBits[nyDibBites], &pMyBits[nyMyBites], nWidthByte);
        }
    }

    return hBmp;
}

//+---------------------------------------------------------------------------
//
// MARSHAL_HDR
//
//----------------------------------------------------------------------------

template<class TYPE>
struct MARSHAL_HDR
{
    DWORD                   dwDataType;
    CAlignWinHandle<TYPE>   h;
};

// #########################################################################
//
//  HBITMAP
//  See transmit.h for explanation of gdi data/handle passing.
//
// #########################################################################

struct BITMAP_WOW64
{
    // Identical BITMAP structure.

    LONG    bmType;
    LONG    bmWidth;
    LONG    bmHeight;
    LONG    bmWidthBytes;
    WORD    bmPlanes;
    WORD    bmBitsPixel;
    CAlignPointer<LPVOID>  bmBits;

    void operator = (BITMAP& a)
    {
        bmType = a.bmType;
        bmWidth = a.bmWidth;
        bmHeight = a.bmHeight;
        bmWidthBytes = a.bmWidthBytes;
        bmPlanes     = a.bmPlanes;
        bmBitsPixel  = a.bmBitsPixel;
        bmBits       = a.bmBits;
    }

    void operator = (int a)
    {
        memset(this, a, sizeof(BITMAP_WOW64));
    }
};

struct MARSHAL_HBITMAP
{
    MARSHAL_HDR<HBITMAP>    hdr;
    MARSHAL_HDR<HBITMAP>    hdr_2;

    struct
    {
        DWORD               dwCount;
        BITMAP_WOW64        bm;
    } bitmap_1;

    struct
    {
        DWORD               dwCount;
        BITMAP_WOW64        bm;
    } bitmap_2;

    BYTE                    bits[1];
};

//+-------------------------------------------------------------------------
//
// UserSize
//
//--------------------------------------------------------------------------

ULONG Cic_HBITMAP_UserSize (HBITMAP *pHBitmap, HBITMAP *pHBitmap_2) 
{
    ULONG Offset = 0;

    if ( !pHBitmap )
        return 0;

    BITMAP      bm, bm_2;
    HBITMAP     hBitmap, hBitmap_2;

    hBitmap   = *pHBitmap;
    hBitmap_2 = pHBitmap_2 ? *pHBitmap_2 : NULL;

    memset(&bm, 0, sizeof(BITMAP));
    memset(&bm_2, 0, sizeof(BITMAP));

    //
    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    //

    if ( GDI_DATA_PASSING() )
    {
        Offset += sizeof(struct MARSHAL_HBITMAP);

        if (hBitmap)
        {
            // Get information about the bitmap
            if (!GetObject(hBitmap, sizeof(BITMAP), &bm))
                return 0;

            Offset += (bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes);
        }

        if (hBitmap_2)
        {
            // Get information about the bitmap
            if (!GetObject(hBitmap_2, sizeof(BITMAP), &bm_2))
                return 0;

            Offset += (bm_2.bmPlanes * bm_2.bmHeight * bm_2.bmWidthBytes);
        }

        Offset = Align( Offset );

    }
    else
    {
        if (pHBitmap)
            Offset += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );

        if (pHBitmap_2)
            Offset += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  HBITMAP_UserMarshall
//
//--------------------------------------------------------------------------

BYTE *Cic_HBITMAP_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2)
{
    if ( !pHBitmap )
        return pBuffer;

    // Discriminant of the encapsulated union and union arm.
    struct MARSHAL_HBITMAP* pdata = (struct MARSHAL_HBITMAP*) pBuffer;

    if ( GDI_DATA_PASSING() )
    {
        if (!pHBitmap)
        {
            pdata->hdr.dwDataType = 0;
            pdata->hdr.h          = NULL;
        }
        else
        {
            pdata->hdr.dwDataType = DATA_MARKER;
            pdata->hdr.h          = *pHBitmap;
        }

        if (!pHBitmap_2)
        {
            pdata->hdr_2.dwDataType = 0;
            pdata->hdr_2.h          = NULL;
        }
        else
        {
            pdata->hdr_2.dwDataType = DATA_MARKER;
            pdata->hdr_2.h          = *pHBitmap_2;
        }

        //
        // Get information about the bitmap
        //

        BITMAP bm, bm_2;
        HBITMAP hBitmap   = *pHBitmap;
        HBITMAP hBitmap_2 = pHBitmap_2 ? *pHBitmap_2 : NULL;

        //
        // Bitmap object 1
        //
        if (!hBitmap)
        {
            pdata->bitmap_1.bm = 0;
            pdata->bitmap_1.dwCount = 0;
        }
        else
        {
            if (!GetObject(hBitmap, sizeof(BITMAP), &bm))
                return pBuffer + Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );

            pdata->bitmap_1.dwCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

            //
            // Get the bm structure fields.
            //
            pdata->bitmap_1.bm = bm;
        }


        //
        // Bitmap object 2
        //

        if (!hBitmap_2)
        {
            pdata->bitmap_2.bm = 0;
            pdata->bitmap_2.dwCount = 0;
        }
        else
        {
            if (!GetObject(hBitmap_2, sizeof(BITMAP), &bm_2))
                return pBuffer + Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );

            pdata->bitmap_2.dwCount = bm_2.bmPlanes * bm_2.bmHeight * bm_2.bmWidthBytes;

            pdata->bitmap_2.bm     = bm_2;
        }

        //
        // Get the raw bits.
        //

        if (hBitmap)
        {
     
            BYTE *pbTemp = pdata->bits;
            if (pbTemp + pdata->bitmap_1.dwCount > pBufferEnd)
            {
                Assert(0);
                pdata->bitmap_1.bm      = 0;
                pdata->bitmap_1.dwCount = 0;
            }
            else
            {
                GetBitmapBits( hBitmap, 
                               pdata->bitmap_1.dwCount, 
                               pdata->bits );

            }
        }

        if (hBitmap_2)
        {
            BYTE *pbTemp = &pdata->bits[pdata->bitmap_1.dwCount];
            if (pbTemp + pdata->bitmap_2.dwCount > pBufferEnd)
            {
                Assert(0);
                pdata->bitmap_2.bm      = 0;
                pdata->bitmap_2.dwCount = 0;
            }
            else
            {
                GetBitmapBits( hBitmap_2, 
                               pdata->bitmap_2.dwCount, 
                               &pdata->bits[pdata->bitmap_1.dwCount]);
            }
        }

        pBuffer += Align( sizeof(struct MARSHAL_HBITMAP) + pdata->bitmap_1.dwCount + pdata->bitmap_2.dwCount);

    }
    else
    {
        // Sending a handle.

        pdata->hdr.dwDataType = 0;
        pdata->hdr.h          = NULL;
        pdata->hdr_2.dwDataType = 0;
        pdata->hdr_2.h          = NULL;

        if (pHBitmap)
        {
            pdata->hdr.dwDataType = HANDLE_MARKER;
            pdata->hdr.h          = *pHBitmap;

            pBuffer += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );
        }

        if (pHBitmap_2)
        {
            pdata->hdr_2.dwDataType = HANDLE_MARKER;
            pdata->hdr_2.h          = *pHBitmap_2;

            pBuffer += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );
        }

    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HBITMAP_UserUnmarshallWorker
//
//--------------------------------------------------------------------------

BYTE *Cic_HBITMAP_UserUnmarshal(BYTE *pBuffer, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2)
{
    HBITMAP         hBitmap, hBitmap_2;

    // Get Discriminant and handle.  Caller checked for EOB.
    struct MARSHAL_HBITMAP* pdata = (struct MARSHAL_HBITMAP*) pBuffer;

    DWORD UnionDisc = pdata->hdr.dwDataType;
    hBitmap   = pdata->hdr.h;

    if (!hBitmap)
    {
        if (!pHBitmap_2)
        {
            *pHBitmap = NULL;
            return pBuffer;
        }

        UnionDisc = pdata->hdr_2.dwDataType;
    }

    hBitmap_2 = pdata->hdr_2.h ? (HBITMAP)pdata->hdr_2.h : NULL;

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        ULONG_PTR dwCount = 0;
        ULONG_PTR dwCount_2 = 0;

        if ( hBitmap )
        {
            dwCount = pdata->bitmap_1.dwCount;
            
            // verify dwCount matches the bitmap.
            if ( dwCount != (DWORD) pdata->bitmap_1.bm.bmPlanes * 
                                    pdata->bitmap_1.bm.bmHeight * 
                                    pdata->bitmap_1.bm.bmWidthBytes )
            {
                Assert(0);
                return NULL;
            }


            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer

            if (pdata->bitmap_1.bm.bmBitsPixel == 0x20)
                hBitmap = CreateDIB( pdata->bitmap_1.bm.bmWidth,
                                     pdata->bitmap_1.bm.bmHeight,
                                     pdata->bitmap_1.bm.bmWidthBytes,
                                     pdata->bits, dwCount);
            else
                hBitmap = CreateBitmap( pdata->bitmap_1.bm.bmWidth,
                                        pdata->bitmap_1.bm.bmHeight,
                                        pdata->bitmap_1.bm.bmPlanes,
                                        pdata->bitmap_1.bm.bmBitsPixel,
                                        pdata->bits);
        }

        if (hBitmap_2)
        {
            dwCount_2 = pdata->bitmap_2.dwCount;

            // verify dwCount_2 matches the bitmap.
            if ( dwCount_2 != (DWORD) pdata->bitmap_2.bm.bmPlanes * 
                                      pdata->bitmap_2.bm.bmHeight * 
                                      pdata->bitmap_2.bm.bmWidthBytes )
            {
                Assert(0);
                return NULL;
            }

            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer

            if (pdata->bitmap_2.bm.bmBitsPixel == 0x20)
                hBitmap_2 = CreateDIB( pdata->bitmap_2.bm.bmWidth,
                                       pdata->bitmap_2.bm.bmHeight,
                                       pdata->bitmap_2.bm.bmWidthBytes,
                                       &pdata->bits[dwCount], dwCount_2);
            else
                hBitmap_2 = CreateBitmap( pdata->bitmap_2.bm.bmWidth,
                                          pdata->bitmap_2.bm.bmHeight,
                                          pdata->bitmap_2.bm.bmPlanes,
                                          pdata->bitmap_2.bm.bmBitsPixel,
                                          &pdata->bits[dwCount]);
        }


        pBuffer += Align( sizeof(struct MARSHAL_HBITMAP) + dwCount + dwCount_2 );
    }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
    {
        Assert(0);
    }

    // A new bitmap handle is ready, destroy the old one, if needed.

    if ( *pHBitmap )
        DeleteObject( *pHBitmap );

    *pHBitmap = hBitmap;

    if ( pHBitmap_2 )
    {
        if ( *pHBitmap_2 )
            DeleteObject( *pHBitmap_2 );

        *pHBitmap_2 = hBitmap_2;
    }


    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HBITMAP_UserFree
//
//--------------------------------------------------------------------------

void Cic_HBITMAP_UserFree(HBITMAP *pHBitmap, HBITMAP *pHBitmap_2)
{
    if( pHBitmap  &&  *pHBitmap )
    {
        if ( GDI_DATA_PASSING() )
        {
            DeleteObject( *pHBitmap );
        }
    }

    if( pHBitmap_2  &&  *pHBitmap_2 )
    {
        if ( GDI_DATA_PASSING() )
        {
            DeleteObject( *pHBitmap_2 );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// TF_LBBALLOON
//
//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
// UserSize
//
//--------------------------------------------------------------------------

ULONG Cic_TF_LBBALLOONINFO_UserSize(TF_LBBALLOONINFO *pInfo)
{
    ULONG ulRet;

    ulRet = sizeof(TF_LBBALLOONINFO);
    LENGTH_ALIGN(ulRet, CIC_ALIGNMENT);

    if (pInfo->bstrText)
        ulRet += (SysStringByteLen(pInfo->bstrText) + 2);
    else
        ulRet += 2;

    LENGTH_ALIGN(ulRet, CIC_ALIGNMENT);
    return ulRet;
}

//+-------------------------------------------------------------------------
//
// UserMarshal
//
//--------------------------------------------------------------------------

BYTE *Cic_TF_LBBALLOONINFO_UserMarshal(BYTE *pBuf, TF_LBBALLOONINFO *pInfo)
{
    if (!pInfo)
        return pBuf;

    memcpy(pBuf, pInfo, sizeof(TF_LBBALLOONINFO));
    pBuf += sizeof(TF_LBBALLOONINFO);
    POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
    if (pInfo->bstrText)
        wcscpy((WCHAR *)pBuf, pInfo->bstrText);


    pBuf += ((pInfo->bstrText ? wcslen(pInfo->bstrText) : 0) + 2);
    POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
    return pBuf;
}

//+-------------------------------------------------------------------------
//
// UserUnMarshal
//
//--------------------------------------------------------------------------

HRESULT Cic_TF_LBBALLOONINFO_UserUnmarshal(BYTE *pBuf, TF_LBBALLOONINFO  *pInfo)
{
    HRESULT hr;;

    if (!pInfo)
        return S_OK;

    hr = S_OK;

    memcpy(pInfo, pBuf, sizeof(TF_LBBALLOONINFO));
   
    if (pInfo->bstrText)
    {
        BYTE *pTmp = pBuf + sizeof(TF_LBBALLOONINFO);
        POINTER_ALIGN( pTmp, CIC_ALIGNMENT);
        pInfo->bstrText =  SysAllocString((WCHAR *)pTmp);
        hr = (pInfo->bstrText != NULL) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
// UserFree
//
//--------------------------------------------------------------------------

void Cic_TF_LBBALLOONINFO_UserFree(TF_LBBALLOONINFO *pInfo)
{
    if (pInfo->bstrText)
    {
       SysFreeString(pInfo->bstrText);
       pInfo->bstrText = NULL;
    }
}

// #########################################################################
//
//  HICON
//  See transmit.h for explanation of gdi data/handle passing.
//
// #########################################################################

struct ICONINFO_WOW64
{
    // Identical ICONINFO structure.

    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    CAlignWinHandle<HBITMAP>  hbmMask;
    CAlignWinHandle<HBITMAP>  hbmColor;

    void operator = (ICONINFO& a)
    {
        fIcon    = a.fIcon;
        xHotspot = a.xHotspot;
        yHotspot = a.yHotspot;
        hbmMask  = a.hbmMask;
        hbmColor = a.hbmColor;
    }

};

struct MARSHAL_HICON
{
    MARSHAL_HDR<HICON>      hdr;

    ICONINFO_WOW64          ic;

    MARSHAL_HBITMAP         bm;
};

//+-------------------------------------------------------------------------
//
// UserSize
//
//--------------------------------------------------------------------------

ULONG Cic_HICON_UserSize (HICON *pHIcon) 
{
    ULONG Offset = 0;

    if ( !pHIcon )
        return 0;

    HICON     hIcon = *pHIcon;

    //
    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    //
    if ( ! *pHIcon )
        return Align( sizeof(struct MARSHAL_HDR<HICON>) );

    if ( ICON_DATA_PASSING() )
    {
        ICONINFO IconInfo;
        ULONG ulBmpUserSize = 0;
        if (!GetIconInfo(hIcon, &IconInfo))
            return 0;

        Offset += Align( sizeof(struct MARSHAL_HICON) );

        //
        // On NT4, CreateBitmap() can not create different device type
        // bitmap. We convert the dc bitmap by calling DrawIconEx().
        //
        // We may want to use DIB section to marshal but marshaling and 
        // unmarshaling happens in same device so it does not have to
        // convert bitmaps to DIB.
        //
        if (!IsOnNT5())
        {
            HBITMAP hbmp = NULL;
            HBITMAP hbmpMask = NULL;
            SIZE    size;
            BITMAP  bmp;

            if (!GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp ))
            {
                Offset = 0;
                goto DeleteAndExit;
            }

            size.cx = bmp.bmWidth;
            size.cy = bmp.bmHeight;
            Cic_GetIconBitmaps(*pHIcon, &hbmp, &hbmpMask, &size);

            ulBmpUserSize = Cic_HBITMAP_UserSize(&hbmp, &hbmpMask);
            if (!ulBmpUserSize)
            {
                Offset = 0;
                goto DeleteAndExit;
            }

            Offset += ulBmpUserSize;
            Offset = Align( Offset );

DeleteAndExit:
            if (hbmp)
                DeleteObject(hbmp);
            if (hbmpMask)
                DeleteObject(hbmpMask);
        }
        else
        {
            ulBmpUserSize = Cic_HBITMAP_UserSize(&IconInfo.hbmColor, &IconInfo.hbmMask);
            if (!ulBmpUserSize)
            {
                Offset = 0;
                goto Exit;
            }

            Offset += ulBmpUserSize;
            Offset = Align( Offset );

        }
Exit:
        if (IconInfo.hbmColor)
            DeleteObject(IconInfo.hbmColor);
        if (IconInfo.hbmMask)
            DeleteObject(IconInfo.hbmMask);
    }
    else
    {
        Offset += Align( sizeof(struct MARSHAL_HDR<HICON>) );
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  HICON_UserMarshall
//
//--------------------------------------------------------------------------

BYTE *Cic_HICON_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HICON *pHIcon)
{
    if ( !pHIcon )
        return pBuffer;

    // Discriminant of the encapsulated union and union arm.
    struct MARSHAL_HICON* pdata = (struct MARSHAL_HICON*) pBuffer;

    if ( ICON_DATA_PASSING() )
    {
        pdata->hdr.dwDataType = DATA_MARKER;
        pdata->hdr.h          = *pHIcon;

        if ( ! *pHIcon )
            return pBuffer + Align( sizeof(struct MARSHAL_HDR<HICON>) );

        //
        // Get information about the bitmap
        //
        ICONINFO IconInfo;

        if (!GetIconInfo(*pHIcon, &IconInfo))
            memset(&IconInfo, 0, sizeof(IconInfo));

        //
        // Get the ic structure fields.
        //
        pdata->ic    = IconInfo;

        //
        // On NT4, CreateBitmap() can not create different device type
        // bitmap. We convert the dc bitmap by calling DrawIconEx().
        //
        // We may want to use DIB section to marshal but marshaling and 
        // unmarshaling happens in same device so it does not have to
        // convert bitmaps to DIB.
        //
        if (!IsOnNT5())
        {
            HBITMAP hbmp = NULL;
            HBITMAP hbmpMask = NULL;
            SIZE    size;
            BITMAP  bmp;
            GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp );
            size.cx = bmp.bmWidth;
            size.cy = bmp.bmHeight;
            Cic_GetIconBitmaps(*pHIcon, &hbmp, &hbmpMask, &size);

            pBuffer = Cic_HBITMAP_UserMarshal((BYTE*) &pdata->bm, pBufferEnd, &hbmp, &hbmpMask);

            if (hbmp)
                DeleteObject(hbmp);
            if (hbmpMask)
                DeleteObject(hbmpMask);
        }
        else
        {
            pBuffer = Cic_HBITMAP_UserMarshal((BYTE*) &pdata->bm, pBufferEnd, &IconInfo.hbmColor, &IconInfo.hbmMask);
        }
        if (IconInfo.hbmColor)
            DeleteObject(IconInfo.hbmColor);
        if (IconInfo.hbmColor)
            DeleteObject(IconInfo.hbmMask);
    }
    else
    {
        //
        // we need to make sure this pointer of the Icon is
        // not a resource.
        //
        HICON hIcon = CopyIcon(*pHIcon);
        if (hIcon)
            DestroyIcon(*pHIcon);
        else
            hIcon = *pHIcon;
     
        // Sending a handle.

        pdata->hdr.dwDataType = HANDLE_MARKER;
        pdata->hdr.h          = hIcon;

        pBuffer += Align( sizeof(struct MARSHAL_HDR<HICON>) );

    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HICON_UserUnmarshallWorker
//
//--------------------------------------------------------------------------

BYTE *Cic_HICON_UserUnmarshal(BYTE *pBuffer, HICON  *pHIcon)
{
    HICON hIcon = NULL;

    // Get Discriminant and handle.  Caller checked for EOB.
    struct MARSHAL_HICON* pdata = (struct MARSHAL_HICON*) pBuffer;

    DWORD UnionDisc = pdata->hdr.dwDataType;
    hIcon           = pdata->hdr.h;

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hIcon )
        {
            ICONINFO IconInfo;
            IconInfo.fIcon    = pdata->ic.fIcon;
            IconInfo.xHotspot = pdata->ic.xHotspot;
            IconInfo.yHotspot = pdata->ic.yHotspot;
            IconInfo.hbmMask  = pdata->ic.hbmMask;
            IconInfo.hbmColor = pdata->ic.hbmColor;

            //
            // We just get the bitmap handle from marshaling buffer.
            // And the marshaling buffer does not have a valid bitmap handle.
            //
            IconInfo.hbmColor = NULL;
            IconInfo.hbmMask = NULL;

            pBuffer = Cic_HBITMAP_UserUnmarshal((BYTE*) &pdata->bm, &IconInfo.hbmColor, &IconInfo.hbmMask);
            if (pBuffer)
            {
                hIcon = CreateIconIndirect(&IconInfo);
            }

            if (IconInfo.hbmColor)
                DeleteObject(IconInfo.hbmColor);
            if (IconInfo.hbmMask)
                DeleteObject(IconInfo.hbmMask);
        }
    }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
    {
        Assert(0);
    }

    // A new bitmap handle is ready, destroy the old one, if needed.

    if ( *pHIcon )
        DestroyIcon( *pHIcon );

    *pHIcon = hIcon;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HICON_UserFree
//
//--------------------------------------------------------------------------

void Cic_HICON_UserFree(HICON *pHIcon)
{
    if( pHIcon  &&  *pHIcon )
    {
        if ( ICON_DATA_PASSING() )
        {
            DestroyIcon( *pHIcon );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\transmit.h ===
//
// transmit.h
//

#ifndef TRANSMIT_H
#define TRANSMIT_H


#define POINTER_ALIGN( pStuff, cAlign ) \
      pStuff = (unsigned char *)((ULONG_PTR)((pStuff) + (cAlign)) & ~ (cAlign))

#define LENGTH_ALIGN( Length, cAlign ) \
            Length = (((Length) + (cAlign)) & ~ (cAlign))


ULONG Cic_HBITMAP_UserSize (HBITMAP * pHBitmap, HBITMAP * pHBitmap_2 = NULL);
BYTE *Cic_HBITMAP_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2 = NULL);
BYTE *Cic_HBITMAP_UserUnmarshal(BYTE *pBuffer, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2 = NULL);
void Cic_HBITMAP_UserFree(HBITMAP *pHBitmap, HBITMAP *pHBitmap_2 = NULL);

ULONG Cic_TF_LBBALLOONINFO_UserSize (TF_LBBALLOONINFO *pInfo);
BYTE *Cic_TF_LBBALLOONINFO_UserMarshal(BYTE *pBuffer, TF_LBBALLOONINFO *pInfo);
HRESULT Cic_TF_LBBALLOONINFO_UserUnmarshal(BYTE *pBuffer, TF_LBBALLOONINFO  *pInfo);
void Cic_TF_LBBALLOONINFO_UserFree(TF_LBBALLOONINFO *pInfo);

ULONG Cic_HICON_UserSize (HICON * pHBitmap);
BYTE *Cic_HICON_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HICON *pHBitmap);
BYTE *Cic_HICON_UserUnmarshal(BYTE *pBuffer, HICON  *pHBitmap);
void Cic_HICON_UserFree(HICON *pHBitmap);

#endif // TRANSMIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\timlist.h ===
//
// timlist.h
//

#ifndef TIMLIST_H
#define TIMLIST_H

#include "smblock.h"
#include "tlapi.h"

#define INITIAL_TIMLIST_SIZE 0x10000


TL_THREADINFO *EnsureTIMList(SYSTHREAD *psfn);
BOOL CicIs16bitTask(DWORD dwProcessId, DWORD dwThreadId);
void PostTimListMessage(DWORD dwMaskFlags, DWORD dwExcludeFlags, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD TLFlagFromTFPriv(WPARAM wParam);

typedef enum {
      TI_THREADID  = 0,
      TI_PROCESSID = 1,
      TI_FLAGS     = 2,
} TIEnum;

class CTimList
{
public:
    void CleanUp()
    {
        if (_psb)
            delete _psb;

        _psb = NULL;
    }

    BOOL Enter()
    {
        if (!_psb || !_psb->GetBase())
            return FALSE;
        
        if (ISINDLLMAIN())
            return TRUE;

        if (!_psb->GetMutex() || !_psb->GetMutex()->Enter())
            return FALSE;

        return TRUE;
    }

    void Leave()
    {
        if (ISINDLLMAIN())
            return;

        _psb->GetMutex()->Leave();
    }

    BOOL Init(BOOL fCreate);
    BOOL Uninit();

    BOOL EnsureCurrentThread();
    TL_THREADINFO *AddCurrentThread(DWORD dwFlags, SYSTHREAD *psfn);
    TL_THREADINFO *AddThreadProcess(DWORD dwThreadId, DWORD dwProcessId, HWND hwndMarshal, DWORD dwFlags);
    BOOL RemoveThread(DWORD dwThreadId);
    BOOL RemoveProcess(DWORD dwProcessId);
    ULONG GetNum();
    BOOL GetList(DWORD *pdwOut, ULONG ulMax, DWORD *pdwNum, DWORD dwMaskFlags, DWORD dwExcludeFlags, BOOL fUpdateExcludeFlags);
    BOOL GetListInProcess(DWORD *pdwOut, DWORD *pdwNum, DWORD dwProcessId);
    DWORD GetProcessId(DWORD dwThreadId);
    DWORD GetFlags(DWORD dwThreadId);
    TL_THREADINFO *IsThreadId(DWORD dwThreadId);
    BOOL SetFlags(DWORD dwThreadId, DWORD dwFlags);
    BOOL ClearFlags(DWORD dwThreadId, DWORD dwFlags);
    BOOL SetMarshalWnd(DWORD dwThreadId, HWND hwndMarshal);
    HWND GetMarshalWnd(DWORD dwThreadId);
    BOOL SetConsoleHKL(DWORD dwThreadId, HKL hkl);
    HKL  GetConsoleHKL(DWORD dwThreadId);

    typedef struct tag_TIMLIST {
        ULONG ulNum;
        TL_THREADINFO rgThread[1];
    } TIMLIST;

    BOOL IsInitialized()
    {
       return (_lInit >= 0) ? TRUE : FALSE;
    }

    BOOL GetThreadFlags(DWORD dwThreadId, DWORD *pdwFlags, DWORD *pdwProcessId, DWORD *pdwTickTime);

private:
    TL_THREADINFO *Find(DWORD dwThreadId);
    DWORD GetDWORD(DWORD dwThreadId, TIEnum tie);
    BOOL SetClearFlags(DWORD dwThreadId, DWORD dwFlags, BOOL fClear);

    static CSharedBlock *_psb;
    static ULONG _ulCommitSize;
    static LONG _lInit;

#ifdef DEBUG
    void dbg_Check(TIMLIST *ptl);
#else
    void dbg_Check(TIMLIST *ptl) {}
#endif
};


#endif // TIMLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tim.h ===
//
// tim.h
//
// CThreadInputMgr
//


#ifndef TIM_H
#define TIM_H

#include "private.h"
#include "globals.h"
#include "ptrmap.h"
#include "ptrary.h"
#include "nuimgr.h"
#include "utb.h"
#include "compart.h"
#include "msctfp.h"
#include "dim.h"
#include "ic.h"

extern void ExecuteLoader(void);

#define TIM_NUM_CONNECTIONPTS    6
// these are indices into _rgSinks, must match _c_rgConnectionIIDs
#define TIM_SINK_ITfDisplayAttributeNotifySink       0
#define TIM_SINK_ITfActiveLanguageProfileNotifySink  1
#define TIM_SINK_ITfUIFocusSink                      2
#define TIM_SINK_ITfPreservedKeyNotifySink           3
#define TIM_SINK_ITfThreadMgrEventSink               4
#define TIM_SINK_ITfKeyTraceEventSink                5

//
// for _AsyncKeyHandler()
//
#define TIM_AKH_SYNC             0x0001
#define TIM_AKH_TESTONLY         0x0002
#define TIM_AKH_SIMULATEKEYMSGS  0x0004

class CHotKey;

// callback for CThreadMgr::_CleanupContexts
typedef void (*POSTCLEANUPCALLBACK)(BOOL fAbort, LONG_PTR lPrivate);

//////////////////////////////////////////////////////////////////////////////
//
// CTip
//
//////////////////////////////////////////////////////////////////////////////

class CTip 
{
public:
    CTip() {};
    ~CTip() 
    {
        Assert(!_rgHotKey.Count());
    };

    void CleanUp()
    {
        Assert(!_pKeyEventSink);
        Assert(!_pFuncProvider);

        if (_hInstSubstituteHKL)
        {
            FreeLibrary(_hInstSubstituteHKL);
            _hInstSubstituteHKL = NULL;
        }

        SafeReleaseClear(_pKeyEventSink);
        SafeReleaseClear(_pFuncProvider);
        SafeReleaseClear(_pTip);
    }

    ITfTextInputProcessor *_pTip;
    TfGuidAtom _guidatom;
    ITfKeyEventSink *_pKeyEventSink;
    ITfFunctionProvider *_pFuncProvider;
    ITfCleanupContextDurationSink *_pCleanupDurationSink;

    BOOL _fForegroundKeyEventSink : 1;
    BOOL _fActivated : 1;
    BOOL _fNeedCleanupCall : 1;

    CPtrArray<CHotKey> _rgHotKey;

    HMODULE _hInstSubstituteHKL;
};

typedef struct _CLEANUPCONTEXT
{
    BOOL fSync;
    const GUID *pCatId;
    LANGID langid;
    POSTCLEANUPCALLBACK pfnPostCleanup;
    LONG_PTR lPrivate;
} CLEANUPCONTEXT;

typedef enum { TIM_INITDIM, TIM_UNINITDIM, TIM_SETFOCUS, TIM_INITIC, TIM_UNINITIC } TimNotify;
typedef enum { TSH_SYSHOTKEY, TSH_NONSYSHOTKEY, TSH_DONTCARE} TimSysHotkey;
typedef enum { KS_DOWN, KS_DOWN_TEST, KS_UP, KS_UP_TEST } KSEnum;

class CDocumentInputManager;
class CInputContext;
class CTIPRegister;
class CACPWrap;
class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CThreadInputMgr
//
//////////////////////////////////////////////////////////////////////////////

class CThreadInputMgr : public ITfThreadMgr_P,
                        public ITfKeystrokeMgr_P,
                        public ITfLangBarItemMgr,
                        public ITfSource,
                        public ITfSourceSingle,
                        public ITfMessagePump,
                        public ITfConfigureSystemKeystrokeFeed,
                        public ITfClientId,
                        public CCompartmentMgr,
                        public CComObjectRoot_CreateSingletonInstance_Verify<CThreadInputMgr>
{
public:
    CThreadInputMgr();
    ~CThreadInputMgr();

    BEGIN_COM_MAP_IMMX(CThreadInputMgr)
        COM_INTERFACE_ENTRY(ITfThreadMgr)
        COM_INTERFACE_ENTRY(ITfThreadMgr_P_old)
        COM_INTERFACE_ENTRY(ITfThreadMgr_P)
        COM_INTERFACE_ENTRY(ITfSource)
        COM_INTERFACE_ENTRY(ITfSourceSingle)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
        COM_INTERFACE_ENTRY(ITfKeystrokeMgr)
        COM_INTERFACE_ENTRY(ITfKeystrokeMgr_P)
        COM_INTERFACE_ENTRY(ITfLangBarItemMgr)
        COM_INTERFACE_ENTRY(ITfMessagePump)
        COM_INTERFACE_ENTRY(ITfConfigureSystemKeystrokeFeed)
        COM_INTERFACE_ENTRY(ITfClientId)
    END_COM_MAP_IMMX()

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    static void PostCreateInstance(REFIID riid, void *pvObj) {}

    // ITfThreadMgr
    STDMETHODIMP Activate(TfClientId *ptid);
    STDMETHODIMP Deactivate();
    STDMETHODIMP CreateDocumentMgr(ITfDocumentMgr **ppdim);
    STDMETHODIMP EnumDocumentMgrs(IEnumTfDocumentMgrs **ppEnum);
    STDMETHODIMP GetFocus(ITfDocumentMgr **ppdimFocus);
    STDMETHODIMP SetFocus(ITfDocumentMgr *pdimFocus);
    STDMETHODIMP AssociateFocus(HWND hwnd, ITfDocumentMgr *pdimNew, ITfDocumentMgr **ppdimPrev);
    STDMETHODIMP IsThreadFocus(BOOL *pfUIFocus);
    STDMETHODIMP GetFunctionProvider(REFGUID guidPrvdr, ITfFunctionProvider **ppv);
    STDMETHODIMP EnumFunctionProviders(IEnumTfFunctionProviders **ppEnum);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);
    // ITfSourceSingle
    STDMETHODIMP AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk);
    STDMETHODIMP UnadviseSingleSink(TfClientId tid, REFIID riid);

    STDMETHODIMP GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

    // ITfThreadMgr_P
    STDMETHODIMP GetAssociated(HWND hWnd, ITfDocumentMgr **ppdim);
    STDMETHODIMP SetSysHookSink(ITfSysHookSink *pSink);
    STDMETHODIMP RequestPostponedLock(ITfContext *pic);
    STDMETHODIMP IsKeystrokeFeedEnabled(BOOL *pfEnabled);
    STDMETHODIMP CallImm32HotkeyHanlder(WPARAM wParam, LPARAM lParam, BOOL *pbHandled);
    STDMETHODIMP ActivateEx(TfClientId *ptid, DWORD dwFlags);

    //
    // ITfKeystrokeManager
    //
    STDMETHODIMP GetForeground(CLSID *pclsid);
    STDMETHODIMP AdviseKeyEventSink(TfClientId tid, ITfKeyEventSink *pSink, BOOL fForeground);
    STDMETHODIMP UnadviseKeyEventSink(TfClientId tid);
    STDMETHODIMP TestKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP TestKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP KeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP KeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP GetPreservedKey(ITfContext *pic, const TF_PRESERVEDKEY *pprekey, GUID *pguid);
    STDMETHODIMP IsPreservedKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey, BOOL *pfRegistered);
    STDMETHODIMP PreserveKey(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *prekey, const WCHAR *pchDesc, ULONG cchDesc);
    STDMETHODIMP UnpreserveKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey);
    STDMETHODIMP SetPreservedKeyDescription(REFGUID rguid, const WCHAR *pchDesc, ULONG cchDesc);
    STDMETHODIMP GetPreservedKeyDescription(REFGUID rguid, BSTR *pbstrDesc);
    STDMETHODIMP SimulatePreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten);
    STDMETHODIMP KeyDownUpEx(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten);

    //
    // ITfKeystrokeManager_P
    //
    STDMETHODIMP PreserveKeyEx(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *prekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags);

    // ITfConfigureSystemKeystrokeFeed
    STDMETHODIMP DisableSystemKeystrokeFeed();
    STDMETHODIMP EnableSystemKeystrokeFeed();

    //
    // ITfLangBarItemMgr
    //
    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP GetItem(REFGUID rguid, ITfLangBarItem **ppItem);
    STDMETHODIMP AddItem(ITfLangBarItem *punk);
    STDMETHODIMP RemoveItem(ITfLangBarItem *punk);
    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguid);
    STDMETHODIMP UnadviseItemSink(DWORD dwCookie);
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus);
    STDMETHODIMP GetItemNum(ULONG *pulCount);

    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched);
    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie);
    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie);

    //
    // ITfMessagePump
    //
    STDMETHODIMP PeekMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult);
    STDMETHODIMP GetMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, BOOL *pfResult);
    STDMETHODIMP PeekMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult);
    STDMETHODIMP GetMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, BOOL *pfResult);

    //
    // ITfClientId
    //
    STDMETHODIMP GetClientId(REFCLSID rclsid, TfClientId *ptid);

    HRESULT ActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, HKL hklSubstitute, BOOL fActivate);
    HRESULT NotifyActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, BOOL fActivate);

    HRESULT _SetForeground(TfClientId tid);
    BOOL _ProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest, BOOL fSync);
    BOOL _SyncProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest);

    // use this to grab the single CThreadInputMgr for the calling thread
    static CThreadInputMgr *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;
        return psfn->ptim;
    }

    static CThreadInputMgr *_GetThisFromSYSTHREAD(SYSTHREAD *psfn) 
    { 
        Assert(psfn);
        return psfn->ptim;
    }

    ITfTextInputProcessor *_tidToTIP(TfClientId tid)
    {
        ITfTextInputProcessor *tip;

        _GetITfIMEfromGUIDATOM(tid, &tip);

        return tip;
    }

    TfClientId _TIPToTid(ITfTextInputProcessor *tip)
    {
        TfClientId tid;

        _GetGUIDATOMfromITfIME(tip, &tid);

        return tid;
    }

    void _SetProcessAtom();

    HRESULT _OnThreadFocus(BOOL fActivate);
    void _GetSubstituteIMEModule(CTip *ptip, HKL hklSubstitute);
    HRESULT _ActivateTip(REFCLSID clsid, HKL hklSubstitute, CTip **pptip);
    HRESULT _DeactivateTip(CTip *ptip);

    HRESULT _SetFocus(CDocumentInputManager *pdim, BOOL fInternal);

    CDocumentInputManager *_GetAssoc(HWND hWnd);
    HWND _GetAssoced(CDocumentInputManager *pdim);
    BOOL _GetGUIDATOMfromITfIME(ITfTextInputProcessor *pIME, TfGuidAtom *pguidatom);
    BOOL _GetITfIMEfromGUIDATOM(TfGuidAtom guidatom, ITfTextInputProcessor **ppIME);
    BOOL _GetCTipfromGUIDATOM(TfGuidAtom guidatom, CTip **pptip);

    UINT _GetTIPCount() { return _rgTip.Count(); }
    const CTip *_GetCTip(UINT i) { return _rgTip.Get(i); }

    CDocumentInputManager *_GetFocusDocInputMgr() { return _pFocusDocInputMgr; }
    BOOL _IsInternalFocusedDim() { return _fInternalFocusedDim; }
    BOOL _IsNoFirstSetFocusAfterActivated() {return _fFirstSetFocusAfterActivated;}

    void _NotifyCallbacks(TimNotify notify, CDocumentInputManager *dim, void *pv);


    void UpdateDispAttr();

    CPtrArray<CDocumentInputManager> _rgdim;

    void InitSystemFunctionProvider();
    CFunctionProvider *GetSystemFunctionProvider();

    CStructArray<GENERICSINK> *_GetThreadMgrEventSink() { return &_rgSinks[TIM_SINK_ITfThreadMgrEventSink]; }
    CStructArray<GENERICSINK> *_GetActiveTIPNotifySinks() { return &_rgSinks[TIM_SINK_ITfActiveLanguageProfileNotifySink]; }
    CStructArray<GENERICSINK> *_GetDispAttrNotifySinks() { return &_rgSinks[TIM_SINK_ITfDisplayAttributeNotifySink]; }
    CStructArray<GENERICSINK> *_GetUIFocusSinks() { return &_rgSinks[TIM_SINK_ITfUIFocusSink]; }
    CStructArray<GENERICSINK> *_GetPreservedKeyNotifySinks() { return &_rgSinks[TIM_SINK_ITfPreservedKeyNotifySink]; }
    CStructArray<GENERICSINK> *_GetKeyTraceEventSinks() { return &_rgSinks[TIM_SINK_ITfKeyTraceEventSink]; }

    HRESULT _GetActiveInputProcessors(ULONG ulCount, CLSID *pclsid, ULONG *pulCount);
    HRESULT _IsActiveInputProcessor(REFCLSID clsid);
    HRESULT _IsActiveInputProcessorByATOM(TfGuidAtom guidatom);

    BOOL _AppWantsKeystrokes()
    { 
        Assert(_cAppWantsKeystrokesRef >= 0);
        return _cAppWantsKeystrokesRef > 0;
    }
    BOOL _IsKeystrokeFeedEnabled()
    {
        Assert(_cDisableSystemKeystrokeFeedRef >= 0);
        return (_cDisableSystemKeystrokeFeedRef == 0);
    }

    BOOL _AsyncKeyHandler(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten);

    BOOL _IsMSAAEnabled() { return _pAAAdaptor != NULL; }
    IAccServerDocMgr *_GetAAAdaptor() { return _pAAAdaptor; }
    CPtrMap<HWND, CDocumentInputManager> *GetDimWndMap() {return &_dimwndMap;}

    
    CGlobalCompartmentMgr *GetGlobalComp(void)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        return psfn->_pGlobalCompMgr;
    }

    void _CleanupContexts(CLEANUPCONTEXT *pcc);
    void _HandlePendingCleanupContext();
    void _NotifyKeyTraceEventSink(WPARAM wParam, LPARAM lParam);

    ITfSysHookSink *GetSysHookSink() {return _pSysHookSink;}
    TfClientId GetForegroundKeyboardTip() {return _tidForeground;}

    HRESULT _KeyStroke(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, BOOL fSync, DWORD dwFlags);

    void _SendEndCleanupNotifications();

    BOOL _IsValidTfClientId(TfClientId tid)
    {
        CTip *ctip;
        return (tid == g_gaApp) || (tid == g_gaSystem) || _GetCTipfromGUIDATOM(tid, &ctip);
    }

    void _InitMSAA();
    void _UninitMSAA();

    void ClearLangBarItemMgr()
    {
        _plbim = NULL;
    }

private:

    void _CleanupContextsWorker(CLEANUPCONTEXT *pcc);
    
    void _CalcAndSendBeginCleanupNotifications(CLEANUPCONTEXT *pcc);
    
    BOOL _CheckNewActiveView(CDocumentInputManager *pdim);

    HRESULT _CallKeyEventSink(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    HRESULT _CallKeyEventSinkNotForeground(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    HRESULT _CallSimulatePreservedKey(CHotKey *pHotKey, CInputContext *pic, REFGUID rguid, BOOL *pfEaten);
    BOOL _FindHotKeyByTID(TfClientId tid, WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, TimSysHotkey tsh, UINT uModSrc);
    BOOL _FindHotKeyAndIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext **ppic, TimSysHotkey tsh, UINT uModSrc);
    BOOL _FindHotKeyInIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext *pic, TimSysHotkey tsh, UINT uModSrc);
    BOOL _GetFirstPreservedKey(REFGUID rguid, CHotKey **ppHotKey);
    BOOL _CheckPreservedKey(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL fSync);
    HRESULT _OnPreservedKeyUpdate(CHotKey *pHotKey);
    BOOL _IsThisHotKey(TfClientId tid, const TF_PRESERVEDKEY *pprekey);
    HRESULT InternalPreserveKey(CTip *ctip, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags, CHotKey **ppHotKey);
    HRESULT InitDefaultHotkeys();
    HRESULT UninitDefaultHotkeys();

    BOOL _IsMsctfimeDim(ITfDocumentMgr *pdim);

    static BOOL _SetThis(CThreadInputMgr *_this)
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return FALSE;

        psfn->ptim = _this;
        return TRUE;
    }

    static void _StaticInit_OnActivate();

    CStructArray<DWORD> _rgCookie;
    CPtrArray<CHotKey> *_rgHotKey[256];

    CFunctionProvider *_pSysFuncPrv;
    ITfFunctionProvider *_pAppFuncProvider;


    TfClientId _tidForeground;
    TfClientId _tidPrevForeground;


    static const IID *_c_rgConnectionIIDs[TIM_NUM_CONNECTIONPTS];
    CStructArray<GENERICSINK> _rgSinks[TIM_NUM_CONNECTIONPTS];

    CPtrMap<HWND, CDocumentInputManager> _dimwndMap;
    CPtrArray<CTip> _rgTip;
    CDocumentInputManager *_pFocusDocInputMgr;
    int _iActivateRefCount;
    TsViewCookie _vcActiveView; // only valid if _fActiveView == TRUE
    BOOL _fInternalFocusedDim : 1;
    BOOL _fActiveView : 1;

    // aa stuff
    //
    void _MSAA_OnSetFocus(CDocumentInputManager *dim)
    {
        CInputContext *pic;

        if (_pAAAdaptor == NULL)
            return; // no msaa hookup

        pic = (dim == NULL) ? NULL : dim->_GetTopIC();

        _pAAAdaptor->OnDocumentFocus((pic == NULL) ? NULL : pic->_GetAATSI());
    }

    IAccServerDocMgr *_pAAAdaptor;    // the AA adaptor
    //
    // end aa stuff

    ITfLangBarItemMgr *_plbim;


    BOOL _fActiveUI : 1;
    int _cAppWantsKeystrokesRef;
    int _cDisableSystemKeystrokeFeedRef;

    BOOL _fInActivate : 1;
    BOOL _fInDeactivate : 1;
    BOOL _fFirstSetFocusAfterActivated : 1;

    CLEANUPCONTEXT *_pPendingCleanupContext;
    BOOL _fPendingCleanupContext : 1;

    BOOL _fAddedProcessAtom : 1;

    BOOL _fReleaseDisplayAttrMgr : 1;

    ITfSysHookSink *_pSysHookSink;

    DBG_ID_DECLARE;
};


#endif // TIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\timlist.cpp ===
//
// timlist.cpp
//

#include "private.h"
#include "globals.h"
#include "timlist.h"
#include "thdutil.h"

CTimList g_timlist;

CSharedBlock *CTimList::_psb = NULL;
ULONG CTimList::_ulCommitSize = INITIAL_TIMLIST_SIZE;
LONG CTimList::_lInit = -1;

//////////////////////////////////////////////////////////////////////////////
//
// func
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  TF_GetThreadFlags
//
//--------------------------------------------------------------------------

BOOL TF_GetThreadFlags(DWORD dwThreadId, DWORD *pdwFlags, DWORD *pdwProcessId, DWORD *pdwTickTime)
{
    return g_timlist.GetThreadFlags(dwThreadId, pdwFlags, pdwProcessId, pdwTickTime);
}

//--------------------------------------------------------------------------
//
//  TF_IsInMarshaling
//
//--------------------------------------------------------------------------

BOOL TF_IsInMarshaling(DWORD dwThreadId)
{
    TL_THREADINFO *pti;
    pti = g_timlist.IsThreadId(dwThreadId);
    if (!pti)
        return FALSE;

    return pti->ulInMarshal ? TRUE : FALSE;
}

//--------------------------------------------------------------------------
//
//  EnsureTIMList
//
//--------------------------------------------------------------------------

TL_THREADINFO *EnsureTIMList(SYSTHREAD *psfn)
{
    TL_THREADINFO *pti = NULL;

    Assert(psfn);

    if (!g_timlist.IsInitialized())
    {
        if (!g_timlist.Init(FALSE))
            return NULL;

        //
        // we should not see the timlist entry of this thread. This thread
        // is starting now.
        // the thread with same ID was terminated incorrectly so there was no
        // chance to clean timlist up.
        //

        Assert(psfn->dwProcessId == GetCurrentProcessId());
        g_timlist.RemoveProcess(psfn->dwProcessId);
    }

    Assert(psfn->dwThreadId == GetCurrentThreadId());
    pti = g_timlist.IsThreadId(psfn->dwThreadId);

    //
    // check if pti is invalid.
    //
    if (pti && (pti->dwProcessId != psfn->dwProcessId))
    {
         Assert(pti->dwThreadId == psfn->dwThreadId);

         memset(pti, 0, sizeof(TL_THREADINFO));
         pti = NULL;
    }

    if (!pti)
    {
        DWORD dwFlags = 0;

        if (psfn && psfn->plbim)
            dwFlags |= TLF_LBIMGR;

        if (CicTestAppCompat(CIC_COMPAT_NOWAITFORINPUTIDLEONWIN9X))
            dwFlags |= TLF_NOWAITFORINPUTIDLEONWIN9X;

        if (g_fCTFMONProcess)
            dwFlags |= TLF_CTFMONPROCESS;

        pti = g_timlist.AddCurrentThread(dwFlags, psfn);
    }

    if (psfn->pti != pti)
        psfn->pti = pti;

    return pti;
}

//--------------------------------------------------------------------------
//
//  CicIs16bitTask
//
//--------------------------------------------------------------------------

BOOL CicIs16bitTask(DWORD dwProcessId, DWORD dwThreadId)
{
    DWORD dwFlags = g_timlist.GetFlags(dwThreadId);

    if (dwFlags & TLF_16BITTASKCHECKED)
        goto Exit;

    dwFlags = TLF_16BITTASKCHECKED;
    if (Is16bitThread(dwProcessId, dwThreadId))
    {
        dwFlags |= TLF_16BITTASK;
    }
    g_timlist.SetFlags(dwThreadId, dwFlags);

Exit:
    return (dwFlags & TLF_16BITTASK) ? TRUE : FALSE;
}

//--------------------------------------------------------------------------
//
//  PostTimListMessage
//
//--------------------------------------------------------------------------

void PostTimListMessage(DWORD dwMaskFlags, DWORD dwExcludeFlags, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // call PostThreadMessage() to other threads.
    //
    ULONG ulNum = g_timlist.GetNum();
    if (ulNum)
    {
         DWORD *pdw = new DWORD[ulNum + 1];
         if (pdw)
         {
             if (g_timlist.GetList(pdw, ulNum+1, &ulNum, dwMaskFlags, dwExcludeFlags, TRUE))
             {
                 DWORD dwCurThreadId = GetCurrentThreadId();
                 ULONG ul;
                 for (ul = 0; ul < ulNum; ul++)
                 {
                     if (pdw[ul] && (dwCurThreadId != pdw[ul]))
                     {
                         PostThreadMessage(pdw[ul], uMsg, wParam, lParam);
                     }
                 }
             }
             delete pdw;
         }
    }
}


//--------------------------------------------------------------------------
//
//  TLFlagFromTFPriv
//
//--------------------------------------------------------------------------

DWORD TLFlagFromTFPriv(WPARAM wParam)
{
    if (wParam == TFPRIV_UPDATE_REG_IMX)
        return TLF_TFPRIV_UPDATE_REG_IMX_IN_QUEUE;

    if (wParam == TFPRIV_SYSCOLORCHANGED)
        return TLF_TFPRIV_SYSCOLORCHANGED_IN_QUEUE;

    if (wParam == TFPRIV_UPDATE_REG_KBDTOGGLE)
        return TLF_TFPRIV_UPDATE_REG_KBDTOGGLE_IN_QUEUE;

    return 0;
}


//////////////////////////////////////////////////////////////////////////////
//
// CTimList
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

extern char g_szTimListCache[];
BOOL CTimList::Init(BOOL fCreate)
{
    BOOL bRet = FALSE;
    // TIMLIST *ptl;

    if (InterlockedIncrement(&_lInit))
        return TRUE;

    if (!_psb)
        _psb = new CSharedBlockNT(g_szTimListCache, 0, TRUE);

    if (!_psb)
    {
        Assert(0);
        return FALSE;
    }

    HRESULT hr = _psb->Init(NULL, 0x40000, _ulCommitSize, NULL, fCreate);
    if (FAILED(hr))
    {
        //
        // maybe ctfmon.exe does not start yet.
        //
        TraceMsg(TF_GENERAL, "Init: failed");
        goto Exit;
    }

    //
    // ulNum is initialized by VirtualAlloc().
    //
    // ptl = (TIMLIST *)_psb->GetBase();
    //
    // ptl->ulNum = 0;
    //

    bRet = TRUE;

Exit:

    if (!bRet)
        InterlockedDecrement(&_lInit);
    return bRet;
}

//--------------------------------------------------------------------------
//
//  UnInit
//
//--------------------------------------------------------------------------

BOOL CTimList::Uninit()
{
    if (InterlockedDecrement(&_lInit) >= 0)
        return TRUE;

    CleanUp();
    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AddCurrentThread
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::AddCurrentThread(DWORD dwFlags, SYSTHREAD *psfn)
{
    return AddThreadProcess(GetCurrentThreadId(), 
                            GetCurrentProcessId(), 
                            psfn ? psfn->hwndMarshal : NULL,
                            dwFlags);
}

//--------------------------------------------------------------------------
//
//  AddThreadProcess
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::AddThreadProcess(DWORD dwThreadId, DWORD dwProcessId, HWND hwndMarshal,  DWORD dwFlags)
{
    TL_THREADINFO *pti = NULL;
    BOOL bFound = FALSE;
    ULONG ul;

    if (!Enter())
        return pti;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        //
        // check if there is a thread info in the list.
        //
        for (ul = 0; ul < ptl->ulNum; ul++)
        {
            if (!ptl->rgThread[ul].dwThreadId || 
                (ptl->rgThread[ul].dwThreadId == dwThreadId))
            {
                pti = &ptl->rgThread[ul];
                goto InitPTI;
            }
        }


        if (_ulCommitSize <  sizeof(TIMLIST) + (ptl->ulNum * sizeof(TL_THREADINFO)))
        {
            _ulCommitSize = sizeof(TIMLIST) + (ptl->ulNum * sizeof(TL_THREADINFO));
            _ulCommitSize += INITIAL_TIMLIST_SIZE;
            if (FAILED(_psb->Commit(_ulCommitSize)))
            {
                Assert(0);
                goto Exit;
            }
        }

        pti = &ptl->rgThread[ptl->ulNum];
        ptl->ulNum++;

InitPTI:
        memset(pti, 0, sizeof(TL_THREADINFO));
        pti->dwThreadId = dwThreadId;
        pti->dwProcessId = dwProcessId;
        pti->dwFlags = dwFlags;
        pti->hwndMarshal = hwndMarshal;

        pti->dwTickTime = GetTickCount();

    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();
    return pti;
}

//--------------------------------------------------------------------------
//
//  RemoveThread
//
//--------------------------------------------------------------------------

BOOL CTimList::RemoveThread(DWORD dwThreadId)
{
    ULONG ul;
    ULONG ulMax;
    BOOL bRet = FALSE;

    if (!_psb)
        return bRet;
        
    TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
    if (!ptl)
        goto Exit;

    ulMax = ptl->ulNum;
    for (ul = 0; ul < ulMax; ul++)
    {
        if (ptl->rgThread[ul].dwThreadId == dwThreadId)
        {
            memset(&ptl->rgThread[ul], 0, sizeof(TL_THREADINFO));
            break;
        }
    }

    bRet = TRUE;
Exit:
    return bRet;
}

//--------------------------------------------------------------------------
//
//  RemoveProcess
//
//--------------------------------------------------------------------------

BOOL CTimList::RemoveProcess(DWORD dwProcessId)
{
    ULONG ul;
    ULONG ulMax;
    BOOL bRet = FALSE;

    if (!_psb)
        return bRet;

    if (!Enter())
        return bRet;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (ptl)
        {
            ulMax = ptl->ulNum;
            for (ul = 0; ul < ulMax; ul++)
            {
                if (ptl->rgThread[ul].dwProcessId == dwProcessId)
                    memset(&ptl->rgThread[ul], 0, sizeof(TL_THREADINFO));
            }
            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }

    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetNum
//
//--------------------------------------------------------------------------

ULONG CTimList::GetNum()
{
    ULONG ulRet = 0;

    if (!Enter())
        return ulRet;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        ulRet = ptl->ulNum;

    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();
    return ulRet;
}


//--------------------------------------------------------------------------
//
//  GetList
//
//--------------------------------------------------------------------------

BOOL CTimList::GetList(DWORD *pdwOut, ULONG ulMax, DWORD *pdwNum, DWORD dwMaskFlags, DWORD dwExcludeFlags, BOOL fUpdateExcludeFlags)
{
    if (!Enter())
        return FALSE;

    ULONG ul;
    ULONG ulCur = 0;
    BOOL bRet = FALSE;
    DWORD dwTmpFlags = 0;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        for (ul = 0; ul < ptl->ulNum; ul++)
        {
            if (ul >= ulMax)
                break; // no space in caller's buffer

            if (!ptl->rgThread[ul].dwThreadId)
               continue;

            if (ptl->rgThread[ul].dwFlags & dwExcludeFlags)
               continue;

            dwTmpFlags = ptl->rgThread[ul].dwFlags;

            if (fUpdateExcludeFlags)
               dwTmpFlags |= dwExcludeFlags;

            if (!dwMaskFlags || (dwTmpFlags & dwMaskFlags))
            {
                if (pdwOut)
                {
                    pdwOut[ulCur] = ptl->rgThread[ul].dwThreadId;

                    if (fUpdateExcludeFlags)
                       ptl->rgThread[ul].dwFlags |= dwExcludeFlags;
                }
                ulCur++;

            }
        }

Exit:
        if (pdwNum)
            *pdwNum = ulCur;

        bRet = TRUE;
    }
    _except(1)
    {
        Assert(0);
    }

    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetListInProcess
//
//--------------------------------------------------------------------------

BOOL CTimList::GetListInProcess(DWORD *pdwOut, DWORD *pdwNum, DWORD dwProcessId)
{
    if (!Enter())
        return FALSE;

    ULONG ul;
    ULONG ulCur = 0;
    BOOL bRet = FALSE;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        for (ul = 0; ul < ptl->ulNum; ul++)
        {
            if (!ptl->rgThread[ul].dwThreadId)
               continue;

            if (!dwProcessId || (ptl->rgThread[ul].dwProcessId == dwProcessId))
            {
                if (pdwOut)
                    pdwOut[ulCur] = ptl->rgThread[ul].dwThreadId;
                ulCur++;
            }
        }

Exit:
        if (pdwNum)
            *pdwNum = ulCur;

        bRet = TRUE;
    }
    _except(1)
    {
        Assert(0);
    }

    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetFlags
//
//--------------------------------------------------------------------------

DWORD CTimList::GetFlags(DWORD dwThreadId)
{
    return GetDWORD(dwThreadId, TI_FLAGS);
}

//--------------------------------------------------------------------------
//
//  GetProcessId
//
//--------------------------------------------------------------------------

DWORD CTimList::GetProcessId(DWORD dwThreadId)
{
    return GetDWORD(dwThreadId, TI_PROCESSID);
}

//--------------------------------------------------------------------------
//
//  GetThreadId
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::IsThreadId(DWORD dwThreadId)
{
    TL_THREADINFO *pti = NULL;

    if (!Enter())
        return NULL;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();
    return pti;
}

//--------------------------------------------------------------------------
//
//  GetDWORD
//
//--------------------------------------------------------------------------

DWORD CTimList::GetDWORD(DWORD dwThreadId, TIEnum tie)
{
    DWORD dwRet = 0;
    TIMLIST *ptl;
    TL_THREADINFO *pti;

    if (!Enter())
        return 0;

    _try 
    {
        ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            switch (tie)
            {
                case TI_THREADID: 
                    dwRet = pti->dwThreadId;
                    break;

                case TI_PROCESSID: 
                    dwRet = pti->dwProcessId;
                    break;

                case TI_FLAGS: 
                    dwRet = pti->dwFlags;
                    break;
            }
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return dwRet;
}

//--------------------------------------------------------------------------
//
//  SetFlags
//
//--------------------------------------------------------------------------

BOOL CTimList::SetFlags(DWORD dwThreadId, DWORD dwFlags)
{
    return SetClearFlags(dwThreadId, dwFlags, FALSE);
}

//--------------------------------------------------------------------------
//
//  ClearFlags
//
//--------------------------------------------------------------------------

BOOL CTimList::ClearFlags(DWORD dwThreadId, DWORD dwFlags)
{
    return SetClearFlags(dwThreadId, dwFlags, TRUE);
}

//--------------------------------------------------------------------------
//
//  SetClearFlags
//
//--------------------------------------------------------------------------

BOOL CTimList::SetClearFlags(DWORD dwThreadId, DWORD dwFlags, BOOL fClear)
{
    BOOL bRet = FALSE;
    TL_THREADINFO *pti;

    if (!Enter())
        return bRet;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            if (fClear)
                pti->dwFlags &= ~dwFlags;
            else
                pti->dwFlags |= dwFlags;

            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();

    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetDWORD
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::Find(DWORD dwThreadId)
{
    ULONG ul;
    DWORD dwRet = 0;

    Assert(_psb);

    TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
    if (!ptl)
        goto Exit;

    for (ul = 0; ul < ptl->ulNum; ul++)
    {
        if (ptl->rgThread[ul].dwThreadId == dwThreadId)
        {
            return &ptl->rgThread[ul];
        }
    }

Exit:
    return NULL;
}

//--------------------------------------------------------------------------
//
//  GetDWORD
//
//--------------------------------------------------------------------------

BOOL CTimList::GetThreadFlags(DWORD dwThreadId, DWORD *pdwFlags, DWORD *pdwProcessId, DWORD *pdwTickTime)
{
    BOOL bRet = FALSE;
    TIMLIST *ptl;
    TL_THREADINFO *pti;

    if (pdwFlags)
        *pdwFlags = 0;

    if (pdwProcessId)
        *pdwProcessId = 0;

    if (!Enter())
        return FALSE;

    _try
    {
        ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            if (pdwProcessId)
                *pdwProcessId = pti->dwProcessId;

            if (pdwFlags)
                *pdwFlags = pti->dwFlags;

            if (pdwTickTime)
                *pdwTickTime = pti->dwTickTime;

            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  SetMarshalWnd
//
//--------------------------------------------------------------------------

BOOL CTimList::SetMarshalWnd(DWORD dwThreadId, HWND hwndMarshal)
{
    BOOL bRet = FALSE;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return bRet;

    if (!Enter())
        return bRet;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            pti->hwndMarshal = hwndMarshal;
            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetMarshalWnd
//
//--------------------------------------------------------------------------

HWND CTimList::GetMarshalWnd(DWORD dwThreadId)
{
    HWND hwndRet = NULL;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return NULL;

    if (!Enter())
        return NULL;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
            hwndRet = pti->hwndMarshal;

    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return hwndRet;
}

//--------------------------------------------------------------------------
//
//  SetConsoleHKL
//
//--------------------------------------------------------------------------

BOOL CTimList::SetConsoleHKL(DWORD dwThreadId, HKL hkl)
{
    BOOL bRet = FALSE;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return bRet;

    if (!Enter())
        return bRet;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            pti->hklConsole = hkl;
            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetConsoleHKL
//
//--------------------------------------------------------------------------

HKL CTimList::GetConsoleHKL(DWORD dwThreadId)
{
    HKL hklRet = NULL;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return NULL;

    if (!Enter())
        return NULL;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
            hklRet = pti->hklConsole;

    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return hklRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tim.cpp ===
//
// tim.cpp
//

#include "private.h"
#include "lmcons.h" // for UNLEN
#include "tim.h"
#include "dim.h"
#include "range.h"
#include "imelist.h"
#include "nuimgr.h"
#include "assembly.h"
#include "acp2anch.h"
#include "sink.h"
#include "ic.h"
#include "funcprv.h"
#include "enumfnpr.h"
#include "enumdim.h"
#include "profiles.h"
#include "marshal.h"
#include "timlist.h"
#include "nuihkl.h"
#include "immxutil.h"
#include "dam.h"
#include "hotkey.h"
#include "sddl.h"

extern void UninitBackgroundThread(); // bthread.cpp
extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **ppCompMgr);

const IID *CThreadInputMgr::_c_rgConnectionIIDs[TIM_NUM_CONNECTIONPTS] =
{
    &IID_ITfDisplayAttributeNotifySink,
    &IID_ITfActiveLanguageProfileNotifySink,
    &IID_ITfThreadFocusSink,
    &IID_ITfPreservedKeyNotifySink,
    &IID_ITfThreadMgrEventSink,
    &IID_ITfKeyTraceEventSink,
};

BOOL OnForegroundChanged(HWND hwndFocus);

DBG_ID_INSTANCE(CEnumDocumentInputMgrs);

#ifndef _WIN64
static const TCHAR c_szCicLoadMutex[] = TEXT("CtfmonInstMutex");
#else
static const TCHAR c_szCicLoadMutex[] = TEXT("CtfmonInstMutex.IA64");
#endif

static BOOL s_fOnlyTranslationRunning = FALSE;

TCHAR g_szUserUnique[MAX_PATH];
TCHAR g_szUserSidString[MAX_PATH];
BOOL g_fUserSidString = FALSE;

//+---------------------------------------------------------------------------
//
// InitUniqueString
//
//----------------------------------------------------------------------------

char *GetUserSIDString()
{
    HANDLE hToken = NULL;
    char *pszStringSid = NULL;

    OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);

    if (hToken)
    {
        DWORD dwReturnLength = 0;
        void  *pvUserBuffer = NULL;

        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwReturnLength);

        pvUserBuffer = cicMemAllocClear(dwReturnLength);
        if (pvUserBuffer &&
            GetTokenInformation(hToken, 
                                 TokenUser, 
                                 pvUserBuffer, 
                                 dwReturnLength, 
                                 &dwReturnLength))
        {
            if (!ConvertSidToStringSid(((TOKEN_USER*)(pvUserBuffer))->User.Sid,
                                       &pszStringSid))
            {
                if (pszStringSid)
                    LocalFree(pszStringSid);

                pszStringSid = NULL;
            }
                               
        }

        if (pvUserBuffer)
        {
            cicMemFree(pvUserBuffer);
        }
        CloseHandle(hToken);
    }

    return pszStringSid;
}

BOOL InitUserSidString()
{
    if (g_fUserSidString)
        return TRUE;

    char *pStringSid = GetUserSIDString();
    if (pStringSid)
    {
        StringCchCopy(g_szUserSidString, ARRAYSIZE(g_szUserSidString), pStringSid);
        g_fUserSidString = TRUE;
        LocalFree(pStringSid);
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// InitUniqueString
//
//----------------------------------------------------------------------------

BOOL InitUniqueString()
{
    TCHAR ach[MAX_PATH];
    DWORD dwLength;
    HDESK hdesk;

    g_szUserUnique[0] = TEXT('\0');

    hdesk = GetThreadDesktop(GetCurrentThreadId());

    if (hdesk && 
        GetUserObjectInformation(hdesk, UOI_NAME, ach, sizeof(ach) /* byte count */, &dwLength))
    {
        StringCchCat(g_szUserUnique, ARRAYSIZE(g_szUserUnique), ach);
    }

    DWORD dwLen = ARRAYSIZE(ach);
    if (InitUserSidString())
    {
        StringCchCat(g_szUserUnique, ARRAYSIZE(g_szUserUnique), g_szUserSidString);
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetDesktopUniqueName
//
//----------------------------------------------------------------------------

void GetDesktopUniqueName(const TCHAR *pszPrefix, TCHAR *pch, ULONG cchPch)
{
    StringCchCopy(pch, cchPch, pszPrefix);
    StringCchCat(pch, cchPch, g_szUserUnique);
}

//+---------------------------------------------------------------------------
//
// TF_IsCtfmonRunning
//
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_IsCtfmonRunning()
{
    TCHAR ach[MAX_PATH];
    HANDLE hInstanceMutex;

    //
    // get mutex name.
    //
    GetDesktopUniqueName(c_szCicLoadMutex, ach, ARRAYSIZE(ach));


    hInstanceMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, ach);

    if (hInstanceMutex != NULL)
    {
        // ctfmon.exe is already running, don't do any more work
        CloseHandle(hInstanceMutex);
        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// ExecuteLoader
//
//----------------------------------------------------------------------------

const char c_szCtfmonExe[] = "ctfmon.exe";
const char c_szCtfmonExeN[] = "ctfmon.exe -n";

void ExecuteLoader(void)
{
    if (TF_IsCtfmonRunning())
        return;

    FullPathExec(c_szCtfmonExe,
                 s_fOnlyTranslationRunning ? c_szCtfmonExeN : c_szCtfmonExe,
                 SW_SHOWMINNOACTIVE,
                 FALSE);
}

//+---------------------------------------------------------------------------
//
// TF_CreateCicLoadMutex
//
//----------------------------------------------------------------------------

extern "C" HANDLE WINAPI TF_CreateCicLoadMutex(BOOL *pfWinLogon)
{
    *pfWinLogon = FALSE;

    if (IsOnNT())
    {
        //
        // This checking is for logged on user or not. So we can blcok running
        // ctfmon.exe process from non-authorized user.
        //
        if (!IsInteractiveUserLogon())
        {
            g_SharedMemory.Close();
#ifdef WINLOGON_LANGBAR
            g_SharedMemory.Start();
#else
            return NULL;
#endif WINLOGON_LANGBAR
        }
    }

    HANDLE hmutex;
    TCHAR ach[MAX_PATH];

    //
    // get mutex name after calling SetThreadDesktop.
    //
    GetDesktopUniqueName(c_szCicLoadMutex, ach, ARRAYSIZE(ach));

#ifdef __DEBUG
    {
        char szBuf[MAX_PATH];
        wsprintf(szBuf, "TF_CreateCicLoadMutex in %s\r\n", ach);
        OutputDebugString(szBuf);
    }
#endif

    CCicSecAttr sa;
    hmutex =  CreateMutex(sa, FALSE, ach);

    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        //
        // another cicload process is already running        
        //
        CloseHandle(hmutex);
        hmutex = NULL;
    }

    return hmutex;
}

DBG_ID_INSTANCE(CThreadInputMgr);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CThreadInputMgr::CThreadInputMgr()
                :CCompartmentMgr(g_gaApp, COMPTYPE_TIM)
{
    Dbg_MemSetThisNameID(TEXT("CThreadInputMgr"));

    Assert(_GetThis() == NULL);
    _SetThis(this); // save a pointer to this in TLS

    _fAddedProcessAtom = FALSE;
    _SetProcessAtom();

    Assert(_fActiveView == FALSE);
    Assert(_pSysHookSink == NULL);
    Assert(_fFirstSetFocusAfterActivated == FALSE);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CThreadInputMgr::~CThreadInputMgr()
{
    ATOM atom;

    Assert(_tidForeground == TF_INVALID_GUIDATOM);
    Assert(_tidPrevForeground == TF_INVALID_GUIDATOM);

    Assert(_rgTip.Count() == 0);

    Assert(_pPendingCleanupContext == NULL);
    Assert(_pSysHookSink == NULL);

    SafeReleaseClear(_pSysFuncPrv);
    SafeReleaseClear(_pAppFuncProvider);

    // remove ref to this in TLS
    _SetThis(NULL);

    // Release the per-process atom
    if (_fAddedProcessAtom &&
        (atom = FindAtom(TF_PROCESS_ATOM)))
    {
        DeleteAtom(atom);
    }
}

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
BOOL CThreadInputMgr::VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Look up disabling Text Services status from the registry.
    // If it is disabled, return fail not to support Text Services.
    if (IsDisabledTextServices())
        return FALSE;

    if (NoTipsInstalled(&s_fOnlyTranslationRunning))
        return FALSE;

    //
    // Check up the interactive user logon
    //
    if (!IsInteractiveUserLogon())
        return FALSE;

    //
    // #609356
    //
    // we don't want to start Cicero on SMSCliToknAcct& account.
    //
    char szUserName[UNLEN + 1];
    DWORD dwUserNameLen = UNLEN;
    if (GetUserName(szUserName, &dwUserNameLen) && dwUserNameLen)
    {
        if (!lstrcmp(szUserName, "SMSCliToknAcct&"))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SetProcessAtom
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_SetProcessAtom()
{
    if (_fAddedProcessAtom)
        return;

    // AddRef the per-process atom
    if (FindAtom(TF_ENABLE_PROCESS_ATOM))
    {
        AddAtom(TF_PROCESS_ATOM);
        _fAddedProcessAtom = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
// _StaticInit_OnActivate
//
// Init all our process global members. Called from Activate.
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_StaticInit_OnActivate()
{

    CicEnterCriticalSection(g_cs);

    // register two special guid atoms
    MyRegisterGUID(GUID_APPLICATION, &g_gaApp);
    MyRegisterGUID(GUID_SYSTEM, &g_gaSystem);

    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::Activate(TfClientId *ptid)
{
    return ActivateEx(ptid, 0);
}

//+---------------------------------------------------------------------------
//
// ActivateEx
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::ActivateEx(TfClientId *ptid, DWORD dwFlags)
{
    CDisplayAttributeMgr *pDisplayAttrMgr;
    CAssemblyList *pAsmList = NULL;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (ptid == NULL)
        return E_INVALIDARG;

    *ptid = TF_INVALID_GUIDATOM;

    if (_fInDeactivate)
    {
        Assert(0); // woah, we're inside Deactivate higher up the stack...
        return E_UNEXPECTED;
    }
    _fInActivate = TRUE;

    //
    // Windows #476099
    //
    // Under CUAS, TIM could be created before Word set TF_ENABLE_PROCESS_ATIM,
    // so we need to check the atom whenever Activate() is called.
    //
    _SetProcessAtom();

    if (_iActivateRefCount++ > 0)
        goto Exit;

    Assert(_iActivateRefCount == 1);

    ExecuteLoader();

    CtfImmSetCiceroStartInThread(TRUE);

    if (EnsureTIMList(psfn))
        g_timlist.SetFlags(psfn->dwThreadId, TLF_TIMACTIVE | TLF_GCOMPACTIVE);

    // g_gcomplist.Init();

    _StaticInit_OnActivate();

    // dink with active accessibility
    if (GetSharedMemory()->cMSAARef >= 0) // don't worry about mutex since this is just for perf
    {
        _InitMSAA();
    }

    // make sure lbaritems are updated
    TF_CreateLangBarItemMgr(&_plbim);

    //
    // we call _Init here to make sure Reconversion and DeviceType items
    // are added. LangBarItemMgr could be created before TIM is created.
    // Then the LangBarItemMgr does not have Reconversion or DeviceTye items.
    //
    if (psfn && psfn->plbim)
        psfn->plbim->_Init();

    if (psfn)
    {
        //
        // perf: need to find a way to delay allocation.
        //
        pAsmList = EnsureAssemblyList(psfn);
    }

    //
    // warm up the tips
    //
    
    if (!pAsmList || !pAsmList->Count())
        goto Exit;
    
    // keep a ref on the display attr mgr while tips are activated
    Assert(_fReleaseDisplayAttrMgr == FALSE);
    if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) == S_OK)
    {
        _fReleaseDisplayAttrMgr = TRUE;
    }

    if (!(dwFlags & TF_TMAE_NOACTIVATETIP))
    {
        //
        // get first (default) assembly.
        //
        CAssembly *pAsm;
        pAsm = pAsmList->FindAssemblyByLangId(GetCurrentAssemblyLangId(psfn));
        if (pAsm)
            ActivateAssembly(pAsm->GetLangId(), ACTASM_ONTIMACTIVE);
    }

    if (GetSharedMemory()->dwFocusThread == GetCurrentThreadId())
    {
        _OnThreadFocus(TRUE);
    }

    InitDefaultHotkeys();
    _fFirstSetFocusAfterActivated = TRUE;
    
Exit:
    _fInActivate = FALSE;

    *ptid = g_gaApp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::Deactivate()
{
    SYSTHREAD *psfn;
    int i;
    int nCnt;
    HRESULT hr;
    CLEANUPCONTEXT cc;

    if (_fInActivate)
    {
        Assert(0); // woah, we're inside Activate higher up the stack...
        return E_UNEXPECTED;
    }
    _fInDeactivate = TRUE;

    hr = S_OK;

    _iActivateRefCount--;

    if (_iActivateRefCount > 0)
        goto Exit;

    if (_iActivateRefCount < 0)
    {
        Assert(0); // someone is under-refing us
        _iActivateRefCount = 0;
        hr = E_UNEXPECTED;
        goto Exit;
    }

    CtfImmSetCiceroStartInThread(FALSE);

    UninitDefaultHotkeys();

    psfn = GetSYSTHREAD();

    _SetFocus(NULL, TRUE);

    if (_fActiveUI)
    {
        _OnThreadFocus(FALSE);
    }
    _tidPrevForeground = TF_INVALID_GUIDATOM;

    _iActivateRefCount = 0; // must do this after calling _OnThreadFocus(FALSE) or the call will be ignored

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        goto Exit;

    // cleanup all the ics
    cc.fSync = TRUE;
    cc.pCatId = NULL;
    cc.langid = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    cc.pfnPostCleanup = NULL;
    cc.lPrivate = 0;

    _CleanupContexts(&cc);


    // deactivate everyone
    for (i=0; i<_rgTip.Count(); i++)
    {
        CTip *ptip = _rgTip.Get(i);

        if (ptip->_pTip != NULL)
        {
            _DeactivateTip(ptip);
        }
    }
    // wipe out the array after calling everyone
    for (i=0; i<_rgTip.Count(); i++)
    {
        CTip *ptip = _rgTip.Get(i);

        ptip->CleanUp();
        delete ptip;
    }
    _rgTip.Clear();

    if (_pAAAdaptor != NULL)
    {
        _UninitMSAA();
    }

    if (psfn != NULL &&
        psfn->plbim &&
        psfn->plbim->_GetLBarItemDeviceTypeArray() &&
        (nCnt = psfn->plbim->_GetLBarItemDeviceTypeArray()->Count()))
    {
        for (i = 0; i < nCnt; i++)
        {
            CLBarItemDeviceType *plbiDT;
            plbiDT = psfn->plbim->_GetLBarItemDeviceTypeArray()->Get(i);
            if (plbiDT)
                plbiDT->Uninit();
        }
    }

    // g_gcomplist.Uninit();
    g_timlist.ClearFlags(GetCurrentThreadId(), TLF_TIMACTIVE);

    if (_fReleaseDisplayAttrMgr && psfn->pdam != NULL)
    {
        psfn->pdam->Release();
    }
    _fReleaseDisplayAttrMgr = FALSE;

    Perf_DumpStats();

Exit:
    _fInDeactivate = FALSE;
    return hr;
}

//+---------------------------------------------------------------------------
//
// _GetActiveInputProcessors
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_GetActiveInputProcessors(ULONG ulCount, CLSID *pclsid, ULONG *pulCount)
{
    ULONG i;
    ULONG ulCopy;
    ULONG ulCnt;
    HRESULT hr;

    if (!pulCount)
        return E_INVALIDARG;

    ulCnt = _rgTip.Count();
    if (!pclsid)
    {
        ulCopy = 0;
        for (i = 0; i < ulCnt; i++)
        {
            CTip *ptip = _rgTip.Get(i);
            if (ptip->_fActivated)
                 ulCopy++;
        }
        *pulCount = ulCopy;
        return S_OK;
    }

    ulCopy = min((int)ulCount, _rgTip.Count());
    *pulCount = ulCopy;

    hr = S_OK;

    for (i = 0; i < ulCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);

        if (ulCopy && ptip->_fActivated)
        {
            if (FAILED(hr = MyGetGUID(ptip->_guidatom, pclsid)))
                 break;

            pclsid++;
            ulCopy--;
        }
    }
   

    return hr;
}


//+---------------------------------------------------------------------------
//
// IsActivateInputProcessor
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_IsActiveInputProcessor(REFCLSID clsid)
{
    TfGuidAtom guidatom;

    if (FAILED(MyRegisterGUID(clsid, &guidatom)))
        return E_FAIL;

    return _IsActiveInputProcessorByATOM(guidatom);
}

HRESULT CThreadInputMgr::_IsActiveInputProcessorByATOM(TfGuidAtom guidatom)
{
    ULONG i;
    ULONG ulCnt;
    HRESULT hr = E_FAIL;

    ulCnt = _rgTip.Count();
    for (i = 0; i < ulCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);

        if (ptip->_guidatom == guidatom)
        {
            hr = ptip->_fActivated ? S_OK : S_FALSE;
            break;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// ActivateInputProcessor
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::ActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, HKL hklSubstitute, BOOL fActivate)
{
    CTip *ptip;
    HRESULT hr = E_FAIL;

    if (fActivate)
    {
        if (_ActivateTip(clsid, hklSubstitute, &ptip) == S_OK)
        { 
            hr = S_OK;
        }
    }
    else
    {
        TfGuidAtom guidatom;

        if (FAILED(MyRegisterGUID(clsid, &guidatom)))
            return E_FAIL;

        if (_GetCTipfromGUIDATOM(guidatom, &ptip))
        {
            hr = _DeactivateTip(ptip);
        }
    }

    if (hr == S_OK)
    {
        NotifyActivateInputProcessor(clsid, guidProfile, fActivate);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// NotifyActivateInputProcessor
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::NotifyActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, BOOL fActivate)
{
    if (DllShutdownInProgress())
        return S_OK;

    CStructArray<GENERICSINK> *rgActiveTIPNotifySinks;
    int i;

    // Notify this to ITfActiveLanguageProfileNotifySink
    rgActiveTIPNotifySinks = _GetActiveTIPNotifySinks();

    for (i=0; i<rgActiveTIPNotifySinks->Count(); i++)
    {
        ((ITfActiveLanguageProfileNotifySink *)rgActiveTIPNotifySinks->GetPtr(i)->pSink)->OnActivated(clsid, guidProfile, fActivate);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetSubstituteIMEModule
//
// Win98's imm.dll load and free IME module whenever hKL is changed. But 
// Cicero changes hKL frequently even during IME is showing it's on 
// dialog boxies.
// It is bad to free IME module then. So we keep IME's module ref count 
// in CTip.
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_GetSubstituteIMEModule(CTip *ptip, HKL hklSubstitute)
{
    char szIMEFile[MAX_PATH];

    //
    // In NT, system keep the module of IME. So we don't have to cache it.
    //
    if (IsOnNT())
        return;

    if (!IsIMEHKL(hklSubstitute))
        return;

    if (ptip->_hInstSubstituteHKL)
        return;

    if (ImmGetIMEFileNameA(hklSubstitute, szIMEFile, ARRAYSIZE(szIMEFile)))
    {
        ptip->_hInstSubstituteHKL = LoadSystemLibrary(szIMEFile);
    }
}

//+---------------------------------------------------------------------------
//
// ActivateTip
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_ActivateTip(REFCLSID clsid, HKL hklSubstitute, CTip **pptip)
{
    ITfTextInputProcessor *pitip;
    CTip *ptip = NULL;
    HRESULT hr = E_FAIL;
    TfGuidAtom guidatom;
    int i;
    int nCnt;
    BOOL fCoInitCountCkipMode;

    if (FAILED(MyRegisterGUID(clsid, &guidatom)))
        return E_FAIL;

    nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        ptip = _rgTip.Get(i);

        if (ptip->_guidatom == guidatom)
        {
            Assert(ptip->_pTip);
            if (!ptip->_fActivated)
            {
                ptip->_fActivated = TRUE;

                fCoInitCountCkipMode = CtfImmEnterCoInitCountSkipMode();
                ptip->_pTip->Activate(this, guidatom);
                if (fCoInitCountCkipMode)
                    CtfImmLeaveCoInitCountSkipMode();

                hr = S_OK;
                goto Exit;
            }
            hr = S_FALSE;
            goto Exit;
        }
    }

    if (SUCCEEDED(CoCreateInstance(clsid,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfTextInputProcessor, 
                                   (void**)&pitip)))
    {
        CTip **pptipBuf;
        if ((ptip = new CTip) == NULL)
        {
            pitip->Release();
            goto Exit;
        }

        pptipBuf = _rgTip.Append(1);
        if (!pptipBuf)
        {
            delete ptip;
            pitip->Release();
            goto Exit;
        }

        *pptipBuf = ptip;

        ptip->_pTip = pitip;

        ptip->_guidatom = guidatom;
        ptip->_fActivated = TRUE;

        //
        // add refcound of IME file module of klSubstitute.
        //
        _GetSubstituteIMEModule(ptip, hklSubstitute);

        // and activate its ui
        fCoInitCountCkipMode = CtfImmEnterCoInitCountSkipMode();
        ptip->_pTip->Activate(this, guidatom);
        if (fCoInitCountCkipMode)
            CtfImmLeaveCoInitCountSkipMode();

        hr = S_OK;
    }

Exit:
    //
    // Stress 613240
    //
    //   clsid {f25e9f57-2fc8-4eb3-a41a-cce5f08541e6} Tablet PC handwriting 
    //   TIP somehow has this problem. During tip->Activate(), tim seems to
    //   be deactivated. So now _rgTip is empty.
    //
    if (!_rgTip.Count())
    {
        ptip = NULL;
        hr = E_FAIL;
    }

    if (pptip)
        *pptip = ptip;
 
    if (hr == S_OK)
    {
        // hook up any display attribute collections for this tip
        CDisplayAttributeMgr::_AdviseMarkupCollection(ptip->_pTip, guidatom);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// DeactivateTip
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_DeactivateTip(CTip *ptip)
{
    HRESULT hr = S_FALSE;

    //
    // #622929
    //
    // Hack for UninitThread on shutting down.
    //
    SYSTHREAD *psfn = FindSYSTHREAD();
    if (psfn && psfn->fUninitThreadOnShuttingDown)
    {
        Assert(0);
        return S_OK;
    }

    Assert(ptip->_pTip);
    if (ptip->_fActivated)
    {
        BOOL fCoInitCountCkipMode;

        if (ptip->_guidatom == _tidForeground)
        {
            _SetForeground(TF_INVALID_GUIDATOM);
        }

        if (ptip->_guidatom == _tidPrevForeground)
        {
            _tidPrevForeground = TF_INVALID_GUIDATOM;
        }

        ptip->_fActivated = FALSE;

        if (psfn)
            psfn->fDeactivatingTIP = TRUE;

        fCoInitCountCkipMode = CtfImmEnterCoInitCountSkipMode();
        ptip->_pTip->Deactivate();
        if (fCoInitCountCkipMode)
            CtfImmLeaveCoInitCountSkipMode();

        if (psfn)
            psfn->fDeactivatingTIP = FALSE;

        hr = S_OK;

        // unhook any display attribute collections for this tip
        CDisplayAttributeMgr::_UnadviseMarkupCollection(ptip->_guidatom);
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// _OnThreadFocus
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_OnThreadFocus(BOOL fActivate)
{
    int i;
    ITfThreadFocusSink *pUIFocusSink;

    if (_iActivateRefCount == 0)
        return S_OK; // thread has not been Activate'd

    if (_fActiveUI == fActivate)
        return S_OK; // already in a matching state

    _fActiveUI = fActivate;

    if (!fActivate)
    {
        if (_tidForeground != TF_INVALID_GUIDATOM)
        {
            _tidPrevForeground = _tidForeground;
            _tidForeground = TF_INVALID_GUIDATOM;
        }
    }
    else
    {
        if (_tidPrevForeground != TF_INVALID_GUIDATOM)
        {
            _tidForeground = _tidPrevForeground;
            _tidPrevForeground = TF_INVALID_GUIDATOM;
        }
    }

    for (i=0; i<_GetUIFocusSinks()->Count(); i++)
    {
        pUIFocusSink = (ITfThreadFocusSink *)_GetUIFocusSinks()->GetPtr(i)->pSink;
        _try {
            if (fActivate)
            {
                pUIFocusSink->OnSetThreadFocus();
            }
            else
            {
                pUIFocusSink->OnKillThreadFocus();
            }
        }
        _except(1) {
            Assert(0);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreateDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::CreateDocumentMgr(ITfDocumentMgr **ppdim)
{
    CDocumentInputManager *dim;
    CDocumentInputManager **ppSlot;

    if (ppdim == NULL)
        return E_INVALIDARG;

    *ppdim = NULL;

    dim = new CDocumentInputManager;
    if (dim == NULL)
        return E_OUTOFMEMORY;
   
    ppSlot = _rgdim.Append(1);

    if (ppSlot == NULL)
    {
        dim->Release();
        return E_OUTOFMEMORY;
    }

    *ppSlot = dim;
    *ppdim = dim;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CheckNewActiveView
//
// Returns TRUE if the old and new value don't match, and there is both an old and new value.
//         FALSE otherwise.
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_CheckNewActiveView(CDocumentInputManager *pdim)
{
    CInputContext *pic;
    TsViewCookie vcActiveViewOld;
    BOOL fActiveViewOld;

    fActiveViewOld = _fActiveView;
    _fActiveView = FALSE;

    if (pdim == NULL)
        return FALSE;

    vcActiveViewOld = _vcActiveView;

    if (pic = pdim->_GetTopIC())
    {
        if (pic->_GetTSI()->GetActiveView(&_vcActiveView) != S_OK)
        {
            Assert(0); // how did GetActiveView fail?
            return FALSE;
        }
    }
    else
    {
        //
        // empty dim so set null active view.
        //
        _vcActiveView = TS_VCOOKIE_NUL;
    }

    _fActiveView = TRUE;

    return (fActiveViewOld && _vcActiveView != vcActiveViewOld);
}

//+---------------------------------------------------------------------------
//
// _SetFocus
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_SetFocus(CDocumentInputManager *pdim, BOOL fInternal)
{
    int iStack;
    BOOL fDoLayoutNotify;
    BOOL fNewActiveView;
    BOOL fDIMFocusChanged;
    CDocumentInputManager *pPrevFocusDIM;
    SYSTHREAD *psfn = GetSYSTHREAD();
    BOOL fFirstSetFocusAfterActivated;
    BOOL fShutdownInProgress = DllShutdownInProgress();

    fNewActiveView = _CheckNewActiveView(pdim);
    fDoLayoutNotify = FALSE;

    fFirstSetFocusAfterActivated = _fFirstSetFocusAfterActivated;
    _fFirstSetFocusAfterActivated = FALSE;

    _fInternalFocusedDim = fInternal;

    //
    // stop pending focus change.
    //

    if (psfn != NULL )
        psfn->hwndBeingFocused = NULL;

    if (pdim == _pFocusDocInputMgr)
    {
        if (pdim == NULL)
        {
            //
            // we were ready to be acitvated Cicero. But the first setfocus
            // was not Cicero enabled after Activate call....
            //
            // if we or msctfime are in thread detach, we don't
            // have to set assembly back.
            //
            if (psfn && 
                fFirstSetFocusAfterActivated && 
                !psfn->fCUASDllDetachInOtherOrMe)
                SetFocusDIMForAssembly(FALSE);

            return S_OK; // nothing happened (no view change)
        }

        // did the default view change?
        if (!fNewActiveView)
            return S_OK; // nothing happened (no view change)

        fDoLayoutNotify = TRUE;
    }

    pPrevFocusDIM = _pFocusDocInputMgr;;
    _pFocusDocInputMgr = NULL;

    if (pdim != NULL)
    {
#ifdef DEBUG
    {
        BOOL fFound = FALSE;
        int i = 0;
        int nCnt = _rgdim.Count();
        CDocumentInputManager **ppdim = _rgdim.GetPtr(0);
        while (i < nCnt)
        {
            if (*ppdim == pdim)
            {
                fFound = TRUE;
            }
            i++;
            ppdim++;
        }
        if (!fFound)
        {
                Assert(0);
        }
    }
#endif
        _pFocusDocInputMgr = pdim;
        _pFocusDocInputMgr->AddRef();
    }

    if ((!pPrevFocusDIM && _pFocusDocInputMgr) ||
        (pPrevFocusDIM && !_pFocusDocInputMgr))
    {
        fDIMFocusChanged = TRUE;

        //
        // we will call SetFocusDIMForAssembly() and it will makes 
        // ThreadItmChange. So we don't need to handle OnUpdate call.
        //
        if (psfn && psfn->plbim)
            psfn->plbim->StopHandlingOnUpdate();
    }
    else
    {
        fDIMFocusChanged = FALSE;
    }

    //
    // we skip notification in Shutdown
    //
    if (!fShutdownInProgress)
    {
        _MSAA_OnSetFocus(pdim);
        _NotifyCallbacks(TIM_SETFOCUS, pdim, pPrevFocusDIM);
    }

    SafeReleaseClear(pPrevFocusDIM);

    //
    // we skip notification in Shutdown
    //
    if (fShutdownInProgress)
        goto Exit;

    if (fDoLayoutNotify)
    {
        // kick a layout chg notification for the benefit
        // of tips just tracking the active view
        iStack = _pFocusDocInputMgr->_GetCurrentStack();
        if (iStack >= 0)
        {
            _pFocusDocInputMgr->_GetIC(iStack)->OnLayoutChange(TS_LC_CHANGE, _vcActiveView);
        }

    }

    if (fDIMFocusChanged)
    {
        //
        // if we or msctfime are in thread detach, we don't
        // have to set assembly back.
        //
        if (psfn && !psfn->fCUASDllDetachInOtherOrMe)
            SetFocusDIMForAssembly(_pFocusDocInputMgr ? TRUE : FALSE);
    }
    else
    {
        if (psfn && psfn->plbim && psfn->plbim->_GetLBarItemReconv())
            psfn->plbim->_GetLBarItemReconv()->ShowOrHide(TRUE);
    }

    //
    // we now start handling ITfLangBarMge::OnUpdate()
    //
    if (psfn && psfn->plbim)
        psfn->plbim->StartHandlingOnUpdate();

Exit:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetAssoc
//
//----------------------------------------------------------------------------

CDocumentInputManager *CThreadInputMgr::_GetAssoc(HWND hWnd)
{
    CDocumentInputManager *dim;

    dim = _dimwndMap._Find(hWnd);

    return dim;
}

//+---------------------------------------------------------------------------
//
// _GetAssoced
//
//----------------------------------------------------------------------------

HWND CThreadInputMgr::_GetAssoced(CDocumentInputManager *pdim)
{
    HWND hwnd = NULL;

    if (!pdim)
        return NULL;

    if (_dimwndMap._FindKey(pdim, &hwnd))
        return hwnd;

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _GetGUIDATOMfromITfIME
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetGUIDATOMfromITfIME(ITfTextInputProcessor *pTip, TfGuidAtom *pguidatom)
{
    int i;
    int nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);
        if (ptip->_pTip == pTip)
        {
            *pguidatom = ptip->_guidatom;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _GetITfIMEfromCLSID
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetITfIMEfromGUIDATOM(TfGuidAtom guidatom, ITfTextInputProcessor **ppTip)
{
    int i;
    int nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);
        if (ptip->_guidatom == guidatom)
        {
            *ppTip = ptip->_pTip;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _GetCTipfromCLSID
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetCTipfromGUIDATOM(TfGuidAtom guidatom, CTip **pptip)
{
    int i;
    int nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);
        if (ptip->_guidatom == guidatom)
        {
            *pptip = ptip;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _NotifyCallbacks
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_NotifyCallbacks(TimNotify notify, CDocumentInputManager *dim, void *pv)
{
    int i;

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        return;

    CStructArray<GENERICSINK> *_rgSink = _GetThreadMgrEventSink();

    i = 0;
    while(i < _rgSink->Count())
    {
        int nCnt = _rgSink->Count();
        ITfThreadMgrEventSink *pSink = (ITfThreadMgrEventSink *)_rgSink->GetPtr(i)->pSink;

        switch (notify)
        {
            case TIM_INITDIM:
                pSink->OnInitDocumentMgr(dim);
                break;

            case TIM_UNINITDIM:
                pSink->OnUninitDocumentMgr(dim);
                break;

            case TIM_SETFOCUS:
                pSink->OnSetFocus(dim, (ITfDocumentMgr *)pv);
                break;

            case TIM_INITIC:
                pSink->OnPushContext((ITfContext *)pv);
                break;

            case TIM_UNINITIC:
                pSink->OnPopContext((ITfContext *)pv);
                break;
        }

        if (i >= _rgSink->Count())
            break;

        if (nCnt == _rgSink->Count())
            i++;
    }
}

//+---------------------------------------------------------------------------
//
// UpdateDispAttr
//
//----------------------------------------------------------------------------

void CThreadInputMgr::UpdateDispAttr()
{
    CStructArray<GENERICSINK> *rgDispAttrNotifySinks;
    int i;

    rgDispAttrNotifySinks = _GetDispAttrNotifySinks();

    for (i=0; i<rgDispAttrNotifySinks->Count(); i++)
    {
        ((ITfDisplayAttributeNotifySink *)rgDispAttrNotifySinks->GetPtr(i)->pSink)->OnUpdateInfo();
    }
}

//+---------------------------------------------------------------------------
//
// InitSystemFunctionProvider
//
//----------------------------------------------------------------------------

void CThreadInputMgr::InitSystemFunctionProvider()
{
    if (_pSysFuncPrv)
        return;
    //
    // register system function provider.
    //
    _pSysFuncPrv = new CFunctionProvider();
}

//+---------------------------------------------------------------------------
//
// InitSystemFunctionProvider
//
//----------------------------------------------------------------------------

CFunctionProvider *CThreadInputMgr::GetSystemFunctionProvider() 
{
    InitSystemFunctionProvider();
    if (_pSysFuncPrv)
        _pSysFuncPrv->AddRef();

    return _pSysFuncPrv;
}

//+---------------------------------------------------------------------------
//
// GetFunctionProvider
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetFunctionProvider(REFCLSID clsidTIP, ITfFunctionProvider **ppv)
{
    TfGuidAtom guidatom;
    HRESULT hr = TF_E_NOPROVIDER;
    CTip *ctip;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    // 
    // create system function provider, if it is not create yet.
    // 
    if (IsEqualGUID(clsidTIP, GUID_SYSTEM_FUNCTIONPROVIDER))
    {
        *ppv = GetSystemFunctionProvider();
        hr = (*ppv) ? S_OK : E_FAIL;
        goto Exit;
    }
    else if (IsEqualGUID(clsidTIP, GUID_APP_FUNCTIONPROVIDER))
    {
        if (_pAppFuncProvider == NULL)
            goto Exit;

        *ppv = _pAppFuncProvider;
    }
    else
    {
        if (FAILED(MyRegisterGUID(clsidTIP, &guidatom)))
            goto Exit;
        if (!_GetCTipfromGUIDATOM(guidatom, &ctip))
            goto Exit;

        if (ctip->_pFuncProvider == NULL)
            goto Exit;

        *ppv = ctip->_pFuncProvider;
    }

    (*ppv)->AddRef();
    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// EnumFunctionProviders
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnumFunctionProviders(IEnumTfFunctionProviders **ppEnum)
{
    CEnumFunctionProviders *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    *ppEnum = NULL;
    // 
    // create system function provider, if it is not create yet.
    // 
    InitSystemFunctionProvider();

    pEnum = new CEnumFunctionProviders();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
    {
        pEnum->Release();
        return E_FAIL;
    }
    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie)
{
    return GenericAdviseSink(refiid, punk, _c_rgConnectionIIDs, _rgSinks, TIM_NUM_CONNECTIONPTS, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(_rgSinks, TIM_NUM_CONNECTIONPTS, dwCookie);
}

//+---------------------------------------------------------------------------
//
// AdviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk)
{
    CTip *ctip;

    if (punk == NULL)
        return E_INVALIDARG;

    if (tid == g_gaApp)
    {
        if (IsEqualIID(riid, IID_ITfFunctionProvider))
        {
            if (_pAppFuncProvider)
                return CONNECT_E_ADVISELIMIT;

            if (punk->QueryInterface(IID_ITfFunctionProvider, (void **)&_pAppFuncProvider) != S_OK)
                return E_NOINTERFACE;
    
            return S_OK;
        }
    }

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_ITfFunctionProvider))
    {
        if (ctip->_pFuncProvider != NULL)
             return CONNECT_E_ADVISELIMIT;

        if (punk->QueryInterface(IID_ITfFunctionProvider, (void **)&ctip->_pFuncProvider) != S_OK)
            return E_NOINTERFACE;

        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextDurationSink))
    {
        if (ctip->_pCleanupDurationSink != NULL)
             return CONNECT_E_ADVISELIMIT;

        if (punk->QueryInterface(IID_ITfCleanupContextDurationSink, (void **)&ctip->_pCleanupDurationSink) != S_OK)
            return E_NOINTERFACE;

        return S_OK;        
    }

    return CONNECT_E_CANNOTCONNECT;
}

//+---------------------------------------------------------------------------
//
// UnadviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseSingleSink(TfClientId tid, REFIID riid)
{
    CTip *ctip;

    if (tid == g_gaApp)
    {
        if (IsEqualIID(riid, IID_ITfFunctionProvider))
        {
            if (_pAppFuncProvider == NULL)
                 return CONNECT_E_NOCONNECTION;

            SafeReleaseClear(_pAppFuncProvider);

            return S_OK;
        }
    }

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_ITfFunctionProvider))
    {
        if (ctip->_pFuncProvider == NULL)
             return CONNECT_E_NOCONNECTION;

        SafeReleaseClear(ctip->_pFuncProvider);

        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextDurationSink))
    {
        if (ctip->_pCleanupDurationSink == NULL)
             return CONNECT_E_NOCONNECTION;

        SafeReleaseClear(ctip->_pCleanupDurationSink);

        return S_OK;
    }

    return CONNECT_E_NOCONNECTION;
}

//+---------------------------------------------------------------------------
//
// EnumItems
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnumItems(IEnumTfLangBarItems **ppEnum)
{
    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->EnumItems(ppEnum);
}

//+---------------------------------------------------------------------------
//
// GetItem
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItem(REFGUID rguid, ITfLangBarItem **ppItem)
{
    if (ppItem == NULL)
        return E_INVALIDARG;

    *ppItem = NULL;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItem(rguid, ppItem);
}

//+---------------------------------------------------------------------------
//
// AddItem
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AddItem(ITfLangBarItem *punk)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->AddItem(punk);
}

//+---------------------------------------------------------------------------
//
// RemoveItem
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::RemoveItem(ITfLangBarItem *punk)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->RemoveItem(punk);
}

//+---------------------------------------------------------------------------
//
// AdviseItemSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguid)
{
    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = 0;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->AdviseItemSink(punk, pdwCookie, rguid);
}

//+---------------------------------------------------------------------------
//
// UnadviseItemSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseItemSink(DWORD dwCookie)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->UnadviseItemSink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetItemFloatingRect
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    if (prc == NULL)
        return E_INVALIDARG;

    memset(prc, 0, sizeof(*prc));

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItemFloatingRect(dwThreadId, rguid, prc);
}

//+---------------------------------------------------------------------------
//
// GetItemsStatus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItemsStatus(ulCount, prgguid, pdwStatus);
}

//+---------------------------------------------------------------------------
//
// GetItemNum
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItemNum(ULONG *pulCount)
{
    if (pulCount == NULL)
        return E_INVALIDARG;

    *pulCount = 0;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItemNum(pulCount);
}

//+---------------------------------------------------------------------------
//
// GetItems
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItems(ulCount, ppItem,  pInfo, pdwStatus, pcFetched);
}

//+---------------------------------------------------------------------------
//
// AdviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadInputMgr::AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->AdviseItemsSink(ulCount, ppunk, pguidItem, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadInputMgr::UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->UnadviseItemsSink(ulCount, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// EnumDocumentInputMgrs
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnumDocumentMgrs(IEnumTfDocumentMgrs **ppEnum)
{
    CEnumDocumentInputMgrs *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    if ((pEnum = new CEnumDocumentInputMgrs()) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetFocus(ITfDocumentMgr **ppdimFocus)
{
    if (ppdimFocus == NULL)
        return E_INVALIDARG;

    *ppdimFocus = _pFocusDocInputMgr;

    if (*ppdimFocus)
    {
        (*ppdimFocus)->AddRef();
        return S_OK;
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SetFocus(ITfDocumentMgr *pdimFocus)
{
    CDocumentInputManager *dim = NULL;
    HRESULT hr;
               
    if (pdimFocus && (dim = GetCDocumentInputMgr(pdimFocus)) == NULL)
        return E_INVALIDARG;

    // pdimFocus may be NULL, which means clear the focus
    // (_tim->_SetFocus will check for this)
    hr = _SetFocus(dim, FALSE);

    SafeRelease(dim);

    //
    // #602692
    //
    // The richedit calls SetFocus(dim) when it gets WM_SETFOCUS.
    // But user32!SetFocus() of this WM_SETFOCUS could be made by 
    // AcitivateWindow() of another user32!SetFocus() call.
    // If this happens, CBTHook() has been called and we won't get
    // another notification when pq->hwndFocus is changed.
    // 
    // So we can not call OnForegroundChanges() right now and need to wait
    // until pq->hwndFocus() set. So we can trust user32!GetFocus().
    //
    PostThreadMessage(GetCurrentThreadId(), 
        g_msgPrivate, 
        TFPRIV_ONSETWINDOWFOCUS,  
        (LPARAM)-2);

    return hr;
}

//+---------------------------------------------------------------------------
//
// AssociateFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AssociateFocus(HWND hwnd, ITfDocumentMgr *pdimNew, ITfDocumentMgr **ppdimPrev)
{
    CDocumentInputManager *dim;
    CDocumentInputManager *dimNew;
    SYSTHREAD *psfn;

    if (ppdimPrev == NULL)
        return E_INVALIDARG;

    *ppdimPrev = NULL;

    if (!IsWindow(hwnd))
        return E_INVALIDARG;

    if (pdimNew == NULL)
    {
        dimNew = NULL;
    }
    else if ((dimNew = GetCDocumentInputMgr(pdimNew)) == NULL)
        return E_INVALIDARG;

    // get the old association and remove it from our list
    dim = _GetAssoc(hwnd);

    if (dim != NULL)
    {
        _dimwndMap._Remove(hwnd);
    }

    *ppdimPrev = dim;
    if (*ppdimPrev)
       (*ppdimPrev)->AddRef();

    // setup the new assoc
    // nb: we don't AddRef the dim, since we assume caller will clear before releasing it
    if (dimNew != NULL)
    {
        _dimwndMap._Set(hwnd, dimNew);
    }

    //
    // if some window is being focused, we will have another _SetFocus().
    // Then we don't have to call _SetFocus() now.
    //
    psfn = GetSYSTHREAD();
    if (psfn && !psfn->hwndBeingFocused && (hwnd == ::GetFocus()))
        _SetFocus(dimNew, TRUE);

    SafeRelease(dimNew);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::IsThreadFocus(BOOL *pfUIFocus)
{
    if (pfUIFocus == NULL)
        return E_INVALIDARG;

    *pfUIFocus = _fActiveUI;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetAssociated
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetAssociated(HWND hWnd, ITfDocumentMgr **ppdim)
{
    //
    // we may need to have a more complex logic here.
    // Some application does not call AssociateFocus and it may
    // handle the dim focus by it self. The we need to walk all TSI and 
    // find the window is associated to an IC.
    //
    *ppdim = _GetAssoc(hWnd);
    if (*ppdim)
        (*ppdim)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetSysHookSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SetSysHookSink(ITfSysHookSink *pSink)
{    
    // nb: this is a private, internal interface method
    // so we break COM rules and DON'T AddRef pSink (to avoid a circular ref)
    // we'll get a call later with pSink == NULL to clear it out
    // the pointer is contained in the life of the aimm layer tip,
    // which is responsible for NULLing it out before unloading
    _pSysHookSink = pSink;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RequestPostponedLock
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::RequestPostponedLock(ITfContext *pic)
{    
    HRESULT hr = E_FAIL;
    CInputContext *pcic = GetCInputContext(pic);
    if (!pcic)
        goto Exit;

    if (pcic->_fLockHeld)
        pcic->_EmptyLockQueue(pcic->_dwlt, FALSE);
    else
    {
        SYSTHREAD *psfn;
        if (psfn = GetSYSTHREAD())
        {
            CInputContext::_PostponeLockRequestCallback(psfn, pcic);
        }
    }
    hr = S_OK;

Exit:
    SafeRelease(pcic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGlobalCompartment
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetGlobalCompartment(ITfCompartmentMgr **ppCompMgr)
{
    return TF_GetGlobalCompartment(ppCompMgr);
}

//+---------------------------------------------------------------------------
//
// GetClientId
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetClientId(REFCLSID rclsid, TfClientId *ptid)
{
    TfGuidAtom guidatom;
    if (!ptid)
        return E_INVALIDARG;

    *ptid = TF_INVALID_GUIDATOM;

    if (FAILED(MyRegisterGUID(rclsid, &guidatom)))
        return E_FAIL;

    *ptid = guidatom;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CallImm32Hotkeyhandler
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::CallImm32HotkeyHanlder(WPARAM wParam, LPARAM lParam, BOOL *pbHandled)
{
    if (!pbHandled)
        return E_INVALIDARG;

    *pbHandled = CheckImm32HotKey(wParam, lParam);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tom.cpp ===
//
// tom.cpp
//

#include "private.h"
#include "range.h"
#include "tim.h"
#include "ic.h"
#include "immxutil.h"
#include "dim.h"
#include "view.h"
#include "tsi.h"
#include "compose.h"
#include "profiles.h"
#include "fnrecon.h"
#include "acp2anch.h"

//+---------------------------------------------------------------------------
//
// GetSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched)
{
    HRESULT hr;
    TS_SELECTION_ANCHOR sel;
    TS_SELECTION_ANCHOR *pSelAnchor;
    ULONG i;
    ULONG j;
    CRange *range;

    if (pcFetched == NULL)
        return E_INVALIDARG;

    *pcFetched = 0;

    if (pSelection == NULL && ulCount > 0)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (ulCount == 1)
    {
        pSelAnchor = &sel;
    }
    else if ((pSelAnchor = (TS_SELECTION_ANCHOR *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ANCHOR))) == NULL)
        return E_OUTOFMEMORY;

    if ((hr = _ptsi->GetSelection(ulIndex, ulCount, pSelAnchor, pcFetched)) != S_OK)
        goto Exit;

    // verify the anchors
    for (i=0; i<*pcFetched; i++)
    {
        if (pSelAnchor[i].paStart == NULL ||
            pSelAnchor[i].paEnd == NULL ||
            CompareAnchors(pSelAnchor[i].paStart, pSelAnchor[i].paEnd) > 0)
        {
            // free up all the anchors
            for (j=0; j<*pcFetched; j++)
            {
                SafeRelease(pSelAnchor[i].paStart);
                SafeRelease(pSelAnchor[i].paEnd);
            }
            hr = E_FAIL;
            goto Exit;
        }
    }

    // anchors -> ranges
    for (i=0; i<*pcFetched; i++)
    {
        range = new CRange;
        pSelection[i].range = (ITfRangeAnchor *)range;

        if (range == NULL ||
            !range->_InitWithDefaultGravity(this, OWN_ANCHORS, pSelAnchor[i].paStart, pSelAnchor[i].paEnd))
        {
            SafeRelease(range);
            SafeRelease(pSelAnchor[i].paStart);
            SafeRelease(pSelAnchor[i].paEnd);
            while (i>0) // need to free up all the ranges already allocated
            {
                pSelection[--i].range->Release();
            }
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        pSelection[i].style.ase = (TfActiveSelEnd)pSelAnchor[i].style.ase;
        pSelection[i].style.fInterimChar = pSelAnchor[i].style.fInterimChar;
    }

Exit:
    if (hr != S_OK)
    {
        *pcFetched = 0;
    }
    if (pSelAnchor != &sel)
    {
        cicMemFree(pSelAnchor);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection)
{
    CRange *pRangeP;
    HRESULT hr;
    TS_SELECTION_ANCHOR sel;
    TS_SELECTION_ANCHOR *pSelAnchor;
    ULONG i;
    BOOL fPrevInterimChar;
    BOOL fEqual;
    IAnchor *paTest;
    LONG cchShift;

    if (ulCount == 0)
        return E_INVALIDARG;
    if (pSelection == NULL)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (ulCount == 1)
    {
        pSelAnchor = &sel;
    }
    else if ((pSelAnchor = (TS_SELECTION_ANCHOR *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ANCHOR))) == NULL)
        return E_OUTOFMEMORY;

    // convert to TS_SELECTION_ANCHOR
    fPrevInterimChar = FALSE;

    for (i=0; i<ulCount; i++)
    {
        hr = E_INVALIDARG;

        if (pSelection[i].range == NULL)
            goto Exit;

        if ((pRangeP = GetCRange_NA(pSelection[i].range)) == NULL)
            goto Exit;

        pSelAnchor[i].paStart = pRangeP->_GetStart(); // no AddRef here
        pSelAnchor[i].paEnd = pRangeP->_GetEnd();

        if (pSelection[i].style.fInterimChar)
        {
            // verify this really has length 1, and there's only one in the array
            if (fPrevInterimChar)
                goto Exit;

            if (pSelection[i].style.ase != TS_AE_NONE)
                goto Exit;

            if (pSelAnchor[i].paStart->Clone(&paTest) == S_OK)
            {
                if (paTest->Shift(0, 1, &cchShift, NULL) != S_OK)
                    goto EndTest;

                if (cchShift != 1)
                    goto EndTest;

                if (paTest->IsEqual(pSelAnchor[i].paEnd, &fEqual) != S_OK || !fEqual)
                    goto EndTest;

                hr = S_OK;
EndTest:
                paTest->Release();
                if (hr != S_OK)
                    goto Exit;
            }

            fPrevInterimChar = TRUE;
        }

        pSelAnchor[i].style.ase = (TsActiveSelEnd)pSelection[i].style.ase;
        pSelAnchor[i].style.fInterimChar = pSelection[i].style.fInterimChar;
    }

    hr = _ptsi->SetSelection(ulCount, pSelAnchor);

    if (hr != S_OK)
        goto Exit;

    // app won't notify us about sel changes we cause, so do that manually
    _OnSelectionChangeInternal(FALSE);

Exit:
    if (pSelAnchor != &sel)
    {
        cicMemFree(pSelAnchor);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// RequestEditSession
//
//----------------------------------------------------------------------------

STDAPI CInputContext::RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession)
{
    BOOL fForceAsync;
    TS_QUEUE_ITEM item;
    DWORD dwEditSessionFlagsOrg;

    if (phrSession == NULL)
        return E_INVALIDARG;

    *phrSession = E_FAIL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (pes == NULL ||
        (dwFlags & TF_ES_READ) == 0 ||
        (dwFlags & ~(TF_ES_SYNC | TF_ES_ASYNC | TF_ES_ALL_ACCESS_BITS)) != 0 ||
        ((dwFlags & TF_ES_SYNC) && (dwFlags & TF_ES_ASYNC)))
    {
        Assert(0);
        return E_INVALIDARG;
    }

    if (dwFlags & TF_ES_WRITE)
    {
        // TS_ES_WRITE implies TF_ES_PROPERTY_WRITE, so set it here to make life easier
        // for binary compat with cicero 1.0, we couldn't redefine TF_ES_READWRITE to include the third bit
        dwFlags |= TF_ES_PROPERTY_WRITE;
    }

    fForceAsync = (dwFlags & TF_ES_ASYNC);

    if ((dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) && (_dwEditSessionFlags & TF_ES_INNOTIFY))
    {
        // we're in _NotifyEndEdit or OnLayoutChange -- we only allow read locks here
        if (!(dwFlags & TF_ES_SYNC))
        {
            fForceAsync = TRUE;
        }
        else
        {
            Assert(0); // we can't do a synchronous write during a notification callback
            *phrSession = TF_E_SYNCHRONOUS;
            return S_OK;
        }
    }
    else if (!fForceAsync && (_dwEditSessionFlags & TF_ES_INEDITSESSION))
    {
        *phrSession = TF_E_LOCKED; // edit sessions are generally not re-entrant

        // no reentrancy if caller wants a write lock but current lock is read-only
        // nb: this explicitly disallows call stacks like: write-read-write, the
        // inner write would confuse the preceding reader, who doesn't expect changes
        if ((dwFlags & TF_ES_WRITE) && !(_dwEditSessionFlags & TF_ES_WRITE) ||
            (dwFlags & TF_ES_PROPERTY_WRITE) && !(_dwEditSessionFlags & TF_ES_PROPERTY_WRITE))
        {
            if (!(dwFlags & TF_ES_SYNC))
            {
                // request is TS_ES_ASYNCDONTCARE, so we'll make it async to recover
                fForceAsync = TRUE;
                goto QueueItem;
            }

            Assert(0);
            return TF_E_LOCKED;
        }

        // only allow reentrant write locks for the same tip
        if ((dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) && _tidInEditSession != tid)
        {
            Assert(0);
            return TF_E_LOCKED;
        }

        dwEditSessionFlagsOrg = _dwEditSessionFlags;
        // adjust read/write access for inner es
        _dwEditSessionFlags = (_dwEditSessionFlags & ~TF_ES_ALL_ACCESS_BITS) | (dwFlags & TF_ES_ALL_ACCESS_BITS);

        // ok, do it
        *phrSession = pes->DoEditSession(_ec);

        _dwEditSessionFlags = dwEditSessionFlagsOrg;

        return S_OK;
    }

QueueItem:
    //
    // Don't queue the write lock item when the doc is read only.
    //
    if (dwFlags & TF_ES_WRITE) 
    {
        TS_STATUS dcs;
        if (SUCCEEDED(GetStatus(&dcs)))
        {
            if (dcs.dwDynamicFlags & TF_SD_READONLY)
            {
                *phrSession = TS_E_READONLY;
                return S_OK;
            }
        }
    }

    item.pfnCallback = _EditSessionQiCallback;
    item.dwFlags = dwFlags;
    item.state.es.tid = tid;
    item.state.es.pes = pes;

    return _QueueItem(&item, fForceAsync, phrSession);
}

//+---------------------------------------------------------------------------
//
// _EditSessionQiCallback
//
//----------------------------------------------------------------------------

/* static */
HRESULT CInputContext::_EditSessionQiCallback(CInputContext *pic, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode)
{
    HRESULT hr = S_OK;

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        return hr;

    //
    // #507366
    //
    // Random AV happens with SPTIP's edit session.
    // #507366 might be fixed by #371798 (sptip). However it is nice to
    // have a pointer checking and protect the call by an exception handler.
    //
    if (!pItem->state.es.pes)
        return E_FAIL;

    switch (qiCode)
    {
        case QI_ADDREF:
            //
            // #507366
            //
            // Random AV happens with SPTIP's edit session.
            // #507366 might be fixed by #371798 (sptip). However it is nice to
            // have a pointer checking and protect the call by an exception 
            // handler.
            //
            _try {
                pItem->state.es.pes->AddRef();
            }
            _except(1) {
                Assert(0);
            }
            break;

        case QI_DISPATCH:
            hr = pic->_DoEditSession(pItem->state.es.tid, pItem->state.es.pes, pItem->dwFlags);
            break;

        case QI_FREE:
            //
            // #507366
            //
            // Random AV happens with SPTIP's edit session.
            // #507366 might be fixed by #371798 (sptip). However it is nice to
            // have a pointer checking and protect the call by an exception 
            // handler.
            //
            _try {
                pItem->state.es.pes->Release();
            }
            _except(1) {
                Assert(0);
            }
            break;

        default:
            Assert(0);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _PseudoSyncEditSessionQiCallback
//
//----------------------------------------------------------------------------

/* static */
HRESULT CInputContext::_PseudoSyncEditSessionQiCallback(CInputContext *_this, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode)
{
    HRESULT hr;
    DWORD      dwEditSessionFlags;
    TfClientId tidInEditSession;

    if (qiCode != QI_DISPATCH)
        return S_OK; // we can skip QI_ADDREF, QI_FREE since everything is synchronous/on the stack

    hr = S_OK;

    //
    // hook up fake ec here!
    //
    // NB: this code is very similar to _DoEditSession
    // make sure the logic stays consistent

    if (_this->_dwEditSessionFlags & TF_ES_INEDITSESSION)
    {
        Assert((TF_ES_WRITE & _this->_dwEditSessionFlags) ||
                !(TF_ES_WRITE & pItem->dwFlags));

        dwEditSessionFlags = _this->_dwEditSessionFlags;
        tidInEditSession = _this->_tidInEditSession;
    }
    else
    {
        dwEditSessionFlags = _this->_dwEditSessionFlags & ~TF_ES_ALL_ACCESS_BITS;
        tidInEditSession = TF_CLIENTID_NULL;
    }

    _this->_dwEditSessionFlags |= (TF_ES_INEDITSESSION | (pItem->dwFlags & TF_ES_ALL_ACCESS_BITS));
    _this->_tidInEditSession = g_gaSystem;

    //
    // dispatch
    //
    switch (pItem->state.pes.uCode)
    {
        case PSEUDO_ESCB_TERMCOMPOSITION:
            _this->_TerminateCompositionWithLock((ITfCompositionView *)pItem->state.pes.pvState, _this->_ec);
            break;

        case PSEUDO_ESCB_UPDATEKEYEVENTFILTER:
            _this->_UpdateKeyEventFilterCallback(_this->_ec);
            break;

        case PSEUDO_ESCB_GROWRANGE:
            GrowEmptyRangeByOneCallback(_this->_ec, (ITfRange *)pItem->state.pes.pvState);
            break;

        case PSEUDO_ESCB_BUILDOWNERRANGELIST:
            {
            BUILDOWNERRANGELISTQUEUEINFO *pbirl;
            pbirl = (BUILDOWNERRANGELISTQUEUEINFO *)(pItem->state.pes.pvState);
            pbirl->pFunc->BuildOwnerRangeListCallback(_this->_ec, _this, pbirl->pRange);
            }
            break;

        case PSEUDO_ESCB_SHIFTENDTORANGE:
            {
            SHIFTENDTORANGEQUEUEITEM *pqItemSER;
            pqItemSER = (SHIFTENDTORANGEQUEUEITEM*)(pItem->state.pes.pvState);
            pqItemSER->pRange->ShiftEndToRange(_this->_ec, pqItemSER->pRangeTo, pqItemSER->aPos);
            }
            break;

        case PSEUDO_ESCB_GETSELECTION:
            {
            GETSELECTIONQUEUEITEM *pqItemGS;
            pqItemGS = (GETSELECTIONQUEUEITEM *)(pItem->state.pes.pvState);
            GetSelectionSimple(_this->_ec, _this, pqItemGS->ppRange);
            break;
            }
            break;

        case PSEUDO_ESCB_SERIALIZE_ACP:
        {
            SERIALIZE_ACP_PARAMS *pParams = (SERIALIZE_ACP_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pWrap->_Serialize(pParams->pProp, pParams->pRange, pParams->pHdr, pParams->pStream);

            break;
        }

        case PSEUDO_ESCB_SERIALIZE_ANCHOR:
        {
            SERIALIZE_ANCHOR_PARAMS *pParams = (SERIALIZE_ANCHOR_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pProp->_Serialize(pParams->pRange, pParams->pHdr, pParams->pStream);

            break;
        }

        case PSEUDO_ESCB_UNSERIALIZE_ACP:
        {
            UNSERIALIZE_ACP_PARAMS *pParams = (UNSERIALIZE_ACP_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pWrap->_Unserialize(pParams->pProp, pParams->pHdr, pParams->pStream, pParams->pLoaderACP);

            break;
        }

        case PSEUDO_ESCB_UNSERIALIZE_ANCHOR:
        {
            UNSERIALIZE_ANCHOR_PARAMS *pParams = (UNSERIALIZE_ANCHOR_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pProp->_Unserialize(pParams->pHdr, pParams->pStream, pParams->pLoader);

            break;
        }

        case PSEUDO_ESCB_GETWHOLEDOCRANGE:
            {
            GETWHOLEDOCRANGE *pqItemGWDR;
            pqItemGWDR = (GETWHOLEDOCRANGE *)(pItem->state.pes.pvState);
            GetRangeForWholeDoc(_this->_ec, _this, pqItemGWDR->ppRange);
            }
            break;
    }

    //
    // notify/cleanup
    //
    if (pItem->dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) // don't bother if it was read-only
    {
        _this->_NotifyEndEdit();
    }

    if (tidInEditSession == TF_CLIENTID_NULL)
        _this->_IncEditCookie(); // next edit cookie value

    _this->_dwEditSessionFlags = dwEditSessionFlags;
    _this->_tidInEditSession = tidInEditSession;

    return hr;
}

//+---------------------------------------------------------------------------
//
// InWriteSession
//
//----------------------------------------------------------------------------

STDAPI CInputContext::InWriteSession(TfClientId tid, BOOL *pfWriteSession)
{
    if (pfWriteSession == NULL)
        return E_INVALIDARG;

    *pfWriteSession = (_dwEditSessionFlags & TF_ES_INEDITSESSION) &&
                      (_tidInEditSession == tid) &&
                      (_dwEditSessionFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE));

    Assert(!*pfWriteSession || tid != TF_CLIENTID_NULL); // should never return TRUE for TFCLIENTID_NULL
                                                         // _tidInEditSession shouldn't be NULL if _dwEditSessionFlags & TF_ES_INEDITSESSION

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _DoEditSession
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_DoEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags)
{
    HRESULT hr;

    // NB: this code is very similar to _PseudoSyncEditSessionQiCallback
    // make sure the logic stays consistent

    Assert(!(_dwEditSessionFlags & TF_ES_INEDITSESSION)); // shouldn't get this far
    Assert(_tidInEditSession == TF_CLIENTID_NULL || _tidInEditSession == g_gaApp); // there should never be another session in progress -- this is not a reentrant func

    _dwEditSessionFlags |= (TF_ES_INEDITSESSION | (dwFlags & TF_ES_ALL_ACCESS_BITS));

    _tidInEditSession = tid;

    //
    // #507366
    //
    // Random AV happens with SPTIP's edit session.
    // #507366 might be fixed by #371798 (sptip). However it is nice to
    // have a pointer checking and protect the call by an exception 
    // handler.
    //
    _try {
        hr = pes->DoEditSession(_ec);
    }
    _except(1) {
        hr = E_FAIL;
    }

    // app won't notify us about our own lock release, so do it manually
    if (dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) // don't bother if it was read-only
    {
        _NotifyEndEdit();
    }

    _IncEditCookie(); // next edit cookie value
    _dwEditSessionFlags &= ~(TF_ES_INEDITSESSION | TF_ES_ALL_ACCESS_BITS);
    _tidInEditSession = TF_CLIENTID_NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
// _NotifyEndEdit
//
// Returns TRUE iff there were changes.
//----------------------------------------------------------------------------

BOOL CInputContext::_NotifyEndEdit(void)
{
    CRange *pRange;
    CProperty *prop;
    int i;
    int cTextSpans;
    SPAN *pSpan;
    CSpanSet *pssText;
    CSpanSet *pssProperty;
    DWORD dwOld;
    CStructArray<GENERICSINK> *prgSinks;
    BOOL fChanges = FALSE;

    if (!_IsConnected())
        return FALSE; // we've been disconnected, nothing to notify

    if (!EnsureEditRecord())
        return FALSE; // low mem.

    if (_pEditRecord->_GetSelectionStatus())
    {
        // we let keystroke manager to update _gaKeyEventFilterTIP
        // since selection was changed.
        _fInvalidKeyEventFilterTIP = TRUE;
    }

    // only allow read locks during the notification
    // if we're in an edit session, keep using the same lock
    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    pssText = _pEditRecord->_GetTextSpanSet();
    cTextSpans = pssText->GetCount();

    // if we are not in the edit session, we need to make
    // _PropertyTextUpdate.  The app has clobbered some text.
    if (!(_dwEditSessionFlags & TF_ES_INEDITSESSION))
    {
        pSpan = pssText->GetSpans();

        for (i = 0; i < cTextSpans; i++)
        {
            _PropertyTextUpdate(pSpan->dwFlags, pSpan->paStart, pSpan->paEnd);
            pSpan++;
        }
    }

    // do the ITfRangeChangeSink::OnChange notifications
    if (cTextSpans > 0)
    {
        fChanges = TRUE;

        for (pRange = _pOnChangeRanges; pRange != NULL; pRange = pRange->_GetNextOnChangeRangeInIcsub())
        {
            if (!pRange->_IsDirty())
                continue;

            pRange->_ClearDirty();

            prgSinks = pRange->_GetChangeSinks();
            Assert(prgSinks); // shouldn't be on the list if this is NULL
            Assert(prgSinks->Count() > 0); // shouldn't be on the list if this is 0

            for (i=0; i<prgSinks->Count(); i++)
            {
                ((ITfRangeChangeSink *)prgSinks->GetPtr(i)->pSink)->OnChange((ITfRangeAnchor *)pRange);
            }
        }
    }

    // accumulate the property span sets into _pEditRecord
    for (prop = _pPropList; prop != NULL; prop = prop->_pNext)
    {
        if ((pssProperty = prop->_GetSpanSet()) == NULL ||
            pssProperty->GetCount() == 0)
        {
            continue; // no delta
        }

        fChanges = TRUE;
  
        _pEditRecord->_AddProperty(prop->GetPropGuidAtom(), pssProperty);
    }

    if (!_pEditRecord->_IsEmpty()) // just a perf thing
    {
        // do the OnEndEdit notifications
        prgSinks = _GetTextEditSinks();
        dwOld = _dwEditSessionFlags;
        _dwEditSessionFlags = (TF_ES_READWRITE | TF_ES_PROPERTY_WRITE | TF_ES_INNOTIFY | TF_ES_INEDITSESSION);

        for (i=0; i<prgSinks->Count(); i++)
        {
            ((ITfTextEditSink *)prgSinks->GetPtr(i)->pSink)->OnEndEdit(this, _ec, _pEditRecord);
        }

        _dwEditSessionFlags = dwOld;

        // properties need to either stop referencing their span sets, or reset them
        for (prop = _pPropList; prop != NULL; prop = prop->_pNext)
        {
            prop->_Dbg_AssertNoChangeHistory();

            if ((pssProperty = prop->_GetSpanSet()) == NULL ||
                pssProperty->GetCount() == 0)
            {
                continue; // no delta
            }

            if (_pEditRecord->_SecondRef())
            {
                prop->_ClearSpanSet();
            }
            else
            {
                prop->_ResetSpanSet();
            }
        }

        if (!_pEditRecord->_SecondRef())
        {
            _pEditRecord->_Reset();
        }
        else
        {
            // someone still holds a ref, so need a new edit record
            _pEditRecord->Release();
            _pEditRecord = new CEditRecord(this); // Issue: delay load! Issue: handle out of mem
        }
    }

    // status change sinks
    if (_fStatusChanged)
    {
        _fStatusChanged = FALSE;
        _OnStatusChangeInternal();
    }

    // layout change sinks
    if (_fLayoutChanged)
    {
        _fLayoutChanged = FALSE;

        // for cicero 1, we only support one view
        // eventually we'll need a list of all affected views...not just the default view..and also create/destroy
        TsViewCookie vcActiveView;

        if (_ptsi->GetActiveView(&vcActiveView) == S_OK)
        {
            _OnLayoutChangeInternal(TS_LC_CHANGE, vcActiveView);
        }
        else
        {
            Assert(0); // how did GetActiveView fail?
        }
    }

    // clear the read-only block
    _dwEditSessionFlags &= ~TF_ES_INNOTIFY;

    return fChanges;
}

//+---------------------------------------------------------------------------
//
// OnTextChange
//
// We only get here from ITextStoreAnchorSink.  We don't have a lock!
//----------------------------------------------------------------------------

STDAPI CInputContext::OnTextChange(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd)
{
    HRESULT hr;
    SPAN *span;

    Assert((dwFlags & ~TS_TC_CORRECTION) == 0);

    if (_IsInEditSession())
    {
        Assert(0); // someone other than cicero is editing the doc while cicero holds a lock
        return TS_E_NOLOCK;
    }

    // record this change
    if ((span = _rgAppTextChanges.Append(1)) == NULL)
        return E_OUTOFMEMORY;

    if (paStart->Clone(&span->paStart) != S_OK || span->paStart == NULL)
        goto ExitError;
    if (paEnd->Clone(&span->paEnd) != S_OK || span->paEnd == NULL)
        goto ExitError;

    span->dwFlags = dwFlags;

    // get a lock eventually so we can deal with the changes
    SafeRequestLock(_ptsi, TS_LF_READ, &hr);

    return S_OK;

ExitError:
    SafeRelease(span->paStart);
    SafeRelease(span->paEnd);
    Assert(_rgAppTextChanges.Count() > 0);
    _rgAppTextChanges.Remove(_rgAppTextChanges.Count()-1, 1);

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _OnTextChangeInternal
//
// Unlike OnTextChange, here we know it's safe to call IAnchor::Compare.
// We either got here from an ITfRange method, or from a wrapped ITextStoreACP.
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnTextChangeInternal(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao)
{
    Assert((dwFlags & ~TS_TC_CORRECTION) == 0);

    if (!EnsureEditRecord())
        return E_OUTOFMEMORY;

    // track the delta
    _pEditRecord->_GetTextSpanSet()->Add(dwFlags, paStart, paEnd, ao);

    // mark any appropriate ranges dirty
    // perf: do this after the edit session ends!  fewer calls that way...
    _MarkDirtyRanges(paStart, paEnd);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSelectionChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnSelectionChange()
{
    if (_IsInEditSession())
    {
        Assert(0); // someone other than cicero is editing the doc while cicero holds a lock
        return TS_E_NOLOCK;
    }

    return _OnSelectionChangeInternal(TRUE);
}

//+---------------------------------------------------------------------------
//
// _OnSelectionChangeInternal
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnSelectionChangeInternal(BOOL fAppChange)
{
    HRESULT hr;

    if (!EnsureEditRecord())
        return E_OUTOFMEMORY;

    _pEditRecord->_SetSelectionStatus();

    if (fAppChange) // perf: could we use _fLockHeld and do away with the fAppChange param?
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLockGranted
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnLockGranted(DWORD dwLockFlags)
{
    BOOL fAppChangesSent;
    BOOL fAppCall;
    HRESULT hr;

    if ((dwLockFlags & ~(TS_LF_SYNC | TS_LF_READWRITE)) != 0)
    {
        Assert(0); // bogus dwLockFlags param
        return E_INVALIDARG;
    }
    if ((dwLockFlags & TS_LF_READWRITE) == 0)
    {
        Assert(0); // bogus dwLockFlags param
        return E_INVALIDARG;
    }

#ifdef DEBUG
    // we don't really need to check for reentrancy since
    // the app is not supposed to call back into us, but
    // why not be paranoid?
    // Issue: for robustness, do something in retail
    Assert(!_dbg_fInOnLockGranted) // no reentrancy
    _dbg_fInOnLockGranted = TRUE;
#endif // DEBUG

    fAppChangesSent = FALSE;
    fAppCall = FALSE;

    if (_fLockHeld == FALSE)
    {
        fAppCall = TRUE;
        _fLockHeld = TRUE;
        _dwlt = dwLockFlags;

        fAppChangesSent = _SynchAppChanges(dwLockFlags);
    }

    // hr will hold result of any synch queue item, need to return this!
    hr = _EmptyLockQueue(dwLockFlags, fAppChangesSent);

    if (fAppCall)
    {
        _fLockHeld = FALSE;
    }

#ifdef DEBUG
    _dbg_fInOnLockGranted = FALSE;
#endif // DEBUG

    return hr;
}

//+---------------------------------------------------------------------------
//
// _SynchAppChanges
//
//----------------------------------------------------------------------------

BOOL CInputContext::_SynchAppChanges(DWORD dwLockFlags)
{
    TfClientId tidInEditSessionOrg;
    int i;
    SPAN *span;
    BOOL fAppChangesSent;

    if (!EnsureEditRecord())
        return FALSE;

    // check for cached app text changes
    for (i=0; i<_rgAppTextChanges.Count(); i++)
    {
        span = _rgAppTextChanges.GetPtr(i);

        // track the delta
        // NB: Add takes ownership of anchors here!  So we don't release them...
        _pEditRecord->_GetTextSpanSet()->Add(span->dwFlags, span->paStart, span->paEnd, OWN_ANCHORS);

        // mark any appropriate ranges dirty
        _MarkDirtyRanges(span->paStart, span->paEnd);
    }
    // all done with the app changes!
    _rgAppTextChanges.Clear();

    // at this point ranges with TF_GRAVITY_FORWARD, TF_GRAVITY_BACKWARD could
    // have crossed anchors (this can only happen in response to app changes,
    // so we check here instead of in _NotifyEndEdit, which can be called after
    // a SetText, etc.).  We track this with a lazy test in the range obj
    // based on an id.
    if (++_dwLastLockReleaseID == 0xffffffff)
    {
        Assert(0); // Issue: need code here to handle wrap-around, prob. need to notify all range objects
    }

    // deal with any app changes, need to send notifications
    // theoretically, we only need to make this call when _tidInEditSession == TF_CLIENTID_NULL
    // (not inside _DoEditSession, a call from the app) but we'll make it anyways to deal with app bugs
    // App bug: if the app has pending changes but grants a synchronous lock, we'll announce the changes
    // here even though we're in an edit session, then return error below...
    tidInEditSessionOrg = _tidInEditSession;
    _tidInEditSession = g_gaApp;

    fAppChangesSent = _NotifyEndEdit();

    _tidInEditSession = tidInEditSessionOrg;

    return fAppChangesSent;
}

//+---------------------------------------------------------------------------
//
// ITfContextOwnerServices::OnLayoutChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnLayoutChange()
{
    // the default impl always has just one view,
    // so specify it directly
    return OnLayoutChange(TS_LC_CHANGE, TSI_ACTIVE_VIEW_COOKIE);
}

//+---------------------------------------------------------------------------
//
// IDocCommonSinkAnchor::OnLayoutChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView)
{
    HRESULT hr;

    _fLayoutChanged = TRUE;

    // for now (cicero 1), ignoring views other than the default!
    // todo: need to keep a list of all affected views

    if (!_fLockHeld) // might hold lock if ic owner is making modifications
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnStatusChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnStatusChange(DWORD dwFlags)
{
    HRESULT hr;

    _fStatusChanged = TRUE;
    _dwStatusChangedFlags |= dwFlags;

    if (!_fLockHeld) // might hold lock if ic owner is making modifications
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnAttrsChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnAttrsChange(IAnchor *paStart, IAnchor *paEnd, ULONG cAttrs, const TS_ATTRID *paAttrs)
{
    CSpanSet *pss;
    ULONG i;
    TfGuidAtom gaType;
    HRESULT hr;

    //
    // Issue: need to delay any work until we have a lock!, just like text deltas
    //

    // paStart, paEnd can be NULL if both are NULL -> whole doc
    if ((paStart == NULL && paEnd != NULL) ||
        (paStart != NULL && paEnd == NULL))
    {
        return E_INVALIDARG;
    }

    if (cAttrs == 0)
        return S_OK;

    if (paAttrs == NULL)
        return E_INVALIDARG;

    if (!EnsureEditRecord())
        return E_OUTOFMEMORY;

    // record the change
    for (i=0; i<cAttrs; i++)
    {
        if (MyRegisterGUID(paAttrs[i], &gaType) != S_OK)
            continue;

        if (pss = _pEditRecord->_FindCreateAppAttr(gaType))
        {
            pss->Add(0, paStart, paEnd, COPY_ANCHORS);
        }
    }

    if (!_fLockHeld) // might hold lock if ic owner is making modifications
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnAttributeChange
//
// Called when sys attr changes for cicero default tsi.
//----------------------------------------------------------------------------

HRESULT CInputContext::OnAttributeChange(REFGUID rguidAttr)
{
    return OnAttrsChange(NULL, NULL, 1, &rguidAttr);
}

//+---------------------------------------------------------------------------
//
// OnStartEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnStartEditTransaction()
{
    int i;
    CStructArray<GENERICSINK> *prgSinks;

    if (_cRefEditTransaction++ > 0)
        return S_OK;

    prgSinks = _GetEditTransactionSink();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfEditTransactionSink *)prgSinks->GetPtr(i)->pSink)->OnStartEditTransaction(this);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnEndEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnEndEditTransaction()
{
    int i;
    CStructArray<GENERICSINK> *prgSinks;

    if (_cRefEditTransaction <= 0)
    {
        Assert(0); // bogus ref count
        return E_UNEXPECTED;
    }

    if (_cRefEditTransaction > 1)
        goto Exit;

    prgSinks = _GetEditTransactionSink();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfEditTransactionSink *)prgSinks->GetPtr(i)->pSink)->OnEndEditTransaction(this);
    }

Exit:
    // dec the ref to 0 last, to prevent reentrancy
    _cRefEditTransaction--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _OnLayoutChangeInternal
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnLayoutChangeInternal(TsLayoutCode lcode, TsViewCookie vcView)
{
    DWORD dwOld;
    CStructArray<GENERICSINK> *prgSinks;
    int i;
    ITfContextView *pView = NULL; // compiler "uninitialized var" warning

    // xlate the view
    GetActiveView(&pView); // when we support multiple views, need to actually use vcView
    if (pView == NULL)
        return E_OUTOFMEMORY;

    // only allow read locks during the notification
    // we might have the read-only bit set already, so save the
    // old value
    dwOld = _dwEditSessionFlags;
    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    prgSinks = _GetTextLayoutSinks();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfTextLayoutSink *)prgSinks->GetPtr(i)->pSink)->OnLayoutChange(this, (TfLayoutCode)lcode, pView);
    }

    pView->Release();

    // clear the read-only block
    _dwEditSessionFlags = dwOld;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _OnStatusChangeInternal
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnStatusChangeInternal()
{
    DWORD dwOld;
    CStructArray<GENERICSINK> *prgSinks;
    int i;

    Assert((_dwEditSessionFlags & TF_ES_INEDITSESSION) == 0); // we must never hold a lock when we do the callbacks

    // only allow read locks during the notification
    // we might have the read-only bit set already, so save the
    // old value
    dwOld = _dwEditSessionFlags;
    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    prgSinks = _GetStatusSinks();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfStatusSink *)prgSinks->GetPtr(i)->pSink)->OnStatusChange(this, _dwStatusChangedFlags);
    }

    _dwStatusChangedFlags = 0;

    // clear the read-only block
    _dwEditSessionFlags = dwOld;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream)
{
    SERIALIZE_ANCHOR_PARAMS params;
    HRESULT hr;
    CProperty *pPropP;
    CRange *pCRange;

    if ((pCRange = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pCRange))
        return E_INVALIDARG;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_INVALIDARG;

    params.pProp = pPropP;
    params.pRange = pCRange;
    params.pHdr = pHdr;
    params.pStream = pStream;

    hr = S_OK;

    // need a sync read lock to do our work
    if (_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_SERIALIZE_ANCHOR, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        hr = E_FAIL;
    }

    SafeRelease(pPropP);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader)
{
    CProperty *pPropP;
    UNSERIALIZE_ANCHOR_PARAMS params;
    HRESULT hr;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_INVALIDARG;

    params.pProp = pPropP;
    params.pHdr = pHdr;
    params.pStream = pStream;
    params.pLoader = pLoader;

    // need a sync read lock to do our work
    if (_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_UNSERIALIZE_ANCHOR, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        return E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ForceLoadProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::ForceLoadProperty(ITfProperty *pProp)
{
    CProperty *pPropP;
    HRESULT hr;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_INVALIDARG;

    hr = pPropP->ForceLoad();

    pPropP->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// _MarkDirtyRanges
//
//----------------------------------------------------------------------------

void CInputContext::_MarkDirtyRanges(IAnchor *paStart, IAnchor *paEnd)
{
    CRange *range;
    IAnchor *paRangeStart;
    IAnchor *paRangeEnd;
    DWORD dwHistory;
    BOOL fDirty;

    // we're only interested in ranges that have notification sinks
    // perf: it would be cool avoid checking ranges based on some ordering scheme....
    for (range = _pOnChangeRanges; range != NULL; range = range->_GetNextOnChangeRangeInIcsub())
    {
        if (range->_IsDirty())
            continue;

        fDirty = FALSE;
        paRangeStart = range->_GetStart();
        paRangeEnd = range->_GetEnd();

        // check BOTH anchors for deletions -- need to clear both
        // no matter what
        if (paRangeStart->GetChangeHistory(&dwHistory) == S_OK &&
            (dwHistory & TS_CH_FOLLOWING_DEL))
        {
            paRangeStart->ClearChangeHistory();
            fDirty = TRUE;
        }
        if (paRangeEnd->GetChangeHistory(&dwHistory) == S_OK &&
            (dwHistory & TS_CH_PRECEDING_DEL))
        {
            paRangeEnd->ClearChangeHistory();
            fDirty = TRUE;
        }

        // even if no anchors collapsed, the range may overlap a delta
        if (!fDirty)
        {
            if (CompareAnchors(paRangeEnd, paStart) > 0 &&
                CompareAnchors(paRangeStart, paEnd) < 0)
            {
                fDirty = TRUE;
            }
        }

        if (fDirty)
        {
            range->_SetDirty();
        }
    }
}

//+---------------------------------------------------------------------------
//
// UpdateKeyEventFilter
//
//----------------------------------------------------------------------------

void CInputContext::_UpdateKeyEventFilter()
{
    HRESULT hr;

    // Our cache _gaKeyEventFilterTTIP is valid so just return TRUE.
    if (!_fInvalidKeyEventFilterTIP)
        return;

    _gaKeyEventFilterTIP[0] = TF_INVALID_GUIDATOM;
    _gaKeyEventFilterTIP[1] = TF_INVALID_GUIDATOM;

    if (_DoPseudoSyncEditSession(TF_ES_READ, 
                                 PSEUDO_ESCB_UPDATEKEYEVENTFILTER, 
                                 NULL, 
                                 &hr) != S_OK || hr != S_OK)
    {
        //
        // Isn't application ready to give lock?
        //
        Assert(0);
    }
}


//+---------------------------------------------------------------------------
//
// _UpdateKeyEventFilterCallback
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_UpdateKeyEventFilterCallback(TfEditCookie ec)
{
    TF_SELECTION sel;
    ULONG cFetched;
    BOOL fEmpty;

    // perf: we don't really need to create a range here, we just want the anchors
    if (GetSelection(ec, TF_DEFAULT_SELECTION, 1, &sel, &cFetched) == S_OK && cFetched == 1)
    {
        HRESULT hr;
        BOOL bRightSide= TRUE;
        BOOL bLeftSide= TRUE;

        //
        // If the current selection is not empty, we just interested in
        // the caret position.
        //
        hr = sel.range->IsEmpty(ec, &fEmpty);
        if ((hr == S_OK) && !fEmpty)
        {
            if (sel.style.ase == TF_AE_START)
            {
                hr = sel.range->ShiftEndToRange(ec,
                                                sel.range, 
                                                TF_ANCHOR_START);
                bRightSide = FALSE;
            }
            else if (sel.style.ase == TF_AE_END)
            {
                hr = sel.range->ShiftStartToRange(ec,
                                                  sel.range, 
                                                  TF_ANCHOR_END);
                bLeftSide = FALSE;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (_pPropTextOwner)
            {
                CRange *pPropRange;
                CRange *pSelRange = GetCRange_NA(sel.range);
                Assert(pSelRange != NULL); // we just created this guy

                if (bRightSide)
                {
                    //
                    // Find the right side owner of sel.
                    // try the start edge of the property so fEnd is FALSE.
                    //
                    if (_pPropTextOwner->_InternalFindRange(pSelRange, 
                                                                   &pPropRange, 
                                                                   TF_ANCHOR_END, 
                                                                   FALSE) == S_OK)
                    {
                        VARIANT var;

                        if (_pPropTextOwner->GetValue(ec, (ITfRangeAnchor *)pPropRange, &var) == S_OK)
                        {
                            IAnchor *paEnd;
                            CRange *pCRangeSel;

                            Assert(var.vt == VT_I4);

                            _gaKeyEventFilterTIP[LEFT_FILTERTIP] = (TfGuidAtom)var.lVal;
                            // don't need to VariantClear because it's VT_I4

                            //
                            // If the end of this proprange is left side of
                            // the caret, the left side owner will be same.
                            // so we don't have to find left proprange then.
                            //
                            paEnd = pPropRange->_GetEnd();
                            if (paEnd && (pCRangeSel = GetCRange_NA(sel.range)))
                            {
                                if (CompareAnchors(paEnd, pCRangeSel->_GetStart()) > 0)
                                    bLeftSide = FALSE;
                            }
                        }
                        pPropRange->Release();
                    }
                }

                if (bLeftSide)
                {
                    //
                    // Find the left side owner of sel.
                    // try the end edge of the property so fEnd is TRUE.
                    //
                    if (_pPropTextOwner->_InternalFindRange(pSelRange, 
                                                                   &pPropRange, 
                                                                   TF_ANCHOR_START, 
                                                                   TRUE) == S_OK)
                    {
                        VARIANT var;

                        if (_pPropTextOwner->GetValue(ec, (ITfRangeAnchor *)pPropRange, &var) == S_OK)
                        {
                            Assert(var.vt == VT_I4);

                            if (_gaKeyEventFilterTIP[LEFT_FILTERTIP] != (TfGuidAtom)var.lVal)
                            {
                                _gaKeyEventFilterTIP[RIGHT_FILTERTIP] = (TfGuidAtom)var.lVal;
                            }
                            // don't need to VariantClear because it's VT_I4
                        }
                        pPropRange->Release();
                    }
                }
            }
        }
        sel.range->Release();
    }

    _fInvalidKeyEventFilterTIP = FALSE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tsdo.cpp ===
//
// sdo.cpp
//

#include "private.h"
#include "tsdo.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CTFDataObject
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = SAFECAST(this, IDataObject *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTFDataObject::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTFDataObject::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTFDataObject::CTFDataObject()
{
    Dbg_MemSetThisName(TEXT("CTFDataObject"));

    memset(&_fe, 0, sizeof(_fe));
    memset(&_sm, 0, sizeof(_sm));
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTFDataObject::~CTFDataObject()
{
    ReleaseStgMedium(&_sm);
}

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::GetData(FORMATETC *pfe, STGMEDIUM *psm)
{
    WCHAR *pch;
    ULONG cch;

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    // verify the formatetc -- Issue: use QueryGetData
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    Assert(_fe.tymed == _sm.tymed);

    // allocate the medium
    if ((pfe->tymed & _fe.lindex) == TYMED_HGLOBAL)
    {
        switch (pfe->cfFormat)
        {
            case CF_UNICODETEXT:
                pch = (WCHAR *)GlobalLock(_sm.hGlobal);
                if (pch)
                {
                    cch = wcslen(pch) + 1; // include the '\0'

                    if ((psm->hGlobal = GlobalAlloc(GMEM_FIXED, cch*sizeof(WCHAR))) == NULL)
                    {
                        GlobalUnlock(_sm.hGlobal);
                        return STG_E_MEDIUMFULL;
                    }

                    memcpy(psm->hGlobal, pch, cch*sizeof(WCHAR));
                    GlobalUnlock(_sm.hGlobal);
                }

                psm->tymed = TYMED_HGLOBAL;

                psm->pUnkForRelease = NULL; // caller must GlobalFree
                break;

            default:
                Assert(0); // shouldn't have let anyone SetData with something we can't handle
                break;
        }
    }
    else
    {
        Assert(0); // shouldn't have let anyone SetData with something we can't handle
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDataHere
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::GetDataHere(FORMATETC *pfe, STGMEDIUM *psm)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// QueryGetData
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::QueryGetData(FORMATETC *pfe)
{
    if (pfe == NULL)
        return E_INVALIDARG;

    // verify the formatetc
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCanonicalFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// SetData
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease)
{
    Assert(fRelease == TRUE); // bogus, but for now we don't support copying

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    if (pfe->tymed != psm->tymed)
        return E_INVALIDARG;

    // free up any storage
    ReleaseStgMedium(&_sm);

    // copy the new stuff
    _fe = *pfe;
    _sm = *psm;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DAdvise
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DUnadvise
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::DUnadvise(DWORD dwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// EnumDAdvise
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::EnumDAdvise(IEnumSTATDATA **ppesd)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// _SetData
//
//----------------------------------------------------------------------------

HRESULT CTFDataObject::_SetData(const WCHAR *pch, ULONG cch)
{
    FORMATETC fe;
    STGMEDIUM sm;

    fe.cfFormat = CF_UNICODETEXT;
    fe.ptd = NULL;
    fe.dwAspect = DVASPECT_CONTENT;
    fe.lindex = -1;
    fe.tymed = TYMED_HGLOBAL;

    sm.tymed = TYMED_HGLOBAL;
    sm.hGlobal = NULL;
    sm.pUnkForRelease = NULL;
    sm.hGlobal = GlobalAlloc(GMEM_FIXED, (cch+1)*sizeof(WCHAR));

    if (sm.hGlobal == NULL)
        return E_OUTOFMEMORY;

    memcpy(sm.hGlobal, pch, cch*sizeof(WCHAR));
    ((WCHAR *)sm.hGlobal)[cch] = '\0';

    return SetData(&fe, &sm, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tsdo.h ===
//
// tsdo.h
//
// Generic simple IDataObject object
//

#ifndef SDO_H
#define SDO_H

#include "private.h"

class CTFDataObject : public IDataObject
{
public:
    CTFDataObject();
    ~CTFDataObject();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IDataObject
    //
    STDMETHODIMP GetData(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP GetDataHere(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP QueryGetData(FORMATETC *pfe);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut);
    STDMETHODIMP SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe);
    STDMETHODIMP DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie);
    STDMETHODIMP DUnadvise(DWORD dwCookie);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppesd);

    HRESULT _SetData(const WCHAR *pch, ULONG cch);

private:
    FORMATETC _fe;
    STGMEDIUM _sm;
    BOOL _fReleaseSM;
    long _cRef;
};

#endif // SDO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\txtcache.cpp ===
//
// txtcache.cpp
//

#include "private.h"
#include "txtcache.h"

long CProcessTextCache::_lCacheMutex = -1;
ITextStoreACP *CProcessTextCache::_ptsi = NULL;
LONG CProcessTextCache::_acpStart;
LONG CProcessTextCache::_acpEnd;
WCHAR CProcessTextCache::_achPlain[CACHE_SIZE_TEXT];
TS_RUNINFO CProcessTextCache::_rgRunInfo[CACHE_SIZE_RUNINFO];
ULONG CProcessTextCache::_ulRunInfoLen;

//+---------------------------------------------------------------------------
//
// GetText
//
// Wrapper for GetText that uses a cache.
//----------------------------------------------------------------------------

HRESULT CProcessTextCache::GetText(ITextStoreACP *ptsi, LONG acpStart, LONG acpEnd,
                                   WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut,
                                   TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                                   LONG *pacpNext)
{
#ifdef DEBUG
    // use these guys to verify the cache in debug
    WCHAR *dbg_pchPlain;
    LONG dbg_acpStart = acpStart;
    LONG dbg_acpEnd = acpEnd;
    ULONG dbg_cchPlainReq = cchPlainReq;
    ULONG dbg_cchPlainOut;
    TS_RUNINFO *dbg_prgRunInfo;
    ULONG dbg_ulRunInfoReq = ulRunInfoReq;
    ULONG dbg_ulRunInfoOut;
    LONG dbg_acpNext;
#endif
    ULONG cch;
    ULONG cchBase;
    LONG acpBase;
    ULONG i;
    ULONG iDst;
    ULONG iOffset;
    int dStartEnd;
    HRESULT hr;

    // don't block if the mutex is held, just call the real GetText
    if (InterlockedIncrement(&_lCacheMutex) != 0)
        goto RealGetText;

    // if its a really big request, don't try to use the cache
    // the way we set things up, once we decide to use the cache we only ask
    // for CACHE_SIZE_TEXT chunks of text at a time, no matter what
    // the code would still be correct without this test, but probably slower
    if (acpEnd < 0 && cchPlainReq > CACHE_SIZE_TEXT)
        goto RealGetText;

    // need to reset the cache?
    if (_ptsi != ptsi ||                              // no cache       
        _acpStart > acpStart || _acpEnd <= acpStart) // is any of the text in the cache?
    {
        _ptsi = NULL; // invalidate the cache in case the GetText fails
        _acpStart = max(0, acpStart - CACHE_PRELOAD_COUNT);

        hr = ptsi->GetText(_acpStart, -1, _achPlain, ARRAYSIZE(_achPlain), &cch,
                           _rgRunInfo, ARRAYSIZE(_rgRunInfo), &_ulRunInfoLen, &_acpEnd);

        if (hr != S_OK)
            goto RealGetText;

        // we have a good cache
        _ptsi = ptsi;
    }

    // return something from the cache

    if (pcchPlainOut != NULL)
    {
        *pcchPlainOut = 0;
    }
    if (pulRunInfoOut != NULL)
    {
        *pulRunInfoOut = 0;
    }

    // find a start point
    // in the first run?
    acpBase = _acpStart;
    cchBase = 0;
    iDst = 0;

    for (i=0; i<_ulRunInfoLen; i++)
    {
        if (acpStart == acpEnd)
            break;
        dStartEnd = acpEnd - acpStart;

        iOffset = acpStart - acpBase;
        acpBase += _rgRunInfo[i].uCount;
        cch = 0;

        if (iOffset >= _rgRunInfo[i].uCount)
        {
            if (_rgRunInfo[i].type != TS_RT_OPAQUE)
            {
                cchBase += _rgRunInfo[i].uCount;
            }
            continue;
        }

        if (ulRunInfoReq > 0)
        {
            cch = _rgRunInfo[i].uCount - iOffset;
            if (dStartEnd > 0 &&
                iOffset + dStartEnd < _rgRunInfo[i].uCount)
            {
                cch = dStartEnd;
            }
            prgRunInfo[iDst].uCount = cch;
            prgRunInfo[iDst].type = _rgRunInfo[i].type;
            (*pulRunInfoOut)++;
        }

        if (cchPlainReq > 0 &&
            _rgRunInfo[i].type != TS_RT_OPAQUE)
        {
            cch = min(cchPlainReq, _rgRunInfo[i].uCount - iOffset);
            if (dStartEnd > 0 &&
                iOffset + dStartEnd < _rgRunInfo[i].uCount)
            {
                cch = min(cchPlainReq, (ULONG)dStartEnd);
            }
            memcpy(pchPlain+*pcchPlainOut, _achPlain+cchBase+iOffset, sizeof(WCHAR)*cch);
            *pcchPlainOut += cch;
            if (ulRunInfoReq > 0)
            {
                // might have truncated the run based on pchPlain buffer size, so fix it
                prgRunInfo[iDst].uCount = cch;
            }
            cchPlainReq -= cch;
            cchBase += cch + iOffset;

            if (cchPlainReq == 0)
            {
                ulRunInfoReq = 1; // force a break below
            }
        }

        if (cch == 0)
            break;

        acpStart += cch;
        iDst++;

        if (ulRunInfoReq > 0)
        {
            if (--ulRunInfoReq == 0)
                break;
        }
    }

    *pacpNext = acpStart;

    InterlockedDecrement(&_lCacheMutex);

#ifdef DEBUG
    // verify the cache worked
    if (dbg_acpEnd <= _acpEnd) // this simple check won't work if the GetText was truncated
    {
        dbg_pchPlain = (WCHAR *)cicMemAlloc(sizeof(WCHAR)*dbg_cchPlainReq);

        if (dbg_pchPlain)
        {
            // there's a bug in word where it will write to dbg_ulRunInfoReq even when dbg_ulRunInfoReq is zero,
            // if it is non-NULL
            dbg_prgRunInfo = dbg_ulRunInfoReq ? (TS_RUNINFO *)cicMemAlloc(sizeof(TS_RUNINFO)*dbg_ulRunInfoReq) : NULL;

            if (dbg_prgRunInfo || !dbg_ulRunInfoReq)
            {
                hr = ptsi->GetText(dbg_acpStart, dbg_acpEnd, dbg_pchPlain, dbg_cchPlainReq, &dbg_cchPlainOut,
                                     dbg_prgRunInfo, dbg_ulRunInfoReq, &dbg_ulRunInfoOut, &dbg_acpNext);

                Assert(hr == S_OK);
                if (dbg_cchPlainReq > 0)
                {
                    Assert(dbg_cchPlainOut == *pcchPlainOut);
                    Assert(memcmp(dbg_pchPlain, pchPlain, dbg_cchPlainOut*sizeof(WCHAR)) == 0);
                }
                if (dbg_ulRunInfoReq > 0)
                {
                    Assert(dbg_ulRunInfoOut == *pulRunInfoOut);
                    Assert(memcmp(dbg_prgRunInfo, prgRunInfo, sizeof(TS_RUNINFO)*dbg_ulRunInfoOut) == 0);
                }
                Assert(dbg_acpNext == *pacpNext);

                cicMemFree(dbg_prgRunInfo);
            }
            else
            {
                // could not allocate mem.
                Assert(0);
            }

            cicMemFree(dbg_pchPlain);
        }
        else
        {
            // could not allocate mem.
            Assert(0);
        }
    }
#endif

    return S_OK;

RealGetText:
    InterlockedDecrement(&_lCacheMutex);
    return ptsi->GetText(acpStart, acpEnd, pchPlain, cchPlainReq, pcchPlainOut,
                         prgRunInfo, ulRunInfoReq, pulRunInfoOut, pacpNext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tsi.cpp ===
//
// tsi.cpp
//
// CTextStoreImpl
//

#include "private.h"
#include "tsi.h"
#include "immxutil.h"
#include "tsdo.h"
#include "tsattrs.h"
#include "ic.h"
#include "rprop.h"

#define TSI_TOKEN   0x01010101

DBG_ID_INSTANCE(CTextStoreImpl);

/* 012313d4-b1e7-476a-bf88-173a316572fb */
extern const IID IID_PRIV_CTSI = { 0x012313d4, 0xb1e7, 0x476a, {0xbf, 0x88, 0x17, 0x3a, 0x31, 0x65, 0x72, 0xfb} };

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTextStoreImpl::CTextStoreImpl(CInputContext *pic)
{
    Dbg_MemSetThisNameID(TEXT("CTextStoreImpl"));

	Assert(_fPendingWriteReq == FALSE);
	Assert(_dwlt == 0);

    _pic = pic;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTextStoreImpl::~CTextStoreImpl()
{
    cicMemFree(_pch);
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask)
{
    if (_ptss != NULL)
    {
        Assert(0); // cicero shouldn't do this
        return CONNECT_E_ADVISELIMIT;
    }

    if (FAILED(punk->QueryInterface(IID_ITextStoreACPSink, (void **)&_ptss)))
        return E_UNEXPECTED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::UnadviseSink(IUnknown *punk)
{
    Assert(_ptss == punk); // we're dealing with cicero, this should always hold
    SafeReleaseClear(_ptss);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ACP *pSelection, ULONG *pcFetched)
{
    if (pcFetched == NULL)
        return E_INVALIDARG;

    *pcFetched = 0;

    if (ulIndex > 1 && ulIndex != TS_DEFAULT_SELECTION)
        return E_INVALIDARG; // index too high

    if (ulCount == 0 || ulIndex == 1)
        return S_OK;

    if (pSelection == NULL)
        return E_INVALIDARG;

    pSelection[0] = _Sel;
    *pcFetched = 1;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::SetSelection(ULONG ulCount, const TS_SELECTION_ACP *pSelection)
{
    Assert(ulCount > 0); // should have been caught by caller
    Assert(pSelection != NULL); // should have been caught by caller

    Assert(pSelection[0].acpStart >= 0);
    Assert(pSelection[0].acpEnd >= pSelection[0].acpStart);

    if (ulCount > 1)
        return E_FAIL; // don't support disjoint sel

    if (pSelection[0].acpEnd > _cch)
        return TS_E_INVALIDPOS;

    _Sel = pSelection[0];

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetText(LONG acpStart, LONG acpEnd,
                               WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut,
                               TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                               LONG *pacpNext)
{
    ULONG cch;

    *pcchPlainOut = 0;
    *pulRunInfoOut = 0;
    *pacpNext = acpStart;

    if (acpStart < 0 || acpStart > _cch)
        return TS_E_INVALIDPOS;    

    // get a count of acp chars requested
    cch = (acpEnd >= acpStart) ? acpEnd - acpStart : _cch - acpStart;
    // since we're plain text, we can also simply clip by the plaintext buffer len
    if (cchPlainReq > 0) // if they don't want plain text we won't clip!
    {
        cch = min(cch, cchPlainReq);
    }

    // check for eod
    if (acpStart + cch > (ULONG)_cch)
    {
        cch = _cch - acpStart;
    }

    if (ulRunInfoReq > 0 && cch > 0)
    {
        *pulRunInfoOut = 1;
        prgRunInfo[0].uCount = cch;
        prgRunInfo[0].type = TS_RT_PLAIN;
    }

    if (cchPlainReq > 0)
    {
        // we're a plain text buffer, so we always copy all the requested chars
        *pcchPlainOut = cch;
        memcpy(pchPlain, _pch + acpStart, cch*sizeof(WCHAR));
    }

    *pacpNext = acpStart + cch;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetText
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::SetText(DWORD dwFlags, LONG acpStart, LONG acpEnd, const WCHAR *pchText, ULONG cch, TS_TEXTCHANGE *pChange)
{
    int iSizeRange;
    int cchAdjust;
    TS_STATUS tss;
    WCHAR *pch = NULL;

    // Since we know our only caller will be cicero, we can assert rather than
    // returning failure codes.
    Assert(acpStart >= 0);
    Assert(acpStart <= acpEnd);

    if (acpEnd > _cch)
        return TS_E_INVALIDPOS;

    if (_owner != NULL &&
        _owner->GetStatus(&tss) == S_OK &&
        (tss.dwDynamicFlags & TS_SD_READONLY))
    {
        return TS_E_READONLY;
    }

    //
    // Check mapped app property for TSATTRID_Text_ReadOnly.
    //
    CProperty *pProp;
    BOOL fReadOnly = FALSE;
    if (SUCCEEDED(_pic->GetMappedAppProperty(TSATTRID_Text_ReadOnly, &pProp)))
    {
        ITfRangeACP *range;
        if (SUCCEEDED(_pic->CreateRange(acpStart, acpEnd, &range)))
        {
            IEnumTfRanges *pEnumRanges;

            if (SUCCEEDED(pProp->EnumRanges(BACKDOOR_EDIT_COOKIE,
                                            &pEnumRanges,
                                            range)))
            {
                ITfRange *rangeTmp;
                while (pEnumRanges->Next(1, &rangeTmp, NULL) == S_OK)
                {
                    VARIANT var;
                    if (pProp->GetValue(BACKDOOR_EDIT_COOKIE, rangeTmp, &var) == S_OK)
                    {
                        if (var.lVal != 0)
                        {
                            fReadOnly = TRUE;
                            break;
                        }
                    }
                    rangeTmp->Release();
                }

                pEnumRanges->Release();
            }

            range->Release();
        }
        pProp->Release();
    }

    if (fReadOnly)
    {
        return TS_E_READONLY;
    }


    // this will all be rewritten for the gap buffer, so keep it simple for now.
    // delete the ranage, then insert the new text.

    iSizeRange = acpEnd - acpStart;
    cchAdjust = (LONG)cch - iSizeRange;

    if (cchAdjust > 0)
    {
        // if we need to alloc more memory, try now, to handle failure gracefully
        if ((pch = (_pch == NULL) ? (WCHAR *)cicMemAlloc((_cch + cchAdjust)*sizeof(WCHAR)) :
                                    (WCHAR *)cicMemReAlloc(_pch, (_cch + cchAdjust)*sizeof(WCHAR))) == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // we're all set
        _pch = pch;
    }

    //
    // shift existing text to the right of the range
    //
    memmove(_pch + acpStart + cch, _pch + acpStart + iSizeRange, (_cch - iSizeRange - acpStart)*sizeof(WCHAR));

    //
    // now fill in the gap
    //
    if (pchText != NULL)
    {
        memcpy(_pch + acpStart, pchText, cch*sizeof(WCHAR));
    }

    //
    // update our buffer size
    //
    _cch += cchAdjust;
    Assert(_cch >= 0);

    // if we shrank, try to realloc a smaller buffer (otherwise we alloc'd above)
    if (cchAdjust < 0)
    {
        if (_cch == 0)
        {
            cicMemFree(_pch);
            _pch = NULL;
        }
        else if (pch = (WCHAR *)cicMemReAlloc(_pch, _cch*sizeof(WCHAR)))
        {
            _pch = pch;
        }
    }

    // handle the out params
    pChange->acpStart = acpStart;
    pChange->acpOldEnd = acpEnd;
    pChange->acpNewEnd = acpEnd + cchAdjust;

    //
    // update the selection
    //
    _Sel.acpStart = AdjustAnchor(acpStart, acpEnd, cch, _Sel.acpStart, FALSE);
    _Sel.acpEnd = AdjustAnchor(acpStart, acpEnd, cch, _Sel.acpEnd, TRUE);
    Assert(_Sel.acpStart >= 0);
    Assert(_Sel.acpStart <= _Sel.acpEnd);
    Assert(_Sel.acpEnd <= _cch);

    // never need to call OnTextChange because we have only one adaptor
    // and this class never calls SetText internally
    // do the OnDelta
    //_ptss->OnTextChange(acpStart, acpEnd, acpStart + cch);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetFormattedText
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetFormattedText(LONG acpStart, LONG acpEnd, IDataObject **ppDataObject)
{
    CTFDataObject *pcdo;

    Assert(acpStart >= 0 && acpEnd <= _cch);
    Assert(acpStart <= acpEnd);
    Assert(ppDataObject != NULL);

    *ppDataObject = NULL;

    pcdo = new CTFDataObject;

    if (pcdo == NULL)
        return E_OUTOFMEMORY;

    if (FAILED(pcdo->_SetData(&_pch[acpStart], acpEnd - acpStart)))
    {
        Assert(0);
        pcdo->Release();
        return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetEmbedded
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetEmbedded(LONG acpPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// InsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::InsertEmbedded(DWORD dwFlags, LONG acpStart, LONG acpEnd, IDataObject *pDataObject, TS_TEXTCHANGE *pChange)
{
    ULONG cch;
    FORMATETC fe;
    STGMEDIUM sm;
    WCHAR *pch;
    HRESULT hr;

    Assert(acpStart <= acpEnd);
    Assert((dwFlags & ~TS_IE_CORRECTION) == 0);
    Assert(pDataObject != NULL);
    Assert(pChange != NULL);

    memset(pChange, 0, sizeof(*pChange));

    fe.cfFormat = CF_UNICODETEXT;
    fe.ptd = NULL;
    fe.dwAspect = DVASPECT_CONTENT;
    fe.lindex = -1;
    fe.tymed = TYMED_HGLOBAL;

    if (FAILED(pDataObject->GetData(&fe, &sm)))
        return TS_E_FORMAT;

    if (sm.hGlobal == NULL)
        return E_FAIL;

    pch = (WCHAR *)GlobalLock(sm.hGlobal);
    cch = wcslen(pch);

    hr = SetText(dwFlags, acpStart, acpEnd, pch, cch, pChange);

    GlobalUnlock(sm.hGlobal);
    ReleaseStgMedium(&sm);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RequestLock
//
//----------------------------------------------------------------------------

#define TS_LF_WRITE (TS_LF_READWRITE & ~TS_LF_READ)

STDAPI CTextStoreImpl::RequestLock(DWORD dwLockFlags, HRESULT *phrSession)
{
    Assert(phrSession != NULL); // caller should have caught this

    if (_dwlt != 0)
    {
        *phrSession = E_UNEXPECTED;

        // this is a reentrant call
        // only one case is legal
        if ((_dwlt & TS_LF_WRITE) ||
            !(dwLockFlags & TS_LF_WRITE) ||
            (dwLockFlags & TS_LF_SYNC))
        {
            Assert(0); // bogus reentrant lock req!
            return E_UNEXPECTED;
        }

        _fPendingWriteReq = TRUE;
        *phrSession = TS_S_ASYNC;
        return S_OK;
    }

    _dwlt = dwLockFlags;

    *phrSession = _ptss->OnLockGranted(dwLockFlags);

    if (_fPendingWriteReq)
    {
        _dwlt = TS_LF_READWRITE;
        _fPendingWriteReq = FALSE;
        if (_ptss != NULL) // might be NULL if we're disconnected during the OnLockGranted above
        {
            _ptss->OnLockGranted(TS_LF_READWRITE);
        }
    }

    _dwlt = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetStatus(TS_STATUS *pdcs)
{
    HRESULT hr;

    if (_owner != NULL)
    {
        hr = _owner->GetStatus(pdcs);

        // only let the owner ctl certain bits
        if (hr == S_OK)
        {
            pdcs->dwDynamicFlags &= (TF_SD_READONLY | TF_SD_LOADING);
            pdcs->dwStaticFlags &= (TF_SS_TRANSITORY);
        }
        else
        {
            memset(pdcs, 0, sizeof(*pdcs));
        }
    }
    else
    {
        hr = S_OK;
        memset(pdcs, 0, sizeof(*pdcs));
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryInsert
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::QueryInsert(LONG acpTestStart, LONG acpTestEnd, ULONG cch, LONG *pacpResultStart, LONG *pacpResultEnd)
{
    Assert(acpTestStart >= 0);
    Assert(acpTestStart <= acpTestEnd);
    Assert(acpTestEnd <= _cch);

    // default text store does not support overtype, and the selection is always replaced
    *pacpResultStart = acpTestStart;
    *pacpResultEnd = acpTestEnd;

    return S_OK;   
}

//+---------------------------------------------------------------------------
//
// Unlock
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetEndACP(LONG *pacp)
{
    *pacp = _cch;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetACPFromPoint
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetACPFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, LONG *pacp)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetACPFromPoint(pt, dwFlags, pacp);    
}

//+---------------------------------------------------------------------------
//
// GetScreenExt
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetScreenExt(TsViewCookie vcView, RECT *prc)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetScreenExt(prc);
}

//+---------------------------------------------------------------------------
//
// GetTextExt
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetTextExt(TsViewCookie vcView, LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetTextExt(acpStart, acpEnd, prc, pfClipped);
}

//+---------------------------------------------------------------------------
//
// GetWnd
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetWnd(TsViewCookie vcView, HWND *phwnd)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view
    Assert(phwnd != NULL); // should have caught this in the ic

    *phwnd = NULL;

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetWnd(phwnd);
}

//+---------------------------------------------------------------------------
//
// _LoadAttr
//
//----------------------------------------------------------------------------

HRESULT CTextStoreImpl::_LoadAttr(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs)
{
    ULONG i;
    HRESULT hr;

    ClearAttrStore();

    if (dwFlags & TS_ATTR_FIND_WANT_VALUE)
    {
        if (_owner == NULL)
            return E_FAIL;
    }

    for (i=0; i<cFilterAttrs; i++)
    {
        VARIANT var;
        QuickVariantInit(&var);

        if (dwFlags & TS_ATTR_FIND_WANT_VALUE)
        {
            if (_owner->GetAttribute(paFilterAttrs[i], &var) != S_OK)
            {
                ClearAttrStore();
                return E_FAIL;
            }
        }
        else
        {
            // Issue: benwest: I think these should be init'd to VT_EMPTY if caller doesn't specify TS_ATTR_FIND_WANT_VALUE
            if (IsEqualGUID(paFilterAttrs[i], GUID_PROP_MODEBIAS))
            {
                 var.vt   = VT_I4;
                 var.lVal = TF_INVALID_GUIDATOM;
            }
            else if (IsEqualGUID(paFilterAttrs[i], TSATTRID_Text_Orientation))
            {
                 var.vt   = VT_I4;
                 var.lVal = 0;
            }
            else if (IsEqualGUID(paFilterAttrs[i], TSATTRID_Text_VerticalWriting))
            {
                 var.vt   = VT_BOOL;
                 var.lVal = 0;
            }
        }

        if (var.vt != VT_EMPTY)
        {
            TSI_ATTRSTORE *pas = _rgAttrStore.Append(1);
            if (!pas)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            pas->attrid = paFilterAttrs[i];
            pas->var    = var;
        }
    }

    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// RequestSupportedAttrs
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RequestSupportedAttrs(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs)
{
    // note the return value is technically a default value, but since we have a value for every location
    // this will never need to be used
    return _LoadAttr(dwFlags, cFilterAttrs, paFilterAttrs);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsAtPosition
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RequestAttrsAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    return _LoadAttr(TS_ATTR_FIND_WANT_VALUE, cFilterAttrs, paFilterAttrs);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsTransitioningAtPosition
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RequestAttrsTransitioningAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    ClearAttrStore();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindNextAttrTransition
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::FindNextAttrTransition(LONG acpStart, LONG acpHaltPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, LONG *pacpNext, BOOL *pfFound, LONG *plFoundOffset)
{
    // our attrs never transition

    *pacpNext = acpStart;
    *pfFound = FALSE;
    plFoundOffset = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RetrieveRequestedAttrs
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched)
{
    ULONG i = 0;

    while((i < ulCount) && ((int)i < _rgAttrStore.Count()))
    {
        TSI_ATTRSTORE *pas = _rgAttrStore.GetPtr(i);
        paAttrVals->idAttr = pas->attrid;
        paAttrVals->dwOverlapId = 0;
        QuickVariantInit(&paAttrVals->varValue);
        paAttrVals->varValue = pas->var;
        paAttrVals++;
        i++;
    }

    *pcFetched = i;
    ClearAttrStore();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF) ||
        !IsEqualIID(riid, IID_PRIV_CTSI))
    {
        // SVC_E_NOSERVICE is proper return code for wrong service....
        // but it's not defined anywhere.  So use E_NOINTERFACE for both
        // cases as trident is rumored to do
        return E_NOINTERFACE;
    }

    *ppv = this;
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetActiveView
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetActiveView(TsViewCookie *pvcView)
{
    // each CEditWnd has only a single view, so this can be constant.
    *pvcView = TSI_ACTIVE_VIEW_COOKIE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie)
{
    ITfMouseTrackerACP *pTracker;
    HRESULT hr;

    Assert(range != NULL);
    Assert(pSink != NULL);
    Assert(pdwCookie != NULL);

    *pdwCookie = 0;

    if (_owner == NULL)
        return E_FAIL;

    if (_owner->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTracker) != S_OK)
        return E_NOTIMPL;

    hr = pTracker->AdviseMouseSink(range, pSink, pdwCookie);

    pTracker->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::UnadviseMouseSink(DWORD dwCookie)
{
    ITfMouseTrackerACP *pTracker;
    HRESULT hr;

    if (_owner == NULL)
        return E_FAIL;

    if (_owner->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTracker) != S_OK)
        return E_NOTIMPL;

    hr = pTracker->UnadviseMouseSink(dwCookie);

    pTracker->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryInsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable)
{
    Assert(pfInsertable != NULL); // cicero should have caught this

    *pfInsertable = FALSE;

    // only accept unicode text
    if (pguidService == NULL &&
        pFormatEtc != NULL &&
        pFormatEtc->cfFormat == CF_UNICODETEXT &&
        pFormatEtc->dwAspect == DVASPECT_CONTENT &&
        pFormatEtc->lindex == -1 &&
        pFormatEtc->tymed == TYMED_HGLOBAL)
    {
        *pfInsertable = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText,
                                             ULONG cch, LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange)
{
    HRESULT hr;

    Assert((dwFlags & TS_IAS_QUERYONLY) || pchText != NULL); // caller should have already caught this
    Assert((dwFlags & TS_IAS_QUERYONLY) || cch > 0); // caller should have already caught this
    Assert(pacpStart != NULL && pacpEnd != NULL); // caller should have already caught this
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));  // caller should have already caught this

    if (dwFlags & TS_IAS_QUERYONLY)
        goto Exit;

    *pacpStart = -1;
    *pacpEnd = -1;

    hr = SetText(0, _Sel.acpStart, _Sel.acpEnd, pchText, cch, pChange);

    if (hr != S_OK)
        return hr;

Exit:
    // since this is cheap, always set the insert span even if caller sets TS_IAS_NOQUERY
    *pacpStart = _Sel.acpStart;
    *pacpEnd = _Sel.acpEnd;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InsertEmbeddedAtSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject,
                                                 LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange)
{
    HRESULT hr;

    Assert((dwFlags & TS_IAS_QUERYONLY) || pDataObject != NULL); // caller should have already caught this
    Assert(pacpStart != NULL && pacpEnd != NULL); // caller should have already caught this
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));  // caller should have already caught this

    if (dwFlags & TS_IAS_QUERYONLY)
        goto Exit;

    *pacpStart = -1;
    *pacpEnd = -1;

    hr = InsertEmbedded(0, _Sel.acpStart, _Sel.acpEnd, pDataObject, pChange);

    if (hr != S_OK)
        return hr;

Exit:
    // since this is cheap, always set the insert span even if caller sets TS_IAS_QUERYONLY
    *pacpStart = _Sel.acpStart;
    *pacpEnd = _Sel.acpEnd;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\tsi.h ===
//
// tsi.h
//
// CTextStoreImpl
//

#ifndef TSI_H
#define TSI_H

#include "private.h"
#include "strary.h"

extern const IID IID_PRIV_CTSI;

// the cookie for each CTextStoreImpl's single view
#define TSI_ACTIVE_VIEW_COOKIE 0

class CInputContext;

class CTextStoreImpl : public ITextStoreACP,
                       public ITfMouseTrackerACP,
                       public IServiceProvider,
                       public CComObjectRootImmx
{
public:
    CTextStoreImpl(CInputContext *pic);
    ~CTextStoreImpl();

    BEGIN_COM_MAP_IMMX(CTextStoreImpl)
        COM_INTERFACE_ENTRY(ITextStoreACP)
        COM_INTERFACE_ENTRY(ITfMouseTrackerACP)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITextStoreACP
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask);
    STDMETHODIMP UnadviseSink(IUnknown *punk);
    STDMETHODIMP RequestLock(DWORD dwLockFlags, HRESULT *phrSession);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP QueryInsert(LONG acpTestStart, LONG acpTestEnd, ULONG cch, LONG *pacpResultStart, LONG *pacpResultEnd);
    STDMETHODIMP GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ACP *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(ULONG ulCount, const TS_SELECTION_ACP *pSelection);
    STDMETHODIMP GetText(LONG acpStart, LONG acpEnd, WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut, TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut, LONG *pacpNext);
    STDMETHODIMP SetText(DWORD dwFlags, LONG acpStart, LONG acpEnd, const WCHAR *pchText, ULONG cch, TS_TEXTCHANGE *pChange);
    STDMETHODIMP GetFormattedText(LONG acpStart, LONG acpEnd, IDataObject **ppDataObject);
    STDMETHODIMP GetEmbedded(LONG acpPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable);
    STDMETHODIMP InsertEmbedded(DWORD dwFlags, LONG acpStart, LONG acpEnd, IDataObject *pDataObject, TS_TEXTCHANGE *pChange);
    STDMETHODIMP RequestSupportedAttrs(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs);
    STDMETHODIMP RequestAttrsAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP RequestAttrsTransitioningAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP FindNextAttrTransition(LONG acpStart, LONG acpHalt, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, LONG *pacpNext, BOOL *pfFound, LONG *plFoundOffset);
    STDMETHODIMP RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched);
    STDMETHODIMP GetEndACP(LONG *pacp);
    STDMETHODIMP GetActiveView(TsViewCookie *pvcView);
    STDMETHODIMP GetACPFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, LONG *pacp);
    STDMETHODIMP GetTextExt(TsViewCookie vcView, LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP GetScreenExt(TsViewCookie vcView, RECT *prc);
    STDMETHODIMP GetWnd(TsViewCookie vcView, HWND *phwnd);
    STDMETHODIMP InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText, ULONG cch, LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange);
    STDMETHODIMP InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject, LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange);

    // ITfMouseTrackerACP
    STDMETHODIMP AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie);
    STDMETHODIMP UnadviseMouseSink(DWORD dwCookie);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    void _AdviseOwner(ITfContextOwner *owner) { Assert(_owner == NULL); _owner = owner; _owner->AddRef(); }
    void _UnadviseOwner() { SafeReleaseClear(_owner); }
    BOOL _HasOwner() { return (_owner != NULL); }

private:

    HRESULT _LoadAttr(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs);

    WCHAR *_pch;    // text buffer
    int _cch;       // size of buffer

    TS_SELECTION_ACP _Sel;

    ITextStoreACPSink *_ptss;

    ITfContextOwner *_owner; // this can be NULL...be careful

    BOOL _fAttrToReturn : 1;
    TfGuidAtom _gaModeBias;

    typedef struct {
         TS_ATTRID    attrid;
         VARIANT      var;
    } TSI_ATTRSTORE;

    CStructArray<TSI_ATTRSTORE> _rgAttrStore;
    void ClearAttrStore()
    {
        int i;
        for (i = 0; i < _rgAttrStore.Count(); i++)
        {
             TSI_ATTRSTORE *pas = _rgAttrStore.GetPtr(i);
             VariantClear(&pas->var);
        }
        _rgAttrStore.Clear();
    }

    BOOL _fPendingWriteReq : 1;
    DWORD _dwlt;

    CInputContext *_pic;

    DBG_ID_DECLARE;
};

#endif // TSI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\utb.cpp ===
//
// utb.cpp
//

#include "private.h"
#include "tim.h"
#include "utb.h"
#include "ithdmshl.h"
#include "shlapip.h"
#include "cregkey.h"
#include "assembly.h"
#include "mui.h"
#include "timlist.h"
#include "compart.h"
#include "tlapi.h"


HWND g_hwndTray = NULL;
HWND g_hwndNotify = NULL;
HWND g_hwndSysTabControlInTray = NULL;
DWORD g_dwThreadIdTray = NULL;

DBG_ID_INSTANCE(CLangBarMgr);

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

ALLOWSETFOREGROUNDWINDOW EnsureAllowSetForeground()
{
    static ALLOWSETFOREGROUNDWINDOW g_fnAllowSetForeground = NULL;

    if (!g_fnAllowSetForeground)
    {
        HINSTANCE hUser32 = GetSystemModuleHandle("USER32");
        if (hUser32)
            g_fnAllowSetForeground = (ALLOWSETFOREGROUNDWINDOW)GetProcAddress(hUser32, "AllowSetForegroundWindow");
    }

    return g_fnAllowSetForeground;
}

REGISTERSYSTEMTHREAD EnsureRegSys()
{
    static REGISTERSYSTEMTHREAD g_fnRegSys = NULL;

    if (!g_fnRegSys)
    {
        HINSTANCE hUser32 = GetSystemModuleHandle("USER32");
        if (hUser32)
            g_fnRegSys = (REGISTERSYSTEMTHREAD)GetProcAddress(hUser32, "RegisterSystemThread");
    }

    return g_fnRegSys;
}

//---------------------------------------------------------------------------
//
//  BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam)
//
//  Look at the class names using GetClassName to see if you can find the
//  Tray notification Window.
//
//---------------------------------------------------------------------------

static const TCHAR c_szNotifyWindow[] = TEXT("TrayNotifyWnd");
static const TCHAR c_szSysTabControl32[] = TEXT("SysTabControl32");
BOOL CALLBACK EnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    char    szString[50];

    if (!GetClassName(hwnd, (LPSTR) szString, sizeof(szString)))
        return FALSE;

    if (!lstrcmp(szString, c_szNotifyWindow))
    {
        g_hwndNotify = hwnd;
    }
    else if (!lstrcmp(szString, c_szSysTabControl32))
    {
        g_hwndSysTabControlInTray = hwnd;
        return FALSE;
    }

    return TRUE;
}

BOOL FindTrayEtc()
{
    if (g_hwndTray)
        return TRUE;

    g_hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

    if (!g_hwndTray)
    {
        return FALSE;
    }

    EnumChildWindows(g_hwndTray, (WNDENUMPROC)EnumChildWndProc, (LPARAM)0);

    if (!g_hwndNotify)
    {
        return FALSE;
    }

    g_dwThreadIdTray = GetWindowThreadProcessId(g_hwndTray, NULL);

    return TRUE;
}

BOOL IsNotifyTrayWnd(HWND hWnd)
{
    FindTrayEtc();
    HWND hwndParent = hWnd;
    while (hwndParent)
    {
        if (hwndParent == g_hwndNotify)
            return TRUE;

        if (hwndParent == g_hwndSysTabControlInTray)
            return TRUE;

        hwndParent = GetParent(hwndParent);
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// LangbarClosed
//
//----------------------------------------------------------------------------

void LangBarClosed()
{
    SYSTHREAD *psfn;
    CThreadInputMgr *ptim;

    if (!(psfn = GetSYSTHREAD()))
        return;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!ptim)
        return;

    MySetCompartmentDWORD(g_gaSystem, 
                          ptim, 
                          GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 
                          0);

    MySetCompartmentDWORD(g_gaSystem, 
                          ptim, 
                          GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, 
                          0);

    MySetCompartmentDWORD(g_gaSystem, 
                          ptim->GetGlobalComp(), 
                          GUID_COMPARTMENT_SPEECH_OPENCLOSE, 
                          0);

}

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarMgr::CLangBarMgr()
{
    Dbg_MemSetThisNameID(TEXT("CLangBarMgr"));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarMgr::~CLangBarMgr()
{
}

//+---------------------------------------------------------------------------
//
// GetThreadMarshallInterface
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk)
{
    return ::GetThreadMarshalInterface(dwThreadId, dwType, riid, ppunk);
}

//+---------------------------------------------------------------------------
//
// GetThreadLangBarItemMgr
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetThreadLangBarItemMgr(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId)
{
    return ::GetThreadUIManager(dwThreadId, pplbi, pdwThreadId);
}

//+---------------------------------------------------------------------------
//
// GetInputProcessotProdiles
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId)
{
    return ::GetInputProcessorProfiles(dwThreadId, ppaip, pdwThreadId);
}

//+---------------------------------------------------------------------------
//
// AadviseEventSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::AdviseEventSink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie)
{
    HRESULT hr;

    if (!pSink)
        return E_INVALIDARG;

    hr = RegisterLangBarNotifySink(pSink, hwnd, dwFlags, pdwCookie);

    if (SUCCEEDED(hr))
    {
        OnForegroundChanged(NULL);
        DWORD dwActiveThreadId = GetSharedMemory()->dwFocusThread;
        if (dwActiveThreadId)
        {
            PostThreadMessage(dwActiveThreadId,
                              g_msgPrivate,
                              TFPRIV_REGISTEREDNEWLANGBAR,
                              0);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseEventSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::UnadviseEventSink(DWORD dwCookie)
{
    return UnregisterLangBarNotifySink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// RestoreLastFocus
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev)
{
    DWORD dwThreadTarget;
    HWND hwndTarget;
    BOOL bRet = FALSE;
    SYSTHREAD *psfn;
    TL_THREADINFO *ptiTarget = NULL;

    FindTrayEtc();

    if (pdwThreadId)
        *pdwThreadId = 0;

    if ((fPrev && GetSharedMemory()->hwndForegroundPrev && (g_dwThreadIdTray == GetSharedMemory()->dwFocusThread)) || !GetSharedMemory()->hwndForeground)
    {
        dwThreadTarget = GetSharedMemory()->dwFocusThreadPrev;
        hwndTarget = GetSharedMemory()->hwndForegroundPrev;
    }
    else
    {
        dwThreadTarget = GetSharedMemory()->dwFocusThread;
        hwndTarget = GetSharedMemory()->hwndForeground;
    }

    //
    // call RegisterSystemThread() is one bad way to allow SetForeground()
    // under Win98.
    //
    if (IsOn98())
    {
        REGISTERSYSTEMTHREAD fnRegSys = EnsureRegSys();
        if (fnRegSys)
            fnRegSys(0, 0);
    }
#if 0
    else if (IsOnNT5())
    {
        ALLOWSETFOREGROUNDWINDOW fnAllowSetForeground = EnsureAllowSetForeground();
        if (fnAllowSetForeground)
            bRet = fnAllowSetForeground(ASFW_ANY);

#ifdef DEBUG
        if (!bRet)
        {
            TraceMsg(TF_GENERAL, "AllowForegroundWindow failed thread - %x hwnd - %x", dwThreadTarget, hwndTarget);
        }
#endif
    }
#endif

    //
    // RestoreLastFocus() is called in the notify message of TrayIcon.
    // sending message to tray icon area thread causes dead lock on Win9x.
    //
    ptiTarget = g_timlist.IsThreadId(dwThreadTarget);
    psfn = GetSYSTHREAD();

    if (ptiTarget && 
        psfn &&
        (ptiTarget->dwMarshalWaitingThread != psfn->dwThreadId))
    {
        TL_THREADINFO *ptiCur = NULL;
        if (psfn->pti && (psfn->pti->dwThreadId == psfn->dwThreadId))
            ptiCur = psfn->pti;

        if (ptiCur)
            ptiCur->dwFlags |= TLF_INSFW;

        bRet = SetForegroundWindow(hwndTarget);

        if (ptiCur)
            ptiCur->dwFlags &= ~TLF_INSFW;

    }

#ifdef DEBUG
    if (!bRet)
    {
        TraceMsg(TF_GENERAL, "SetForegroundWindow failed thread - %x hwnd - %x", dwThreadTarget, hwndTarget);
    }
#endif

    if (bRet && pdwThreadId)
        *pdwThreadId = dwThreadTarget;

    // Issue:
    // we want to restore the focus, too. But we need to go to the target
    // thread to call SetFocus()....
    // SetFocus(g_hwndFocus);

    return bRet ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// SetModalInput
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::SetModalInput(ITfLangBarEventSink *pSink, DWORD dwThreadId, DWORD dwFlags)
{
    SetModalLBarSink(dwThreadId, pSink ? TRUE : NULL, dwFlags);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShowFloating
//
//----------------------------------------------------------------------------
#define REG_TF_SFT_SHOWNORMAL    (DWORD)0
#define REG_TF_SFT_DOCK          (DWORD)1
#define REG_TF_SFT_MINIMIZED     (DWORD)2
#define REG_TF_SFT_HIDDEN        (DWORD)3
#define REG_TF_SFT_DESKBAND      (DWORD)4

#define TF_SFT_BITS_SHOWSTATUS    (TF_SFT_SHOWNORMAL | TF_SFT_DOCK | TF_SFT_MINIMIZED | TF_SFT_HIDDEN | TF_SFT_DESKBAND)
#define TF_SFT_BITS_TRANSPARENCY  (TF_SFT_NOTRANSPARENCY | TF_SFT_LOWTRANSPARENCY | TF_SFT_HIGHTRANSPARENCY)
#define TF_SFT_BITS_LABELS        (TF_SFT_LABELS | TF_SFT_NOLABELS)
#define TF_SFT_BITS_EXTRAICONSONMINIMIZED    (TF_SFT_EXTRAICONSONMINIMIZED | TF_SFT_NOEXTRAICONSONMINIMIZED)

STDAPI CLangBarMgr::ShowFloating(DWORD dwFlags)
{
    // 
    //  check params
    // 
    if (!CheckFloatingBits(dwFlags))
        return E_INVALIDARG;

    return s_ShowFloating(dwFlags);
}

__inline BOOL IsNotPowerOf2(DWORD dw)
{
    return (dw & (dw - 1));
}

BOOL CLangBarMgr::CheckFloatingBits(DWORD dwBits)
{
    //
    // we allow only one bit in each group.
    // if there are two or more bits are set there, return FALSE.
    //

    if (IsNotPowerOf2(dwBits & TF_SFT_BITS_SHOWSTATUS))
        return FALSE;

    if (IsNotPowerOf2(dwBits & TF_SFT_BITS_TRANSPARENCY))
        return FALSE;

    if (IsNotPowerOf2(dwBits & TF_SFT_BITS_LABELS))
        return FALSE;

    if (IsNotPowerOf2(dwBits &  TF_SFT_BITS_EXTRAICONSONMINIMIZED))
        return FALSE;

    return TRUE;
}

HRESULT CLangBarMgr::s_ShowFloating(DWORD dwFlags)
{
    DWORD dwStatus;
    CMyRegKey key;

    //
    // keep tracking the prev show floating sttaus.
    //
    if (SUCCEEDED(s_GetShowFloatingStatus(&dwStatus)))
        GetSharedMemory()->dwPrevShowFloatingStatus = dwStatus;
    
    if (key.Create(HKEY_CURRENT_USER, c_szLangBarKey) != S_OK)
        return E_FAIL;

    if (dwFlags & TF_SFT_SHOWNORMAL)
    {
        key.SetValue(REG_TF_SFT_SHOWNORMAL, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_DOCK)
    {
        key.SetValue(REG_TF_SFT_DOCK, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_MINIMIZED)
    {
        key.SetValue(REG_TF_SFT_MINIMIZED, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_HIDDEN)
    {
        key.SetValue(REG_TF_SFT_HIDDEN, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_DESKBAND)
    {
        key.SetValue(REG_TF_SFT_DESKBAND, c_szShowStatus);
    }

    if (dwFlags & TF_SFT_NOTRANSPARENCY)
    {
        key.SetValue((DWORD)255, c_szTransparency);
    }
    else if (dwFlags & TF_SFT_LOWTRANSPARENCY)
    {
        key.SetValue((DWORD)128, c_szTransparency);
    }
    else if (dwFlags & TF_SFT_HIGHTRANSPARENCY)
    {
        key.SetValue((DWORD)64, c_szTransparency);
    }

    if (dwFlags & TF_SFT_LABELS)
    {
        key.SetValue((DWORD)1, c_szLabel);
    }
    else if (dwFlags & TF_SFT_NOLABELS)
    {
        key.SetValue((DWORD)0, c_szLabel);
    }

    if (dwFlags & TF_SFT_EXTRAICONSONMINIMIZED)
    {
        key.SetValue((DWORD)1, c_szExtraIconsOnMinimized);
    }
    else if (dwFlags & TF_SFT_NOEXTRAICONSONMINIMIZED)
    {
        key.SetValue((DWORD)0, c_szExtraIconsOnMinimized);
    }

    if (SUCCEEDED(s_GetShowFloatingStatus(&dwStatus)))
        MakeSetFocusNotify(g_msgShowFloating, 0, (LPARAM)dwStatus);

    if (dwStatus & TF_SFT_HIDDEN)
        PostTimListMessage(TLF_TIMACTIVE, 0, g_msgPrivate, TFPRIV_LANGBARCLOSED, 0);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetShowFloatingStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetShowFloatingStatus(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_INVALIDARG;

    return s_GetShowFloatingStatus(pdwFlags);
}

//+---------------------------------------------------------------------------
//
// GetPrevShowFloatingStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetPrevShowFloatingStatus(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_INVALIDARG;

    DWORD dwFlags;
    if (!GetSharedMemory()->dwPrevShowFloatingStatus)
    {
        s_GetShowFloatingStatus(&dwFlags);
        GetSharedMemory()->dwPrevShowFloatingStatus = dwFlags;
    }

    *pdwFlags = GetSharedMemory()->dwPrevShowFloatingStatus;
    return S_OK;
}

HRESULT CLangBarMgr::s_GetShowFloatingStatus(DWORD *pdwFlags)
{
    CMyRegKey key;
    DWORD dwFlags = 0;

    if (!pdwFlags)
        return E_INVALIDARG;

    if (key.Open(HKEY_CURRENT_USER, c_szLangBarKey, KEY_READ) != S_OK)
    {
        // return default.
        if (IsFELangId(GetPlatformResourceLangID()))
            *pdwFlags = (TF_SFT_SHOWNORMAL | 
                         TF_SFT_NOTRANSPARENCY | 
                         TF_SFT_NOLABELS | 
                         TF_SFT_EXTRAICONSONMINIMIZED);
        else
        {
            if (IsOnNT51())
            {
                *pdwFlags = (TF_SFT_DESKBAND |
                             TF_SFT_NOTRANSPARENCY |
                             TF_SFT_LABELS |
                             TF_SFT_NOEXTRAICONSONMINIMIZED);
            }
            else
            {
                *pdwFlags = (TF_SFT_SHOWNORMAL |
                             TF_SFT_NOTRANSPARENCY |
                             TF_SFT_LABELS |
                             TF_SFT_NOEXTRAICONSONMINIMIZED);
            }
        }
        return S_OK;
    }

    DWORD dw;
    dw = 0;
    if (key.QueryValue(dw, c_szShowStatus) == S_OK)
    {
        switch (dw)
        {
            case REG_TF_SFT_SHOWNORMAL: dwFlags |= TF_SFT_SHOWNORMAL;  break;
            case REG_TF_SFT_DOCK:       dwFlags |= TF_SFT_DOCK;        break;
            case REG_TF_SFT_MINIMIZED:
                //
                // BugBug#452872 - Only take care of GetShowFloating case,
                // since SetShowFloating require the regression testing.
                // This is simple fix to support the upgrade Window XP from the
                // minimized language UI status platform.
                //
                dwFlags |= IsOnNT51() ? TF_SFT_DESKBAND : TF_SFT_MINIMIZED;
                break;
            case REG_TF_SFT_HIDDEN:     dwFlags |= TF_SFT_HIDDEN;      break;
            case REG_TF_SFT_DESKBAND:   dwFlags |= TF_SFT_DESKBAND;    break;
            default:                    dwFlags |= TF_SFT_SHOWNORMAL;  break;
        }
    }
    else
    {
        if (IsOnNT51() && !IsFELangId(GetPlatformResourceLangID()))
        {
            dwFlags |= TF_SFT_DESKBAND;
        }
        else
        {
            dwFlags |= TF_SFT_SHOWNORMAL;
        }
    }

    dw = 0;
    if (key.QueryValue(dw, c_szTransparency) == S_OK)
    {
        switch (dw)
        {
            case 255: dwFlags |= TF_SFT_NOTRANSPARENCY;    break;
            case 128: dwFlags |= TF_SFT_LOWTRANSPARENCY;   break;
            case 64:  dwFlags |= TF_SFT_HIGHTRANSPARENCY;  break;
            default:  dwFlags |= TF_SFT_NOTRANSPARENCY;    break;
        }
    }
    else
    {
        dwFlags |= TF_SFT_NOTRANSPARENCY;
    }

    dw = 0;
    if (key.QueryValue(dw, c_szLabel) == S_OK)
    {
        switch (dw)
        {
            case 1:   dwFlags |= TF_SFT_LABELS;      break;
            default:  dwFlags |= TF_SFT_NOLABELS;    break;
        }
    }
    else
    {
        if (IsFELangId(GetPlatformResourceLangID()))
            dwFlags |= TF_SFT_NOLABELS;
        else
            dwFlags |= TF_SFT_LABELS;
    }

    dw = 0;
    if (key.QueryValue(dw, c_szExtraIconsOnMinimized) == S_OK)
    {
        switch (dw)
        {
            case 1:   dwFlags |= TF_SFT_EXTRAICONSONMINIMIZED;      break;
            default:  dwFlags |= TF_SFT_NOEXTRAICONSONMINIMIZED;    break;
        }
    }
    else
    {
        if (IsFELangId(GetPlatformResourceLangID()))
            dwFlags |= TF_SFT_EXTRAICONSONMINIMIZED;
        else
            dwFlags |= TF_SFT_NOEXTRAICONSONMINIMIZED;
    }

    *pdwFlags = dwFlags;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\txtcache.h ===
//
// txtcache.h
//

#ifndef TXTCACHE_H
#define TXTCACHE_H

#define CACHE_SIZE_TEXT     128
#define CACHE_PRELOAD_COUNT (CACHE_SIZE_TEXT/4) // number of chars we ask for ahead of the GetText acpStart to init the cache
#define CACHE_SIZE_RUNINFO  (CACHE_PRELOAD_COUNT+1) // this number should be very small for speed, but must be > CACHE_PRELOAD_COUNT
                                                    // the danger is that we could run out of space before hitting the caller's acpStart

class CProcessTextCache
{
public:

    static HRESULT GetText(ITextStoreACP *ptsi, LONG acpStart, LONG acpEnd,
                           WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut,
                           TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                           LONG *pacpNext);

    static void Invalidate(ITextStoreACP *ptsi)
    {
        // not strictly thread safe
        // BUT, since we're appartment threaded, we shouldn't ever invalidate the
        // same ptsi that someone is trying to use simultaneously
        if (_ptsi == ptsi)
        {
            _ptsi = NULL;
        }
    }

private:

    static long _lCacheMutex;
    static ITextStoreACP *_ptsi;
    static LONG _acpStart;
    static LONG _acpEnd;
    static WCHAR _achPlain[CACHE_SIZE_TEXT];
    static TS_RUNINFO _rgRunInfo[CACHE_SIZE_RUNINFO];
    static ULONG _ulRunInfoLen;
};

#endif // TXTCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\utb.h ===
//
// utb.h
//

#ifndef UTB_H
#define UTB_H

#include "private.h"

#ifndef ASFW_ANY
#define ASFW_ANY    ((DWORD)-1)
#endif

typedef void (*REGISTERSYSTEMTHREAD)(DWORD dw, DWORD reserve);
typedef BOOL (*ALLOWSETFOREGROUNDWINDOW)(DWORD dw);
ALLOWSETFOREGROUNDWINDOW EnsureAllowSetForeground();
REGISTERSYSTEMTHREAD EnsureRegSys();

HRESULT RegisterLangBarNotifySink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie);
HRESULT UnregisterLangBarNotifySink(DWORD dwCookie);

BOOL CALLBACK EnumChildWndProc(HWND hwnd, LPARAM lParam);
BOOL FindTrayEtc();
BOOL IsNotifyTrayWnd(HWND hWnd);

void LangBarClosed();

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

// If we ever go crazy for perf, this class could be a single static instance,
// since it has no state.  We need to get rid of the ATL CComCoClass and
// CComObjectRoot to do this.
class CLangBarMgr : 
      public ITfLangBarMgr_P,
      public CComObjectRoot_CreateInstance<CLangBarMgr>
{
public:
    CLangBarMgr();
    ~CLangBarMgr();

    BEGIN_COM_MAP_IMMX(CLangBarMgr)
        COM_INTERFACE_ENTRY(ITfLangBarMgr)
        COM_INTERFACE_ENTRY(ITfLangBarMgr_P)
    END_COM_MAP_IMMX()

    //
    // ITfLangBarManager
    //
    STDMETHODIMP AdviseEventSink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie);
    STDMETHODIMP UnadviseEventSink(DWORD dwCookie);
    STDMETHODIMP GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP GetThreadLangBarItemMgr(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId) ;
    STDMETHODIMP GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId) ;
    STDMETHODIMP RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev);
    STDMETHODIMP SetModalInput(ITfLangBarEventSink *pSink, DWORD dwThreadId, DWORD dwFlags);
    STDMETHODIMP ShowFloating(DWORD dwFlags);
    STDMETHODIMP GetShowFloatingStatus(DWORD *pdwFlags);

    //
    // ITfLangBarManager_P
    //
    STDMETHODIMP GetPrevShowFloatingStatus(DWORD *pdwFlags);

    static HRESULT s_ShowFloating(DWORD dwFlags);
    static HRESULT s_GetShowFloatingStatus(DWORD *pdwFlags);

private:
    static BOOL CheckFloatingBits(DWORD dwBits);

    DBG_ID_DECLARE;
};


#endif //UTB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uuid\ctffunc_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

/* dcbd6fa8-032f-11d3-b5b1-00c04fc324a1 */
const CLSID CLSID_SapiLayr  = {
    0xdcbd6fa8,
    0x032f,
    0x11d3,
    {0xb5, 0xb1, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}
};

// FE7C68F6-DED1-4787-9AB5-AF15E8B91A0F
const GUID GUID_TFCAT_TIP_MASTERLM =
{0xFE7C68F6, 0xDED1, 0x4787, {0x9A, 0xB5, 0xAF, 0x15, 0xE8, 0xB9, 0x1A, 0x0F} };

// FF341C48-DB92-46E5-8830-18B8015BAF49
const GUID GUID_MASTERLM_FUNCTIONPROVIDER =
{0xFF341C48, 0xDB92, 0x46E5, {0x88, 0x30, 0x18, 0xB8, 0x01, 0x5B, 0xAF, 0x49} };

// 23B2BE84-9EBE-4820-B29F-70FCA97E7D57 
const GUID GUID_LMLATTICE_VER1_0 = 
{0x23B2BE84, 0x9EBE, 0x4820, {0xB2, 0x9F, 0x70, 0xFC, 0xA9, 0x7E, 0x7D, 0x57} };

// 8189B801-D62F-400A-8C12-E29340967BA8 
const GUID GUID_PROP_LMLATTICE = 
{0x8189B801, 0xD62F, 0x400A, {0x8C, 0x12, 0xE2, 0x93, 0x40, 0x96, 0x7B, 0xA8} };
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\view.h ===
//
// view.h
//

#ifndef VIEW_H
#define VIEW_H

class CInputContext;

class CContextView : public ITfContextView,
                     public CComObjectRootImmx
{
public:
    CContextView(CInputContext *pic, TsViewCookie vcView);
    ~CContextView();

    BEGIN_COM_MAP_IMMX(CContextView)
        COM_INTERFACE_ENTRY(ITfContextView)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfContextView
    STDMETHODIMP GetRangeFromPoint(TfEditCookie ec, const POINT *ppt, DWORD dwFlags, ITfRange **ppRange);
    STDMETHODIMP GetTextExt(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP GetScreenExt(RECT *prc);
    STDMETHODIMP GetWnd(HWND *phwnd);

private:
    CInputContext *_pic;
    TsViewCookie _vcView;
    DBG_ID_DECLARE;
};

#endif // VIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\bridgecp\bridgecp.cpp ===
// DUser.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "BridgeCP.h"
#include "Bridge.h"

/***************************************************************************\
*
* DllMain
*
* DllMain() is called after the CRT has fully ininitialized.
*
\***************************************************************************/

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        if (!InitBridges()) {
            return FALSE;
        }
        break;
        
    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uuid\ctfspui_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

/* 1443904b-34e4-40f6-b30f-6beb81267b80 */
const CLSID CLSID_SpeechUIServer = { 
    0x1443904b,
    0x34e4,
    0x40f6,
    {0xb3, 0x0f, 0x6b, 0xeb, 0x81, 0x26, 0x7b, 0x80}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\view.cpp ===
//
// view.cpp
//

#include "private.h"
#include "view.h"
#include "ic.h"
#include "range.h"

DBG_ID_INSTANCE(CContextView);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CContextView::CContextView(CInputContext *pic, TsViewCookie vcView)
{
    Dbg_MemSetThisNameID(TEXT("CContextView"));

    _pic = pic;
    _pic->AddRef();

    _vcView = vcView;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CContextView::~CContextView()
{
    _pic->Release();
}

//+---------------------------------------------------------------------------
//
// GetRangeFromPoint
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetRangeFromPoint(TfEditCookie ec, const POINT *ppt, DWORD dwFlags, ITfRange **ppRange)
{
    CRange *range;
    IAnchor *pa;
    HRESULT hr;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (ppt == NULL)
        return E_INVALIDARG;

    if (dwFlags & ~(GXFPF_ROUND_NEAREST | GXFPF_NEAREST))
        return E_INVALIDARG;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _pic->_GetTSI()->GetAnchorFromPoint(_vcView, ppt, dwFlags, &pa);

    if (hr != S_OK)
    {
        // the only potentially bogus arg is the view, which could have gone away
        return (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    hr = E_FAIL;

    range = new CRange;

    if (range == NULL)
        goto Exit;

    if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pa, pa))
    {
        range->Release();
        goto Exit;
    }

    *ppRange = (ITfRangeAnchor *)range;
    hr = S_OK;

Exit:
    pa->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetScreenExt
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetScreenExt(RECT *prc)
{
    HRESULT hr;

    if (prc == NULL)
        return E_INVALIDARG;

    hr = _pic->_GetTSI()->GetScreenExt(_vcView, prc);

    if (hr != S_OK)
    {
        hr = (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetScreenExtent
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetTextExt(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped)
{
    CRange *range;
    HRESULT hr;

    if (prc != NULL)
    {
        memset(prc, 0, sizeof(*prc));
    }
    if (pfClipped != NULL)
    {
        *pfClipped = FALSE;
    }
    if (pRange == NULL || prc == NULL || pfClipped == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    range->_QuickCheckCrossedAnchors();

    hr = _pic->_GetTSI()->GetTextExt(_vcView, range->_GetStart(), range->_GetEnd(), prc, pfClipped);

    if (hr != S_OK)
    {
        // the only potentially bogus arg is the view, which could have gone away
        hr = (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetWnd
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetWnd(HWND *phwnd)
{
    HRESULT hr;

    if (phwnd == NULL)
        return E_INVALIDARG;

    hr = _pic->_GetTSI()->GetWnd(_vcView, phwnd);

    if (hr != S_OK)
    {
        // the only potentially bogus arg is the view, which could have gone away
        hr = (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uuid\msctf_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#include "cicclsid.c"

/* f1e2d520-0969-11d3-8df0-00105a2799b5 */
const GUID GUID_PROP_TEXTOWNER = { 
    0xf1e2d520,
    0x0969,
    0x11d3,
    {0x8d, 0xf0, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 34b45670-7526-11d2-a147-00105a2799b5 */
const GUID GUID_PROP_ATTRIBUTE = { 
    0x34b45670,
    0x7526,
    0x11d2,
    {0xa1, 0x47, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };


/* 3280ce20-8032-11d2-b603-00105a2799b5 */
const GUID GUID_PROP_LANGID = { 
    0x3280ce20,
    0x8032,
    0x11d2,
    {0xb6, 0x03, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 5463f7c0-8e31-11d2-bf46-00105a2799b5 */
const GUID GUID_PROP_READING = { 
    0x5463f7c0,
    0x8e31,
    0x11d2,
    {0xbf, 0x46, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* e12ac060-af15-11d2-afc5-00105a2799b5 */
const GUID GUID_PROP_COMPOSING = {
    0xe12ac060,
    0xaf15,
    0x11d2,
    {0xaf, 0xc5, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 9a698bb0-0f21-11d3-8df1-00105a2799b5 */
const GUID GUID_SYSTEM_FUNCTIONPROVIDER = { 
    0x9a698bb0,
    0x0f21,
    0x11d3,
    {0x8d, 0xf1, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 4caef01e-12af-4b0e-9db1-a6ec5b881208 */
const GUID GUID_APP_FUNCTIONPROVIDER = { 
    0x4caef01e,
    0x12af,
    0x4b0e,
    {0x9d, 0xb1, 0xa6, 0xec, 0x5b, 0x88, 0x12, 0x08}
  };


/* 534c48c1-0607-4098-a521-4fc899c73e90 */
const GUID GUID_TFCAT_CATEGORY_OF_TIP = { 
    0x534c48c1,
    0x0607,
    0x4098,
    {0xa5, 0x21, 0x4f, 0xc8, 0x99, 0xc7, 0x3e, 0x90}
  };

/* 34745c63-b2f0-4784-8b67-5e12c8701a31 */
const GUID GUID_TFCAT_TIP_KEYBOARD = { 
    0x34745c63,
    0xb2f0,
    0x4784,
    {0x8b, 0x67, 0x5e, 0x12, 0xc8, 0x70, 0x1a, 0x31}
  };

/* b5a73cd1-8355-426b-a161-259808f26b14 */
const GUID GUID_TFCAT_TIP_SPEECH = { 
    0xb5a73cd1,
    0x8355,
    0x426b,
    {0xa1, 0x61, 0x25, 0x98, 0x08, 0xf2, 0x6b, 0x14}
  };

/* 246ecb87-c2f2-4abe-905b-c8b38add2c43 */
const GUID GUID_TFCAT_TIP_HANDWRITING = { 
    0x246ecb87,
    0xc2f2,
    0x4abe,
    {0x90, 0x5b, 0xc8, 0xb3, 0x8a, 0xdd, 0x2c, 0x43}
  };

/* 9b7be3a9-e8ab-4d47-a8fe-254fa423436d */
const GUID GUID_TFCAT_PROP_AUDIODATA = { 
    0x9b7be3a9,
    0xe8ab,
    0x4d47,
    {0xa8, 0xfe, 0x25, 0x4f, 0xa4, 0x23, 0x43, 0x6d}
  };

/* 7c6a82ae-b0d7-4f14-a745-14f28b009d61 */
const GUID GUID_TFCAT_PROP_INKDATA = { 
    0x7c6a82ae,
    0xb0d7,
    0x4f14,
    {0xa7, 0x45, 0x14, 0xf2, 0x8b, 0x00, 0x9d, 0x61}
  };

/* 51af2086-cc6b-457d-b5aa-8b19dc290ab4 */
const GUID GUID_COMPARTMENT_SAPI_AUDIO= {
    0x51af2086,
    0xcc6b,
    0x457d,
    {0xb5, 0xaa, 0x8b, 0x19, 0xdc, 0x29, 0x0a, 0xb4}
};

/* 71a5b253-1951-466b-9fbc-9c8808fa84f2 */
const GUID GUID_COMPARTMENT_KEYBOARD_DISABLED = { 
    0x71a5b253,
    0x1951,
    0x466b,
    {0x9f, 0xbc, 0x9c, 0x88, 0x08, 0xfa, 0x84, 0xf2}
  };

/* 58273aad-01bb-4164-95c6-755ba0b5162d */
const GUID GUID_COMPARTMENT_KEYBOARD_OPENCLOSE = { 
    0x58273aad,
    0x01bb,
    0x4164,
    {0x95, 0xc6, 0x75, 0x5b, 0xa0, 0xb5, 0x16, 0x2d}
  };

/* f9ae2c6b-1866-4361-af72-7aa30948890e */
const GUID GUID_COMPARTMENT_HANDWRITING_OPENCLOSE = { 
    0xf9ae2c6b,
    0x1866,
    0x4361,
    {0xaf, 0x72, 0x7a, 0xa3, 0x09, 0x48, 0x89, 0x0e}
  };

/* 56c5c607-0703-4e59-8e52-cbc84e8bbe35 */
const GUID GUID_COMPARTMENT_SPEECH_DISABLED = { 
    0x56c5c607,
    0x0703,
    0x4e59,
    {0x8e, 0x52, 0xcb, 0xc8, 0x4e, 0x8b, 0xbe, 0x35}
  };

/* 544d6a63-e2e8-4752-bbd1-000960bca083 */
const GUID GUID_COMPARTMENT_SPEECH_OPENCLOSE = { 
    0x544d6a63,
    0xe2e8,
    0x4752,
    {0xbb, 0xd1, 0x00, 0x09, 0x60, 0xbc, 0xa0, 0x83}
  };

/* 2a54fe8e-0d08-460c-a75d-87035ff436c5 */
const GUID GUID_COMPARTMENT_SPEECH_GLOBALSTATE = { 
    0x2a54fe8e, 
    0x0d08, 
    0x460c, 
    {0xa7, 0x5d, 0x87, 0x03, 0x5f, 0xf4, 0x36, 0xc5}
  };

/* 5497f516-ee91-436e-b946-aa2c05f1ac5b */
const GUID GUID_COMPARTMENT_CONVERSIONMODEBIAS = {
    0x5497f516,
    0xee91,
    0x436e,
    {0xb9, 0x46, 0xaa, 0x2c, 0x05, 0xf1, 0xac, 0x5b}
  };

/* 372E0716-974F-40AC-A088-08CDC92EBFBC */
const GUID GUID_PROP_MODEBIAS = {
    0x372E0716,
    0x974F,
    0x40AC,
    {0xA0, 0x88, 0x08, 0xCD, 0xC9, 0x2E, 0xBF, 0xBC}
  };

/* b6592511-bcee-4122-a7c4-09f4b3fa4396 */
const GUID GUID_COMPARTMENT_KEYBOARD_INPUTMODE = {
    0xb6592511,
    0xbcee,
    0x4122,
    {0xa7, 0xc4, 0x09, 0xf4, 0xb3, 0xfa, 0x43, 0x96}
  };


/* GUID_NULL */
const GUID GUID_MODEBIAS_NONE = {
    0x00000000,
    0x0000,
    0x0000,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  };

/* 8b0e54d9-63f2-4c68-84d4-79aee7a59f09 */
const GUID GUID_MODEBIAS_URLHISTORY = {
    0x8b0e54d9,
    0x63f2,
    0x4c68,
    {0x84, 0xd4, 0x79, 0xae, 0xe7, 0xa5, 0x9f, 0x09}
  };

/* d7f707fe-44c6-4fca-8e76-86ab50c7931b */
const GUID GUID_MODEBIAS_FILENAME = {
    0xd7f707fe,
    0x44c6,
    0x4fca,
    {0x8e, 0x76, 0x86, 0xab, 0x50, 0xc7, 0x93, 0x1b}
  };


/* e31643a3-6466-4cbf-8d8b-0bd4d8545461 */
const GUID GUID_MODEBIAS_READING = {
    0xe31643a3,
    0x6466,
    0x4cbf,
    {0x8d, 0x8b, 0x0b, 0xd4, 0xd8, 0x54, 0x54, 0x61}
  };


/* f2bdb372-7f61-4039-92ef-1c35599f0222 */
const GUID GUID_MODEBIAS_DATETIME = {
    0xf2bdb372,
    0x7f61,
    0x4039,
    {0x92, 0xef, 0x1c, 0x35, 0x59, 0x9f, 0x02, 0x22}
  };

/* fddc10f0-d239-49bf-b8fc-5410caaa427e */
const GUID GUID_MODEBIAS_NAME = {
    0xfddc10f0,
    0xd239,
    0x49bf,
    {0xb8, 0xfc, 0x54, 0x10, 0xca, 0xaa, 0x42, 0x7e}
  };

/* 0f4ec104-1790-443b-95f1-e10f939d6546 */
const GUID GUID_MODEBIAS_CONVERSATION = {
    0x0f4ec104,
    0x1790,
    0x443b,
    {0x95, 0xf1, 0xe1, 0x0f, 0x93, 0x9d, 0x65, 0x46}
  };

/* 4021766c-e872-48fd-9cee-4ec5c75e16c3 */
const GUID GUID_MODEBIAS_NUMERIC = {
    0x4021766c,
    0xe872,
    0x48fd,
    {0x9c, 0xee, 0x4e, 0xc5, 0xc7, 0x5e, 0x16, 0xc3}
  };

/* d73d316e-9b91-46f1-a280-31597f52c694 */
const GUID GUID_MODEBIAS_HIRAGANA = {
    0xd73d316e,
    0x9b91,
    0x46f1,
    {0xa2, 0x80, 0x31, 0x59, 0x7f, 0x52, 0xc6, 0x94}
  };

/* 2e0eeddd-3a1a-499e-8543-3c7ee7949811 */
const GUID GUID_MODEBIAS_KATAKANA = {
    0x2e0eeddd,
    0x3a1a,
    0x499e,
    {0x85, 0x43, 0x3c, 0x7e, 0xe7, 0x94, 0x98, 0x11}
  };


/* 76ef0541-23b3-4d77-a074-691801ccea17 */
const GUID GUID_MODEBIAS_HANGUL = {
    0x76ef0541,
    0x23b3,
    0x4d77,
    {0xa0, 0x74, 0x69, 0x18, 0x01, 0xcc, 0xea, 0x17}
  };

/* 7add26de-4328-489b-83ae-6493750cad5c */
const GUID GUID_MODEBIAS_CHINESE = { 
    0x7add26de,
    0x4328,
    0x489b,
    {0x83, 0xae, 0x64, 0x93, 0x75, 0x0c, 0xad, 0x5c}
  };

/* 005f6b63-78d4-41cc-8859-485ca821a795 */
const GUID GUID_MODEBIAS_HALFWIDTHKATAKANA = {
    0x005f6b63,
    0x78d4,
    0x41cc,
    {0x88, 0x59, 0x48, 0x5c, 0xa8, 0x21, 0xa7, 0x95}
  };

/* 81489fb8-b36a-473d-8146-e4a2258b24ae */
const GUID GUID_MODEBIAS_FULLWIDTHALPHANUMERIC = {
    0x81489fb8,
    0xb36a,
    0x473d,
    {0x81, 0x46, 0xe4, 0xa2, 0x25, 0x8b, 0x24, 0xae}
  };

/* c6f24fc0-4479-46ed-938a-6052b1653d3b */
const GUID GUID_MODEBIAS_HALFWIDTHALPHANUMERIC = {
    0xc6f24fc0,
    0x4479,
    0x46ed,
    {0x93, 0x8a, 0x60, 0x52, 0xb1, 0x65, 0x3d, 0x3b}
  };

/* c01ae6c9-45b5-4fd0-9cb1-9f4cebc39fea */
const GUID GUID_MODEBIAS_FULLWIDTHHANGUL = { 
    0xc01ae6c9,
    0x45b5,
    0x4fd0,
    {0x9c, 0xb1, 0x9f, 0x4c, 0xeb, 0xc3, 0x9f, 0xea}
  };


/* 24af3031-852d-40a2-bc09-8992898ce722 */
const GUID GUID_TFCAT_PROPSTYLE_CUSTOM = { 
    0x24af3031,
    0x852d,
    0x40a2,
    {0xbc, 0x09, 0x89, 0x92, 0x89, 0x8c, 0xe7, 0x22}
  };

/* 565fb8d8-6bd4-4ca1-b223-0f2ccb8f4f96 */
const GUID GUID_TFCAT_PROPSTYLE_STATIC = { 
    0x565fb8d8,
    0x6bd4,
    0x4ca1,
    {0xb2, 0x23, 0x0f, 0x2c, 0xcb, 0x8f, 0x4f, 0x96}
  };

/* 85f9794b-4d19-40d8-8864-4e747371a66d */
const GUID GUID_TFCAT_PROPSTYLE_STATICCOMPACT = { 
    0x85f9794b,
    0x4d19,
    0x40d8,
    {0x88, 0x64, 0x4e, 0x74, 0x73, 0x71, 0xa6, 0x6d}
  };

/* 046b8c80-1647-40f7-9b21-b93b81aabc1b */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER = { 
    0x046b8c80,
    0x1647,
    0x40f7,
    {0x9b, 0x21, 0xb9, 0x3b, 0x81, 0xaa, 0xbc, 0x1b}
  };

/* b95f181b-ea4c-4af1-8056-7c321abbb091 */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY = { 
    0xb95f181b,
    0xea4c,
    0x4af1,
    {0x80, 0x56, 0x7c, 0x32, 0x1a, 0xbb, 0xb0, 0x91}
  };

/* 1edb55cc-58f0-4592-aae1-fe51f43b95c5 */
const GUID GUID_COMPARTMENT_SPEECH_DICTATIONSTAT = {
    0x1edb55cc,
    0x58f0,
    0x4592,
    {0xaa, 0xe1, 0xfe, 0x51, 0xf4, 0x3b, 0x95, 0xc5 }
  };
/* 575F3783-70C8-47C8-AE5D-91A01A1F7592 */
const GUID GUID_COMPARTMENT_PERSISTMENUENABLED = {
    0x575F3783,
    0x70C8,
    0x47C8,
    {0xAE, 0x5D, 0x91, 0xA0, 0x1A, 0x1F, 0x75, 0x92 }
  };

/* D92016F0-9367-4FE7-9ABF-BC59DACBE0E3 */
const GUID GUID_COMPARTMENT_SPEECH_UI_STATUS = {
    0xD92016F0,
    0x9367,
    0x4FE7,
    {0x9A, 0xBF, 0xBC, 0x59, 0xDA, 0xCB, 0xE0, 0xE3 }
  };

/* d7487dbf-804e-41c5-894d-ad96fd4eea13 */
const GUID GUID_COMPARTMENT_EMPTYCONTEXT = { 
    0xd7487dbf,
    0x804e,
    0x41c5,
    {0x89, 0x4d, 0xad, 0x96, 0xfd, 0x4e, 0xea, 0x13}
  };

/* 148ca3ec-0366-401c-8d75-ed978d85fbc9 */
const GUID GUID_COMPARTMENT_TIPUISTATUS = {
    0x148ca3ec,
    0x0366,
    0x401c,
    {0x8d, 0x75, 0xed, 0x97, 0x8d, 0x85, 0xfb, 0xc9}
  };

/* fb6c5c2d-4e83-4bb6-91a2-e019bff6762d */
const GUID GUID_COMPARTMENT_SPEECH_CFGMENU = { 
    0xfb6c5c2d,
    0x4e83,
    0x4bb6,
    {0x91, 0xa2, 0xe0, 0x19, 0xbf, 0xf6, 0x76, 0x2d}
  };

/* D02F24A1-942D-422E-8D99-B4F2ADDEE999 */
const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON = {
    0xD02F24A1,
    0x942D,
    0x422E,
    {0x8D, 0x99, 0xB4, 0xF2, 0xAD, 0xDE, 0xE9, 0x99}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uuid\cicclsid.c ===
//
//  !! WARNING WARNING WARNING !!
// 
//  THIS FILE WAS GENERATED BY CICCLSID.BAT.
//  THESE CLSIDS MUST BE SAME WITH *.RGS FILES UNDER UIM.
//


/* 529A9E6B-6587-4F23-AB9E-9C7D683E3C50 */
const CLSID CLSID_TF_ThreadMgr = { 
    0x529A9E6B,
    0x6587,
    0x4F23,
    {0xAB, 0x9E, 0x9C, 0x7D, 0x68, 0x3E, 0x3C, 0x50}
  };
/* EBB08C45-6C4A-4FDC-AE53-4EB8C4C7DB8E */
const CLSID CLSID_TF_LangBarMgr = { 
    0xEBB08C45,
    0x6C4A,
    0x4FDC,
    {0xAE, 0x53, 0x4E, 0xB8, 0xC4, 0xC7, 0xDB, 0x8E}
  };
/* 3CE74DE4-53D3-4D74-8B83-431B3828BA53 */
const CLSID CLSID_TF_DisplayAttributeMgr = { 
    0x3CE74DE4,
    0x53D3,
    0x4D74,
    {0x8B, 0x83, 0x43, 0x1B, 0x38, 0x28, 0xBA, 0x53}
  };
/* A4B544A1-438D-4B41-9325-869523E2D6C7 */
const CLSID CLSID_TF_CategoryMgr = { 
    0xA4B544A1,
    0x438D,
    0x4B41,
    {0x93, 0x25, 0x86, 0x95, 0x23, 0xE2, 0xD6, 0xC7}
  };
/* 33C53A50-F456-4884-B049-85FD643ECFED */
const CLSID CLSID_TF_InputProcessorProfiles = { 
    0x33C53A50,
    0xF456,
    0x4884,
    {0xB0, 0x49, 0x85, 0xFD, 0x64, 0x3E, 0xCF, 0xED}
  };
/* B9931692-A2B3-4FAB-BF33-9EC6F9FB96AC */
const CLSID CLSID_TF_LangBarItemMgr = { 
    0xB9931692,
    0xA2B3,
    0x4FAB,
    {0xBF, 0x33, 0x9E, 0xC6, 0xF9, 0xFB, 0x96, 0xAC}
  };

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\bridgecp\factory.h ===
#if !defined(BRIDGECP__Factory_h__INCLUDED)
#define BRIDGECP__Factory_h__INCLUDED
#pragma once

extern "C"  BOOL        WINAPI  InitBridge();
extern "C"  DUser::Gadget *
                        WINAPI  BuildBridgeGadget(HCLASS hcl, DUser::Gadget::ConstructInfo * pmicData, EventProc pfnEvent, MethodProc pfnMethod);

#endif // BRIDGECP__Factory_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\bridgecp\bridgecp.h ===
#if !defined(BRIDGECP__BridgeCP_h__INCLUDED)
#define BRIDGECP__BridgeCP_h__INCLUDED
#pragma once

typedef UINT    (CALLBACK * EventProc)(EventMsg * pMsg);
typedef void    (CALLBACK * MethodProc)(MethodMsg * pMsg);

struct BridgeData
{
    EventProc   pfnEvent;
    MethodProc  pfnMethod;
};

BridgeData *    GetBridgeData();

//------------------------------------------------------------------------------
inline void SetError(HRESULT hr)
{
    SetLastError((DWORD) hr);
}


#endif // BRIDGECP__BridgeCP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\bridgecp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Services.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\bridgecp\factory.cpp ===
#include "stdafx.h"
#include "BridgeCP.h"
#include "Factory.h"

DWORD g_tls = (DWORD) -1;

//------------------------------------------------------------------------------
BridgeData *
GetBridgeData()
{
    return (BridgeData *) TlsGetValue(g_tls);
}


//------------------------------------------------------------------------------
BOOL
InitBridge()
{
    if (g_tls == (DWORD) -1) {
        g_tls = TlsAlloc();
        if (g_tls == (DWORD) -1) {
            SetError(DU_E_OUTOFKERNELRESOURCES);
            return FALSE;
        }
    }

    return TRUE;
}


//------------------------------------------------------------------------------
DUser::Gadget *
BuildBridgeGadget(
    IN  HCLASS hcl, 
    IN  DUser::Gadget::ConstructInfo * pmicData, 
    IN  EventProc pfnEvent, 
    IN  MethodProc pfnMethod)
{
    if (g_tls == -1) {
        SetError(DU_E_NOTINITIALIZED);
        return NULL;
    }

    BridgeData * pbd = (BridgeData *) TlsGetValue(g_tls);
    if (pbd == NULL) {
        pbd = (BridgeData *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BridgeData));
        if (pbd == NULL) {
            SetError(E_OUTOFMEMORY);
            return NULL;
        }
        TlsSetValue(g_tls, pbd);
    }

    pbd->pfnEvent   = pfnEvent;
    pbd->pfnMethod  = pfnMethod;

    return DUserBuildGadget(hcl, pmicData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\bridgecp\makefile.inc ===
#
# GIDL
#

$(O)\stub.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -t$(NTMAKEENV)\Template.gml

$(O)\super.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -t$(NTMAKEENV)\Template.gml

$(O)\Api.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -tApi.gml

$(O)\Bridge.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -tApi.gml

$(O)\BridgeCP.def: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -tApi.gml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\sources.inc ===
!IF 0

    Shared sources.inc file for Engine projects.

!ENDIF

# Do not use NTBUILD's Warning.h pragmas, will treat all warnings as errors and use highest level (W4)
COMPILER_WARNINGS=

MSC_STDCALL=1
MSC_WARNING_LEVEL=/W4

USE_MSVCRT=1

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
# Disable PCH because DirectUI.lib is published to public\internal, and there
# are libs included in DirectUIGP.lib which is published to public\internal.
NTNOPCH=1
!endif

INCLUDES=\
        $(WINDOWS_INC_PATH)\DUser;\
        $(ADVCORE_PATH)\duser\inc;\
        $(SDK_INC_PATH)\gdiplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\base.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_BASE_BASE_H_INCLUDED
#define DUI_BASE_BASE_H_INCLUDED

#pragma once

#endif // DUI_BASE_BASE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\bridgecp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
#define AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_

#pragma once

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500		// TODO: Remove this when updated headers are available
#endif


// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros


// COM Header Files
#include <ObjBase.h>            // CoCreateInstance, IUnknown
#include <DDraw.h>              // DirectDraw
#include <oleidl.h>             // OLE2 Interfaces

// Related services
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)


// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <tchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Gadgets Header Files
#include <AutoUtil.h>           // External debugging support

#define GADGET_ENABLE_ALL
#include <DUser.h>

#endif // !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\error.cpp ===
/*
 * Error checking support methods
 */

#include "stdafx.h"
#include "base.h"

#include "duierror.h"

namespace DirectUI
{

/////////////////////////////////////////////////////////////////////////////
// Debugging

void ForceDebugBreak()
{
    DebugBreak();
}

/////////////////////////////////////////////////////////////////////////////
// Profiling support
//
#ifdef PROFILING

typedef (__stdcall *ICPROFILE)(int nLevel, unsigned long dwId);

HINSTANCE hIceCap = NULL;
ICPROFILE pfnStart = NULL;
ICPROFILE pfnStop = NULL;

void ICProfileOn()
{
    if (!pfnStart)
    {
        if (!hIceCap)
        {
            hIceCap = LoadLibraryW(L"icecap.dll");
        }

        if (hIceCap)
        {
            pfnStart = (ICPROFILE)GetProcAddress(hIceCap, L"StartProfile");
        }
    }

    if (pfnStart)
        pfnStart(3, (ULONG)-1);
}

void ICProfileOff()
{
    if (!pfnStop)
    {
        if (!hIceCap)
        {
            hIceCap = LoadLibraryW(L"icecap.dll");
        }

        if (hIceCap)
        {
            pfnStop = (ICPROFILE)GetProcAddress(hIceCap, L"StopProfile");
        }
    }

    if (pfnStop)
        pfnStop(3, (ULONG)-1);
}

#endif

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\alloc.cpp ===
/*
 * Heap allocation methods
 */

#include "stdafx.h"
#include "base.h"

#include "duialloc.h"

#include "duierror.h"

namespace DirectUI
{

HANDLE g_hHeap = NULL;

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\linkedlist.cpp ===
/*
 * LinkedList
 */

#include "stdafx.h"
#include "base.h"

#include "linkedlist.h"

#include "duierror.h"

namespace DirectUI
{

LinkedList::LinkedList()
{
    pHead = NULL;
    pTail = NULL;
}

LinkedList::~LinkedList()
{
    DUIAssert(!pHead, "List destroyed with without all nodes removed first");
}

void LinkedList::Add(LinkedListNode* pNode)
{
    DUIAssertNoMsg(pNode && !pNode->pNext && !pNode->pPrev);

    pNode->pNext = pHead;
    
    if (pHead)
        pHead->pPrev = pNode;
    else
        pTail = pNode;

    pHead = pNode;
    pNode->pPrev = NULL;
}

void LinkedList::Remove(LinkedListNode* pNode)
{
    if (pNode->pPrev)
        pNode->pPrev->pNext = pNode->pNext;
    else
        pHead = pNode->pNext;

    if (pNode->pNext)
        pNode->pNext->pPrev = pNode->pPrev;
    else
        pTail = pNode->pPrev;

    pNode->pNext = NULL;
    pNode->pPrev = NULL;
}

LinkedListNode* LinkedList::RemoveTail()
{
    LinkedListNode* pNode = NULL;

    if (pTail)
    {
        pNode = pTail;
        Remove(pTail);
    }

    return pNode;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\linkedlist.h ===
/*
 * Linked List
 */

#ifndef DUI_BASE_LINKEDLIST_H_INCLUDED
#define DUI_BASE_LINKEDLIST_H_INCLUDED

#pragma once

#include "stdafx.h"
#include "base.h"

namespace DirectUI
{

class LinkedListNode
{
public:
    LinkedListNode* pNext;
    LinkedListNode* pPrev;
};

class LinkedList
{
public:
    LinkedList();
    ~LinkedList();
    void Add(LinkedListNode* pNode);
    void Remove(LinkedListNode* pNode);
    LinkedListNode* RemoveTail();

private:
    LinkedListNode* pHead;
    LinkedListNode* pTail;
};

} // namespace DirectUI

#endif // DUI_BASE_LINKEDLIST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\fontcache.cpp ===
/*
 * Font Cache
 */

#include "stdafx.h"
#include "base.h"

#include "duifontcache.h"

#include "duierror.h"
#include "duialloc.h"

// Font cache exposes GDI font failures by returning NULL font handles

namespace DirectUI
{

int __cdecl FCSort(const void* pA, const void* pB)
{
    FontCache::RecordIdx* priA = (FontCache::RecordIdx*)pA;
    FontCache::RecordIdx* priB = (FontCache::RecordIdx*)pB;

    DUIAssert(priA->pfcContext == priB->pfcContext, "Font cache sort context mismatch");

    FontCache* pfc = priA->pfcContext;

    UINT uAHits = pfc->_GetRecordHits(priA->idx);
    UINT uBHits = pfc->_GetRecordHits(priB->idx);

    if (uAHits == uBHits)
        return 0;

    if (uAHits > uBHits)
        return -1;
    else
        return 1;
}

HRESULT FontCache::Create(UINT uCacheSize, OUT FontCache** ppCache)
{
    DUIAssert(uCacheSize >= 1, "Cache size must be greater than 1");
    
    *ppCache = NULL;

    FontCache* pfc = HNew<FontCache>();
    if (!pfc)
        return E_OUTOFMEMORY;

    HRESULT hr = pfc->Initialize(uCacheSize);
    if (FAILED(hr))
    {
        pfc->Destroy();
        return hr;
    }

    *ppCache = pfc;

    return S_OK;
}

HRESULT FontCache::Initialize(UINT uCacheSize)
{
    // Initialize
    _pDB = NULL;
    _pFreq = NULL;
    _fLock = false;
    _uCacheSize = uCacheSize;

    // Create tables
    _pDB = (FontRecord*)HAllocAndZero(sizeof(FontRecord) * _uCacheSize);
    if (!_pDB)
        return E_OUTOFMEMORY;

    _pFreq = (RecordIdx*)HAlloc(sizeof(RecordIdx) * _uCacheSize);
    if (!_pFreq)
    {
        HFree(_pDB);
        _pDB = NULL;
        return E_OUTOFMEMORY;
    }

    for (UINT i = 0; i < _uCacheSize; i++)
    {
        _pFreq[i].pfcContext = this;  // Store context for global sort routine
        _pFreq[i].idx = i;
    }

    return S_OK;
}

void FontCache::Destroy()
{ 
    HDelete<FontCache>(this); 
}

FontCache::~FontCache()
{
    if (_pFreq)
        HFree(_pFreq);

    if (_pDB)
    {
        // Free all fonts
        for (UINT i = 0; i < _uCacheSize; i++)
        {
            if ((_pDB + i)->hFont)
                DeleteObject((_pDB + i)->hFont);
        }

        HFree(_pDB);
    }
}

HFONT FontCache::CheckOutFont(LPWSTR szFamily, int dSize, int dWeight, int dStyle, int dAngle)
{
    // Only one font can be checked out at a time, use CheckInFont to unlock cache
    DUIAssert(!_fLock, "Only one font can be checked out at a time.");

    _fLock = true;

    // Search for font in order of most-frequently-used Index
    FontRecord* pRec = NULL;
    UINT i;
    for (i = 0; i < _uCacheSize; i++)
    {
        // Get record
        pRec = _pDB + _pFreq[i].idx;

        // Check for match
        if (pRec->dStyle == dStyle &&
            pRec->dWeight == dWeight &&
            pRec->dSize == dSize &&
            pRec->dAngle == dAngle &&
            !_wcsicmp(pRec->szFamily, szFamily))
        {
            // Match, _pFreq[i].idx has record number
            break;
        }

        pRec = NULL;
    }

    // Check existance of record
    if (!pRec)
    {
        // Record not found, create
        // Take LFU (last index) and fill struct
        i--;

        pRec = _pDB + _pFreq[i].idx;

        // Destroy record first, if exists
        if (pRec->hFont)
            DeleteObject(pRec->hFont);
        
        // Create new font
        LOGFONTW lf;
        ZeroMemory(&lf, sizeof(LOGFONT));

        lf.lfHeight = dSize;
        lf.lfWeight = dWeight;
        lf.lfItalic = (dStyle & FS_Italic) != 0;
        lf.lfUnderline = (dStyle & FS_Underline) != 0;
        lf.lfStrikeOut = (dStyle & FS_StrikeOut) != 0;
        lf.lfCharSet = DEFAULT_CHARSET;
        lf.lfQuality = DEFAULT_QUALITY;
        lf.lfEscapement = dAngle;
        lf.lfOrientation = dAngle;
        StringCbCopyW(lf.lfFaceName, sizeof(lf.lfFaceName), szFamily);

        // Create
        pRec->hFont = CreateFontIndirectW(&lf);

#if DBG
        DUIAssert(pRec->hFont, "Unable to create font!");

        HDC hdc = GetDC(NULL);
        HFONT hOldFont = (HFONT)SelectObject(hdc, pRec->hFont);

        
        WCHAR szUsed[81];
        GetTextFaceW(hdc, 80, szUsed);

        SelectObject(hdc, hOldFont);
        ReleaseDC(NULL, hdc);

        //DUITrace(">> Font: '%S' (Actual: %S)\n", lf.lfFaceName, szUsed);
#endif

        // Fill rest of record
        pRec->dSize = dSize;
        pRec->dStyle = dStyle;
        pRec->dWeight = dWeight;
        pRec->dAngle = dAngle;
        StringCbCopyW(pRec->szFamily, sizeof(pRec->szFamily), szFamily);
        pRec->uHits = 0;
    }

    // Add font hit
    pRec->uHits++;

    // Check if should resort index by checking number of hit of previous index
    if (i != 0 && pRec->uHits >= (_pDB + _pFreq[i-1].idx)->uHits)
    {
        qsort(_pFreq, _uCacheSize, sizeof(RecordIdx), FCSort);

        //OutputDebugStringW(L"FontCache Hit sort: ");
        //WCHAR buf[81];
        //for (UINT j = 0; j < _uCacheSize; j++)
        //{
        //    wsprintf(buf, L"%d[%d] ", _pFreq[j].idx, _GetRecordHits(_pFreq[j].idx));
        //    OutputDebugStringW(buf);
        //}
        //OutputDebugStringW(L"\n");
    }

    return pRec->hFont;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_BASE_PUBLISHED_H_INCLUDED
#define DUI_BASE_PUBLISHED_H_INCLUDED

#include "duierror.h"
#include "duialloc.h"
#include "duisballoc.h"
#include "duisurface.h"
#include "duiuidgen.h"
#include "duifontcache.h"
#include "duibtreelookup.h"
#include "duivaluemap.h"
#include "duidynamicarray.h"

#endif // DUI_BASE_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\sources.inc ===
!IF 0

    DirectUI Base Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\alloc.cpp        \
        ..\error.cpp        \
        ..\fontcache.cpp    \
        ..\linkedlist.cpp   \
        ..\sballoc.cpp      \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxbase.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\stdafxbase.cpp ===
/*
 * stdafxbase.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_BASE_STDAFX_H_INCLUDED
#define DUI_BASE_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_BASE_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\base\sballoc.cpp ===
/*
 * Fixed-Size Small Block Allocator
 */

#include "stdafx.h"
#include "base.h"

#include "duisballoc.h"

#include "duialloc.h"
#include "duierror.h"

// SBAlloc is intended for structures and reserves the first byte of the block for
// block flags. The structure used will be auto-packed by the compiler
//
// BLOCK: | BYTE | ------ Non-reserved DATA ------ S

// SBAlloc does not have a static creation method. Memory failures will be
// exposed via it's Alloc method

// Define SBALLOCDISABLE to force small block allocator to simply make
// every process allocation using the process heap. Although much slower,
// it is useful when running tools to detect heap corruption (including
// mismatched reference counting)
//#define SBALLOCDISABLE

namespace DirectUI
{

#if DBG
int g_cSBAllocs = 0;
int g_cSBRefills = 0;
#endif

#ifndef SBALLOCDISABLE

HRESULT SBAlloc::Create(UINT uBlockSize, UINT uBlocksPerSection, ISBLeak* pisbLeak, SBAlloc** ppSBA)
{
    HRESULT hr;

    *ppSBA = NULL;

    SBAlloc* psba = HNew<SBAlloc>();
    if (!psba)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    psba->_pSections = NULL;
    psba->_ppStack = NULL;
        
    // Leak callback interface, not ref counted
    psba->_pisbLeak = pisbLeak;

    psba->_uBlockSize = uBlockSize;
    psba->_uBlocksPerSection = uBlocksPerSection;

    // Setup first section, extra byte per block as InUse flag
    psba->_pSections = (SBSection*)HAlloc(sizeof(SBSection));
    if (!psba->_pSections)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    psba->_pSections->pNext = NULL;

    psba->_pSections->pData = (BYTE*)HAlloc(psba->_uBlockSize * psba->_uBlocksPerSection);

    if (psba->_pSections->pData)
    {
#if DBG
        memset(psba->_pSections->pData, SBALLOC_FILLCHAR, psba->_uBlockSize * psba->_uBlocksPerSection);
#endif
        for (UINT i = 0; i < psba->_uBlocksPerSection; i++)
            *(psba->_pSections->pData + (i * psba->_uBlockSize)) = 0; // Block not in use
    }

    // Create free block stack
    psba->_ppStack = (BYTE**)HAlloc(sizeof(BYTE*) * psba->_uBlocksPerSection);
    if (!psba->_ppStack)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }
    
    psba->_dStackPtr = -1;

    *ppSBA = psba;

    //DUITrace("DUI Small-block allocator created (block size: %d)\n", uBlockSize);

    return S_OK;

Failure:

    if (psba)
    {
        if (psba->_ppStack)
            HFree(psba->_ppStack);

        if (psba->_pSections)
            HFree(psba->_pSections);

        psba->Destroy();
    }

    return hr;
}

void SBAlloc::Destroy() 
{ 
    HDelete<SBAlloc>(this); 
}

SBAlloc::~SBAlloc()
{
    // Free all sections
    SBSection* psbs = _pSections;
    SBSection* ptmp;

    while (psbs)
    {
        // Leak detection
        if (_pisbLeak && psbs->pData)
        {
            BYTE* pScan;

            // Check for leaks
            for (UINT i = 0; i < _uBlocksPerSection; i++)
            {
                pScan = psbs->pData + (i * _uBlockSize);
                if (*pScan)
                    _pisbLeak->AllocLeak(pScan);
            }
        }

        ptmp = psbs;
        psbs = psbs->pNext;

        // Free section
        if (ptmp->pData)
            HFree(ptmp->pData);
        if (ptmp)
            HFree(ptmp);
    }

    // Free stack
    if (_ppStack)
        HFree(_ppStack);
}

// Returns false on memory errors
bool SBAlloc::_FillStack()
{
#if DBG
    g_cSBRefills++;
#endif

    if (!_pSections || !_ppStack)
        return false;

    // Scan for free block
    SBSection* psbs = _pSections;

    BYTE* pScan;

    for(;;)
    {
        // Locate free blocks in section and populate stack
        if (psbs->pData)
        {
            for (UINT i = 0; i < _uBlocksPerSection; i++)
            {
                pScan = psbs->pData + (i * _uBlockSize);

                if (!*pScan)
                {
                    // Block free, store in stack
                    _dStackPtr++;
                    _ppStack[_dStackPtr] = pScan;

                    if ((UINT)(_dStackPtr + 1) == _uBlocksPerSection)
                        return true;
                }
            }
        }

        if (!psbs->pNext)
        {
            // No block found, and out of sections, create new section
            SBSection* pnew = (SBSection*)HAlloc(sizeof(SBSection));

            if (pnew)
            {
                pnew->pNext = NULL;

                pnew->pData = (BYTE*)HAlloc(_uBlockSize * _uBlocksPerSection);

                if (pnew->pData)
                {
#if DBG
                    memset(pnew->pData, SBALLOC_FILLCHAR, _uBlockSize * _uBlocksPerSection);
#endif
                    for (UINT i = 0; i < _uBlocksPerSection; i++)
                        *(pnew->pData + (i * _uBlockSize)) = 0; // Block not in use
                }
            }
            else
                return false;

            psbs->pNext = pnew;
        }

        // Search in next section
        psbs = psbs->pNext;
    }
}

void* SBAlloc::Alloc()
{
#if DBG
    g_cSBAllocs++;
#endif

    if (_dStackPtr == -1)
    {
        if (!_FillStack())
            return NULL;
    }

    if (!_ppStack)
        return NULL;

    BYTE* pBlock = _ppStack[_dStackPtr];

#if DBG
     memset(pBlock, SBALLOC_FILLCHAR, _uBlockSize);
#endif

    *pBlock = 1;  // Mark as in use

    _dStackPtr--;

    return pBlock;
}

void SBAlloc::Free(void* pBlock)
{
    if (!pBlock)
        return;

    // Return to stack
    BYTE* pHold = (BYTE*)pBlock;

#if DBG
     memset(pHold, SBALLOC_FILLCHAR, _uBlockSize);
#endif

    *pHold = 0;  // No longer in use

    if ((UINT)(_dStackPtr + 1) != _uBlocksPerSection)
    {
        _dStackPtr++;

        if (_ppStack)
            _ppStack[_dStackPtr] = pHold;
    }
}

#else // SBALLOCDISABLE

#error Use for temporary corruption detection only

SBAlloc::SBAlloc(UINT uBlockSize, UINT uBlocksPerSection, ISBLeak* pisbLeak)
{
    //DUITrace("DUI Small-block allocator created (block size: %d)\n", uBlockSize);

    // Leak callback interface, not ref counted
    _pisbLeak = pisbLeak;

    _uBlockSize = uBlockSize;
    _uBlocksPerSection = uBlocksPerSection;

    _pSections = NULL;
    _ppStack = NULL;
}

SBAlloc::~SBAlloc()
{
}

// Returns false on memory errors
bool SBAlloc::_FillStack()
{
#if DBG
    g_cSBRefills++;
#endif

    return true;
}

void* SBAlloc::Alloc()
{
#if DBG
    g_cSBAllocs++;
#endif

    return HAlloc(_uBlockSize);
}

void SBAlloc::Free(void* pBlock)
{
    HFree(pBlock);
}

#endif // SBALLOCDISABLE

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\behavior.h ===
/*
 * Behavior
 */

#ifndef DUI_CONTROL_BEHAVIOR_H_INCLUDED
#define DUI_CONTROL_BEHAVIOR_H_INCLUDED

#pragma once

//typedef void    (CALLBACK * EventCallback)(Element* pe);

namespace DirectUI
{

typedef struct tagClickInfo
{
    UINT  nCount;
    UINT  uModifiers;
    POINT pt;
} ClickInfo;

BOOL CheckContext(Element* pe, InputEvent* pie, BOOL* pbPressed, ClickInfo* pci);
BOOL CheckClick(Element* pe, InputEvent* pie, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci);
BOOL CheckClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci);
BOOL CheckRepeatClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbActionDelay, HACTION* phAction, ACTIONPROC pfnActionCallback, ClickInfo* pci);

} // namespace DirectUI

#endif // DUI_CONTROL_BEHAVIOR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\control.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_CONTROL_CONTROL_H_INCLUDED
#define DUI_CONTROL_CONTROL_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>
#include <DUICoreP.h>

#endif // DUI_CONTROL_CONTROL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\button.cpp ===
/*
 * Button
 */

#include "stdafx.h"
#include "control.h"

#include "duibutton.h"

#include "Behavior.h"

namespace DirectUI
{

// Internal helper
extern inline void _FireClickEvent(Button* peTarget, ClickInfo* pci);
extern inline void _FireContextEvent(Button* peTarget, ClickInfo* pci);

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Button, Click)  // ButtonClickEvent struct
DefineClassUniqueID(Button, Context)  // ButtonContextEvent struct

////////////////////////////////////////////////////////
// Button

HRESULT Button::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    Button* pb = HNew<Button>();
    if (!pb)
        return E_OUTOFMEMORY;

    HRESULT hr = pb->Initialize(nActive);
    if (FAILED(hr))
    {
        pb->Destroy();
        return hr;
    }

    *ppElement = pb;

    return S_OK;
}

HRESULT Button::Initialize(UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    SetActive(nActive);

    return S_OK;
}

void _FireClickEvent(Button* peTarget, ClickInfo* pci)
{
    //DUITrace("Click! <%x>\n", peTarget);

    // Fire click event
    ButtonClickEvent bce;
    bce.uidType = Button::Click;
    bce.nCount = pci->nCount;
    bce.uModifiers = pci->uModifiers;
    bce.pt = pci->pt;

    peTarget->FireEvent(&bce);  // Will route and bubble
}

void _FireContextEvent(Button* peTarget, ClickInfo* pci)
{
    //DUITrace("Click! <%x>\n", peTarget);

    // Fire click event
    ButtonContextEvent bce;
    bce.uidType = Button::Context;
    bce.uModifiers = pci->uModifiers;
    bce.pt = pci->pt;

    peTarget->FireEvent(&bce);  // Will route and bubble
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
void Button::OnInput(InputEvent* pie)
{
    BOOL bPressed = GetPressed(); // Previous pressed state required for CheckClick
    BOOL bPressedBefore = bPressed; // Store previous state to optimize set since already getting value
    BOOL bCaptured = FALSE;
    ClickInfo ci;

    // First, watch for a click event
    BOOL bFire = CheckClick(this, pie, GBUTTON_LEFT, &bPressed, &bCaptured, &ci);

    if (bPressed != bPressedBefore)
    {
        if (bPressed)
            SetPressed(true);
        else
            RemoveLocalValue(PressedProp);
    }

    // Update mouse captured state
    if (bCaptured)
        SetCaptured(true);
    else
        RemoveLocalValue(CapturedProp);
    
    if (bFire) 
        _FireClickEvent(this, &ci);

    if (pie->fHandled)
        return;

    // Second, watch for a context event
    bFire = CheckContext(this, pie, &_bRightPressed, &ci);

    if (bFire)
        _FireContextEvent(this, &ci);

    if (pie->fHandled)
        return;

    Element::OnInput(pie);
}

void Button::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Accessible)) {
        //
        // When accessibility support for this button is turned ON,
        // make sure that its state reflects the appropriate information.
        //
        if (pvNew->GetBool()) {
            int nAccState = GetAccState();
            if (GetPressed()) {
                nAccState |= STATE_SYSTEM_PRESSED;
            } else {
                nAccState &= ~STATE_SYSTEM_PRESSED;
            }
            SetAccState(nAccState);
        }
    }
    else if (IsProp(Pressed)) {
        if (GetAccessible()) {
            int nAccState = GetAccState();
            if (pvNew->GetBool()) {
                nAccState |= STATE_SYSTEM_PRESSED;
            } else {
                nAccState &= ~STATE_SYSTEM_PRESSED;
            }
            SetAccState(nAccState);
        }
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

HRESULT Button::DefaultAction()
{
	//
	// Simulate that a keypress caused the click.
	//
	ClickInfo ci;
	ci.nCount = 1;
	ci.uModifiers = 0;
	ci.pt.x = -1;
	ci.pt.y = -1;

	_FireClickEvent(this, &ci);

	return S_OK;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Pressed property
static int vvPressed[] = { DUIV_BOOL, -1 };
static PropertyInfo impPressedProp = { L"Pressed", PF_Normal, 0, vvPressed, NULL, Value::pvBoolFalse };
PropertyInfo* Button::PressedProp = &impPressedProp;

// Captured property
static int vvCaptured[] = { DUIV_BOOL, -1 };
static PropertyInfo impCapturedProp = { L"Captured", PF_Normal, 0, vvCaptured, NULL, Value::pvBoolFalse };
PropertyInfo* Button::CapturedProp = &impCapturedProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Button::PressedProp,
                                Button::CapturedProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Button::Class = NULL;

HRESULT Button::Register()
{
    return ClassInfo<Button,Element>::Register(L"Button", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\behavior.cpp ===
/*
 * Button
 */

#include "stdafx.h"
#include "control.h"

#include "Behavior.h"

namespace DirectUI
{

BOOL CheckContext(Element* pe, InputEvent* pie, BOOL* pbPressed, ClickInfo* pci)
{
    BOOL bUnused;

    if (CheckClick(pe, pie, GBUTTON_RIGHT, pbPressed, &bUnused, pci))
        return TRUE;
        
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        if (pie->nDevice == GINPUT_KEYBOARD)
        {
            KeyboardEvent* pke = (KeyboardEvent*)pie;

            switch (pke->ch)
            {
                case VK_F10:
                    if ((pke->nCode == GKEY_SYSDOWN) && (pke->uModifiers & GMODIFIER_SHIFT))
                    {
                        *pbPressed = FALSE;
                        pci->nCount = 1;
                        pci->pt.x = -1;
                        pci->pt.y = -1;
                        pci->uModifiers = (pke->uModifiers & ~GMODIFIER_SHIFT);
                        pie->fHandled = true;
                        return TRUE;
                    }
                    break;

                case VK_APPS:
                    if (pke->nCode == GKEY_DOWN)
                    {
                        *pbPressed = TRUE;
                        pie->fHandled = true;
                    }
                    else if (pke->nCode == GKEY_UP)
                    {
                        pie->fHandled = true;

                        if (*pbPressed)
                        {
                            *pbPressed = FALSE;
                            pci->nCount = 1;
                            pci->pt.x = -1;
                            pci->pt.y = -1;
                            pci->uModifiers = pke->uModifiers;
                            return TRUE;
                        }
                    }
                    break;

                case 0x1B:  // ESC
                    if (pke->nCode == GKEY_DOWN && *pbPressed)
                    {
                        // todo:  need to tell gadget to release mouse capture
                        *pbPressed = FALSE;

                        pie->fHandled = true;
                    }
                    break;
            }
        }
    }
    return false;

}

BOOL CheckClick(Element* pe, InputEvent* pie, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci)
{
    return CheckClick(pe, pie, GBUTTON_LEFT, pbPressed, pbCaptured, pci);
}

BOOL CheckRepeatClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbActionDelay, HACTION* phAction, ACTIONPROC pfnActionCallback, ClickInfo* pci)
{
    BOOL bPressedOld = *pbPressed;
    BOOL bUnused;
    
    // use checkclick to update pressed state
    CheckClick(pe, pie, bButton, pbPressed, &bUnused, pci);
    BOOL bReturn = FALSE;

    if (bPressedOld != *pbPressed)
    {
        if (pie->nDevice == GINPUT_MOUSE)
        {
            if (pie->nCode == GMOUSE_DOWN)
            {
                pci->nCount = 1;
                pci->pt = ((MouseEvent*) pie)->ptClientPxl;
                pci->uModifiers = pie->uModifiers;
                *pbActionDelay = TRUE;
            }
        }
        else if (pie->nDevice == GINPUT_KEYBOARD)
        {
            if (pie->nCode == GKEY_DOWN)
            {
                pci->nCount = 1;
                pci->pt.x = -1;
                pci->pt.y = -1;
                pci->uModifiers = pie->uModifiers;
                *pbActionDelay = TRUE;
            }
        }

        bReturn = *pbActionDelay;

        // this is one reason these behaviors aren't ready for prime time;
        // what I need here is a handler for onpropertychanged of the 
        // pressed property since someone could programmatically reset
        // pressed and I would be unable to see that change and reset 
        // the timer appropriately
        if (bPressedOld)
        {
            // Clear timer
            if (*phAction)
                DeleteHandle(*phAction);

            *phAction = NULL;
        }
        else
        {
            DUIAssert(!*phAction, "An action should not be active");

            // Actions will fire subsequent events
            GMA_ACTION maa;
            ZeroMemory(&maa, sizeof(maa));
            maa.cbSize = sizeof(GMA_ACTION);
            maa.flDelay = *pbActionDelay ? (float).5 : 0;
            maa.flDuration = 0;
            maa.flPeriod = (float).05;
            maa.cRepeat = (UINT) -1;
            maa.pfnProc = pfnActionCallback;
            maa.pvData = pe;                

            *phAction = CreateAction(&maa);

            *pbActionDelay = FALSE;
        }
    }
    return bReturn;
}

BOOL CheckClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci)
{
    UNREFERENCED_PARAMETER(pe);

    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
            case GINPUT_MOUSE:
            {
                MouseEvent* pme = (MouseEvent*)pie;

                if (pme->bButton == bButton)
                {
                    switch (pme->nCode)
                    {
                        case GMOUSE_DOWN:
                            *pbPressed = TRUE;
                            *pbCaptured = TRUE;
                            pme->fHandled = true;
                            break;

                        case GMOUSE_DRAG:
                            *pbPressed = ((MouseDragEvent*) pme)->fWithin;
                            *pbCaptured = TRUE;
                            pme->fHandled = true;
                            break;

                        case GMOUSE_UP:
                            *pbPressed = FALSE;
                            *pbCaptured = FALSE;
                            pme->fHandled = true;
                            MouseClickEvent* pmce = (MouseClickEvent*) pme;
                            if (pmce->cClicks)
                            {
                                pci->nCount = pmce->cClicks;
                                pci->pt = pmce->ptClientPxl;
                                pci->uModifiers = pmce->uModifiers;
                                return TRUE;
                            }
                            break;
                    }
                }
            }
            break;

            case GINPUT_KEYBOARD:
            {
                // only do keyboard handling of click for left click
                if (bButton == GBUTTON_LEFT)
                {
                    KeyboardEvent* pke = (KeyboardEvent*)pie;
                    //DUITrace("KeyboardEvent <%x>: %d[%d]\n", this, pke->ch, pke->nCode);

                    switch (pke->ch)
                    {
                    case 0x20:  // Space
                        if (pke->nCode == GKEY_DOWN)
                        {
                            *pbPressed = TRUE;
                            pie->fHandled = true;
                        }
                        else if (pke->nCode == GKEY_UP)
                        {
                            pie->fHandled = true;

                            if (*pbPressed)
                            {
                                *pbPressed = FALSE;
                                pci->nCount = 1;
                                pci->pt.x = -1;
                                pci->pt.y = -1;
                                pci->uModifiers = pke->uModifiers;
                                return TRUE;
                            }
                        }
                        break;

                    case 0x0D:  // Enter
                        if (pke->nCode == GKEY_DOWN)
                        {
                            pie->fHandled = true;
                            pci->nCount = 1;
                            pci->pt.x = -1;
                            pci->pt.y = -1;
                            pci->uModifiers = pke->uModifiers;
                            return TRUE;
                        }
                        break;

                    case 0x1B:  // ESC
                        if (pke->nCode == GKEY_DOWN && *pbPressed)
                        {
                            // todo:  need to tell gadget to release mouse capture
                            *pbPressed = FALSE;

                            pie->fHandled = true;
                        }
                        break;
                    }
                }
            }
            break;
        }
    }
    return false;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\hwndhost.cpp ===
// HWNDHost.cpp
//

#include "stdafx.h"
#include "control.h"

#include "duihwndhost.h"

/*
 * Order of Win32 focus messages:
 *
 * WM_ACTIVATE is only sent to top-level (focus is entering/leaving top-level window).
 *
 * When in WM_ACTIVATE(WA_INACTIVE) state
 *
 * If click, WM_ACTIVATE(WA_CLICKACTIVE) then WM_SETFOCUS on top level,
 *    WM_KILLFOCUS on top level, then WM_SETFOCUS on item clicked on.
 * If Alt-Tab, WM_ACTIVATE(WM_ACTIVE) then WM_SETFOCUS on top level.
 * If SetFocus, WM_ACTIVATE(WA_ACTIVE) then WM_SETFOCUS on top level, 
 *    WM_KILLFOCUS on top level, then WM_SETFOCUS on item specified.
 *
 * When in WM_ACTIVATE(WA_ACTIVE) state
 *
 * If click, WM_KILLFOCUS on current focused item, WM_SETFOCUS on item clicked on.
 * If Alt-Tab, WM_ACTIVATE(WM_INACTIVE) then WM_KILLFOCUS on current.
 * If SetFocus, WM_KILLFOCUS on current focused item, WM_SETFOCUS on item specified.
 */

namespace DirectUI
{

// Gadget input message to HWND input message mapping
const UINT HWNDHost::g_rgMouseMap[7][3] =
{
    // GBUTTON_NONE (0)  
    // GBUTTON_LEFT (1)  GBUTTON_RIGHT (2) GBUTTON_MIDDLE (3)
    {  WM_MOUSEMOVE,     WM_MOUSEMOVE,     WM_MOUSEMOVE    },  // GMOUSE_MOVE  (0)
    {  WM_LBUTTONDOWN,   WM_RBUTTONDOWN,   WM_MBUTTONDOWN  },  // GMOUSE_DOWN  (1)
    {  WM_LBUTTONUP,     WM_RBUTTONUP,     WM_MBUTTONUP    },  // GMOUSE_UP    (2)
    {  WM_MOUSEMOVE,     WM_MOUSEMOVE,     WM_MOUSEMOVE    },  // GMOUSE_DRAG  (3)
    {  WM_MOUSEHOVER,    WM_MOUSEHOVER,    WM_MOUSEHOVER   },  // GMOUSE_HOVER (4)
    {  WM_MOUSEWHEEL,    WM_MOUSEWHEEL,    WM_MOUSEWHEEL   },  // GMOUSE_WHEEL (5)
};

////////////////////////////////////////////////////////
// HWNDHost

HRESULT HWNDHost::Create(UINT nCreate, UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDHost* phh = HNew<HWNDHost>();
    if (!phh)
        return E_OUTOFMEMORY;

    HRESULT hr = phh->Initialize(nCreate, nActive);
    if (FAILED(hr))
    {
        phh->Destroy();
        return hr;
    }

    *ppElement = phh;

    return S_OK;
}

HRESULT HWNDHost::Initialize(UINT nCreate, UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    SetActive(nActive);

    _nCreate = nCreate;
    _fHwndCreate = true;
    _hwndSink = NULL;
    _hwndCtrl = NULL;
    _pfnCtrlOrgProc = NULL;
    SetRectEmpty(&_rcBounds);
    _hFont = NULL;

    return S_OK;
}

HWND HWNDHost::CreateHWND(HWND hwndParent)
{
    UNREFERENCED_PARAMETER(hwndParent);

    DUIAssertForce("No HWND created by HWNDHost, must be overridden");

    return NULL;
}

HRESULT HWNDHost::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    HRESULT hr = S_OK;

    //
    // Initialize and validate the out parameter(s).
    //
    if (ppAccessible != NULL) {
        *ppAccessible = NULL;
    } else {
        return E_INVALIDARG;
    }

    //
    // If this element is not marked as accessible, refuse to give out its
    // IAccessible implementation!
    //
    if (GetAccessible() == false) {
        return E_FAIL;
    }

    //
    // Create an accessibility implementation connected to this element if we
    // haven't done so already.
    //
    if (_pDuiAccessible == NULL) {
        hr = HWNDHostAccessible::Create(this, &_pDuiAccessible);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //
    // Ask the existing accessibility implementation for a pointer to the
    // actual IAccessible interface.
    //
    hr = _pDuiAccessible->QueryInterface(__uuidof(IAccessible), (LPVOID*)ppAccessible);
    if (FAILED(hr)) {
        return hr;
    }

    DUIAssert(SUCCEEDED(hr) && _pDuiAccessible != NULL && *ppAccessible != NULL, "Accessibility is broken!");
    return hr;
}

////////////////////////////////////////////////////////
// System events

// When hosted to a native HWND, parent HWND hierarchy (sink and ctrl) to it.
// On first call, create hierarchy
void HWNDHost::OnHosted(Element* peNewHost)
{
    DWORD dwExStyle = 0;

    Element::OnHosted(peNewHost);

    DUIAssert(peNewHost->GetClassInfo()->IsSubclassOf(HWNDElement::Class), "HWNDHost only supports HWNDElement roots");

    HWND hwndRoot = ((HWNDElement*)peNewHost)->GetHWND();

    if (_fHwndCreate)
    {
        // Create hierarchy and attach subclass procs

        // Do not attempt creation on subsequent hosting calls
        _fHwndCreate = false;

        // Create control notification sink, register class if needed
        WNDCLASSEXW wcex;

        wcex.cbSize = sizeof(wcex);

        if (!GetClassInfoExW(GetModuleHandleW(NULL), L"CtrlNotifySink", &wcex))
        {
            ZeroMemory(&wcex, sizeof(wcex));

            wcex.cbSize = sizeof(WNDCLASSEX);
            wcex.style = CS_GLOBALCLASS;
            wcex.hInstance = GetModuleHandleW(NULL);
            wcex.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
            wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
            wcex.lpszClassName = L"CtrlNotifySink";
            wcex.lpfnWndProc = DefWindowProc;

            if (RegisterClassExW(&wcex) == 0)
                return;
        }

        // Create sink
        if (IsRTL())
            dwExStyle |= WS_EX_LAYOUTRTL;

        _hwndSink = CreateWindowExW(dwExStyle, L"CtrlNotifySink", NULL, WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,
                    0, 0, 0, 0, hwndRoot, NULL, NULL, NULL);
        DUIAssert(_hwndSink, "Adaptor notification sink creation failure.");
        if (!_hwndSink)
            return;

        // Subclass
        AttachWndProcW(_hwndSink, _SinkWndProc, this);

        // Create control
        _hwndCtrl = CreateHWND(_hwndSink);
        DUIAssert(_hwndCtrl, "Adaptor child creation failure.");
        if (!_hwndCtrl)
            return;

        // Get orginial window proc for forwarding messages
        _pfnCtrlOrgProc = (WNDPROC)GetWindowLongPtrW(_hwndCtrl, GWLP_WNDPROC);
        if (!_pfnCtrlOrgProc)
            return;

        // Subclass
        AttachWndProcW(_hwndCtrl, _CtrlWndProc, this);

        // Turn on style to start receiving adaptor messages
        SetGadgetStyle(GetDisplayNode(), GS_ADAPTOR, GS_ADAPTOR);

        // Synchronize the state of the HWND to the current state of Element
        SyncRect(SGR_MOVE | SGR_SIZE);
        SyncParent();
        SyncFont();
        SyncVisible();
        SyncText();
    }
    else if (_hwndSink)
    {
        // Parent HWND to native host
        SetParent(_hwndSink, hwndRoot);
    }
}

// Leaving native HWND container, parent sink to desktop
void HWNDHost::OnUnHosted(Element* peOldHost)
{
    Element::OnUnHosted(peOldHost);

    // Park HWND outside of root host
    if (_hwndSink)
    {
        DUIAssert(peOldHost->GetClassInfo()->IsSubclassOf(HWNDElement::Class), "HWNDHost only supports HWNDElement roots");

        // Hide window when unhosted, go to zero size
        SetRectEmpty(&_rcBounds);
        SetWindowPos(_hwndSink, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);

        SetParent(_hwndSink, NULL);
    }
}

void HWNDHost::OnDestroy()
{
    // Unlink Element and marked as destroyed
    Element::OnDestroy();

    // Destroy sink and control HWND.
    // Do not destroy control HWND directly since it may have been detached.
    // These windows may have already been destroyed by DestroyWindow. If so,
    // the handles will already be NULL.
    if (_hwndSink)
        DestroyWindow(_hwndSink);
        
    // Cleanup
    if (_hFont)
    {
        DeleteObject(_hFont);
        _hFont = NULL;
    }
}

void HWNDHost::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Match HWND control with changes in properties

    if (_hwndCtrl)
    {
        if (IsProp(FontFace) || IsProp(FontSize) || IsProp(FontWeight) || IsProp(FontStyle))
        {
            // Update font being used
            SyncFont();
        }
        else if (IsProp(Content))
        {
            // Relect content change into HWND control
            SyncText();
        }
        else if (IsProp(Visible))
        {
            // Update visible state
            SyncVisible();
        }
        if ((ppi == KeyFocusedProp) && (iIndex == PI_Local) && (pvNew->GetType() != DUIV_UNSET))
        {
            // Element received keyboard focus
            HWND hwndCurFocus = GetFocus();
            if (hwndCurFocus != _hwndCtrl)
            {
                // Control doesn't already have keyboard focus, start the cycle here
                SetFocus(_hwndCtrl);
            }

            // Base will set focus to the display node if needed
        }
    }

    // Call base
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

// All input messages to HWND control will be intercepted and mapped to DUser messages.
// These messages are then processed normally by the DirectUI event model. OnInput takes
// these messages and converts them back to HWND messages and forwards them to the HWND control
void HWNDHost::OnInput(InputEvent* pInput)
{
    // Map input events to Element to HWND control messages
    // When destroyed, HWND sink and control are gone. No need to do any mappings.
    // If detached, control original window proc is NULL.
    // All maps input messages are marked as handled and method will return
    if (pInput->nStage == GMF_DIRECT && _pfnCtrlOrgProc && !IsDestroyed())  // Handle when direct
    {
        switch (pInput->nDevice)
        {
        case GINPUT_MOUSE:
            {
                // When not forwarding mouse messages, no HWND mouse message conversion should take place
                if (!(_nCreate & HHC_NoMouseForward))
                {
                    MouseEvent* pme = (MouseEvent*)pInput;

                    // Check if can support mapping
                    if ((pme->nCode < GMOUSE_MOVE) || (pme->nCode > GMOUSE_WHEEL))
                    {
                        DUITrace("Gadget mouse message unsupported for HWND mapping: %d\n", pme->nCode);
                        break;
                    }

                    // Map button, (left shares none mapping)
                    int iButton;
                    if (pme->bButton == GBUTTON_NONE)
                        iButton = 0;
                    else
                        iButton = pme->bButton - 1;

                    if ((iButton < 0) || (iButton > 2)) 
                    {
                        DUITrace("Gadget mouse button unsupported for HWND mapping: %d\n", iButton);
                        break;
                    }

                    // Map message based on gadget message and button state
                    UINT nMsg = g_rgMouseMap[pme->nCode][iButton];

                    // Create lParam
                    // TODO markfi: subtract off inset of HWND due to border and padding
                    LPARAM lParam = (LPARAM)POINTTOPOINTS(pme->ptClientPxl);

                    // Create wParam
                    WPARAM wParam = NULL;
                    switch (pme->nCode)
                    {
                    case GMOUSE_DOWN:
                        // NOTE:  this is not actually truly accurate -- this 
                        // will cause down, up, down, dblclick instead of 
                        // down, up, dblclick, up
                        // I am leaving this as is for now -- if this causes problems, I'll fix it
                        //
                        // jeffbog
                        if (((MouseClickEvent*) pInput)->cClicks == 1) {
                            nMsg += (WM_LBUTTONDBLCLK - WM_LBUTTONDOWN);
                        }
                        // Fall through...

                    case GMOUSE_MOVE:
                    case GMOUSE_UP:
                    case GMOUSE_HOVER:
                        wParam = pme->nFlags;
                        break;

                    case GMOUSE_DRAG:
                        wParam = pme->nFlags;
                        // TODO: Need to compute the correct lParam
                        break;

                    case GMOUSE_WHEEL:
                        wParam = MAKEWPARAM((WORD)pme->nFlags, (WORD)(short)(((MouseWheelEvent*) pme)->sWheel));
                        break;
                    }

                    // Forward message
                    // Note: Mouse positions outside the control RECT is possible if using
                    // borders and/or padding
                    CallWindowProcW(_pfnCtrlOrgProc, _hwndCtrl, nMsg, wParam, lParam);

                    pInput->fHandled = true;
                }
            }
            return;

        case GINPUT_KEYBOARD:
            {
                // When not forwarding keyboard messages, no HWND keyboard message conversion should take place
                if (!(_nCreate & HHC_NoKeyboardForward))
                {
                    KeyboardEvent* pke = (KeyboardEvent*)pInput;

                    // Check if can support mapping
                    if ((pke->nCode < GKEY_DOWN) || (pke->nCode > GKEY_SYSCHAR))
                    {
                        DUITrace("Gadget keyboard message unsupported for HWND mapping: %d\n", pke->nCode);
                        break;
                    }

                    // Map message based on gadget keyboard message
                    UINT nMsg = 0;
                    switch (pke->nCode)
                    {
                    case GKEY_DOWN:
                        nMsg = WM_KEYDOWN;
                        break;

                    case GKEY_UP:
                        nMsg = WM_KEYUP;
                        break;

                    case GKEY_CHAR:
                        nMsg = WM_CHAR;
                        break;

                    case GKEY_SYSDOWN:
                        nMsg = WM_SYSKEYDOWN;
                        break;

                    case GKEY_SYSUP:
                        nMsg = WM_SYSKEYUP;
                        break;

                    case GKEY_SYSCHAR:
                        nMsg = WM_SYSCHAR;
                        break;
                    }

                    // Map wParam
                    WPARAM wParam = (WPARAM)pke->ch;

                    // Map lParam
                    LPARAM lParam = MAKELPARAM(pke->cRep, pke->wFlags);

                    // Forward message
                    CallWindowProcW(_pfnCtrlOrgProc, _hwndCtrl, nMsg, wParam, lParam);

                    pInput->fHandled = true;
                }
            }
            return;
        }
    }

    Element::OnInput(pInput);
}

////////////////////////////////////////////////////////
// Rendering
//
// Need to prevent the "content" from being displayed, since it is actually 
// being rendered by the HWND.

void HWNDHost::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcSkipContent);

    RECT rcSkipContent;
    Element::Paint(hDC, prcBounds, prcInvalid, prcSkipBorder, &rcSkipContent);

    // Paint control
    if (_hwndCtrl && (_nCreate & HHC_SyncPaint))
        UpdateWindow(_hwndCtrl);
}


#ifdef GADGET_ENABLE_GDIPLUS

void HWNDHost::Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prcSkipBorder, Gdiplus::RectF* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcSkipContent);

    Gdiplus::RectF rcSkipContent;
    Element::Paint(pgpgr, prcBounds, prcInvalid, prcSkipBorder, &rcSkipContent);

    // Paint control
    if (_hwndCtrl && (_nCreate & HHC_SyncPaint))
        UpdateWindow(_hwndCtrl);
}

#endif // GADGET_ENABLE_GDIPLUS


////////////////////////////////////////////////////////
// Notifications from control

bool HWNDHost::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    UNREFERENCED_PARAMETER(nMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(plRet);

    // Call subclassed window proc
    return false;
}

////////////////////////////////////////////////////////
// Message callback override

UINT HWNDHost::MessageCallback(GMSG* pmsg)
{
    if (pmsg->hgadMsg == GetDisplayNode())
    {
        switch (pmsg->nMsg)
        {
        case GM_SYNCADAPTOR:
            {
                if (_hwndSink && _hwndCtrl)
                {
                    GMSG_SYNCADAPTOR* pmsgS = (GMSG_SYNCADAPTOR*)pmsg;
                    switch (pmsgS->nCode)
                    {
                    case GSYNC_RECT:
                    case GSYNC_XFORM:
                        //DUITrace("Adaptor RECT sync: <%x>\n", this);
                        SyncRect(SGR_MOVE | SGR_SIZE);
                        return DU_S_PARTIAL;

                    case GSYNC_STYLE:
                        SyncStyle();
                        return DU_S_PARTIAL;

                    case GSYNC_PARENT:
                        SyncParent();
                        return DU_S_PARTIAL;
                    }
                }
            }
        }
    }

    return DU_S_NOTHANDLED;
}

BOOL HWNDHost::OnAdjustWindowSize(int x, int y, UINT uFlags)
{
    return SetWindowPos(_hwndCtrl, NULL, 0, 0, x, y, uFlags);
}

void HWNDHost::Detach()
{
    if (_hwndCtrl)
    {
        // Unsubclass control window
        DetachWndProc(_hwndCtrl, _CtrlWndProc, this);

        // Clear our hFont from the control
        if (_hFont)
            SendMessageW(_hwndCtrl, WM_SETFONT, (WPARAM)NULL, FALSE);

        // Act like it no longer exists
        _hwndCtrl = NULL;
        _pfnCtrlOrgProc = NULL;
    }
}

////////////////////////////////////////////////////////
// Match state of HWND control/sink to that of HWNDHost

void HWNDHost::SyncRect(UINT nChangeFlags, bool bForceSync)
{
    // Get size of gadget in container coordinates
    RECT rcConPxl;
    GetGadgetRect(GetDisplayNode(), &rcConPxl, SGR_CONTAINER);

    // See if rect really did change
    if (!EqualRect(&rcConPxl, &_rcBounds) || bForceSync)
    {
        if (!IsDestroyed() && GetVisible())
        {
            // Update bounds cache
            SetRect(&_rcBounds, rcConPxl.left, rcConPxl.top, rcConPxl.right, rcConPxl.bottom);

            // Map gadget flags to SWP flags
            UINT nSwpFlags = SWP_NOACTIVATE | SWP_NOZORDER;
            if (!(nChangeFlags & SGR_MOVE))
                nSwpFlags |= SWP_NOMOVE;

            if (!(nChangeFlags & SGR_SIZE))
                nSwpFlags |= SWP_NOSIZE;

            // Determine inset of sink and control based on border and padding of HWNDHost
            RECT rcSink = rcConPxl;

            Value* pvRect;

            const RECT* prc = GetBorderThickness(&pvRect);
            rcSink.left   += prc->left;
            rcSink.top    += prc->top;
            rcSink.right  -= prc->right;
            rcSink.bottom -= prc->bottom;
            pvRect->Release();

            prc = GetPadding(&pvRect);
            rcSink.left   += prc->left;
            rcSink.top    += prc->top;
            rcSink.right  -= prc->right;
            rcSink.bottom -= prc->bottom;
            pvRect->Release();

            // Bounds check
            if (rcSink.right < rcSink.left)
                rcSink.right = rcSink.left;

            if (rcSink.bottom < rcSink.top)
                rcSink.bottom = rcSink.top;

            SIZE sizeExt = { rcSink.right - rcSink.left, rcSink.bottom - rcSink.top };

            // Set sink HWND
            SetWindowPos(_hwndSink, NULL, rcSink.left, rcSink.top, sizeExt.cx, sizeExt.cy, nSwpFlags);

            // Set child HWND only if size changed
            if (nChangeFlags & SGR_SIZE)
            {
                nSwpFlags |= SWP_NOMOVE;
                OnAdjustWindowSize(sizeExt.cx, sizeExt.cy, nSwpFlags);
            }

            // Setup clipping region for sink/ctrl
            HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
            if (hrgn != NULL)
            {
                if (GetGadgetRgn(GetDisplayNode(), GRT_VISRGN, hrgn, 0))
                {
                    // Region is relative to container, offset for SetWindowRgn
                    // which requires the region relative to itself
                    // On success, system will own (and destroy) the region
                    OffsetRgn(hrgn, -rcConPxl.left, -rcConPxl.top);
                    if (!SetWindowRgn(_hwndSink, hrgn, TRUE))
                    {
                        DeleteObject(hrgn);
                    }
                }
                else
                {
                    DeleteObject(hrgn);
                }
            }
        }
    }
}

void HWNDHost::SyncParent()
{
    SyncRect(SGR_MOVE | SGR_SIZE);
}

void HWNDHost::SyncStyle()
{
    SyncRect(SGR_MOVE | SGR_SIZE);
}

void HWNDHost::SyncVisible()
{
    if (!IsDestroyed())
        ShowWindow(_hwndSink, GetVisible() ? SW_SHOW : SW_HIDE);
}

// Match HWND control's font to font properties of HWNDHost
void HWNDHost::SyncFont()
{
    if (!IsDestroyed())
    {
        Value* pvFFace;

        LPWSTR pszFamily = GetFontFace(&pvFFace);
        int dSize = GetFontSize();
        int dWeight = GetFontWeight();
        int dStyle = GetFontStyle();
        int dAngle = 0;

        if (_nCreate & HHC_CacheFont)
        {
            // Automatically cache font sent via WM_SETFONT

            // Destroy record first, if exists
            if (_hFont)
            {
                DeleteObject(_hFont);
                _hFont = NULL;
            }

            // Create new font
            LOGFONTW lf;
            ZeroMemory(&lf, sizeof(LOGFONT));

            lf.lfHeight = dSize;
            lf.lfWeight = dWeight;
            lf.lfItalic = (dStyle & FS_Italic) != 0;
            lf.lfUnderline = (dStyle & FS_Underline) != 0;
            lf.lfStrikeOut = (dStyle & FS_StrikeOut) != 0;
            lf.lfCharSet = DEFAULT_CHARSET;
            lf.lfQuality = DEFAULT_QUALITY;
            lf.lfEscapement = dAngle;
            lf.lfOrientation = dAngle;
            StringCbCopyW(lf.lfFaceName, sizeof(lf.lfFaceName), pszFamily);

            // Create
            _hFont = CreateFontIndirectW(&lf);

            pvFFace->Release();

            // Send to control
            SendMessageW(_hwndCtrl, WM_SETFONT, (WPARAM)_hFont, TRUE);
        }
        else
        {
            // No font caching, WM_SETFONT handled expected to cache font

            FontCache* pfc = GetFontCache();
            if (pfc)
            {
                HFONT hFont = pfc->CheckOutFont(pszFamily, dSize, dWeight, dStyle, dAngle);
    
                SendMessageW(_hwndCtrl, WM_SETFONT, (WPARAM)hFont, TRUE);

                pfc->CheckInFont();
            }
        }
    }
}

// Match HWND control's text to content property of HWNDHost
void HWNDHost::SyncText()
{
    if (!IsDestroyed() && (_nCreate & HHC_SyncText))
    {
        // Hosted HWND content
        int dLen = GetWindowTextLengthW(_hwndCtrl) + 1;  // Including NULL terminator
        LPWSTR pszHWND = (LPWSTR)HAlloc(dLen * sizeof(WCHAR));
        if (pszHWND)
        {
            // HWND content
            GetWindowTextW(_hwndCtrl, pszHWND, dLen);

            // New Element content
            Value* pvNew;
            LPCWSTR pszNew = GetContentString(&pvNew);
            if (!pszNew)
                pszNew = L"";  // Convert NULL pointer to NULL content

            // Compare and update if different
            if (wcscmp(pszHWND, pszNew))
                SetWindowTextW(_hwndCtrl, pszNew);

            pvNew->Release();

            HFree(pszHWND);
        }
    }
}

////////////////////////////////////////////////////////
// Sink and control subclass procs

// Return value is whether to call overridden window proc
BOOL CALLBACK HWNDHost::_SinkWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    UNREFERENCED_PARAMETER(hwnd);

    HWNDHost* phh = (HWNDHost*)pThis;

    switch (nMsg)
    {
    case WM_COMMAND:
    case WM_NOTIFY:

        // Fire HWNDHost system event (direct only)
        return (phh->OnNotify(nMsg, wParam, lParam, plRet)) ? true : false;
    
    case WM_GETOBJECT:
        //
        // Refuse to give out any accessibility information for our sink window.
        //
        *plRet = 0;
        return TRUE;

    case WM_DESTROY:
        phh->_hwndSink = NULL;
        break;

    }

    return FALSE;  // Pass to subclassed window proc
}

// Intercept all messages to HWND control and convert them to gadget messages. These messages
// will surface as DirectUI events and will route and bubble. Upon reaching the HWNDHost,
// it will be converted back to a HWND message and conditionally sent

// Return value is whether to call overridden window proc (FALSE = call subclassed window proc)
BOOL CALLBACK HWNDHost::_CtrlWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    HWNDHost* phh = (HWNDHost*)pThis;

    switch (nMsg)
    {
    // Keyboard input, convert. Will be routed and bubbled
    case WM_KEYUP:
    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    case WM_SYSCHAR:
        if (!(phh->_nCreate & HHC_NoKeyboardForward))
            return ForwardGadgetMessage(phh->GetDisplayNode(), nMsg, wParam, lParam, plRet);

        break;

    // Mouse input, convert. Will be routed and bubbled
    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MBUTTONDBLCLK:
    case WM_MOUSEHOVER:
    case WM_MOUSEWHEEL:
    {
        if (!(phh->_nCreate & HHC_NoMouseForward))
        {
            // Convert mouse messages so coordinates are relative to root
            HWND hwndRoot = ::GetParent(phh->_hwndSink);

            POINT ptRoot;
            ptRoot.x = GET_X_LPARAM(lParam);
            ptRoot.y = GET_Y_LPARAM(lParam);
            MapWindowPoints(hwnd, hwndRoot, &ptRoot, 1);

            LPARAM lParamNew = (LPARAM)POINTTOPOINTS(ptRoot);

            return ForwardGadgetMessage(phh->GetDisplayNode(), nMsg, wParam, lParamNew, plRet);
        }

        break;
    }

    // Map focus
    case WM_SETFOCUS:
        //DUITrace("HWNDHost, SetFocus()\n");
        if (!(phh->_nCreate & HHC_NoKeyboardForward))
            phh->SetKeyFocus();
        break;

    // Map lost focus
    case WM_KILLFOCUS:
        if (!(phh->_nCreate & HHC_NoKeyboardForward))
            ForwardGadgetMessage(phh->GetDisplayNode(), nMsg, wParam, lParam, plRet);
        break;

    case WM_GETOBJECT:
        {
            //
            // Make sure COM has been initialized on this thread!
            //
            ElTls * pet = (ElTls*) TlsGetValue(g_dwElSlot);
            DUIAssert(pet != NULL, "This is not a DUI thread!");
            if (pet == NULL) {
                *plRet = 0;
                return TRUE;
            }
            if (pet->fCoInitialized == false) {
                CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
                pet->fCoInitialized = true;
            }
    
            if (((DWORD)lParam) == OBJID_WINDOW) {
                //
                // The object ID is refering to ourselves.  Since we contain
                // an actually HWND, we want the system to provide most of
                // the IAccessible implementation.  However, we need to
                // do some special stuff, so we have to return our own
                // implementation wrapper.
                //
                IAccessible * pAccessible = NULL;
                HRESULT hr =  phh->GetAccessibleImpl(&pAccessible);
                if (SUCCEEDED(hr)) {
                    *plRet = LresultFromObject(__uuidof(IAccessible), wParam, pAccessible);
                    pAccessible->Release();
    
                    //
                    // We processed the message.  Don't pass to the subclassed window proc.
                    //
                    return TRUE;
                }
            } else {
                //
                // This is one of the "standard" object identifiers, such as:
                //
                // OBJID_ALERT 
                // OBJID_CARET 
                // OBJID_CLIENT 
                // OBJID_CURSOR 
                // OBJID_HSCROLL 
                // OBJID_MENU 
                // OBJID_SIZEGRIP 
                // OBJID_SOUND 
                // OBJID_SYSMENU 
                // OBJID_TITLEBAR 
                // OBJID_VSCROLL 
                //
                // Or it could be a private identifier of the control. 
                //
                // Just pass this on to the subclassed window proc.
                //
            }
        }
        break;

    case WM_DESTROY:
        phh->_hwndCtrl = NULL;
        phh->_pfnCtrlOrgProc = NULL;
        break;
        
    }

    return FALSE;  // Pass to subclassed window proc
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDHost::Class = NULL;

HRESULT HWNDHost::Register()
{
    return ClassInfo<HWNDHost,Element>::Register(L"HWNDHost", NULL, 0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\combobox.cpp ===
// Combobox.cpp
//

#include "stdafx.h"
#include "control.h"

#include "duicombobox.h"

namespace DirectUI
{

// Internal helper
extern inline void _FireSelectionEvent(Combobox* peTarget, int iOld, int iNew);

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Combobox, SelectionChange)  // SelectionChangeEvent struct


HRESULT Combobox::Create(UINT nActive, Element** ppElement)
{
    *ppElement = NULL;

    Combobox* pe = HNew<Combobox>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nActive);
    if (FAILED(hr))
    {
        pe->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = pe;

    return S_OK;
}

HWND Combobox::CreateHWND(HWND hwndParent)
{
    int dwStyle = WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST;

    HWND hwndCombo = CreateWindowExW(0, L"ComboBox", NULL, dwStyle, 0, 0, 0, 0, hwndParent, (HMENU)1, NULL, NULL);

    return hwndCombo;
}

bool Combobox::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    switch (nMsg)
    {
    case WM_COMMAND:
        if (HIWORD(wParam) == CBN_SELENDOK )
        {
            HWND hwndCtrl = GetHWND();
            if (hwndCtrl)
                SetSelection((int) SendMessageW(hwndCtrl, CB_GETCURSEL, 0, 0));
            return true;
        }
        break;
    }

    return HWNDHost::OnNotify(nMsg, wParam, lParam, plRet);
}

void _FireSelectionEvent(Combobox* peTarget, int iOld, int iNew)
{

    // Fire selection event
    SelectionIndexChangeEvent sice;
    sice.uidType = Combobox::SelectionChange;
    sice.iOld = iOld;
    sice.iNew = iNew;

    peTarget->FireEvent(&sice);  // Will route and bubble
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
// Events passed to the base class will be mappend and sent to the HWND control
void Combobox::OnInput(InputEvent* pie)
{
    // Handle only when direct
    if (pie->nStage == GMF_DIRECT)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                //DUITrace("KeyboardEvent <%x>: %d[%d]\n", this, pke->ch, pke->nCode);

                if (pke->nCode == GKEY_DOWN || pke->nCode == GKEY_UP)  // Virtual keys
                {
                    switch (pke->ch)
                    {
                    case VK_TAB:     // Has GKEY_CHAR equivalent
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;
                      }
                }
                else if (pke->nCode == GKEY_CHAR) // Characters
                {
                    switch (pke->ch)
                    {
                    case 9:                 // TAB
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;
                    }
                }
            }
            break;
        }
    }

    // Forward message to the HWND control
    HWNDHost::OnInput(pie);
}

BOOL Combobox::OnAdjustWindowSize(int x, int y, UINT uFlags)
{
    // Size of control is based on full expanded height. The actual height of
    // the non-dropdown is controled by the Combobox HWND

    HWND hwndCtrl = GetHWND();
    if (hwndCtrl)
    {
        int iCount = (int)SendMessageW(hwndCtrl, CB_GETCOUNT, 0, 0);
        int iHeight = (int)SendMessageW(hwndCtrl, CB_GETITEMHEIGHT, 0, 0);
        int iEditHeight = (int)SendMessageW(hwndCtrl, CB_GETITEMHEIGHT, (WPARAM)-1, 0);
        
        if(iCount != CB_ERR && iHeight!= CB_ERR && iEditHeight != CB_ERR)
        {
            y += (iCount * iHeight) + iEditHeight;
        }
    }
    
    return HWNDHost::OnAdjustWindowSize(x, y, uFlags);
}

void Combobox::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selection))
    {
        // Setup SelectionChange event
        SelectionIndexChangeEvent sce;
        sce.uidType = SelectionChange;
        sce.iOld = pvOld->GetInt();
        sce.iNew = pvNew->GetInt();
        HWND hwndCtrl = GetHWND();
        if (hwndCtrl)
            SendMessageW(hwndCtrl, CB_SETCURSEL, (WPARAM)sce.iNew, 0);

        // Fire bubbling event
        //DUITrace("SelectionChange! <%x>, O:%x N:%x\n", this, sce.peOld, sce.peNew);

        FireEvent(&sce);  // Will route and bubble
    }

    HWNDHost::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

int Combobox::AddString(LPCWSTR lpszString)
{
    HWND hwndCtrl = GetHWND();
    int iRet = CB_ERR;
    if (hwndCtrl)
    {
        iRet =  (int)SendMessageW(hwndCtrl, CB_ADDSTRING, 0, (LPARAM)lpszString);
        if(iRet != CB_ERR)
        {
            SyncRect(SGR_MOVE | SGR_SIZE, true);
        }
    }
    
    return iRet;
}

////////////////////////////////////////////////////////
// Rendering

SIZE Combobox::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(psrf);

    SIZE sizeDS = { dConstW, dConstH };

    // Combobox HWND height isn't set by SetWindowPos. Rather, the entire height (including
    // the drop down list) is controlled this way. The Combobox HWND sizes itself, we
    // can't control it. The Combobox Element content size is determined by querying
    // the Combobox HWND. The width will always be the constraint passed in.

    HWND hwndCtrl = GetHWND();
    if (hwndCtrl)
    {
        int iEditHeight = (int)SendMessageW(hwndCtrl, CB_GETITEMHEIGHT, (WPARAM)-1, 0);
        int iBorderSize = GetSystemMetrics(SM_CYEDGE) + 1;

        sizeDS.cy = iEditHeight + (2 * iBorderSize);
    }

    // Size returned must not be greater than constraints. -1 constraint is "auto"
    // Returned size must be >= 0

    if (sizeDS.cy > dConstH)
        sizeDS.cy = dConstH;

    return sizeDS;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Selection property
static int vvSelection[] = { DUIV_INT, -1 }; StaticValue(svDefaultSelection, DUIV_INT, -1);
static PropertyInfo impSelectionProp = { L"Selection", PF_Normal, 0, vvSelection, NULL, (Value*)&svDefaultSelection };
PropertyInfo* Combobox::SelectionProp = &impSelectionProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Combobox::SelectionProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Combobox::Class = NULL;

HRESULT Combobox::Register()
{
    return ClassInfo<Combobox,HWNDHost>::Register(L"Combobox", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\edit.cpp ===
// Edit.cpp
//

#include "stdafx.h"
#include "control.h"

#include "duiedit.h"

namespace DirectUI
{

// Internal helper
extern inline void _FireEnterEvent(Edit* peTarget);

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Edit, Enter)  // EditEnterEvent struct

////////////////////////////////////////////////////////
// Edit

HRESULT Edit::Create(UINT nActive, Element** ppElement)
{
    *ppElement = NULL;

    Edit* pe = HNew<Edit>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nActive);
    if (FAILED(hr))
    {
        pe->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = pe;

    return S_OK;
}

HWND Edit::CreateHWND(HWND hwndParent)
{
    int dwStyle = WS_CHILD | WS_VISIBLE | ES_PASSWORD | ES_AUTOHSCROLL;

    // Extra styles for multiline
    if (GetMultiline())
        dwStyle |= ES_MULTILINE | ES_WANTRETURN | WS_VSCROLL | WS_HSCROLL;

    HWND hwndEdit = CreateWindowExW(0, L"edit", NULL, dwStyle, 0, 0, 0, 0, hwndParent, (HMENU)1, NULL, NULL);

    if (hwndEdit)
        SendMessageW(hwndEdit, EM_SETPASSWORDCHAR, GetPasswordCharacter(), 0);

    return hwndEdit;
}

////////////////////////////////////////////////////////
// System events

void Edit::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(PasswordCharacter))
    {
        HWND hwndCtrl = GetHWND();
        if (hwndCtrl)
            SendMessageW(hwndCtrl, EM_SETPASSWORDCHAR, pvNew->GetInt(), 0);
    }
    else if (IsProp(Multiline))
    {
        if (GetHWND())
        {
            DUIAssertForce("Dynamic set of multiline for Edit controls not yet implemented");
        }
    }

    // Call base
    HWNDHost::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

HRESULT Edit::SetDirty(bool fDirty)
{
    HWND hwndCtrl = GetHWND();

    if (hwndCtrl)
    {
        bool fOld = (SendMessage(hwndCtrl, EM_GETMODIFY, 0, 0) != 0);
        if (fOld != fDirty)
            SendMessageW(hwndCtrl, EM_SETMODIFY, fDirty, 0);
    }

    // this actually has a return in it -- so no need to specify *return* here
    DUIQuickSetter(CreateBool(fDirty), Dirty);
}

////////////////////////////////////////////////////////
// Control notifications

bool Edit::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    switch (nMsg)
    {
    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            // Reflect changes to HWND edit control text in Content property

            HWND hwndCtrl = GetHWND();
            DUIAssert(hwndCtrl, "Invalid hosted HWND control: NULL");

            int dLen = GetWindowTextLengthW(hwndCtrl);
            if (dLen)
            {
                // Have text in HWND, include null terminator
                dLen++;

                LPWSTR pszNew = (LPWSTR)HAlloc(dLen * sizeof(WCHAR));
                if (pszNew)
                {
                    GetWindowTextW(hwndCtrl, pszNew, dLen);
                    SetContentString(pszNew);
                    HFree(pszNew);
                }
            }
            else
            {
                // No text in HWND, remove content in Element
                RemoveLocalValue(ContentProp);
            }

            if (!GetDirty())
                SetDirty(SendMessage(hwndCtrl, EM_GETMODIFY, 0, 0) != 0);

            // Notification handled
            return true;
        }
        break;
    }

    return HWNDHost::OnNotify(nMsg, wParam, lParam, plRet);
}

UINT Edit::MessageCallback(GMSG* pGMsg)
{
    return HWNDHost::MessageCallback(pGMsg);
}

void _FireEnterEvent(Edit* peTarget)
{
    //DUITrace("Enter! <%x>\n", peTarget);

    // Fire click event
    EditEnterEvent eee;
    eee.uidType = Edit::Enter;

    peTarget->FireEvent(&eee);  // Will route and bubble
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
// Events passed to the base class will be mappend and sent to the HWND control
void Edit::OnInput(InputEvent* pie)
{
    // Handle only when direct
    if (pie->nStage == GMF_DIRECT)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                //DUITrace("KeyboardEvent <%x>: %d[%d]\n", this, pke->ch, pke->nCode);

                if (pke->nCode == GKEY_DOWN || pke->nCode == GKEY_UP)  // Virtual keys
                {
                    switch (pke->ch)
                    {
                    // Never forward
                    case VK_ESCAPE:  // Has GKEY_CHAR equivalent
                    case VK_F1:
                    case VK_F2:
                    case VK_F3:
                    case VK_F4:
                    case VK_F5:
                    case VK_F6:
                    case VK_F7:
                    case VK_F8:
                    case VK_F9:
                    case VK_F10:
                    case VK_F11:
                    case VK_F12:
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;
        
                    // Do not forward for single line edit
                    case VK_DOWN:     
                    case VK_UP:
                    case VK_RETURN:  // Has GKEY_CHAR equivalent
                    case VK_TAB:     // Has GKEY_CHAR equivalent
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        if (!GetMultiline())
                        {
                            Element::OnInput(pie);
                            return;
                        }
                        break;
                    }
                }
                else if (pke->nCode == GKEY_CHAR) // Characters
                {
                    switch (pke->ch)
                    {
                    // Never forward
                    case 27:                // ESC
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;

                    // Do not forward for single line edit
                    case 13:                // RETURN
                        // Fire ENTER event
                        _FireEnterEvent(this);

                        pie->fHandled = true;

                        if (!GetMultiline())  // Is multiline, pass to control
                            return;
                    
                        break;

                    // Do not forward for single line edit
                    case 9:                 // TAB
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        if (!GetMultiline())
                        {
                            Element::OnInput(pie);
                            return;
                        }
                        break;
                    }
                }
            }
            break;
        }
    }

    // Forward message to the HWND control, input event will be marked as handled.
    // It will not bubble to parent
    HWNDHost::OnInput(pie);
}

////////////////////////////////////////////////////////
// Rendering

SIZE Edit::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(psrf);

    // Size returned must not be greater than constraints. -1 constraint is "auto"
    // Returned size must be >= 0

    SIZE sizeDS = { dConstW, abs(GetFontSize()) };  // Font size may be negative

    if (sizeDS.cy > dConstH)
        sizeDS.cy = dConstH;

    return sizeDS;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Multiline property
static int vvMultiline[] = { DUIV_BOOL, -1 };
static PropertyInfo impMultilineProp = { L"Multiline", PF_Normal, 0, vvMultiline, NULL, Value::pvBoolFalse };
PropertyInfo* Edit::MultilineProp = &impMultilineProp;

// Password Character property
static int vvPasswordCharacter[] = { DUIV_INT, -1 };
static PropertyInfo impPasswordCharacterProp = { L"PasswordCharacter", PF_Normal|PF_Cascade, 0, vvPasswordCharacter, NULL, Value::pvIntZero };
PropertyInfo* Edit::PasswordCharacterProp = &impPasswordCharacterProp;

// Dirty property
static int vvDirty[] = { DUIV_BOOL, -1 };
static PropertyInfo impDirtyProp = { L"Dirty", PF_Normal, 0, vvDirty, NULL, Value::pvBoolFalse };
PropertyInfo* Edit::DirtyProp = &impDirtyProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Edit::MultilineProp,
                                Edit::PasswordCharacterProp,
                                Edit::DirtyProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Edit::Class = NULL;

HRESULT Edit::Register()
{
    return ClassInfo<Edit,HWNDHost>::Register(L"Edit", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_CONTROL_PUBLISHED_H_INCLUDED
#define DUI_CONTROL_PUBLISHED_H_INCLUDED

#include "duibutton.h"
#include "duiedit.h"
#include "duicombobox.h"
#include "duinative.h"
#include "duiprogress.h"
#include "duirefpointelement.h"
#include "duirepeatbutton.h"
#include "duiscrollbar.h"
#include "duiscrollviewer.h"
#include "duiselector.h"
#include "duithumb.h"
#include "duiviewer.h"

#endif // DUI_CONTROL_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\native.cpp ===
/*
 * Native
 */

#include "stdafx.h"
#include "control.h"

#include "duinative.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Top-level native HWND host of HWNDElement

HRESULT NativeHWNDHost::Create(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions, OUT NativeHWNDHost** ppHost)
{
    *ppHost = NULL;

    NativeHWNDHost* pnhh = HNew<NativeHWNDHost>();
    if (!pnhh)
        return E_OUTOFMEMORY;

    HRESULT hr = pnhh->Initialize(pszTitle, hWndParent, hIcon, dX, dY, dWidth, dHeight, iExStyle, iStyle, nOptions);
    if (FAILED(hr))
    {
        pnhh->Destroy();
        return hr;
    }

    *ppHost = pnhh;

    return S_OK;
}

HRESULT NativeHWNDHost::Initialize(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions)
{
    _pe = NULL;
    _hWnd = NULL;

    _nOptions = nOptions;

    // Make sure window class is registered
    WNDCLASSEXW wcex;

    // Register host window class, if needed
    wcex.cbSize = sizeof(wcex);

    if (!GetClassInfoExW(GetModuleHandleW(NULL), L"NativeHWNDHost", &wcex))
    {
        ZeroMemory(&wcex, sizeof(wcex));

        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_GLOBALCLASS;
        wcex.hInstance = GetModuleHandleW(NULL);
        wcex.hIcon = hIcon;
        wcex.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
        wcex.hbrBackground = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
        wcex.lpszClassName = L"NativeHWNDHost";
        wcex.lpfnWndProc = DefWindowProcW;

        if (RegisterClassExW(&wcex) == 0)
            return DUI_E_USERFAILURE;
    }

    _hWnd = CreateWindowExW(iExStyle, L"NativeHWNDHost", pszTitle, iStyle | WS_CLIPCHILDREN, dX, dY, dWidth, dHeight,
                            hWndParent, 0, NULL, NULL);

    if (!_hWnd)
        return DUI_E_USERFAILURE;

    SetWindowLongPtrW(_hWnd, GWLP_WNDPROC, (LONG_PTR)NativeHWNDHost::WndProc);
    SetWindowLongPtrW(_hWnd, GWLP_USERDATA, (LONG_PTR)this);

    // If top-level, initialize keyboard cue state, start all hidden
    if (!hWndParent)
        SendMessage(_hWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);

    return S_OK;
}

void NativeHWNDHost::Host(Element* pe)
{
    DUIAssert(!_pe && _hWnd, "Already hosting an Element");
    DUIAssert(pe->GetClassInfo()->IsSubclassOf(HWNDElement::Class), "NativeHWNDHost must only host HWNDElements");

    _pe = pe;

    //
    // Mirror NativeHWNDHost window without mirroring any of its children.
    //
    if (pe->IsRTL())
        SetWindowLong(_hWnd, GWL_EXSTYLE, GetWindowLong(_hWnd, GWL_EXSTYLE) | WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT);
    
    RECT rc;
    GetClientRect(_hWnd, &rc);

    if(!(_nOptions & NHHO_HostControlsSize))
    {
        Element::StartDefer();
        _pe->SetWidth(rc.right - rc.left);
        _pe->SetHeight(rc.bottom - rc.top);
        Element::EndDefer();
    }
    else if(pe->GetClassInfo()->IsSubclassOf(HWNDElement::Class))
    {
        // [msadek] , We want the host window to copy those attributes.
        // and to force size update.
        ((HWNDElement*)pe)->SetParentSizeControl(true);
        if((_nOptions & NHHO_ScreenCenter))
        {
            ((HWNDElement*)pe)->SetScreenCenter(true);        
        }
        ((HWNDElement*)pe)->OnGroupChanged(PG_AffectsBounds , true);
    }
}

LRESULT NativeHWNDHost::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SIZE:
        {
            if (!(GetWindowLongPtrW(hWnd, GWL_STYLE) & WS_MINIMIZE))
            {
                NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
                if (pnhh)
                {
                    Element* pe = pnhh->GetElement();
                    if (pe)
                    {
                        DisableAnimations();
                        if(!(pnhh->_nOptions & NHHO_HostControlsSize))
                        {
                            Element::StartDefer();
                            pe->SetWidth(LOWORD(lParam));
                            pe->SetHeight(HIWORD(lParam));
                            Element::EndDefer();
                        }    
                        EnableAnimations();
                    }
                }
            }
        }
        break;

    case WM_CLOSE:
        {
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                if (!(pnhh->_nOptions & NHHO_IgnoreClose))
                    pnhh->DestroyWindow();  // Post an async-destroy

                // Do not destroy immediately
                return 0;
            }
        }
        break;

    case WM_DESTROY:
        {
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                if(!(pnhh->_nOptions & NHHO_NoSendQuitMessage))
                {
                    PostQuitMessage(0);
                }
                pnhh->_hWnd = NULL;

                if (pnhh->_nOptions & NHHO_DeleteOnHWNDDestroy)
                {
                    // Auto destroy instance of object
                    SetWindowLongPtrW(hWnd, GWLP_USERDATA, NULL);
                    pnhh->Destroy();
                }
            }    
        }
        break;

    case WM_SETFOCUS:
        {
            // Push focus to HWNDElement (won't set gadget focus to the HWNDElement, but
            // will push focus to the previous gadget with focus)
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                HWNDElement* phe = (HWNDElement*)pnhh->GetElement();
                if (phe && phe->GetHWND() && phe->CanSetFocus())
                    SetFocus(phe->GetHWND());
            }
        }
        break;

    case WM_SYSCOMMAND:
        // If ALT was pressed, show all keyboard cues
        if (wParam == SC_KEYMENU)
            SendMessage(hWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);
        break;

    // Messages to top-level window only, forward
    case WM_PALETTECHANGED:
    case WM_QUERYNEWPALETTE:
    case WM_DISPLAYCHANGE:
    case WM_SETTINGCHANGE:
    case WM_THEMECHANGED:
        {
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                HWNDElement* phe = (HWNDElement*)pnhh->GetElement();
                if (phe)
                    return SendMessageW(phe->GetHWND(), uMsg, wParam, lParam);
            }
        }
        break;

    case NHHM_ASYNCDESTROY:
        ::DestroyWindow(hWnd);
        return 0;
    }

    return DefWindowProcW(hWnd, uMsg, wParam, lParam);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\progress.cpp ===
/*
 * Progress
 */

#include "stdafx.h"
#include "control.h"

#include "duiprogress.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Progress

HRESULT Progress::Create(Element** ppElement)
{
    *ppElement = NULL;

    Progress* pp = HNew<Progress>();
    if (!pp)
        return E_OUTOFMEMORY;

    HRESULT hr = pp->Initialize();
    if (FAILED(hr))
    {
        pp->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = pp;

    return S_OK;
}

////////////////////////////////////////////////////////
// Rendering overrides

void Progress::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcSkipContent);
    UNREFERENCED_PARAMETER(prcSkipBorder);

    // Paint all less content
    RECT rcContent;
    Element::Paint(hDC, prcBounds, prcInvalid, NULL, &rcContent);

    // Render progress content

    // Compute content bounds
    int dBlock = GetMaximum() - GetMinimum();
    if (dBlock > 0)
        dBlock = (rcContent.right - rcContent.left) / dBlock;

    if (IsRTL())
        rcContent.left = rcContent.right - (GetPosition() * dBlock);
    else
        rcContent.right = rcContent.left + (GetPosition() * dBlock);

    // Use foreground brush as bar fill
    HBRUSH hb = NULL;
    bool bDelete = true;
    BYTE dAlpha = 255;  // Opaque

    Value* pv = GetValue(ForegroundProp, PI_Specified); 
    switch (pv->GetType())
    {
    case DUIV_INT:
        bDelete = false;
        hb = GetStdColorBrushI(pv->GetInt());
        break;

    case DUIV_FILL:  // Only non-standard colors can have alpha value, only solid colors supported
        {
            const Fill* pf = pv->GetFill();
            dAlpha = GetAValue(pf->ref.cr);
            if (dAlpha == 0)  // Transparent
                bDelete = false;
            else
                hb = CreateSolidBrush(~(255 << 24) & pf->ref.cr);
        }
        break;

    case DUIV_GRAPHIC:  // Graphic background transparent color fills and per-pixel alpha unsupported
        {
            Graphic* pg = pv->GetGraphic();
            if (pg->BlendMode.dMode == GRAPHIC_AlphaConst)
                dAlpha = pg->BlendMode.dAlpha;
            if (dAlpha == 0)  // Transparent
                bDelete = false;
            else
                hb = CreatePatternBrush(GethBitmap(pv, IsRTL()));
        }
        break;
    }
    pv->Release();

    // Fill
    if (dAlpha)
    {
        if (dAlpha == 255)  // Normal fill for opaque
            FillRect(hDC, &rcContent, hb);
        else
            UtilDrawBlendRect(hDC, &rcContent, hb, dAlpha, 0, 0);
    }

    // Cleanup
    if (hb && bDelete)
        DeleteObject(hb);
}

SIZE Progress::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(dConstW);
    UNREFERENCED_PARAMETER(dConstH);
    UNREFERENCED_PARAMETER(psrf);

    // No content size
    SIZE size = { 0, 0 };
    return size;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Position property
static int vvPosition[] = { DUIV_INT, -1 };
static PropertyInfo impPositionProp = { L"Position", PF_Normal, PG_AffectsDisplay, vvPosition, NULL, Value::pvIntZero };
PropertyInfo* Progress::PositionProp = &impPositionProp;

// Minimum property
static int vvMinimum[] = { DUIV_INT, -1 }; 
static PropertyInfo impMinimumProp = { L"Minimum", PF_Normal, PG_AffectsDisplay, vvMinimum, NULL, Value::pvIntZero };
PropertyInfo* Progress::MinimumProp = &impMinimumProp;

// Maximum property
static int vvMaximum[] = { DUIV_INT, -1 }; StaticValue(svDefaultMaximum, DUIV_INT, 1000);
static PropertyInfo impMaximumProp = { L"Maximum", PF_Normal, PG_AffectsDisplay, vvMaximum, NULL, (Value*)&svDefaultMaximum };
PropertyInfo* Progress::MaximumProp = &impMaximumProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Progress::PositionProp,
                                Progress::MinimumProp,
                                Progress::MaximumProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Progress::Class = NULL;

HRESULT Progress::Register()
{
    return ClassInfo<Progress,Element>::Register(L"Progress", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\refpointelement.cpp ===
/*
 * RefPointElement
 */

#include "stdafx.h"
#include "control.h"

#include "duirefpointelement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// RefPointElement

HRESULT RefPointElement::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    RefPointElement* prpe = HNew<RefPointElement>();
    if (!prpe)
        return E_OUTOFMEMORY;

    HRESULT hr = prpe->Initialize(nActive);
    if (FAILED(hr))
    {
        prpe->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = prpe;

    return S_OK;
}

HRESULT RefPointElement::Initialize(UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    SetActive(nActive);

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

void RefPointElement::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Extent) || IsProp(ReferencePoint))
    {
        // Compute actual reference point
        Value* pvRef;
        const POINT* ppt = GetReferencePoint(&pvRef);

        Value* pvActRef;

        if (ppt)
        {
            // Reflect reference point
            pvActRef = pvRef;
        }
        else
        {
            // Default to center
            Value* pvExt;
            const SIZE* psizeExt = GetExtent(&pvExt);

            pvActRef = Value::CreatePoint(psizeExt->cx / 2, psizeExt->cy / 2);

            pvExt->Release();
        }

        // Set
        _SetValue(ActualReferencePointProp, PI_Local, pvActRef);

        if (!ppt)
            pvActRef->Release();

        pvRef->Release();
    }

    // Call base implementation
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

////////////////////////////////////////////////////////
// Reference point helpers

// Search for a reference point in a tree
RefPointElement* RefPointElement::Locate(Element* pe)
{
    DUIAssert(pe, "Illegal arguments");

    RefPointElement* peFound = NULL;
    Value* pv;

    // If this is an reference point Element, return
    if (pe->GetClassInfo()->IsSubclassOf(RefPointElement::Class))
        return (RefPointElement*)pe;

    // Search, DFS
    ElementList* peList = pe->GetChildren(&pv);
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peFound = Locate(peList->GetItem(i));
            if (peFound)
                break;
        }
    }
    pv->Release();

    return peFound;
}

Element* RefPointElement::FindRefPoint(Element* pe, POINT* ppt)
{
    DUIAssert(pe && ppt, "Illegal arguments");

    RefPointElement* perFound = Locate(pe);

    if (perFound)
    {
        Value* pvPoint;

        const POINT* pptRef = perFound->GetActualReferencePoint(&pvPoint);
        pe->MapElementPoint(perFound, pptRef, ppt);

        pvPoint->Release();
    }

    return perFound;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// ReferencePoint property
static int vvReferencePoint[] = { DUIV_POINT, -1 };
static PropertyInfo impReferencePointProp = { L"ReferencePoint", PF_LocalOnly, 0, vvReferencePoint, NULL, Value::pvUnset };
PropertyInfo* RefPointElement::ReferencePointProp = &impReferencePointProp;

// ActualReferencePoint property
static int vvActualReferencePoint[] = { DUIV_POINT, -1 };
static PropertyInfo impActualReferencePointProp = { L"ActualReferencePoint", PF_Normal|PF_ReadOnly, PG_AffectsParentLayout, vvReferencePoint, NULL, Value::pvPointZero };
PropertyInfo* RefPointElement::ActualReferencePointProp = &impActualReferencePointProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                  RefPointElement::ReferencePointProp,
                                  RefPointElement::ActualReferencePointProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* RefPointElement::Class = NULL;

HRESULT RefPointElement::Register()
{
    return ClassInfo<RefPointElement,Element>::Register(L"RefPointElement", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\repeatbutton.cpp ===
/*
 * RepeatButton
 */

#include "stdafx.h"
#include "control.h"

#include "duirepeatbutton.h"

#include "Behavior.h"

namespace DirectUI
{

// Inernal helper (defined in Button)
extern inline void _FireClickEvent(Button* peTarget, ClickInfo* pci);

////////////////////////////////////////////////////////
// Event types

// Fires 'ButtonClickEvent'

////////////////////////////////////////////////////////
// RepeatButton

HRESULT RepeatButton::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    RepeatButton* prb = HNew<RepeatButton>();
    if (!prb)
        return E_OUTOFMEMORY;

    HRESULT hr = prb->Initialize(nActive);
    if (FAILED(hr))
    {
        prb->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = prb;

    return S_OK;
}

HRESULT RepeatButton::Initialize(UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Button::Initialize(nActive);
    if (FAILED(hr))
        return hr;

    // Initialize
    _hAction = NULL;
    _fActionDelay = false;

    return S_OK;
}

////////////////////////////////////////////////////////
// Global action callback

void RepeatButton::_RepeatButtonActionCallback(GMA_ACTIONINFO* pmai)
{
    DUIAssert(pmai->pvData, "RepeatButton data should be non-NULL");

    //DUITrace("RepeatButton Action <%x>\n", pmai->pvData);

    // Fire click event
    if (!pmai->fFinished)
    {
        // todo -- pick some better values than this -- when behavior is made public, all we have to do is hold a ClickInfo as a 
        // data member on RepeatButton
        ClickInfo ci;
        ci.nCount = 1;
        ci.pt.x = -1;
        ci.pt.y = -1;
        ci.uModifiers = 0;
        _FireClickEvent((RepeatButton*) pmai->pvData, &ci);
    }
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
void RepeatButton::OnInput(InputEvent* pie)
{
    BOOL bPressed = GetPressed(); // sucks to have to call GetPressed here because it's not always needed
    BOOL bPressedBefore = bPressed;
    ClickInfo ci;

    // First, watch for a click event
    BOOL bFire = CheckRepeatClick(this, pie, GBUTTON_LEFT, &bPressed, &_fActionDelay, &_hAction, _RepeatButtonActionCallback, &ci);

    if (bPressed != bPressedBefore)
    {
        if (bPressed)
            SetPressed(true);
        else
            RemoveLocalValue(PressedProp);
    }
    if (bFire) 
        _FireClickEvent(this, &ci);

    if (pie->fHandled)
        return;

    Element::OnInput(pie);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { V_INT, -1 }; StaticValue(svDefault!!!, V_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties

// Define class info with type and base type, set static class pointer
IClassInfo* RepeatButton::Class = NULL;

HRESULT RepeatButton::Register()
{
    return ClassInfo<RepeatButton,Button>::Register(L"RepeatButton", NULL, 0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\scrollbar.cpp ===
/*
 * ScrollBar
 */

#include "stdafx.h"
#include "control.h"

#include "duiscrollbar.h"

#include "duirepeatbutton.h"
#include "duithumb.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(ScrollBar, Scroll) // ScrollEvent

////////////////////////////////////////////////////////
// ScrollBar

HRESULT ScrollBar::Create(bool fBuildSubTree, OUT Element** ppElement)
{
    *ppElement = NULL;

    ScrollBar* psb = HNew<ScrollBar>();
    if (!psb)
        return E_OUTOFMEMORY;

    HRESULT hr = psb->Initialize(fBuildSubTree);
    if (FAILED(hr))
        return hr;

    *ppElement = psb;

    return S_OK;
}

HRESULT ScrollBar::Initialize(bool fBuildSubTree)
{
    HRESULT hr;

    for (int i = 0; i < SP_Count; i++)
        _peParts[i] = NULL;

    // Initialize base
    hr = Element::Initialize(EC_SelfLayout); // Normal display node creation, self-layout
    if (FAILED(hr))
        goto Failed;
    
    if (fBuildSubTree)
    {
        hr = RepeatButton::Create(AE_Mouse, &_peLineUp);
        if (FAILED(hr))
            goto Failed;

        hr = RepeatButton::Create(AE_Mouse, &_pePageUp);
        if (FAILED(hr))
            goto Failed;

        hr = Thumb::Create(AE_Mouse, &_peThumb);
        if (FAILED(hr))
            goto Failed;

        hr = RepeatButton::Create(AE_Mouse, &_pePageDown);
        if (FAILED(hr))
            goto Failed;

        hr = RepeatButton::Create(AE_Mouse, &_peLineDown);
        if (FAILED(hr))
            goto Failed;

        StartDefer();

        // Scroll bar settings
        SetActive(AE_Mouse);

        _fPinned = false;

        // Complete initialization of children
        _peLineUp->SetID(L"LineUp");
        _peLineUp->SetClass(L"Line");

        _pePageUp->SetID(L"PageUp");
        _pePageUp->SetClass(L"Page");

        _peThumb->SetID(L"Thumb");

        _pePageDown->SetID(L"PageDown");
        _pePageDown->SetClass(L"Page");

        _peLineDown->SetID(L"LineDown");
        _peLineDown->SetClass(L"Line");

        Add(_peParts, SP_Count);

        EndDefer();
    }

    return S_OK;

Failed:

    for (i = 0; i < SP_Count; i++)
    {
        if (_peParts[i])
        {
            _peParts[i]->Destroy();
            _peParts[i] = NULL;
        }
    }

    return hr;
}

bool ScrollBar::IsScrollable()
{
    int iMax = GetMaximum();
    int iMin = GetMinimum();

    int iDiff = iMax - iMin;

    if (iDiff <= 0)
        return false;

    int iPage = GetProportional() ? GetPage() : 1;

    return (iDiff + 1) > iPage;
}

////////////////////////////////////////////////////////
// Generic eventing


void ScrollBar::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*) pEvent;

            if (pbce->peTarget == _peLineUp)
                LineUp();
            else if (pbce->peTarget == _peLineDown)
                LineDown();
            else if (pbce->peTarget == _pePageUp)
                PageUp();
            else if (pbce->peTarget == _pePageDown)
                PageDown();

            pEvent->fHandled = true;
            return;
        }
        else if (pEvent->uidType == Thumb::Drag)
        {
            ThumbDragEvent* ptde = (ThumbDragEvent*)pEvent;

            if (ptde->peTarget == _peThumb && _cTrack)
            {
                Value* pvLocation;

                const POINT* ppt = _peThumb->GetLocation(&pvLocation);
                int posNew = GetVertical() ? (ppt->y + ptde->sizeDelta.cy) : (ppt->x + ptde->sizeDelta.cy);
                pvLocation->Release();
                int min = GetMinimum();
                long lEffectivePos = 0;

                if (posNew > _posTop)
                {
                    int max = GetMaximum();
                    long lEffectiveRange = (((long) max - min) + 1) - (GetProportional() ? GetPage() : 1);       

                    lEffectivePos = (((long) posNew - _posTop) * lEffectiveRange + _cTrack / 2) / _cTrack;

                    if (lEffectivePos > lEffectiveRange)
                        lEffectivePos = lEffectiveRange;
                }

                SetPosition(min + lEffectivePos);

                pEvent->fHandled = true;
                return;
            }
        }
    }
}

////////////////////////////////////////////////////////
// System events

// Validation
bool ScrollBar::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    UNREFERENCED_PARAMETER(iIndex);
    UNREFERENCED_PARAMETER(pvOld);

    if (ppi == PositionProp)
    {
        int dPos = pvNew->GetInt();

        int dMin = GetMinimum();

        if (dPos < dMin)
        {
            SetPosition(dMin);
            return false;
        }
        else
        {
            int dMax = GetMaximum();
            if (GetProportional())
            {
                dMax -= GetPage() - 1;
                if (dMax < dMin)
                    dMax = dMin;
            }
            if (dPos > dMax)        
            {
                SetPosition(dMax);
                return false;            
            }
        }
    }
    else if (ppi == PageProp)
    {
        int dPage = pvNew->GetInt();

        int dMax = GetMaximum() - GetMinimum() + 1;
        if (dPage > dMax)
        {
            SetPage(dMax);
            return false;
        }
    }

    return true;
}

void ScrollBar::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Position))
    {
        // Fire scroll event
        //DUITrace("Scroll Event <%x>: %d\n", this, pvNew->GetInt());

        ScrollEvent se;
        se.uidType = Scroll;
        se.dPos = pvNew->GetInt();

        // Scrollbar position is changing. Update the ScrollBar's "pinned state" (i.e.
        // bar at maximum position) only if the ScrollBar is in use
        if (GetLayoutPos() != LP_None)
        {
            int iPage = GetProportional() ? GetPage() : 1;
            _fPinned = (GetPosition() == (GetMaximum() - iPage + 1));
        }

        FireEvent(&se); // Will route and bubble
    }
    else if (IsProp(Vertical))
    {
        bool bVert = pvNew->GetBool();
        _peLineUp->SetID(bVert ? L"LineUp" : L"LineLeft");
        _pePageUp->SetID(bVert ? L"PageUp" : L"PageLeft");
        _peThumb->SetID(bVert ? L"Thumb" : L"HThumb");
        _pePageDown->SetID(bVert ? L"PageDown" : L"PageRight");
        _peLineDown->SetID(bVert ? L"LineDown" : L"LineRight");
    }
    else if (IsProp(Minimum))
    {
        int min = pvNew->GetInt();
        if (GetPosition() < min)
            SetPosition(min);
    }
    else if (IsProp(Maximum))
    {
        int max = pvNew->GetInt();

        if (GetProportional())
        {
            max -= GetPage() - 1;
            int min = GetMinimum();
            if (max < min)
                max = min;
        }

        if (GetPosition() > max)
            SetPosition(max);
    }
    else if (IsProp(Page))
    {
        int max = GetMaximum();

        if (GetProportional())
        {
            max -= pvNew->GetInt() - 1;
            int min = GetMinimum();
            if (max < min)
                max = min;
        }

        if (GetPosition() > max)
            SetPosition(max);
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

int ScrollBar::GetPageInc()
{
    int inc = GetPage();

    if (GetProportional())
        // if non-proportional, then page is the exact page amount; otherwise, we have to reduce the page by a line increment
        inc -= GetLine();

    return (inc > 0) ? inc : 1;
}

////////////////////////////////////////////////////////
// Self-layout methods

#define X 0
#define Y 1

void ScrollBar::_SelfLayoutDoLayout(int cx, int cy)
{
    bool bVertical = GetVertical();

    int iLen = bVertical ? 1 : 0;
    int iThick  = bVertical ? 0 : 1;

    int cRemaining = bVertical ? cy : cx;
    int cThick  = bVertical ? cx : cy;
    
    int c[2][SP_Count] = { { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } };

    for (int i = 0; i < SP_Count; i++)
        c[iThick][i] = cThick;

    // Get extents of line up and down
    c[iLen][SP_LineUp]   = ((int*) (_peLineUp->GetDesiredSize()))[iLen];
    c[iLen][SP_LineDown] = ((int*) (_peLineDown->GetDesiredSize()))[iLen];
    int cLineLen = c[iLen][SP_LineUp] + c[iLen][SP_LineDown];

    if (cLineLen > cRemaining)
    {
        c[iLen][SP_LineUp] = cRemaining / 2;
        c[iLen][SP_LineDown] = cRemaining - c[iLen][SP_LineUp];
        cRemaining = 0;
        _cTrack = 0;
    }
    else
    {
        // Get metrics of scroll bar
        bool bProportional = GetProportional();
        int dPos = GetPosition(); // dMin <= dPos <= (dMax - dPage)
        int dMin = GetMinimum();
        int dMax = GetMaximum();
        int dPage = bProportional ? GetPage() : 1;

        cRemaining -= cLineLen;

        int cRange = (dMax - dMin) + 1;

        int cThumb = 0;

        if (bProportional)
        {
            cThumb = (cRemaining * dPage) / cRange;
            if (cThumb < 8) // 4*CXEDGE
            {
                if (cRemaining < 8)
                    cThumb = cRemaining;
                else
                    cThumb = 8;
            }
        }
        else
            cThumb = cThick;

        _cTrack = cRemaining - cThumb;

        c[iLen][SP_Thumb] = cThumb;

        if (cRange == dPage)
            c[iLen][SP_PageUp] = 0;
        else
            c[iLen][SP_PageUp] = (int) ((((long) dPos - dMin) * _cTrack) / (cRange - dPage));

        c[iLen][SP_PageDown] = cRemaining - (c[iLen][SP_PageUp] + c[iLen][SP_Thumb]);
    }

    int pos[2] = { 0, 0 };

    // Check layout order
    int iOrder = GetOrder();

    for (int i = 0; i < SP_Count; i++)
    {
        int iPart = (iOrder & 0xF);
        iOrder = iOrder >> 4;

        if (iPart == SP_PageUp)
            _posTop = pos[iLen];

        _peParts[iPart]->_UpdateLayoutPosition(pos[X], pos[Y]);
        _peParts[iPart]->_UpdateLayoutSize(c[X][iPart], c[Y][iPart]);
        pos[iLen] += c[iLen][iPart];
    }
}

SIZE ScrollBar::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    bool bVertical = GetVertical();

    int iLength = bVertical ? 1 : 0;
    int iThick  = bVertical ? 0 : 1;

    int cRemaining[2];

    cRemaining[X] = cxConstraint;
    cRemaining[Y] = cyConstraint;

    SIZE size = { 0 };

    int cMaxThick = 0;
    int cTotalLength = 0;

    int cThick;
    int cLength;

    // Check layout order
    int iOrder = GetOrder();

    size = _peParts[SP_LineUp]->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);
    cMaxThick    = ((int*) &size)[iThick];
    cTotalLength = ((int*) &size)[iLength];
    size = _peParts[SP_LineDown]->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);
    cTotalLength += ((int*) &size)[iLength];
    cThick = ((int*) &size)[iThick];
    if (cMaxThick < cThick)
        cMaxThick = cThick;

    if (cTotalLength > cRemaining[iLength])
    {
        cTotalLength = cRemaining[iLength];
        cRemaining[iLength] = 0;
    }
    else
        cRemaining[iLength] -= cTotalLength;

    for (int i = 0; i < SP_Count; i++)
    {
        int iPart = iOrder & 0xF;
        iOrder = iOrder >> 4;

        if ((iPart == SP_LineUp) || (iPart == SP_LineDown))
            continue;

        size = _peParts[iPart]->_UpdateDesiredSize(cRemaining[X], cRemaining[Y], psrf);

        cThick  = ((int*) &size)[iThick];
        cLength = ((int*) &size)[iLength];

        if (cMaxThick < cThick)
            cMaxThick = cThick;

        cTotalLength += cLength;
        cRemaining[iLength] -= cLength;
    }

    if (bVertical)
    {
        size.cx = cMaxThick;
        size.cy = cTotalLength;
    }
    else
    {
        size.cx = cTotalLength;
        size.cy = cMaxThick;
    }

    return size;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Position property
static int vvPosition[] = { DUIV_INT, -1 };
static PropertyInfo impPositionProp = { L"Position", PF_Normal, PG_AffectsLayout, vvPosition, NULL, Value::pvIntZero };
PropertyInfo* ScrollBar::PositionProp = &impPositionProp;

// Minimum property
static int vvMinimum[] = { DUIV_INT, -1 }; 
static PropertyInfo impMinimumProp = { L"Minimum", PF_Normal, PG_AffectsLayout, vvMinimum, NULL, Value::pvIntZero };
PropertyInfo* ScrollBar::MinimumProp = &impMinimumProp;

// Maximum property
static int vvMaximum[] = { DUIV_INT, -1 }; StaticValue(svDefaultMaximum, DUIV_INT, 1000);
static PropertyInfo impMaximumProp = { L"Maximum", PF_Normal, PG_AffectsLayout, vvMaximum, NULL, (Value*)&svDefaultMaximum };
PropertyInfo* ScrollBar::MaximumProp = &impMaximumProp;

// Page property
static int vvPage[] = { DUIV_INT, -1 }; StaticValue(svDefaultPage, DUIV_INT, 250);
static PropertyInfo impPageProp = { L"Page", PF_Normal, PG_AffectsLayout, vvPage, NULL, (Value*)&svDefaultPage };
PropertyInfo* ScrollBar::PageProp = &impPageProp;

// Line property
static int vvLine[] = { DUIV_INT, -1 }; StaticValue(svDefaultLine, DUIV_INT, 10);
static PropertyInfo impLineProp = { L"Line", PF_Normal, 0, vvLine, NULL, (Value*)&svDefaultLine };
PropertyInfo* ScrollBar::LineProp = &impLineProp;

// Vertical property
static int vvVertical[] = { DUIV_BOOL, -1 };
static PropertyInfo impVerticalProp = { L"Vertical", PF_Normal|PF_Cascade, PG_AffectsLayout|PG_AffectsDesiredSize, vvVertical, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollBar::VerticalProp = &impVerticalProp;

// Proportional property
static int vvProportional[] = { DUIV_BOOL, -1 };
static PropertyInfo impProportionalProp = { L"Proportional", PF_Normal|PF_Cascade, PG_AffectsLayout, vvProportional, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollBar::ProportionalProp = &impProportionalProp;

// Order property
static int vvOrder[] = { DUIV_INT, -1 }; StaticValue(svDefaultOrder, DUIV_INT, SBO_Normal);
static EnumMap emOrder[] = { { L"Normal", SBO_Normal }, { L"ArrowsAtTop", SBO_ArrowsAtTop }, { L"ArrowsAtBottom", SBO_ArrowsAtBottom }, { NULL, 0 } };
static PropertyInfo impOrderProp = { L"Order", PF_Normal|PF_Cascade, PG_AffectsLayout, vvOrder, emOrder, (Value*)&svDefaultOrder };
PropertyInfo* ScrollBar::OrderProp = &impOrderProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                ScrollBar::PositionProp,
                                ScrollBar::MinimumProp,
                                ScrollBar::MaximumProp,
                                ScrollBar::PageProp,
                                ScrollBar::LineProp,
                                ScrollBar::VerticalProp,
                                ScrollBar::ProportionalProp,
                                ScrollBar::OrderProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* ScrollBar::Class = NULL;

HRESULT ScrollBar::Register()
{
    return ClassInfo<ScrollBar,Element>::Register(L"ScrollBar", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\selector.cpp ===
/*
 * Selector
 */

#include "stdafx.h"
#include "control.h"

#include "duiselector.h"

#include "duibutton.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Selector, SelectionChange)  // SelectionChangeEvent struct

////////////////////////////////////////////////////////
// Selector

HRESULT Selector::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Selector* ps = HNew<Selector>();
    if (!ps)
        return E_OUTOFMEMORY;

    HRESULT hr = ps->Initialize();
    if (FAILED(hr))
    {
        ps->Destroy();
        return hr;
    }

    *ppElement = ps;

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

// Validation
void Selector::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selection))
    {
        // Setup SelectionChange event
        SelectionChangeEvent sce;
        sce.uidType = SelectionChange;
        sce.peOld = pvOld->GetElement();
        sce.peNew = pvNew->GetElement();

        // Update selected properties on elements
        if (sce.peOld)
            sce.peOld->RemoveLocalValue(SelectedProp);

        if (sce.peNew)
            sce.peNew->SetSelected(true);

        // Fire bubbling event
        //DUITrace("SelectionChange! <%x>, O:%x N:%x\n", this, sce.peOld, sce.peNew);

        FireEvent(&sce);  // Will route and bubble
    }
    else if (IsProp(Children))
    {
        // Check if child list change affects selection

        Element* peSel = GetSelection();
        if (peSel)
        {
            DUIAssert(pvOld->GetElementList()->GetIndexOf(peSel) != -1, "Stored selection invalid");

            // Children property (and Index) is updated before the Parent property of all the children.
            // As a result, this notification may happen before the Parent property
            // changes on the child. Use new array and index to determine if child is still in it
            ElementList* peList = pvNew->GetElementList();
            if ((peSel->GetIndex() == -1) || !peList || ((UINT)peSel->GetIndex() >= peList->GetSize()) ||
                (peList->GetItem(peSel->GetIndex()) != peSel))
            {
                // Item is no longer in list
                RemoveLocalValue(SelectionProp);
                peSel->RemoveLocalValue(SelectedProp);
            }
        }
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

// Pointer is only guaranteed good for the lifetime of the call
void Selector::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                if ((pke->nCode == GKEY_CHAR) && (pke->ch == VK_TAB))
                    // don't allow tab key to perform child navigation at this level
                    return;
            }
        }
    }

    Element::OnInput(pie);
}

void Selector::OnKeyFocusMoved(Element* peFrom, Element* peTo)
{
    Element::OnKeyFocusMoved(peFrom, peTo);

    if (peTo && peTo->GetParent() == this)
    {
        SetSelection(peTo);
    }
}

// Generic eventing

void Selector::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if ((pEvent->nStage == GMF_DIRECT) || (pEvent->nStage == GMF_BUBBLED))
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
        }
    }
    return Element::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// Hierarchy

Element* Selector::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    if (!peFrom)
    {
        Element* pe = GetSelection();
        if (pe)
            pe = pe->GetAdjacent(NULL, iNavDir, pnr, bKeyable);
        if (pe)
            return pe;
    }
    else if (iNavDir & NAV_LOGICAL)
    {
        return NULL;
    }

    return Element::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Selection property
static int vvSelection[] = { DUIV_ELEMENTREF, -1 };
static PropertyInfo impSelectionProp = { L"Selection", PF_Normal, 0, vvSelection, NULL, Value::pvElementNull };
PropertyInfo* Selector::SelectionProp = &impSelectionProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Selector::SelectionProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Selector::Class = NULL;

HRESULT Selector::Register()
{
    return ClassInfo<Selector,Element>::Register(L"Selector", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\sources.inc ===
!IF 0

    DirectUI Control Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\behavior.cpp        \
        ..\button.cpp          \
        ..\edit.cpp            \
        ..\combobox.cpp        \
        ..\hwndhost.cpp        \
        ..\native.cpp          \
        ..\progress.cpp        \
        ..\refpointelement.cpp \
        ..\repeatbutton.cpp    \
        ..\scrollbar.cpp       \
        ..\scrollviewer.cpp    \
        ..\selector.cpp        \
        ..\thumb.cpp           \
        ..\viewer.cpp          \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxcontrol.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_CONTROL_STDAFX_H_INCLUDED
#define DUI_CONTROL_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_CONTROL_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\scrollviewer.cpp ===
/*
 * ScrollViewer
 */

#include "stdafx.h"
#include "control.h"

#include "duiscrollviewer.h"
#include "duininegridlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// ScrollViewer

HRESULT ScrollViewer::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ScrollViewer* psv = HNew<ScrollViewer>();
    if (!psv)
        return E_OUTOFMEMORY;

    HRESULT hr = psv->Initialize();
    if (FAILED(hr))
    {
        psv->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = psv;

    return S_OK;
}

HRESULT ScrollViewer::Initialize()
{
    _peVScroll = NULL;
    _peHScroll = NULL;
    _peViewer = NULL;
    NineGridLayout* pngl = NULL;

    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        goto Failed;
    
    // Create children
    hr = ScrollBar::Create(true, (Element**)&_peVScroll);
    if (FAILED(hr))
        goto Failed;

    hr = ScrollBar::Create(true, (Element**)&_peHScroll);
    if (FAILED(hr))
        goto Failed;

    hr = Viewer::Create((Element**)&_peViewer);
    if (FAILED(hr))
        goto Failed;

    hr = NineGridLayout::Create((Layout**)&pngl);
    if (FAILED(hr))
        goto Failed;

    StartDefer();

    // Setup state
    _peContent = NULL;

    SetActive(AE_Inactive);
    SetLayout(pngl);

    // Children state
    Element::Add(_peVScroll);

    _peHScroll->SetVertical(false);
    Element::Add(_peHScroll);

    Element::Add(_peViewer);
    _peViewer->AddListener(this);

    // For mouse wheel support
    SetActive(AE_Mouse);

    EndDefer();

    return S_OK;

Failed:

    if (_peVScroll)
    {
        _peVScroll->Destroy();
        _peVScroll = NULL;
    }

    if (_peHScroll)
    {
        _peHScroll->Destroy();
        _peHScroll = NULL;
    }

    if (_peViewer)
    {
        _peViewer->Destroy();
        _peViewer = NULL;
    }

    if (pngl)
    {
        pngl->Destroy();
        pngl = NULL;
    }

    return hr;
}

////////////////////////////////////////////////////////
// Generic eventing

void ScrollViewer::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == ScrollBar::Scroll)
        {
            // Scroll bar scrollevent
            ScrollEvent* se = (ScrollEvent*) pEvent;

            if (pEvent->peTarget == _peHScroll)
            {
                SetXOffset(se->dPos);
                _peViewer->SetXOffset(se->dPos);
                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _peVScroll)
            {
                SetYOffset(se->dPos);
                _peViewer->SetYOffset(se->dPos);
                pEvent->fHandled = true;
                return;
            }
        }
        else if (pEvent->uidType == Element::KeyboardNavigate)
        {
            // If receiving a keyboard navigate event, no child did anything with it.
            // Stop navigation from moving outside of scroll viewer. Also, adjust 
            // scrolling position to unsure non-keyfocusable items get shown
        
            KeyboardNavigateEvent* pkne = (KeyboardNavigateEvent*) pEvent;
            
            if (!(pkne->iNavDir & NAV_LOGICAL))
            {
                if (pkne->iNavDir == NAV_UP)
                    _peVScroll->PageUp();
                else if (pkne->iNavDir == NAV_DOWN)
                    _peVScroll->PageDown();
                else if (pkne->iNavDir == NAV_LEFT)
                    _peHScroll->PageUp();
                else if (pkne->iNavDir == NAV_RIGHT)
                    _peHScroll->PageDown();
            
                pEvent->fHandled = true;
                return;
            }
        }
    }

    Element::OnEvent(pEvent);
}

HRESULT ScrollViewer::Add(Element** ppe, UINT cCount)
{
    UINT cRun = 0;
    HRESULT hr;

    for (UINT i = 0; i < cCount; i++)
    {
        if ((ppe[i] != _peVScroll) && (ppe[i] != _peHScroll) && (ppe[i] != _peViewer))
        {
            hr = _peViewer->Add(ppe[i]);
            if (FAILED(hr))
                goto Failed;

            if (cRun)
            {
                hr = Element::Add(ppe + (i - cRun), cRun);
                if (FAILED(hr))
                    goto Failed;
            }

            cRun = 0;
        }
        else
            cRun++;
    }

    if (cRun)
    {
        hr = Element::Add(ppe + (cCount - cRun), cRun);
        if (FAILED(hr))
            goto Failed;
    }

    return S_OK;

Failed:
    
    return hr;
}

////////////////////////////////////////////////////////
// System events

// Validation
bool ScrollViewer::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    UNREFERENCED_PARAMETER(ppi);
    UNREFERENCED_PARAMETER(iIndex);
    UNREFERENCED_PARAMETER(pvOld);
    UNREFERENCED_PARAMETER(pvNew);

    // use the scrollbars as our "validators" for XOffset and YOffset values
    if (ppi == XOffsetProp)
    {
        int x = pvNew->GetInt();
        _peHScroll->SetPosition(x);
        int xNew = _peHScroll->GetPosition();
        if (x != xNew)
        {
            SetXOffset(xNew);
            return false;
        }
    }
    else if (ppi == YOffsetProp)
    {
        int y = pvNew->GetInt();
        _peVScroll->SetPosition(y);
        int yNew = _peVScroll->GetPosition();
        if (y != yNew)
        {
            SetYOffset(yNew);
            return false;
        }
    }
    return true;
}

void ScrollViewer::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(XOffset))
    {
        // the scrollbar is updated in the OnPropertyChanging -- so now we only need to update the viewer
        _peViewer->SetXOffset(pvNew->GetInt());
    }
    else if (IsProp(YOffset))
    {
        // the scrollbar is updated in the OnPropertyChanging -- so now we only need to update the viewer
        _peViewer->SetYOffset(pvNew->GetInt());
    }
    else if (IsProp(XScrollable))
    {
        bool fScrollable = pvNew->GetBool();
        _peViewer->SetXScrollable(fScrollable);
        CheckScroll(_peHScroll, fScrollable,      GetXBarVisibility());
        CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());
    }
    else if (IsProp(YScrollable))
    {
        bool fScrollable = pvNew->GetBool();
        _peViewer->SetYScrollable(fScrollable);
        CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
        CheckScroll(_peVScroll, fScrollable,      GetYBarVisibility());
    }
    else if (IsProp(YBarVisibility))
    {
        CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
        CheckScroll(_peVScroll, GetYScrollable(), pvNew->GetInt());
    }
    else if (IsProp(XBarVisibility))
    {
        CheckScroll(_peHScroll, GetXScrollable(), pvNew->GetInt());
        CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

void ScrollViewer::OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (peFrom == _peViewer)
    {
        if (IsProp(Viewer::XOffset))
            SetXOffset(pvNew->GetInt());
        else if (IsProp(Viewer::YOffset))
            SetYOffset(pvNew->GetInt());
        else if (IsProp(Viewer::XScrollable))
            SetXScrollable(pvNew->GetBool());
        else if (IsProp(Viewer::YScrollable))
            SetYScrollable(pvNew->GetBool());
        else if (IsProp(Children))
        {
            ElementList* pelOld = pvOld->GetElementList();
            ElementList* pelNew = pvNew->GetElementList();

            if (pelOld)
                pelOld->GetItem(0)->RemoveListener(this);

            if (pelNew)
            {
                _peContent = pelNew->GetItem(0);
                _peContent->AddListener(this);
            }
        }
        else if (IsProp(Extent))
        {
            // Update scroller metrics (extent of viewer has changed due to a layout, make changes
            // to other ScrollViewer controls to reflect this which will cause another layout)
            // Before that happens, check if scroller is pinned (since position may change)
            bool fVPinned = false;
            bool fHPinned = false;

            int nPinning = GetPinning();

            if (nPinning & P_Vert)
                fVPinned = _peVScroll->IsPinned();
            if (nPinning & P_Horz)
                fHPinned = _peHScroll->IsPinned();

            const SIZE* psize = pvNew->GetSize();
            _peHScroll->SetPage(psize->cx);
            _peVScroll->SetPage(psize->cy);
            
            CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
            CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());

            if (fVPinned)
                _peVScroll->End();
            if (fHPinned)
                _peHScroll->End();
        }
    }
    else if (peFrom == _peContent)
    {
        if (IsProp(Extent))
        {
            // Update scroller metrics (extent of content has changed due to a layout, make changes
            // to other ScrollViewer controls to reflect this which will cause another layout)
            // Before that happens, check if scroller is pinned (since position may change)
            bool fVPinned = false;
            bool fHPinned = false;

            int nPinning = GetPinning();

            if (nPinning & P_Vert)
                fVPinned = _peVScroll->IsPinned();
            if (nPinning & P_Horz)
                fHPinned = _peHScroll->IsPinned();
                
            const SIZE* psize = pvNew->GetSize();
            _peHScroll->SetMaximum(psize->cx - 1);
            _peVScroll->SetMaximum(psize->cy - 1);
            Value* pvSize;
            psize =_peViewer->GetExtent(&pvSize);
            _peHScroll->SetPage(psize->cx);
            _peVScroll->SetPage(psize->cy);
            pvSize->Release();
            
            CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
            CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());

            if (fVPinned)
                _peVScroll->End();
            if (fHPinned)
                _peHScroll->End();
        }
    }
}

void ScrollViewer::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
            case GINPUT_KEYBOARD:
                {
                    KeyboardEvent* pke = (KeyboardEvent*)pie;
                    switch (pke->nCode)
                    {
                    case GKEY_DOWN:
                        switch (pke->ch)
                        {
                            // todo:  support moving offset with these keys if the child is not key active
                            case VK_DOWN:
                            case VK_UP:
                            case VK_LEFT:
                            case VK_RIGHT:
                            case VK_HOME:
                            case VK_END:
                                pie->fHandled = true;
                                return;
                       }
                    }
                }
                break;

            case GINPUT_MOUSE:
                {
                    MouseEvent* pme = (MouseEvent*)pie;
                    if ((pme->nCode == GMOUSE_WHEEL) && GetYScrollable())
                    {
                        StartDefer();

                        int sWheel = ((MouseWheelEvent*)pme)->sWheel;
                        bool fUp =  sWheel > 0;
                        UINT nDelta = abs(sWheel) / WHEEL_DELTA;
                        UINT nMultiplier = 1;

                        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &nMultiplier, FALSE);

                        if (nMultiplier == WHEEL_PAGESCROLL)
                        {
                            if (fUp)
                                _peVScroll->PageUp(nDelta);
                            else
                                _peVScroll->PageDown(nDelta);
                        }
                        else
                        {
                            if (fUp)
                                _peVScroll->LineUp(nDelta * nMultiplier);
                            else
                                _peVScroll->LineDown(nDelta * nMultiplier);
                        }

                        //DUITrace("SV: Wheel, Delta: %d, Multiplier: %d\n", nDelta, nMultiplier);

                        EndDefer();
                        
                        pme->fHandled = true;
                        return;
                    }
                }
                break;
        }
     }

    Element::OnInput(pie);
}

void ScrollViewer::CheckScroll(ScrollBar* psb, BOOL fScrollable, int iVisibility)
{
    if (!fScrollable)
    {
        psb->SetLayoutPos(LP_None);
        return;
    }

    fScrollable = psb->IsScrollable();
    if (iVisibility == BV_Always)
    {
        if (fScrollable)
            psb->RemoveLocalValue(EnabledProp);
        else
            psb->SetEnabled(false);

        psb->RemoveLocalValue(LayoutPosProp);
    }
    else if ((iVisibility == BV_AsNeeded) && fScrollable)
        psb->RemoveLocalValue(LayoutPosProp);
    else
        psb->SetLayoutPos(LP_None);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// XOffset property
static int vvXOffset[] = { DUIV_INT, -1 };
static PropertyInfo impXOffsetProp = { L"XOffset", PF_Normal, 0, vvXOffset, NULL, Value::pvIntZero };
PropertyInfo* ScrollViewer::XOffsetProp = &impXOffsetProp;

// YOffset property
static int vvYOffset[] = { DUIV_INT, -1 };
static PropertyInfo impYOffsetProp = { L"YOffset", PF_Normal, 0, vvYOffset, NULL, Value::pvIntZero };
PropertyInfo* ScrollViewer::YOffsetProp = &impYOffsetProp;

// XScrollable property
static int vvXScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impXScrollableProp = { L"XScrollable", PF_Normal, 0, vvXScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollViewer::XScrollableProp = &impXScrollableProp;

// YScrollable property
static int vvYScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impYScrollableProp = { L"YScrollable", PF_Normal, 0, vvYScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollViewer::YScrollableProp = &impYScrollableProp;

static EnumMap emVisibility[] = { { L"AsNeeded", BV_AsNeeded }, { L"Always", BV_Always }, { L"Never", BV_Never } };

// XBarVisibility property
static int vvXBarVisibility[] = { DUIV_INT, -1 }; StaticValue(svDefaultBarVisibility, DUIV_INT, BV_AsNeeded);  
static PropertyInfo impXBarVisibilityProp = { L"XBarVisibility", PF_Normal, 0, vvXBarVisibility, emVisibility, (Value*)&svDefaultBarVisibility };
PropertyInfo* ScrollViewer::XBarVisibilityProp = &impXBarVisibilityProp;

// YBarVisibility property
static int vvYBarVisibility[] = { DUIV_INT, -1 }; StaticValue(svDefaultYBarVisibility, DUIV_INT, 0);
static PropertyInfo impYBarVisibilityProp = { L"YBarVisibility", PF_Normal, 0, vvYBarVisibility, emVisibility, (Value*)&svDefaultBarVisibility };
PropertyInfo* ScrollViewer::YBarVisibilityProp = &impYBarVisibilityProp;

// Pinning property
static int vvPinning[] = { DUIV_INT, -1 };
static EnumMap emPinning[] = { { L"NoPin", P_None}, { L"PinHorz", P_Horz }, { L"PinVert", P_Vert } };
static PropertyInfo impPinningProp = { L"Pinning", PF_Normal | PF_Cascade, 0, vvPinning, emPinning, Value::pvIntZero };
PropertyInfo* ScrollViewer::PinningProp = &impPinningProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                ScrollViewer::XOffsetProp,
                                ScrollViewer::YOffsetProp,
                                ScrollViewer::XScrollableProp,
                                ScrollViewer::YScrollableProp,
                                ScrollViewer::XBarVisibilityProp,
                                ScrollViewer::YBarVisibilityProp,
                                ScrollViewer::PinningProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* ScrollViewer::Class = NULL;

HRESULT ScrollViewer::Register()
{
    return ClassInfo<ScrollViewer,Element>::Register(L"ScrollViewer", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\stdafxcontrol.cpp ===
/*
 * stdafxcontrol.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\core.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_CORE_CORE_H_INCLUDED
#define DUI_CORE_CORE_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>

#endif // DUI_CORE_CORE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\thumb.cpp ===
/*
 * Thumb
 */

#include "stdafx.h"
#include "control.h"

#include "duithumb.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Thumb, Drag) // ThumbDragEvent

////////////////////////////////////////////////////////
// Thumb

HRESULT Thumb::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    Thumb* pt = HNew<Thumb>();
    if (!pt)
        return E_OUTOFMEMORY;

    HRESULT hr = pt->Initialize(nActive);
    if (FAILED(hr))
    {
        pt->Destroy();
        return hr;
    }

    *ppElement = pt;

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
void Thumb::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
        case GINPUT_MOUSE:
            {
                MouseEvent* pme = (MouseEvent*)pie;
                //DUITrace("MouseEvent: %d\n", pme->nCode);

                switch (pme->nCode)
                {
                case GMOUSE_UP:
                    // Override of base, no click fire on up, however
                    // mimic Button's behavior for state changes
                    if (GetPressed())  
                        RemoveLocalValue(PressedProp);
                    RemoveLocalValue(CapturedProp);

                    pie->fHandled = true;
                    return;

                case GMOUSE_DRAG:
                    // Fire thumb drag event
                    //DUITrace("Thumb drag <%x>: %d %d\n", this, pme->ptClientPxl.x, pme->ptClientPxl.y);

                    ThumbDragEvent tde;
                    tde.uidType = Thumb::Drag;
                    MapElementPoint(pme->peTarget, (POINT *) &((MouseDragEvent*) pme)->sizeDelta, (POINT *) &tde.sizeDelta);
                    if (IsRTL())
                    {
                        tde.sizeDelta.cx = -tde.sizeDelta.cx;
                    }
                    FireEvent(&tde); // Will route and bubble

                    // Pass to base
                    break;
                }
            }
            break;
        }
    }

    Button::OnInput(pie);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { V_INT, -1 }; StaticValue(svDefault!!!, V_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Thumb::Class = NULL;

HRESULT Thumb::Register()
{
    return ClassInfo<Thumb,Button>::Register(L"Thumb", NULL, 0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\expression.cpp ===
/*
 * Expression
 */

#include "stdafx.h"
#include "core.h"

#include "duiexpression.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Expression

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\accessibility.cpp ===
/*
 * Accessibility support
 */

#include "stdafx.h"
#include "core.h"

#include "DUIError.h"
#include "DUIElement.h"
#include "DUIHost.h"
#include "DUIHWNDHost.h"
#include "DUIAccessibility.h"
#include "DUINavigation.h"

typedef HRESULT (*PfnAccessibleChildCallback)(DirectUI::Element * peAccessible, void * pRawData);
HRESULT ForAllAccessibleChildren(DirectUI::Element * pe, PfnAccessibleChildCallback pfnCallback, void * pRawData)
{
    HRESULT hr = S_OK;

    //
    // Validate the input parameters.
    //
    if (pe == NULL || pfnCallback == NULL) {
        return E_INVALIDARG;
    }


    DirectUI::Value* pvChildren = NULL;
    DirectUI::ElementList* pel = NULL;
    
    //
    // The basic idea is to spin through all of our children, and count
    // them if they are accessible.  However, if a child is not 
    // accessible, we must "count through" them.  In other words, we ask
    // all unaccessible children if they have accessible children
    // themselves.  The reason is that even actual great-great-great 
    // grandchildren must be considered a direct "accessible child" if
    // their parent chain is not accessible up to us.
    //
    pel = pe->GetChildren(&pvChildren);
    if (pel)
    {
        DirectUI::Element* peChild = NULL;
        UINT i = 0;
        UINT iMax = pel->GetSize();

        for (i = 0; i < iMax && (hr == S_OK); i++)
        {
            peChild = pel->GetItem(i);

            if (peChild->GetAccessible()) {
                hr = pfnCallback(peChild, pRawData);
            } else {
                hr = ForAllAccessibleChildren(peChild, pfnCallback, pRawData);
            }
        }
    }
    pvChildren->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
struct GetAccessibleChildCountData
{
    GetAccessibleChildCountData() : count(0) {}
    
    UINT count;
};

HRESULT GetAccessibleChildCountCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetAccessibleChildCountData * pData = (GetAccessibleChildCountData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    //
    // Simply increase the count.
    //
    pData->count++;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
struct GetAccessibleChildByIndexData
{
    GetAccessibleChildByIndexData(UINT i) : index(i), pe(NULL) {}
    
    UINT index;
    DirectUI::Element * pe;
} ;

HRESULT GetAccessibleChildByIndexCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetAccessibleChildByIndexData * pData = (GetAccessibleChildByIndexData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    if (pData->index == 0) {
        //
        // We found the accessible child being searched for.  Return S_FALSE to
        // stop walking our list of children, since we're done.
        //
        pData->pe = peAccessible;
        return S_FALSE;
    } else {
        //
        // We weren't looking for this child.  Decrement our count and check
        // the next one.
        //
        pData->index--;
        return S_OK;
    }
}

///////////////////////////////////////////////////////////////////////////////
struct GetFirstAccessibleChildData
{
    GetFirstAccessibleChildData() : peFirst(NULL) {}

    DirectUI::Element * peFirst;
};

HRESULT GetFirstAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetFirstAccessibleChildData * pData = (GetFirstAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    //
    // Uh, we're the first one!  Return S_FALSE to stop walking over the
    // accessible children since we are done.
    //
    pData->peFirst = peAccessible;
    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
struct GetPrevAccessibleChildData
{
    GetPrevAccessibleChildData(DirectUI::Element * p) : peStart(p), pePrev(NULL), fFound(false) {}

    DirectUI::Element * peStart;
    DirectUI::Element * pePrev;
    bool fFound;
};

HRESULT GetPrevAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetPrevAccessibleChildData * pData = (GetPrevAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    if (peAccessible == pData->peStart) {
        //
        // We reached the element we were supposed to start from.  The
        // previous element already stored its pointer in our data.
        // Simply indicate that we are done and then return S_FALSE to stop
        // walking over the accessible children since we are done.
        //
        pData->fFound = true;
        return S_FALSE;
    } else {
        //
        // We may be the previous element, but we don't know for sure.  So,
        // store our pointer in the data just in case.
        //
        pData->pePrev = peAccessible;
        return S_OK;
    }
}

///////////////////////////////////////////////////////////////////////////////
struct GetNextAccessibleChildData
{
    GetNextAccessibleChildData(DirectUI::Element * p) : peStart(p), peNext(NULL) {}

    DirectUI::Element * peStart;
    DirectUI::Element * peNext;
};

HRESULT GetNextAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetNextAccessibleChildData * pData = (GetNextAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    if (pData->peStart == NULL) {
        //
        // This is the one for us to return!  Return S_FALSE to stop walking
        // the accessible children since we are done.
        //
        pData->peNext = peAccessible;
        return S_FALSE;
    } else if (peAccessible == pData->peStart) {
        //
        // We found the starting element.  The next one will be the one
        // we want to return.  Set peStart to NULL to indicate that next
        // time we should set peNext and return.
        //
        pData->peStart = NULL;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
struct GetLastAccessibleChildData
{
    GetLastAccessibleChildData() : peLast(NULL) {}

    DirectUI::Element * peLast;
};

HRESULT GetLastAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetLastAccessibleChildData * pData = (GetLastAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    //
    // Keep over-writting the last pointer.  The last element will win.
    //
    pData->peLast = peAccessible;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
struct CollectAllAccessibleChildrenData
{
    CollectAllAccessibleChildrenData() : pel(NULL)
    {
        DirectUI::ElementList::Create(0, true, &pel);
    }

    ~CollectAllAccessibleChildrenData()
    {
        if (pel != NULL) {
            pel->Destroy();
        }
    }

    DirectUI::ElementList * pel;
};

HRESULT CollectAllAccessibleChildrenCB(DirectUI::Element * peAccessible, void * pRawData)
{
    CollectAllAccessibleChildrenData * pData = (CollectAllAccessibleChildrenData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL || pData->pel == NULL) {
        return E_FAIL;
    }

    //
    // Add this element to the collection.
    //
    pData->pel->Add(peAccessible);
    return S_OK;
}

namespace DirectUI
{

void NotifyAccessibilityEvent(IN DWORD dwEvent, Element * pe)
{
    //
    // Check to see if anyone cares about this event.
    //
    if (true) { //IsWinEventHookInstalled(dwEvent)) {
        HWND hwndRoot = NULL;
        DWORD dwTicket = 0;

		//
		// Don't fire accessibility events from an HWNDHost element.  We rely
		// on the window it hosts to fire the events.  If we both do, 
		// accessibility tools can get confused.
		//
        if (pe->GetClassInfo()->IsSubclassOf(HWNDHost::Class)) {
        	return;
       	}

        //
        // Get a handle to the host window for this element.  This is
        // what we will pass to NotifyWinEvent.  We have specialized
        // handlers in the host window that can respond to accessibility
        // requests.
        //
        Element * peRoot = pe->GetRoot();
        if (peRoot == NULL) {
            //
            // We can't send any notifications if there isn't a root HWND.
            // This can happen on occasion: during startup, for instance.
            // So we don't Assert or anything, we just bail.
            //
            return;
        }

        if (!peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class)) {
            DUIAssert(FALSE, "Error: Cannot announce an accessibility event for an unhosted element!");
            return;
        }
        hwndRoot = ((HWNDElement*)peRoot)->GetHWND();
        if (hwndRoot == NULL) {
            DUIAssert(FALSE, "Error: The root HWNDElement doesn't have a HWND! Eh?");
            return;
        }

        //
        // Get the cross-process identity of the element.
        //
        dwTicket = GetGadgetTicket(pe->GetDisplayNode());
        if (dwTicket == 0) {
            DUIAssert(FALSE, "Failed to retrieve a ticket for a gadget!");
            return;
        }

        //
        // Just use the NotifyWinEvent API to broadcast this event.
        //
        // DUITrace("NotifyWinEvent(dwEvent:%x, hwndRoot:%p, dwTicket:%x, CHILDID_SELF)\n", dwEvent, hwndRoot, dwTicket);
        NotifyWinEvent(dwEvent, hwndRoot, dwTicket, CHILDID_SELF);
    }
}

HRESULT DuiAccessible::Create(Element * pe, DuiAccessible ** ppDA)
{
    DUIAssert(pe != NULL, "DuiAccessible created for a NULL element!");

    DuiAccessible * pda;

    *ppDA = NULL;

    pda = HNew<DuiAccessible>();
    if (!pda)
        return E_OUTOFMEMORY;

    //
    // Note: this is a weak reference - in other words, we don't hold a
    // reference on it.  The element is responsible for calling Disconnect()
    // before it evaporates to make sure that this pointer remains valid.
    //
    pda->Initialize(pe);

    *ppDA = pda;

    return S_OK;
}

DuiAccessible::~DuiAccessible()
{
    //
    // Supposedly some element holds a reference to us.  We should only ever
    // get completely released if they call Disconnect().
    //
    DUIAssert(_pe == NULL, "~DuiAccessible called while still connected to an element!");

    //
    // We should only get destroyed when all of our references have been
    // released!
    //
    DUIAssert(_cRefs == 0, "~DuiAccessible called with outstanding references!");
}

HRESULT DuiAccessible::Disconnect()
{
    //
    // Supposedly some element holds a reference to us.
    //
    DUIAssert(_pe != NULL, "DuiAccessible::Disconnect called when already disconnected!");
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // We can no longer access the element!
    //
    _pe = NULL;

    //
    // Forcibly disconnect all external (remote) clients.
    //
    return CoDisconnectObject((IUnknown*)(IDispatch*)(IAccessible*)this, 0);
}

STDMETHODIMP_(ULONG) DuiAccessible::AddRef()
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) DuiAccessible::Release()
{
    if (0 == InterlockedDecrement(&_cRefs)) {
        HDelete<DuiAccessible>(this);
        return 0;
    } else {
        return _cRefs;
    }
}

STDMETHODIMP DuiAccessible::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    //
    // Initialize and validate the out parameter(s).
    //
    if (ppvObj != NULL) {
        *ppvObj = NULL;
    } else {
        return E_POINTER;
    }

    //
    // Return interface pointers to interfaces that we know we support.
    //
    if (riid == __uuidof(IUnknown)) {
        *ppvObj = (LPVOID*)(IUnknown*)(IDispatch*)(IAccessible*)this;
    } else if (riid == __uuidof(IDispatch)) {
        *ppvObj = (LPVOID*)(IDispatch*)(IAccessible*)this;
    } else if (riid == __uuidof(IAccessible)) {
        *ppvObj = (LPVOID*)(IAccessible*)this;
    } else {
        return E_NOINTERFACE;
    }
    
    //
    // The interface we hand out has to be referenced.
    //
    AddRef();

    return S_OK;
}

STDMETHODIMP DuiAccessible::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(rgszNames);
    UNREFERENCED_PARAMETER(cNames);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(rgdispid);

    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::GetTypeInfoCount(UINT *pctinfo)
{
    UNREFERENCED_PARAMETER(pctinfo);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    UNREFERENCED_PARAMETER(itinfo);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(pptinfo);

    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Invoke(DISPID dispidMember,
                                   REFIID riid,
                                   LCID lcid,
                                   WORD wFlags,
                                   DISPPARAMS *pdispparams,
                                   VARIANT *pvarResult,
                                   EXCEPINFO *pexcepinfo,
                                   UINT *puArgErr)
{
    UNREFERENCED_PARAMETER(dispidMember);
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(wFlags);
    UNREFERENCED_PARAMETER(pdispparams);
    UNREFERENCED_PARAMETER(pvarResult);
    UNREFERENCED_PARAMETER(pexcepinfo);
    UNREFERENCED_PARAMETER(puArgErr);

    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::accSelect(long flagsSelect, VARIANT varChild)
{
    UNREFERENCED_PARAMETER(flagsSelect);
    UNREFERENCED_PARAMETER(varChild);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::accLocation(long *pxLeft,
                                        long *pyTop,
                                        long *pcxWidth,
                                        long *pcyHeight,
                                        VARIANT varChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pxLeft != NULL) {
        *pxLeft = 0;
    }
    if (pyTop != NULL) {
        *pyTop = 0;
    }
    if (pcxWidth != NULL) {
        *pcxWidth = 0;
    }
    if (pcyHeight != NULL) {
        *pcyHeight = 0;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pxLeft == NULL || pyTop == NULL || pcxWidth == NULL || pcyHeight == NULL) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return the bounds of the element in screen coordinates.  Screen 
    // coordinates are the same as coordinates relative to the desktop.
    //
    RECT rcLocation;
    GetGadgetRect(_pe->GetDisplayNode(), &rcLocation, SGR_DESKTOP);

    //
    // TODO:
    // These are the coordinates of the rectangle relative to the desktop.
    // However, what we really need to return is the bounding box of the
    // gadget.  Currently, rotated gadgets will report wierd results.
    //
    *pxLeft = rcLocation.left;
    *pyTop = rcLocation.top;
    *pcxWidth = rcLocation.right - rcLocation.left;
    *pcyHeight = rcLocation.bottom - rcLocation.top;

    return hr;
}

STDMETHODIMP DuiAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarEndUpAt != NULL) {
        VariantInit(pvarEndUpAt);
    }
    if (V_VT(&varStart) != VT_I4 || V_I4(&varStart) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pvarEndUpAt == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    Element * peFound = NULL;

    switch (navDir) {
    case NAVDIR_FIRSTCHILD:
        {
            GetFirstAccessibleChildData data;

            hr = ForAllAccessibleChildren(_pe, GetFirstAccessibleChildCB, (void*) &data);
            if SUCCEEDED(hr)
            {
                peFound = data.peFirst;
                hr = S_OK;
            }
        }
        break;

    case NAVDIR_LASTCHILD:
        {
            GetLastAccessibleChildData data;

            hr = ForAllAccessibleChildren(_pe, GetLastAccessibleChildCB, (void*) &data);
            if SUCCEEDED(hr)
            {
                peFound = data.peLast;
                hr = S_OK;
            }
        }
        break;

    case NAVDIR_NEXT:
        {
            GetNextAccessibleChildData data(_pe);
            Element * peParent = GetAccessibleParent(_pe);

            if (peParent == NULL) {
                hr = E_FAIL;
            } else {
                hr = ForAllAccessibleChildren(peParent, GetNextAccessibleChildCB, (void*) &data);
                if SUCCEEDED(hr)
                {
                    peFound = data.peNext;
                    hr = S_OK;
                }
            }
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            GetPrevAccessibleChildData data(_pe);
            Element * peParent = GetAccessibleParent(_pe);

            if (peParent == NULL) {
                hr = E_FAIL;
            } else {
                hr = ForAllAccessibleChildren(peParent, GetPrevAccessibleChildCB, (void*) &data);
                if SUCCEEDED(hr)
                {
                    peFound = data.pePrev;
                    hr = S_OK;
                }
            }
        }
        break;

    case NAVDIR_LEFT:
    case NAVDIR_RIGHT:
    case NAVDIR_UP:
    case NAVDIR_DOWN:
        {
            //
            // Collect all of the accessible children into a list.
            //
            CollectAllAccessibleChildrenData data;
            Element * peParent = GetAccessibleParent(_pe);

            if (peParent == NULL) {
                hr = E_FAIL;
            } else {
                hr = ForAllAccessibleChildren(peParent, CollectAllAccessibleChildrenCB, (void*) &data);
                if SUCCEEDED(hr)
                {
                    //
                    // Convert the IAccessible navigation direction value into
                    // an equivalent DUI navigation direction value.
                    //
                    switch (navDir) {
                    case NAVDIR_LEFT:
                        navDir = NAV_LEFT;
                        break;

                    case NAVDIR_RIGHT:
                        navDir = NAV_RIGHT;
                        break;

                    case NAVDIR_UP:
                        navDir = NAV_UP;
                        break;

                    case NAVDIR_DOWN:
                        navDir = NAV_DOWN;
                        break;
                    }

                    //
                    // Now navigate in the requested direction among the
                    // collection of accessible peers.
                    //
                    peFound = DuiNavigate::Navigate(_pe, data.pel, navDir);
                    hr = S_OK;
                }
            }
            
        }
        break;

    default:
        return E_FAIL;
    }


    //
    // If we found an appropriate accessible element, return its IDispatch
    // interface.
    //
    if (peFound != NULL) {
        IDispatch * pDispatch = NULL;

        hr = GetDispatchFromElement(peFound, &pDispatch);
        if (SUCCEEDED(hr)) {
            V_VT(pvarEndUpAt) = VT_DISPATCH;
            V_DISPATCH(pvarEndUpAt) = pDispatch;
        }
    }

    return hr;
}

STDMETHODIMP DuiAccessible::accHitTest(long x, long y, VARIANT *pvarChildAtPoint)
{
    //
    // Initialize output and validate input parameters.
    //
    if (pvarChildAtPoint != NULL) {
        VariantInit(pvarChildAtPoint);
    }
    if (pvarChildAtPoint == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }
    
    //
    // Get the root element.
    //
    HWND hwndRoot = NULL;
    Element * peRoot = _pe->GetRoot();
    if (peRoot == NULL) {
        //
        // No root!  We have no idea how to translate the screen coordinates
        // through all of our display tree transformations.  We have to bail.
        //
        return E_FAIL;
    }

    if (!peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class)) {
        DUIAssert(FALSE, "Error: Cannot hit test an unhosted element!");
        return E_FAIL;
    }

    hwndRoot = ((HWNDElement*)peRoot)->GetHWND();
    if (hwndRoot == NULL) {
        DUIAssert(FALSE, "Error: The root HWNDElement doesn't have a HWND! Eh?");
        return E_FAIL;
    }

    //
    // Convert the screen coordinates into coordinates relative to the root.
    // There are no complicated transformations yet.
    //
    POINT ptRoot;
    ptRoot.x = x;
    ptRoot.y = y;
    ScreenToClient(hwndRoot, &ptRoot);

    //
    // Translate the coordinates relative to the root into coordinates
    // relative to us.  There could be complicated transforms!
    //
    POINT ptElement;
    ptElement.x = ptRoot.x;
    ptElement.y = ptRoot.y;
    MapGadgetPoints(peRoot->GetDisplayNode(), _pe->GetDisplayNode(), &ptElement, 1);
        
    //
    // Now try and find our immediate child under this point.
    //
    Element * peChild = NULL;
    HGADGET hgadChild = FindGadgetFromPoint(_pe->GetDisplayNode(), ptElement, GS_VISIBLE, NULL);
    if (hgadChild) {
        peChild = ElementFromGadget(hgadChild);
        if (peChild != NULL && peChild != _pe) {
            Element * pe = peChild;
            peChild = NULL;

            //
            // We found some element buried deep in the tree that is under
            // the point. Now look up the tree for the immediate accessible
            // child of the original element (if any).
            //
            for (; pe != NULL && pe != _pe; pe = pe->GetParent()) {
                if (pe->GetAccessible()) {
                    peChild = pe;
                }
            }

            //
            // If we didn't find an accessible element between the element
            // under the point and us, then we get the hit test ourselves.
            //
            if (peChild == NULL) {
                peChild = _pe;
            }
        }
    }


    if (peChild == _pe) {
        //
        // The point wasn't over any of our immediate accessible children,
        // but it was over us.
        //
        V_VT(pvarChildAtPoint) = VT_I4;
        V_I4(pvarChildAtPoint) = CHILDID_SELF;
        return S_OK;
    }else if (peChild != NULL) {
        HRESULT hr = S_OK;
        IDispatch * pDispatch = NULL;

        hr = GetDispatchFromElement(peChild, &pDispatch);
        if (SUCCEEDED(hr)) {
            V_VT(pvarChildAtPoint) = VT_DISPATCH;
            V_DISPATCH(pvarChildAtPoint) = pDispatch;
        }

        return hr;
    } else {
        //
        // Evidently, the point wasn't even over us!
        //
        return S_FALSE;
    }
}

STDMETHODIMP DuiAccessible::accDoDefaultAction(VARIANT varChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Perform the default action on the element.
    // Do not call directly, queue for async invokation.
    //
    hr = _pe->QueueDefaultAction();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accChild(VARIANT varChildIndex, IDispatch **ppdispChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (ppdispChild != NULL) {
        *ppdispChild = NULL;
    }
    if (V_VT(&varChildIndex) != VT_I4) {
        return E_INVALIDARG;
    }
    if (V_I4(&varChildIndex) == 0) {
        //
        // We are expecting a 1-based index.
        //
        return E_INVALIDARG;
    }
    if (ppdispChild == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    GetAccessibleChildByIndexData data(V_I4(&varChildIndex) - 1);
    hr = ForAllAccessibleChildren(_pe, GetAccessibleChildByIndexCB, (void*) &data);
    if (SUCCEEDED(hr))
    {
        if (data.pe != NULL) {
            hr = GetDispatchFromElement(data.pe, ppdispChild);
        } else {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accParent(IDispatch **ppdispParent)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (ppdispParent != NULL) {
        *ppdispParent = NULL;
    }
    if (ppdispParent == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Once we found our "accessible parent", get its IAccessible
    // implementation and then query that for IDispatch.
    //
    Element * peParent = GetAccessibleParent(_pe);
    if (peParent != NULL) {
        hr = GetDispatchFromElement(peParent, ppdispParent);
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accChildCount(long *pChildCount)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pChildCount != NULL) {
        *pChildCount = 0;
    }
    if (pChildCount == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    GetAccessibleChildCountData data;
    hr = ForAllAccessibleChildren(_pe, GetAccessibleChildCountCB, (void*) &data);
    if SUCCEEDED(hr)
    {
        *pChildCount = data.count;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accName(VARIANT varChild, BSTR * pbstrName)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrName != NULL) {
        *pbstrName = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrName == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccName property.
    //
    Value* pvAccName = NULL;
    LPWSTR wstrAccName = _pe->GetAccName(&pvAccName);
    if (NULL != wstrAccName) {
        *pbstrName = SysAllocString(wstrAccName);
        if (*pbstrName == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccName->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::put_accName(VARIANT varChild, BSTR szName)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(szName);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accValue(VARIANT varChild, BSTR * pbstrValue)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrValue != NULL) {
        *pbstrValue = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrValue == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccValue property.
    //
    Value* pvAccValue = NULL;
    LPWSTR wstrAccValue = _pe->GetAccValue(&pvAccValue);
    if (NULL != wstrAccValue) {
        *pbstrValue = SysAllocString(wstrAccValue);
        if (*pbstrValue == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccValue->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::put_accValue(VARIANT varChild, BSTR pszValue)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pszValue);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accDescription(VARIANT varChild, BSTR * pbstrDescription)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrDescription != NULL) {
        *pbstrDescription = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrDescription == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccDesc property.
    //
    Value* pvAccDescription = NULL;
    LPWSTR wstrAccDescription = _pe->GetAccDesc(&pvAccDescription);
    if (NULL != wstrAccDescription) {
        *pbstrDescription = SysAllocString(wstrAccDescription);
        if (*pbstrDescription == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccDescription->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pszKeyboardShortcut);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarRole != NULL) {
        VariantInit(pvarRole);
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pvarRole == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return the AccRole property.
    //
    V_VT(pvarRole) = VT_I4;
    V_I4(pvarRole) = _pe->GetAccRole();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarState != NULL) {
        VariantInit(pvarState);
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pvarState == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return the AccState property.
    //
    V_VT(pvarState) = VT_I4;
    V_I4(pvarState) = _pe->GetAccState();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accHelp(VARIANT varChild, BSTR *pszHelp)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pszHelp);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic)
{
    UNREFERENCED_PARAMETER(pszHelpFile);
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pidTopic);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accFocus(VARIANT *pvarFocusChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarFocusChild != NULL) {
        VariantInit(pvarFocusChild);
    }
    if (pvarFocusChild == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    if (_pe->GetKeyFocused() && (_pe->GetActive() & AE_Keyboard)) {
        V_VT(pvarFocusChild) = VT_I4;
        V_I4(pvarFocusChild) = CHILDID_SELF;
    } else {
        V_VT(pvarFocusChild) = VT_EMPTY;
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accSelection(VARIANT *pvarSelectedChildren)
{
    UNREFERENCED_PARAMETER(pvarSelectedChildren);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accDefaultAction(VARIANT varChild, BSTR * pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrDefaultAction != NULL) {
        *pbstrDefaultAction = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrDefaultAction == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccDefAction property.
    //
    Value* pvAccDefAction = NULL;
    LPWSTR wstrAccDefAction = _pe->GetAccDefAction(&pvAccDefAction);
    if (NULL != wstrAccDefAction) {
        *pbstrDefaultAction = SysAllocString(wstrAccDefAction);
        if (*pbstrDefaultAction == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccDefAction->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::Next(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched)
{
    UNREFERENCED_PARAMETER(celt);
    UNREFERENCED_PARAMETER(rgvar);
    UNREFERENCED_PARAMETER(pceltFetched);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Next!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Skip(unsigned long celt)
{
    UNREFERENCED_PARAMETER(celt);
    
    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Skip!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Reset()
{
    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Reset!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Clone(IEnumVARIANT ** ppenum)
{
    UNREFERENCED_PARAMETER(ppenum);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Clone!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::GetWindow(HWND * phwnd)
{
    UNREFERENCED_PARAMETER(phwnd);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IOleWindow.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::GetWindow!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    UNREFERENCED_PARAMETER(fEnterMode);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IOleWindow.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::ContextSensitiveHelp!  Should never happen!");
    return E_NOTIMPL;
}

Element * DuiAccessible::GetAccessibleParent(Element * pe)
{
    //
    // Scan up our ancestors looking for a parent, grandparent, great-grandparent, etc
    // that is Accessible.  This is our "accessible parent".
    //
    Element * peParent = NULL;
    for(peParent = pe->GetParent(); peParent != NULL; peParent = peParent->GetParent())
    {
        if (peParent->GetAccessible()) {
            break;
        }
    }

    return peParent;
}

HRESULT DuiAccessible::GetDispatchFromElement(Element * pe, IDispatch ** ppDispatch)
{
    HRESULT hr = S_OK;

    //
    // Validate the input parameters and initialize the output parameters.
    //
    if (ppDispatch != NULL) {
        *ppDispatch = NULL;
    }
    if (pe == NULL || ppDispatch == NULL) {
        return E_INVALIDARG;
    }

    //
    // Only return an IDispatch interface to the element if it is accessible.
    //
    if (!pe->GetAccessible()) {
        return E_FAIL;
    }

    IAccessible * pAccessible = NULL;
    hr = pe->GetAccessibleImpl(&pAccessible);
    if (SUCCEEDED(hr)) {
        hr = pAccessible->QueryInterface(__uuidof(IDispatch), (LPVOID*) ppDispatch);
        pAccessible->Release();
    }

    return hr;
}

HRESULT HWNDElementAccessible::Create(HWNDElement * pe, DuiAccessible ** ppDA)
{
    HRESULT hr;

    HWNDElementAccessible* phea;

    *ppDA = NULL;

    phea = HNew<HWNDElementAccessible>();
    if (!phea)
        return E_OUTOFMEMORY;

    hr = phea->Initialize(pe);
    if (FAILED(hr))
    {
        phea->Release();
        goto Failure;
    }

    *ppDA = phea;

    return S_OK;

Failure:

    return hr;
}

HRESULT HWNDElementAccessible::Initialize(HWNDElement * pe)
{
    HRESULT hr = S_OK;

    //
    // Initialize base
    //
    
    DuiAccessible::Initialize(pe);

    _pParent = NULL;


    //
    // Use the "window" piece of the current HWND as our accessibility parent.
    // We will take over the "client" piece of this same window. In accessibility,
    // the "client" piece is a child of the "window" piece, even of the same HWND.
    //
    hr = AccessibleObjectFromWindow(pe->GetHWND(),
                                    (DWORD)OBJID_WINDOW,
                                    __uuidof(IAccessible),
                                    (void**)&_pParent);

    DUIAssert(SUCCEEDED(hr), "HWNDElementAccessible failed!");

    return hr;
}

HWNDElementAccessible::~HWNDElementAccessible()
{
    //
    // Supposedly some element holds a reference to us.  We should only ever
    // get completely released if they call Disconnect().
    //
    DUIAssert(_pParent == NULL, "~HWNDElementAccessible called while still connected to an element!");
}

HRESULT HWNDElementAccessible::Disconnect()
{
    HRESULT hr = S_OK;

    //
    // Supposedly some element holds a reference to us.
    //
    DUIAssert(_pParent != NULL, "HWNDElementAccessible::Disconnect called when already disconnected!");

    //
    // Release our reference to our parent window's IAccessible.
    //
    if (_pParent != NULL) {
        _pParent->Release();
        _pParent = NULL;
    }

    //
    // Continue disconnecting.
    //
    hr = DuiAccessible::Disconnect();

    return S_OK;
}

STDMETHODIMP HWNDElementAccessible::get_accParent(IDispatch **ppdispParent)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (ppdispParent != NULL) {
        *ppdispParent = NULL;
    }
    if (ppdispParent == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pParent == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // We maintain a pointer to the IAccessible interface of our parent window.
    // Now we simply QI it for IDispatch.
    //
    hr = _pParent->QueryInterface(__uuidof(IDispatch), (LPVOID*) ppdispParent);

    return hr;
}


HRESULT HWNDHostAccessible::Create(HWNDHost * pe, DuiAccessible ** ppDA)
{
    HRESULT hr;

    HWNDHostAccessible* phha;

    *ppDA = NULL;

    phha = HNew<HWNDHostAccessible>();
    if (!phha)
        return E_OUTOFMEMORY;

    hr = phha->Initialize(pe);
    if (FAILED(hr))
    {
        phha->Release();
        goto Failure;
    }

    *ppDA = phha;

    return S_OK;

Failure:

    return hr;
}
    

HRESULT HWNDHostAccessible::Initialize(HWNDHost * pe)
{
    HRESULT hr = S_OK;

    //
    // Initialize base
    //
    
    DuiAccessible::Initialize(pe);

    _pCtrl = NULL;
    _pEnum = NULL;
    _pOleWindow = NULL;

    //
    // Get the control HWND.
    //
    HWND hwndCtrl = pe->GetHWND();
    if (hwndCtrl != NULL) {
        hr = CreateStdAccessibleObject(hwndCtrl, OBJID_WINDOW, __uuidof(IAccessible), (void**) &_pCtrl);
    } else {
        hr = E_FAIL;
    }

    //
    // Check to see if the control supports IEnumVariant.
    //
    if (SUCCEEDED(hr)) {
        hr = _pCtrl->QueryInterface(__uuidof(IEnumVARIANT), (LPVOID*) &_pEnum);
    }

    //
    // Check to see if the control supports IOleWindow.
    //
    if (SUCCEEDED(hr)) {
        hr = _pCtrl->QueryInterface(__uuidof(IOleWindow), (LPVOID*) &_pOleWindow);
    }

    DUIAssert(SUCCEEDED(hr), "HWNDHostAccessible failed!");

    return hr;
}

HWNDHostAccessible::~HWNDHostAccessible()
{
    //
    // Supposedly some element holds a reference to us.  We should only ever
    // get completely released if they call Disconnect().
    //
    DUIAssert(_pCtrl == NULL, "~HWNDHostAccessible called while still connected to an element!");
}

HRESULT HWNDHostAccessible::Disconnect()
{
    HRESULT hr = S_OK;

    //
    // Supposedly some element holds a reference to us.
    //
    DUIAssert(_pCtrl != NULL, "HWNDHostAccessible::Disconnect called when already disconnected!");

    //
    // Release our reference to our control window's IAccessible.
    //
    if (_pCtrl != NULL) {
        _pCtrl->Release();
        _pCtrl = NULL;
    }

    //
    // Release our reference to our control window's IEnumVARIANT.
    //
    if (_pEnum != NULL) {
        _pEnum->Release();
        _pEnum = NULL;
    }

    //
    // Release our reference to our control window's IOleWindow.
    //
    if (_pOleWindow != NULL) {
        _pOleWindow->Release();
        _pOleWindow = NULL;
    }

    //
    // Continue disconnecting.
    //
    hr = DuiAccessible::Disconnect();

    return S_OK;
}
    
STDMETHODIMP HWNDHostAccessible::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    //
    // Initialize and validate the out parameter(s).
    //
    if (ppvObj != NULL) {
        *ppvObj = NULL;
    } else {
        return E_POINTER;
    }

    //
    // This is an attempt to have "smart" support for IEnumVARIANT and
    // IOleWindow.  We only admit we support these interfaces if our
    // control window does.
    //
    if (riid == __uuidof(IEnumVARIANT)) {
        if (_pEnum != NULL) {
            *ppvObj = (LPVOID*)(IEnumVARIANT*)(DuiAccessible*)this;
        } else {
            return E_NOINTERFACE;
        }
    } else if (riid == __uuidof(IOleWindow)) {
        if (_pOleWindow != NULL) {
            *ppvObj = (LPVOID*)(IOleWindow*)(DuiAccessible*)this;
        } else {
            return E_NOINTERFACE;
        }
    } else {
        return DuiAccessible::QueryInterface(riid, ppvObj);
    }
    
    //
    // The interface we hand out has to be referenced.
    //
    AddRef();

    return S_OK;
}

STDMETHODIMP HWNDHostAccessible::accSelect(long flagsSelect, VARIANT varChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accSelect(flagsSelect, varChild);
}

STDMETHODIMP HWNDHostAccessible::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}

STDMETHODIMP HWNDHostAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // We only delegate the FirstChild and LastChild navigation directions to
    // the window.  Spatial and logical navigation is handled by us, because
    // we have to be able to navigate to non-HWND siblings of this element.
    //
    if (V_VT(&varStart) == VT_I4 && V_I4(&varStart) == CHILDID_SELF) {
        switch (navDir) {
        case NAVDIR_NEXT:
        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
        case NAVDIR_RIGHT:
        case NAVDIR_UP:
        case NAVDIR_DOWN:
            return DuiAccessible::accNavigate(navDir, varStart, pvarEndUpAt);

        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
        default:
            return _pCtrl->accNavigate(navDir, varStart, pvarEndUpAt);
        }
    } else {
        return _pCtrl->accNavigate(navDir, varStart, pvarEndUpAt);
    }
}

STDMETHODIMP HWNDHostAccessible::accHitTest(long xLeft, long yTop, VARIANT *pvarChildAtPoint)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accHitTest(xLeft, yTop, pvarChildAtPoint);
}

STDMETHODIMP HWNDHostAccessible::accDoDefaultAction(VARIANT varChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accDoDefaultAction(varChild);
}

STDMETHODIMP HWNDHostAccessible::get_accChild(VARIANT varChildIndex, IDispatch **ppdispChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accChild(varChildIndex, ppdispChild);
}

STDMETHODIMP HWNDHostAccessible::get_accParent(IDispatch **ppdispParent)
{
    HRESULT hr = DuiAccessible::get_accParent(ppdispParent);

    return hr;
}

STDMETHODIMP HWNDHostAccessible::get_accChildCount(long *pChildCount)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accChildCount(pChildCount);
}

STDMETHODIMP HWNDHostAccessible::get_accName(VARIANT varChild, BSTR *pszName)
{
    HRESULT hr;

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    // Give the host element the first chance
    if (SUCCEEDED(hr = DuiAccessible::get_accName(varChild, pszName))) {
        return hr;
    }    
    
    return _pCtrl->get_accName(varChild, pszName);
}

STDMETHODIMP HWNDHostAccessible::put_accName(VARIANT varChild, BSTR szName)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->put_accName(varChild, szName);
}

STDMETHODIMP HWNDHostAccessible::get_accValue(VARIANT varChild, BSTR *pszValue)
{
    HRESULT hr;

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    // Give the host element the first chance
    if (SUCCEEDED(hr = DuiAccessible::get_accValue(varChild, pszValue))) {
        return hr;
    }    
    
    return _pCtrl->get_accValue(varChild, pszValue);
}

STDMETHODIMP HWNDHostAccessible::put_accValue(VARIANT varChild, BSTR pszValue)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->put_accValue(varChild, pszValue);
}

STDMETHODIMP HWNDHostAccessible::get_accDescription(VARIANT varChild, BSTR *pszDescription)
{
    HRESULT hr;

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    // Give the host element the first chance
    if (SUCCEEDED(hr = DuiAccessible::get_accDescription(varChild, pszDescription))) {
        return hr;
    }    
    
    return _pCtrl->get_accDescription(varChild, pszDescription);
}

STDMETHODIMP HWNDHostAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}

STDMETHODIMP HWNDHostAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accRole(varChild, pvarRole);
}

STDMETHODIMP HWNDHostAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accState(varChild, pvarState);
}

STDMETHODIMP HWNDHostAccessible::get_accHelp(VARIANT varChild, BSTR *pszHelp)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accHelp(varChild, pszHelp);
}

STDMETHODIMP HWNDHostAccessible::get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}

STDMETHODIMP HWNDHostAccessible::get_accFocus(VARIANT *pvarFocusChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accFocus(pvarFocusChild);
}

STDMETHODIMP HWNDHostAccessible::get_accSelection(VARIANT *pvarSelectedChildren)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accSelection(pvarSelectedChildren);
}

STDMETHODIMP HWNDHostAccessible::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accDefaultAction(varChild, pszDefaultAction);
}

STDMETHODIMP HWNDHostAccessible::Next(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pEnum->Next(celt, rgvar, pceltFetched);
}

STDMETHODIMP HWNDHostAccessible::Skip(unsigned long celt)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pEnum->Skip(celt);
}

STDMETHODIMP HWNDHostAccessible::Reset()
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pEnum->Reset();
}

STDMETHODIMP HWNDHostAccessible::Clone(IEnumVARIANT ** ppenum)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // This is a problem.
    //
    // We can only ever have one DuiAccessible connected to an Element at a
    // time.  This is because the Element is responsible for disconnecting
    // the DuiAccessible object when it is getting destroyed.  And since
    // IEnumVARIANT is implemented on DuiAccessible directly, we can't
    // create a separate instance of jsut the enumerator, but would have to
    // create a new instance of DuiAccessible itself.  Which means we can't
    // connect it to the element without disconnecting the other one or
    // risking a bogus pointer if the element ever gets deleted.
    //
    // Dang!
    //
    // We try to cheat and just return a clone of our control window's
    // IEnumVARIANT.  Hopefully, the client will not try to QI it back
    // to an IAccessible, because that will then circumvent our
    // implementation.
    //
    return _pEnum->Clone(ppenum);
}

STDMETHODIMP HWNDHostAccessible::GetWindow(HWND * phwnd)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pOleWindow == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pOleWindow->GetWindow(phwnd);
}

STDMETHODIMP HWNDHostAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pOleWindow == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pOleWindow->ContextSensitiveHelp(fEnterMode);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\element.cpp ===
/*
 * Element
 */

#include "stdafx.h"
#include "core.h"

#include "duielement.h"
#include "duiaccessibility.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Element

// Per-thread Element slot (initialized on main thread)
DWORD g_dwElSlot = (DWORD)-1;

#if DBG
// Process-wide Element count
LONG g_cElement = 0;
#endif

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Element, KeyboardNavigate)  // KeyboardNavigateEvent struct

void NavReference::Init(Element* pe, RECT* prc)
{
    cbSize = sizeof(NavReference);
    this->pe = pe;
    this->prc = prc;
}

HRESULT Element::Create(UINT nCreate, OUT Element** ppElement)
{
    *ppElement = NULL;

    Element* pe = HNew<Element>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nCreate);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

HRESULT Element::Initialize(UINT nCreate)
{
    HRESULT hr;

    _pvmLocal = NULL;
    _hgDisplayNode = NULL;

    // Accessibility
    _pDuiAccessible = NULL;

    // Listeners
    _ppel = NULL;

#if DBG
    // Store owner context and side-by-side instance for multithreading
    owner.hCtx = GetContext();
    owner.dwTLSSlot = g_dwElSlot;
#endif
    
    // Local storage
    hr = BTreeLookup<Value*>::Create(false, &_pvmLocal);
    if (FAILED(hr))
        goto Failed;

    // Defer table and index information
    _iGCSlot = -1;
    _iGCLPSlot = -1;
    _iPCTail = -1;
    _iIndex = -1;

    // Lifetime and native hosting flags
    _fBit.bDestroyed = false;
    _fBit.bHosted = false;

    // Indirect VE cache
    _fBit.bNeedsDSUpdate = false;
    _fBit.fNeedsLayout = LC_Pass;
    _fBit.bHasChildren = false;
    _fBit.bHasLayout = false;
    _fBit.bHasBorder = false;
    _fBit.bHasPadding = false;
    _fBit.bHasMargin = false;
    _fBit.bHasContent = false;
    _fBit.bDefaultCAlign = true;
    _fBit.bWordWrap = false;
    _fBit.bHasAnimation = false;
    _fBit.bDefaultCursor = true;
    _fBit.bDefaultBorderColor = true;
    _fBit.bDefaultForeground = true;
    _fBit.bDefaultFontWeight = true;
    _fBit.bDefaultFontStyle = true;

    // Self layout set
    _fBit.bSelfLayout = (nCreate & EC_SelfLayout) != 0;

    // Initialize cached and local property values to default (defaults are static, no ref counting)
    // Although LocalOnly and TriLevel properties don't use the 'default' value during
    // lookup, must do one-time initialization of these cached values using the default value

    // Local values
    _fBit.bLocKeyWithin = KeyWithinProp->pvDefault->GetBool();
    _fBit.bLocMouseWithin = MouseWithinProp->pvDefault->GetBool();
    _peLocParent = ParentProp->pvDefault->GetElement();
    _ptLocPosInLayt = *(PosInLayoutProp->pvDefault->GetPoint());
    _sizeLocSizeInLayt = *(SizeInLayoutProp->pvDefault->GetSize());
    _sizeLocLastDSConst = *(LastDSConstProp->pvDefault->GetSize());
    _sizeLocDesiredSize = *(DesiredSizeProp->pvDefault->GetSize());

    // Cached VE values
    _fBit.fSpecActive = ActiveProp->pvDefault->GetInt();
    _fBit.bSpecSelected = SelectedProp->pvDefault->GetBool();;
    _fBit.bSpecKeyFocused = KeyFocusedProp->pvDefault->GetBool();
    _fBit.bSpecMouseFocused = MouseFocusedProp->pvDefault->GetBool();
    _fBit.bCmpVisible = VisibleProp->pvDefault->GetBool();
    _fBit.bSpecVisible = VisibleProp->pvDefault->GetBool();;
    _fBit.nSpecDirection = DirectionProp->pvDefault->GetInt();
    _fBit.bSpecAccessible = AccessibleProp->pvDefault->GetBool();
    _fBit.bSpecEnabled = EnabledProp->pvDefault->GetBool();
    _dSpecLayoutPos = LayoutPosProp->pvDefault->GetInt();
    _pvSpecSheet = SheetProp->pvDefault;
    _atomSpecID = IDProp->pvDefault->GetAtom();
    _dSpecAlpha = AlphaProp->pvDefault->GetInt();

    // Create display node (gadget)
    if (!(nCreate & EC_NoGadgetCreate))
    {
        _hgDisplayNode = CreateGadget(NULL, GC_SIMPLE, _DisplayNodeCallback, this);
        if (!_hgDisplayNode)
        {
            hr = GetLastError();
            goto Failed;
        }

        SetGadgetMessageFilter(_hgDisplayNode, NULL, GMFI_PAINT|GMFI_CHANGESTATE, 
                GMFI_PAINT|GMFI_CHANGESTATE|GMFI_INPUTMOUSE|GMFI_INPUTMOUSEMOVE|GMFI_INPUTKEYBOARD|GMFI_CHANGERECT|GMFI_CHANGESTYLE);

        SetGadgetStyle(_hgDisplayNode, 
//                GS_RELATIVE,
                GS_RELATIVE|GS_OPAQUE,
                GS_RELATIVE|GS_HREDRAW|GS_VREDRAW|GS_OPAQUE|GS_VISIBLE|GS_KEYBOARDFOCUS|GS_MOUSEFOCUS);
    }

#if DBG
    // Track Element count
    InterlockedIncrement(&g_cElement);
#endif

    return S_OK;

Failed:

    if (_pvmLocal)
    {
        _pvmLocal->Destroy();
        _pvmLocal = NULL;
    }

    if (_hgDisplayNode)
    {
        DeleteHandle(_hgDisplayNode);
        _hgDisplayNode = NULL;
    }

    return hr;
}

// Value destroy
void _ReleaseValue(void* ppi, Value* pv)
{
    UNREFERENCED_PARAMETER(ppi);

    pv->Release();
}

Element::~Element()
{
    //
    // Break our link to the accessibility object!
    //
    if (_pDuiAccessible != NULL) {
        _pDuiAccessible->Disconnect();
        _pDuiAccessible->Release();
        _pDuiAccessible = NULL;
    }

    // Free storage
    if (_pvmLocal)
        _pvmLocal->Destroy();
}

// Element is about to be destroyed
void Element::OnDestroy()
{
    DUIAssert(!_fBit.bDestroyed, "OnDestroy called more than once");

    // Match Element/Gadget hierarchies immediately

    // Display node is being destroyed, prepare for the final destruction method
    _fBit.bDestroyed = true;

    // Manually mark parent as NULL, unless this is the root of the
    // destruction. If so, it was removed normally to allow property updates.
    // Update parent's child list as well
    Element* peParent = GetParent();
    if (peParent)
    {
        // Destruction code, relies on pre-Remove of Elements (other half in Element::Destroy)

        // Unparent, parent is destroyed prior to this call
        DUIAssert(peParent->IsDestroyed(), "Parent should already be destroyed");

        // Manual parent update. Cached, inherited VE values are no longer valid due to
        // this manual unparenting. The only cached-inherited value this could be
        // destructive to is the property sheet. This pointer may no longer be valid.
        // Since destruction order only guarantees destroy "final" occurs after
        // destroy "start" of subtree, a child may have a cached property sheet that
        // is not valid. So, the property sheet Value is cached and ref counted (the
        // content (pointer) is not cached directly -- unlike all other cached values)
        _peLocParent = NULL;

        // Manual parent child update
        Value** ppv = peParent->_pvmLocal->GetItem(ChildrenProp);  // No ref count
        DUIAssert(ppv, "Parent/child destruction mismatch");

        ElementList* peList = (*ppv)->GetElementList();

        DUIAssert((*ppv)->GetElementList()->GetItem(GetIndex()) == this, "Parent/child index mismatch");

        // If this is the only child, destroy the list, otherwise, remove the item
        if (peList->GetSize() == 1)
        {
            // Release first since pointer may change when value is removed
            // since data structure is changing
            (*ppv)->Release();
            peParent->_pvmLocal->Remove(ChildrenProp);
        }
        else
        {
            peList->MakeWritable();
            peList->Remove(GetIndex());
            peList->MakeImmutable();

            // Update remaining child indicies, if necessary
            if (GetIndex() < (int)peList->GetSize())
            {
                for (UINT i = GetIndex(); i < peList->GetSize(); i++)
                    peList->GetItem(i)->_iIndex--;
            }

            // The parent's layout may now have invalid "ignore child" indicies for
            // absolute and none layout information. Do not update since not visible
            // and not unstable
#if DBG
            // Ensure all indicies were property sequenced
            for (UINT s = 0; s < peList->GetSize(); s++)
                DUIAssert(peList->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a manual child remove failed");
#endif
        }

        // Parent's child list was manually updated in order to quickly tear down
        // the tree (no formal property change). Normally, a change of children would cause
        // an OnAdd/OnRemove for the parent's layout. This notification happens in direct
        // result of an OnPropertyChange of children. Force an OnRemove now to keep
        // state up-to-date.
        Value* pvLayout;
        Layout* pl = peParent->GetLayout(&pvLayout);
        if (pl)
        {
            Element* peRemoving = this;
            pl->OnRemove(peParent, &peRemoving, 1);
        }
        pvLayout->Release();

        // Update index
        _iIndex = -1;
    }

    // Remove listeners
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];

        IElementListener** ppelOld = _ppel;
        _ppel = NULL;

        for (UINT_PTR i = 1; i <= cListeners; i++)
            ppelOld[i]->OnListenerDetach(this);

        HFree(ppelOld);
    }
}

////////////////////////////////////////////////////////
// End deferring

void Element::_FlushDS(Element* pe, DeferCycle* pdc)
{
    // Locate all nodes that require a Desired Size update in a tree. Mark all nodes above these
    // queued nodes as needing a Desired Size update as well. Then, call UpdateDesiredSize with 
    // specfied value constraints on node that has no parent/non-absolute (a "DS Root").
    // DFS from root happens by layouts having to call UpdateDesiredSize on all non-absolute children

    int dLayoutPos;

    Value* pvChildren;

    ElementList* pel = pe->GetChildren(&pvChildren);
    
    if (pel)
    {
        Element* peChild;
        for (UINT i = 0; i < pel->GetSize(); i++)
        {
            peChild = pel->GetItem(i);

            dLayoutPos = peChild->GetLayoutPos();

            if (dLayoutPos != LP_Absolute)
                _FlushDS(peChild, pdc);
        }
    }

    // Returning from children (if any), if this is a "DS Root", call UpdateDesiredSize to
    // cause a DFS (2nd pass) to compute desired size
    Element* peParent = pe->GetParent();

    dLayoutPos = pe->GetLayoutPos();
    
    if (!peParent || dLayoutPos == LP_Absolute)
    {
        // Roots get their specified size
        int dWidth = pe->GetWidth();
        int dHeight = pe->GetHeight();

        // Reuse DC for renderer during update
        // Use NULL handle since may not be visible (no display node)
        // Have constraints at DS Root, update desired size of children

        HDC hDC = GetDC(NULL);

        {
#ifdef GADGET_ENABLE_GDIPLUS
            Gdiplus::Graphics gpgr(hDC);
            GpSurface srf(&gpgr);
            pe->_UpdateDesiredSize((dWidth == -1) ? INT_MAX : dWidth, (dHeight == -1) ? INT_MAX : dHeight, &srf);
#else
            DCSurface srf(hDC);
            pe->_UpdateDesiredSize((dWidth == -1) ? INT_MAX : dWidth, (dHeight == -1) ? INT_MAX : dHeight, &srf);
#endif
        }

        ReleaseDC(NULL, hDC);
    }
    else
    {
        // Not a DS Root, mark parent as needing DS update if this node needs it
        if (pe->_fBit.bNeedsDSUpdate)
            peParent->_fBit.bNeedsDSUpdate = true;
    }

    pvChildren->Release();
}

void Element::_FlushLayout(Element* pe, DeferCycle* pdc)
{
    // Perform a DFS on a tree and Layout nodes if they have a Layout queued. As laying out,
    // childrens' size and position may change. If size changes (Extent), a layout is queued
    // on that child. Children will lay out during the same pass of the tree as a result (1-pass)

    Value* pv;

    if (pe->_fBit.fNeedsLayout)
    {
        DUIAssert(pe->_fBit.fNeedsLayout == LC_Normal, "Optimized layout bit should have been cleared before the flush");  // Must not be LC_Optimize

        pe->_fBit.fNeedsLayout = LC_Pass;

        Value* pvLayout;
        Layout* pl = pe->GetLayout(&pvLayout);

        if (pe->IsSelfLayout() || pl)
        {
            const SIZE* ps = pe->GetExtent(&pv);
            int dLayoutW = ps->cx;
            int dLayoutH = ps->cy;
            pv->Release();

            // Box model, subtract off border and padding from total extent
            const RECT* pr = pe->GetBorderThickness(&pv);  // Border thickness
            dLayoutW -= pr->left + pr->right;
            dLayoutH -= pr->top + pr->bottom;
            pv->Release();

            pr = pe->GetPadding(&pv);  // Padding
            dLayoutW -= pr->left + pr->right;
            dLayoutH -= pr->top + pr->bottom;
            pv->Release();

            // Higher priority border and padding may cause layout size to go negative
            if (dLayoutW < 0)
                dLayoutW = 0;

            if (dLayoutH < 0)
                dLayoutH = 0;

            if (pe->IsSelfLayout())  // Self layout gets precidence
            {
                pe->_SelfLayoutDoLayout(dLayoutW, dLayoutH);
            }
            else
            {
                pl->DoLayout(pe, dLayoutW, dLayoutH);
            }
        }

        pvLayout->Release();
    }

    // Layout non-absolute children (all non-Root children). If a child has a layout
    // position of none, set its size and position to zero and skip
    int dLayoutPos;
    Value* pvList;
    ElementList* peList = pe->GetChildren(&pvList);

    if (peList)
    {
        Element* peChild;
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peChild = peList->GetItem(i);

            dLayoutPos = peChild->GetLayoutPos();
            
            if (dLayoutPos == LP_None)
            {
                peChild->_UpdateLayoutPosition(0, 0);
                peChild->_UpdateLayoutSize(0, 0);
            }
            else if (dLayoutPos != LP_Absolute)
                _FlushLayout(peChild, pdc);
        }
    }

    pvList->Release();
}

SIZE Element::_UpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    // Given constraints, return what size Element would like to be (and cache information).
    // Returned size is no larger than constraints passed in

    SIZE sizeDesired;

    DUIAssert(cxConstraint >= 0 && cyConstraint >= 0, "Constraints must be greater than or equal to zero");
    bool bChangedConst = (_sizeLocLastDSConst.cx != cxConstraint) || (_sizeLocLastDSConst.cy != cyConstraint);
    Value* pv;

    if (_fBit.bNeedsDSUpdate || bChangedConst)
    {
        _fBit.bNeedsDSUpdate = false;

        if (bChangedConst)
        {
            Value* pvOld = Value::CreateSize(_sizeLocLastDSConst.cx, _sizeLocLastDSConst.cy);
            pv = Value::CreateSize(cxConstraint, cyConstraint);

            _PreSourceChange(LastDSConstProp, PI_Local, pvOld, pv);

            _sizeLocLastDSConst.cx = cxConstraint;
            _sizeLocLastDSConst.cy = cyConstraint;

            _PostSourceChange();

            pvOld->Release();
            pv->Release();
        }
        
        // Update desired size cache since it was marked as dirty or a new constraint is being used
        int cxSpecified = GetWidth();
        if (cxSpecified > cxConstraint)
            cxSpecified = cxConstraint;

        int cySpecified = GetHeight(); 
        if (cySpecified > cyConstraint)
            cySpecified = cyConstraint;

        sizeDesired.cx = (cxSpecified == -1) ? cxConstraint : cxSpecified;
        sizeDesired.cy = (cySpecified == -1) ? cyConstraint : cySpecified;

        // KEY POINT:  One would think that, at this point, if a size is specified for both the width and height,
        // then there is no need to go through the rest of the work here to ask what the desired size for the 
        // element is.  Looking at the math here, that is completely true.  The key is that the "get desired size"
        // calls below have the side effect of recursively caching the desired sizes of the descendants of this
        // element.
        //
        // A perf improvement going forward would be allowing the specified width and height case to bail early,
        // and have the computing and caching of descendant desired sizes happening as needed at a later point.


        // Initial DS is spec value if unconstrained (auto). If constrained and spec value is "auto",
        // dimension can be constrained or lesser value. If constrained and spec value is larger, use constraint
        
        // Adjusted constrained dimensions for passing to renderer/layout
        int cxClientConstraint = sizeDesired.cx;
        int cyClientConstraint = sizeDesired.cy;

        // Get constrained desired size of border and padding (box model)
        SIZE sizeNonContent;

        const RECT* pr = GetBorderThickness(&pv); // Border thickness
        sizeNonContent.cx = pr->left + pr->right;
        sizeNonContent.cy = pr->top + pr->bottom;
        pv->Release();

        pr = GetPadding(&pv); // Padding
        sizeNonContent.cx += pr->left + pr->right;
        sizeNonContent.cy += pr->top + pr->bottom;
        pv->Release();

        cxClientConstraint -= sizeNonContent.cx;
        if (cxClientConstraint < 0)
        {
            sizeNonContent.cx += cxClientConstraint;
            cxClientConstraint = 0;
        }

        cyClientConstraint -= sizeNonContent.cy;
        if (cyClientConstraint < 0)
        {
            sizeNonContent.cy += cyClientConstraint;
            cyClientConstraint = 0;
        }

        SIZE sizeContent;

        // Get content constrained desired size

        if (IsSelfLayout()) // Element has self-layout, use it
            sizeContent = _SelfLayoutUpdateDesiredSize(cxClientConstraint, cyClientConstraint, psrf);
        else // No self-layout, check for external layout
        {
            Layout* pl = GetLayout(&pv);

            if (pl)
                sizeContent = pl->UpdateDesiredSize(this, cxClientConstraint, cyClientConstraint, psrf);
            else // No layout, ask renderer
                sizeContent = GetContentSize(cxClientConstraint, cyClientConstraint, psrf);

            pv->Release();
        }

        // validate content desired size
        // 0 <= cx <= cxConstraint
        // 0 <= cy <= cyConstraint
        if (sizeContent.cx < 0)
        {
            sizeContent.cx = 0;
            DUIAssertForce("Out-of-range value:  Negative width for desired size.");
        }
        else if (sizeContent.cx > cxClientConstraint)
        {
            sizeContent.cx = cxClientConstraint;
            DUIAssertForce("Out-of-range value:  Width greater than constraint for desired size.");
        }

        if (sizeContent.cy < 0)
        {
            sizeContent.cy = 0;
            DUIAssertForce("Out-of-range value:  Negative height for desired size.");
        }
        else if (sizeContent.cy > cyClientConstraint)
        {
            sizeContent.cy = cyClientConstraint;
            DUIAssertForce("Out-of-range value:  Height greater than constraint for desired size.");
        }

        // New desired size is sum of border/padding and content dimensions if auto,
        // or if was auto and constrained, use sum if less
        if (cxSpecified == -1)
        {
            int cxSum = sizeNonContent.cx + sizeContent.cx;
            if (cxSum < sizeDesired.cx)
                sizeDesired.cx = cxSum;
        }

        if (cySpecified == -1)
        {
            int cySum = sizeNonContent.cy + sizeContent.cy;
            if (cySum < sizeDesired.cy)
                sizeDesired.cy = cySum;
        }

        Value* pvOld = Value::CreateSize(_sizeLocDesiredSize.cx, _sizeLocDesiredSize.cy);
        pv = Value::CreateSize(sizeDesired.cx, sizeDesired.cy);

        _PreSourceChange(DesiredSizeProp, PI_Local, pvOld, pv);

        _sizeLocDesiredSize = sizeDesired;

        _PostSourceChange();

        pvOld->Release();
        pv->Release();
    }
    else
        // Desired size doesn't need to be updated, return current
        sizeDesired = *GetDesiredSize();

    return sizeDesired;
}

// Called within a Layout cycle
void Element::_UpdateLayoutPosition(int dX, int dY)
{
#if DBG
    // _UpdateLayoutPosition is only valid inside a layout cycle

    // Per-thread storage
    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
    DUIAssert(pdc, "Defer cycle table doesn't exist");

    DUIAssert(pdc->cPCEnter == 0, "_UpdateLayoutPosition must only be used within DoLayout");
#endif

    // Cached value
    if (_ptLocPosInLayt.x != dX || _ptLocPosInLayt.y != dY)
    {
        Value* pvOld = Value::CreatePoint(_ptLocPosInLayt.x, _ptLocPosInLayt.y);
        Value* pvNew = Value::CreatePoint(dX, dY);

        _PreSourceChange(PosInLayoutProp, PI_Local, pvOld, pvNew);

        _ptLocPosInLayt.x = dX;
        _ptLocPosInLayt.y = dY;

        _PostSourceChange();  // Will never queue a Layout GPC due to a change in PosInLayout

        pvOld->Release();
        pvNew->Release();
    }
}

// Called within a Layout cycle
void Element::_UpdateLayoutSize(int dWidth, int dHeight)
{
#if DBG
    // _UpdateLayoutSize is only valid inside a layout cycle.
    // Optimized layout Q requires a call from outsize any OnPropertyChanged since
    // the _PostSourceChange must queue GPCs (outter-most) so that "affects-layout"
    // may be cancelled

    // Per-thread storage
    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
    DUIAssert(pdc, "Defer cycle table doesn't exist");

    DUIAssert(pdc->cPCEnter == 0, "_UpdateLayoutSize must only be used within DoLayout");
    DUIAssert(dWidth >= 0 && dHeight >= 0, "New child size must be greater than or equal to zero");
#endif

    if (_sizeLocSizeInLayt.cx != dWidth || _sizeLocSizeInLayt.cy != dHeight)
    {
        _StartOptimizedLayoutQ();
        //DUITrace("Optimized Layout Q for <%x>\n"), this);

        // Cached value
        Value* pvOld = Value::CreateSize(_sizeLocSizeInLayt.cx, _sizeLocSizeInLayt.cy);
        Value* pvNew = Value::CreateSize(dWidth, dHeight);

        _PreSourceChange(SizeInLayoutProp, PI_Local, pvOld, pvNew);

        _sizeLocSizeInLayt.cx = dWidth;
        _sizeLocSizeInLayt.cy = dHeight;

        _PostSourceChange();

        pvOld->Release();
        pvNew->Release();

        _EndOptimizedLayoutQ();
    }
}

////////////////////////////////////////////////////////
// Self-layout methods (must be overridden if was created with EC_SelfLayout)

void Element::_SelfLayoutDoLayout(int dWidth, int dHeight)
{
    UNREFERENCED_PARAMETER(dWidth);
    UNREFERENCED_PARAMETER(dHeight);

    DUIAssertForce("Must override");
}

SIZE Element::_SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(dConstW);
    UNREFERENCED_PARAMETER(dConstH);
    UNREFERENCED_PARAMETER(psrf);

    DUIAssertForce("Must override");

    SIZE size = { 0, 0 };

    return size;
}

////////////////////////////////////////////////////////
// Generic eventing

// pEvent target and handled fields set this method automatically
// Full will route and bubble
void Element::FireEvent(Event* pEvent, bool fFull)
{
    DUIAssert(pEvent, "Invalid parameter: NULL");

    // Package generic event into a gadget message and send to target (self)
    GMSG_DUIEVENT gmsgEv;
    gmsgEv.cbSize = sizeof(GMSG_DUIEVENT);
    gmsgEv.nMsg = GM_DUIEVENT;
    gmsgEv.hgadMsg = GetDisplayNode();  // this

    // Auto-initialize fields
    pEvent->peTarget = this;
    pEvent->fHandled = false;

    gmsgEv.pEvent = pEvent;

    DUserSendEvent(&gmsgEv, fFull ? SGM_FULL : 0);
}

HRESULT Element::QueueDefaultAction()
{
    // Package generic event into a gadget message and post to target (self)
    EventMsg gmsg;
    gmsg.cbSize = sizeof(GMSG);
    gmsg.nMsg = GM_DUIACCDEFACTION;
    gmsg.hgadMsg = GetDisplayNode();  // this

    return DUserPostEvent(&gmsg, 0);  // Direct
}

void Element::OnEvent(Event* pEvent)
{
    if ((pEvent->nStage == GMF_BUBBLED) || (pEvent->nStage == GMF_DIRECT))
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
            Element* peTo = NULL;

            NavReference nr;
            nr.Init(pEvent->peTarget, NULL);

            Element* peFrom = (pEvent->peTarget == this) ? this : GetImmediateChild(pEvent->peTarget);

            // todo:  leverage from DCD navigation
            // Three cases:
            // 1) Directional navigation: Call Control's getNearestDirectional.
            // 2) Logical forward navigation: Call getAdjacent. Nav'ing into the guy.
            // 3) Logical backward navigation: Return null, 'cause we'll want to go
            //    up a level. We're nav'ing back OUT of the guy.
            peTo = GetAdjacent(peFrom, ((KeyboardNavigateEvent*) pEvent)->iNavDir, &nr, true);

            if (peTo)
            {
                peTo->SetKeyFocus();
                pEvent->fHandled = true;
                return;
            }    
        }
    }

    // Inform listeners for all stages
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT_PTR i = 1; i <= cListeners; i++)
        {
            // Callback
            _ppel[i]->OnListenedEvent(this, pEvent);

            if (pEvent->fHandled)
                break;
        }
    }
}

////////////////////////////////////////////////////////
// System input event

// Pointer is only guaranteed good for the lifetime of the call
void Element::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                int iNavDir = -1;

                switch (pke->nCode)
                {
                case GKEY_DOWN:
                    switch (pke->ch)
                    {
                        case VK_DOWN:   iNavDir = NAV_DOWN;     break;
                        case VK_UP:     iNavDir = NAV_UP;       break;
                        case VK_LEFT:   iNavDir = (!IsRTL()) ? NAV_LEFT : NAV_RIGHT; break;
                        case VK_RIGHT:  iNavDir = (!IsRTL()) ? NAV_RIGHT : NAV_LEFT; break;
                        case VK_HOME:   iNavDir = NAV_FIRST;    break;   // todo:  check for ctrl modifier
                        case VK_END:    iNavDir = NAV_LAST;     break;   // todo:  check for ctrl modifier
                        case VK_TAB:    pke->fHandled = true;   return;  // eat the down -- we'll handle this one on GKEY_CHAR
                    }
                    break;

                /*
                case GKEY_UP:
                    return;
                */            

                case GKEY_CHAR:
                    if (pke->ch == VK_TAB)
                        iNavDir = (pke->uModifiers & GMODIFIER_SHIFT) ? NAV_PREV : NAV_NEXT;
                    break;
                }

                if (iNavDir != -1)
                {
                    DUIAssert(pie->peTarget->GetKeyWithin(), "Key focus should still be in this child");

                    KeyboardNavigateEvent kne;
                    kne.uidType = Element::KeyboardNavigate;
                    kne.peTarget = pie->peTarget;
                    kne.iNavDir = iNavDir;

                    pie->peTarget->FireEvent(&kne);  // Will route and bubble
                    pie->fHandled = true;
                    return;
                }
                break;
            }
        }
    }

    // Inform listeners for all stages
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT_PTR i = 1; i <= cListeners; i++)
        {
            // Callback
            _ppel[i]->OnListenedInput(this, pie);

            if (pie->fHandled)
                break;
        }
    }
}

void Element::OnKeyFocusMoved(Element* peFrom, Element* peTo)
{
    UNREFERENCED_PARAMETER(peFrom);

    Element* peParent = peTo;

    while (peParent)
    {
        if (peParent == this)
            break;
        peParent = peParent->GetParent();
    }

    if (peParent == this)
    {
        if (!GetKeyWithin())
        {
            _PreSourceChange(KeyWithinProp, PI_Local, Value::pvBoolFalse, Value::pvBoolTrue);
            _fBit.bLocKeyWithin = true;
            _PostSourceChange();
        }
    }
    else // (peParent == NULL)
    {
        if (GetKeyWithin())
        {
            _PreSourceChange(KeyWithinProp, PI_Local, Value::pvBoolTrue, Value::pvBoolFalse);
            _fBit.bLocKeyWithin = false;
            _PostSourceChange();
        }
    }
}

void Element::OnMouseFocusMoved(Element* peFrom, Element* peTo)
{
    UNREFERENCED_PARAMETER(peFrom);

    Element* peParent = peTo;

    while (peParent)
    {
        if (peParent == this)
            break;
        peParent = peParent->GetParent();
    }

    if (peParent == this)
    {
        if (!GetMouseWithin())
        {
            _PreSourceChange(MouseWithinProp, PI_Local, Value::pvBoolFalse, Value::pvBoolTrue);
            _fBit.bLocMouseWithin = true;
            _PostSourceChange();
        }
    }
    else // (peParent == NULL)
    {
        if (GetMouseWithin())
        {
            _PreSourceChange(MouseWithinProp, PI_Local, Value::pvBoolTrue, Value::pvBoolFalse);
            _fBit.bLocMouseWithin = false;
            _PostSourceChange();
        }
    }
}

////////////////////////////////////////////////////////
// Hosting system event callbacks and retrieval

// Now being hosted by a native root, fire event on children as well
void Element::OnHosted(Element* peNewHost)
{
    DUIAssert(!IsHosted(), "OnHosted event fired when already hosted");

    _fBit.bHosted = true;

    //DUITrace("Hosted: <%x,%S>\n", this, GetClassInfo()->GetName());

    Value* pv;
    ElementList* peList = GetChildren(&pv);
    if (peList)
        for (UINT i = 0; i < peList->GetSize(); i++)
            peList->GetItem(i)->OnHosted(peNewHost);
    pv->Release();
}

// No longer being hosted by a native root, fire event on children as well
void Element::OnUnHosted(Element* peOldHost)
{
    DUIAssert(IsHosted(), "OnUnhosted event fired when already un-hosted");

    _fBit.bHosted = false;

    //DUITrace("UnHosted: <%x,%S>\n", this, GetClassInfo()->GetName());

    Value* pv;
    ElementList* peList = GetChildren(&pv);
    if (peList)
        for (UINT i = 0; i < peList->GetSize(); i++)
            peList->GetItem(i)->OnUnHosted(peOldHost);
    pv->Release();
}

////////////////////////////////////////////////////////
// Element tree methods

HRESULT Element::Add(Element* pe)
{
    DUIAssert(pe, "Invalid parameter: NULL");

    return Add(&pe, 1);
}

HRESULT Element::Add(Element** ppe, UINT cCount)
{
    DUIAssert(ppe, "Invalid parameter: NULL");

    Value* pv;
    ElementList* pel = GetChildren(&pv);

    HRESULT hr = Insert(ppe, cCount, (pel) ? pel->GetSize() : 0);

    pv->Release();

    return hr;
}

// Insertion at end of list requires iInsIndex equal to size of list
HRESULT Element::Insert(Element* pe, UINT iInsertIdx)
{
    DUIAssert(pe, "Invalid parameter: NULL");

    return Insert(&pe, 1, iInsertIdx);
}

// insert to same parent, after current location in childlist, causes a fault
// i.e. child at index 0, inserted again at index 1, indices are off
// fix:
//   int iInsertionIndex = iInsertIdx;
//   for (i = 0; i < cCount; i++)
//   {
//       Element* pe = ppe[i];
//       if ((pe->GetParent() == this) && (pe->GetIndex < iInsertIdx))
//           iInsertionIndex--;
//   }
//

// Insertion at end of list requires iInsIndex equal to size of list
HRESULT Element::Insert(Element** ppe, UINT cCount, UINT iInsertIdx)
{
    DUIAssert(ppe, "Invalid parameter: NULL");

    HRESULT hr;

    // Values to free on failure
    ElementList* pelNew = NULL;
    Value* pvOldList = NULL;
    Value* pvNewList = NULL;
    Value* pvNewParent = NULL;
    bool fEndDeferOnFail = false;

    // Get current Children list
    ElementList* pelOld = GetChildren(&pvOldList);

    DUIAssert(iInsertIdx <= ((pelOld) ? pelOld->GetSize() : 0), "Invalid insertion index");

    // Create new Children list
    hr = (pelOld) ? pelOld->Clone(&pelNew) : ElementList::Create(cCount, false, &pelNew);
    if (FAILED(hr))
        goto Failed;

    UINT i;

    // Allocate space in list
    // TODO: Bulk insert
    for (i = 0; i < cCount; i++)
    {
        hr = pelNew->Insert(iInsertIdx + i, NULL);  // Items will be set later
        if (FAILED(hr))
            goto Failed;
    }

    // New child list value
    pvNewList = Value::CreateElementList(pelNew);
    if (!pvNewList)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    // New parent value
    pvNewParent = Value::CreateElementRef(this);
    if (!pvNewParent)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    // Update tree
    StartDefer();

    // If fail after this point, make sure to do an EndDefer
    fEndDeferOnFail = true;

    // Children must be removed from previous parent (if has one)
    for (i = 0; i < cCount; i++)
    {
        if (ppe[i]->GetParent())
        {
            hr = ppe[i]->GetParent()->Remove(ppe[i]);
            if (FAILED(hr))
                goto Failed;
        }
    }

    pelNew->MakeWritable();
    for (i = 0; i < cCount; i++)
    {
        DUIAssert(ppe[i] != this, "Cannot set parent to self");
        DUIAssert(ppe[i]->GetIndex() == -1, "Child's index must be reset to -1 before it's inserted");

        // TODO: Bulk insert
        pelNew->SetItem(iInsertIdx + i, ppe[i]);
        ppe[i]->_iIndex = iInsertIdx + i;
    }
    pelNew->MakeImmutable();

    // Update remaining indicies
    for (i = iInsertIdx + cCount; i < pelNew->GetSize(); i++)
        pelNew->GetItem(i)->_iIndex = i;

    // Set children list (it is read-only, use internal set since property is Normal type)
    // Partial fail means Value was set but dependency sync/notifications were incomplete
    hr = _SetValue(ChildrenProp, PI_Local, pvNewList, true);
    if (FAILED(hr) && (hr != DUI_E_PARTIAL))
    {
        // Re-sequence indicies of children since failed to change from original child list
        for (i = 0; i < pelOld->GetSize(); i++)
            pelOld->GetItem(i)->_iIndex = i;
            
        goto Failed;
    }

#if DBG
    // Ensure all indicies were property sequenced
    for (UINT s = 0; s < pelNew->GetSize(); s++)
        DUIAssert(pelNew->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a child insert failed");
#endif

    pvOldList->Release();
    pvNewList->Release();

    // Set child's parent (it is read-only, set value directly since property is LocalOnly type)
    // Operation will not fail to set correct parent (member on Element)
    for (i = 0; i < cCount; i++)
    {
        DUIAssert(!ppe[i]->GetParent(), "Child's parent should be NULL before its parent is set");  // Should be NULL

        ppe[i]->_PreSourceChange(ParentProp, PI_Local, Value::pvElementNull, pvNewParent);

        ppe[i]->_peLocParent = this;

        ppe[i]->_PostSourceChange();
    }
    pvNewParent->Release();

    EndDefer();

    return S_OK;

Failed:

    if (pvOldList)
    {
        pvOldList->Release();
        pvOldList = NULL;
    }

    if (pvNewList)
    {
        pvNewList->Release();
        pvNewList = NULL;
    }
    else
        pelNew->Destroy(); // Release on Value-owner will automatically destroy the ElementList
    pelNew = NULL;

    if (pvNewParent)
    {
        pvNewParent->Release();
        pvNewParent = NULL;
    }

    if (fEndDeferOnFail)
        EndDefer();

    return hr;
}

HRESULT Element::Add(Element* pe, CompareCallback lpfnCompare)
{
    UNREFERENCED_PARAMETER(pe);
    UNREFERENCED_PARAMETER(lpfnCompare);

    Value* pvChildren;
    ElementList* pel = GetChildren(&pvChildren);

    UINT i = 0;
    if (pel)
    {
        // simple linear search right now -- can easily make into a binary search
        while (i < pel->GetSize())
        {
            Element* peCheck = pel->GetItem(i);
            if (lpfnCompare(&pe, &peCheck) < 0)
                break;
            i++;
        }
    }

    pvChildren->Release();

    return Insert(pe, i);
}

HRESULT Element::SortChildren(CompareCallback lpfnCompare)
{
    HRESULT hr;

    // Values to free on failure
    ElementList* pelNew = NULL;
    Value* pvList = NULL;

    // Get current Children list
    ElementList* pelOld = GetChildren(&pvList);

    if (!pelOld || (pelOld->GetSize() <= 1))
    {
        pvList->Release();
        return S_OK;
    }

    // Create new Children list
    hr = pelOld->Clone(&pelNew);
    if (FAILED(hr))
        goto Failed;

    pvList->Release();

    // New child list value
    pvList = Value::CreateElementList(pelNew);
    if (!pvList)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    // Update tree
    StartDefer();

    pelNew->Sort(lpfnCompare);

    for (UINT i = 0; i < pelNew->GetSize(); i++)
        ((Element*) pelNew->GetItem(i))->_iIndex = i;

    // Set children list (it is read-only, use internal set since property is Normal type)
    _SetValue(ChildrenProp, PI_Local, pvList, true);

#if DBG
    // Ensure all indicies were property sequenced
    for (UINT s = 0; s < pelNew->GetSize(); s++)
        DUIAssert(pelNew->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a child insert failed");
#endif

    pvList->Release();

    EndDefer();

    return S_OK;

Failed:

    if (pvList)
        pvList->Release();
    else
        pelNew->Destroy(); // Release on Value-owner will automatically destroy the ElementList

    return hr;
}

HRESULT Element::Remove(Element* pe)
{
    DUIAssert(pe, "Invalid parameter: NULL");

    return Remove(&pe, 1);
}

HRESULT Element::RemoveAll()
{
    HRESULT hr = S_OK;

    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);

    if (peList)
    {
        peList->MakeWritable();
        hr = Remove(peList->GetItemPtr(0), peList->GetSize());  // Access list directly
        peList->MakeImmutable();
    }

    pvChildren->Release();

    return hr;
}

HRESULT Element::Remove(Element** ppe, UINT cCount)
{
    DUIAssert(ppe, "Invalid parameter: NULL");

    HRESULT hr;

    Value* pvOld;
    int iLowest = INT_MAX;
    int iIndex = -1;
    bool fEndDeferOnFail = false;

    // Get current Children list
    ElementList* pelOld = GetChildren(&pvOld);

    DUIAssert(pelOld, "Element has no children");

    // Values to free on failure
    ElementList* pelNew = NULL;
    Value* pvNew = NULL;

    // Create new Children list (copy old)
    hr = pelOld->Clone(&pelNew);
    if (FAILED(hr))
        goto Failed;

    // Update list, remove Elements and track lowest index changed

    UINT i;
    for (i = 0; i < cCount; i++)
    {
        //DUITrace("Normal Remove of: <%x>\n", ppe[i]);

        DUIAssert(ppe[i] != this, "Cannot set parent to self");
        DUIAssert(ppe[i]->GetParent() == this, "Not a child of this Element");

        // GetIndex() is valid for Elements with indicies less than the smallest index removed
        if (ppe[i]->GetIndex() < iLowest)
        {
            iIndex = ppe[i]->GetIndex();  // Faster lookup
            iLowest = iIndex;
        }
        else
            iIndex = pelNew->GetIndexOf(ppe[i]);
                    
        pelNew->Remove(iIndex);
    }

    // If all the children were removed, make list NULL
    if (!pelNew->GetSize())
    {
        pelNew->Destroy();
        pelNew = NULL;
        pvNew = Value::pvElListNull;
    }
    else
    {
        pvNew = Value::CreateElementList(pelNew);
        if (!pvNew)
        {
            hr = E_OUTOFMEMORY;
            goto Failed;
        }
    }

    // Update indicies of children removed
    for (i = 0; i < cCount; i++)
        ppe[i]->_iIndex = -1;
    
    // Update tree
    StartDefer();

    // If fail after this point, make sure to do an EndDefer
    fEndDeferOnFail = true;

    // Reset child indicies of remaining children starting at lowest index changed
    if (pelNew)
    {
        for (i = iLowest; i < pelNew->GetSize(); i++)
            pelNew->GetItem(i)->_iIndex = i;

        // Set children list (it is read-only, use internal set since property is Normal type)
        // Partial fail means Value was set but dependency sync/notifications were incomplete        
        hr = _SetValue(ChildrenProp, PI_Local, pvNew, true);
    }
    else
    {
        // No children, remove local value
        hr = _RemoveLocalValue(ChildrenProp);
    }

    if (FAILED(hr) && (hr != DUI_E_PARTIAL))
    {
        // Re-sequence indicies of children since failed to change from original child list
        for (i = 0; i < pelOld->GetSize(); i++)
            pelOld->GetItem(i)->_iIndex = i;
    
        goto Failed;
    }

#if DBG
    // Ensure all indicies were property sequenced
    if (pelNew)
    {
        for (UINT s = 0; s < pelNew->GetSize(); s++)
            DUIAssert(pelNew->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a child remove failed");
    }
#endif

    pvOld->Release();
    pvNew->Release();

    // Set child parent to NULL (it is read-only, set value directly since property is LocalOnly type)
    // Operation will not fail to set correct parent (member on Element)
    for (i = 0; i < cCount; i++)
    {
        pvOld = ppe[i]->GetValue(ParentProp, PI_Local);

        DUIAssert(pvOld->GetElement(), "Child's old parent when inserting should be NULL");

        ppe[i]->_PreSourceChange(ParentProp, PI_Local, pvOld, Value::pvElementNull);

        ppe[i]->_peLocParent = NULL;

        ppe[i]->_PostSourceChange();

        pvOld->Release();
    }

    EndDefer();

    return S_OK;

Failed:
    
    if (pvOld)
    {
        pvOld->Release();
        pvOld = NULL;
    }

    if (pvNew)
    {
        pvNew->Release();
        pvNew = NULL;
    }
    else
        pelNew->Destroy(); // Release on Value-owner will automatically destroy the ElementList
    pelNew = NULL;

    if (fEndDeferOnFail)
        EndDefer();

    return hr;
}

// Destroy this Element. Must not use delete operator to destroy Elements.
// A delayed destroy uses a posted message to delay the actual DeleteHandle.
// Care must be taken to not pump messages when notifications may be pending
// (i.e. in a defer cycle).
//
// If an Element is destroyed with pending notifications, the notifications
// will be lost.
//
// Deferred destruction allows:
//   1) Calling destroy on self within a callback on the Element
//   2) Processing of all nofictaions before destruction (as long
//      as messages aren't pumped within a defer cycle)

HRESULT Element::Destroy(bool fDelayed)
{
    HRESULT hr = S_OK;

    // Check to see what type of destruction is allowed. If the Element's Initialize
    // succeeds, a standard destruction is used (since a display node exits -- all
    // destruction is driven by the Gadget). However, if Element's Initialize fails,
    // then no display node is available. Direct deletion is then required.
    if (!GetDisplayNode())
    {
        // Destruction is immidiate, regardless of fDelayed if no
        // display node is present
        HDelete<Element>(this);
        return S_OK;
    }

    // New destruction code, relies on pre-Remove of Elements (other half in Element::OnDestroy)
    // Root of destruction, remove from parent (if exists)
    Element* peParent = GetParent();
    if (peParent)
        hr = peParent->Remove(this);

    if (fDelayed)
    {
        // Async-invoke the DeleteHandle so that and pending
        // defer cycle can complete
        EventMsg gmsg;
        gmsg.cbSize = sizeof(GMSG);
        gmsg.nMsg = GM_DUIASYNCDESTROY;
        gmsg.hgadMsg = GetDisplayNode();  // this

        DUserPostEvent(&gmsg, 0);
    }
    else
    {
        // Destroy immediately, do not allow multiple destroys on an Element
        if (!IsDestroyed())
            DeleteHandle(GetDisplayNode());
    }

    return hr;
}

HRESULT Element::DestroyAll()
{
    HRESULT hr = S_OK;

    // Get list of all children
    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);

    if (peList)
    {
        // Remove all children (roots of destruction)
        // Will do a bulk remove instead of relying on the Remove called from Destroy
        hr = RemoveAll();

        if (FAILED(hr))
            goto Failed;

        // All children have been removed, however, we still have a list of children.
        // Mark them for destruction (this call will aways succeed since all have been removed)
        for (UINT i = 0; i < peList->GetSize(); i++)
            peList->GetItem(i)->Destroy();    
    }

Failed:

    pvChildren->Release();

    return hr;
}

// Locate descendent based on ID
Element* Element::FindDescendent(ATOM atomID)
{
    DUIAssert(atomID, "Invalid parameter");

    // Check this Element
    if (GetID() == atomID)
        return this;

    // No match, check children
    Element* peMatch = NULL;

    Value* pvList;
    ElementList* peList = GetChildren(&pvList);

    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            if ((peMatch = peList->GetItem(i)->FindDescendent(atomID)) != NULL)
                break;
        }
    }

    pvList->Release();    

    return peMatch;
}

// Map a point in client coordinated from a Element to this
void Element::MapElementPoint(Element* peFrom, const POINT* pptFrom, POINT* pptTo)
{
    DUIAssert(peFrom && pptFrom && pptTo, "Invalid parameter: NULL");

    if (peFrom == this)
    {
        *pptTo = *pptFrom;
        return;
    }

    RECT rcTo;
    RECT rcFrom;
    GetGadgetRect(peFrom->GetDisplayNode(), &rcFrom, SGR_CONTAINER);
    GetGadgetRect(GetDisplayNode(), &rcTo, SGR_CONTAINER);
    pptTo->x = (rcFrom.left + pptFrom->x) - rcTo.left;
    pptTo->y = (rcFrom.top + pptFrom->y) - rcTo.top;
}

// Give this keyboard focus and ensure it is visible
void Element::SetKeyFocus()
{
    // TODO: Resolve possibility that setting property may not result in SetGadgetFocus happen
    // on this (i.e. check for 'Enabled' when available)
    if (GetVisible() && GetEnabled() && (GetActive() & AE_Keyboard))
        _SetValue(KeyFocusedProp, PI_Local, Value::pvBoolTrue);
}

// Locate direct descendant that is an ancestor of the given Element
Element* Element::GetImmediateChild(Element* peFrom)
{
    if (!peFrom)
        return NULL;

    Element* peParent = peFrom->GetParent();

    while (peParent != this)
    {
        if (!peParent)
            return NULL;

        peFrom = peParent;
        peParent = peParent->GetParent();
    }

    return peFrom;
}

bool Element::IsDescendent(Element* pe)
{
    if (!pe)
        return false;

    Element* peParent = pe;

    while ((peParent != this) && (peParent != NULL))
        peParent = peParent->GetParent();

    return (peParent != NULL);
}

//
// GetAdjacent is used to locate a physically neighboring element given a "starting" element.
// It is used most commonly for directional navigation of keyboard focus, but it is general purpose
// enough to be used for other applications.
//
// peFrom vs. pnr->pe -- this is definitely redundant -- peFrom is really just a convenience that narrows it down
// to self, immediate child, or *else*
//
// logical uses peFrom
// directional uses peFrom & optionally pnr->pe
//
// DISCUSS -- an "approval" callback instead of bKeyableOnly, to make it even more general purpose
//            we can still do some trick for bKeyableOnly for perf reasons (if we find perf to be a problem here)
//         -- should we continue to use event bubbling for *completing* getadjacent in the cases where it's
//            outside the scope of this element?  Or should we build GetAdjacent to go up (in addition to down,
//            which it's already doing) the element chain as needed to find the adjacent element
// 
//
// peFrom:
//   NULL -- meaning we're navigating from something outside element's scope -- peer, parent, etc.
//   this -- meaning we're navigating from this element itself
//   immediate child -- meaning we're navigation from one of this element's children
//
// pnr:
//   pe:
//     NULL -- we're navigating from space (i.e. outside this Element hierarchy)
//     element -- we're navigating from this exact element
//   prc:
//     rect -- use described rectangle, in reference element's coordinates
//     NULL -- use entire bounding rectangle for reference element
//
Element* Element::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly)
{
    if (!GetVisible() || (GetLayoutPos() == LP_None))
        // don't dig down into invisible or non-laid out elements
        return NULL;

    // todo -- we *still* need to think about the implications of this;
    // the bigger question is, do we ignore a zero sized guy for keyfocus?
    // also, since a zero size element is going to happen when you've compressed the window (i.e. not enough room to 
    // fit all items), then it may be odd that keynav is behaving differently based on the size of the window
    // (i.e. you hit the right arrow three times, but based on whether one guy in the middle is zero size or not,
    // you may end up at a different element
    // - jeffbog 08/21/00
    Value* pvExtent;
    SIZE const* psize = GetExtent(&pvExtent);
    bool bZeroSize = (!psize->cx || !psize->cy);
    pvExtent->Release();

    if (bZeroSize)
        return NULL;

    // this element can be a valid choice if it's keyboard focusable or if we don't care about whether or not the element
    // is keyboard focusable (as indicated by the bKeyableOnly flag)
    bool bCanChooseSelf = !bKeyableOnly || (GetEnabled() && ((GetActive() & AE_Keyboard) != 0));
    int  bForward = (iNavDir & NAV_FORWARD);

    if (!peFrom && bCanChooseSelf && (bForward || !(iNavDir & NAV_LOGICAL)))
        return this;

    Element* peTo = GA_NOTHANDLED;
    bool bReallyRelative = (peFrom && (iNavDir & NAV_RELATIVE));


    Value* pvLayout;
    Layout* pl = GetLayout(&pvLayout);
    
    if (pl)
        // jeffbog todo:  investigate whether or not this only needs to be called for directional navigation
        peTo = pl->GetAdjacent(this, peFrom, iNavDir, pnr, bKeyableOnly);

    pvLayout->Release();

    if (peTo == GA_NOTHANDLED)
    {
        // default processing
        peTo = NULL;

        Value* pvChildren;
        ElementList* pelChildren = GetChildren(&pvChildren);

        UINT uChild = 0;
        UINT cChildren = 0;
        if (pelChildren)
        {
            cChildren = pelChildren->GetSize();
            int iInc = bForward ? 1 : -1;
            UINT uStop = bForward ? cChildren : ((UINT)-1);

            if (bReallyRelative)
            {
                if (peFrom == this)
                    uChild = bForward ? 0 : ((UINT)-1);
                else
                    uChild = peFrom->GetIndex() + iInc;
            }
            else
                // absolute (or null "from" -- which is the equivalent of absolute)
                uChild = bForward ? 0 : cChildren - 1;

            // was GetFirstKeyable -- keeping boxed for now just in case we want to factor it back out for reuse
            // peTo = GetFirstKeyable(iNavDir, prcReference, bKeyableOnly, uChild);
            for (UINT u = uChild; u != uStop; u += iInc)
            {        
                Element* peWalk = pelChildren->GetItem(u);

                peWalk = peWalk->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                if (peWalk)
                {
                    peTo = peWalk;
                    break;
                }
            }
        }
        pvChildren->Release();
    }
  
    if ((iNavDir & NAV_LOGICAL) && !peTo)
    {
        if ((peFrom != this) && !bForward && bCanChooseSelf)
            return this;
    }

    return peTo;
}

// Retrieve first child with 'KeyWithin' property set to true
Element* Element::GetKeyWithinChild()
{
    Value* pv;

    ElementList* pelChildren = GetChildren(&pv);
    if (!pelChildren)
    {
        pv->Release();
        return NULL;
    }

    UINT cChildren = pelChildren->GetSize();
    DUIAssert(cChildren, "Zero children even though a child list exists");

    Element* peWalk = NULL;
    for (UINT u = 0; u < cChildren; u++)
    {
        peWalk = pelChildren->GetItem(u);
        if (peWalk->GetKeyWithin())
            break;
    }

    pv->Release();

    return peWalk;
}

// Retrieve first child with 'MouseWithin' property set to true
Element* Element::GetMouseWithinChild()
{
    Value* pv;

    ElementList* pelChildren = GetChildren(&pv);
    if (!pelChildren)
    {
        pv->Release();
        return NULL;
    }

    UINT cChildren = pelChildren->GetSize();
    DUIAssert(cChildren, "Zero children even though a child list exists");

    Element* peWalk = NULL;
    for (UINT u = 0; u < cChildren; u++)
    {
        peWalk = pelChildren->GetItem(u);
        if (peWalk->GetMouseWithin())
            break;
    }

    pv->Release();

    return peWalk;
}

// Ensure child is not obstructed
bool Element::EnsureVisible()
{
    // todo:  before passing to parent, have to clip this rectangle
    // also, should check visibility -- duh
    Value* pvSize;
    const SIZE* psize = GetExtent(&pvSize);
    bool bRet = EnsureVisible(0, 0, psize->cx, psize->cy);
    pvSize->Release();

    return bRet;
}

bool Element::EnsureVisible(UINT uChild)
{
    // todo:  before passing to parent, have to clip this rectangle
    // also, should check visibility -- duh
    Value* pvChildren;
    Value* pvSize;
    Value* pvPoint;

    ElementList* pelChildren = GetChildren(&pvChildren);

    if (!pelChildren || (uChild >= pelChildren->GetSize()))
    {
        pvChildren->Release();
        return false;
    }

    Element* pe = pelChildren->GetItem(uChild);

    const POINT* ppt = pe->GetLocation(&pvPoint);
    const SIZE* psize = pe->GetExtent(&pvSize);

    bool bChanged = EnsureVisible(ppt->x, ppt->y, psize->cx, psize->cy);

    pvPoint->Release();
    pvSize->Release();
    pvChildren->Release();

    return bChanged;
}

// Ensure region of Element is not obstructed
bool Element::EnsureVisible(int x, int y, int cx, int cy)
{
    Element* peParent = GetParent();

    if (peParent)
    {
        Value* pv;
        const POINT* ppt = GetLocation(&pv);
        
        bool bChanged = peParent->EnsureVisible(ppt->x + x, ppt->y + y, cx, cy);

        pv->Release();

        return bChanged;
    }

    return false;
}

// Passed Animation value for this describes the animation to invoke
void Element::InvokeAnimation(int dAni, UINT nTypeMask)
{
    // Get duration
    float flDuration = 0.0f;
    switch (dAni & ANI_SpeedMask)
    {
    case ANI_VeryFast:
        flDuration = 0.15f;
        break;

    case ANI_Fast:  
        flDuration = 0.35f;
        break;

    case ANI_MediumFast:
        flDuration = 0.50f;
        break;

    case ANI_Medium:
        flDuration = 0.75f;
        break;

    case ANI_MediumSlow:
        flDuration = 1.10f;
        break;

    case ANI_Slow:
        flDuration = 1.50f;
        break;

    case ANI_DefaultSpeed:
    default:
        flDuration = 0.75f;
        break;
    }

    // Get delay
    float flDelay = 0.0f;
    switch (dAni & ANI_DelayMask)
    {
    case ANI_DelayShort:  
        flDelay = 0.25f;
        break;

    case ANI_DelayMedium:
        flDelay = 0.75f;
        break;

    case ANI_DelayLong:
        flDelay = 1.50f;
        break;
    }

    InvokeAnimation(dAni & nTypeMask, dAni & ANI_InterpolMask, flDuration, flDelay);
}

// Animate display node to match current Element state
void Element::InvokeAnimation(UINT nTypes, UINT nInterpol, float flDuration, float flDelay, bool fPushToChildren)
{
    IInterpolation* piip = NULL;

    if (nInterpol == ANI_DefaultInterpol)
        nInterpol = ANI_Linear;
    BuildInterpolation(nInterpol, 0, __uuidof(IInterpolation), (void**)&piip);

    if (piip == NULL)
        return;

    // Start Bounds type animations
    if (nTypes & ANI_BoundsType)
    {
        // Get requested bounds type animation
        UINT nType = nTypes & ANI_BoundsType;

        // Retrieve final size
        Value* pvLoc;
        Value* pvExt;

        const POINT* pptLoc = GetLocation(&pvLoc);
        const SIZE* psizeExt = GetExtent(&pvExt);

        // Create rect animation
        GANI_RECTDESC descRect;
        ZeroMemory(&descRect, sizeof(descRect));
        descRect.cbSize         = sizeof(descRect);
        descRect.act.flDuration = flDuration;
        descRect.act.flDelay    = flDelay;
        descRect.act.dwPause    = (DWORD) -1;
        descRect.hgadChange     = GetDisplayNode();
        descRect.pipol          = piip;
        descRect.ptEnd          = *pptLoc;
        descRect.sizeEnd        = *psizeExt;

        // Rect animations override position and size animations
        if (nType == ANI_Rect)
        {
            IAnimation * pian = NULL;
            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: Rectangle Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_RectH)
        {
            IAnimation * pian = NULL;
            RECT rcCur;
            GetGadgetRect(GetDisplayNode(), &rcCur, SGR_PARENT);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.ptStart.x    = rcCur.left;
            descRect.ptStart.y    = pptLoc->y;
            descRect.sizeStart.cx = rcCur.right - rcCur.left;
            descRect.sizeStart.cy = psizeExt->cy;

            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeV Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_RectV)
        {
            IAnimation * pian = NULL;
            RECT rcCur;
            GetGadgetRect(GetDisplayNode(), &rcCur, SGR_PARENT);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.ptStart.x    = pptLoc->x;
            descRect.ptStart.y    = rcCur.top;
            descRect.sizeStart.cx = psizeExt->cx;
            descRect.sizeStart.cy = rcCur.bottom - rcCur.top;

            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeV Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_Position)
        {
            IAnimation * pian = NULL;
            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: Position Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_Size)
        {
            IAnimation * pian = NULL;
            descRect.nChangeFlags = SGR_PARENT | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: Size Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_SizeH)
        {
            IAnimation * pian = NULL;
            SIZE sizeCur;
            GetGadgetSize(GetDisplayNode(), &sizeCur);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.sizeStart.cx = sizeCur.cx;
            descRect.sizeStart.cy = psizeExt->cy;

            descRect.nChangeFlags = SGR_PARENT | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeH Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_SizeV)
        {
            IAnimation * pian = NULL;
            SIZE sizeCur;
            GetGadgetSize(GetDisplayNode(), &sizeCur);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.sizeStart.cx = psizeExt->cx;
            descRect.sizeStart.cy = sizeCur.cy;

            descRect.nChangeFlags = SGR_PARENT | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeV Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }

        pvLoc->Release();
        pvExt->Release();
    }

    // Start Alpha type animations
    if (nTypes & ANI_AlphaType)
    {
        // Retrieve final alpha level
        int dAlpha = GetAlpha();

        // Create alpha animation
        GANI_ALPHADESC descAlpha;
        ZeroMemory(&descAlpha, sizeof(descAlpha));
        descAlpha.cbSize            = sizeof(descAlpha);
        descAlpha.act.flDuration    = flDuration;
        descAlpha.act.flDelay       = flDelay;
        descAlpha.act.dwPause       = (DWORD) -1;
        descAlpha.hgadChange        = GetDisplayNode();
        descAlpha.pipol             = piip;
        descAlpha.flEnd             = (float)dAlpha / 255.0f;
        descAlpha.fPushToChildren   = fPushToChildren ? TRUE : FALSE;
        descAlpha.nOnComplete       = GANI_ALPHACOMPLETE_OPTIMIZE;

        IAnimation * pian = NULL;
        BuildAnimation(ANIMATION_ALPHA, 0, &descAlpha, __uuidof(IAnimation), (void **) &pian);
        if (pian)
            pian->Release();
        //DUITrace("DUI: Alpha Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
    }

    if (piip)
        piip->Release();
}


void Element::StopAnimation(UINT nTypes)
{
    IAnimation* pian;
    
    if (nTypes & ANI_BoundsType)
    {
        pian = NULL;
        GetGadgetAnimation(GetDisplayNode(), ANIMATION_RECT, __uuidof(IAnimation), (void**)&pian);
        if (pian != NULL)
            pian->SetTime(IAnimation::tDestroy);
    }

    if (nTypes & ANI_AlphaType)
    {
        pian = NULL;
        GetGadgetAnimation(GetDisplayNode(), ANIMATION_ALPHA, __uuidof(IAnimation), (void**)&pian);
        if (pian != NULL)
            pian->SetTime(IAnimation::tDestroy);
    }

    //DUITrace("DUI: Animation Cancelled for <%x> (%S)\n", this, GetClassInfo()->GetName());
}


////////////////////////////////////////////////////////
// Element Listeners

HRESULT Element::AddListener(IElementListener* pel)
{
    DUIAssert(pel, "Invalid listener: NULL");

    IElementListener** ppNewList;
    UINT_PTR cListeners;

    // Add listener to list
    if (_ppel)
    {
        cListeners = (UINT_PTR)_ppel[0] + 1;
        ppNewList = (IElementListener**)HReAllocAndZero(_ppel, sizeof(IElementListener*) * (cListeners + 1));
    }
    else
    {
        cListeners = 1;
        ppNewList = (IElementListener**)HAllocAndZero(sizeof(IElementListener*) * (cListeners + 1));
    }

    if (!ppNewList)
        return E_OUTOFMEMORY;

    _ppel = ppNewList;
    _ppel[0] = (IElementListener*)cListeners;

    _ppel[(UINT_PTR)(*_ppel)] = pel;

    // Callback
    pel->OnListenerAttach(this);

    return S_OK;
}

void Element::RemoveListener(IElementListener* pel)
{
    DUIAssert(pel, "Invalid listener: NULL");

    if (!_ppel)
        return;

    // Locate listener
    bool fFound = false;

    UINT_PTR cListeners = (UINT_PTR)_ppel[0];

    for (UINT_PTR i = 1; i <= cListeners; i++)
    {
        if (fFound) // Once found, use the remaining iterations to move the indices down by one
            _ppel[i-1] = _ppel[i]; 
        else if (_ppel[i] == pel)
            fFound = true;
    }

    // If listener was found, remove    
    if (fFound)
    {
        // Callback
        pel->OnListenerDetach(this);

        cListeners--;
        
        if (!cListeners)
        {
            HFree(_ppel);
            _ppel = NULL;
        }
        else
        {
            // Trim list
            IElementListener** ppNewList;
            ppNewList = (IElementListener**)HReAllocAndZero(_ppel, sizeof(IElementListener*) * (cListeners + 1));

            // If allocation failed, keep old list
            if (ppNewList)
                _ppel = ppNewList;

            // Set new count (one less)
            _ppel[0] = (IElementListener*)cListeners;
        }
    }
}

////////////////////////////////////////////////////////
// Global Gadget callback

// Per-instance callback
UINT Element::MessageCallback(GMSG* pgMsg)
{
    UNREFERENCED_PARAMETER(pgMsg);

    return DU_S_NOTHANDLED;
}

HRESULT Element::_DisplayNodeCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    //DUITrace("Gad<%x>, El<%x>\n", pGMsg->hgadCur, pvCur);

    Element* pe = (Element*)pvCur;

#if DBG
    // Check for callback reentrancy
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (petls)
    {
        petls->cDNCBEnter++;
        //if (petls->cDNCBEnter > 1)
        //    DUITrace("_DisplayNodeCallback() entered %d times. (El:<%x> GMsg:%d)\n", petls->cDNCBEnter, pe, pGMsg->nMsg);
    }
#endif

    // Allow for override of messages
    HRESULT nRes = pe->MessageCallback(pGMsg);
    
    if (nRes != DU_S_COMPLETE)
    {
        switch (pGMsg->nMsg)
        {
        case GM_DESTROY:
            {
                GMSG_DESTROY* pDestroy = (GMSG_DESTROY*)pGMsg;
                if (pDestroy->nCode == GDESTROY_START)
                {
                    // On a "destroy start" remove Element from parent
                    pe->OnDestroy();
                }
                else if (pDestroy->nCode == GDESTROY_FINAL)
                {
                    // Last message received, destroy Element
                    DUIAssert(pe->IsDestroyed(), "Element got final destroy message but isn't marked as destroyed");

                    // Ensure no children exist for this Element. All children should have received
                    // a "destroy start" before the parent receives "destroy finish"
#if DBG
                    Value* pv;
                    DUIAssert(!pe->GetChildren(&pv), "Child count should be zero for final destroy");
                    pv->Release();
#endif
                    Value* pvLayout;
                    Layout* pl = pe->GetLayout(&pvLayout);
                    if (pl)
                        pl->Detach(pe);
                    pvLayout->Release();
                    // Clear all values currently being stored
                    pe->_pvmLocal->Enum(_ReleaseValue);

                    // Clear ref-counted cache
                    pe->_pvSpecSheet->Release();

                    // Remove Element from all applicable defer tables, if within defer cycle
                    DeferCycle* pdc = GetDeferObject();
                    if (pdc && pdc->cEnter > 0) // Check if active
                    {
                        // Remove possible pending root operations
                        pdc->pvmUpdateDSRoot->Remove(pe, false, true);
                        pdc->pvmLayoutRoot->Remove(pe, false, true);

                        // Remove pending group notifications (normal)
                        if (pe->_iGCSlot != -1)
                        {
                            DUIAssert((int)pdc->pdaGC->GetSize() > pe->_iGCSlot, "Queued group changes expected");
                            GCRecord* pgcr = pdc->pdaGC->GetItemPtr(pe->_iGCSlot);
                            pgcr->pe = NULL;  // Ignore record
                            DUITrace("Element <%x> group notifications ignored due to deletion\n", pe);
                        }

                        // Remove pending group notifications (low priority)
                        if (pe->_iGCLPSlot != -1)
                        {
                            DUIAssert((int)pdc->pdaGCLP->GetSize() > pe->_iGCLPSlot, "Queued low-pri group changes expected");
                            GCRecord* pgcr = pdc->pdaGCLP->GetItemPtr(pe->_iGCLPSlot);
                            pgcr->pe = NULL;  // Ignore record
                            DUITrace("Element <%x> low-pri group notifications ignored due to deletion\n", pe);
                        }

                        // Remove pending property notifications
                        if (pe->_iPCTail != -1)
                        {
                            DUIAssert((int)pdc->pdaPC->GetSize() > pe->_iPCTail, "Queued property changes expected");

                            PCRecord* ppcr;
                            int iScan = pe->_iPCTail;
                            while (iScan >= pdc->iPCPtr)
                            {
                                ppcr = pdc->pdaPC->GetItemPtr(iScan);
                                if (!ppcr->fVoid)
                                {
                                    // Free record
                                    ppcr->fVoid = true;
                                    ppcr->pvOld->Release();
                                    ppcr->pvNew->Release();
                                }

                                // Walk back to previous record
                                iScan = ppcr->iPrevElRec;
                            }
                            DUITrace("Element <%x> property notifications ignored due to deletion\n", pe);
                        }
                    }
                    else
                    {
                        DUIAssert(pe->_iGCSlot == -1, "Invalid group notification state for destruction");
                        DUIAssert(pe->_iGCLPSlot == -1, "Invalid low-pri group notification state for destruction");
                        DUIAssert(pe->_iPCTail == -1, "Invalid property notification state for destruction");
                    }

#if DBG
                    // Track element count
                    InterlockedDecrement(&g_cElement);
#endif

                    HDelete<Element>(pe);
                }
            }
            nRes = DU_S_COMPLETE;
            break;

        case GM_PAINT:  // Painting (box model)
            {
                // Direct message
                DUIAssert(GET_EVENT_DEST(pGMsg) == GMF_DIRECT, "'Current' and 'About' gadget doesn't match even though message is direct");
                GMSG_PAINT* pmsgP = (GMSG_PAINT*)pGMsg;
                DUIAssert(pmsgP->nCmd == GPAINT_RENDER, "Invalid painting command");

                switch (pmsgP->nSurfaceType)
                {
                case GSURFACE_HDC:
                    {
                        GMSG_PAINTRENDERI* pmsgR = (GMSG_PAINTRENDERI*)pmsgP;
                        pe->Paint(pmsgR->hdc, pmsgR->prcGadgetPxl, pmsgR->prcInvalidPxl, NULL, NULL);
                    }
                    break;

#ifdef GADGET_ENABLE_GDIPLUS
                case GSURFACE_GPGRAPHICS:
                    {
                        GMSG_PAINTRENDERF* pmsgR = (GMSG_PAINTRENDERF*)pmsgP;
                        pe->Paint(pmsgR->pgpgr, pmsgR->prcGadgetPxl, pmsgR->prcInvalidPxl, NULL, NULL);
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS

                default:
                    DUIAssertForce("Unknown rendering surface");
                }
            }
            nRes = DU_S_COMPLETE;
            break;

        case GM_CHANGESTATE:  // Gadget state changed
            {
                // Full message

                // Only allow direct and bubbled change state messages, ignore routed
                if (GET_EVENT_DEST(pGMsg) == GMF_ROUTED)
                    break;

                GMSG_CHANGESTATE* pSC = (GMSG_CHANGESTATE*)pGMsg;

                // Retrieve corresponding Elements of state change
                Element* peSet = NULL;
                Element* peLost = NULL;

                GMSG_DUIGETELEMENT gmsgGetEl;
                ZeroMemory(&gmsgGetEl, sizeof(GMSG_DUIGETELEMENT));

                gmsgGetEl.cbSize = sizeof(GMSG_DUIGETELEMENT);
                gmsgGetEl.nMsg = GM_DUIGETELEMENT;

                if (pSC->hgadSet)
                {
                    gmsgGetEl.hgadMsg = pSC->hgadSet;

                    DUserSendEvent(&gmsgGetEl, false);
                    peSet = gmsgGetEl.pe;
                }
        
                if (pSC->hgadLost)
                {
                    gmsgGetEl.hgadMsg = pSC->hgadLost;

                    DUserSendEvent(&gmsgGetEl, false);
                    peLost = gmsgGetEl.pe;
                }

                // Handle by input type
                switch (pSC->nCode)
                {
                case GSTATE_KEYBOARDFOCUS:  // Track focus, map to Focused read-only property

                    // Set keyboard focus state only on direct messages (will be inherited)
                    if (GET_EVENT_DEST(pGMsg) == GMF_DIRECT)  // in Direct stage
                    {
                        if (pSC->nCmd == GSC_SET)
                        {
                            // Gaining focus
                            // State change may be as a result of SetKeyFocus (which sets the Keyboard focus
                            // property resulting in a call to SetGadgetFocus, resulting in the state change) or it may
                            // come from DUser. This property may already be set, if so, it's ignored
                            DUIAssert(pe == peSet, "Incorrect keyboard focus state");
                            if (!pe->GetKeyFocused())
                                pe->_SetValue(KeyFocusedProp, PI_Local, Value::pvBoolTrue);  // Came from system, update property
                            pe->EnsureVisible();
                        }
                        else
                        {
                            // Losing focus
                            DUIAssert(pe->GetKeyFocused() && (pe == peLost), "Incorrect keyboard focus state");
                            pe->_RemoveLocalValue(KeyFocusedProp);
                        }
                    }
                    else if (pSC->nCmd == GSC_LOST)
                    {
                        // Eat the lost part of this chain once we've hit a common ancestor -- 
                        // from this common ancestor up, we will only react to the set part of this chain;
                        // this will remove the duplicate notifications that occur from the common ancestor
                        // up otherwise
                        //
                        // We are eating the lost, not the set, because the lost happens first, and the ancestors
                        // should be told after the both the lost chain and set chain has run up from below them
                        //
                        // We only have to check set because we are receiving the lost, hence, we know peLost
                        // is a descendent
                        if (pe->GetImmediateChild(peSet))
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }

                    // Fire system event (direct and bubble)
                    pe->OnKeyFocusMoved(peLost, peSet);

                    nRes = DU_S_PARTIAL;
                    break;

                case GSTATE_MOUSEFOCUS:

                    // Set keyboard focus state only on direct messages (will be inherited)
                    if (GET_EVENT_DEST(pGMsg) == GMF_DIRECT)  // in Direct stage
                    {
                        // Set mouse focus state (will be inherited)
                        if (pSC->nCmd == GSC_SET)
                        {
                            DUIAssert(!pe->GetMouseFocused() && (pe == peSet), "Incorrect mouse focus state");
                            pe->_SetValue(MouseFocusedProp, PI_Local, Value::pvBoolTrue);
                        }
                        else
                        {
                            DUIAssert(pe->GetMouseFocused() && (pe == peLost), "Incorrect mouse focus state");
                            pe->_RemoveLocalValue(MouseFocusedProp);
                        }
                    }
                    else if (pSC->nCmd == GSC_LOST)
                    {
                        // See comments for key focus
                        if (pe->GetImmediateChild(peSet))
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }

                    // Fire system event
                    pe->OnMouseFocusMoved(peLost, peSet);

                    nRes = DU_S_PARTIAL;
                    break;
                }
            }
            break;

        case GM_INPUT:  // User input
            {
                // Full message
                GMSG_INPUT* pInput = (GMSG_INPUT*)pGMsg;

                // This is a bubbled message, gadgets that receive it might not be the target (find it)
                Element* peTarget;

                if (GET_EVENT_DEST(pGMsg) == GMF_DIRECT)  // in Direct stage
                    peTarget = pe;
                else
                    peTarget = ElementFromGadget(pInput->hgadMsg);  // Query gadget for Element this message is about (target)

                // Map to an input event and call OnInput
                switch (pInput->nDevice)
                {
                case GINPUT_MOUSE:  // Mouse message
                    {
                        MouseEvent* pme = NULL;
                        union
                        {
                            MouseEvent      me;
                            MouseDragEvent  mde;
                            MouseClickEvent mce;
                            MouseWheelEvent mwe;
                        };

                        switch (pInput->nCode)
                        {
                        case GMOUSE_DRAG:
                            {
                                GMSG_MOUSEDRAG* pMouseDrag = (GMSG_MOUSEDRAG*) pInput;
                                mde.sizeDelta = pMouseDrag->sizeDelta;
                                mde.fWithin = pMouseDrag->fWithin;
                                pme = &mde;
                            }
                            break;

                        case GMOUSE_WHEEL:
                            mwe.sWheel = ((GMSG_MOUSEWHEEL*) pInput)->sWheel;
                            pme = &mwe;
                            break;

                        case GMOUSE_UP:
                        case GMOUSE_DOWN:
                            mce.cClicks = ((GMSG_MOUSECLICK*) pInput)->cClicks;
                            pme = &mce;
                            break;

                        default:
                            pme = &me;
                            break;
                        }

                        GMSG_MOUSE* pMouse = (GMSG_MOUSE*) pInput;

                        pme->peTarget = peTarget;
                        pme->fHandled = false;
                        pme->nStage = GET_EVENT_DEST(pMouse);
                        pme->nDevice = pMouse->nDevice;
                        pme->nCode = pMouse->nCode;
                        pme->ptClientPxl = pMouse->ptClientPxl;
                        pme->bButton = pMouse->bButton;
                        pme->nFlags = pMouse->nFlags;
                        pme->uModifiers = pMouse->nModifiers;

                        // Fire system event
                        pe->OnInput(pme);

                        if (pme->fHandled)
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }
                    break;

                case GINPUT_KEYBOARD:  // Keyboard message
                    {
                        GMSG_KEYBOARD* pKbd = (GMSG_KEYBOARD*)pGMsg;

                        KeyboardEvent ke;
                        ke.peTarget = peTarget;
                        ke.fHandled = false;
                        ke.nStage = GET_EVENT_DEST(pKbd);
                        ke.nDevice = pKbd->nDevice;
                        ke.nCode = pKbd->nCode;
                        ke.ch = pKbd->ch;
                        ke.cRep = pKbd->cRep;
                        ke.wFlags = pKbd->wFlags;
                        ke.uModifiers = pKbd->nModifiers;

                        // Fire system event
                        pe->OnInput(&ke);

                        if (ke.fHandled)
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }
                    break;
                }
            }
            break;

        case GM_QUERY:
            {
                GMSG_QUERY* pQ = (GMSG_QUERY*)pGMsg;
                switch (pQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC* pQD = (GMSG_QUERYDESC*)pGMsg;

                        // Name
                        Value* pv = pe->GetValue(ContentProp, PI_Specified);
                        WCHAR szContent[128];

                        if (pe->GetID())
                        {
                            WCHAR szID[128];
                            szID[0] = NULL;

                            GetAtomNameW(pe->GetID(), szID, DUIARRAYSIZE(szID));
                            _snwprintf(pQD->szName, DUIARRAYSIZE(pQD->szName), L"[%s] %s", szID, pv->ToString(szContent, DUIARRAYSIZE(szContent)));
                            *(pQD->szName + (DUIARRAYSIZE(pQD->szName) - 1)) = NULL;
                        }
                        else
                        {
                            pv->ToString(pQD->szName, DUIARRAYSIZE(pQD->szName));
                        }

                        pv->Release();

                        // Type
                        wcsncpy(pQD->szType, pe->GetClassInfo()->GetName(), DUIARRAYSIZE(pQD->szType));
                        *(pQD->szType + (DUIARRAYSIZE(pQD->szType) - 1)) = NULL;

                        nRes = DU_S_COMPLETE;
                    }
                    break;

                case GQUERY_DETAILS:
                    {
                        GMSG_QUERYDETAILS* pQDT = (GMSG_QUERYDETAILS*)pGMsg;
                        if (pQDT->nType == GQDT_HWND)
                            QueryDetails(pe, (HWND)pQDT->hOwner);
                    }
                    break;
                }
            }
            break;

        case GM_DUIEVENT:  // Generic DUI event
            {
                // Possible full message
                GMSG_DUIEVENT* pDUIEv = (GMSG_DUIEVENT*)pGMsg;

                // Set what stage this is (routed, direct, or bubbled)
                pDUIEv->pEvent->nStage = GET_EVENT_DEST(pGMsg);

                // Call handler (target and rest of struct set by FireEvent)
                pe->OnEvent(pDUIEv->pEvent);

                if (pDUIEv->pEvent->fHandled)
                {
                    nRes = DU_S_COMPLETE;
                    break;
                }
            }
            break;

        case GM_DUIGETELEMENT:  // Gadget query for Element pointer
            {
                // Direct message
                DUIAssert(GET_EVENT_DEST(pGMsg) == GMF_DIRECT, "Must only be a direct message");

                GMSG_DUIGETELEMENT* pGetEl = (GMSG_DUIGETELEMENT*)pGMsg;
                pGetEl->pe = pe;
            }
            nRes = DU_S_COMPLETE;
            break;

        case GM_DUIACCDEFACTION:  // Async invokation
            // Direct message
            DUIAssert(GET_EVENT_DEST(pGMsg) == GMF_DIRECT, "Must only be a direct message");
            pe->DefaultAction();
            nRes = DU_S_COMPLETE;
            break;

        case GM_DUIASYNCDESTROY:
            // Direct message
            // Do not allow multiple destroys on an Element
            if (!pe->IsDestroyed())
                DeleteHandle(pe->GetDisplayNode());
            nRes = DU_S_COMPLETE;
            break;
        }
    }

#if DBG
    // Check for callback reentrancy
    if (petls)
        petls->cDNCBEnter--;
#endif

    return nRes;
}

HRESULT Element::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    HRESULT hr = S_OK;

    //
    // Initialize and validate the out parameter(s).
    //
    if (ppAccessible != NULL) {
        *ppAccessible = NULL;
    } else {
        return E_INVALIDARG;
    }

    //
    // If this element is not marked as accessible, refuse to give out its
    // IAccessible implementation!
    //
    if (GetAccessible() == false) {
        return E_FAIL;
    }

    //
    // Create an accessibility implementation connected to this element if we
    // haven't done so already.
    //
    if (_pDuiAccessible == NULL) {
        hr = DuiAccessible::Create(this, &_pDuiAccessible);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //
    // Ask the existing accessibility implementation for a pointer to the
    // actual IAccessible interface.
    //
    hr = _pDuiAccessible->QueryInterface(__uuidof(IAccessible), (LPVOID*)ppAccessible);
    if (FAILED(hr)) {
        return hr;
    }

    DUIAssert(SUCCEEDED(hr) && _pDuiAccessible != NULL && *ppAccessible != NULL, "Accessibility is broken!");
    return hr;
}

HRESULT Element::DefaultAction()
{
    return S_OK;
}

////////////////////////////////////////////////////////
// Element helpers

Element* ElementFromGadget(HGADGET hGadget)
{
    // Get Element from gadget
    GMSG_DUIGETELEMENT gmsgGetEl;
    ZeroMemory(&gmsgGetEl, sizeof(GMSG_DUIGETELEMENT));

    gmsgGetEl.cbSize = sizeof(GMSG_DUIGETELEMENT);
    gmsgGetEl.nMsg = GM_DUIGETELEMENT;
    gmsgGetEl.hgadMsg = hGadget;

    DUserSendEvent(&gmsgGetEl, false);

    return gmsgGetEl.pe;
}

////////////////////////////////////////////////////////
// Property definitions

// Element's PropertyInfo index values need to be known at compile-time for optimization. These values
// are set automatically for all other Element-derived objects. Set and maintain values manually
// and ensure match with _PIDX_xxx defines. These system-defined properties will be referred to by this value.
// Class and Global index scope are the same for Element

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, NULL, (Value*)&svDefault!!!, _PIDX_MustSet, _PIDX_MustSet };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Parent property
static int vvParent[] = { DUIV_ELEMENTREF, -1 };
static PropertyInfo impParentProp = { L"Parent", PF_LocalOnly|PF_ReadOnly, PG_AffectsDesiredSize|PG_AffectsLayout, vvParent, NULL, Value::pvElementNull, _PIDX_Parent, _PIDX_Parent };
PropertyInfo* Element::ParentProp = &impParentProp;

// Children property
static int vvChildren[] = { DUIV_ELLIST, -1 };
static PropertyInfo impChildrenProp = { L"Children", PF_Normal|PF_ReadOnly, PG_AffectsDesiredSize|PG_AffectsLayout, vvChildren, NULL, Value::pvElListNull, _PIDX_Children, _PIDX_Children };
PropertyInfo* Element::ChildrenProp = &impChildrenProp;

// Visibile property (Computed value cached)
static int vvVisible[] = { DUIV_BOOL, -1 };
static PropertyInfo impVisibleProp = { L"Visible", PF_TriLevel|PF_Cascade|PF_Inherit, 0, vvVisible, NULL, Value::pvBoolFalse, _PIDX_Visible, _PIDX_Visible };
PropertyInfo* Element::VisibleProp = &impVisibleProp;

// Width property
static int vvWidth[] = { DUIV_INT, -1 }; StaticValue(svDefaultWidth, DUIV_INT, -1);
static PropertyInfo impWidthProp = { L"Width", PF_Normal|PF_Cascade, PG_AffectsDesiredSize, vvWidth, NULL, (Value*)&svDefaultWidth, _PIDX_Width, _PIDX_Width };
PropertyInfo* Element::WidthProp = &impWidthProp;

// Height property
static int vvHeight[] = { DUIV_INT, -1 }; StaticValue(svDefaultHeight, DUIV_INT, -1);
static PropertyInfo impHeightProp = { L"Height", PF_Normal|PF_Cascade, PG_AffectsDesiredSize, vvHeight, NULL, (Value*)&svDefaultHeight, _PIDX_Height, _PIDX_Height };
PropertyInfo* Element::HeightProp = &impHeightProp;

// X property
static int vvX[] = { DUIV_INT, -1 };
static PropertyInfo impXProp = { L"X", PF_Normal, 0, vvX, NULL, Value::pvIntZero, _PIDX_X, _PIDX_X };
PropertyInfo* Element::XProp = &impXProp;

// Y property
static int vvY[] = { DUIV_INT, -1 };
static PropertyInfo impYProp = { L"Y", PF_Normal, 0, vvY, NULL, Value::pvIntZero, _PIDX_Y, _PIDX_Y };
PropertyInfo* Element::YProp = &impYProp;

// Location property
static int vvLocation[] = { DUIV_POINT, -1 };
static PropertyInfo impLocationProp = { L"Location", PF_LocalOnly|PF_ReadOnly, PG_AffectsBounds, vvLocation, NULL, Value::pvPointZero, _PIDX_Location, _PIDX_Location };
PropertyInfo* Element::LocationProp = &impLocationProp;

// Extent property
static int vvExtent[] = { DUIV_SIZE, -1 };
static PropertyInfo impExtentProp = { L"Extent", PF_LocalOnly|PF_ReadOnly, PG_AffectsLayout|PG_AffectsBounds, vvExtent, NULL, Value::pvSizeZero, _PIDX_Extent, _PIDX_Extent };
PropertyInfo* Element::ExtentProp = &impExtentProp;

// PosInLayout property
static int vvPosInLayout[] = { DUIV_POINT, -1 };
static PropertyInfo impPosInLayoutProp = { L"PosInLayout", PF_LocalOnly|PF_ReadOnly, 0, vvPosInLayout, NULL, Value::pvPointZero, _PIDX_PosInLayout, _PIDX_PosInLayout };
PropertyInfo* Element::PosInLayoutProp = &impPosInLayoutProp;

// SizeInLayout property
static int vvSizeInLayout[] = { DUIV_SIZE, -1 };
static PropertyInfo impSizeInLayoutProp = { L"SizeInLayout", PF_LocalOnly|PF_ReadOnly, 0, vvSizeInLayout, NULL, Value::pvSizeZero, _PIDX_SizeInLayout, _PIDX_SizeInLayout };
PropertyInfo* Element::SizeInLayoutProp = &impSizeInLayoutProp;

// DesiredSize property
static int vvDesiredSize[] = { DUIV_SIZE, -1 };
static PropertyInfo impDesiredSizeProp = { L"DesiredSize", PF_LocalOnly|PF_ReadOnly, PG_AffectsLayout|PG_AffectsParentLayout, vvDesiredSize, NULL, Value::pvSizeZero, _PIDX_DesiredSize, _PIDX_DesiredSize };
PropertyInfo* Element::DesiredSizeProp = &impDesiredSizeProp;

// LastDSConst property
static int vvLastDSConst[] = { DUIV_INT, -1 };
static PropertyInfo impLastDSConstProp = { L"LastDSConst", PF_LocalOnly|PF_ReadOnly, 0, vvLastDSConst, NULL, Value::pvSizeZero, _PIDX_LastDSConst, _PIDX_LastDSConst };
PropertyInfo* Element::LastDSConstProp = &impLastDSConstProp;

// Layout property
static int vvLayout[] = { DUIV_LAYOUT, -1 };
static PropertyInfo impLayoutProp = { L"Layout", PF_Normal, PG_AffectsDesiredSize|PG_AffectsLayout, vvLayout, NULL, Value::pvLayoutNull, _PIDX_Layout, _PIDX_Layout };
PropertyInfo* Element::LayoutProp = &impLayoutProp;

// LayoutPos property
static int vvLayoutPos[] = { DUIV_INT, -1 };  StaticValue(svDefaultLayoutPos, DUIV_INT, LP_Auto);
static PropertyInfo impLayoutPosProp = { L"LayoutPos", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsParentLayout, vvLayoutPos, NULL, (Value*)&svDefaultLayoutPos, _PIDX_LayoutPos, _PIDX_LayoutPos };
PropertyInfo* Element::LayoutPosProp = &impLayoutPosProp;

// BorderThickness property
static int vvBorderThickness[] = { DUIV_RECT, -1 };
static PropertyInfo impBorderThicknessProp = { L"BorderThickness", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsDisplay, vvBorderThickness, NULL, Value::pvRectZero, _PIDX_BorderThickness, _PIDX_BorderThickness };
PropertyInfo* Element::BorderThicknessProp = &impBorderThicknessProp;

// BorderStyle property
static int vvBorderStyle[] = { DUIV_INT, -1 };
static EnumMap emBorderStyle[] = { { L"Solid", BDS_Solid }, { L"Raised", BDS_Raised }, { L"Sunken", BDS_Sunken }, { L"Rounded", BDS_Rounded }, { NULL, 0 } };
static PropertyInfo impBorderStyleProp = { L"BorderStyle", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvBorderStyle, emBorderStyle, Value::pvIntZero, _PIDX_BorderStyle, _PIDX_BorderStyle };
PropertyInfo* Element::BorderStyleProp = &impBorderStyleProp;

// BorderColor property
static int vvBorderColor[] = { DUIV_INT /*Std Color*/, DUIV_FILL, -1 }; StaticValue(svDefaultBorderColor, DUIV_INT, SC_Black);
static PropertyInfo impBorderColorProp = { L"BorderColor", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvBorderColor, NULL, (Value*)&svDefaultBorderColor, _PIDX_BorderColor, _PIDX_BorderColor };
PropertyInfo* Element::BorderColorProp = &impBorderColorProp;

// Padding property
static int vvPadding[] = { DUIV_RECT, -1 };
static PropertyInfo impPaddingProp = { L"Padding", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsDisplay, vvPadding, NULL, Value::pvRectZero, _PIDX_Padding, _PIDX_Padding };
PropertyInfo* Element::PaddingProp = &impPaddingProp;

// Margin property
static int vvMargin[] = { DUIV_RECT, -1 };
static PropertyInfo impMarginProp = { L"Margin", PF_Normal|PF_Cascade, PG_AffectsParentDesiredSize|PG_AffectsParentLayout, vvMargin, NULL, Value::pvRectZero, _PIDX_Margin, _PIDX_Margin };
PropertyInfo* Element::MarginProp = &impMarginProp;

// Foreground property
static int vvForeground[] = { DUIV_INT /*Std Color*/, DUIV_FILL, DUIV_GRAPHIC, -1 }; StaticValue(svDefaultForeground, DUIV_INT, SC_Black);
static PropertyInfo impForegroundProp = { L"Foreground", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvForeground, NULL, (Value*)&svDefaultForeground, _PIDX_Foreground, _PIDX_Foreground };
PropertyInfo* Element::ForegroundProp = &impForegroundProp;

// Background property
#ifdef GADGET_ENABLE_GDIPLUS                                    
static int vvBackground[] = { DUIV_INT /*Std Color*/, DUIV_FILL, DUIV_GRAPHIC, -1 };
static PropertyInfo impBackgroundProp = { L"Background", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvBackground, NULL, Value::pvColorTrans, _PIDX_Background, _PIDX_Background };
#else
static int vvBackground[] = { DUIV_INT /*Std Color*/, DUIV_FILL, DUIV_GRAPHIC, -1 }; StaticValue(svDefaultBackground, DUIV_INT, SC_White);
static PropertyInfo impBackgroundProp = { L"Background", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvBackground, NULL, (Value*)&svDefaultBackground, _PIDX_Background, _PIDX_Background };
#endif // GADGET_ENABLE_GDIPLUS                                    
PropertyInfo* Element::BackgroundProp = &impBackgroundProp;

// Content property
static int vvContent[] = { DUIV_STRING, DUIV_GRAPHIC, DUIV_FILL, -1 };
static PropertyInfo impContentProp = { L"Content", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsDisplay, vvContent, NULL, Value::pvStringNull, _PIDX_Content, _PIDX_Content };
PropertyInfo* Element::ContentProp = &impContentProp;

// FontFace property
static int vvFontFace[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultFontFace, DUIV_STRING, (void*)L"Arial");
static PropertyInfo impFontFaceProp = { L"FontFace", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDesiredSize|PG_AffectsDisplay, vvFontFace, NULL, (Value*)&svDefaultFontFace, _PIDX_FontFace, _PIDX_FontFace };
PropertyInfo* Element::FontFaceProp = &impFontFaceProp;

// FontSize property
static int vvFontSize[] = { DUIV_INT, -1 }; StaticValue(svDefaultFontSize, DUIV_INT, 20);
static PropertyInfo impFontSizeProp = { L"FontSize", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDesiredSize|PG_AffectsDisplay, vvFontSize, NULL, (Value*)&svDefaultFontSize, _PIDX_FontSize, _PIDX_FontSize };
PropertyInfo* Element::FontSizeProp = &impFontSizeProp;

// FontWeight property
static int vvFontWeight[] = { DUIV_INT, -1 }; StaticValue(svDefaultFontWeight, DUIV_INT, FW_Normal);
static EnumMap emFontWeight[] = { { L"DontCare", FW_DontCare}, { L"Thin", FW_Thin }, { L"ExtraLight", FW_ExtraLight }, { L"Light", FW_Light }, { L"Normal", FW_Normal }, 
                                  { L"Medium", FW_Medium }, { L"SemiBold", FW_SemiBold }, { L"Bold", FW_Bold }, { L"ExtraBold", FW_ExtraBold }, { L"Heavy", FW_Heavy }, { NULL, 0 } };
static PropertyInfo impFontWeightProp = { L"FontWeight", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDesiredSize|PG_AffectsDisplay, vvFontWeight, emFontWeight, (Value*)&svDefaultFontWeight, _PIDX_FontWeight, _PIDX_FontWeight };
PropertyInfo* Element::FontWeightProp = &impFontWeightProp;

// FontStyle property
static int vvFontStyle[] = { DUIV_INT, -1 };
static EnumMap emFontStyle[] = { { L"None", FS_None }, { L"Italic", FS_Italic }, { L"Underline", FS_Underline }, { L"StrikeOut", FS_StrikeOut }, { L"Shadow", FS_Shadow }, { NULL, 0 } };
static PropertyInfo impFontStyleProp = { L"FontStyle", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvFontStyle, emFontStyle, Value::pvIntZero /*FS_None*/, _PIDX_FontStyle, _PIDX_FontStyle };
PropertyInfo* Element::FontStyleProp = &impFontStyleProp;

// Active property
static int vvActive[] = { DUIV_INT, -1 }; 
static EnumMap emActive[] = { { L"Inactive", AE_Inactive }, { L"Mouse", AE_Mouse }, { L"Keyboard", AE_Keyboard }, { L"MouseAndKeyboard", AE_MouseAndKeyboard }, { NULL, 0 } };
static PropertyInfo impActiveProp = { L"Active", PF_Normal, 0, vvActive, emActive, Value::pvIntZero /*AE_Inactive*/, _PIDX_Active, _PIDX_Active };
PropertyInfo* Element::ActiveProp = &impActiveProp;

// ContentAlign property
static int vvContentAlign[] = { DUIV_INT, -1 };
static EnumMap emContentAlign[] = { { L"TopLeft", CA_TopLeft }, { L"TopCenter", CA_TopCenter }, { L"TopRight", CA_TopRight },
                                    { L"MiddleLeft", CA_MiddleLeft }, { L"MiddleCenter", CA_MiddleCenter }, { L"MiddleRight", CA_MiddleRight }, 
                                    { L"BottomLeft", CA_BottomLeft }, { L"BottomCenter", CA_BottomCenter }, { L"BottomRight", CA_BottomRight },
                                    { L"WrapLeft", CA_WrapLeft }, { L"WrapCenter", CA_WrapCenter }, { L"WrapRight", CA_WrapRight },
                                    { L"EndEllipsis", CA_EndEllipsis }, { L"FocusRect", CA_FocusRect }, { NULL, 0 } };
#ifdef GADGET_ENABLE_GDIPLUS                                    
static PropertyInfo impContentAlignProp = { L"ContentAlign", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvContentAlign, emContentAlign, Value::pvIntZero /*CA_TopLeft*/, _PIDX_ContentAlign, _PIDX_ContentAlign };
#else
static PropertyInfo impContentAlignProp = { L"ContentAlign", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvContentAlign, emContentAlign, Value::pvIntZero /*CA_TopLeft*/, _PIDX_ContentAlign, _PIDX_ContentAlign };
#endif // GADGET_ENABLE_GDIPLUS                                    
PropertyInfo* Element::ContentAlignProp = &impContentAlignProp;

// KeyFocused property
static int vvKeyFocused[] = { DUIV_BOOL, -1 };
static PropertyInfo impKeyFocusedProp = { L"KeyFocused", PF_Normal|PF_ReadOnly|PF_Inherit /*Conditional inherit*/, 0, vvKeyFocused, NULL, Value::pvBoolFalse, _PIDX_KeyFocused, _PIDX_KeyFocused };
PropertyInfo* Element::KeyFocusedProp = &impKeyFocusedProp;

// KeyWithin property
static int vvKeyWithin[] = { DUIV_BOOL, -1 };
static PropertyInfo impKeyWithinProp = { L"KeyWithin", PF_LocalOnly|PF_ReadOnly, 0, vvKeyWithin, NULL, Value::pvBoolFalse, _PIDX_KeyWithin, _PIDX_KeyWithin };
PropertyInfo* Element::KeyWithinProp = &impKeyWithinProp;

// MouseFocused property
static int vvMouseFocused[] = { DUIV_BOOL, -1 }; 
static PropertyInfo impMouseFocusedProp = { L"MouseFocused", PF_Normal|PF_ReadOnly|PF_Inherit /*Conditional inherit*/, 0, vvMouseFocused, NULL, Value::pvBoolFalse, _PIDX_MouseFocused, _PIDX_MouseFocused };
PropertyInfo* Element::MouseFocusedProp = &impMouseFocusedProp;

// MouseWithin property
static int vvMouseWithin[] = { DUIV_BOOL, -1 };
static PropertyInfo impMouseWithinProp = { L"MouseWithin", PF_LocalOnly|PF_ReadOnly, 0, vvMouseWithin, NULL, Value::pvBoolFalse, _PIDX_MouseWithin, _PIDX_MouseWithin };
PropertyInfo* Element::MouseWithinProp = &impMouseWithinProp;

// Class property
static int vvClass[] = { DUIV_STRING, -1 };
static PropertyInfo impClassProp = { L"Class", PF_Normal, 0, vvClass, NULL, Value::pvStringNull, _PIDX_Class, _PIDX_Class };
PropertyInfo* Element::ClassProp = &impClassProp;

// ID property
static int vvID[] = { DUIV_ATOM, -1 };
static PropertyInfo impIDProp = { L"ID", PF_Normal, 0, vvID, NULL, Value::pvAtomZero, _PIDX_ID, _PIDX_ID };
PropertyInfo* Element::IDProp = &impIDProp;

// Sheet property
static int vvSheet[] = { DUIV_SHEET, -1 };
static PropertyInfo impSheetProp = { L"Sheet", PF_Normal|PF_Inherit, 0, vvSheet, NULL, Value::pvSheetNull, _PIDX_Sheet, _PIDX_Sheet };
PropertyInfo* Element::SheetProp = &impSheetProp;

// Selected property
static int vvSelected[] = { DUIV_BOOL, -1 };
static PropertyInfo impSelectedProp = { L"Selected", PF_Normal|PF_Inherit, 0, vvSelected, NULL, Value::pvBoolFalse, _PIDX_Selected, _PIDX_Selected };
PropertyInfo* Element::SelectedProp = &impSelectedProp;

// Alpha property
static int vvAlpha[] = { DUIV_INT, -1 }; StaticValue(svDefaultAlpha, DUIV_INT, 255 /*Opaque*/);
static PropertyInfo impAlphaProp = { L"Alpha", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvAlpha, NULL, (Value*)&svDefaultAlpha, _PIDX_Alpha, _PIDX_Alpha };
PropertyInfo* Element::AlphaProp = &impAlphaProp;

// Animation property
static int vvAnimation[] = { DUIV_INT, -1 };
static EnumMap emAnimation[] = { { L"Linear", ANI_Linear }, { L"Log", ANI_Log }, { L"Exp", ANI_Exp }, { L"S", ANI_S }, 
                                 { L"DelayShort", ANI_DelayShort }, { L"DelayMedium", ANI_DelayMedium }, { L"DelayLong", ANI_DelayLong },
                                 { L"Alpha", ANI_Alpha }, { L"Position", ANI_Position }, { L"Size", ANI_Size }, { L"SizeH", ANI_SizeH }, { L"SizeV", ANI_SizeV }, { L"Rectangle", ANI_Rect }, { L"RectangleH", ANI_RectH }, { L"RectangleV", ANI_RectV }, { L"Scale", ANI_Scale },
                                 { L"VeryFast", ANI_VeryFast }, { L"Fast", ANI_Fast }, { L"MediumFast", ANI_MediumFast }, { L"MediumSlow", ANI_MediumSlow }, { L"Medium", ANI_Medium },
                                 { L"MediumSlow", ANI_MediumSlow }, { L"Slow", ANI_Fast }, { L"VerySlow", ANI_VerySlow }, { NULL, 0 } };
static PropertyInfo impAnimationProp = { L"Animation", PF_Normal|PF_Cascade, 0, vvAnimation, emAnimation, Value::pvIntZero, _PIDX_Animation, _PIDX_Animation };
PropertyInfo* Element::AnimationProp = &impAnimationProp;

// Cursor property
static int vvCursor[] = { DUIV_INT, DUIV_CURSOR, -1 };
static EnumMap emCursor[] = { { L"Arrow", CUR_Arrow }, { L"Hand", CUR_Hand }, { L"Help", CUR_Help }, 
                              { L"No", CUR_No }, { L"Wait", CUR_Wait }, { L"SizeAll", CUR_SizeAll },
                              { L"SizeNESW", CUR_SizeNESW }, { L"SizeNS", CUR_SizeNS }, { L"SizeNWSE", CUR_SizeNWSE },
                              { L"SizeWE", CUR_SizeWE }, { NULL, 0 } };
static PropertyInfo impCursorProp = { L"Cursor", PF_Normal|PF_Inherit|PF_Cascade, 0, vvCursor, emCursor, Value::pvIntZero /*CUR_Arrow*/, _PIDX_Cursor, _PIDX_Cursor };
PropertyInfo* Element::CursorProp = &impCursorProp;

// Direction property
static int vvDirection[] = { DUIV_INT, -1 }; StaticValue(svDefaultDirection, DUIV_INT, 0);
static EnumMap emDirection[] = { { L"LTR", DIRECTION_LTR }, { L"RTL", DIRECTION_RTL } };
static PropertyInfo impDirectionProp = { L"Direction", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsLayout|PG_AffectsDisplay, vvDirection, emDirection, (Value*)&svDefaultDirection, _PIDX_Direction, _PIDX_Direction };
PropertyInfo* Element::DirectionProp = &impDirectionProp;

// Accessible property
static int vvAccessible[] = { DUIV_BOOL, -1 };
static PropertyInfo impAccessibleProp = { L"Accessible", PF_Normal|PF_Cascade, 0, vvAccessible, NULL, Value::pvBoolFalse, _PIDX_Accessible, _PIDX_Accessible };
PropertyInfo* Element::AccessibleProp = &impAccessibleProp;

// AccRole property
static int vvAccRole[] = { DUIV_INT, -1 };
static PropertyInfo impAccRoleProp = { L"AccRole", PF_Normal|PF_Cascade, 0, vvAccRole, NULL, Value::pvIntZero, _PIDX_AccRole, _PIDX_AccRole };
PropertyInfo* Element::AccRoleProp = &impAccRoleProp;

// AccState property
static int vvAccState[] = { DUIV_INT, -1 };
static PropertyInfo impAccStateProp = { L"AccState", PF_Normal|PF_Cascade, 0, vvAccState, NULL, Value::pvIntZero, _PIDX_AccState, _PIDX_AccState };
PropertyInfo* Element::AccStateProp = &impAccStateProp;

// AccName property
static int vvAccName[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccName, DUIV_STRING, (void*)L"");
static PropertyInfo impAccNameProp = { L"AccName", PF_Normal|PF_Cascade, 0, vvAccName, NULL, (Value*)&svDefaultAccName, _PIDX_AccName, _PIDX_AccName };
PropertyInfo* Element::AccNameProp = &impAccNameProp;

// AccDesc property
static int vvAccDesc[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccDesc, DUIV_STRING, (void*)L"");
static PropertyInfo impAccDescProp = { L"AccDesc", PF_Normal|PF_Cascade, 0, vvAccDesc, NULL, (Value*)&svDefaultAccDesc, _PIDX_AccDesc, _PIDX_AccDesc };
PropertyInfo* Element::AccDescProp = &impAccDescProp;

// AccValue property
static int vvAccValue[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccValue, DUIV_STRING, (void*)L"");
static PropertyInfo impAccValueProp = { L"AccValue", PF_Normal|PF_Cascade, 0, vvAccValue, NULL, (Value*)&svDefaultAccValue, _PIDX_AccValue, _PIDX_AccValue };
PropertyInfo* Element::AccValueProp = &impAccValueProp;

// AccDefAction property
static int vvAccDefAction[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccDefAction, DUIV_STRING, (void*)L"");
static PropertyInfo impAccDefActionProp = { L"AccDefAction", PF_Normal|PF_Cascade, 0, vvAccDefAction, NULL, (Value*)&svDefaultAccDefAction, _PIDX_AccDefAction, _PIDX_AccDefAction };
PropertyInfo* Element::AccDefActionProp = &impAccDefActionProp;

// Shortcut property
static int vvShortcut[] = { DUIV_INT, -1 };
static PropertyInfo impShortcutProp = { L"Shortcut", PF_Normal|PF_Cascade, PG_AffectsDesiredSize | PG_AffectsDisplay, vvShortcut, NULL, Value::pvIntZero, _PIDX_Shortcut, _PIDX_Shortcut };
PropertyInfo* Element::ShortcutProp = &impShortcutProp;

// Enabled property
static int vvEnabled[] = { DUIV_BOOL, -1 };
static PropertyInfo impEnabledProp = { L"Enabled", PF_Normal|PF_Cascade|PF_Inherit, 0, vvEnabled, NULL, Value::pvBoolTrue, _PIDX_Enabled, _PIDX_Enabled };
PropertyInfo* Element::EnabledProp = &impEnabledProp;

////////////////////////////////////////////////////////
// ClassInfo

// ClassInfo to name mapping
BTreeLookup<IClassInfo*>* Element::pciMap = NULL;

// Class properties 
static PropertyInfo* _aPI[] = {
                                 Element::ParentProp,            // DS, Layt, Disp
                                 Element::WidthProp,             // DS
                                 Element::HeightProp,            // DS
                                 Element::ChildrenProp,          // DS, Layt, Disp
                                 Element::VisibleProp,           // Disp
                                 Element::LocationProp,          // Disp, Bnds
                                 Element::ExtentProp,            // Layt, Disp, Bnds
                                 Element::XProp,                 //
                                 Element::YProp,                 //
                                 Element::PosInLayoutProp,       //
                                 Element::SizeInLayoutProp,      //
                                 Element::DesiredSizeProp,       // Layt, LaytP, Disp
                                 Element::LastDSConstProp,       //
                                 Element::LayoutProp,            // DS, Layt, Disp
                                 Element::LayoutPosProp,         // DS, LaytP
                                 Element::BorderThicknessProp,   // DS, Disp
                                 Element::BorderStyleProp,       // Disp
                                 Element::BorderColorProp,       // Disp
                                 Element::PaddingProp,           // DS, Disp
                                 Element::MarginProp,            // DS, Layt, Disp
                                 Element::ForegroundProp,        // Disp
                                 Element::BackgroundProp,        // Disp
                                 Element::ContentProp,           // DS, Disp
                                 Element::FontFaceProp,          // DS, Disp
                                 Element::FontSizeProp,          // DS, Disp
                                 Element::FontWeightProp,        // Disp
                                 Element::FontStyleProp,         // Disp
                                 Element::ActiveProp,            //
                                 Element::ContentAlignProp,      // Disp
                                 Element::KeyFocusedProp,        //
                                 Element::KeyWithinProp,         //
                                 Element::MouseFocusedProp,      //
                                 Element::MouseWithinProp,       //
                                 Element::ClassProp,             //
                                 Element::IDProp,                //
                                 Element::SheetProp,             //
                                 Element::SelectedProp,          //
                                 Element::AlphaProp,             // Disp
                                 Element::AnimationProp,         //
                                 Element::CursorProp,            //
                                 Element::DirectionProp,         // Layt, Disp
                                 Element::AccessibleProp,        //
                                 Element::AccRoleProp,           //
                                 Element::AccStateProp,          //
                                 Element::AccNameProp,           //
                                 Element::AccDescProp,           //
                                 Element::AccValueProp,          //
                                 Element::AccDefActionProp,      //
                                 Element::ShortcutProp,          // DS, Disp
                                 Element::EnabledProp,           //
                              };

// Element has a specialized IClassInfo implemention since it has no base class
// and it's properties are manually initialized to known values for optimization.
// All other Element-derived classes use ClassInfo<C,B>
class ElementClassInfo : public IClassInfo
{
public:
    // Registration (cannot unregister -- will be registered until UnInitProcess is called)
    static HRESULT Register(PropertyInfo** ppPI, UINT cPI)
    {
        HRESULT hr;
    
        // If class mapping doesn't exist, registration fails 
        if (!Element::pciMap)
            return E_FAIL;

        // Check for entry in mapping, if exists, ignore registration
        if (!Element::pciMap->GetItem((void*)L"Element"))
        {
            // Never been registered, create class info entry
            hr = Create(ppPI, cPI, &Element::Class);
            if (FAILED(hr))
                return hr;
        
            hr = Element::pciMap->SetItem((void*)L"Element", Element::Class);
            if (FAILED(hr))
                return hr;
        }

        return S_OK;
    }

    static HRESULT Create(PropertyInfo** ppPI, UINT cPI, IClassInfo** ppCI)
    {
        *ppCI = NULL;

        ElementClassInfo* peci = HNew<ElementClassInfo>();
        if (!peci)
            return E_OUTOFMEMORY;

        // Setup state
        peci->_ppPI = ppPI; 
        peci->_cPI = cPI;

        // Setup property ownership
        for (UINT i = 0; i < cPI; i++)
        {
            // Index and global index are manually coded
            ppPI[i]->_pciOwner = peci;
        }

        *ppCI = peci;

        //DUITrace("RegDUIClass[0]: 'Element', %d ClassProps\n", cPI);

        return S_OK;
    }

    void Destroy() { HDelete<ElementClassInfo>(this); }

    HRESULT CreateInstance(OUT Element** ppElement) { return Element::Create(0, ppElement); };
    PropertyInfo* EnumPropertyInfo(UINT nEnum) { return (nEnum < _cPI) ? _ppPI[nEnum] : NULL; }
    UINT GetPICount() { return _cPI; }
    UINT GetGlobalIndex() { return 0; } // Reserved by Element
    IClassInfo* GetBaseClass() { return NULL; }
    LPCWSTR GetName() { return L"Element"; }
    bool IsValidProperty(PropertyInfo* ppi) { return ppi->_pciOwner == this; }
    bool IsSubclassOf(IClassInfo* pci) { return pci == this; }

    ElementClassInfo() { }
    virtual ~ElementClassInfo() { }

private:
    PropertyInfo** _ppPI;
    UINT _cPI;
};

// Process wide zero-based consecutive unique ClassInfo and PropertyInfo counters.
// Element is manually set and reserves class index 0 and property indicies 0 through 
// _PIDX_TOTAL-1. These values are used by ClassInfo<C,B> constructors during process
// initialization (these constructor calls are synchronous).

// Initialized on main thread
UINT g_iGlobalCI = 1;
UINT g_iGlobalPI = _PIDX_TOTAL;

// Define class info with type and base type, init static class pointer
IClassInfo* Element::Class = NULL;

HRESULT Element::Register()
{
    return ElementClassInfo::Register(_aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\control\viewer.cpp ===
/*
 * Viewer
 */

#include "stdafx.h"
#include "control.h"

#include "duiviewer.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Viewer

HRESULT Viewer::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Viewer* pvw = HNew<Viewer>();
    if (!pvw)
        return E_OUTOFMEMORY;

    HRESULT hr = pvw->Initialize();
    if (FAILED(hr))
        return hr;

    *ppElement = pvw;

    return S_OK;
}

HRESULT Viewer::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(EC_SelfLayout); // Normal display node, self layout
    if (FAILED(hr))
        return hr;

    // Children can exist outside of Element bounds
    SetGadgetStyle(GetDisplayNode(), GS_CLIPINSIDE, GS_CLIPINSIDE);

    SetActive(AE_Inactive);

    return S_OK;
}

////////////////////////////////////////////////////////
// Generic eventing

void Viewer::OnEvent(Event* pEvent)
{
    Element::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// System events

void Viewer::OnInput(InputEvent* pie)
{
    Element::OnInput(pie);
}

// Validation
bool Viewer::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    UNREFERENCED_PARAMETER(ppi);
    UNREFERENCED_PARAMETER(iIndex);
    UNREFERENCED_PARAMETER(pvOld);
    UNREFERENCED_PARAMETER(pvNew);

    return true;
}

void Viewer::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

Element* Viewer::GetContent()
{
    Value* pv;
    ElementList* peList = GetChildren(&pv);

    if (!peList || !peList->GetSize())
    {
        pv->Release();
        return NULL;
    }

    Element* pe = peList->GetItem(0);
    pv->Release();
    return pe;
}

bool Viewer::InternalEnsureVisible(int x, int y, int cx, int cy)
{
    Element* peContent = GetContent();
    if (!peContent)
        return false;

    bool changed = false;

    Value* pvSize;
    Value* pvPoint;
    const POINT* pptContent = peContent->GetLocation(&pvPoint);
    const SIZE* psizeView = GetExtent(&pvSize);

    POINT ptContent;
    ptContent.x = pptContent->x;
    ptContent.y = pptContent->y;

    SIZE sizeView;
    sizeView.cx = psizeView->cx;
    sizeView.cy = psizeView->cy;
    POINT ptView = { 0, 0 };

    // check horizontal location
    int diff = (x + cx) - sizeView.cx;

    // if it fills the width, then don't scroll it horizontally
    if ((x > ptView.x) || (diff < 0))
    {
        // doesn't fill width -- adjust horizontal as necessary
        if (diff < 0)
            // the right side is ok
            diff = 0;
        else
            // the right side runs out the right side of the view
            ptView.x += diff;

        if (ptView.x > x)
            // the left side runs out the left side of the view
            diff -= ptView.x - x;

        if (diff != 0)
        {
            ptContent.x -= diff;
            x -= diff;
            changed = true;
        }
    }

    diff = (y + cy) - sizeView.cy;

    // if it fills the height, then don't scroll it vertically
    if ((y > ptView.y) || (diff < 0))
    {
        // doesn't fill height -- adjust vertical as necessary
        if (diff < 0)
            diff = 0;
        else
            ptView.y += diff;

        if (ptView.y > y)
            diff -= ptView.y - y;

        if (diff != 0)
        {
            ptContent.y -= diff;
            y -= diff;
            changed = true;
        }
    }

    if (changed)
    {
        StartDefer();
        SetXOffset(-ptContent.x);
        SetYOffset(-ptContent.y);
        Element::EnsureVisible(x, y, cx, cy);
        EndDefer();
    }

    pvPoint->Release();
    pvSize->Release();

    return changed;
}


bool Viewer::EnsureVisible(int x, int y, int cx, int cy)
{
    return InternalEnsureVisible(x, y, cx, cy);
}


////////////////////////////////////////////////////////
// Self-layout methods

void Viewer::_SelfLayoutDoLayout(int cx, int cy)
{
    Element* peContent = GetContent();
    if (peContent)
    {   
        // todo -- investigate why this isn't being called -- most probably because we're returning the same
        // desired size?
        const SIZE* psizeContent = peContent->GetDesiredSize();

        POINT ptContent;
        ptContent.x = GetXOffset();
        ptContent.y = GetYOffset();

        SIZE sizeContent;
        sizeContent.cx = psizeContent->cx;
        sizeContent.cy = psizeContent->cy;

        // make sure size at least covers container's bounds
        if (sizeContent.cx < cx)
            sizeContent.cx = cx;
        if (sizeContent.cy < cy)
            sizeContent.cy = cy;

        peContent->_UpdateLayoutSize(sizeContent.cx, sizeContent.cy);

        // now make sure location allows for content to cover container's bounds
        sizeContent.cx -= cx;
        sizeContent.cy -= cy;

        if (ptContent.x > sizeContent.cx)
            ptContent.x = sizeContent.cx;
        if (ptContent.y > sizeContent.cy)
            ptContent.y = sizeContent.cy;

        peContent->_UpdateLayoutPosition(-ptContent.x, -ptContent.y);
    }
}

SIZE Viewer::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    Element* peContent = GetContent();
    SIZE size = { 0, 0 };

    if (peContent)
    {
        size = peContent->_UpdateDesiredSize(
                    (GetXScrollable() ? INT_MAX : cxConstraint),
                    (GetYScrollable() ? INT_MAX : cyConstraint),
                    psrf);

        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;
    }

    return size;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// XOffset property
static int vvXOffset[] = { DUIV_INT, -1 };
static PropertyInfo impXOffsetProp = { L"XOffset", PF_Normal, PG_AffectsLayout, vvXOffset, NULL, Value::pvIntZero };
PropertyInfo* Viewer::XOffsetProp = &impXOffsetProp;

// YOffset property
static int vvYOffset[] = { DUIV_INT, -1 };
static PropertyInfo impYOffsetProp = { L"YOffset", PF_Normal, PG_AffectsLayout, vvYOffset, NULL, Value::pvIntZero };
PropertyInfo* Viewer::YOffsetProp = &impYOffsetProp;

// XScrollable property
static int vvXScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impXScrollableProp = { L"XScrollable", PF_Normal, PG_AffectsDesiredSize, vvXScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* Viewer::XScrollableProp = &impXScrollableProp;

// YScrollable property
static int vvYScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impYScrollableProp = { L"YScrollable", PF_Normal, PG_AffectsDesiredSize, vvYScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* Viewer::YScrollableProp = &impYScrollableProp;


////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Viewer::XOffsetProp,
                                Viewer::YOffsetProp,
                                Viewer::XScrollableProp,
                                Viewer::YScrollableProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Viewer::Class = NULL;

HRESULT Viewer::Register()
{
    return ClassInfo<Viewer,Element>::Register(L"Viewer", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\layout.cpp ===
/*
 * Layout
 */

#include "stdafx.h"
#include "core.h"

#include "duilayout.h"

#include "duielement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Base layout

// Not shareable by default

////////////////////////////////////////////////////////
// Callbacks from clients

HRESULT Layout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    Layout* pl = HNew<Layout>();
    if (!pl)
        return E_OUTOFMEMORY;

    pl->Initialize();

    *ppLayout = pl;

    return S_OK;
}

void Layout::Initialize()
{
    _peClient = NULL;
    _pdaIgnore = NULL;
    SetCacheDirty();
}

Layout::~Layout()
{
    if (_pdaIgnore)
        _pdaIgnore->Destroy();
}

void Layout::UpdateLayoutRect(Element* pec, int cxContainer, int cyContainer, Element* peChild, int xElement, int yElement, int cxElement, int cyElement)
{
    UNREFERENCED_PARAMETER(cyContainer);

    if (pec->IsRTL())
        xElement = cxContainer - (xElement + cxElement);

    peChild->_UpdateLayoutPosition(xElement, yElement);
    peChild->_UpdateLayoutSize(cxElement, cyElement);
}

void Layout::DoLayout(Element* pec, int dWidth, int dHeight)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(dWidth);
    UNREFERENCED_PARAMETER(dHeight);
}

SIZE Layout::UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(dConstW);
    UNREFERENCED_PARAMETER(dConstH);
    UNREFERENCED_PARAMETER(psrf);

    SIZE sizeDS;

    ZeroMemory(&sizeDS, sizeof(SIZE));

    return sizeDS;
}

// Helper: Sort Ignore list by index
int __cdecl _IdxCompare(const void* pA, const void* pB)
{
    if ((*((Element**)pA))->GetIndex() == (*((Element**)pB))->GetIndex())
        return 0;
    else if ((*((Element**)pA))->GetIndex() < (*((Element**)pB))->GetIndex())
        return -1;
    else
        return 1;
}

// Layout callbacks happen as a result of OnPropertyChanges, these events
// are deferred if sets happen within an OnPropertyChange (in which case,
// the outter-most set fires the events). A return to steady state happens
// after every set (however, as stated, the events are deferred).
//
// This means that these callbacks may happen as changes happen to the
// context, or after all the changes happen. This is taken into account
// when determining if Elements should be ingored for layout.
//
// May have been Added or Removed as a result of an OnPropertyChanged().
// If this is the case, parent and layout pos state will be updated
// before the events come in (which will call these methods). Both
// methods will update the ignore list (if was not called from OnPropertyChanged(),
// only one method would update the ignore list). All events to update
// the Layout's ignore state will complete before control is returned

// TODO: Investigate using b-search for GetIndexOf is list already sorted
void Layout::OnAdd(Element* pec, Element** ppeAdd, UINT cCount)
{
    UNREFERENCED_PARAMETER(pec);

    int dLayoutPos;
    bool fReSort = false;

    for (UINT i = 0; i < cCount; i++)
    {
        dLayoutPos = ppeAdd[i]->GetLayoutPos();

        // Check if should ignore
        if (dLayoutPos == LP_Absolute || dLayoutPos == LP_None)
        {
            // Create ignore list if needed
            if (!_pdaIgnore)
                DynamicArray<Element*>::Create(0, false, &_pdaIgnore);

            if (_pdaIgnore && _pdaIgnore->GetIndexOf(ppeAdd[i]) == -1)
            {
                _pdaIgnore->Add(ppeAdd[i]);
                fReSort = true;
            }
        }
    }

    // List must stay sorted by Element index for mapping lookup
    if (fReSort)
        _pdaIgnore->Sort(_IdxCompare);

    SetCacheDirty();
}

void Layout::OnRemove(Element* pec, Element** ppeRemove, UINT cCount)
{
    UNREFERENCED_PARAMETER(pec);

    int dLayoutPos;
    bool fReSort = false;

    for (UINT i = 0; i < cCount; i++)
    {
        dLayoutPos = ppeRemove[i]->GetLayoutPos();

        // Check if was ignored
        if (dLayoutPos == LP_Absolute || dLayoutPos == LP_None)
        {
            DUIAssert(_pdaIgnore, "Layout ignore list unavailable in remove");

            if (_pdaIgnore)
            {
                int dIgnIdx = _pdaIgnore->GetIndexOf(ppeRemove[i]);
                if (dIgnIdx != -1)
                {
                    _pdaIgnore->Remove(dIgnIdx);
                    fReSort = true;
                }
            }
        }
    }

    // List must stay sorted by Element index for mapping lookup
    if (fReSort)
        _pdaIgnore->Sort(_IdxCompare);

    SetCacheDirty();
}

void Layout::OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP)
{
    UNREFERENCED_PARAMETER(pec);

    DUIAssert(dOldLP != dNewLP, "Should not be receiving layout pos change if old and new are the same");

    //DUITrace("LayoutPos Change!\n");

    //DUITrace("Currently being ignored:\n");
    //for (UINT i = 0; i < _daIgnore.GetSize(); i++)
    //    DUITrace("%d\n", _daIgnore.GetItem(i)->GetIndex());

    bool fReSort = false;

    // Check if was ignored
    if (dOldLP == LP_Absolute || dOldLP == LP_None)
    {
        DUIAssert(_pdaIgnore, "Layout ignore list unavailable in remove");

        if (_pdaIgnore)
        {
            int dIgnIdx = _pdaIgnore->GetIndexOf(peChanged);
            if (dIgnIdx != -1)
            {
                _pdaIgnore->Remove(dIgnIdx);
                fReSort = true;
            }
        }
    }

    // Check if should ignore
    if (dNewLP == LP_Absolute || dNewLP == LP_None)
    {
        // Create ignore list if needed
        if (!_pdaIgnore)
            DynamicArray<Element*>::Create(0, false, &_pdaIgnore);

        if (_pdaIgnore && _pdaIgnore->GetIndexOf(peChanged) == -1)
            _pdaIgnore->Add(peChanged);
            fReSort = true;
    }

    // List must stay sorted by Element index for mapping lookup
    if (fReSort)
        _pdaIgnore->Sort(_IdxCompare);

    SetCacheDirty();

    //DUITrace("Now being ignored:\n");
    //for (UINT i = 0; i < _daIgnore.GetSize(); i++)
    //    DUITrace("%d\n", _daIgnore.GetItem(i)->GetIndex());
}

void Layout::Attach(Element* pec)
{
    DUIAssert(!_peClient, "Multiple clients not yet supported");

    _peClient = pec;

    SetCacheDirty();
}

void Layout::Detach(Element* pec)
{
    UNREFERENCED_PARAMETER(pec);

    _peClient = NULL;

    if (_pdaIgnore)
        _pdaIgnore->Reset();

    SetCacheDirty();
}

////////////////////////////////////////////////////////
// Client query methods (omits absolute children)

UINT Layout::GetLayoutChildCount(Element* pec)
{
    Value* pv;

    ElementList* peList = pec->GetChildren(&pv);

    // Less absolute children
    UINT dCount = 0;
    if (peList)
    {
        dCount = peList->GetSize();
        if (_pdaIgnore)
            dCount -= _pdaIgnore->GetSize();
    }

    pv->Release();

    return dCount;
}

int Layout::GetLayoutIndexFromChild(Element* pec, Element* peChild)
{
    UNREFERENCED_PARAMETER(pec);

    DUIAssert(peChild->GetParent() == pec, "Not a child of specified parent");

    int iLayoutIdx = peChild->GetIndex();

    if (_pdaIgnore && _pdaIgnore->GetSize())
    {   
        UINT i = 0;
        while (i < _pdaIgnore->GetSize() && _pdaIgnore->GetItem(i)->GetIndex() <= iLayoutIdx)
        {
            i++;
        }

        iLayoutIdx -= i;
    }

    return iLayoutIdx;
}

Element* Layout::GetChildFromLayoutIndex(Element* pec, int iLayoutIdx, ElementList* peList)
{
    Value* pvChildren = NULL;

    // If no child list supplied, get
    if (!peList)
        peList = pec->GetChildren(&pvChildren);

    int iIndex = iLayoutIdx;

    if (_pdaIgnore && _pdaIgnore->GetSize())
    {
        UINT i = 0;
        while (i < _pdaIgnore->GetSize() && _pdaIgnore->GetItem(i)->GetIndex() <= iIndex)
        {
            iIndex++;
            i++;
        }
    }

    Element* peChild = NULL;

    if ((UINT)iIndex < peList->GetSize())
        peChild = peList->GetItem(iIndex);

    if (pvChildren)
        pvChildren->Release();

    return peChild;
}

Element* Layout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(peFrom);
    UNREFERENCED_PARAMETER(iNavDir);
    UNREFERENCED_PARAMETER(pnr);
    UNREFERENCED_PARAMETER(bKeyable);

    return GA_NOTHANDLED;
}

BOOL NavScoring::TrackScore(Element* pe, Element* peChild)
{
    Value* pvValue;
    POINT const* ppt = pe->GetLocation(&pvValue);
    int iCheckLow = ((int const*) ppt)[iBaseIndex];
    pvValue->Release();
    SIZE const* psize = pe->GetExtent(&pvValue);
    int iCheckHigh = iCheckLow + ((int const* ) psize)[iBaseIndex];
    pvValue->Release();

    if (iCheckLow < iLow)
        iCheckLow = iLow;

    if (iCheckHigh > iHigh)
        iCheckHigh = iHigh;
    
    int iCheckScore = iCheckHigh - iCheckLow;

    if (iCheckScore > iHighScore)
    {
        iHighScore = iCheckScore;
        peWinner = peChild ? peChild : pe;

        return (iCheckScore > iMajorityScore);
    }

    return FALSE;
}

BOOL NavScoring::Try(Element* peChild, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);

    return (peTo) ? TrackScore(peChild, peTo) : FALSE;
}

void NavScoring::Init(Element* peRelative, int iNavDir, NavReference const* pnr)
{
    Element* peRef;
    RECT* prcRef;

    if (pnr)
    {
        peRef = pnr->pe;
        prcRef = pnr->prc;
    }
    else
    {
        peRef = peRelative;
        prcRef = NULL;
    }

    RECT rc;

    if (prcRef)
        rc = *prcRef;
    else
    {
        Value* pvExtent;
        SIZE const* psize = peRef->GetExtent(&pvExtent);

        rc.left   = 0;
        rc.top    = 0;
        rc.right  = psize->cx;
        rc.bottom = psize->cy;
        pvExtent->Release();
    }

    if (peRelative != peRef)
    {
        POINT pt = { 0, 0 };
        peRelative->MapElementPoint(peRef, &pt, &pt);
        rc.top    += pt.y;
        rc.left   += pt.x;
        rc.bottom += pt.y;
        rc.right  += pt.x;
    }

    iBaseIndex = (iNavDir & NAV_VERTICAL) ? 0 : 1;

    iLow  = ((int*) &rc) [iBaseIndex];
    iHigh = ((int*) &rc) [iBaseIndex + 2];
    iMajorityScore = (iHigh - iLow + 1) / 2;
    iHighScore = 0;
    peWinner = NULL;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\navigation.cpp ===
/*
 * Spatial navigation support
 */

#include "stdafx.h"
#include "core.h"

#include "DUIError.h"
#include "DUIElement.h"
#include "DUINavigation.h"

LONG ScoreConsideredElement(RECT * prcFrom,
                            DirectUI::Element * peFrom,
                            DirectUI::Element * peConsider,
                            int nNavDir)
{
    if (peConsider == NULL) {
        return -1;
    }

    //
    // Get the coordinates of the element being considered and map them into
    // coordinates relative to the element we are navigating from.
    //
    // TODO: This won't work well with rotated gadgets.  Either use a
    // bounding box, or support true intersections.
    //
    RECT rcConsider;
    GetGadgetRect(peConsider->GetDisplayNode(), &rcConsider, SGR_CLIENT);
    MapGadgetPoints(peConsider->GetDisplayNode(), peFrom->GetDisplayNode(), (POINT*)&rcConsider, 2);

    //
    // Do not consider elements who don't intersect the region formed by
    // extending our paralell extents.  If going left or right, extend our
    // top and bottom boundaries horizontally.  An element must intersect
    // that area to be considered.  Do a symetric calculation for up and down.
    //
    switch (nNavDir) {
    case NAV_LEFT:
    case NAV_RIGHT:
        if (rcConsider.bottom < prcFrom->top ||
            rcConsider.top > prcFrom->bottom) {
            return -1;
        }
        break;

    case NAV_UP:
    case NAV_DOWN:
        if (rcConsider.right < prcFrom->left ||
            rcConsider.left > prcFrom->right) {
            return -1;
        }
        break;
    }

    //
    // Do not consider elements that either overlap us or are "behind"
    // us relative to the direction we are navigating.  In other words,
    // do not consider an element unless it is completely in the
    // direction we are navigating.
    //
    //
    switch (nNavDir) {
    case NAV_LEFT:
        if (rcConsider.right > prcFrom->left) {
            return -1;
        }
        break;

    case NAV_RIGHT:
        if (rcConsider.left < prcFrom->right) {
            return -1;
        }
        break;

    case NAV_UP:
        if (rcConsider.bottom > prcFrom->top) {
            return -1;
        }
        break;

    case NAV_DOWN:
        if (rcConsider.top < prcFrom->bottom) {
            return -1;
        }
        break;
    }

    //
    // Finally!  This is an element we should consider.  Assign it a score
    // based on how close it is to us.  Smaller is better, 0 is best, negative
    // scores are invalid.
    //
    switch (nNavDir) {
    case NAV_LEFT:
        return prcFrom->left - rcConsider.right;

    case NAV_RIGHT:
        return rcConsider.left - prcFrom->right;

    case NAV_UP:
        return prcFrom->top - rcConsider.bottom;

    case NAV_DOWN:
        return rcConsider.top - prcFrom->bottom;
    }
    
    return -1;
}

namespace DirectUI
{

//
// The standard algorithm for spatial navigation.
//
// This is not the final algorithm, but a quick starting point.  Initially,
// we only support the 4 primary directions LEFT, UP, RIGHT, and DOWN.
//
// Simply choose the element with the closest opposite edge in the
// direction specified.  Only consider elements that intersets the
// paralell dimensions of the starting element.
//
// For example, if going RIGHT look for an element with a LEFT edge nearest
// to us.
//
// Confused?  Don't worry, its gonna change.
//
Element * DuiNavigate::Navigate(Element * peFrom, ElementList * pelConsider, int nNavDir)
{
    //
    // Validate the input parameters.
    //
    if (peFrom == NULL || pelConsider == NULL) {
        return NULL;
    }
    if (nNavDir != NAV_LEFT && nNavDir != NAV_UP && nNavDir != NAV_RIGHT && nNavDir != NAV_DOWN) {
        return NULL;
    }

    //
    // Get the dimensions of the element we are navidating from.
    //
    RECT rcFrom;
    GetGadgetRect(peFrom->GetDisplayNode(), &rcFrom, SGR_CLIENT);

    Element * peBestScore = NULL;
    Element * peConsider = NULL;
    LONG lBestScore = -1, lScore = -1;
    UINT i;
    UINT iMax = pelConsider->GetSize();

    //
    // Work through the list of elements that we were told to consider.
    // Assign each of them a score, such that smaller scores are better,
    // a score of 0 is best, and negative scores are invalid.  A negative
    // score means that the element should not even be considered an
    // option for navigating in the specified direction.
    //
    for (i = 0; i < iMax; i++) {
        peConsider = pelConsider->GetItem(i);
        lScore = ScoreConsideredElement(&rcFrom, peFrom, peConsider, nNavDir);
        if (lScore >= 0 && (lBestScore < 0 || lScore < lBestScore)) {
            lBestScore = lScore;
            peBestScore = peConsider;
        }
    }

    //
    // Return the element with the best score.
    //
    return peBestScore;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\host.cpp ===
/*
 * Host
 */

#include "stdafx.h"
#include "core.h"

#include "duihost.h"
#include "duiaccessibility.h"
#include "duibutton.h" // todo:  not needed when we switch to using DoDefaultAction for shortcuts


namespace DirectUI
{

////////////////////////////////////////////////////////
// Native surface hosts

////////////////////////////////////////////////////////
// HWNDElement

// HWNDElements are used to host Elements in HWNDs. An HWND parent is provided at
// creation time. This parent cannot be NULL.

// All Element methods are valid. If the native parent is destroyed (DestroyWindow),
// this Element will be destroyed

// HWNDElement cannot be created via the parser (non-optional first parameter)

// Required for ClassInfo (always fails)
HRESULT HWNDElement::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);

    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");

    return E_NOTIMPL;
}

HRESULT HWNDElement::Create(HWND hParent, bool fDblBuffer, UINT nCreate, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDElement* phe = HNew<HWNDElement>();
    if (!phe)
        return E_OUTOFMEMORY;

    HRESULT hr = phe->Initialize(hParent, fDblBuffer, nCreate);
    if (FAILED(hr))
    {
        phe->Destroy();
        return hr;
    }

    *ppElement = phe;

    return S_OK;
}

HRESULT HWNDElement::Initialize(HWND hParent, bool fDblBuffer, UINT nCreate)
{
    HRESULT hr;
    static int RTLOS = -1;

    _hWnd = NULL;
    _hgDisplayNode = NULL;
    _hPal = NULL;
    _wUIState = 0;
    WNDCLASSEXW wcex;
    LRESULT lr = 0;

    // Do base class initialization
    hr = Element::Initialize(nCreate | EC_NoGadgetCreate);  // Will create gadget here
    if (FAILED(hr))
        goto Failed;

    // Register host window class, if needed
    // Winproc will be replaced upon creation
    wcex.cbSize = sizeof(wcex);

    if (!GetClassInfoExW(GetModuleHandleW(NULL), L"DirectUIHWND", &wcex))
    {
        ZeroMemory(&wcex, sizeof(wcex));

        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_GLOBALCLASS;
        wcex.hInstance = GetModuleHandleW(NULL);
        wcex.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
        wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wcex.lpszClassName = L"DirectUIHWND";
        wcex.lpfnWndProc = DefWindowProc;
        wcex.cbWndExtra = sizeof(HWNDElement*);

        if (RegisterClassExW(&wcex) == 0)
        {
            hr = DUI_E_USERFAILURE;
            goto Failed;
        }
    }

    // Create HWND
    _hWnd = CreateWindowExW(0, L"DirectUIHWND", NULL, WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,
                            0, 0, 0, 0, hParent, 0, GetModuleHandleW(NULL), 0);
    if (!_hWnd)
    {
        hr = DUI_E_USERFAILURE;
        goto Failed;
    }

    // Store pointer to the Element in HWND and subclass
    SetWindowLongPtrW(_hWnd, GWLP_WNDPROC, (LONG_PTR)HWNDElement::StaticWndProc);
    SetWindowLongPtrW(_hWnd, 0, (LONG_PTR)this);

    // Inherit keyboard cues UI state from HWND parent
    lr = SendMessageW(hParent, WM_QUERYUISTATE, 0, 0);
    _wUIState = LOWORD(lr);

    // Check if we are running on a Localized or not?
    if (RTLOS == -1)
    {
        LANGID langID = GetUserDefaultUILanguage();

        RTLOS = DIRECTION_LTR;

        if( langID )
        {
            WCHAR wchLCIDFontSignature[16];
            LCID iLCID = MAKELCID( langID , SORT_DEFAULT );

            /*
             * Let's Verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
             * convert to decimal value and call GetLocaleInfo afterwards.
             * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
             */
            if( GetLocaleInfoW( iLCID , 
                                LOCALE_FONTSIGNATURE , 
                                (WCHAR *) &wchLCIDFontSignature[0] ,
                                (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
                /* Let's Verify the bits we have a BiDi UI locale */
                if( wchLCIDFontSignature[7] & (WCHAR)0x0800 )
                    RTLOS = DIRECTION_RTL;
        }
    }

    if (RTLOS == DIRECTION_RTL) 
    {
        SetDirection(DIRECTION_RTL);

        // Turn off mirroring on us.
        SetWindowLongPtrW(_hWnd, GWL_EXSTYLE, GetWindowLongPtrW(_hWnd, GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL);
    }

    // Mirror with Element constructor, however, account for buffering and mouse filtering
    // (must always allow all mouse messages for the root display node)

    _hgDisplayNode = CreateGadget(_hWnd, GC_HWNDHOST, _DisplayNodeCallback, this);
    if (!_hgDisplayNode)
    {
        hr = GetLastError();
        goto Failed;
    }

    SetGadgetMessageFilter(_hgDisplayNode, NULL, 
            GMFI_PAINT|GMFI_INPUTMOUSE|GMFI_INPUTMOUSEMOVE|GMFI_CHANGESTATE,
            GMFI_PAINT|GMFI_INPUTMOUSE|GMFI_INPUTMOUSEMOVE|GMFI_CHANGESTATE|GMFI_INPUTKEYBOARD|GMFI_CHANGERECT|GMFI_CHANGESTYLE);

    SetGadgetStyle(_hgDisplayNode, 
            GS_RELATIVE|GS_OPAQUE|((fDblBuffer)?GS_BUFFERED:0),
            GS_RELATIVE|GS_HREDRAW|GS_VREDRAW|GS_VISIBLE|GS_KEYBOARDFOCUS|GS_OPAQUE|GS_BUFFERED);

#ifdef GADGET_ENABLE_GDIPLUS
    //
    // If using GDI+, we want to enable state at the top and use this for the entire tree
    //

    SetGadgetStyle(_hgDisplayNode, GS_DEEPPAINTSTATE, GS_DEEPPAINTSTATE);
#endif

    // Use palette if on palettized device
    if (IsPalette())
    {
        HDC hDC = GetDC(NULL);
        _hPal = CreateHalftonePalette(hDC);
        ReleaseDC(NULL, hDC);

        if (!_hPal)
        {
            hr = DU_E_OUTOFGDIRESOURCES;
            goto Failed;
        }
    }

    ROOT_INFO ri;
    ZeroMemory(&ri, sizeof(ri));

#ifdef GADGET_ENABLE_GDIPLUS
    // Mark as using GDI+ surfaces

    ri.cbSize   = sizeof(ri);
    ri.nMask    = GRIM_SURFACE;
    ri.nSurface = GSURFACE_GPGRAPHICS;

#else // GADGET_ENABLE_GDIPLUS
    // For GDC, need to setup a palette and surface info

    ri.cbSize = sizeof(ri);
    ri.nMask = GRIM_SURFACE | GRIM_PALETTE;
    ri.nSurface = GSURFACE_HDC;
    ri.hpal = _hPal;

#endif // GADGET_ENABLE_GDIPLUS

    SetGadgetRootInfo(_hgDisplayNode, &ri);

    // Manually set native hosted flag
    MarkHosted();

    return S_OK;

Failed:

    if (_hWnd)
    {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }

    if (_hgDisplayNode)
    {
        DeleteHandle(_hgDisplayNode);
        _hgDisplayNode = NULL;
    }

    if (_hPal)
    {
        DeleteObject(_hPal);
        _hPal = NULL;
    }

    return hr;
}

// HWNDElement is about to be destroyed
void HWNDElement::OnDestroy()
{
    // Fire unhosted event
    OnUnHosted(GetRoot());

    // Remove reference to this
    SetWindowLongPtrW(_hWnd, 0, NULL);

    // Cleanup
    if (_hPal)
    {
        DeleteObject(_hPal);
        _hPal = NULL;
    }

    // Call base
    Element::OnDestroy();
}

void HWNDElement::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    switch (iIndex)
    {
    case PI_Specified:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Active:
            // HWND Element is always mouse active
            switch (pvNew->GetInt())
            {
            case AE_Inactive:
                SetGadgetMessageFilter(GetDisplayNode(), NULL, 0, GMFI_INPUTKEYBOARD);
                SetGadgetStyle(GetDisplayNode(), 0, GS_KEYBOARDFOCUS);
                break;

            case AE_Keyboard:
            case AE_MouseAndKeyboard:   
                SetGadgetMessageFilter(GetDisplayNode(), NULL, GMFI_INPUTKEYBOARD, GMFI_INPUTKEYBOARD);
                SetGadgetStyle(GetDisplayNode(), GS_KEYBOARDFOCUS, GS_KEYBOARDFOCUS);
                break;
            }
            // No call on base
            return;

        case _PIDX_Alpha:
            // Alpha unsuppored on HWNDElement, No call on base
            return;

        case _PIDX_Visible:
            // Set HWND's visibility, base impl will set gadget visibility
            // Follow specified value, computed will reflect true state
            LONG dStyle = GetWindowLongW(_hWnd, GWL_STYLE);
            if (pvNew->GetBool())
                dStyle |= WS_VISIBLE;
            else
                dStyle &= ~WS_VISIBLE;
            SetWindowLongW(_hWnd, GWL_STYLE, dStyle);
            break;
        }
        break;
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

void HWNDElement::OnGroupChanged(int fGroups, bool bLowPri)
{
    if (bLowPri && (fGroups & PG_AffectsBounds))
    {
        // Handle bounds change since will need to use SetWindowPos
        // rather than SetGadgetRect for HWND gadgets
        Value* pvLoc;
        Value* pvExt;

        const POINT* pptLoc = GetLocation(&pvLoc);
        const SIZE* psizeExt = GetExtent(&pvExt);

        SetWindowPos(_hWnd, NULL, pptLoc->x, pptLoc->y, psizeExt->cx, psizeExt->cy, SWP_NOACTIVATE);
        if(_bParentSizeControl)
        {
            HWND hwnd = ::GetParent(_hWnd);
            if(hwnd)
            {
                RECT rect;
                rect.left = pptLoc->x;
                rect.top = pptLoc->y;
                rect.right = psizeExt->cx + pptLoc->x;
                rect.bottom = psizeExt->cy + pptLoc->y;
                
                LONG Style = GetWindowLong(hwnd, GWL_STYLE);
                LONG ExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
                AdjustWindowRectEx(&rect, Style, FALSE, ExStyle);
                int iWindowWidth = rect.right - rect.left;
                int iWindowHeight = rect.bottom - rect.top;

                if(_bScreenCenter)
                {
                    rect.left = (GetSystemMetrics(SM_CXSCREEN) - iWindowWidth) /2;
                    rect.top = (GetSystemMetrics(SM_CYSCREEN) - iWindowHeight) /2;                
                }
            
                SetWindowPos(hwnd, NULL, rect.left, rect.top, iWindowWidth, iWindowHeight, SWP_NOACTIVATE);
            }

        }

        pvLoc->Release();
        pvExt->Release();

        // Clear affects bounds group so base doesn't do set bounds
        fGroups &= ~PG_AffectsBounds;
    }

    // Call base
    Element::OnGroupChanged(fGroups, bLowPri);
}

HRESULT HWNDElement::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    HRESULT hr = S_OK;

    //
    // Initialize and validate the out parameter(s).
    //
    if (ppAccessible != NULL) {
        *ppAccessible = NULL;
    } else {
        return E_INVALIDARG;
    }

    //
    // If this element is not marked as accessible, refuse to give out its
    // IAccessible implementation!
    //
    if (GetAccessible() == false) {
        return E_FAIL;
    }

    //
    // Create an accessibility implementation connected to this element if we
    // haven't done so already.
    //
    if (_pDuiAccessible == NULL) {
        hr = HWNDElementAccessible::Create(this, &_pDuiAccessible);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //
    // Ask the existing accessibility implementation for a pointer to the
    // actual IAccessible interface.
    //
    hr = _pDuiAccessible->QueryInterface(__uuidof(IAccessible), (LPVOID*)ppAccessible);
    if (FAILED(hr)) {
        return hr;
    }

    DUIAssert(SUCCEEDED(hr) && _pDuiAccessible != NULL && *ppAccessible != NULL, "Accessibility is broken!");
    return hr;
}

void HWNDElement::ShowUIState(bool fUpdateAccel, bool fUpdateFocus)
{
    WORD wFlags = 0;
    
    // Setup "hide" bits to clear
    if (fUpdateAccel)
        wFlags |= UISF_HIDEACCEL;
    if (fUpdateFocus)
        wFlags |= UISF_HIDEFOCUS;

    // If the bits to be cleared are already 0, ignore
    // Otherwise, notify change
    if ((GetUIState() & wFlags) != 0)
    {
        SendMessageW(GetHWND(), WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, wFlags), 0);
    }
}

// algorithm
// 1) start from the root
// 2) find the first element with this shortcut, and save it
// 3) continue search for all other elements with this shortcut
// 4) if another element is found, set the multiple flag
// 5) if an element is found that has keyboard focus, then we want to choose the next one
//    found to match after that, so set the use next flag
// 6) bail when end of tree is hit, or when a match is found and the next flag is set
// 
BOOL FindShortcut(WCHAR ch, Element* pe, Element** ppeFound, BOOL* pfMultiple, BOOL* pfUseNext)
{
    WCHAR wcShortcut = (WCHAR) pe->GetShortcut();
    if (wcShortcut)
    {
        if ((wcShortcut >= 'a') && (wcShortcut <= 'z'))
            wcShortcut -= 32;
        
        // if it has focus, skip it.
        if (wcShortcut == ch)
        {
            Element* peFound = pe;
            while (peFound && !(peFound->GetActive() & AE_Keyboard))
                peFound = peFound->GetParent();
            if (!peFound)
            {
                peFound = pe->GetParent();
                if (peFound)
                    peFound = peFound->GetAdjacent(pe, NAVDIR_NEXT, NULL, true);
            }
            if (peFound && (peFound != *ppeFound))
            {
                if (*ppeFound)
                    *pfMultiple = TRUE;
                else
                    // only save the first one
                    *ppeFound = peFound;

                if (*pfUseNext)
                {
                    // keyboard focus was on last match, so treat this one as the match
                    *ppeFound = peFound;
                    return TRUE;
                }

                *pfUseNext = peFound->GetKeyFocused();
            }
        }
    }
    
    Value* pv;
    ElementList* peList = pe->GetChildren(&pv);
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            if (FindShortcut(ch, peList->GetItem(i), ppeFound, pfMultiple, pfUseNext))
            {
                pv->Release();
                return TRUE;
            }
        }
    }
    pv->Release();
    return FALSE;
}

Element* HWNDElement::GetKeyFocusedElement()
{
    HGADGET hgad = GetGadgetFocus();
    if (!hgad)
        return NULL;

    return ElementFromGadget(hgad);  // Query gadget for Element this message is about (target)
}

void HWNDElement::OnEvent(Event* pEvent)
{
    if ((pEvent->nStage == GMF_BUBBLED) || (pEvent->nStage == GMF_DIRECT))
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
            Element::OnEvent(pEvent);
            if (!pEvent->fHandled && GetWrapKeyboardNavigate())
            {
                KeyboardNavigateEvent* pkne = (KeyboardNavigateEvent*) pEvent;

                if ((pkne->iNavDir & NAV_LOGICAL) && (pkne->iNavDir & NAV_RELATIVE))
                {
                    Element* peSave = pEvent->peTarget;
                    pEvent->peTarget = NULL;
                    Element::OnEvent(pEvent);
                    pEvent->peTarget = peSave;
                }
            }
            return;
        }
    }
    else if (pEvent->nStage == GMF_ROUTED)
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
            // A keyboard navigate is happening within the tree, active focus cues
            ShowUIState(false, true);
        }
    }

    Element::OnEvent(pEvent);
}

void HWNDElement::OnInput(InputEvent* pie)
{
    if ((pie->nDevice == GINPUT_KEYBOARD) && (pie->nStage == GMF_ROUTED) && (pie->uModifiers & GMODIFIER_ALT) && (pie->nCode == GKEY_SYSCHAR))
    {
         WCHAR ch = (WCHAR) ((KeyboardEvent*)pie)->ch;
         if (ch > ' ')
         {
             if ((ch >= 'a') && (ch <= 'z'))
                 ch -= 32;

             Element* peFound = NULL;
             BOOL fMultipleFound = FALSE;
             BOOL fUseNext = FALSE;
             FindShortcut(ch, this, &peFound, &fMultipleFound, &fUseNext);
             if (peFound)
             {
                 // todo: there is one outstanding issue here -- selector, on setting key focus, will 
                 // select that item -- we need a way where, if fMultipleFound, we give it focus without
                 // giving is selection.  But removing that behavior from selector wrecks all other uses of 
                 // selector when clicking in it or keying to it will give focus and select, as expected
                 peFound->SetKeyFocus();
                 // todo:  when we have DoDefaultAction working, change the following conditional and code to:
                 //  if (!fMultipleFound)
                 //      peFound->DoDefaultAction();
                 if (!fMultipleFound && peFound->GetClassInfo()->IsSubclassOf(Button::Class))
                 {
                     // make a click happen
                     ButtonClickEvent bce;
                     bce.uidType = Button::Click;
                     bce.nCount = 1;
                     bce.uModifiers = 0;
                     bce.pt.x = 0;
                     bce.pt.y = 0;

                     peFound->FireEvent(&bce);  // Will route and bubble
                 }
                     
                     
                 pie->fHandled = true;
                 return;
             }
         }
    }
    Element::OnInput(pie);
}


Element* HWNDElement::ElementFromPoint(POINT* ppt)
{
    DUIAssert(ppt, "Invalid parameter: NULL\n");

    Element* pe = NULL;

    HGADGET hgad = FindGadgetFromPoint(GetDisplayNode(), *ppt, GS_VISIBLE | GS_ENABLED, NULL);

    if (hgad) // Get Element from gadget
        pe = ElementFromGadget(hgad);

    return pe;        
}

// Async flush working set
void HWNDElement::FlushWorkingSet()
{
    if (_hWnd)
    {
        PostMessage(_hWnd, HWEM_FLUSHWORKINGSET, 0, 0);
    }
}

LRESULT CALLBACK HWNDElement::StaticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Get context
    HWNDElement* phe = (HWNDElement*)GetWindowLongPtrW(hWnd, 0);
    if (!phe)
        return DefWindowProcW(hWnd, uMsg, wParam, lParam);

    return phe->WndProc(hWnd, uMsg, wParam, lParam);
}



// note, keep same order as enums from Element.w
// CUR_Arrow, CUR_Hand, CUR_Help, CUR_No, CUR_Wait, CUR_SizeAll, CUR_SizeNESW, CUR_SizeNS, CUR_SizeNWSE, CUR_SizeWE
static LPSTR lprCursorMap[] = { IDC_ARROW, IDC_HAND, IDC_HELP, IDC_NO, IDC_WAIT, IDC_SIZEALL, IDC_SIZENESW, IDC_SIZENS, IDC_SIZENWSE, IDC_SIZEWE };

LRESULT HWNDElement::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SETCURSOR:
        {
            // Get position at time of message (convert to HWNDElement coordinates)
            DWORD dwPos = GetMessagePos();
            POINT ptCur = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
            ScreenToClient(hWnd, &ptCur);

            // Locate Element
            Element* pe = ElementFromPoint(&ptCur);
            if (pe)
            {
                if (!pe->IsDefaultCursor())
                {
                    // Not using default cursor (arrow)
                    HCURSOR hCursor = NULL;

                    Value* pvCursor = pe->GetValue(CursorProp, PI_Specified);

                    if (pvCursor->GetType() == DUIV_INT)
                    {
                        int iCursor = pvCursor->GetInt();
                        // this check isn't necessary if he validates against the enums when setting
                        if ((iCursor >= 0) && (iCursor < CUR_Total))
                            hCursor = LoadCursorW(NULL, MAKEINTRESOURCEW(lprCursorMap[iCursor]));
                        else
                            hCursor = pvCursor->GetCursor()->hCursor;
                    }
                    else
                    {
                        DUIAssert(pvCursor->GetType() == DUIV_CURSOR, "Expecting Cursor type");

                        hCursor = pvCursor->GetCursor()->hCursor;
                    }

                    pvCursor->Release();

                    if (hCursor)
                        ::SetCursor(hCursor);

                    return TRUE;
                }
            }
        }
        break;  // Use default cursor (arrow)

    case WM_PALETTECHANGED:
        {
            if (_hPal && (HWND)wParam == hWnd)
                break;
        }
        // Fall through

    case WM_QUERYNEWPALETTE:
        {
            if (_hPal)
            {
                HDC hDC = GetDC(hWnd);

                HPALETTE hOldPal = SelectPalette(hDC, _hPal, FALSE);
                UINT iMapped = RealizePalette(hDC);

                SelectPalette(hDC, hOldPal, TRUE);
                RealizePalette(hDC);

                ReleaseDC(hWnd, hDC);

                if (iMapped)
                    InvalidateRect(hWnd, NULL, TRUE);

                return iMapped;
            }
        }
        break;

    case WM_DISPLAYCHANGE:
        InvalidateRect(hWnd, NULL, TRUE);
        break;

    case HWEM_FLUSHWORKINGSET:
        // Flush working set
        SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T)-1, (SIZE_T)-1);
        return 0;

    case WM_UPDATEUISTATE:
        {
            // State of keyboard cues have changed

            // Cache new value
            WORD wOldUIState = _wUIState;
            switch (LOWORD(wParam))
            {
                case UIS_SET:
                    _wUIState |= HIWORD(wParam);
                    break;

                case UIS_CLEAR:
                    _wUIState &= ~(HIWORD(wParam));
                    break;
            }

            if (wOldUIState != _wUIState)
            {
                // Refresh tree
                InvalidateGadget(GetDisplayNode());
            }
        }
        break;

    case WM_SYSCHAR:
        // to prevent the beep that you get from doing Alt+char when you don't have a menu or menu item with that
        // mnemonic -- I need to think this one through -- jeffbog
        if (wParam != ' ')
            return 0;
        break;

    case WM_CONTEXTMENU:
        // Default processing (DefWindowProc) of this message is to pass it to the parent.
        // Since controls will create and fire a context menu events as a result of keyboard
        // and mouse input, this message should not be passed to the parent.
        // However, if the message originated on a child HWND (Adaptors, which are outside
        // the DirectUI world), allow it to be passed to parent.
        if ((HWND)wParam == hWnd)
            return 0;
        break;

    case WM_GETOBJECT:
        {
            LRESULT lResult = 0;

            //
            // Make sure COM has been initialized on this thread!
            //
            ElTls * pet = (ElTls*) TlsGetValue(g_dwElSlot);
            DUIAssert(pet != NULL, "This is not a DUI thread!");
            if (pet == NULL) {
                return 0;
            }
            if (pet->fCoInitialized == false) {
                CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
                pet->fCoInitialized = true;
            }

            if (((DWORD)lParam) == OBJID_CLIENT) {
                //
                // The object ID is refering to ourselves.  Since we are
                // actually an HWND, the system would normally provide
                // the IAccessible implementation.  However, we need to
                // do some special stuff, so we have to return our own
                // implementation.
                //
                IAccessible * pAccessible = NULL;
                HRESULT hr =  GetAccessibleImpl(&pAccessible);
                if (SUCCEEDED(hr)) {
                    lResult = LresultFromObject(__uuidof(IAccessible), wParam, pAccessible);
                    pAccessible->Release();
                }
            } else if (((long)lParam) > 0 ) {
                //
                // The object ID is one of our internal ticket identifiers.
                // Decode the element that the caller wants an IAccessible
                // interface for.  Then return a peer implementation of
                // IAccessible that is connected to the specified element.
                //
                HGADGET hgad = LookupGadgetTicket((DWORD)lParam);
                if (hgad != NULL) {
                    Element * pe = ElementFromGadget(hgad);
                    if (pe != NULL) {
                        IAccessible * pAccessible = NULL;
                        HRESULT hr =  pe->GetAccessibleImpl(&pAccessible);
                        if (SUCCEEDED(hr)) {
                            lResult = LresultFromObject(__uuidof(IAccessible), wParam, pAccessible);
                            pAccessible->Release();
                        }
                    }
                }
            } else {
                //
                // This is one of the "standard" object identifiers, such as:
                //
                // OBJID_ALERT 
                // OBJID_CARET 
                // OBJID_CLIENT 
                // OBJID_CURSOR 
                // OBJID_HSCROLL 
                // OBJID_MENU 
                // OBJID_SIZEGRIP 
                // OBJID_SOUND 
                // OBJID_SYSMENU 
                // OBJID_TITLEBAR 
                // OBJID_VSCROLL 
                //
                // None of these are supported on an HWNDElement.
                //
            }


            return lResult;
        }
    }

    return DefWindowProcW(hWnd, uMsg, wParam, lParam);
}

// WrapKeyboardNavigate property
static int vvWrapKeyboardNavigate[] = { DUIV_BOOL, -1 };
static PropertyInfo impWrapKeyboardNavigateProp = { L"WrapKeyboardNavigate", PF_Normal, 0, vvWrapKeyboardNavigate, NULL, Value::pvBoolTrue };
PropertyInfo* HWNDElement::WrapKeyboardNavigateProp = &impWrapKeyboardNavigateProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                HWNDElement::WrapKeyboardNavigateProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDElement::Class = NULL;

HRESULT HWNDElement::Register()
{
    return ClassInfo<HWNDElement,Element>::Register(L"HWNDElement", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\property.cpp ===
/*
 * Property
 */

#include "stdafx.h"
#include "core.h"

#include "duielement.h"
#include "duithread.h"
#include "duiaccessibility.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Property system of Element

#if DBG

// GetValue instrumentation class
class GVTrack
{
public:
    // Hash key
    class Key
    {
    public:
        Key() { _ppi = NULL; _iIndex = -1; };
        Key(PropertyInfo* ppi, int iIndex) { _ppi = ppi; _iIndex = iIndex; }
        operator =(Key k) { _ppi = k._ppi; _iIndex = k._iIndex; }
        BOOL operator ==(Key k) { return _ppi == k._ppi && _iIndex == k._iIndex; }
        operator INT_PTR() { return (INT_PTR)_ppi | _iIndex; }

        LPCWSTR GetPIName() { return _ppi->szName; }
        int GetIndex() { return _iIndex; }

    private:
        PropertyInfo* _ppi;
        int _iIndex;
    };

    // Methods
    GVTrack() { ValueMap<Key,int>::Create(3371, &_pvmGetValTrack); _cGV = 0; _cGVUpdateCache = 0; ZeroMemory(_cGVSpecSource, sizeof(_cGVSpecSource)); _fTrack = true; }
    static void GetValueProfileCB(Key k, int cQueries) { DUITrace("GV(%S[%d]): \t\t%d\n", k.GetPIName(), k.GetIndex(), cQueries); }

    void Count(PropertyInfo* ppi, int iIndex, bool fCacheUpdate) 
    {
        if (_fTrack)
        {
            Key k(ppi, iIndex);  
            int* pCount = _pvmGetValTrack->GetItem(k, false);
            int cCount = pCount ? *pCount : 0;
            cCount++;
            _pvmGetValTrack->SetItem(k, cCount, false);

            _cGV++;

            if (fCacheUpdate)
                _cGVUpdateCache++;
        }
    }

    void CountSpecSource(UINT iFrom) { _cGVSpecSource[iFrom]++; }

    void DumpMetrics() { if (_fTrack) { DUITrace(">> Total GV calls: %d, w/updatecache: %d.\nSpecified sources: L:%d, SS:%d, I:%d, D:%d\n", 
        _cGV, _cGVUpdateCache, _cGVSpecSource[0], _cGVSpecSource[1], _cGVSpecSource[2], _cGVSpecSource[3] ); _pvmGetValTrack->Enum(GetValueProfileCB); } }
    void EnableTracking(bool fEnable) { _fTrack = fEnable; }

private:
    ValueMap<Key,int>* _pvmGetValTrack;
    UINT _cGV;
    UINT _cGVUpdateCache;
    UINT _cGVSpecSource[4]; // 0 Local, 1 Style Sheet, 2 Inherted, 3 Default
    bool _fTrack;
};

//GVTrack g_gvt;

// API call count
UINT g_cGetDep = 0;
UINT g_cGetVal = 0;
UINT g_cOnPropChg = 0;

/*
class GVCache
{
public:
    // Hash key
    class Key
    {
    public:
        Key() { _pe = NULL; _ppi = NULL; _iIndex = -1; };
        Key(Element* pe, PropertyInfo* ppi, int iIndex) { _pe = pe; _ppi = ppi; _iIndex = iIndex; }
        operator =(Key k) { _pe = k._pe; _ppi = k._ppi; _iIndex = k._iIndex; }
        BOOL operator ==(Key k) { return _pe == k._pe && _ppi == k._ppi && _iIndex == k._iIndex; }
        operator INT_PTR() { return ((INT_PTR)_pe & 0xFFFF0000) | ((INT_PTR)_ppi & 0xFFFF) | _iIndex; }

    private:
        Element* _pe;
        PropertyInfo* _ppi;
        int _iIndex;
    };

    // Methods
    GVCache() { ValueMap<Key,Value*>::Create(3371, &_pvmCache); }
    static void GVCacheCB(Key k, Value* pv) { k; pv; }

    Value* Read(Key k)
    {
        Value** ppv = _pvmCache->GetItem(k, false);
        if (ppv)
        {
            (*ppv)->AddRef();
            return *ppv;
        }

        return NULL;
    }

    void Write(Key k, Value* pv)
    {
        pv->AddRef();
        _pvmCache->SetItem(k, pv, false);
    }

private:
    ValueMap<Key,Value*>* _pvmCache;
};

GVCache g_gvc;
*/

#endif

// Start defer initiates the defer cycle. Upon reentrancy, simply updates a count and returns
void Element::StartDefer()
{
    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
        return;

    pdc->cEnter++;
}

// EndDefer will return on a reentrancy. The "outter-most" EndDefer will empty the defer table
// queues in priority order. This priority is:
//    Normal Priority Group Property Changes (Affects DS/Layout, Affects Parent DS/Layout)
//    Update Desired Size of Q'ed roots (updates DesiredSize property)
//    Layout of Q'ed roots (invokes _UpdateLayoutSize, _UpdateLayoutPosition)
//    Low Priority Group Property Changes (Bounds, Invalidation)
//
// The outter-most EndDefer will happen outside any OnPropertyChange notification
void Element::EndDefer()
{
    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
        return;

    DUIAssert(pdc->cEnter, "Mismatched StartDefer and EndDefer");
    DUIAssert(pdc->cEnter == 1 ? !pdc->fFiring : true, "Mismatched StartDefer and EndDefer");

    // Outter most defer call, fire all events
    if (pdc->cEnter == 1)
    {
#if DBG
        //g_gvt.DumpMetrics();
        //g_gvt.EnableTracking(false);
#endif

        pdc->fFiring = true;

        // Complete defer cycle
        bool fDone = false;
        while (!fDone)
        {
            // Fire group changed notifications
            if (pdc->iGCPtr + 1 < (int)pdc->pdaGC->GetSize())
            {
                pdc->iGCPtr++;

                // Null Element means it has been deleted with pending group notifications
                GCRecord* pgcr = pdc->pdaGC->GetItemPtr(pdc->iGCPtr);
                if (pgcr->pe)
                {
                    pgcr->pe->_iGCSlot = -1;  // No pending group changes

                    // Fire
                    pgcr->pe->OnGroupChanged(pgcr->fGroups, false);
                }
            }
            else
            {
                // Check for trees needing desired size updated
                Element** ppe = pdc->pvmUpdateDSRoot->GetFirstKey();
                if (ppe)
                {
                    //DUITrace("Updating Desired Size: Root<%x>\n", *ppe);

                    //StartBlockTimer();

                    _FlushDS(*ppe, pdc);

                    pdc->pvmUpdateDSRoot->Remove(*ppe, false, true);

                    //StopBlockTimer();
                    //TCHAR buf[81];
                    //_stprintf(buf, L"UpdateDS time: %dms\n", BlockTime());
                    // OutputDebugStringW(buf);

                    //DUITrace("Update Desired Size complete.\n");
                }
                else
                {
                    ppe = pdc->pvmLayoutRoot->GetFirstKey();
                    if (ppe)
                    {
                        //DUITrace("Laying out: Root<%x>\n", *ppe);

                        //StartBlockTimer();

                        _FlushLayout(*ppe, pdc);

                        pdc->pvmLayoutRoot->Remove(*ppe, false, true);

                        //StopBlockTimer();
                        // TCHAR buf[81];
                        //_stprintf(buf, L"  Layout time: %dms\n", BlockTime());
                        // OutputDebugStringW(buf);

                        //DUITrace("Layout complete.\n");
                    }
                    else
                    {
                        // Fire group changed notifications
                        if (pdc->iGCLPPtr + 1 < (int)pdc->pdaGCLP->GetSize())
                        {
                            pdc->iGCLPPtr++;

                            // Null Element means it has been deleted with pending low-pri group notifications
                            GCRecord* pgcr = pdc->pdaGCLP->GetItemPtr(pdc->iGCLPPtr);
                            if (pgcr->pe)
                            {
                                pgcr->pe->_iGCLPSlot = -1;  // No pending low pri group changes

                                // Fire
                                pgcr->pe->OnGroupChanged(pgcr->fGroups, true);
                            }
                        }
                        else
                            fDone = true;
                    }
                }
            }
        }

        // Reset for next cycle
        DUIAssert(pdc->fFiring, "Incorrect state for end of defer cycle");

        pdc->Reset();

        DUIAssert(pdc->pvmLayoutRoot->IsEmpty(), "Defer cycle ending with pending layouts");
        DUIAssert(pdc->pvmUpdateDSRoot->IsEmpty(), "Defer cycle ending with pending update desired sizes");
    }

    // Complete cycle
    pdc->cEnter--;
}

// _PreSourceChange is called when the property engine is about to exit steady state
// (a Value changed). As a reasult, this method will determine the scope of influence
// of this change, coalesce duplicate records, and then store the values of those
// that may be affected.
//
// The scope of influence (dependency tree) is determined _using GetDependencies().
// A list is built and traversed in a BFS manner which describes which values
// must be updated first. The order guarantees state is updated in the correct order.
//
// _PreSourceChange will always run despite the PC rentrancy count
HRESULT Element::_PreSourceChange(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    //DUITrace(">>> Scanning for dependencies...\n");
    HRESULT hr;

    // If any failure occurs during a dependency Q, track. Will recover and return partial error
    bool fDepFailure = false;

    DepRecs dr = { 0 };

    int iPCPreSync = 0;
    int iPreSyncLength = 0;
    int iPCSrcRoot = 0;

    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
    {
        hr = DUI_E_NODEFERTABLE;
        goto Failed;
    }

    DUIAssert(!pdc->cPCEnter ? pdc->iPCPtr == -1 : true, "PropertyChange index pointer should have 'reset' value on first pre source change");

    pdc->cPCEnter++;

    // Record this property change
    PCRecord* ppcr;
    
    hr = pdc->pdaPC->AddPtr(&ppcr);
    if (FAILED(hr))
        goto Failed;

    ppcr->fVoid = false;
    ppcr->pe = this; ppcr->ppi = ppi; ppcr->iIndex = iIndex;

    // Track last record for this element instance
    // If this is first record in cycle, iPrevElRec will be -1. Coalecsing
    // lookups (which uses this) will not go past the first record
    ppcr->iPrevElRec = ppcr->pe->_iPCTail;
    ppcr->pe->_iPCTail = pdc->pdaPC->GetIndexPtr(ppcr);

    pvOld->AddRef();
    ppcr->pvOld = pvOld;

    pvNew->AddRef();
    ppcr->pvNew = pvNew;

    // Append list of all steady state values from the dependency graph this source affects.
    // Do so in a BFS manner as to get direct dependents first
    iPCPreSync = pdc->pdaPC->GetIndexPtr(ppcr);
    iPCSrcRoot = iPCPreSync;

    DUIAssert((int)iPCPreSync == pdc->iPCSSUpdate, "Record should match index of post-update starting point");

    while (iPCPreSync < (int)pdc->pdaPC->GetSize())  // Size may change during iteration
    {
        // Get property changed record
        ppcr = pdc->pdaPC->GetItemPtr(iPCPreSync);

        // Get all dependencies of this source (append to end of list) and track in this record.
        if (FAILED(ppcr->pe->_GetDependencies(ppcr->ppi, ppcr->iIndex, &dr, iPCSrcRoot, pdc)))
            fDepFailure = true;

        // GetDependencies may have added records which may have caused the da to move in memory,
        // so recompute pointer to record (if no new records, this AddPtr may have caused a move, do anyway)
        //if (pdc->pdaPC->WasMoved())
            ppcr = pdc->pdaPC->GetItemPtr(iPCPreSync);

        // Track position of dependent records
        ppcr->dr = dr;
    
        iPCPreSync++;
    }

    // Coalesce and store SS before source change
    int iScan;
    int iLastDup;

    // Reset pre-sync index
    iPCPreSync = pdc->iPCSSUpdate + 1;  // Start after root source change
    iPreSyncLength = (int)pdc->pdaPC->GetSize();  // Size will not change during iteration

    while (iPCPreSync < iPreSyncLength)
    {
        // Coalecse and void duplicates
        ppcr = pdc->pdaPC->GetItemPtr(iPCPreSync);

        if (!ppcr->fVoid)
        {
            PCRecord* ppcrChk;

            // Search only records that refer to this record's element instance
            // Walk backwards from tail of element's record set (tracked by element) to
            // this, scanning for matches
            iScan = ppcr->pe->_iPCTail;
            iLastDup = -1;

            DUIAssert(iPCPreSync <= ppcr->pe->_iPCTail, "Element property change tail index mismatch");

            while (iScan != iPCPreSync)
            {
                ppcrChk = pdc->pdaPC->GetItemPtr(iScan);

                if (!ppcrChk->fVoid)
                {
                    // Check for match
                    if (ppcrChk->iIndex == ppcr->iIndex && 
                        ppcrChk->ppi == ppcr->ppi)
                    {
                        DUIAssert(ppcrChk->pe == ppcr->pe, "Property change record does not match with current lookup list");

                        if (iLastDup == -1)
                        {
                            // Found the last duplicate, track. Will not be voided
                            iLastDup = iScan;
                        }
                        else
                        {
                            // Found a duplicate between last and initial record, void
                            // it and all dependencies on it
                            _VoidPCNotifyTree(iScan, pdc);
                        }

                        DUIAssert(iScan <= ppcr->pe->_iPCTail, "Coalescing pass went past property change lookup list");
                    }
                }

                // Walk back
                iScan = ppcrChk->iPrevElRec;
            }

            // No duplicates found, get presync SS value for record
            if (iLastDup == -1)
            {
                // Get old value
                DUIAssert(!ppcr->pvOld, "Old value shouldn't be available when storing pre SS sync values");
                ppcr->pvOld = ppcr->pe->GetValue(ppcr->ppi, ppcr->iIndex, NULL);  // Use ref count
            }
            else
            {
                // Duplicates found, void this record. Keep last record. All sources before it
                // will be brought back to steady state before it (in PostSourceChange)
                _VoidPCNotifyTree(iPCPreSync, pdc);
            }
        }

        iPCPreSync++;
    }

    DUIAssert(iPCPreSync == (int)pdc->pdaPC->GetSize(), "Index pointer and actual property change array size mismatch");

    return fDepFailure ? DUI_E_PARTIAL : S_OK;

Failed:

    // On a total failure, there is no dependency tree. Reentrancy is set if defer object was available
    return hr;
}

// _PostSourceChange takes the list of dependencies and old values created in _PreSourceChange
// and retrieves all the new values (and, in the cases of the value remaining the same, will
// void the PC record and all dependencies of that record).
//
// The value state is now back to steady state of this point (GetValue will return the value set).
//
// Only the "outter-most" _PostSourceChange continues at this point (all other's return). _PostSourceChange
// will continue to queue up GPC's based on the properties changed, and finally fires OnPropertyChanged().
//
// OnPropertyChanged() events are guaranteed to be in the order of sets. However, it is not guaranteed
// that an OnPropertyChanged() will be called right after a set happens. If another set happens
// within an OnPropertyChanged(), the event will be deferred until the outter-most _PostSourceChange
// processes the notification.
HRESULT Element::_PostSourceChange()
{
    HRESULT hr;

    // If any failure occurs during a group Q, track. Will recover and return partial error
    bool fGrpQFailure = false;

    int cSize = 0;

    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
    {
        hr = DUI_E_NODEFERTABLE;
        goto Failed;
    }

    StartDefer();

    PCRecord* ppcr;

    // Source change happened, dependent values (cached) need updating.
    // Go through records, get new value, and compare with old. If different, void

    // TODO: Change to bool
    UpdateCache uc;
    ZeroMemory(&uc, sizeof(UpdateCache));

    // iPCSSUpdate holds the starting index of a group of records that needs post processing
    // (get new values, compare and void if needed)
    cSize = (int)pdc->pdaPC->GetSize();
    while (pdc->iPCSSUpdate < cSize)  // Size constant during iteration
    {
        ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCSSUpdate);

        if (!ppcr->fVoid)  // Items may have been voided by below
        {
            DUIAssert(ppcr->pvOld, "Non-voided items should have a valid 'old' value during SS update (PostSourceChange)");

            if (!ppcr->pvNew)
            {
                // Retrieve new value (Element/Property/Index will be back to SS)
                ppcr->pvNew = ppcr->pe->GetValue(ppcr->ppi, ppcr->iIndex, &uc);
            }

            // If new value hasn't changed, void this and all dependent notifications
            if (ppcr->pvOld->IsEqual(ppcr->pvNew))
            {
                _VoidPCNotifyTree(pdc->iPCSSUpdate, pdc);
            }
        }

        pdc->iPCSSUpdate++;
    }

    // Back to steady state at this point

    // First entered PostSourceChange is responsible for voiding duplicate property change records,
    // logging group changes, and firing property changes.
    //
    // OnPropertyChanged is fired when values (sources and dependents) are at steady state (SS)
    if (pdc->cPCEnter == 1)
    {
        while (pdc->iPCPtr + 1 < (int)pdc->pdaPC->GetSize())  // Size may change during iteration
        {
            pdc->iPCPtr++;

            // Coalecse and void duplicates
            ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCPtr);

            if (!ppcr->fVoid)
            {
                // Log property groups only if retrieval index
                if ((ppcr->ppi->fFlags & PF_TypeBits) == ppcr->iIndex)
                {
                    GCRecord* pgcr;

                    int fGroups = ppcr->ppi->fGroups;

                    // If layout optimization is set on the Element, don't queue a layout GPC
                    // (which will, when fired, mark it as needing layout and queue another
                    // layout cycle). Rather, clear the layout GPC bit since the layout will be
                    // forced to happen within the current layout cycle
                    if (ppcr->pe->_fBit.fNeedsLayout == LC_Optimize)
                        fGroups &= ~PG_AffectsLayout;

                    // Record normal priority group changes
                    if (fGroups & PG_NormalPriMask)
                    {
                        if (ppcr->pe->_iGCSlot == -1)  // No GC record
                        {
                            hr = pdc->pdaGC->AddPtr(&pgcr);
                            if (FAILED(hr))
                                fGrpQFailure = true;
                            else
                            {
                                pgcr->pe = ppcr->pe;
                                pgcr->fGroups = 0;
                                ppcr->pe->_iGCSlot = pdc->pdaGC->GetIndexPtr(pgcr);
                            }
                        }
                        else                           // Has GC record
                        {
                            pgcr = pdc->pdaGC->GetItemPtr(ppcr->pe->_iGCSlot);
                        }

                        // Mark groups that have changed for later async group notifications
                        pgcr->fGroups |= fGroups;
                    }

                    // Record low priority group changes
                    if (fGroups & PG_LowPriMask)
                    {
                        if (ppcr->pe->_iGCLPSlot == -1)  // No GC record
                        {
                            hr = pdc->pdaGCLP->AddPtr(&pgcr);
                            if (FAILED(hr))
                                fGrpQFailure = true;
                            else
                            {
                                pgcr->pe = ppcr->pe;
                                pgcr->fGroups = 0;
                                ppcr->pe->_iGCLPSlot = pdc->pdaGCLP->GetIndexPtr(pgcr);
                            }
                        }
                        else                             // Has Low Pri GC record
                        {
                            pgcr = pdc->pdaGCLP->GetItemPtr(ppcr->pe->_iGCLPSlot);
                        }

                        // Mark groups that have changed for later async group notifications
                        pgcr->fGroups |= fGroups;
                    }
                }

                // Property change notification
                ppcr->pe->OnPropertyChanged(ppcr->ppi, ppcr->iIndex, ppcr->pvOld, ppcr->pvNew);

                // OnPropertyChanged may have added record which may have caused the da to move in memory,
                // so recompute pointer to record
                //if (pdc->pdaPC->WasMoved())
                    ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCPtr);

                // Done with notification record
                ppcr->pvOld->Release();
                ppcr->pvNew->Release();
                ppcr->fVoid = true;
            }

            // Reset PC tail index if this is the last notification for this Element
            if (pdc->iPCPtr == ppcr->pe->_iPCTail)
                ppcr->pe->_iPCTail = -1;

        }

        // Reset PC List
        pdc->iPCPtr = -1;
        pdc->iPCSSUpdate = 0;
        pdc->pdaPC->Reset();
    }

    pdc->cPCEnter--;

    EndDefer(); 

    return fGrpQFailure ? DUI_E_PARTIAL : S_OK;

Failed:

    // Lack of a defer object will result in a total failure. In this case, _PreSourceChange would have
    // failed as well. As a result, there is no dependency tree to destroy
    return hr;
}

void Element::_VoidPCNotifyTree(int iPCPos, DeferCycle* pdc)
{
    PCRecord* ppcr = pdc->pdaPC->GetItemPtr(iPCPos);

    ppcr->fVoid = true;
    if (ppcr->pvOld)
        ppcr->pvOld->Release();
    if (ppcr->pvNew)
        ppcr->pvNew->Release();

    // Void subtree
    for (int i = 0; i < ppcr->dr.cDepCnt; i++)
    {
        _VoidPCNotifyTree(ppcr->dr.iDepPos + i, pdc);
    }
}

//#define _AddDependency(e, p, i) { ppcr = pdc->pdaPC->AddPtr(); ppcr->fVoid = false; \
//                                 ppcr->pe = e; ppcr->ppi = p; ppcr->iIndex = i;  \
//                                 ppcr->pvOld = NULL; ppcr->pvNew = NULL;         \
//                                 if (!pdr->cDepCnt) pdr->iDepPos = pdc->pdaPC->GetIndexPtr(ppcr); pdr->cDepCnt++; }
//#define _AddDependency(e, p, i)
void Element::_AddDependency(Element* pe, PropertyInfo* ppi, int iIndex, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr)
{
    HRESULT hr;
    PCRecord* ppcr;

    hr = pdc->pdaPC->AddPtr(&ppcr);
    if (FAILED(hr))
    {
        *phr = hr;  // Only set on a failure
        return;
    }

    ppcr->fVoid = false;
    ppcr->pe = pe; ppcr->ppi = ppi; ppcr->iIndex = iIndex;

    // Track last record for this element instance
    ppcr->iPrevElRec = pe->_iPCTail;
    pe->_iPCTail = pdc->pdaPC->GetIndexPtr(ppcr);

    ppcr->pvOld = NULL; ppcr->pvNew = NULL;
    if (!pdr->cDepCnt)
        pdr->iDepPos = pe->_iPCTail;
    pdr->cDepCnt++;
}

// _GetDependencies stores a database of dependencies (all nodes and directed edges).
// It forms the dependency graph. It will store all dependents of the provided source
// in the dependency list (via PCRecords).
//
// _GetDependencies will attempt to predict the outcome of _PostSourceChange of
// various properties. This greatly reduces the number of calls to GetValue and
// _GetDependencies. The prediction relies on already stored cached values on
// Elements. It optimizes dependencies of inherited and cascaded properties.
HRESULT Element::_GetDependencies(PropertyInfo* ppi, int iIndex, DepRecs* pdr, int iPCSrcRoot, DeferCycle* pdc)
{
    // In the event of a failure of adding a dependency, adding of dependencies will continue
    // and no work is undone. A failure will still be reported

    // Track failures, report the last failure
    HRESULT hr = S_OK;

#if DBG
    g_cGetDep++;
#endif

    pdr->iDepPos = -1;
    pdr->cDepCnt = 0;

    // Get Specified IVE extension dependencies via PropertySheet. Only retrieval indicies are allowed
    if (iIndex == RetIdx(ppi))
    {
        PropertySheet* pps = GetSheet();
        if (pps)
            pps->GetSheetDependencies(this, ppi, pdr, pdc, &hr);
    }

    switch (iIndex)
    {
    case PI_Local:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Parent:
            {
                _AddDependency(this, LocationProp, PI_Local, pdr, pdc, &hr);
                _AddDependency(this, ExtentProp, PI_Local, pdr, pdc, &hr);
                _AddDependency(this, VisibleProp, PI_Computed, pdr, pdc, &hr);

                // Inherited values might change
                PropertyInfo* ppiScan;
                UINT nEnum = 0;
                PCRecord* ppcrRoot = pdc->pdaPC->GetItemPtr(iPCSrcRoot);

                Element* peParent = NULL;
                if (ppcrRoot->ppi == ParentProp)
                    peParent = ppcrRoot->pvNew->GetElement();

                IClassInfo* pci = GetClassInfo();
                while ((ppiScan = pci->EnumPropertyInfo(nEnum++)) != NULL)
                {
                    if (ppiScan->fFlags & PF_Inherit)
                    {
                        // Optimization

                        // Heavy operation. Be smart about what to inherit. If the value
                        // is the same as the parent's, there is no reason to add this
                        // as a dependency. However, in most cases, values aren't cached,
                        // so it's not known whether the source change will in fact change
                        // this.

                        // In cases where the value is known to be cached, we can check now
                        // of the value will really change without doing it in the PostSourceChange.
                        // As a result, node syncs may be eliminated.

                        // It is possible for this optimization to predict incorrectly.
                        // That may happen if the source change (in this case, the parent
                        // property) is the source of another property that this property
                        // is dependent on. The extra property may affect the VE. If it does,
                        // it doesn't matter since this property change will be coalesced
                        // into the latest like property change and voided out.

                        if (peParent)
                        {
                            switch (ppiScan->_iGlobalIndex)
                            {
                            case _PIDX_KeyFocused:
                                if (peParent->_fBit.bSpecKeyFocused == _fBit.bSpecKeyFocused)
                                    continue;
                                break;

                            case _PIDX_MouseFocused:
                                if (peParent->_fBit.bSpecMouseFocused == _fBit.bSpecMouseFocused)
                                    continue;
                                break;
 
                            case _PIDX_Direction:
                                if (peParent->_fBit.nSpecDirection == _fBit.nSpecDirection)
                                    continue;
                                break;

                            case _PIDX_Enabled:
                                if (peParent->_fBit.bSpecEnabled == _fBit.bSpecEnabled)
                                    continue;
                                break;

                            case _PIDX_Selected:
                                if (peParent->_fBit.bSpecSelected == _fBit.bSpecSelected)
                                    continue;
                                break;

                            case _PIDX_Cursor:
                                if (peParent->_fBit.bDefaultCursor && _fBit.bDefaultCursor)
                                    continue;
                                break;

                            case _PIDX_Visible:
                                if (peParent->_fBit.bSpecVisible == _fBit.bSpecVisible)
                                    continue;
                                break;

                            case _PIDX_ContentAlign:
                                if (peParent->IsDefaultCAlign() && IsDefaultCAlign())
                                    continue;
                                break;

                            case _PIDX_Sheet:
                                if (peParent->GetSheet() == GetSheet())
                                    continue;
                                break;

                            case _PIDX_BorderColor:
                                if (peParent->_fBit.bDefaultBorderColor && _fBit.bDefaultBorderColor)
                                    continue;
                                break;

                            case _PIDX_Foreground:
                                if (peParent->_fBit.bDefaultForeground && _fBit.bDefaultForeground)
                                    continue;
                                break;

                            case _PIDX_FontWeight:
                                if (peParent->_fBit.bDefaultFontWeight && _fBit.bDefaultFontWeight)
                                    continue;
                                break;

                            case _PIDX_FontStyle:
                                if (peParent->_fBit.bDefaultFontStyle && _fBit.bDefaultFontStyle)
                                    continue;
                                break;
                            }
                        }

                        // If the value changing is currently being stored locally
                        // on this Element, it is known that a change of the source will not
                        // affect it.
                        if (_pvmLocal->GetItem(ppiScan))
                            continue;
                    
                        _AddDependency(this, ppiScan, PI_Specified, pdr, pdc, &hr);
                    }
                }
            }
            break;

        case _PIDX_PosInLayout:
            _AddDependency(this, LocationProp, PI_Local, pdr, pdc, &hr);
            break;

        case _PIDX_SizeInLayout:
        case _PIDX_DesiredSize:
            _AddDependency(this, ExtentProp, PI_Local, pdr, pdc, &hr);
            break;
        }

        // Default general dependencies on this (Local flag)
        if ((ppi->fFlags & PF_TypeBits) != PF_LocalOnly)
        {
            _AddDependency(this, ppi, PI_Specified, pdr, pdc, &hr);  // Specified is dependent for Normal and TriLevel
        }
        break;

    case PI_Specified:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Active:
        case _PIDX_Enabled:
            _AddDependency(this, KeyFocusedProp, PI_Specified, pdr, pdc, &hr);
            _AddDependency(this, MouseFocusedProp, PI_Specified, pdr, pdc, &hr);
            break;

        case _PIDX_X:
        case _PIDX_Y:
            _AddDependency(this, LocationProp, PI_Local, pdr, pdc, &hr);
            break;

        case _PIDX_Padding:
        case _PIDX_BorderThickness:
            {
                // Affects content offset (Location of all children)
                Value* pv;
                ElementList* peList = GetChildren(&pv);

                if (peList)
                {
                    for (UINT i = 0; i < peList->GetSize(); i++)
                    {
                        _AddDependency(peList->GetItem(i), LocationProp, PI_Local, pdr, pdc, &hr);
                    }
                }

                pv->Release();
            }
            break;

        case _PIDX_Sheet:
            {
                // Specified values change
                PropertySheet* pps = NULL;
                PCRecord* ppcrRoot = pdc->pdaPC->GetItemPtr(iPCSrcRoot);
            
                // Optimization

                // This sheet is either being inherited or set locally
                
                // If it's inherited, it's as a result of a new parent or a value being
                // set on an ancestor and propagating down. In either case, as it's
                // propagating down, if an Element already has a sheet set locally,
                // the inheritance will end. So, if it made it here, this is the
                // new property sheet that will be used with this Element (i.e.
                // PostSourceChange will result in a different value)

                // If it's being set locally, the result is the same.

                // A prediction can be made if the source of the change (root) is
                // known. If not, assume any property can change. An unknown source
                // occurs if the sheet is dependent on something other than a parent
                // change or an inherited local sheet set. If a style sheet is going
                // to 'unset', it's not known if the resulting source will become
                // null or a valid inherit from a further ancestor. It can also happen
                // if the sheet property is set to anything other than a known value
                // expression.
                bool fKnownRoot = false;

                if (ppcrRoot->ppi == SheetProp && ppcrRoot->pvNew->GetType() == DUIV_SHEET)
                {
                    pps = ppcrRoot->pvNew->GetPropertySheet();
                    fKnownRoot = true;
                }
                else if (ppcrRoot->ppi == ParentProp)
                {
                    if (ppcrRoot->pvNew->GetElement())
                        pps = ppcrRoot->pvNew->GetElement()->GetSheet();
                    fKnownRoot = true;
                }

                if (fKnownRoot)
                {
                    // Get scope in influence from new and current (old) property sheet.
                    // Any duplicates will be coalesed out

                    // New sheet contribution
                    if (pps)
                        pps->GetSheetScope(this, pdr, pdc, &hr);

                    // Old (current) cached sheet
                    PropertySheet* ppsCur = GetSheet();
                    if (ppsCur)
                        ppsCur->GetSheetScope(this, pdr, pdc, &hr);
                }
                else
                {
                    PropertyInfo* ppiScan;
                    UINT nEnum = 0;

                    IClassInfo* pci = GetClassInfo();
                    while ((ppiScan = pci->EnumPropertyInfo(nEnum++)) != NULL)
                    {
                        if (ppiScan->fFlags & PF_Cascade)
                        {
                            _AddDependency(this, ppiScan, PI_Specified, pdr, pdc, &hr);
                        }
                    }
                }
            }
            break;
        }

        // Inherited dependencies
        if (ppi->fFlags & PF_Inherit)
        {
            Value* pv;
            ElementList* peList = GetChildren(&pv);

            if (peList)
            {
                Element* peChild;
                for (UINT i = 0; i < peList->GetSize(); i++)
                {
                    peChild = peList->GetItem(i);
                    if (peChild->GetClassInfo()->IsValidProperty(ppi))  // Will never ask for an unsupported property
                    {
                        // Optimization
                        
                        // If a local value is set, inheritance doesn't matter
                        if (peChild->_pvmLocal->GetItem(ppi))
                            continue;

                        _AddDependency(peChild, ppi, PI_Specified, pdr, pdc, &hr);
                    }
                }
            }

            pv->Release();
        }

        // Default general dependencies on this (Normal flag)
        if ((ppi->fFlags & PF_TypeBits) == PF_TriLevel)
        {
            _AddDependency(this, ppi, PI_Computed, pdr, pdc, &hr);  // Computed is dependent for TriLevel
        }
        break;

    case PI_Computed:
        // Specific dependencies
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Visible:
            Value* pv;
            ElementList* peList = GetChildren(&pv);

            if (peList)
            {
                // All Elements have the Visible property
                Element* peChild;
                for (UINT i = 0; i < peList->GetSize(); i++)
                {
                    peChild = peList->GetItem(i);
                    _AddDependency(peChild, VisibleProp, PI_Computed, pdr, pdc, &hr);
                }
            }
            
            pv->Release();
            break;
        }
        break;

    default:
        DUIAssertForce("Invalid index in GetDependencies");
        break;
    }

    return hr;
}

Value* Element::GetValue(PropertyInfo* ppi, int iIndex, UpdateCache* puc)
{
    // Validate
    DUIContextAssert(this);
    DUIAssert(GetClassInfo()->IsValidProperty(ppi), "Unsupported property");
    DUIAssert(IsValidAccessor(ppi, iIndex, false), "Unsupported Get on property");

#if DBG
    g_cGetVal++;

    //g_gvt.Count(ppi, iIndex, puc ? true : false);
#endif

    Value* pv;

    pv = Value::pvUnset;

    switch (iIndex)
    {
    case PI_Local:
        // Local/Read-only properties (either cached or unchangable expressions)
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Parent:
            pv = (_peLocParent) ? Value::CreateElementRef(_peLocParent) : ParentProp->pvDefault;  // Use ref count
            break;

        case _PIDX_PosInLayout:
            pv = Value::CreatePoint(_ptLocPosInLayt.x, _ptLocPosInLayt.y);  // Use ref count
            break;

        case _PIDX_SizeInLayout:
            pv = Value::CreateSize(_sizeLocSizeInLayt.cx, _sizeLocSizeInLayt.cy);  // Use ref count
            break;

        case _PIDX_DesiredSize:
            pv = Value::CreateSize(_sizeLocDesiredSize.cx, _sizeLocDesiredSize.cy);  // Use ref count
            break;

        case _PIDX_LastDSConst:
            pv = Value::CreateSize(_sizeLocLastDSConst.cx, _sizeLocLastDSConst.cy);  // Use ref count
            break;

        case _PIDX_Location:
            {
                Element* peParent = GetParent();
                int dLayoutPos = GetLayoutPos();

                if (peParent && dLayoutPos != LP_Absolute)
                {
                    // Box model, add in border/padding
                    int dX;
                    int dY;

                    // Get position in layout
                    dX = _ptLocPosInLayt.x;
                    dY = _ptLocPosInLayt.y;

                    // Add on parent's border and padding
                    const RECT* pr = peParent->GetBorderThickness(&pv);  // Border thickness
                    dX += IsRTL() ? pr->right : pr->left;
                    dY += pr->top;
                    pv->Release();

                    pr = peParent->GetPadding(&pv);  // Padding
                    dX += IsRTL() ? pr->right : pr->left;
                    dY += pr->top;
                    pv->Release();

                    pv = Value::CreatePoint(dX, dY);  // Use ref count
                }
                else
                {
                    pv = Value::CreatePoint(GetX(), GetY());
                }
            }
            break;

        case _PIDX_Extent:
            {
                Element* peParent = GetParent();
                int dLayoutPos = GetLayoutPos();

                if (peParent && dLayoutPos != LP_Absolute)
                {
                    pv = Value::CreateSize(_sizeLocSizeInLayt.cx, _sizeLocSizeInLayt.cy);
                }
                else
                {
                    pv = Value::CreateSize(_sizeLocDesiredSize.cx, _sizeLocDesiredSize.cy);
                }
            }
            break;

        case _PIDX_KeyWithin:
            pv = _fBit.bLocKeyWithin ? Value::pvBoolTrue : Value::pvBoolFalse;
            break;

        case _PIDX_MouseWithin:
            pv = _fBit.bLocMouseWithin ? Value::pvBoolTrue : Value::pvBoolFalse;
            break;

        default:
            {
QuickLocalLookup:
                // Default get for Local, Normal, and TriLevel properties
                Value** ppv = _pvmLocal->GetItem(ppi);
                if (ppv)
                {
                    pv = *ppv;
                    pv->AddRef();
                }
            }
            break;
        }

        // On failure, set to Unset
        if (pv == NULL)
            pv = Value::pvUnset;

        // Check if was called as a result of a Specified lookup
        if (iIndex != PI_Local)
            goto QuickLocalLookupReturn;

        break;

    case PI_Specified:
        {
            // Try to get based on cached (or partial cached) value (if updating cache, fall though, do
            // get normally, and cache value at the end)
            if (!puc)
            {
                // Return cached values instead of doing lookup (cannot create values for
                // cached values that will be deleted by the value if no longer referenced)
                switch (ppi->_iGlobalIndex)
                {
                case _PIDX_Children:
                    if (!HasChildren())
                        pv = ChildrenProp->pvDefault;
                    break;

                case _PIDX_Layout:
                    if (!HasLayout())
                        pv = LayoutProp->pvDefault;
                    break;

                case _PIDX_BorderThickness:
                    if (!HasBorder())
                        pv = BorderThicknessProp->pvDefault;
                    break;

                case _PIDX_Padding:
                    if (!HasPadding())
                        pv = PaddingProp->pvDefault;
                    break;

                case _PIDX_Margin:
                    if (!HasMargin())
                        pv = MarginProp->pvDefault;
                    break;

                case _PIDX_Content:
                    if (!HasContent())
                        pv = ContentProp->pvDefault;
                    break;

                case _PIDX_ContentAlign:
                    if (IsDefaultCAlign())
                        pv = ContentAlignProp->pvDefault;
                    break;

                case _PIDX_LayoutPos:
                    pv = Value::CreateInt(_dSpecLayoutPos);  // Use ref count
                    break;

                case _PIDX_Active:
                    pv = Value::CreateInt(_fBit.fSpecActive);  // Use ref count
                    break;

                case _PIDX_Selected:
                    pv = Value::CreateBool(_fBit.bSpecSelected);  // Use ref count
                    break;

                case _PIDX_KeyFocused:
                    pv = Value::CreateBool(_fBit.bSpecKeyFocused);  // Use ref count
                    break;

                case _PIDX_MouseFocused:
                    pv = Value::CreateBool(_fBit.bSpecMouseFocused);  // Use ref count
                    break;

                case _PIDX_Animation:
                    if (!HasAnimation())
                        pv = AnimationProp->pvDefault;
                    break;

                case _PIDX_Cursor:
                    if (IsDefaultCursor())
                        pv = CursorProp->pvDefault;
                    break;

                case _PIDX_Direction:
                    pv = Value::CreateInt(_fBit.nSpecDirection);  // Use ref count
                    break;

                case _PIDX_Accessible:
                    pv = Value::CreateBool(_fBit.bSpecAccessible);  // Use ref count
                    break;

                case _PIDX_Enabled:
                    pv = Value::CreateBool(_fBit.bSpecEnabled);  // Use ref count
                    break;

                case _PIDX_Visible:
                    pv = Value::CreateBool(_fBit.bSpecVisible);  // Use ref count
                    break;

                case _PIDX_BorderColor:
                    if (_fBit.bDefaultBorderColor)
                        pv = BorderColorProp->pvDefault;
                    break;

                case _PIDX_Foreground:
                    if (_fBit.bDefaultForeground)
                        pv = ForegroundProp->pvDefault;
                    break;

                case _PIDX_FontWeight:
                    if (_fBit.bDefaultFontWeight)
                        pv = FontWeightProp->pvDefault;
                    break;

                case _PIDX_FontStyle:
                    if (_fBit.bDefaultFontStyle)
                        pv = FontStyleProp->pvDefault;
                    break;

                case _PIDX_Alpha:
                    pv = Value::CreateInt(_dSpecAlpha);  // Use ref count
                    break;
                }

                // On cache Value creation failure, set to Unset
                if (pv == NULL)
                    pv = Value::pvUnset;

            }

            // Default get for Normal, and TriLevel properties
QuickSpecifiedLookup:
            // Try for local value
            if (pv->GetType() == DUIV_UNSET)
            {
                goto QuickLocalLookup;
            }

QuickLocalLookupReturn:
            // Try for cascaded PropertySheet value if applicable
            if (pv->GetType() == DUIV_UNSET)
            {
                if (ppi->fFlags & PF_Cascade)
                {
                    PropertySheet* pps = GetSheet();
                    if (pps)
                        pv = pps->GetSheetValue(this, ppi);
                }
            }

            // Try to inherit value if applicable
            if (pv->GetType() == DUIV_UNSET)
            {
                bool bNoInherit = false;

                // Conditional inherit of the mouse focused property
                switch (ppi->_iGlobalIndex)
                {
                case _PIDX_KeyFocused:
                    bNoInherit = (!GetEnabled() || (GetActive() & AE_Keyboard));
                    break;

                case _PIDX_MouseFocused:
                    bNoInherit = (!GetEnabled() || (GetActive() & AE_Mouse));
                    break;
                }

                // No need to release static value 'Unset'
                if ((ppi->fFlags & PF_Inherit) && !bNoInherit)
                {
                    Element* peParent = GetParent();
                    if (peParent)
                    {
                        if (peParent->GetClassInfo()->IsValidProperty(ppi))  // Will never ask for an unsupported property
                        {
                            pv = peParent->GetValue(ppi, PI_Specified, NULL);  // Use ref count
                        }
                    }
                    else
                    {
                        pv = Value::pvUnset;  // No ref count on static value
                    }
                }
            }

            // Use default value
            if (pv->GetType() == DUIV_UNSET)
            {
                // No need to release static value 'Unset'
                pv = ppi->pvDefault;
                pv->AddRef();
            }

            // On failure, set to default value
            if (pv == NULL)
                pv = ppi->pvDefault;

            // Check if was called as a result of a Computed lookup
            if (iIndex != PI_Specified)
                goto QuickSpecifiedLookupReturn;

            // Update cached values
            if (puc)
            {
                switch (ppi->_iGlobalIndex)
                {
                case _PIDX_LayoutPos:
                    _dSpecLayoutPos = pv->GetInt();
                    break;

                case _PIDX_Active:
                    _fBit.fSpecActive = pv->GetInt();
                    break;

                case _PIDX_Children:
                    _fBit.bHasChildren = (pv->GetElementList() != NULL);
                    break;

                case _PIDX_Layout:
                    _fBit.bHasLayout = (pv->GetLayout() != NULL);
                    break;

                case _PIDX_BorderThickness:
                    {
                        const RECT* pr = pv->GetRect();
                        _fBit.bHasBorder = (pr->left || pr->top || pr->right || pr->bottom);
                    }
                    break;

                case _PIDX_Padding:
                    {
                        const RECT* pr = pv->GetRect();
                        _fBit.bHasPadding = (pr->left || pr->top || pr->right || pr->bottom);
                    }
                    break;

                case _PIDX_Margin:
                    {
                        const RECT* pr = pv->GetRect();
                        _fBit.bHasMargin = (pr->left || pr->top || pr->right || pr->bottom);
                    }
                    break;

                case _PIDX_Content:
                    _fBit.bHasContent = ((pv->GetType() != DUIV_STRING) || (pv->GetString() != NULL));
                    break;

                case _PIDX_ContentAlign:
                    _fBit.bDefaultCAlign = (pv->GetInt() == 0); // TopLeft, no ellipsis, no focus rect
                    _fBit.bWordWrap = (((pv->GetInt()) & 0xC) == 0xC);  // Word wrap bits
                    break;

                case _PIDX_Sheet:
                    _pvSpecSheet->Release();
                    pv->AddRef();
                    _pvSpecSheet = pv;
                    break;

                case _PIDX_Selected:
                    _fBit.bSpecSelected = pv->GetBool();
                    break;

                case _PIDX_ID:
                    _atomSpecID = pv->GetAtom();
                    break;

                case _PIDX_KeyFocused:
                    _fBit.bSpecKeyFocused = pv->GetBool();
                    break;

                case _PIDX_MouseFocused:
                    _fBit.bSpecMouseFocused = pv->GetBool();
                    break;

                case _PIDX_Animation:
                    _fBit.bHasAnimation = ((pv->GetInt() & ANI_TypeMask) != ANI_None);
                    break;

                case _PIDX_Cursor:
                    _fBit.bDefaultCursor = ((pv->GetType() == DUIV_INT) && (pv->GetInt() == 0));
                    break;

                case _PIDX_Direction:
                    _fBit.nSpecDirection = pv->GetInt();
                    break;

                case _PIDX_Accessible:
                    _fBit.bSpecAccessible = pv->GetBool();
                    break;

                case _PIDX_Enabled:
                    _fBit.bSpecEnabled = pv->GetBool();
                    break;

                case _PIDX_Visible:
                    _fBit.bSpecVisible = pv->GetBool();
                    break;

                case _PIDX_BorderColor:
                    _fBit.bDefaultBorderColor = pv->IsEqual(BorderColorProp->pvDefault);
                    break;

                case _PIDX_Foreground:
                    _fBit.bDefaultForeground = pv->IsEqual(ForegroundProp->pvDefault);
                    break;

                case _PIDX_FontWeight:
                    _fBit.bDefaultFontWeight = pv->IsEqual(FontWeightProp->pvDefault);
                    break;

                case _PIDX_FontStyle:
                    _fBit.bDefaultFontStyle = pv->IsEqual(FontStyleProp->pvDefault);
                    break;

                case _PIDX_Alpha:
                    _dSpecAlpha = pv->GetInt();
                    break;
                }
            }
        }

        break;

    case PI_Computed:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Visible:
            if (puc)
            {
                goto QuickSpecifiedLookup;

QuickSpecifiedLookupReturn:

                _fBit.bCmpVisible = pv->GetBool();

                pv->Release();

                if (_fBit.bCmpVisible)
                {
                    Element* peParent = GetParent();
                    if (peParent)
                    {
                        _fBit.bCmpVisible = peParent->GetVisible(); 
                    }
                }
            }

            pv = (_fBit.bCmpVisible) ? Value::pvBoolTrue : Value::pvBoolFalse;  // No ref count on static values
            break;

        default:
            // Default get for TriLevel properties
            pv = GetValue(ppi, PI_Specified, NULL);  // Use ref count
            break;
        }

        // On failure, set to default value
        if (pv == NULL)
            pv = ppi->pvDefault;

        break;

    default:
        DUIAssertForce("Invalid index for GetValue");
        break;
    }

    DUIAssert(pv != NULL, "Return value from GetValue must never be NULL");
    DUIAssert(iIndex != PI_Local ? pv != Value::pvUnset : true, "Specified and Computed values must never be 'Unset'");

    return pv;
}

// Elements can always set a value for any valid PropertyInfo
HRESULT Element::SetValue(PropertyInfo* ppi, int iIndex, Value* pv)
{
    return _SetValue(ppi, iIndex, pv, false);
}

// Internal SetValue. Used by ReadOnly properties that want to use generic storage.
// All other local values that want to use specific storage must call Pre/PostSourceChange
// directly since a switch statement is intentionally left out of _SetValue for maximum perf.
HRESULT Element::_SetValue(PropertyInfo* ppi, int iIndex, Value* pv, bool fInternalCall)
{
    // Validate
    DUIContextAssert(this);
    DUIAssert(GetClassInfo()->IsValidProperty(ppi), "Unsupported property");
    DUIAssert(fInternalCall ? true : IsValidAccessor(ppi, iIndex, true), "Unsupported Set on property");
    DUIAssert(IsValidValue(ppi, pv), "Invalid value for property");

    // Set
    DUIAssert(iIndex == PI_Local, "Can set Local values only");

    HRESULT hr = S_OK;

    // Partial fail in SetValue means that not all dependents are synced and/or 
    // notifications are fired, but Value was set
    bool fPartialFail = false;  

    Value* pvOld = GetValue(ppi, PI_Local, NULL);

    // No set on equivalent values
    if (!pvOld->IsEqual(pv))
    {
        // No call to OnPropertyChanging if an internal call
        if (fInternalCall || OnPropertyChanging(ppi, iIndex, pvOld, pv))
        {
            if (FAILED(_PreSourceChange(ppi, iIndex, pvOld, pv)))
                fPartialFail = true;  // Not all PC records could be queued, continue

            // Set value
            hr = _pvmLocal->SetItem(ppi, pv);
            if (SUCCEEDED(hr))
            {
                // Storing new value, ref new and release for local reference
                pv->AddRef();
                pvOld->Release();
            }

            if (FAILED(_PostSourceChange()))
                fPartialFail = true; // Not all GPC records could be queued
        }
    }

    // Release for GetValue
    pvOld->Release();

    if (FAILED(hr))
        return hr;
    else
        return fPartialFail ? DUI_E_PARTIAL : S_OK;
}

bool Element::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Inform listeners
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT i = 1; i <= cListeners; i++)
        {
            // Callback
            if (!_ppel[i]->OnListenedPropertyChanging(this, ppi, iIndex, pvOld, pvNew))
                return false;
        }
    }

    return true;
}

// Property changes may not happen immediately after a value is set. If a SetValue happens
// during another SetValue (meaning, a set in an OnPropertyChanged), the notification 
// will be delayed until the outter-most SetValue continues firing the notifications
void Element::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
#if DBG
    //WCHAR szvOld[81];
    //WCHAR szvNew[81];

    //DUITrace("PC: <%x> %S[%d] O:%S N:%S\n", this, ppi->szName, iIndex, pvOld->ToString(szvOld, DUIARRAYSIZE(szvOld)), pvNew->ToString(szvNew, DUIARRAYSIZE(szvNew)));
    
    g_cOnPropChg++;
#endif

    switch (iIndex)
    {
    case PI_Local:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Parent:
            {
                Element* peNewParent = pvNew->GetElement();
                Element* peOldParent = pvOld->GetElement();
                Element* peNewRoot = NULL;
                Element* peOldRoot = NULL;
                HGADGET hgParent = NULL;

                Element* pThis = this;  // Need pointer to this
                Value* pv;

                if (peOldParent) // Unparenting
                {
                    // Inform parent's layout that this is being removed
                    Layout* pl = peOldParent->GetLayout(&pv);

                    if (pl)
                        pl->OnRemove(peOldParent, &pThis, 1);

                    pv->Release();

                    // Parent display node
                    hgParent = NULL;

                    peOldRoot = peOldParent->GetRoot();
                }

                if (peNewParent) // Parenting
                {
                    // No longer a "Root", remove possible Q for UpdateDS and Layout
                    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
                    DUIAssert(pdc, "Defer cycle table doesn't exit");

                    pdc->pvmUpdateDSRoot->Remove(this, false, true);
                    pdc->pvmLayoutRoot->Remove(this, false, true);

                    // Inform parent's layout that this is being added
                    Layout* pl = peNewParent->GetLayout(&pv);

                    if (pl)
                        pl->OnAdd(peNewParent, &pThis, 1);

                    pv->Release();

                    // Parent display node
                    hgParent = peNewParent->GetDisplayNode();

                    peNewRoot = peNewParent->GetRoot();
                }

                SetGadgetParent(GetDisplayNode(), hgParent, NULL, GORDER_TOP);

                // Fire native hosted events
                if (peOldRoot != peNewRoot)
                {
                    if (peOldRoot)
                    {
                        //DUITrace("OnUnHosted: <%x> Old<%x>\n", this, peOldRoot);
                        OnUnHosted(peOldRoot);
                    }

                    if (peNewRoot)
                    {
                        //DUITrace("OnHosted: <%x> New<%x>\n", this, peNewRoot);
                        OnHosted(peNewRoot);
                    }
                }
            }
            break;

        case _PIDX_KeyFocused:
            if (pvNew->GetType() != DUIV_UNSET)
            {
                DUIAssert(pvNew->GetBool(), "Expecting a boolean TRUE\n");

                // May already have keyboard focus if came from system
                if (GetGadgetFocus() != GetDisplayNode())
                    SetGadgetFocus(GetDisplayNode());
            }
            break;
        }
        break;

    case PI_Specified:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Layout:
            {
                Value* pvChildren;
                ElementList* peList = GetChildren(&pvChildren);

                Layout* pl;

                // Detach from old
                pl = pvOld->GetLayout();
                if (pl)
                {
                    // Remove all children from Layout (external layouts only)
                    if (peList)
                    {
                        peList->MakeWritable();
                        pl->OnRemove(this, peList->GetItemPtr(0), peList->GetSize());
                        peList->MakeImmutable();
                    }

                    pl->Detach(this);
                }

                // Attach to new
                pl = pvNew->GetLayout();
                if (pl)
                {
                    pl->Attach(this);

                    // Add all children to Layout (external layouts only)
                    if (peList)
                    {
                        peList->MakeWritable();
                        pl->OnAdd(this, peList->GetItemPtr(0), peList->GetSize());
                        peList->MakeImmutable();
                    }
                }

                pvChildren->Release();
            }
            break;

        case _PIDX_LayoutPos:
            {
                // If no longer a "Root", remove possible Q for UpdateDS and Layout
                if (pvNew->GetInt() != LP_Absolute)
                {
                    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
                    DUIAssert(pdc, "Defer cycle table doesn't exist");

                    pdc->pvmUpdateDSRoot->Remove(this, false, true);
                    pdc->pvmLayoutRoot->Remove(this, false, true);
                }

                // Inform parent layout (if any) of change
                Element* peParent = GetParent();
                if (peParent)
                {
                    Value* pv;
                    Layout* pl = peParent->GetLayout(&pv);

                    // Inform layout of layoutpos only for external layouts
                    if (pl)
                        pl->OnLayoutPosChanged(peParent, this, pvOld->GetInt(), pvNew->GetInt());

                    pv->Release();
                }
            }
            break;

        case _PIDX_Visible:
            // Follow specified value, computed will reflect true state
            SetGadgetStyle(GetDisplayNode(), pvNew->GetBool() ? GS_VISIBLE : 0, GS_VISIBLE);
            break;

        case _PIDX_Enabled:
        case _PIDX_Active:
        {
            BOOL fEnabled;
            int  iActive;
            if (ppi->_iGlobalIndex == _PIDX_Enabled)
            {
                fEnabled = pvNew->GetBool();
                iActive = GetActive();
            }
            else
            {
                fEnabled = GetEnabled();
                iActive = pvNew->GetInt();
            }

            int iFilter =  0;
            int iStyle = 0;
            if (fEnabled)
            {
                if (iActive & AE_Keyboard)
                {
                    iFilter |= GMFI_INPUTKEYBOARD;
                    iStyle |= GS_KEYBOARDFOCUS;
                }
                if (iActive & AE_Mouse)
                {
                    iFilter |= GMFI_INPUTMOUSE;
                    iStyle |= GS_MOUSEFOCUS;
                }
            }
            SetGadgetMessageFilter(GetDisplayNode(), NULL, iFilter, GMFI_INPUTKEYBOARD|GMFI_INPUTMOUSE);
            SetGadgetStyle(GetDisplayNode(), iStyle, GS_KEYBOARDFOCUS|GS_MOUSEFOCUS);
            break;
        }
        case _PIDX_Alpha:
            {
                // Check for alpha animation, start if necessary if alpha animation type
                // Allow animation to update gadget alpha level
                int dAni;
                if (HasAnimation() && ((dAni = GetAnimation()) & ANI_AlphaType) && IsAnimationsEnabled())
                {
                    // Invoke only "alpha" type animations now
                    InvokeAnimation(dAni, ANI_AlphaType);
                }
                else
                    SetGadgetOpacity(GetDisplayNode(), (BYTE)pvNew->GetInt());
            }
            break;

        case _PIDX_Background:
            {
                bool fOpaque = true;

                // Update Opaque style based on background transparency
                if (pvNew->GetType() == DUIV_FILL)
                {
                    const Fill* pf = pvNew->GetFill();
                    if (pf->dType == FILLTYPE_Solid && GetAValue(pf->ref.cr) != 255)
                        fOpaque = false;
                }
                else if (pvNew->GetType() == DUIV_GRAPHIC)
                {
                    Graphic* pg = pvNew->GetGraphic();
                    if (pg->BlendMode.dMode == GRAPHIC_AlphaConst || 
                        pg->BlendMode.dMode == GRAPHIC_AlphaConstPerPix ||
                        pg->BlendMode.dMode == GRAPHIC_NineGridAlphaConstPerPix)
                        fOpaque = false;
                }

                SetGadgetStyle(GetDisplayNode(), (fOpaque)?GS_OPAQUE:0, GS_OPAQUE);
            }

            // Fall though

        case _PIDX_Content:
        case _PIDX_ContentAlign:
        case _PIDX_Padding:
        case _PIDX_BorderThickness:
            {
                Value* pvBG = NULL;
                Value* pvContent = NULL;

                // Update H and V Gadget Redraw based on values of these properties
                bool fHRedraw = false;
                bool fVRedraw = false;

                // Borders
                if (HasBorder())
                {
                    fHRedraw = true;
                    fVRedraw = true;

                    goto SetRedrawStyle;  // Full redraw in both directions
                }

                if (HasContent())
                {
                    // Padding
                    if (HasPadding())
                    {
                        fHRedraw = true;
                        fVRedraw = true;

                        goto SetRedrawStyle;  // Full redraw in both directions
                    }

                    // Alignment                
                    int dCA = GetContentAlign();

                    int dCAHorz = (dCA & 0x3);       // Horizontal content align
                    int dCAVert = (dCA & 0xC) >> 2;  // Vertical content align

                    if (dCAHorz != 0 || dCAVert == 0x3)  // HRedraw if 'center', 'right', or 'wrap'
                        fHRedraw = true;

                    if (dCAVert != 0)  // VRedraw if 'middle', 'bottom', or 'wrap'
                        fVRedraw = true;

                    if (fHRedraw && fVRedraw)
                        goto SetRedrawStyle;  // Full redraw in both directions

                    // Image and fill content may be shrinked if paint area is smaller than image
                    pvContent = GetValue(ContentProp, PI_Specified);  // Released later
                    if (pvContent->GetType() == DUIV_GRAPHIC || pvContent->GetType() == DUIV_FILL)
                    {
                        fHRedraw = true;
                        fVRedraw = true;

                        goto SetRedrawStyle;  // Full redraw in both directions
                    }
                }

                // Background
                pvBG = GetValue(BackgroundProp, PI_Specified);  // Released later

                if (pvBG->GetType() == DUIV_FILL && pvBG->GetFill()->dType != FILLTYPE_Solid)
                {
                    fHRedraw = true;
                    fVRedraw = true;
                    goto SetRedrawStyle;
                }

                if (pvBG->GetType() == DUIV_GRAPHIC)
                {
                    Graphic * pgr = pvBG->GetGraphic();
                    if (pgr->BlendMode.dImgType == GRAPHICTYPE_EnhMetaFile)
                    {
                        fHRedraw = true;
                        fVRedraw = true;
                        goto SetRedrawStyle;
                    }
                    if ((pgr->BlendMode.dImgType == GRAPHICTYPE_Bitmap) ||
#ifdef GADGET_ENABLE_GDIPLUS                    
                        (pgr->BlendMode.dImgType == GRAPHICTYPE_GpBitmap) ||
#endif GADGET_ENABLE_GDIPLUS
                        0)
                    {
                        BYTE dMode = pgr->BlendMode.dMode;
                        if ((dMode == GRAPHIC_Stretch) || (dMode == GRAPHIC_NineGrid) || (dMode == GRAPHIC_NineGridTransColor)) 
                        {
                            fHRedraw = true;
                            fVRedraw = true;
                            goto SetRedrawStyle;
                        }
                    }
                }

SetRedrawStyle:
                SetGadgetStyle(GetDisplayNode(), ((fHRedraw)?GS_HREDRAW:0) | ((fVRedraw)?GS_VREDRAW:0), GS_HREDRAW|GS_VREDRAW);

                if (pvBG)
                    pvBG->Release();
                if (pvContent)
                    pvContent->Release();
            }
            break;

        case _PIDX_KeyFocused:
            {
                if (GetAccessible()) {
                    if (GetActive() & AE_Keyboard) {
                        int nAccState = GetAccState();
                        if (pvNew->GetBool()) {
                            nAccState |= STATE_SYSTEM_FOCUSED;
                            NotifyAccessibilityEvent(EVENT_OBJECT_FOCUS, this);
                        } else {
                            nAccState &= ~STATE_SYSTEM_FOCUSED;
                        }
                        SetAccState(nAccState);
                    }
                }
            }
            break;

        case _PIDX_Animation:
            {
                // If old animation value contained an animation type and the replacement
                // animation does not, stop the animation
            
                if ((pvOld->GetInt() & ANI_BoundsType) && !(pvNew->GetInt() & ANI_BoundsType))
                    StopAnimation(ANI_BoundsType);

                if ((pvOld->GetInt() & ANI_AlphaType) && !(pvNew->GetInt() & ANI_AlphaType))
                    StopAnimation(ANI_AlphaType);
            }
            break;

        case _PIDX_Accessible:
            {
                //
                // When accessibility support for this element is turned ON,
                // make sure that its state reflects the appropriate information.
                //
                if (pvNew->GetBool()) {
                    if (GetActive() & AE_Keyboard) {
                        int nAccState = GetAccState();
                        if (GetKeyFocused()) {
                            nAccState |= STATE_SYSTEM_FOCUSED;
                            NotifyAccessibilityEvent(EVENT_OBJECT_FOCUS, this);
                        } else {
                            nAccState &= ~STATE_SYSTEM_FOCUSED;
                        }
                        SetAccState(nAccState);
                    }
                }
            }
            break;

        case _PIDX_AccRole:
            {
                /*
                 * Note: Supposedly, the role of a UI element doesn't change
                 * at run time.  Doing so may confuse accessibility tools.
                 * Correspondingly, there is no defined Accessibility event
                 * to announce that the role changed.  So doing so will only
                 * result in a new role being returned from future calls to
                 * IAccessible::get_accRole().
                 */
            }
            break;

        case _PIDX_AccState:
            {
                /*
                 * When the state of an accessible component changes, we send
                 * the EVENT_OBJECT_STATECHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_STATECHANGE, this);
                }
            }
            break;

        case _PIDX_AccName:
            {
                /*
                 * When the name of an accessible component changes, we send
                 * the EVENT_OBJECT_NAMECHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_NAMECHANGE, this);
                }
            }
            break;

        case _PIDX_AccDesc:
            {
                /*
                 * When the description of an accessible component changes, we send
                 * the EVENT_OBJECT_DESCRIPTIONCHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_DESCRIPTIONCHANGE, this);
                }
            }
            break;

        case _PIDX_AccValue:
            {
                /*
                 * When the value of an accessible component changes, we send
                 * the EVENT_OBJECT_VALUECHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_VALUECHANGE, this);
                }
            }
            break;
        }
        break;

    case PI_Computed:
        break;
    }

    // Inform lisnteners
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT_PTR i = 1; i <= cListeners; i++)
        {
            // Callback
            _ppel[i]->OnListenedPropertyChanged(this, ppi, iIndex, pvOld, pvNew);
        }
    }
}

void Element::OnGroupChanged(int fGroups, bool bLowPri)
{
#if DBG
/*
    TCHAR szGroups[81];
    *szGroups = 0;
    if (fGroups & PG_AffectsDesiredSize)
        _tcscat(szGroups, L"D");
    if (fGroups & PG_AffectsParentDesiredSize)
        _tcscat(szGroups, L"pD");
    if (fGroups & PG_AffectsLayout)
        _tcscat(szGroups, L"L");
    if (fGroups & PG_AffectsParentLayout)
        _tcscat(szGroups, L"pL");
    if (fGroups & PG_AffectsDisplay)
        _tcscat(szGroups, L"P");
    if (fGroups & PG_AffectsBounds)
        _tcscat(szGroups, L"B");
    DUITrace("GC: <%x> %s LowPri:%d (%d)\n", this, szGroups, bLowPri, fGroups);
*/
#endif

    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;

    DUIAssert(pdc, "Defer cycle table doesn't exist");

    if (bLowPri)  // Low priority groups
    {
        // All low pri's use Extent

        // Affects Native Window Bounds
        if (fGroups & PG_AffectsBounds)
        {
            // Check for position animation, start if necessary if size, position, or
            // rect animation, allow animation to set gadget rect
            int dAni;
            if (HasAnimation() && ((dAni = GetAnimation()) & ANI_BoundsType) && IsAnimationsEnabled())
            {
                // Invoke only "bounds" type animations now
                InvokeAnimation(dAni, ANI_BoundsType);
            }
            else
            {
                Value* pvLoc;
                Value* pvExt;

                const POINT* pptLoc = GetLocation(&pvLoc);
                const SIZE* psizeExt = GetExtent(&pvExt);

                // Verify the coordinates do not wrap. If they do, don't call SetGadgetRect.
                if (((pptLoc->x + psizeExt->cx) >= pptLoc->x) && ((pptLoc->y + psizeExt->cy) >= pptLoc->y))
                {
                    // PERF: SGR_NOINVALIDATE exists for perf, needs to be evaluated
                    SetGadgetRect(GetDisplayNode(), pptLoc->x, pptLoc->y, psizeExt->cx, psizeExt->cy, /*SGR_NOINVALIDATE|*/SGR_PARENT|SGR_MOVE|SGR_SIZE);
                }

                pvLoc->Release();
                pvExt->Release();
            }
        }

        // Affects Display
        if (fGroups & PG_AffectsDisplay)
        {
            // Gadget needs painting
            InvalidateGadget(GetDisplayNode());
        }
     }
    else  // Normal priority groups
    {
        // Affects Desired Size or Affects Layout
        if (fGroups & (PG_AffectsDesiredSize | PG_AffectsLayout))
        {
            // Locate Layout/DS root and queue tree as needing a layout pass
            // Root doesn't have parent or is absolute positioned
            Element* peRoot;
            Element* peClimb = this; // Start condition
            int dLayoutPos;
            do
            {
                peRoot = peClimb;

                peClimb = peRoot->GetParent(); 
                dLayoutPos = peRoot->GetLayoutPos(); 

            } while (peClimb && dLayoutPos != LP_Absolute);

            DUIAssert(peRoot, "Root not located for layout/update desired size bit set");

            if (fGroups & PG_AffectsDesiredSize)
            {
                _fBit.bNeedsDSUpdate = true;
                pdc->pvmUpdateDSRoot->SetItem(peRoot, 1, true);
            }
            
            if (fGroups & PG_AffectsLayout)
            {
                _fBit.fNeedsLayout = LC_Normal;
                pdc->pvmLayoutRoot->SetItem(peRoot, 1, true);
            }
        }

        // Affects Parent's Desired Size or Affects Parent's Layout
        if (fGroups & (PG_AffectsParentDesiredSize | PG_AffectsParentLayout))
        {
            // Locate Layout/DS root and queue tree as needing a layout pass
            // Root doesn't have parent or is absolute positioned
            Element* peRoot;
            Element* peClimb = this; // Start condition
            Element* peParent = NULL;
            int dLayoutPos;
            do
            {
                peRoot = peClimb;

                peClimb = peRoot->GetParent(); 
                if (peClimb && !peParent)
                    peParent = peClimb;

                dLayoutPos = peRoot->GetLayoutPos(); 

            } while (peClimb && dLayoutPos != LP_Absolute);

            DUIAssert(peRoot, "Root not located for parent layout/update desired size bit set");

            if (peParent)
            {
                if (fGroups & PG_AffectsParentDesiredSize)
                {
                    peParent->_fBit.bNeedsDSUpdate = true;
                    pdc->pvmUpdateDSRoot->SetItem(peRoot, 1, true);
                }

                if (fGroups & PG_AffectsParentLayout)
                {
                    peParent->_fBit.fNeedsLayout = LC_Normal;
                    pdc->pvmLayoutRoot->SetItem(peRoot, 1, true);
                }
            }
        }
    }
}

////////////////////////////////////////////////////////
// Checks

// Determine if the Get or Set operation is valid based on the property flags
bool Element::IsValidAccessor(PropertyInfo* ppi, int iIndex, bool bSetting)
{
    if (bSetting)  // SetValue
    {
        if ((iIndex != PI_Local) || (ppi->fFlags & PF_ReadOnly))
            return false;
    }
    else           // GetValue
    {
        if (iIndex > (ppi->fFlags & PF_TypeBits))
            return false;
    }

    return true;
}

// Check if value type matches a type acceptable for PropertyInfo
bool Element::IsValidValue(PropertyInfo* ppi, Value* pv)
{
    bool bValid = false;
    if (ppi->pValidValues && ppi && pv)
    {
        int i = 0;
        int vv;
        while ((vv = ppi->pValidValues[i++]) != -1)
        {
            if (pv->GetType() == vv)
            {
                bValid = true;
                break;
            }
        }
    }

    return bValid;
}

////////////////////////////////////////////////////////
// Additional property methods

// Elements can always remove a value for any valid PropertyInfo
HRESULT Element::RemoveLocalValue(PropertyInfo* ppi)
{
    return _RemoveLocalValue(ppi, false);
}

// Internal SetValue. Used by ReadOnly properties that want to use generic storage.
// All other local values that want to use specific storage must call Pre/PostSourceChange
// directly since a switch statement is intentionally left out of _RemoveLocalValue for maximum perf.
HRESULT Element::_RemoveLocalValue(PropertyInfo* ppi, bool fInternalCall)
{
    UNREFERENCED_PARAMETER(fInternalCall);

    DUIAssert(GetClassInfo()->IsValidProperty(ppi), "Unsupported property");
    DUIAssert(fInternalCall ? true : IsValidAccessor(ppi, PI_Local, true), "Cannot remove local value for read-only property");

    // Partial fail in SetValue means that not all dependents are synced and/or 
    // notifications are fired, but Value was set
    bool fPartialFail = false;

    Value** ppv = _pvmLocal->GetItem(ppi);
    if (ppv)
    {
        Value* pv = *ppv;  // Make copy in case it moves

        if (FAILED(_PreSourceChange(ppi, PI_Local, pv, Value::pvUnset)))
            fPartialFail = true;  // Not all PC records could be queued, continue

        // Remove Value, never fails
        _pvmLocal->Remove(ppi);

        // Old value removed, release for local reference
        pv->Release();

        if (FAILED(_PostSourceChange()))
            fPartialFail = true;  // Not all GPC records could be queued
    }

    return fPartialFail ? DUI_E_PARTIAL : S_OK;
}

////////////////////////////////////////////////////////
// DeferCycle: Per-thread deferring information

HRESULT DeferCycle::Create(DeferCycle** ppDC)
{
    *ppDC = NULL;

    DeferCycle* pdc = HNew<DeferCycle>();
    if (!pdc)
        return E_OUTOFMEMORY;

    HRESULT hr = pdc->Initialize();
    if (FAILED(hr))
    {
        pdc->Destroy();
        return hr;
    }

    *ppDC = pdc;

    return S_OK;
}

HRESULT DeferCycle::Initialize()
{
    // Defer cycle state
    cEnter = 0;
    cPCEnter = 0;

    iGCPtr = -1;
    iGCLPPtr = -1;
    iPCPtr = -1;
    iPCSSUpdate = 0;

    fFiring = false;

    // Defer cycle tables
    pvmUpdateDSRoot = NULL;
    pvmLayoutRoot = NULL;
    pdaPC = NULL;
    pdaGC = NULL;
    pdaGCLP = NULL;

    HRESULT hr;

    hr = ValueMap<Element*,BYTE>::Create(11, &pvmUpdateDSRoot);   // Update desired size trees pending
    if (FAILED(hr))
        goto Failed;

    hr = ValueMap<Element*,BYTE>::Create(11, &pvmLayoutRoot);     // Layout trees pending
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<PCRecord>::Create(32, false, &pdaPC);       // Property changed database
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<GCRecord>::Create(32, false, &pdaGC);       // Group changed database
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<GCRecord>::Create(32, false, &pdaGCLP);     // Low priority group changed database
    if (FAILED(hr))