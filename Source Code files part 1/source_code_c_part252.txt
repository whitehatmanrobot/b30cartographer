   //
        // For AddWrapper, the crst is always held.
        // For Release, there are 2 cases:
        //      the MTA group always holds the crst when using the hash table
        //      for an STA group, the entire group is removed from the cleanup list atomically under the crst,
        //          but the lock is released before iterating the hash table to clean it out.  (At that point the
        //          hash table is effectively single threaded since nobody outside the cleanup list holds pointers
        //          to the groups.)

        LockOwner realLock = {pCrst, IsOwnerOfCrst};
        LockOwner dummyLock = {pCrst, TrustMeIAmSafe};

        LockOwner *pLock;
        if (pCrst == NULL)
            pLock = &dummyLock;
        else
            pLock = &realLock;

        return m_CtxCookieToContextCleanupGroupMap.Init(CLEANUP_LIST_INIT_MAP_SIZE, pLock);
    }

    static BOOL OwnerOfCleanupGroupMap (LPVOID data)
    {
#ifdef _DEBUG
        return data == GetThread() || GetThread() == g_pGCHeap->GetFinalizerThread();
#else
        return TRUE;
#endif
    }

    Thread *GetSTAThread()
    {
        return m_pSTAThread;
    }
    
    BOOL AddWrapper(ComPlusWrapper *pRCW, CtxEntry *pEntry);

    // Cleans up all the wrappers in the clean up list.
    void CleanUpWrappers(CrstHolder *pHolder);

    // Cleans up all the wrappers from the current context only
    void CleanUpCurrentCtxWrappers(CrstHolder *pHolder);

private:
    void Enter();
    void Leave();

    // Callback called to clean up the wrappers in a group.
    static HRESULT ReleaseCleanupGroupCallback(LPVOID pData);

    // Callback used to switch STA's & clean up the wrappers in a group.
    static HRESULT CleanUpWrappersCallback(LPVOID pData);

    // Helper method called from ReleaseCleanupGroupCallback.
    static void ReleaseCleanupGroup(ComPlusContextCleanupGroup *pCleanupGroup);

    // Hashtable that maps from a context cookie to a list of ctx clean up groups.
    EEPtrHashTable m_CtxCookieToContextCleanupGroupMap;

    Thread *       m_pSTAThread;
};

//--------------------------------------------------------------------------
// Cleanup list of RCW's. This clean up list is used to group RCW's by 
// context before they are released.
//--------------------------------------------------------------------------
class ComPlusWrapperCleanupList
{
    friend struct MEMBER_OFFSET_INFO(ComPlusWrapperCleanupList);
public:
    // Constructor and destructor.
    ComPlusWrapperCleanupList();
    ~ComPlusWrapperCleanupList();

    // Initialization method.
    BOOL Init()
    {
        m_pMTACleanupGroup = new ComPlusApartmentCleanupGroup(NULL);
        LockOwner lock = {&m_lock,IsOwnerOfCrst};
        return (m_pMTACleanupGroup != NULL
                && m_pMTACleanupGroup->Init(&m_lock)
                && m_STAThreadToApartmentCleanupGroupMap.Init(CLEANUP_LIST_INIT_MAP_SIZE,&lock));
    }

    // Adds a wrapper to the clean up list.
    BOOL AddWrapper(ComPlusWrapper *pRCW);

    // Cleans up all the wrappers in the clean up list.
    void CleanUpWrappers();

    // Cleans up all the wrappers from the current STA or context only
    void CleanUpCurrentWrappers(BOOL wait = TRUE);

private:
    void Enter();
    void Leave();

    // Callback called to clean up the wrappers in a group.
    static HRESULT ReleaseCleanupGroupCallback(LPVOID pData);

    // Helper method called from ReleaseCleanupGroupCallback.
    static void ReleaseCleanupGroup(ComPlusApartmentCleanupGroup *pCleanupGroup);

    // Hashtable that maps from a context cookie to a list of apt clean up groups.
    EEPtrHashTable                  m_STAThreadToApartmentCleanupGroupMap;

    ComPlusApartmentCleanupGroup *  m_pMTACleanupGroup;

    // Lock against adding/modifying.
    Crst                            m_lock;

    // Fast check for whether threads should help cleanup wrappers in their contexts
    BOOL                            m_doCleanupInContexts;

    // Current STA which finalizer thread is trying to enter to perform cleanup
    Thread *                        m_currentCleanupSTAThread;
};

//--------------------------------------------------------------------------
// For fast calls from the marshalling stubs, and handling cast checks
// 
IUnknown* ComPlusWrapper::GetComIPFromWrapper(OBJECTREF oRef, REFIID iid)
{
    THROWSCOMPLUSEXCEPTION();

    COMOBJECTREF pRef = (COMOBJECTREF)oRef;

    ComPlusWrapper *pWrap = pRef->GetWrapper();

    // Validate that the COM object is still attached to its ComPlusWrapper.
    if (!pWrap)
        COMPlusThrow(kInvalidComObjectException, IDS_EE_COM_OBJECT_NO_LONGER_HAS_WRAPPER);

    return pWrap->GetComIPFromWrapper(iid);
}

//--------------------------------------------------------------------------
// For fast calls from the marshalling stubs, and handling cast checks
// 
IUnknown* ComPlusWrapper::InlineGetComIPFromWrapper(OBJECTREF oRef, MethodTable* pIntf)
{
    THROWSCOMPLUSEXCEPTION();

    COMOBJECTREF pRef = (COMOBJECTREF)oRef;

    ComPlusWrapper *pWrap = pRef->GetWrapper();

    // Validate that the COM object is still attached to its ComPlusWrapper.
    if (!pWrap)
        COMPlusThrow(kInvalidComObjectException, IDS_EE_COM_OBJECT_NO_LONGER_HAS_WRAPPER);

    return pWrap->GetComIPFromWrapper(pIntf);
}

//--------------------------------------------------------------------------
// Same as InlineGetComIPFromWrapper but throws an exception if the 
// interface is not supported.
// 
IUnknown* ComPlusWrapper::GetComIPFromWrapperEx(OBJECTREF oRef, MethodTable* pIntf)
{
    THROWSCOMPLUSEXCEPTION();

    COMOBJECTREF pRef = (COMOBJECTREF)oRef;

    ComPlusWrapper *pWrap = pRef->GetWrapper();

    // Validate that the COM object is still attached to its ComPlusWrapper.
    if (!pWrap)
        COMPlusThrow(kInvalidComObjectException, IDS_EE_COM_OBJECT_NO_LONGER_HAS_WRAPPER);

    IUnknown* pIUnk = pWrap->GetComIPFromWrapper(pIntf);
    if (pIUnk == NULL)
    {
        DefineFullyQualifiedNameForClassW()
        GetFullyQualifiedNameForClassW(pIntf->GetClass());
        COMPlusThrow(kInvalidCastException, IDS_EE_QIFAILEDONCOMOBJ, _wszclsname_);
    }

    return pIUnk;
}

//--------------------------------------------------------------------------
// For fast calls from the marshalling stubs, and handling cast checks
// 
inline IUnknown* ComObject::GetComIPFromWrapper(OBJECTREF oref, MethodTable* pIntfTable)
{
    return ComPlusWrapper::InlineGetComIPFromWrapper(oref, pIntfTable);
}

#endif _COMPLUSWRAPPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\compluscall.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ComCall.CPP -
//
// Com to Com+ call support.
//@perf
// 1: get rid of two caches in the generic case, when we start generating optimal stubs

#include "common.h"
#include "ml.h"
#include "stublink.h"
#include "excep.h"
#include "mlgen.h"
#include "compluscall.h"
#include "siginfo.hpp"
#include "comcallwrapper.h"
#include "compluswrapper.h"
#include "mlcache.h"
#include "comvariant.h"
#include "ndirect.h"
#include "mlinfo.h"
#include "eeconfig.h"
#include "remoting.h"
#include "ReflectUtil.h"
#include "COMString.h"
#include "COMMember.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif // CUSTOMER_CHECKED_BUILD

#define DISPATCH_INVOKE_SLOT 6

// get stub for com to com+ call
static Stub * CreateComPlusCallMLStub(ComPlusCallMethodDesc *pMD,
                                      PCCOR_SIGNATURE szMetaSig,
                                      HENUMInternal *phEnumParams,
                                      BOOL bHResult,
                                      BOOL fLateBound,
                                      BOOL fComEventCall,
                                      Module* pModule,
                                      OBJECTREF *ppException
                                      );

ComPlusCallMLStubCache *ComPlusCall::m_pComPlusCallMLStubCache = NULL;

static Stub* g_pGenericComplusCallStub = NULL;

class ComPlusCallMLStubCache : public MLStubCache
{
  public:
    ComPlusCallMLStubCache(LoaderHeap *heap = 0) : MLStubCache(heap) {}
    
  private:
        //---------------------------------------------------------
        // Compile a native (ASM) version of the ML stub.
        //
        // This method should compile into the provided stublinker (but
        // not call the Link method.)
        //
        // It should return the chosen compilation mode.
        //
        // If the method fails for some reason, it should return
        // INTERPRETED so that the EE can fall back on the already
        // created ML code.
        //---------------------------------------------------------
        virtual MLStubCompilationMode CompileMLStub(const BYTE *pRawMLStub,
                                                    StubLinker *pstublinker,
                                                    void *callerContext);

        //---------------------------------------------------------
        // Tells the MLStubCache the length of an ML stub.
        //---------------------------------------------------------
        virtual UINT Length(const BYTE *pRawMLStub)
        {
            MLHeader *pmlstub = (MLHeader *)pRawMLStub;
            return sizeof(MLHeader) + MLStreamLength(pmlstub->GetMLCode());
        }
};



//---------------------------------------------------------
// Compile a native (ASM) version of the ML stub.
//
// This method should compile into the provided stublinker (but
// not call the Link method.)
//
// It should return the chosen compilation mode.
//
// If the method fails for some reason, it should return
// INTERPRETED so that the EE can fall back on the already
// created ML code.
//---------------------------------------------------------
MLStubCache::MLStubCompilationMode ComPlusCallMLStubCache::CompileMLStub(const BYTE *pRawMLStub,
                                                                         StubLinker *pstublinker, 
                                                                         void *callerContext)
{
    MLStubCompilationMode mode = INTERPRETED;
    COMPLUS_TRY 
    {
        CPUSTUBLINKER *psl = (CPUSTUBLINKER *)pstublinker;
        const MLHeader *pheader = (const MLHeader *)pRawMLStub;
        if (NDirect::CreateStandaloneNDirectStubSys(pheader, (CPUSTUBLINKER*)psl, TRUE)) {
            mode = STANDALONE;
            __leave;
        }
    } 
    COMPLUS_CATCH
    {        
        mode = INTERPRETED;
    }
    COMPLUS_END_CATCH

    return mode;
}

//---------------------------------------------------------
// One-time init
//---------------------------------------------------------
/*static*/ 
BOOL ComPlusCall::Init()
{
    if (NULL == (m_pComPlusCallMLStubCache 
          = new ComPlusCallMLStubCache(SystemDomain::System()->GetStubHeap()))) 
    {
        return FALSE;
    }

    // 
    // Init debugger-related values
    //

    ComPlusToComWorker(NULL, NULL);

    return TRUE;
}

//---------------------------------------------------------
// One-time cleanup
//---------------------------------------------------------
/*static*/ 
#ifdef SHOULD_WE_CLEANUP
VOID ComPlusCall::Terminate()
{
    if (m_pComPlusCallMLStubCache)
    {
        delete m_pComPlusCallMLStubCache;
        m_pComPlusCallMLStubCache = NULL;
    }

    if (g_pGenericComplusCallStub != NULL)
    {
        g_pGenericComplusCallStub->DecRef();
        g_pGenericComplusCallStub = NULL;
    }
    
}
#endif /* SHOULD_WE_CLEANUP */


I4ARRAYREF SetUpWrapperInfo(MethodDesc *pMD)
{
    Module *pModule = pMD->GetModule();
    IMDInternalImport *pInternalImport = pModule->GetMDImport();
    CorElementType  mtype;
    MetaSig         msig(pMD->GetSig(), pModule);
    LPCSTR          szName;
    USHORT          usSequence;
    DWORD           dwAttr;
    mdParamDef      returnParamDef = mdParamDefNil;
    mdParamDef      currParamDef = mdParamDefNil;
    I4ARRAYREF      WrapperTypeArr = NULL;
    I4ARRAYREF      RetArr = NULL;

#ifdef _DEBUG
    LPCUTF8         szDebugName = pMD->m_pszDebugMethodName;
    LPCUTF8         szDebugClassName = pMD->m_pszDebugClassName;
#endif

    int numArgs = msig.NumFixedArgs();
    SigPointer returnSig = msig.GetReturnProps();
    HENUMInternal *phEnumParams = NULL;
    HENUMInternal hEnumParams;

    GCPROTECT_BEGIN(WrapperTypeArr)
    {
        //
        // Allocate the array of wrapper types.
        //

        WrapperTypeArr = (I4ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_I4, numArgs);


        //
        // Initialize the parameter definition enum.
        //

        HRESULT hr = pInternalImport->EnumInit(mdtParamDef, pMD->GetMemberDef(), &hEnumParams);
        if (SUCCEEDED(hr)) 
            phEnumParams = &hEnumParams;


        //
        // Retrieve the paramdef for the return type and determine which is the next 
        // parameter that has parameter information.
        //

        do 
        {
            if (phEnumParams && pInternalImport->EnumNext(phEnumParams, &currParamDef))
            {
                szName = pInternalImport->GetParamDefProps(currParamDef, &usSequence, &dwAttr);
                if (usSequence == 0)
                {
                    // The first parameter, if it has sequence 0, actually describes the return type.
                    returnParamDef = currParamDef;
                }
            }
            else
            {
                usSequence = (USHORT)-1;
            }
        }
        while (usSequence == 0);

        // Look up the best fit mapping info via Assembly & Interface level attributes
        BOOL BestFit = TRUE;
        BOOL ThrowOnUnmappableChar = FALSE;
        ReadBestFitCustomAttribute(pMD, &BestFit, &ThrowOnUnmappableChar);

        //
        // Determine the wrapper type of the arguments.
        //

        int iParam = 1;
        while (ELEMENT_TYPE_END != (mtype = msig.NextArg()))
        {
            //
            // Get the parameter token if the current parameter has one.
            //

            mdParamDef paramDef = mdParamDefNil;
            if (usSequence == iParam)
            {
                paramDef = currParamDef;

                if (pInternalImport->EnumNext(phEnumParams, &currParamDef))
                {
                    szName = pInternalImport->GetParamDefProps(currParamDef, &usSequence, &dwAttr);

                    // Validate that the param def tokens are in order.
                    _ASSERTE((usSequence > iParam) && "Param def tokens are not in order");
                }
                else
                {
                    usSequence = (USHORT)-1;
                }
            }


            //
            // Set up the marshaling info for the parameter.
            //

            MarshalInfo Info(pModule, msig.GetArgProps(), paramDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 
                              0, 0, TRUE, iParam, BestFit, ThrowOnUnmappableChar
    
    #ifdef CUSTOMER_CHECKED_BUILD
                             ,pMD
    #endif
    #ifdef _DEBUG
                             ,szDebugName, szDebugClassName, NULL, iParam
    #endif
                             );


            //
            // Based on the MarshalInfo, set the wrapper type.
            //

            *((DWORD*)WrapperTypeArr->GetDataPtr() + iParam - 1) = Info.GetDispWrapperType();


            //
            // Increase the argument index.
            //

            iParam++;
        }

        // Make sure that there are not more param def tokens then there are COM+ arguments.
        _ASSERTE( usSequence == (USHORT)-1 && "There are more parameter information tokens then there are COM+ arguments" );

        //
        // If the paramdef enum was used, then close it.
        //

        if (phEnumParams)
            pInternalImport->EnumClose(phEnumParams);
    }
    
    RetArr = WrapperTypeArr;

    GCPROTECT_END();

    return RetArr;
}


extern PCCOR_SIGNATURE InitMessageData(messageData *msgData, FramedMethodFrame *pFrame, Module **ppModule);

INT64 ComPlusToComLateBoundWorker(Thread *pThread, ComPlusMethodFrame* pFrame, ComPlusCallMethodDesc *pMD, MLHeader *pHeader)
{
    static MethodDesc *s_pForwardCallToInvokeMemberMD = NULL;

    HRESULT hr = S_OK;
    DISPID DispId = DISPID_UNKNOWN;
    INT64 retVal;
    STRINGREF MemberNameObj = NULL;
    OBJECTREF ItfTypeObj = NULL;
    I4ARRAYREF WrapperTypeArr = NULL;
    const unsigned cbExtraSlots = 7;
    DWORD BindingFlags = BINDER_AllLookup;
    mdProperty pd;
    LPCUTF8 strMemberName;
    mdToken tkMember;
    ULONG uSemantic;
    
    LOG((LF_STUBS, LL_INFO1000, "Calling ComPlusToComLateBoundWorker %s::%s \n", pMD->m_pszDebugClassName, pMD->m_pszDebugMethodName));

    // Retrieve the method desc for RuntimeType::ForwardCallToInvokeMember().
    if (!s_pForwardCallToInvokeMemberMD)
        s_pForwardCallToInvokeMemberMD = g_Mscorlib.GetMethod(METHOD__CLASS__FORWARD_CALL_TO_INVOKE);

    // Retrieve the method table and the method desc of the call.
    MethodTable *pItfMT = pMD->GetInterfaceMethodTable();
    ComPlusCallMethodDesc *pItfMD = pMD;
    IMDInternalImport *pMDImport = pItfMT->GetClass()->GetMDImport();

    // Make sure this is only called on dispath only interfaces.
    _ASSERTE(pItfMT->GetComInterfaceType() == ifDispatch);

    // If this is a method impl MD then we need to retrieve the actual interface MD that
    // this is a method impl for.
    // BUGBUG: Stop using ComSlot to convert method impls to interface MD
    // _ASSERTE(pMD.compluscall.m_cachedComSlot == 7);
    // GopalK
    if (pMD->IsMethodImpl())
        pItfMD = (ComPlusCallMethodDesc*)pItfMT->GetMethodDescForSlot(pMD->compluscall.m_cachedComSlot - cbExtraSlots);

    // See if there is property information for this member.
    hr = pMDImport->GetPropertyInfoForMethodDef(pItfMD->GetMemberDef(), &pd, &strMemberName, &uSemantic);
    if (hr == S_OK)
    {
        // We are dealing with a property accessor.
        tkMember = pd;

        // Determine which type of accessor we are dealing with.
        switch (uSemantic)
        {
            case msGetter:
            {
                // We are dealing with a INVOKE_PROPERTYGET.
                BindingFlags |= BINDER_GetProperty;
                break;
            }

            case msSetter:
            {
                // We are dealing with a INVOKE_PROPERTYPUT or a INVOKE_PROPERTYPUTREF.
                ULONG cAssoc;
                ASSOCIATE_RECORD* pAssoc;
                HENUMInternal henum;
                BOOL bPropHasOther = FALSE;

                // Retrieve all the associates.
                pMDImport->EnumAssociateInit(pd,&henum);
                cAssoc = pMDImport->EnumGetCount(&henum);
                _ASSERTE(cAssoc > 0);
                pAssoc = (ASSOCIATE_RECORD*) _alloca(sizeof(ASSOCIATE_RECORD) * cAssoc);
                pMDImport->GetAllAssociates(&henum, pAssoc, cAssoc);
                pMDImport->EnumClose(&henum);

                // Check to see if there is both a set and an other. If this is the case
                // then the setter is a INVOKE_PROPERTYPUTREF otherwise we will make it a 
                // INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF.
                for (ULONG i = 0; i < cAssoc; i++)
                {
                    if (pAssoc[i].m_dwSemantics == msOther)
                    {
                        bPropHasOther = TRUE;
                        break;
                    }
                }

                if (bPropHasOther)
                {
                    // There is both a INVOKE_PROPERTYPUT and a INVOKE_PROPERTYPUTREF for this
                    // property so we need to be specific and make this invoke a INVOKE_PROPERTYPUTREF.
                    BindingFlags |= BINDER_PutRefDispProperty;
                }
                else
                {
                    // There is only a setter so we need to make the invoke a Set which will map to
                    // INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF.
                    BindingFlags = BINDER_SetProperty;
                }
                break;
            }

            case msOther:
            {
                // We are dealing with a INVOKE_PROPERTYPUT
                BindingFlags |= BINDER_PutDispProperty;
                break;
            }

            default:
            {
                _ASSERTE(!"Invalid method semantic!");
            }
        }
    }
    else
    {
        // We are dealing with a normal method.
        strMemberName = pItfMD->GetName();
        tkMember = pItfMD->GetMemberDef();
        BindingFlags |= BINDER_InvokeMethod;
    }

    GCPROTECT_BEGIN(MemberNameObj)
    GCPROTECT_BEGIN(ItfTypeObj)
    GCPROTECT_BEGIN(WrapperTypeArr)
    {
        // Retrieve the exposed type object for the interface.
        ItfTypeObj = pItfMT->GetClass()->GetExposedClassObject();

        // Retrieve the name of the member we will be invoking on. If the member 
        // has a DISPID then we will use that to optimize the invoke.
        hr = pItfMD->GetMDImport()->GetDispIdOfMemberDef(tkMember, (ULONG*)&DispId);
        if (hr == S_OK)
        {
            WCHAR strTmp[64];
            swprintf(strTmp, DISPID_NAME_FORMAT_STRING, DispId);
            MemberNameObj = COMString::NewString(strTmp);
        }
        else
        {
            MemberNameObj = COMString::NewString(strMemberName);
        }

        // MessageData struct will be used in creating the message object
        messageData msgData;
        PCCOR_SIGNATURE pSig = NULL;
        Module *pModule = NULL;
        pSig = InitMessageData(&msgData, pFrame, &pModule);

        // If the call requires object wrapping, then set up the array
        // of wrapper types.
        if (pHeader->m_Flags & MLHF_DISPCALLWITHWRAPPERS)
            WrapperTypeArr = SetUpWrapperInfo(pItfMD);

        _ASSERTE(pSig && pModule);

        // Allocate metasig on the stack
        MetaSig mSig(pSig, pModule);
        msgData.pSig = &mSig; 

        // Prepare the arguments that will be passed to the method.
        INT64 Args[] = { 
            ObjToInt64(ItfTypeObj),
            (INT64)&msgData,
            ObjToInt64(WrapperTypeArr),
            ObjToInt64(pFrame->GetThis()),
            (INT64)BindingFlags,
            ObjToInt64(MemberNameObj)
        };

        // Retrieve the array of members from the type object.
        s_pForwardCallToInvokeMemberMD->Call(Args);
        retVal = *(pFrame->GetReturnValuePtr());

        // floating point return values go in different registers.
        if (pHeader->GetManagedRetValTypeCat() == MLHF_TYPECAT_FPU)
        {
            int fpComPlusSize;
            if (pHeader->m_Flags & MLHF_64BITMANAGEDRETVAL) 
            {
                fpComPlusSize = 8;
            }
            else 
            {
                fpComPlusSize = 4;
            }
            setFPReturn(fpComPlusSize, retVal);
        }
    }
    GCPROTECT_END();
    GCPROTECT_END();
    GCPROTECT_END();

    return retVal;
}


INT64 ComEventCallWorker(Thread *pThread, ComPlusMethodFrame* pFrame, ComPlusCallMethodDesc *pMD, MLHeader *pHeader)
{
    static MethodDesc *s_pGetEventProviderMD = NULL;

    INT64 retVal;
    OBJECTREF EventProviderTypeObj = NULL;
    OBJECTREF EventProviderObj = NULL;

    LOG((LF_STUBS, LL_INFO1000, "Calling ComEventCallWorker %s::%s \n", pMD->m_pszDebugClassName, pMD->m_pszDebugMethodName));

    // Retrieve the method desc for __ComObject::GetEventProvider().
    if (!s_pGetEventProviderMD)
        s_pGetEventProviderMD = g_Mscorlib.GetMethod(METHOD__COM_OBJECT__GET_EVENT_PROVIDER);

    // Retrieve the method table and the method desc of the call.
    MethodDesc *pEvProvMD = pMD->GetEventProviderMD();
    MethodTable *pEvProvMT = pEvProvMD->GetMethodTable();

    GCPROTECT_BEGIN(EventProviderTypeObj)
    GCPROTECT_BEGIN(EventProviderObj)        
    {
        // Retrieve the exposed type object for event provider.
        EventProviderTypeObj = pEvProvMT->GetClass()->GetExposedClassObject();

        // Retrieve the event provider for the event interface type.
        INT64 GetEventProviderArgs[] = { 
            ObjToInt64(pFrame->GetThis()),
            ObjToInt64(EventProviderTypeObj)
        };
        EventProviderObj = Int64ToObj(s_pGetEventProviderMD->Call(GetEventProviderArgs));

        // Set up an arg iterator to retrieve the arguments from the frame.
        ArgIterator ArgItr(pFrame, &MetaSig(pMD->GetSig(), pMD->GetModule()));

        // Retrieve the event handler passed in.
        OBJECTREF EventHandlerObj = *((OBJECTREF*)ArgItr.GetNextArgAddr());

        // Make the call on the event provider method desc.
        INT64 EventMethArgs[] = { 
            ObjToInt64(EventProviderObj),
            ObjToInt64(EventHandlerObj)
        };
        retVal = pEvProvMD->Call(EventMethArgs);

        // The COM event call worker does not support value returned in 
        // floating point registers.
        _ASSERTE(pHeader->GetManagedRetValTypeCat() != MLHF_TYPECAT_FPU);
    }
    GCPROTECT_END();
    GCPROTECT_END();

    return retVal;
}


//---------------------------------------------------------
// INT64 __stdcall ComPlusToComWorker(Thread *pThread, 
//                                  ComPlusMethodFrame* pFrame)
//---------------------------------------------------------

static int g_ComPlusWorkerStackSize = 0;
static void *g_ComPlusWorkerReturnAddress = NULL;

// calls that propagate from COMPLUS to COM
#pragma optimize( "y", off )
/*static*/
#ifdef _SH3_
INT32 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame)
#else
INT64 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame)
#endif
{
    
    typedef INT64 (__stdcall* PFNI64)(void);
    INT64 returnValue;

    if (pThread == NULL) // Special case called during initialization
    {
        // Compute information about the worker function for the debugger to 
        // use.  Note that this information could theoretically be 
        // computed statically, except that the compiler provides no means to
        // do so.
#ifdef _X86_
        __asm
        {
            lea eax, pFrame + 4
            sub eax, esp
            mov g_ComPlusWorkerStackSize, eax

            lea eax, RETURN_FROM_CALL
            mov g_ComPlusWorkerReturnAddress, eax
        }
#elif defined(_IA64_)
        //
        // @TODO_IA64: fix this on IA64
        //

        g_ComPlusWorkerStackSize        = 0xBAAD;
        g_ComPlusWorkerReturnAddress    = (void*)0xBAAD;
#else
        _ASSERTE(!"@TODO: ALPHA - ComPlusToComWorker (ComPlusCall)");
#endif // _X86_
        return 0;   
    }

    // could throw exception 
    THROWSCOMPLUSEXCEPTION();

    // get method descriptor
    ComPlusCallMethodDesc *pMD = (ComPlusCallMethodDesc*)(pFrame->GetFunction());
    _ASSERTE(pMD->IsComPlusCall());

    // Retrieve the interface method table.
    MethodTable *pItfMT = pMD->GetInterfaceMethodTable();

    // Fet the com slot number for this method.
    unsigned cbSlot = pMD->compluscall.m_cachedComSlot; 

    // Get the MLStub for this method desc.
    MLHeader *pheader = (MLHeader*)( (*(pMD->GetAddrOfMLStubField()))->GetEntryPoint() );

    // Retrieve the managed return value type category.
    int managedRetValTypeCat = pheader->GetManagedRetValTypeCat();

    // If the interface is a COM event call, then delegate to the ComEventCallWorker.
    if (pItfMT->IsComEventItfType())
        return ComEventCallWorker(pThread, pFrame, pMD, pheader);

    // If the interface is a Dispatch only interface then convert the early bound
    // call to a late bound call.
    if (pItfMT->GetComInterfaceType() == ifDispatch)
        return ComPlusToComLateBoundWorker(pThread, pFrame, pMD, pheader);
    
    LOG((LF_STUBS, LL_INFO1000, "Calling ComPlusToComWorker %s::%s \n", pMD->m_pszDebugClassName, pMD->m_pszDebugMethodName));

    // Allocate enough memory to store both the destination buffer and
    // the locals.
    UINT   cbAlloc         = pheader->m_cbDstBuffer + pheader->m_cbLocals + sizeof(IUnknown *);
        
    BYTE *pAlloc           = (BYTE*)_alloca(cbAlloc);

    // Sanity check on stack layout computation
    _ASSERTE(pAlloc 
             + cbAlloc 
             + g_ComPlusWorkerStackSize 
             + pFrame->GetNegSpaceSize() 
             + (pFrame->GetVTablePtr() 
                == ComPlusMethodFrameGeneric::GetMethodFrameVPtr() 
                ? (sizeof(INT64) + sizeof(CleanupWorkList)) : 0)
             == (BYTE*) pFrame);

#ifdef _DEBUG    
    FillMemory(pAlloc, cbAlloc, 0xcc);
#endif

    BYTE   *pdst    = pAlloc;
    BYTE   *plocals = pdst + pheader->m_cbDstBuffer + sizeof(IUnknown *);

    // assume __stdcall
    pdst += pheader->m_cbDstBuffer + sizeof(IUnknown *);

    // clean up work list, used for allocating local data
    CleanupWorkList *pCleanup = pFrame->GetCleanupWorkList();
    _ASSERTE(pCleanup);

    // Checkpoint the current thread's fast allocator (used for temporary
    // buffers over the call) and schedule a collapse back to the checkpoint in
    // the cleanup list. Note that if we need the allocator, it is
    // guaranteed that a cleanup list has been allocated.
    void *pCheckpoint = pThread->m_MarshalAlloc.GetCheckpoint();
    pCleanup->ScheduleFastFree(pCheckpoint);
    pCleanup->IsVisibleToGc();

    // psrc and pdst are the pointers to the source and destination 
    // from/to where the arguments are marshalled

    VOID   *psrc = (VOID*)pFrame; 

    // CLR doesn't care about float point exception flags, but some legacy runtime 
    // uses the flag to see if there is any exception in float arithmetic. 
    // So we need to clear the exception flag before we call into legacy runtime.   
    __asm 
    {
        fclex
    }

    // Call the ML interpreter to translate the arguments. Assuming
    // it returns, we get back a pointer to the succeeding code stream
    // which we will save away for post-call execution.
#ifdef _X86_
    const MLCode *pMLCode = RunML(pheader->GetMLCode(),
                                  psrc,
                                  pdst,
                                  (UINT8*const)plocals,
                                  pCleanup);
#else
        _ASSERTE(!"@TODO: ALPHA - ComPlusToComWorker (ComPlusCall)");
#endif

    // get 'this'
    OBJECTREF oref = pFrame->GetThis(); 
    _ASSERTE(oref != NULL);

    // Get IUnknown pointer for this interface on this object
    IUnknown* pUnk =  ComPlusWrapper::GetComIPFromWrapperEx(oref, pMD->GetInterfaceMethodTable());
    _ASSERTE(pUnk);
    *(IUnknown **)pAlloc = pUnk; // push this pointer at the top

    // schedule this IUnk to be released unconditionally
    
    pCleanup->ScheduleUnconditionalRelease(pUnk);
    
    LogInteropScheduleRelease(pUnk, "Complus call");

#ifdef _DEBUG
    // method being called  
    LPCUTF8 name = pMD->GetName();  
    LPCUTF8 cls = pMD->GetClass()->m_szDebugClassName;
#endif

    // get target function to calls, cbSlot of the com interface vtable
    LPVOID pvFn = (LPVOID) (*(size_t**)pUnk)[cbSlot];
    INT64  nativeReturnValue;

#ifdef CUSTOMER_CHECKED_BUILD
    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_ObjNotKeptAlive))
    {
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait(1000);
    }
#endif // CUSTOMER_CHECKED_BUILD

    // enable gc
    pThread->EnablePreemptiveGC();

#ifdef PROFILING_SUPPORTED
    // If profiler active, notify of transition to unmanaged, and provide target MethodDesc
    if (CORProfilerTrackTransitions())
    {
        g_profControlBlock.pProfInterface->
            ManagedToUnmanagedTransition((FunctionID) pMD,
                                               COR_PRF_TRANSITION_CALL);
    }
#endif // PROFILING_SUPPORTED

#ifdef _DEBUG
    IUnknown* pTemp = 0;
    GUID guid;
    pMD->GetInterfaceMethodTable()->GetClass()->GetGuid(&guid, TRUE);
    HRESULT hr2 = SafeQueryInterface(pUnk, guid, &pTemp);

    LogInteropQI(pUnk, GUID_NULL, hr2, "Check QI before call");
    _ASSERTE(hr2 == S_OK);
    // ideally we will match pUnk == pTemp to verify that COM interface pointer we have
    // is correct, but ATL seems to create a new tear-off everytime we QI
    // atleast they seem to preserve the target address in the VTable,
    // so we will assert for that
    //@TODO:  removed the below assert, Enable it as soon as we support methodimpls
    /*if (pUnk != pTemp)
        _ASSERTE(((LPVOID) (*(INTPTR **)pUnk)[cbSlot] == (LPVOID) (*(INTPTR **)pTemp)[cbSlot]) && 
        "IUnknown being used is not for the correct GUID");*/
    ULONG cbRef = SafeRelease(pTemp);
    LogInteropRelease(pTemp, cbRef, "Check valid compluscall");

#endif

    // In the checked version, we compile /GZ to check for imbalanced stacks and
    // uninitialized locals.  But here we are managing the stack manually.  So
    // make the call via ASM to defeat the compiler's checking.

    // nativeReturnValue = (*pvFn)();

#if _DEBUG
    //
    // Call through debugger routines to double check their
    // implementation
    //
    pvFn = (void*) Frame::CheckExitFrameDebuggerCalls;
#endif

#ifdef _X86_
    __asm
    {
        call    [pvFn]
    }
#else
        _ASSERTE(!"@TODO: ALPHA - ComPlusToComWorker (ComPlusCall)");
#endif // _X86_

#ifdef _X86_
RETURN_FROM_CALL:
    __asm
    {
        mov     dword ptr [nativeReturnValue], eax
        mov     dword ptr [nativeReturnValue + 4], edx
    }
#else
        _ASSERTE(!"@TODO: ALPHA - ComPlusToComWorker (ComPlusCall)");
        nativeReturnValue = 0;
#endif // _X86_
    
    LPVOID pRetVal = &returnValue;

    if (pheader->GetUnmanagedRetValTypeCat() == MLHF_TYPECAT_FPU) {
        int fpNativeSize;
        if (pheader->m_Flags & MLHF_64BITUNMANAGEDRETVAL) {
            fpNativeSize = 8;
        } else {
            fpNativeSize = 4;
        }
        getFPReturn(fpNativeSize, nativeReturnValue);
    }




#ifdef PROFILING_SUPPORTED
    // If profiler active, notify of transition to unmanaged, and provide target MethodDesc
    if (CORProfilerTrackTransitions())
    {
        g_profControlBlock.pProfInterface->
            UnmanagedToManagedTransition((FunctionID) pMD,
                                               COR_PRF_TRANSITION_RETURN);
    }
#endif // PROFILING_SUPPORTED

    // disable gc
    pThread->DisablePreemptiveGC();

#ifdef CUSTOMER_CHECKED_BUILD
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_BufferOverrun))
    {
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait(1000);
    }
#endif // CUSTOMER_CHECKED_BUILD

    if ((pheader->m_Flags & MLHF_NATIVERESULT) == 0)
    {
        if (FAILED(nativeReturnValue))
        {
            GUID guid;
            pMD->GetInterfaceMethodTable()->GetClass()->GetGuid(&guid, TRUE);
            COMPlusThrowHR((HRESULT)nativeReturnValue, pUnk, 
                           guid);
        }

        // todo: put non-failure status somewhere
    }

    // Marshal the return value and propagate any [out] parameters back.
    // Assumes a little-endian architecture!
    INT64 saveReturnValue;
    if (managedRetValTypeCat == MLHF_TYPECAT_GCREF)
    {
        returnValue = 0;
        GCPROTECT_BEGIN(returnValue);
#ifdef _X86_    
        RunML(pMLCode,
            &nativeReturnValue,
            ((BYTE*)pRetVal) + ((pheader->m_Flags & MLHF_64BITMANAGEDRETVAL) ? 8 : 4),
            (UINT8*const)plocals,
            pCleanup);
#else
        _ASSERTE(!"@TODO: ALPHA - ComPlusToComWorker (ComPlusCall)");
#endif
        saveReturnValue = returnValue;
        GCPROTECT_END();
        returnValue = saveReturnValue;
    }
#ifdef _X86_
    else
    {
        RunML(pMLCode,
            &nativeReturnValue,
            ((BYTE*)pRetVal) + ((pheader->m_Flags & MLHF_64BITMANAGEDRETVAL) ? 8 : 4),
            (UINT8*const)plocals,
            pCleanup);
    }
#else // !_X86_
        _ASSERTE(!"@TODO: ALPHA - ComPlusToComWorker (ComPlusCall)");
#endif // _X86_

    if (managedRetValTypeCat == MLHF_TYPECAT_GCREF) 
    {
        GCPROTECT_BEGIN(returnValue);
        pCleanup->Cleanup(FALSE);
        saveReturnValue = returnValue;
        GCPROTECT_END();
        returnValue = saveReturnValue;
    }
    else 
    {
        pCleanup->Cleanup(FALSE);
    }

    if (managedRetValTypeCat == MLHF_TYPECAT_FPU)
    {
            int fpComPlusSize;
            if (pheader->m_Flags & MLHF_64BITMANAGEDRETVAL) {
                fpComPlusSize = 8;
            } else {
                fpComPlusSize = 4;
            }
            setFPReturn(fpComPlusSize, returnValue);
    }

    return returnValue;
}

#pragma optimize( "", on ) 



#ifdef _X86_
/*static*/ void ComPlusCall::CreateGenericComPlusStubSys(CPUSTUBLINKER *psl)
{
    _ASSERTE(sizeof(CleanupWorkList) == sizeof(LPVOID));

    // Push space for return value - sizeof(INT64)
    psl->Emit8(0x68);
    psl->Emit32(0);
    psl->Emit8(0x68);
    psl->Emit32(0);

    // push 00000000    ;; pushes a CleanupWorkList.
    psl->Emit8(0x68);
    psl->Emit32(0);

    
    psl->X86EmitPushReg(kESI);       // push esi (push new frame as ARG)
    psl->X86EmitPushReg(kEBX);       // push ebx (push current thread as ARG)

#ifdef _DEBUG
    // push IMM32 ; push ComPlusToComWorker
    psl->Emit8(0x68);
    psl->EmitPtr((LPVOID)ComPlusToComWorker);
    // in CE pop 8 bytes or args on return from call
    psl->X86EmitCall(psl->NewExternalCodeLabel(WrapCall),8);
#else

    psl->X86EmitCall(psl->NewExternalCodeLabel(ComPlusToComWorker),8);
#endif

    // Pop off cleanup worker
    psl->X86EmitAddEsp(sizeof(INT64) + sizeof(CleanupWorkList));
}
#endif


//---------------------------------------------------------
// Stub* CreateGenericStub(CPUSTUBLINKER *psl)
//---------------------------------------------------------

Stub* CreateGenericStub(CPUSTUBLINKER *psl)
{
    Stub* pCandidate = NULL;
    COMPLUS_TRY
    {
        //---------------------------------------------------------------
        // Remoting and interop share stubs. We have to handle remoting calls
        // as follows:
        // If the this pointer points to a transparent proxy method table 
        // then we have to redirect the call. We generate a check to do this.
        //-------------------------------------------------------------------
        CRemotingServices::GenerateCheckForProxy(psl);

        psl->EmitMethodStubProlog(ComPlusMethodFrameGeneric::GetMethodFrameVPtr());  

        ComPlusCall::CreateGenericComPlusStubSys(psl);
        psl->EmitSharedMethodStubEpilog(kNoTripStubStyle, ComPlusCallMethodDesc::GetOffsetOfReturnThunk());
        pCandidate = psl->Link(SystemDomain::System()->GetStubHeap());
    }
    COMPLUS_CATCH
    {
    }
    COMPLUS_END_CATCH
    return pCandidate;
}

//---------------------------------------------------------
// BOOL SetupGenericStubs()
//---------------------------------------------------------

BOOL SetupGenericStubs()
{
    if (g_pGenericComplusCallStub != NULL)
    {
        return TRUE;
    }
    StubLinker sl;
    g_pGenericComplusCallStub = CreateGenericStub((CPUSTUBLINKER*)&sl);
    if (g_pGenericComplusCallStub != NULL)
    {
        return TRUE;
    }
    return FALSE;
}


//---------------------------------------------------------
// Either creates or retrieves from the cache, a stub to
// invoke ComCall methods. Each call refcounts the returned stub.
// This routines throws a COM+ exception rather than returning
// NULL.
//---------------------------------------------------------
/*static*/ 
Stub* ComPlusCall::GetComPlusCallMethodStub(StubLinker *pstublinker, ComPlusCallMethodDesc *pMD)
{ 
    THROWSCOMPLUSEXCEPTION();

    Stub  *pTempMLStub = NULL;
    Stub  *pReturnStub = NULL;
    MethodTable *pItfMT = NULL;

    if (!SetupGenericStubs())
        return NULL;

    if (pMD->IsInterface())
    {
        pMD->compluscall.m_cachedComSlot = pMD->GetComSlot();
        pItfMT = pMD->GetMethodTable();
        pMD->compluscall.m_pInterfaceMT = pItfMT;
    }
    else
    {
        MethodDesc *pItfMD = ((MI_ComPlusCallMethodDesc *)pMD)->GetInterfaceMD();
        pMD->compluscall.m_cachedComSlot = pItfMD->GetComSlot();
        pItfMT = pItfMD->GetMethodTable();
        pMD->compluscall.m_pInterfaceMT = pItfMT;
    }

    // Determine if this is a special COM event call.
    BOOL fComEventCall = pItfMT->IsComEventItfType();

    // Determine if the call needs to do early bound to late bound convertion.
    BOOL fLateBound = !fComEventCall && pItfMT->GetComInterfaceType() == ifDispatch;

    EE_TRY_FOR_FINALLY
    {
        OBJECTREF pThrowable;

        IMDInternalImport *pInternalImport = pMD->GetMDImport();
        mdMethodDef md = pMD->GetMemberDef();

        PCCOR_SIGNATURE pSig;
        DWORD       cSig;
        pMD->GetSig(&pSig, &cSig);

        HENUMInternal hEnumParams, *phEnumParams;
        HRESULT hr = pInternalImport->EnumInit(mdtParamDef, 
                                                md, &hEnumParams);

        if (FAILED(hr))
            phEnumParams = NULL;
        else
            phEnumParams = &hEnumParams;

        ULONG ulCodeRVA;
        DWORD dwImplFlags;
        pInternalImport->GetMethodImplProps(md, &ulCodeRVA,
                                                  &dwImplFlags);

        // Determine if we need to do HRESULT munging for this method.
        BOOL fReturnsHR = !IsMiPreserveSig(dwImplFlags);

        pTempMLStub = CreateComPlusCallMLStub(pMD, pSig, phEnumParams, fReturnsHR, fLateBound, fComEventCall, pMD->GetModule(), &pThrowable);
        if (!pTempMLStub)
        {
            COMPlusThrow(pThrowable);
        }

        MLStubCache::MLStubCompilationMode mode;
        Stub *pCanonicalStub = m_pComPlusCallMLStubCache->Canonicalize( 
                                    (const BYTE *)(pTempMLStub->GetEntryPoint()),
                                    &mode);

        if (!pCanonicalStub) 
        {
            COMPlusThrowOM();
        }
        
        switch (mode) 
        {
            case MLStubCache::INTERPRETED:
                {
                    if (!pMD->InterlockedReplaceStub(pMD->GetAddrOfMLStubField(), pCanonicalStub))
                        pCanonicalStub->DecRef();
                    pMD->InitRetThunk();

                    pReturnStub = g_pGenericComplusCallStub;
                    pReturnStub->IncRef();
                }
                break;

            case MLStubCache::SHAREDPROLOG:
                pMD->InterlockedReplaceStub(pMD->GetAddrOfMLStubField(), pCanonicalStub);
                _ASSERTE(!"NYI");
                pReturnStub = NULL;
                break;

            case MLStubCache::STANDALONE:
                pReturnStub = pCanonicalStub;
                break;

            default:
                _ASSERTE(0);        
        }

        // If we are dealing with a COM event call, then we need to initialize the 
        // COM event call information.
        if (fComEventCall)
            pMD->InitComEventCallInfo();
    } 
    EE_FINALLY
    {
        if (pTempMLStub) 
            pTempMLStub->DecRef();
    } EE_END_FINALLY;

    return pReturnStub;
}


//---------------------------------------------------------
// Call at strategic times to discard unused stubs.
//---------------------------------------------------------
/*static*/ VOID ComPlusCall::FreeUnusedStubs()
{
    m_pComPlusCallMLStubCache->FreeUnusedStubs();
}


static Stub * CreateComPlusMLStubWorker(ComPlusCallMethodDesc *pMD,
                                        MLStubLinker *psl,
                                        MLStubLinker *pslPost,
                                        PCCOR_SIGNATURE szMetaSig,
                                        HENUMInternal *phEnumParams,
                                        BOOL fReturnsHR,
                                        BOOL fLateBound,
                                        BOOL fComEventCall,
                                        Module* pModule,
                                        OBJECTREF *ppException
                                        )
{
    Stub* pstub = NULL;
    LPCSTR szName;
    USHORT usSequence;
    DWORD dwAttr;
    _ASSERTE(pModule);

#ifdef _DEBUG
    LPCUTF8 pDebugName = pMD->m_pszDebugMethodName;
    LPCUTF8 pDebugClassName = pMD->m_pszDebugClassName;
#endif

    COMPLUS_TRY 
    {
        THROWSCOMPLUSEXCEPTION();
        IMDInternalImport *pInternalImport = pModule->GetMDImport();
        _ASSERTE(pInternalImport);

        //
        // Set up signature walking objects.
        //

        MetaSig msig(szMetaSig, pModule);
        MetaSig sig = msig;
        ArgIterator ai( NULL, &sig, FALSE);

        //
        // Set up the ML header.
        //

        MLHeader header;
    
        header.m_cbDstBuffer = 0;
        header.m_cbLocals    = 0;
        header.m_cbStackPop = msig.CbStackPop(FALSE); 
        header.m_Flags       = 0;

        if (msig.Is64BitReturn())
            header.m_Flags |= MLHF_64BITMANAGEDRETVAL;

        switch (msig.GetReturnTypeNormalized()) 
        {
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_CLASS:         
            case ELEMENT_TYPE_SZARRAY:
            case ELEMENT_TYPE_ARRAY:       
                header.SetManagedRetValTypeCat(MLHF_TYPECAT_GCREF);
                break;
        }

        if (!fReturnsHR)
            header.m_Flags |= MLHF_NATIVERESULT;
        
        psl->MLEmitSpace(sizeof(header));

        // If the call is for an early bound to late bound convertion, then
        // insert a ML instruction to differenciate this stub from one with
        // the same arguments but not for an early bound to late bound convertion.
        if (fLateBound)
        {
            // fComEventCall should never be set if fLateBound is set.
            _ASSERTE(!fComEventCall);
            psl->Emit8(ML_LATEBOUNDMARKER);
        }

        // If the call is for a COM event call, then insert a ML instruction to 
        // differenciate this stub.
        if (fComEventCall)
        {
            // fLateBound should never be set if fComEventCall is set.
            _ASSERTE(!fLateBound);
            psl->Emit8(ML_COMEVENTCALLMARKER);
        }

        //
        // Get a list of the COM+ argument offsets.  We
        // need this since we have to iterate the arguments
        // backwards. 
        // Note that the first argument listed may
        // be a byref for a value class return value
        //

        int numArgs = msig.NumFixedArgs();
        int returnOffset = 0;

        if (msig.HasRetBuffArg())
            returnOffset = ai.GetRetBuffArgOffset();

        int *offsets = (int*)_alloca(numArgs * sizeof(int));
        int *o = offsets;
        int *oEnd = o + numArgs;
        while (o < oEnd)
            *o++ = ai.GetNextOffset();

        //
        // Similarly, get a list of the parameter tokens. This information
        // can be sparse so not each COM+ argument is guaranteed to have a param def 
        // token associated with it. Note that the first token may be a retval param 
        // token, or the first token may correspond to the first sig argument which is 
        // the return value.
        //

        mdParamDef *params = (mdParamDef*)_alloca(numArgs * sizeof(mdParamDef));
        mdParamDef returnParam = mdParamDefNil;

        // The sequence number is 1 based so we will use a 1 based array.
        mdParamDef *p = params - 1;

        // The current param def token.
        mdParamDef CurrParam = mdParamDefNil;

        // Retrieve the index of the first COM+ argument that has parameter info 
        // associated with it.
        do 
        {
            if (phEnumParams && pInternalImport->EnumNext(phEnumParams, &CurrParam))
            {
                szName = pInternalImport->GetParamDefProps(CurrParam, &usSequence, &dwAttr);
                if (usSequence == 0)
                {
                    // The first parameter actually describes the return type.
                    returnParam = CurrParam;
                }
            }
            else
            {
                usSequence = (USHORT)-1;
            }
        }
        while (usSequence == 0);

        // Set the param def tokens for each of the COM+ arguments. If there is no param def
        // token associated with a given COM+ argument then it is set to mdParamDefNil.
        int iParams;
        for (iParams = 1; iParams <= numArgs; iParams++)
        {
            if (iParams == usSequence)
            {
                // We have found the argument to which this param is associated.
                p[iParams] = CurrParam;
                
                if (pInternalImport->EnumNext(phEnumParams, &CurrParam))
                {
                    szName = pInternalImport->GetParamDefProps(CurrParam, &usSequence, &dwAttr);
                    
                    // Validate that the param def tokens are in order.
                    _ASSERTE((usSequence > iParams) && "Param def tokens are not in order");
                }
                else
                {
                    usSequence = (USHORT)-1;
                }
            }
            else
            {
                p[iParams] = mdParamDefNil;
            }
        }
        
        // Have p point to the end of the array of param defs.
        p += iParams;
        
        // Make sure that there are not more param def tokens then there are COM+ arguments.
        _ASSERTE( usSequence == (USHORT)-1 && "There are more parameter information tokens then there are COM+ arguments" );

        //
        // Get the BestFitMapping & ThrowOnUnmappableChar info via Assembly & Interface level attributes
        //
        BOOL BestFit = TRUE;                    // Default value
        BOOL ThrowOnUnmappableChar = FALSE;     // Default value
        
        ReadBestFitCustomAttribute(pMD, &BestFit, &ThrowOnUnmappableChar);


        //
        // Now, emit the ML.
        //

        int argOffset = 0;
        int lastArgSize = 0;


        //
        // Marshal the return value.
        //

        if (msig.GetReturnType() != ELEMENT_TYPE_VOID)
        {

            MarshalInfo::MarshalType marshalType;
    
            SigPointer pSig = msig.GetReturnProps();
            MarshalInfo returnInfo(pModule, pSig, returnParam, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, FALSE, 0, BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                                   , pMD
#endif
#ifdef _DEBUG
                                   , pDebugName, pDebugClassName, NULL, 0
#endif
                                   );

            marshalType = returnInfo.GetMarshalType();


            if (marshalType == MarshalInfo::MARSHAL_TYPE_VALUECLASS ||
                marshalType == MarshalInfo::MARSHAL_TYPE_BLITTABLEVALUECLASS ||
                marshalType == MarshalInfo::MARSHAL_TYPE_GUID ||
                marshalType == MarshalInfo::MARSHAL_TYPE_DECIMAL
               ) {
                MethodTable *pMT = msig.GetRetTypeHandle().AsMethodTable();
                UINT         managedSize = msig.GetRetTypeHandle().GetSize();

                if (!fReturnsHR && !fLateBound)
                {
                    COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                }
                _ASSERTE(IsManagedValueTypeReturnedByRef(managedSize));
                
                if (argOffset != ai.GetRetBuffArgOffset())
                {
                    psl->Emit8(ML_BUMPSRC);
                    psl->Emit16((INT16)(ai.GetRetBuffArgOffset()));
                    argOffset = ai.GetRetBuffArgOffset();
                }
                psl->MLEmit(ML_STRUCTRETC2N);
                psl->EmitPtr(pMT);
                pslPost->MLEmit(ML_STRUCTRETC2N_POST);
                pslPost->Emit16(psl->MLNewLocal(sizeof(ML_STRUCTRETC2N_SR)));

                lastArgSize = StackElemSize(sizeof(LPVOID));
                if (!SafeAddUINT16(&header.m_cbDstBuffer, lastArgSize))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }
            }
            //else if (msig.HasRetBuffArg() && !fReturnsHR)
            //{
            //    COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
            //}
            else
            {
                if (argOffset != returnOffset)
                {
                    psl->Emit8(ML_BUMPSRC);
                    psl->Emit16((INT16)returnOffset);
                    argOffset = returnOffset;
                }
                
                returnInfo.GenerateReturnML(psl, pslPost, 
                    TRUE, fReturnsHR);
                if (!SafeAddUINT16(&header.m_cbDstBuffer, returnInfo.GetNativeArgSize()))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }
                if (returnInfo.IsFpu())
                {
                    // Ugh - should set this more uniformly or rename the flag.
                    if (returnInfo.GetMarshalType() == MarshalInfo::MARSHAL_TYPE_DOUBLE && !fReturnsHR)
                    {
                        header.m_Flags |= MLHF_64BITUNMANAGEDRETVAL;
                    }
                    header.SetManagedRetValTypeCat(MLHF_TYPECAT_FPU);
                    if (!fReturnsHR)
                    {
                        header.SetUnmanagedRetValTypeCat(MLHF_TYPECAT_FPU);
                    }
                }
                
                lastArgSize = returnInfo.GetComArgSize();
            }
        }

        msig.GotoEnd();

        //
        // Marshal the arguments
        //

        // Check to see if we need to do LCID conversion.
        int iLCIDArg = GetLCIDParameterIndex(pInternalImport, pMD->GetMemberDef());
        if (iLCIDArg != (UINT)-1 && iLCIDArg > numArgs)
            COMPlusThrow(kIndexOutOfRangeException, IDS_EE_INVALIDLCIDPARAM);

        int argidx = msig.NumFixedArgs();
        while (o > offsets)
        {
            --o;
            --p;

            // Check to see if this is the parameter after which we need to insert the LCID.
            if (argidx == iLCIDArg)
            {
                psl->MLEmit(ML_LCID_C2N);
                if (!SafeAddUINT16(&header.m_cbDstBuffer, sizeof(LCID)))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }

            }

            //
            // Adjust src pointer if necessary (for register params or
            // for return value order differences)
            //

            int fixup = *o - (argOffset + lastArgSize);
            argOffset = *o;

            if (!FitsInI2(fixup))
            {
                COMPlusThrow(kTypeLoadException, IDS_EE_SIGTOOCOMPLEX);
            }
            if (fixup != 0) 
            {
                psl->Emit8(ML_BUMPSRC);
                psl->Emit16((INT16)fixup);
            }

            msig.PrevArg();

            MarshalInfo info(pModule, msig.GetArgProps(), *p, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, TRUE, argidx,
                            BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                             ,pMD
#endif
#ifdef _DEBUG
                             , pDebugName, pDebugClassName, NULL, argidx
#endif
                             );
            info.GenerateArgumentML(psl, pslPost, TRUE);
            if (!SafeAddUINT16(&header.m_cbDstBuffer, info.GetNativeArgSize()))
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
            }

            if (fLateBound && info.GetDispWrapperType() != 0)
                header.m_Flags |= MLHF_DISPCALLWITHWRAPPERS;
            
            lastArgSize = info.GetComArgSize();
            argidx--;
        }
        
        // Check to see if this is the parameter after which we need to insert the LCID.
        if (argidx == iLCIDArg)
        {
            psl->MLEmit(ML_LCID_C2N);
            if (!SafeAddUINT16(&header.m_cbDstBuffer, sizeof(LCID)))
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
            }
        }
        
        // This marker separates the pre from the post work.
        psl->MLEmit(ML_INTERRUPT);
        
        // First emit code to do any backpropagation/cleanup work (this
        // was generated into a separate stublinker during the argument phase.)
        // Then emit the code to do the return value marshaling.
        
        pslPost->MLEmit(ML_END);
        Stub *pStubPost = pslPost->Link();
        COMPLUS_TRY 
        {
            if (fReturnsHR)
            {
                // check HR
                psl->MLEmit(ML_THROWIFHRFAILED);
            }
            psl->EmitBytes(pStubPost->GetEntryPoint(), 
                           MLStreamLength((const UINT8 *)(pStubPost->GetEntryPoint())) - 1);
        } 
        COMPLUS_CATCH 
        {
            pStubPost->DecRef();
            COMPlusThrow(GETTHROWABLE());
        }
        COMPLUS_END_CATCH
        pStubPost->DecRef();

        psl->MLEmit(ML_END);

        pstub = psl->Link();

        header.m_cbLocals = psl->GetLocalSize();

        *((MLHeader *)(pstub->GetEntryPoint())) = header;

#ifdef _DEBUG
        {
            MLHeader *pheader = (MLHeader*)(pstub->GetEntryPoint());
            UINT16 locals = 0;
            MLCode opcode;
            const MLCode *pMLCode = pheader->GetMLCode();


            VOID DisassembleMLStream(const MLCode *pMLCode);
            //DisassembleMLStream(pMLCode);


            while (ML_INTERRUPT != (opcode = *(pMLCode++))) {
                locals += gMLInfo[opcode].m_cbLocal;
                pMLCode += gMLInfo[opcode].m_numOperandBytes;
            }
            _ASSERTE(locals == pheader->m_cbLocals);
        }
#endif //_DEBUG



    } 
    COMPLUS_CATCH 
    {
        *ppException = GETTHROWABLE();
        return NULL;
    }
    COMPLUS_END_CATCH

    return pstub; // CHANGE, VC6.0
}


//---------------------------------------------------------
// Creates a new stub for a ComPlusCall call. Return refcount is 1.
// If failed, returns NULL and sets *ppException to an exception
// object.
//---------------------------------------------------------
static Stub * CreateComPlusCallMLStub(
                                      ComPlusCallMethodDesc *pMD,
                                      PCCOR_SIGNATURE szMetaSig,
                                      HENUMInternal *phEnumParams,
                                      BOOL fReturnsHR,
                                      BOOL fLateBound,
                                      BOOL fComEventCall,
                                      Module* pModule,
                                      OBJECTREF *ppException
                                      )
{
    MLStubLinker sl;
    MLStubLinker slPost;
    return CreateComPlusMLStubWorker(pMD, &sl, &slPost, szMetaSig, phEnumParams, 
                                     fReturnsHR, fLateBound, fComEventCall, pModule, ppException);
};




//---------------------------------------------------------
// Debugger support for ComPlusMethodFrame
//---------------------------------------------------------

void *ComPlusCall::GetFrameCallIP(FramedMethodFrame *frame)
{
    ComPlusCallMethodDesc *pCMD = (ComPlusCallMethodDesc *)frame->GetFunction();
    MethodTable *pItfMT = pCMD->GetInterfaceMethodTable();
    void *ip = NULL;
    IUnknown *pUnk = NULL;

    _ASSERTE(pCMD->IsComPlusCall());

    // Note: if this is a COM event call, then the call will be delegated to a different object. The logic below will
    // fail with an invalid cast error. For V1, we just won't step into those.
    if (pItfMT->IsComEventItfType())
        return NULL;
    
    //
    // This is called from some strange places - from
    // unmanaged code, from managed code, from the debugger
    // helper thread.  Make sure we can deal with this object
    // ref.
    //

    Thread *thread = GetThread();
    if (thread == NULL)
    {
        //
        // This is being called from the debug helper thread.  
        // Unfortunately this doesn't bode well for the COM+ IP
        // mapping code - it expects to be called from the appropriate
        // context.
        //
        // This context-naive code will work for most cases.
        //
        // It toggles the GC mode, tries to setup a thread, etc, right after our
        // verification that we have no Thread object above. This needs to be fixed properly in Beta 2. This is a work
        // around for Beta 1, which is just to #if 0 the code out and return NULL.
        //
#if 0
        COMOBJECTREF oref = (COMOBJECTREF) frame->GetThis();

        ComPlusWrapper *pWrap = oref->GetWrapper();
        pUnk = pWrap->GetIUnknown();
        GUID guid;
        pItfMT->GetClass()->GetGuid(&guid, TRUE);
        HRESULT hr = SafeQueryInterface(pUnk , guid,  &pUnk);
        LogInteropQI(pUnk, GUID_NULL, hr, " GetFrameCallIP");

        if (FAILED(hr))
#endif            
        pUnk = NULL;
    }
    else
    {
        bool disable = !thread->PreemptiveGCDisabled();

        if (disable)
            thread->DisablePreemptiveGC();

        OBJECTREF oref = frame->GetThis();

        pUnk = ComPlusWrapper::GetComIPFromWrapperEx(oref, pItfMT);

        if (disable)
            thread->EnablePreemptiveGC();
    }

    if (pUnk != NULL)
    {
        if (pItfMT->GetComInterfaceType() == ifDispatch)
        {
            ip = (*(void ***)pUnk)[DISPATCH_INVOKE_SLOT];
        }
        else
        {
            ip = (*(void ***)pUnk)[pCMD->compluscall.m_cachedComSlot];
        }

        ULONG cbRef = SafeRelease(pUnk);
        LogInteropRelease(pUnk, cbRef, "GetFrameCallIP");       
    }

    return ip;
}



void ComPlusMethodFrameGeneric::GetUnmanagedCallSite(void **ip,
                                              void **returnIP,
                                              void **returnSP)
{
    LOG((LF_CORDB, LL_INFO100000, "ComPlusMethodFrameGeneric::GetUnmanagedCallSite\n"));
    
    MethodDesc *pMD = GetFunction();
    _ASSERTE(pMD->IsComPlusCall());
    ComPlusCallMethodDesc *pCMD = (ComPlusCallMethodDesc *)pMD;

    if (ip != NULL)
        *ip = ComPlusCall::GetFrameCallIP(this);

    if (returnIP != NULL)
        *returnIP = g_ComPlusWorkerReturnAddress;

    if (returnSP != NULL)
    {
        MLHeader *pheader = (MLHeader*)
          (*(pCMD->GetAddrOfMLStubField()))->GetEntryPoint();

        LOG((LF_CORDB, LL_INFO100000, "CPMFG::GUCS: this=0x%x, %d (%d), %d, %d, %d, %d, %d, %d\n",
             this, GetNegSpaceSize(), ComPlusMethodFrame::GetNegSpaceSize(), g_ComPlusWorkerStackSize,
             pheader->m_cbLocals, pheader->m_cbDstBuffer,
             sizeof(IUnknown*), sizeof(INT64), sizeof(CleanupWorkList)));
        
        *returnSP = (void*) (((BYTE*) this) 
                             - GetNegSpaceSize() 
                             - g_ComPlusWorkerStackSize
                             - pheader->m_cbLocals
                             - pheader->m_cbDstBuffer
                             - sizeof(IUnknown *)
                             - sizeof(INT64)
                             - sizeof(CleanupWorkList));
    }
}




BOOL ComPlusMethodFrame::TraceFrame(Thread *thread, BOOL fromPatch,
                                    TraceDestination *trace, REGDISPLAY *regs)
{
    //
    // Get the call site info
    //

    void *ip, *returnIP, *returnSP;
    GetUnmanagedCallSite(&ip, &returnIP, &returnSP);

    //
    // If we've already made the call, we can't trace any more.
    //
    // !!! Note that this test isn't exact.
    //

    if (!fromPatch 
        && (thread->GetFrame() != this
            || !thread->m_fPreemptiveGCDisabled
            || *(void**)returnSP == returnIP))
        return FALSE;

    //
    // Otherwise, return the unmanaged destination.
    //

    trace->type = TRACE_UNMANAGED;
    trace->address = (const BYTE *) ip;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comprincipal.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
//   File:          COMPrincipal.h
//
//   Author:        Gregory Fee 
//
//   Purpose:       unmanaged code for managed classes in the System.Security.Principal namespace
//
//   Date created : February 3, 2000
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMPrincipal_H_
#define _COMPrincipal_H_

#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <stierr.h>
#include <ntsecapi.h>

typedef NTSTATUS (*LSALOGONUSER)( HANDLE, PLSA_STRING, SECURITY_LOGON_TYPE, ULONG, PVOID, ULONG, PTOKEN_GROUPS, PTOKEN_SOURCE, PVOID*, PULONG, PLUID, PHANDLE, PQUOTA_LIMITS, PNTSTATUS );
typedef NTSTATUS (*LSALOOKUPAUTHENTICATIONPACKAGE)( HANDLE, PLSA_STRING, PULONG );
typedef NTSTATUS (*LSACONNECTUNTRUSTED)( PHANDLE );
typedef NTSTATUS (*LSAREGISTERLOGONPROCESS)( PLSA_STRING, PHANDLE, PLSA_OPERATIONAL_MODE );

enum WindowsAccountType
{
    Normal = 0,
    Guest = 1,
    System = 2,
    Anonymous = 3
};


class COMPrincipal
{
private:
    static HMODULE s_secur32Module;
	static LSALOGONUSER s_LsaLogonUser;
	static LSALOOKUPAUTHENTICATIONPACKAGE s_LsaLookupAuthenticationPackage;
	static LSACONNECTUNTRUSTED s_LsaConnectUntrusted;
	static LSAREGISTERLOGONPROCESS s_LsaRegisterLogonProcess;

	static BOOL LoadSecur32Module();

public:

	static void Shutdown();

	typedef struct {
	    DECLARE_ECALL_OBJECTREF_ARG(LPVOID, userToken );
	} _Token;
	
	typedef struct {
	} _NoArgs;
	
    typedef struct {
	    DECLARE_ECALL_I4_ARG( DWORD, rid );
    } _GetRole;

	static LPVOID __stdcall ResolveIdentity( _Token* );	

	static LPVOID __stdcall GetRoles( _Token* );

	static LPVOID __stdcall GetCurrentToken( _NoArgs* );

	static LPVOID __stdcall SetThreadToken( _Token* );
    
    static LPVOID __stdcall ImpersonateLoggedOnUser( _Token* args );

	static LPVOID __stdcall RevertToSelf( _NoArgs* );

    static FCDECL2(HANDLE, DuplicateHandle, LPVOID pToken, bool bClose);
    static FCDECL1(void, CloseHandle, LPVOID pToken);
    static FCDECL1(WindowsAccountType, GetAccountType, LPVOID pToken);

    static LPVOID __stdcall GetRole( _GetRole* );

    static FCDECL1(HANDLE, S4ULogon, StringObject* pUPN);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comprincipal.cpp ===
//depot/URT/main/CLR/build/VM/COMPrincipal.cpp#18 - integrate change 162973 (text)
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
//   File:      COMPrincipal.cpp
//
//   Author:        Gregory Fee 
//
//   Purpose:       unmanaged code for managed classes in the System.Security.Principal namespace
//
//   Date created : February 3, 2000
//
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "excep.h"
#include "CorPerm.h"
#include "CorPermE.h"
#include "COMStringCommon.h"    // RETURN() macro
#include "COMString.h"
#include "COMPrincipal.h"
#include "winwrap.h"
#include "aclapi.h"
#include "lm.h"
#include "security.h"

// Statics
HMODULE COMPrincipal::s_secur32Module = NULL;
LSALOGONUSER COMPrincipal::s_LsaLogonUser = NULL;
LSALOOKUPAUTHENTICATIONPACKAGE COMPrincipal::s_LsaLookupAuthenticationPackage = NULL;
LSACONNECTUNTRUSTED COMPrincipal::s_LsaConnectUntrusted = NULL;
LSAREGISTERLOGONPROCESS COMPrincipal::s_LsaRegisterLogonProcess = NULL;

/* Good for test purposes; leave in for now
static SID* GetSid( WCHAR* username )
{
    BYTE* buffer = new BYTE[2048];
    WCHAR domain[2048];
    DWORD bufferSize = 2048;
    DWORD domainSize = 2048;
    SID_NAME_USE sidNameUse;

    if (!LookupAccountNameW( NULL, username, (SID*)buffer, &bufferSize, domain, &domainSize, &sidNameUse ))
        return NULL;
    else
        return (SID*)buffer;
}
*/

void COMPrincipal::Shutdown()
{
	if(s_secur32Module)
	{
		FreeLibrary( s_secur32Module );
		s_secur32Module = NULL;		
		s_LsaLogonUser = NULL;
		s_LsaLookupAuthenticationPackage = NULL;
		s_LsaConnectUntrusted = NULL;
		s_LsaRegisterLogonProcess = NULL;
	}
}

LPVOID COMPrincipal::ResolveIdentity( _Token* args )
{
#ifdef PLATFORM_CE
    RETURN( 0, STRINGREF );
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();

    BYTE          bufStatic [2048];
    DWORD         dwSize          = sizeof(bufStatic);
    LPVOID        pUser           = bufStatic;
    DWORD         dwReq           = 0;
    HRESULT       hr              = S_OK;
    SID_NAME_USE  nameUse;
    DWORD         dwManagedSize   = 0;
    WCHAR         szName   [256];
    WCHAR         szDomain [256];
    DWORD         dwName          = sizeof( szName ) / sizeof( WCHAR );
    DWORD         dwDomain        = sizeof( szDomain ) / sizeof( WCHAR );
    WCHAR*        pszName = szName;
    WCHAR*        pszDomain = szDomain;
    DWORD         dwRequire       = 0;
    STRINGREF     retval          = NULL;
    BOOL          timeout         = FALSE;
    int iDomain;
    int iName;
    int iReq;

    // We are passed a token and we need the SID (allocating bigger buffers if need be)

    if (!GetTokenInformation(HANDLE(args->userToken), TokenUser, pUser, dwSize, &dwRequire))
    {
        if (dwRequire > dwSize)
        {
            pUser = (LPVOID)new char[dwRequire];

            if (pUser == NULL)
                goto CLEANUP;

            if (!GetTokenInformation(HANDLE(args->userToken), TokenUser, pUser, dwRequire, &dwRequire))
                goto CLEANUP;
        }
        else 
        {
            goto CLEANUP;
        }
    }

    // Lookup the account name and domain (allocating bigger buffers if need be)

    BEGIN_ENSURE_PREEMPTIVE_GC();
    
    if (!WszLookupAccountSid( NULL, ((TOKEN_USER *)pUser)->User.Sid, pszName, &dwName, pszDomain, &dwDomain,  &nameUse ))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            if (dwName > 256)
            {
                pszName = new WCHAR[dwName];
            }
        
            if (dwDomain > 256)
            {
                pszDomain = new WCHAR[dwDomain];
            }
        
            if (!WszLookupAccountSid( NULL, ((TOKEN_USER *)pUser)->User.Sid, pszName, &dwName, pszDomain, &dwDomain,  &nameUse ))
            {
                timeout = TRUE;                
            }
        }
        else
        {
            timeout = TRUE;
        }
    }

    END_ENSURE_PREEMPTIVE_GC();

    if(timeout==FALSE)
    {
        // Fiqure out the size of the managed string we need to create, create it, and fill it
        // in the form <domain>\<name> (e.g. REDMOND\gregfee).

        iDomain = (int)wcslen(pszDomain);
        iName   = (int)wcslen(pszName);
        iReq    = iDomain + iName + ((iDomain > 0) ? 1 : 0);

        retval = COMString::NewString( iReq );

        if (iDomain > 0)
        {
            wcscpy( retval->GetBuffer(), pszDomain );
            wcscat( retval->GetBuffer(), L"\\" );
            wcscat( retval->GetBuffer(), pszName );
        }
        else
        {
            wcscpy( retval->GetBuffer(), pszName );
        }
    }

 CLEANUP:
    if (pUser != NULL && pUser != bufStatic)
        delete [] pUser;

    if (pszName != NULL && pszName != szName)
        delete [] pszName;

    if (pszDomain != NULL && pszDomain != szDomain)
        delete [] pszDomain;

    if (timeout)
        COMPlusThrowWin32(); 

    RETURN( retval, STRINGREF );
#endif // !PLATFORM_CE
}


static PTRARRAYREF GetRoles( HANDLE tokenHandle )
{
#ifdef PLATFORM_CE
    return NULL;
#else // !PLATFORM_CE
    BYTE           bufStatic [2048];
    LPVOID         buf             = bufStatic;
    DWORD          dwSize          = sizeof(bufStatic);
    DWORD          dwRequire       = 0;
    TOKEN_GROUPS * pGroups         = NULL;
    int            iFillPos        = 0;
    BOOL           fOverflow       = FALSE;
    DWORD          iter            = 0;
    HRESULT        hr              = S_OK;
    PTRARRAYREF    ResultArray     = NULL;
    STRINGREF      newString;
    WCHAR          szName [256], szDomain [256];
    WCHAR*         pszName = szName;
    WCHAR*         pszDomain = szDomain;
    DWORD          dwName = 256, dwDomain = 256;

    struct _gc
    {
        PTRARRAYREF array;
        _gc() : array((PTRARRAYREF) (size_t)NULL ) {};
    } gc;


    // We are passed a token but we want the TOKEN_GROUPS (allocate larger buffer as necessary)

    BOOL bGotoCleanup = FALSE;
    if (!GetTokenInformation( tokenHandle, TokenGroups, buf, dwSize, &dwRequire))
    {
        if (dwRequire > dwSize)
        {
            buf = (LPVOID)new char[dwRequire];

            if (buf == NULL)
                bGotoCleanup = TRUE;
            else if (!GetTokenInformation( tokenHandle, TokenGroups, buf, dwRequire, &dwRequire))
                bGotoCleanup = TRUE;
        }
        else 
        {
            bGotoCleanup = TRUE;
        }
    }


    if(bGotoCleanup==FALSE)
    {
        //
        // Allocate the array of STRINGREFs.  We don't need to check for null because the GC will throw 
        // an OutOfMemoryException if there's not enough memory.
        //

        pGroups = (TOKEN_GROUPS *) buf;
        
        ResultArray = (PTRARRAYREF)AllocateObjectArray(pGroups->GroupCount, g_pStringClass);

        // Setup the GC protection

        gc.array = ResultArray;

        GCPROTECT_BEGIN( gc );        
        // Iterate through the groups, grab their domain\name info, and construct a managed string for each placing it in an array.
        
        for(iter=0; iter<pGroups->GroupCount; iter++)
        {
            DWORD         dwNameCopy = dwName;
            DWORD         dwDomainCopy = dwDomain;
            SID_NAME_USE  nameUse;

            szName[0] = szDomain[0] = NULL;

            if ((pGroups->Groups[iter].Attributes & SE_GROUP_ENABLED) == 0)
                continue;

            BOOL bLookupFailed = FALSE;           

            BEGIN_ENSURE_PREEMPTIVE_GC();        
            
            if (!WszLookupAccountSid(NULL, pGroups->Groups[iter].Sid, pszName, &dwNameCopy, pszDomain, &dwDomainCopy,  &nameUse ))
            {
                DWORD error = GetLastError();

                if (error == ERROR_INSUFFICIENT_BUFFER)
                {
                    if (dwNameCopy > dwName)
                    {
                        pszName = new WCHAR[dwNameCopy];
                        dwName = dwNameCopy;
                    }
            
                    if (dwDomainCopy > dwDomain)
                    {
                        pszDomain = new WCHAR[dwDomainCopy];
                        dwDomain = dwDomainCopy;
                    }
            
                    if (!WszLookupAccountSid( NULL, pGroups->Groups[iter].Sid, pszName, &dwNameCopy, pszDomain, &dwDomainCopy,  &nameUse ))
                    {
                        bLookupFailed = TRUE;
                    }
                }
                else
                {
                    bLookupFailed = TRUE;
                }
            }

            END_ENSURE_PREEMPTIVE_GC();                
            
            if( !bLookupFailed )
            {
                int iDomain = (int)wcslen(pszDomain);
                int iName   = (int)wcslen(pszName);
                int iReq    = iDomain + iName + ((iDomain > 0) ? 1 : 0);
         
                newString = COMString::NewString( iReq );

                if (iDomain > 0)
                {
                    wcscpy( newString->GetBuffer(), pszDomain );
                    wcscat( newString->GetBuffer(), L"\\" );
                    wcscat( newString->GetBuffer(), pszName );
                }
                else
                {
                    wcscpy( newString->GetBuffer(), pszName );
                }

                gc.array->SetAt(iter, (OBJECTREF)newString);
            }
        }        
        
        ResultArray = gc.array;        
        GCPROTECT_END();
    }
    
// CLEANUP:
    if (buf != NULL && buf != bufStatic)
        delete [] buf;

    if (pszName != NULL && pszName != szName)
        delete [] pszName;

    if (pszDomain != NULL && pszDomain != szDomain)
        delete [] pszDomain;

    return ResultArray;
#endif // !PLATFORM_CE
}    

LPVOID COMPrincipal::GetRoles( _Token* args )
{
    if (args->userToken == 0)
    {
        RETURN( 0, PTRARRAYREF );
    }
    else
    {
        RETURN( ::GetRoles( (HANDLE)args->userToken ),  PTRARRAYREF );
    }
}




LPVOID COMPrincipal::GetRole( _GetRole* args )
{
    PSID pSid = NULL;
    DWORD dwName = 0;
    DWORD dwDomain = 0;
    WCHAR* pszName = NULL;
    WCHAR* pszDomain = NULL;
    SID_NAME_USE  nameUse;
    STRINGREF newString = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid( &SIDAuthNT, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     args->rid,
                     0, 0, 0, 0, 0, 0,
                     &pSid))
    {
        goto Cleanup;
    }

    BOOL bCleanup = FALSE;
    
    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!WszLookupAccountSid(NULL, pSid, pszName, &dwName, pszDomain, &dwDomain,  &nameUse ))
    {
        DWORD error = GetLastError();

        if (error == ERROR_INSUFFICIENT_BUFFER)
        {
            pszName = new WCHAR[dwName];
            pszDomain = new WCHAR[dwDomain];
    
            if (!WszLookupAccountSid( NULL, pSid, pszName, &dwName, pszDomain, &dwDomain,  &nameUse ))
            {
                bCleanup = TRUE;
            }
        }
        else
        {
            bCleanup =TRUE;
        }
    }

    END_ENSURE_PREEMPTIVE_GC();

    if(!bCleanup)
    {
        int iDomain = (int)wcslen(pszDomain);
        int iName   = (int)wcslen(pszName);
        int iReq    = iDomain + iName + ((iDomain > 0) ? 1 : 0);

        newString = COMString::NewString( iReq );

        if (iDomain > 0)
        {
            wcscpy( newString->GetBuffer(), pszDomain );
            wcscat( newString->GetBuffer(), L"\\" );
            wcscat( newString->GetBuffer(), pszName );
        }
        else
        {
            wcscpy( newString->GetBuffer(), pszName );
        }
    }

Cleanup:
    if (pSid)
        FreeSid( pSid );
    
    delete [] pszDomain;
    delete [] pszName;

    RETURN( newString, STRINGREF );
}

LPVOID COMPrincipal::GetCurrentToken( _NoArgs* args )
{
#ifdef PLATFORM_CE
    return 0;
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();

    HANDLE   hToken = NULL;
    OSVERSIONINFO osvi;
	BOOL bWin9X = FALSE;
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!WszGetVersionEx(&osvi)) {
        _ASSERTE(!"GetVersionEx failed");
        COMPlusThrowWin32();			
    }
    
    bWin9X = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
    // Fail silently under Win9X
    if (bWin9X) 
        return 0;

    if (OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hToken)) {
        return hToken;
    }
    else {
        // Try the thread security context
        if (OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &hToken)) {
            return hToken;
        }

        if (OpenProcessToken( GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
            return hToken;
        }
        else {
            // Throw an exception with the Win32 error message
            COMPlusThrowWin32();
            return 0;
        }
    }
#endif // !PLATFORM_CE
}


LPVOID COMPrincipal::SetThreadToken( _Token* args )
{
    // We need to guarantee that we've already loaded the user policy for this process
    // before we allow an impersonation.

    Security::InitData();

#ifdef PLATFORM_CE
    RETURN( FALSE, BOOL );
#else // !PLATFORM_CE
    RETURN( ::SetThreadToken( NULL, (HANDLE)args->userToken ), BOOL );
#endif // !PLATFORM_CE
}

LPVOID COMPrincipal::ImpersonateLoggedOnUser( _Token* args )
{
    // We need to guarantee that we've already loaded the user policy for this process
    // before we allow an impersonation.

    Security::InitData();

#ifdef PLATFORM_CE
    RETURN( FALSE, BOOL );
#else // !PLATFORM_CE
#ifdef _DEBUG
	DWORD im = ::ImpersonateLoggedOnUser( (HANDLE)args->userToken );
	DWORD er = GetLastError();
    RETURN( im, BOOL );
#else
    RETURN( ::ImpersonateLoggedOnUser( (HANDLE)args->userToken ), BOOL );
#endif // _DEBUG
#endif // !PLATFORM_CE
}

LPVOID COMPrincipal::RevertToSelf( _NoArgs* args )
{
#ifdef PLATFORM_CE
    RETURN( FALSE, BOOL );
#else // !PLATFORM_CE
    RETURN( ::RevertToSelf(), BOOL );
#endif // !PLATFORM_CE
}

FCIMPL2(HANDLE, COMPrincipal::DuplicateHandle, LPVOID pToken, bool bClose) {
    FC_GC_POLL_RET();

    HANDLE newHandle;
    DWORD dwFlags = DUPLICATE_SAME_ACCESS;
    if (bClose)
        dwFlags |= DUPLICATE_CLOSE_SOURCE;
    if (!::DuplicateHandle( GetCurrentProcess(),
                            (HANDLE)pToken,
                            GetCurrentProcess(),
                            &newHandle,
                            0,
                            TRUE,
                            dwFlags ))
    {
        return 0;
    }
    else
    {
        return newHandle;
    }
}
FCIMPLEND


FCIMPL1(void, COMPrincipal::CloseHandle, LPVOID pToken) {
    ::CloseHandle( (HANDLE)pToken );
}
FCIMPLEND

FCIMPL1(WindowsAccountType, COMPrincipal::GetAccountType, LPVOID pToken) {
    BYTE          bufStatic [2048];
    DWORD         dwSize          = sizeof(bufStatic);
    DWORD         dwRequire;
    LPVOID        pUser           = bufStatic;
    PSID pSystemSid = NULL;
    PSID pAnonymousSid = NULL;
    PSID pGuestSid = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    WindowsAccountType retval = Normal;

    // We are passed a token and we need the SID (allocating bigger buffers if need be).

    if (GetTokenInformation(HANDLE(pToken), TokenUser, pUser, dwSize, &dwRequire) == FALSE)
    {
        if (dwRequire > dwSize)
        {
            pUser = (LPVOID)new char[dwRequire];

            if (pUser == NULL)
                goto Cleanup;

            if (GetTokenInformation(HANDLE(pToken), TokenUser, pUser, dwRequire, &dwRequire) != S_OK)
                goto Cleanup;
        }
        else 
        {
            goto Cleanup;
        }
    }

    // Grab the built-in SID for System and compare it to
    // the SID from our token

    if (!AllocateAndInitializeSid( &SIDAuthNT, 1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pSystemSid))
    {
        goto Cleanup;
    }

    if (EqualSid( pSystemSid, ((TOKEN_USER*)pUser)->User.Sid))
    {
        retval = System;
        goto Cleanup;
    }

    if (!AllocateAndInitializeSid( &SIDAuthNT, 1,
                     SECURITY_ANONYMOUS_LOGON_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pAnonymousSid))
    {
        goto Cleanup;
    }

    if (EqualSid( pAnonymousSid, ((TOKEN_USER*)pUser)->User.Sid))
    {
        retval = Anonymous;
        goto Cleanup;
    }

    if (!AllocateAndInitializeSid( &SIDAuthNT, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_USER_RID_GUEST,
                     0, 0, 0, 0, 0, 0,
                     &pGuestSid))
    {
        goto Cleanup;
    }

    if (EqualSid( pGuestSid, ((TOKEN_USER*)pUser)->User.Sid))
    {
        retval = Guest;
        goto Cleanup;
    }

Cleanup:
    if (pSystemSid)
        FreeSid( pSystemSid );
    if (pAnonymousSid)
        FreeSid( pAnonymousSid );
    if (pGuestSid)
        FreeSid( pGuestSid );
    
    if (pUser != bufStatic)
        delete [] pUser;

    return retval;
}
FCIMPLEND

#define SZ_BYTE_COUNT(x) (USHORT)((strlen(x) + 1) * sizeof(CHAR))
#define SZ_SOURCENAME "CLR"

BOOL COMPrincipal::LoadSecur32Module()
{
    if(s_secur32Module &&
       s_LsaLogonUser &&
       s_LsaLookupAuthenticationPackage &&
       s_LsaConnectUntrusted &&
       s_LsaRegisterLogonProcess)
		return TRUE;

    THROWSCOMPLUSEXCEPTION();

	s_secur32Module = WszLoadLibrary( L"secur32.dll" );
	if (!s_secur32Module)
		return FALSE;

	s_LsaLogonUser = (LSALOGONUSER)GetProcAddress( s_secur32Module, "LsaLogonUser" );
	if (!s_LsaLogonUser)
		return FALSE;

	s_LsaLookupAuthenticationPackage = (LSALOOKUPAUTHENTICATIONPACKAGE)GetProcAddress( s_secur32Module, "LsaLookupAuthenticationPackage" );
	if (!s_LsaLookupAuthenticationPackage)
		return FALSE;

	s_LsaConnectUntrusted = (LSACONNECTUNTRUSTED)GetProcAddress( s_secur32Module, "LsaConnectUntrusted" );
	if (!s_LsaConnectUntrusted)
		return FALSE;

	s_LsaRegisterLogonProcess = (LSAREGISTERLOGONPROCESS)GetProcAddress( s_secur32Module, "LsaRegisterLogonProcess" );
	if (!s_LsaRegisterLogonProcess)
		return FALSE;

    return TRUE;
}

// This is used by S4ULogon
bool S4UAdjustPriv()
{
	TOKEN_PRIVILEGES tp;
	HANDLE hToken = NULL;
	LUID luid;

	if ( !WszLookupPrivilegeValue( 
			NULL,            // lookup privilege on local system
			SE_TCB_NAME,     // privilege to lookup 
			&luid ) )        // receives LUID of privilege
    {
		return FALSE; 
	}

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken))
	{
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	
	// Enable the privilege or disable all privileges.
	AdjustTokenPrivileges(
		hToken, 
		FALSE, 
		&tp, 
		sizeof(TOKEN_PRIVILEGES), 
		(PTOKEN_PRIVILEGES) NULL, 
		(PDWORD) NULL
		); 	 
	
	CloseHandle(hToken);

	if (GetLastError() != ERROR_SUCCESS)
        return FALSE;

	return TRUE;
}

// This takes a UPN (User Principal Name, eg "billg@redmond.corp.microsoft.com), logs on the user, and returns the token
FCIMPL1(HANDLE, COMPrincipal::S4ULogon, StringObject* pUPN)
{
    HANDLE token = NULL;

    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();
    THROWSCOMPLUSEXCEPTION();

	// Load Secur32.dll and find the functions we will use in it.
    // It returns null if it can't find one of the functions which
    // we'll take as the signal that the platform doesn't support
    // that functionality.
	if (!LoadSecur32Module())
      COMPlusThrow(kPlatformNotSupportedException, L"PlatformNotSupported_BeforeDotNetServer");

    STRINGREF sUPN(pUPN);
    WCHAR* wszUPN = sUPN->GetBuffer();
	NTSTATUS Status;
    PKERB_S4U_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_S4U_LOGON);

	LSA_STRING Name = { SZ_BYTE_COUNT(SZ_SOURCENAME) - 1,
						SZ_BYTE_COUNT(SZ_SOURCENAME), 
						SZ_SOURCENAME };

	LSA_STRING PackageName = { SZ_BYTE_COUNT(MICROSOFT_KERBEROS_NAME_A) - 1 ,
							   SZ_BYTE_COUNT(MICROSOFT_KERBEROS_NAME_A),
							   MICROSOFT_KERBEROS_NAME_A };

    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
	HANDLE TokenHandle = NULL;

    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;

    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    ULONG NameLength = 100;
    PUCHAR Where;

    LogonInfoSize += (ULONG) (wcslen(wszUPN)+ 1) * sizeof(WCHAR);  

    LogonInfo = (PKERB_S4U_LOGON)LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    if (LogonInfo == NULL)
    {
	    if (LogonHandle) CloseHandle(LogonHandle);
	    if (TokenHandle) CloseHandle(TokenHandle);
        COMPlusThrow(kArgumentException, L"Arg_StackOverflowException");
    }

    LogonInfo->MessageType = KerbS4ULogon;

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->ClientUpn.Buffer = (LPWSTR) Where;
    LogonInfo->ClientUpn.MaximumLength = (USHORT) (wcslen(wszUPN) + 1) * sizeof(WCHAR);
	LogonInfo->ClientUpn.Length = (USHORT) (wcslen(wszUPN) * sizeof(WCHAR));
	memcpy(Where, wszUPN, LogonInfo->ClientUpn.MaximumLength);

    if (S4UAdjustPriv())
    {
        Status = s_LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = s_LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    // From MSDN--SourceContext.SourceName: Specifies an 8-byte character string used to identify
    // the source of an access token. This is used to distinguish between such sources as Session
    // Manager, LAN Manager, and RPC Server. A string, rather than a constant, is used to identify
    // the source so users and developers can make extensions to the system, such as by adding other
    // networks, that act as the source of access tokens.
    const char* szSourceName = "CLR";
    strncpy(SourceContext.SourceName, szSourceName, strlen(szSourceName));

    AllocateLocallyUniqueId(&SourceContext.SourceIdentifier);
    
    Status = s_LsaLookupAuthenticationPackage(
                LogonHandle,
                &PackageName,
                &PackageId
                );

    if (!NT_SUCCESS(Status))
    {
        _ASSERTE(!"LsaLookupAuthenticationPackage Failed to lookup package");
        goto Cleanup;
    }

    //
    // Now call LsaLogonUser
    //
    Status = s_LsaLogonUser(
                LogonHandle,
                &Name,
                Network,
                PackageId,
                LogonInfo,
                LogonInfoSize,
                NULL,           // no token groups
                &SourceContext,
                (PVOID *) &Profile,
                &ProfileSize,
                &LogonId,
                &token,
                &Quotas,
                &SubStatus
                );
    if (!NT_SUCCESS(Status))
    {
        token = NULL;
        goto Cleanup;
    }
    if (!NT_SUCCESS(SubStatus))
    {
        token = NULL;
        goto Cleanup;
    }

Cleanup:
	if (LogonHandle) CloseHandle(LogonHandle);
	if (TokenHandle) CloseHandle(TokenHandle);
    if (token == NULL)
        COMPlusThrow(kArgumentException, L"Argument_UnableToLogOn");

    HELPER_METHOD_FRAME_END_POLL();
    
    return token;
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\compluscall.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// COMCALL.H -
//
//

#ifndef __COMPLUSCALL_H__
#define __COMPLUSCALL_H__

#include "util.hpp"
#include "ml.h"

class ComPlusCallMLStubCache;
//=======================================================================
// class com plus call
//=======================================================================
class ComPlusCall
{
    public:
        //---------------------------------------------------------
        // One-time init
        //---------------------------------------------------------
        static BOOL Init();

        //---------------------------------------------------------
        // One-time cleanup
        //---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
        static VOID Terminate();
#endif /* SHOULD_WE_CLEANUP */

        //---------------------------------------------------------
        // Handles system specfic portion of generic NDirect stub creation
        //---------------------------------------------------------
        static void CreateGenericComPlusStubSys(CPUSTUBLINKER *psl);


        //---------------------------------------------------------
        // Handles system specfic portion of fully optimized NDirect stub creation
        //
        // Results:
        //     TRUE     - was able to create a standalone asm stub (generated into
        //                psl)
        //     FALSE    - decided not to create a standalone asm stub due to
        //                to the method's complexity. Stublinker remains empty!
        //
        //     COM+ exception - error - don't trust state of stublinker.
        //---------------------------------------------------------
        static BOOL CreateStandaloneComPlusStubSys(const MLHeader *pheader, CPUSTUBLINKER *psl);

        // helper to create a generic stub for com calls
        static Stub* CreateGenericComPlusCallStub(StubLinker *pstublinker, ComPlusCallMethodDesc *pMD);

        //---------------------------------------------------------
        // Either creates or retrieves from the cache, a stub to
        // invoke com+ to com
        // Each call refcounts the returned stub.
        // This routines throws a COM+ exception rather than returning
        // NULL.
        //---------------------------------------------------------
        static Stub* GetComPlusCallMethodStub(StubLinker *psl, ComPlusCallMethodDesc *pMD);

        //---------------------------------------------------------
        // Call at strategic times to discard unused stubs.
        //---------------------------------------------------------
        static VOID  FreeUnusedStubs();

        //---------------------------------------------------------
        // Debugger helper function
        //---------------------------------------------------------
		static void *GetFrameCallIP(FramedMethodFrame *frame);
        
        // static ComPlusCallMLStubCache
        static ComPlusCallMLStubCache *m_pComPlusCallMLStubCache;
		//---------------------------------------------------------
        // Stub caches for ComPlusCall Method stubs
        //---------------------------------------------------------
        static ArgBasedStubCache *m_pComPlusCallGenericStubCache;  
		static ArgBasedStubCache *m_pComPlusCallGenericStubCacheCleanup;
    private:
        ComPlusCall() {};     // prevent "new"'s on this class

};





#endif // __COMPLUSCALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsecurityconfig.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
//   File:          COMSecurityConfig.cpp
//
//   Author:        Gregory Fee
//
//   Purpose:       Native implementation for security config access and manipulation
//
//   Date created : August 30, 2000
//
////////////////////////////////////////////////////////////////////////////////

// The security config system resides outside of the rest
// of the config system since our needs are different.  The
// unmanaged portion of the security config system is only
// concerned with data file/cache file pairs, not what they
// are used for.  It performs all the duties of reading data
// from the disk, saving data back to the disk, and maintaining
// the policy and quick cache data structures.
//
// FILE FORMAT
//
// The data file is a purely opaque blob for the unmanaged
// code; however, the cache file is constructed and maintained
// completely in the unmanaged code.  It's format is as follows:
//
// CacheHeader
//  |
//  +-- configFileTime (FILETIME, 8 bytes) = The file time of the config file associated with this cache file.
//  |
//  +-- isSecurityOn (DWORD, 4 bytes) = This is currently not used.
//  |
//  +-- quickCache (DWORD, 4 bytes) = Used as a bitfield to maintain the information for the QuickCache.  See the QuickCache section for more details.
//  |
//  +-- numEntries (DWORD, 4 bytes) = The number of policy cache entries in the latter portion of this cache file.
//  |
//  +-- sizeConfig (DWORD, 4 bytes) = The size of the config information stored in the latter portion of this cache file.
//
// Config Data (if any)
//     The cache file can include an entire copy of this
//     information in the adjoining config file.  This is
//     necessary since the cache often allows us to make
//     policy decisions without having parsed the data in 
//     the config file.  In order to guarantee that the config
//     data used by this process is not altered in the
//     meantime, we need to store the data in a readonly
//     location.  Due to the design of the caching system
//     the cache file is locked when it is opened and therefore
//     is the perfect place to store this information.  The
//     other alternative is to hold it in memory, but since
//     this can amount to many kilobytes of data we decided
//     on this design.
//
// List of CacheEntries
//  |
//  +-- CacheEntry
//  |    |
//  |    +-- numItemsInKey (DWORD, 4 bytes) = The number of evidence objects serialized in the key blob
//  |    |
//  |    +-- keySize (DWORD, 4 bytes) = The number of bytes in the key blob.
//  |    |
//  |    +-- dataSize (DWORD, 4 bytes) = The number of bytes in the data blob.
//  |    |     
//  |    +-- keyBlob (raw) = A raw blob representing the serialized evidence.
//  |    |
//  |    +-- dataBlob (raw) = A raw blob representing an XML serialized PolicyStatement
//  |
//  +-- ...
//  :
//  :
//
// QUICK CACHE
//
// The QuickCache is my name for one of the many policy resolve optimizations.  This
// particular optimization has two major steps.  First, at policy save time we perform
// analysis on the policy level and form a group of partial-evidence/partial-grant-set
// associations, the result of which are stored in the cache file (in the quickCache
// bit field in the CacheHeader).  The second step involves a set of scattered tests
// that check the QuickCache before doing a full policy resolve.  A more detailed
// explanation of the partial-evidence and partial-grant-sets that we are concerned
// about can be found in /clr/src/bcl/system/security/policymanager.cs


#include "common.h"
#include "COMString.h"
#include "COMSecurityConfig.h"
#include "ObjectHandle.h"
#include "util.hpp"
#include "security.h"
#include "safegetfilesize.h"
#include "eeconfig.h"
#include "version\__file__.ver"

// This controls the maximum size of the cache file.

#define MAX_CACHEFILE_SIZE (1 << 20)



#define SIZE_OF_ENTRY( X )   sizeof( CacheEntryHeader ) + X->header.keySize + X->header.dataSize
#define MAX_NUM_LENGTH 16

static WCHAR* wcscatDWORD( WCHAR* dst, DWORD num )
{
    static WCHAR buffer[MAX_NUM_LENGTH];

    buffer[MAX_NUM_LENGTH-1] = L'\0';

    size_t index = MAX_NUM_LENGTH-2;

    if (num == 0)
    {
        buffer[index--] = L'0';
    }
    else
    {
        while (num != 0)
        {
            buffer[index--] = (WCHAR)(L'0' + (num % 10));
            num = num / 10;
        }
    }

    wcscat( dst, buffer + index + 1 );

    return dst;
}

#define Wszdup(_str) wcscpy(new (throws) WCHAR[wcslen(_str) + 1], (_str))

ArrayList COMSecurityConfig::entries_;
Crst* COMSecurityConfig::dataLock_ = NULL;
BOOL COMSecurityConfig::configCreated_ = FALSE;

struct CacheHeader
{
    FILETIME configFileTime;
    DWORD isSecurityOn, quickCache, numEntries, sizeConfig;

    CacheHeader() : isSecurityOn( -1 ), quickCache( 0 ), numEntries( 0 ), sizeConfig( 0 )
    {
        memset( &this->configFileTime, 0, sizeof( configFileTime ) );
    };
};


struct CacheEntryHeader
{
    DWORD numItemsInKey;
    DWORD keySize;
    DWORD dataSize;
};

struct CacheEntry
{
    CacheEntryHeader header;
    BYTE* key;
    BYTE* data;
    DWORD cachePosition;
    BOOL used;

    CacheEntry() : key( NULL ), data( NULL ), used( FALSE ) {};

    ~CacheEntry( void )
    {
        delete [] key;
        delete [] data;
    }
};

struct Data
{
    enum State
    {
        None = 0x0,
        UsingCacheFile = 0x1,
        CopyCacheFile = 0x2,
        CacheUpdated = 0x4,
        UsingConfigFile = 0x10,
        CacheExhausted = 0x20,
        NewConfigFile = 0x40
    };

    INT32 id;
    WCHAR* configFileName;
    WCHAR* cacheFileName;
    WCHAR* cacheFileNameTemp;

    OBJECTHANDLE configData;
    FILETIME configFileTime;
    FILETIME cacheFileTime;
    CacheHeader header;
    ArrayList* oldCacheEntries;
    ArrayList* newCacheEntries;
    State state;
    DWORD cacheCurrentPosition;
    HANDLE cache;
    PBYTE configBuffer;
    DWORD  sizeConfig;
	COMSecurityConfig::ConfigRetval initRetval;
    DWORD newEntriesSize;

    Data( INT32 id )
        : id( id ),
          configData( NULL ),
          configFileName( NULL ),
          cacheFileName( NULL ),
          cache( INVALID_HANDLE_VALUE ),
          state( State::None ),
          oldCacheEntries( new ArrayList ),
          newCacheEntries( new ArrayList ),
          configBuffer( NULL ),
          newEntriesSize( 0 )
    {
    }

    Data( INT32 id, STRINGREF* configFile )
        : id( id ),
          configData( SharedDomain::GetDomain()->CreateHandle( NULL ) ),
          cacheFileName( NULL ),
          cache( INVALID_HANDLE_VALUE ),
          state( State::None ),
          oldCacheEntries( new ArrayList ),
          newCacheEntries( new ArrayList ),
          configBuffer( NULL ),
          newEntriesSize( 0 )
    {
        THROWSCOMPLUSEXCEPTION();

        _ASSERTE( *configFile != NULL && "A config file must be specified" );

        configFileName = Wszdup( (*configFile)->GetBuffer() );
        cacheFileName = NULL;
        cacheFileNameTemp = NULL;
    }

    Data( INT32 id, STRINGREF* configFile, STRINGREF* cacheFile )
        : id( id ),
          configData( SharedDomain::GetDomain()->CreateHandle( NULL ) ),
          cache( INVALID_HANDLE_VALUE ),
          state( State::None ),
          oldCacheEntries( new ArrayList ),
          newCacheEntries( new ArrayList ),
          configBuffer( NULL ),
          newEntriesSize( 0 )
    {
        THROWSCOMPLUSEXCEPTION();

        _ASSERTE( *configFile != NULL && "A config file must be specified" );

        configFileName = Wszdup( (*configFile)->GetBuffer() );

        if (cacheFile != NULL)
        {
            // Since temp cache files can stick around even after the process that
            // created them, we want to make sure they are fairly unique (if they
            // aren't, we'll just fail to save cache information, which is not good
            // but it won't cause anyone to crash or anything).  The unique name
            // algorithm used here is to append the process id and tick count to
            // the name of the cache file.

            cacheFileName = Wszdup( (*cacheFile)->GetBuffer() );
            cacheFileNameTemp = new (throws) WCHAR[wcslen( cacheFileName ) + 1 + 2 * MAX_NUM_LENGTH];
            wcscpy( cacheFileNameTemp, cacheFileName );
            wcscat( cacheFileNameTemp, L"." );
            wcscatDWORD( cacheFileNameTemp, GetCurrentProcessId() );
            wcscat( cacheFileNameTemp, L"." );
            wcscatDWORD( cacheFileNameTemp, GetTickCount() );
        }
        else
        {
            cacheFileName = NULL;
            cacheFileNameTemp = NULL;
        }
    }

    Data( INT32 id, WCHAR* configFile, WCHAR* cacheFile )
        : id( id ),
          configData( SharedDomain::GetDomain()->CreateHandle( NULL ) ),
          cache( INVALID_HANDLE_VALUE ),
          state( State::None ),
          oldCacheEntries( new ArrayList ),
          newCacheEntries( new ArrayList ),
          configBuffer( NULL ),
          newEntriesSize( 0 )

    {
        THROWSCOMPLUSEXCEPTION();

        _ASSERTE( *configFile != NULL && "A config file must be specified" );

        configFileName = Wszdup( configFile );

        if (cacheFile != NULL)
        {
            cacheFileName = Wszdup( cacheFile );
            cacheFileNameTemp = new (throws) WCHAR[wcslen( cacheFileName ) + 1 + 2 * MAX_NUM_LENGTH];
            wcscpy( cacheFileNameTemp, cacheFileName );
            wcscat( cacheFileNameTemp, L"." );
            wcscatDWORD( cacheFileNameTemp, GetCurrentProcessId() );
            wcscat( cacheFileNameTemp, L"." );
            wcscatDWORD( cacheFileNameTemp, GetTickCount() );
        }
        else
        {
            cacheFileName = NULL;
            cacheFileNameTemp = NULL;
        }
    }

    void Reset( void )
    {
        delete [] configBuffer;
        configBuffer = NULL;

        if (cache != INVALID_HANDLE_VALUE)
        {
            CloseHandle( cache );
            cache = INVALID_HANDLE_VALUE;
        }

        if (cacheFileNameTemp != NULL)
        {
            // Note: we don't check a return value here as the worst thing that
            // happens is we leave a spurious cache file.

            WszDeleteFile( cacheFileNameTemp );
        }

        DestroyHandle( configData );
        configData = SharedDomain::GetDomain()->CreateHandle( NULL );

        DeleteAllEntries();
        header = CacheHeader();

        oldCacheEntries = new ArrayList();
        newCacheEntries = new ArrayList();

    }

	void Cleanup( void )
	{
        if (cache != INVALID_HANDLE_VALUE)
        {
            CloseHandle( cache );
            cache = INVALID_HANDLE_VALUE;
        }

        if (cacheFileNameTemp != NULL)
        {
            // Note: we don't check a return value here as the worst thing that
            // happens is we leave a spurious cache file.

            WszDeleteFile( cacheFileNameTemp );
        }
	}


    ~Data( void )
    {
		Cleanup();

        delete [] configBuffer;

        delete [] configFileName;
        delete [] cacheFileName;
        delete [] cacheFileNameTemp;

        DestroyHandle( configData );

        DeleteAllEntries();
    }

    void DeleteAllEntries( void )
    {
        ArrayList::Iterator iter;
        
        if (oldCacheEntries != NULL)
        {
            iter = oldCacheEntries->Iterate();

            while (iter.Next())
            {
                delete (CacheEntry*) iter.GetElement();
            }

            delete oldCacheEntries;

            oldCacheEntries = NULL;
        }

        if (newCacheEntries != NULL)
        {
            iter = newCacheEntries->Iterate();

            while (iter.Next())
            {
                delete (CacheEntry*) iter.GetElement();
            }

            delete newCacheEntries;
            newCacheEntries = NULL;
        }
    }
};


void* COMSecurityConfig::GetData( INT32 id )
{
    ArrayList::Iterator iter = entries_.Iterate();

    while (iter.Next())
    {
        Data* data = (Data*)iter.GetElement();

        if (data->id == id)
        {
            return data;
        }
    }

    return NULL;
}

static BOOL CacheOutOfDate( FILETIME* configFileTime, WCHAR* configFileName, WCHAR* cacheFileName )
{
    HANDLE config = INVALID_HANDLE_VALUE;
    BOOL retval = TRUE;
    BOOL deleteFile = FALSE;

    config = WszCreateFile( configFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    
    if (config == INVALID_HANDLE_VALUE)
    {
        goto CLEANUP;
    }

    // Get the last write time for both files.
    
    FILETIME newConfigTime;
    
    if (!GetFileTime( config, NULL, NULL, &newConfigTime ))
    {
        goto CLEANUP;
    }
    
    if (CompareFileTime( configFileTime, &newConfigTime ) != 0)
    {
        // Cache is dated.  Delete the cache.
        deleteFile = TRUE;
        goto CLEANUP;
    }

    retval = FALSE;
    
CLEANUP:
    if (config != INVALID_HANDLE_VALUE)
        CloseHandle( config );

    // Note: deleting this file is a perf optimization so that
    // we don't have to do this file time comparison next time.
    // Therefore, if it fails for some reason we just loss a
    // little perf.

    if (deleteFile && cacheFileName != NULL)
        WszDeleteFile( cacheFileName );
        
    return retval;
}

static BOOL CacheOutOfDate( FILETIME* cacheFileTime, HANDLE cache, WCHAR* cacheFileName )
{
    BOOL retval = TRUE;

    // Get the last write time for both files.
    
    FILETIME newCacheTime;
    
    if (!GetFileTime( cache, NULL, NULL, &newCacheTime ))
    {
        goto CLEANUP;
    }
    
    if (CompareFileTime( cacheFileTime, &newCacheTime ) != 0)
    {
        // Cache is dated.  Delete the cache.
        // Note: deleting this file is a perf optimization so that
        // we don't have to do this file time comparison next time.
        // Therefore, if it fails for some reason we just loss a
        // little perf.

        if (cacheFileName != NULL)
        {
            CloseHandle( cache );
            WszDeleteFile( cacheFileName );
        }
        goto CLEANUP;
    }

    retval = FALSE;
    
CLEANUP:
    return retval;
}


static BOOL CacheOutOfDate( HANDLE cache, HANDLE config, STRINGREF* cacheFileName )
{
    // Get the last write time for both files.
    
    FILETIME cacheTime, configTime;
    
    if (!GetFileTime( cache, NULL, NULL, &cacheTime ))
    {
        return TRUE;
    }
    
    if (!GetFileTime( config, NULL, NULL, &configTime ))
    {
        return TRUE;
    }
    
    if (CompareFileTime( &configTime, &cacheTime ) != -1)
    {
        // Cache is dated.  Delete the cache.
        // Note: deleting this file is a perf optimization so that
        // we don't have to do this file time comparison next time.
        // Therefore, if it fails for some reason we just loss a
        // little perf.
        CloseHandle( cache );
        WszDeleteFile( (*cacheFileName)->GetBuffer() );
        return TRUE;
    }
    
    // Cache is good
    return FALSE;
}

static BOOL CacheOutOfDate( FILETIME* configTime, FILETIME* cachedConfigTime )
{
    DWORD result = CompareFileTime( configTime, cachedConfigTime );

    return result != 0;
}

static DWORD WriteFileData( HANDLE file, PBYTE data, DWORD size )
{
    DWORD totalBytesWritten = 0;
    DWORD bytesWritten;

    do
    {
        if (WriteFile( file, data, size - totalBytesWritten, &bytesWritten, NULL ) == 0)
        {
            return E_FAIL;
        }

        if (bytesWritten == 0)
        {
            return E_FAIL;
        }
        
        totalBytesWritten += bytesWritten;
        
    } while (totalBytesWritten < size);
    
    return S_OK;
}

static DWORD ReadFileData( HANDLE file, PBYTE data, DWORD size )
{
    DWORD totalBytesRead = 0;
    DWORD bytesRead;

    do
    {
        if (ReadFile( file, data, size - totalBytesRead, &bytesRead, NULL ) == 0)
        {
            return E_FAIL;
        }

        if (bytesRead == 0)
        {
            return E_FAIL;
        }
        
        totalBytesRead += bytesRead;
        
    } while (totalBytesRead < size);
    
    return S_OK;
}


INT32 COMSecurityConfig::EcallInitData( _InitData* args )
{
    THROWSCOMPLUSEXCEPTION();
    return InitData( args->id, args->config->GetBuffer(), NULL );
}
    
INT32 COMSecurityConfig::EcallInitDataEx( _InitDataEx* args )
{
    THROWSCOMPLUSEXCEPTION();
    return InitData( args->id, args->config->GetBuffer(), args->cache->GetBuffer() );
}

static U1ARRAYREF AllocateByteArray(DWORD dwSize)
{
    U1ARRAYREF orRet;

    COMPLUS_TRY
    {
        orRet = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, dwSize);
    }
    COMPLUS_CATCH
    {
        orRet = NULL;
    }
    COMPLUS_END_CATCH

    return orRet;
}

COMSecurityConfig::ConfigRetval COMSecurityConfig::InitData( INT32 id, WCHAR* configFileName, WCHAR* cacheFileName )
{
    Data* data = NULL;

    data = (Data*)GetData( id );

    if (data != NULL)
    {
        return data->initRetval;
    }

    if (configFileName == NULL || wcslen( configFileName ) == 0)
    {
        return NoFile;
    }

    data = new Data( id, configFileName, cacheFileName );

    if (data == NULL)
    {
         return NoFile;
    }

    return InitData( data, TRUE );
}

COMSecurityConfig::ConfigRetval COMSecurityConfig::InitData( void* configDataParam, BOOL addToList )
{
    _ASSERTE( configDataParam != NULL );

    THROWSCOMPLUSEXCEPTION();

    HANDLE config = INVALID_HANDLE_VALUE;
    Data* data = (Data*)configDataParam;
    DWORD cacheSize;
    DWORD configSize;
    U1ARRAYREF configData;
    ConfigRetval retval = NoFile;
    DWORD shareFlags = 0;

    if (GetVersion() < 0x80000000)
    {
        shareFlags = FILE_SHARE_READ | FILE_SHARE_DELETE;
    }
    else
    {
        shareFlags = FILE_SHARE_READ;
    }

    // Crack open the config file.

    config = WszCreateFile( data->configFileName, GENERIC_READ, shareFlags, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        
    if (config == INVALID_HANDLE_VALUE || !GetFileTime( config, NULL, NULL, &data->configFileTime ))
    {
        memset( &data->configFileTime, 0, sizeof( data->configFileTime ) );
    }
    else
    {
        data->state = (Data::State)(Data::State::UsingConfigFile | data->state);
    }

    // If we want a cache file, try to open that up.

    if (data->cacheFileName != NULL)
        data->cache = WszCreateFile( data->cacheFileName, GENERIC_READ, shareFlags, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    
    if (data->cache == INVALID_HANDLE_VALUE)
    {
        goto READ_DATA;
    }

    // Validate that the cache file is in a good form by checking
    // that it is at least big enough to contain a header.

    cacheSize = SafeGetFileSize( data->cache, NULL );
    
    if (cacheSize == 0xFFFFFFFF)
    {
        goto READ_DATA;
    }
    
    if (cacheSize < sizeof( CacheHeader ))
    {
        goto READ_DATA;
    }

    // Finally read the data from the file into the buffer.
    
    if (ReadFileData( data->cache, (BYTE*)&data->header, sizeof( CacheHeader ) ) != S_OK)
    {
        goto READ_DATA;
    }

    // Check to make sure the cache file and the config file
    // match up by comparing the actual file time of the config
    // file and the config file time stored in the cache file.

    if (CacheOutOfDate( &data->configFileTime, &data->header.configFileTime ))
    {
        goto READ_DATA;
    }

    if (!GetFileTime( data->cache, NULL, NULL, &data->cacheFileTime ))
    {
        goto READ_DATA;
    }

    // Set the file pointer to after both the header and config data (if any) so
    // that we are ready to read cache entries.

    if (SetFilePointer( data->cache, sizeof( CacheHeader ) + data->header.sizeConfig, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
    {
        goto READ_DATA;
    }

    data->cacheCurrentPosition = sizeof( CacheHeader ) + data->header.sizeConfig;
    data->state = (Data::State)(Data::State::UsingCacheFile | Data::State::CopyCacheFile | data->state);

    retval = (ConfigRetval)(retval | CacheFile);

READ_DATA:
    // If we are not using the cache file but we successfully opened it, we need
    // to close it now.  In addition, we need to reset the cache information
    // stored in the Data object to make sure there is no spill over.

    if (data->cache != INVALID_HANDLE_VALUE && (data->state & Data::State::UsingCacheFile) == 0)
    {
        CloseHandle( data->cache );
        data->header = CacheHeader();
        data->cache = INVALID_HANDLE_VALUE;
    }

    if (config != INVALID_HANDLE_VALUE)
    {
        configSize = SafeGetFileSize( config, NULL );
    
        if (configSize == 0xFFFFFFFF)
        {
            goto ADD_DATA;
        }

        // Be paranoid and only use the cache file version if we find that it has the correct sized
        // blob in it.
        
        if ((data->state & Data::State::UsingCacheFile) != 0 && configSize == data->header.sizeConfig)
        {
            StoreObjectInHandle( data->configData, NULL );
            goto ADD_DATA;
        }
        else
        {
            if (data->cache != INVALID_HANDLE_VALUE)
            {
                CloseHandle( data->cache );
                data->header = CacheHeader();
                data->cache = INVALID_HANDLE_VALUE;
                data->state = (Data::State)(data->state & ~(Data::State::UsingCacheFile));
            }

            configData = AllocateByteArray(configSize);
            if (configData == NULL)
            {
                goto ADD_DATA;
            }
    
            if (ReadFileData( config, (PBYTE)(configData->GetDirectPointerToNonObjectElements()), configSize ) != S_OK)
            {
                goto ADD_DATA;
            } 

            StoreObjectInHandle( data->configData, (OBJECTREF)configData );

        }
        retval = (ConfigRetval)(retval | ConfigFile);
    }

ADD_DATA:
    BEGIN_ENSURE_PREEMPTIVE_GC();
    COMSecurityConfig::dataLock_->Enter();
    if (addToList)
        entries_.Append( data );
    COMSecurityConfig::dataLock_->Leave();
    END_ENSURE_PREEMPTIVE_GC();

    if (config != INVALID_HANDLE_VALUE)
        CloseHandle( config );

	_ASSERTE( data );
	data->initRetval = retval;

    return retval;

};

static CacheEntry* LoadNextEntry( HANDLE cache, Data* data )
{
    if ((data->state & Data::State::CacheExhausted) != 0)
        return NULL;

    CacheEntry* entry = new (nothrow) CacheEntry();

    if (entry == NULL)
        return NULL;

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (SetFilePointer( cache, data->cacheCurrentPosition, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER ||
        ReadFileData( cache, (BYTE*)&entry->header, sizeof( CacheEntryHeader ) ) != S_OK)
    {
        delete entry;
        entry = NULL;
        goto EXIT;
    }

    entry->cachePosition = data->cacheCurrentPosition + sizeof( entry->header );

    data->cacheCurrentPosition += sizeof( entry->header ) + entry->header.keySize + entry->header.dataSize;

    if (SetFilePointer( cache, entry->header.keySize + entry->header.dataSize, NULL, FILE_CURRENT ) == INVALID_SET_FILE_POINTER)
    {
        delete entry;
        entry = NULL;
        goto EXIT;
    }

    // We append a partially populated entry. CompareEntry is robust enough to handle this.
    data->oldCacheEntries->Append( entry );

EXIT:
    END_ENSURE_PREEMPTIVE_GC();

    return entry;
}

static BOOL WriteEntry( HANDLE cache, CacheEntry* entry, HANDLE oldCache = NULL )
{
    THROWSCOMPLUSEXCEPTION();

    if (WriteFileData( cache, (BYTE*)&entry->header, sizeof( CacheEntryHeader ) ) != S_OK)
    {
        return FALSE;
    }

    if (entry->key == NULL)
    {
        _ASSERTE (oldCache != NULL);

        // We were lazy in reading the entry. Read the key now.
        entry->key = new BYTE[entry->header.keySize];
        if (entry->key == NULL)
            COMPlusThrowOM();

        _ASSERTE (cache != INVALID_HANDLE_VALUE);

        if (SetFilePointer( oldCache, entry->cachePosition, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
            return NULL;

        if (ReadFileData( oldCache, entry->key, entry->header.keySize ) != S_OK)
        {
            DWORD error = GetLastError();
            return NULL;
        }

        entry->cachePosition += entry->header.keySize;
    }
        
    _ASSERTE( entry->key != NULL );
        
    if (entry->data == NULL)
    {
        _ASSERTE (oldCache != NULL);

        // We were lazy in reading the entry. Read the data also.
        entry->data = new BYTE[entry->header.dataSize];

        if (entry->data == NULL)
            COMPlusThrowOM();

        if (SetFilePointer( oldCache, entry->cachePosition, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
            return NULL;

        if (ReadFileData( oldCache, entry->data, entry->header.dataSize ) != S_OK)
            return NULL;

        entry->cachePosition += entry->header.dataSize;
    }

    _ASSERT( entry->data != NULL );

    if (WriteFileData( cache, entry->key, entry->header.keySize ) != S_OK)
    {
        return FALSE;
    }

    if (WriteFileData( cache, entry->data, entry->header.dataSize ) != S_OK)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL COMSecurityConfig::EcallSaveCacheData( _SaveCacheData* args )
{
    return SaveCacheData( args->id );
}

#define MAX_CACHEFILE_SIZE (1 << 20)
#define SIZE_OF_ENTRY( X )   sizeof( CacheEntryHeader ) + X->header.keySize + X->header.dataSize

BOOL COMSecurityConfig::SaveCacheData( INT32 id )
{
    // Note: this function should only be called at EEShutdown time.
    // This is because we need to close the current cache file in
    // order to delete it.  If it ever became necessary to do
    // cache saves while a process we still executing managed code
    // it should be possible to create a locking scheme for usage
    // of the cache handle with very little reordering of the below
    // (as it should always be possible for us to have a live copy of
    // the file and yet still be making the swap).

    HANDLE cache = INVALID_HANDLE_VALUE;
    HANDLE config = INVALID_HANDLE_VALUE;
    CacheHeader header;
    BOOL retval = FALSE;
    DWORD numEntriesWritten = 0;
    DWORD amountWritten = 0;
    DWORD sizeConfig = 0;
    PBYTE configBuffer = NULL;

    Data* data = (Data*)GetData( id );

    // If there is not data by the id or there is no
    // cache file name associated with the data, then fail.

    if (data == NULL || data->cacheFileName == NULL)
        return FALSE;

    // If we haven't added anything new to the cache
    // then just return success.

    if ((data->state & Data::State::CacheUpdated) == 0)
        return TRUE;

    // If the config file has changed since the process started
    // then our cache data is no longer valid.  We'll just
    // return success in this case.

    if ((data->state & Data::State::UsingConfigFile) != 0 && CacheOutOfDate( &data->configFileTime, data->configFileName, NULL ))
        return TRUE;

    DWORD fileNameLength = (DWORD)wcslen( data->cacheFileName );

    WCHAR* newFileName = new(nothrow) WCHAR[fileNameLength + 5];

    if (!newFileName)
        return FALSE;

    wcscpy( newFileName, data->cacheFileName );
    wcscpy( &newFileName[fileNameLength], L".new" );

    cache = WszCreateFile( newFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    
    if (cache == INVALID_HANDLE_VALUE)
        goto CLEANUP;

    // This code seems complicated only because of the
    // number of cases that we are trying to handle.  All we
    // are trying to do is determine the amount of space to
    // leave for the config information.

    // If we saved out a new config file during this run, use
    // the config size stored in the Data object itself.

    if ((data->state & Data::State::NewConfigFile) != 0)
    {
        sizeConfig = data->sizeConfig;
    }

    // If we have a cache file, then use the size stored in the
    // cache header.

    else if ((data->state & Data::State::UsingCacheFile) != 0)
    {
        sizeConfig = data->header.sizeConfig;
    }

    // If we read in the config data, use the size of the
    // managed byte array that it is stored in.

    else if (ObjectFromHandle( data->configData ) != NULL)
    {
        sizeConfig = ((U1ARRAYREF)ObjectFromHandle( data->configData ))->GetNumComponents();
    }

    // Otherwise, check the config file itself to get the size.

    else
    {
        DWORD shareFlags;

        if (GetVersion() < 0x80000000)
        {
            shareFlags = FILE_SHARE_READ | FILE_SHARE_DELETE;
        }
        else
        {
            shareFlags = FILE_SHARE_READ;
        }

        config = WszCreateFile( data->configFileName, GENERIC_READ, shareFlags, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if (config == INVALID_HANDLE_VALUE)
        {
            sizeConfig = 0;
        }
        else
        {
            sizeConfig = SafeGetFileSize( config, NULL );

            if (sizeConfig == 0xFFFFFFFF)
            {
                sizeConfig = 0;
                CloseHandle( config );
                config = INVALID_HANDLE_VALUE;
            }
        }
    }

    // First write the entries.

    if (SetFilePointer( cache, sizeof( CacheHeader ) + sizeConfig, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
    {
        goto CLEANUP;
    }

    // We're going to write out the cache entries in a modified
    // least recently used order, throwing out any that end up
    // taking us past our hardcoded max file size.

    COMPLUS_TRY
    {
        // First, write the entries from the cache file that were used.
        // We do this because presumably these are system assemblies
        // and other assemblies used by a number of applications.
    
        ArrayList::Iterator iter;

        if ((data->state & Data::State::UsingCacheFile) != 0)
        {
            iter = data->oldCacheEntries->Iterate();

            while (iter.Next() && amountWritten < MAX_CACHEFILE_SIZE)
            {
                CacheEntry* currentEntry = (CacheEntry*)iter.GetElement();

                if (currentEntry->used)
                {
                    if(!WriteEntry( cache, currentEntry, data->cache ))
                    {
                        // Write failed, destroy the file and bail.
                        // Note: if the delete fails, we always do a CREATE_NEW
                        // for this file so that should take care of it.  If not
                        // we'll fail to write out future cache files.
                        CloseHandle( cache );
                        cache = INVALID_HANDLE_VALUE;
                        WszDeleteFile( newFileName );
                        goto CLEANUP;
                    }

                    amountWritten += SIZE_OF_ENTRY( currentEntry );
                    numEntriesWritten++;
                }
            }
        }

        // Second, write any new cache entries to the file.  These are
        // more likely to be assemblies specific to this app.

        iter = data->newCacheEntries->Iterate();

        while (iter.Next() && amountWritten < MAX_CACHEFILE_SIZE)
        {
            CacheEntry* currentEntry = (CacheEntry*)iter.GetElement();
    
            if (!WriteEntry( cache, currentEntry ))
            {
                // Write failed, destroy the file and bail.
                // Note: if the delete fails, we always do a CREATE_NEW
                // for this file so that should take care of it.  If not
                // we'll fail to write out future cache files.
                CloseHandle( cache );
                cache = INVALID_HANDLE_VALUE;
                WszDeleteFile( newFileName );
                goto CLEANUP;
            }
    
            amountWritten += SIZE_OF_ENTRY( currentEntry );
            numEntriesWritten++;
        }

        // Third, if we are using the cache file, write the old entries
        // that were not used this time around.

        if ((data->state & Data::State::UsingCacheFile) != 0)
        {
            // First, write the ones that we already have partially loaded

            iter = data->oldCacheEntries->Iterate();

            while (iter.Next() && amountWritten < MAX_CACHEFILE_SIZE)
            {
                CacheEntry* currentEntry = (CacheEntry*)iter.GetElement();

                if (!currentEntry->used)
                {
                    if(!WriteEntry( cache, currentEntry, data->cache ))
                    {
                        // Write failed, destroy the file and bail.
                        // Note: if the delete fails, we always do a CREATE_NEW
                        // for this file so that should take care of it.  If not
                        // we'll fail to write out future cache files.
                        CloseHandle( cache );
                        cache = INVALID_HANDLE_VALUE;
                        WszDeleteFile( newFileName );
                        goto CLEANUP;
                    }

                    amountWritten += SIZE_OF_ENTRY( currentEntry );
                    numEntriesWritten++;
                }
            }

            while (amountWritten < MAX_CACHEFILE_SIZE)
            {
                CacheEntry* entry = LoadNextEntry( data->cache, data );

                if (entry == NULL)
                    break;

                if (!WriteEntry( cache, entry, data->cache ))
                {
                    // Write failed, destroy the file and bail.
                    // Note: if the delete fails, we always do a CREATE_NEW
                    // for this file so that should take care of it.  If not
                    // we'll fail to write out future cache files.
                    CloseHandle( cache );
                    cache = INVALID_HANDLE_VALUE;
                    WszDeleteFile( newFileName );
                    goto CLEANUP;
                }
        
                amountWritten += SIZE_OF_ENTRY( entry );
                numEntriesWritten++;
            }
        }
    }
    COMPLUS_CATCH
    {
        // Note: if the delete fails, we always do a CREATE_NEW
        // for this file so that should take care of it.  If not
        // we'll fail to write out future cache files.
        CloseHandle( cache );
        cache = INVALID_HANDLE_VALUE;
        WszDeleteFile( newFileName );
        goto CLEANUP;
    }
    COMPLUS_END_CATCH

    // End with writing the header.

    header.configFileTime = data->configFileTime;
    header.isSecurityOn = 1;
    header.numEntries = numEntriesWritten;
    header.quickCache = data->header.quickCache;
    header.sizeConfig = sizeConfig;

    if (SetFilePointer( cache, 0, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
    {
        // Couldn't move to the beginning of the file
        goto CLEANUP;
    }
        
    if (WriteFileData( cache, (PBYTE)&header, sizeof( header ) ) != S_OK)
    {
        // Couldn't write header info.
        goto CLEANUP;
    }

    if (sizeConfig != 0)
    {
        if ((data->state & Data::State::NewConfigFile) != 0)
        {
            if (WriteFileData( cache, data->configBuffer, sizeConfig ) != S_OK)
            {
                goto CLEANUP;
            }
        }
        else
        {
            U1ARRAYREF configData = (U1ARRAYREF)ObjectFromHandle( data->configData );

            if (configData != NULL)
            {
                _ASSERTE( sizeConfig == configData->GetNumComponents() && "sizeConfig is set to the wrong value" );

                if (WriteFileData( cache, (PBYTE)(configData->GetDirectPointerToNonObjectElements()), sizeConfig ) != S_OK)
                {
                    goto CLEANUP;
                }
            }
            else if ((data->state & Data::State::UsingCacheFile) != 0)
            {
                configBuffer = new BYTE[sizeConfig];
    
                if (SetFilePointer( data->cache, sizeof( CacheHeader ), NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
                {
                    goto CLEANUP;
                }

                if (ReadFileData( data->cache, configBuffer, sizeConfig ) != S_OK)
                {
                    goto CLEANUP;
                }

                if (WriteFileData( cache, configBuffer, sizeConfig ) != S_OK)
                {
                    goto CLEANUP;
                }
            }
            else
            {
                configBuffer = new BYTE[sizeConfig];
    
                if (SetFilePointer( config, 0, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
                {
                    goto CLEANUP;
                }

                if (ReadFileData( config, configBuffer, sizeConfig ) != S_OK)
                {
                    goto CLEANUP;
                }

                if (WriteFileData( cache, configBuffer, sizeConfig ) != S_OK)
                {
                    goto CLEANUP;
                }
            }
        }
    }

    // Flush the file buffers to make sure
    // we get full write through.

    FlushFileBuffers( cache );

    CloseHandle( cache );
    cache = INVALID_HANDLE_VALUE;
    CloseHandle( data->cache );
    data->cache = INVALID_HANDLE_VALUE;

    // Move the existing file out of the way
    // Note: use MoveFile because we know it will never cross
    // device boundaries.

    // Note: the delete file can fail, but we can't really do anything
    // if it does so just ignore any failures.
    WszDeleteFile( data->cacheFileNameTemp );

    // Try to move the existing cache file out of the way.  However, if we can't
    // then try to delete it.  If it can't be deleted then just bail out.
    if (!WszMoveFile( data->cacheFileName, data->cacheFileNameTemp ) && (GetLastError() != ERROR_FILE_NOT_FOUND) && !WszDeleteFile( data->cacheFileNameTemp ))
    {
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
            goto CLEANUP;
    }

    // Move the new file into position

    if (!WszMoveFile( newFileName, data->cacheFileName ))
    {
        goto CLEANUP;
    }

    retval = TRUE;

CLEANUP:
    if (newFileName != NULL)
        delete [] newFileName;

    if (config != INVALID_HANDLE_VALUE)
        CloseHandle( config );

    if (configBuffer != NULL)
        delete [] configBuffer;

    if (!retval && cache != INVALID_HANDLE_VALUE)
        CloseHandle( cache );

    return retval;

}

void COMSecurityConfig::EcallClearCacheData( _ClearCacheData* args )
{
    ClearCacheData( args->id );
}

void COMSecurityConfig::ClearCacheData( INT32 id )
{
    Data* data = (Data*)GetData( id );

    if (data == NULL)
        return;

    COMSecurityConfig::dataLock_->Enter();

    data->DeleteAllEntries();

    data->oldCacheEntries = new ArrayList;
    data->newCacheEntries = new ArrayList;

    data->header = CacheHeader();
    data->state = (Data::State)(~(Data::State::CopyCacheFile | Data::State::UsingCacheFile) & data->state);

    if (data->cache != INVALID_HANDLE_VALUE)
    {
        CloseHandle( data->cache );
        data->cache = INVALID_HANDLE_VALUE;
    }

    DWORD shareFlags;

    if (GetVersion() < 0x80000000)
    {
        shareFlags = FILE_SHARE_READ | FILE_SHARE_DELETE;
    }
    else
    {
        shareFlags = FILE_SHARE_READ;
    }

    HANDLE config = WszCreateFile( data->configFileName, 0, shareFlags, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    if (config == INVALID_HANDLE_VALUE)
    {
        COMSecurityConfig::dataLock_->Leave();
        return;
    }

    // These api calls should never fail after obtaining this handle.  Verify them in debug.
    VERIFY(GetFileTime( config, NULL, NULL, &data->configFileTime ));
    VERIFY(GetFileTime( config, NULL, NULL, &data->header.configFileTime ));

    CloseHandle( config );

    COMSecurityConfig::dataLock_->Leave();
}


void COMSecurityConfig::EcallResetCacheData( _ResetCacheData* args )
{
    ResetCacheData( args->id );
}

void COMSecurityConfig::ResetCacheData( INT32 id )
{
    Data* data = (Data*)GetData( id );

    if (data == NULL)
        return;

    COMSecurityConfig::dataLock_->Enter();

    data->DeleteAllEntries();

    data->oldCacheEntries = new ArrayList;
    data->newCacheEntries = new ArrayList;

    data->header = CacheHeader();
    data->state = (Data::State)(~(Data::State::CopyCacheFile | Data::State::UsingCacheFile) & data->state);

    DWORD shareFlags;

    if (GetVersion() < 0x80000000)
    {
        shareFlags = FILE_SHARE_READ | FILE_SHARE_DELETE;
    }
    else
    {
        shareFlags = FILE_SHARE_READ;
    }

    HANDLE config = WszCreateFile( data->configFileName, GENERIC_READ, shareFlags, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    if (config == INVALID_HANDLE_VALUE)
    {
        COMSecurityConfig::dataLock_->Leave();
        return;
    }

    VERIFY(GetFileTime( config, NULL, NULL, &data->configFileTime ));
    VERIFY(GetFileTime( config, NULL, NULL, &data->header.configFileTime ));

    CloseHandle( config );

    COMSecurityConfig::dataLock_->Leave();
}


BOOL COMSecurityConfig::EcallSaveDataString( _SaveDataString* args )
{
    return SaveData( args->id, args->data->GetBuffer(), args->data->GetStringLength() * sizeof( WCHAR ) );
}

BOOL COMSecurityConfig::EcallSaveDataByte( _SaveDataByte* args )
{
    return SaveData( args->id, args->data->GetDirectPointerToNonObjectElements() + args->offset, args->length );
}

BOOL COMSecurityConfig::SaveData( INT32 id, void* buffer, size_t bufferSize )
{
    Data* data = (Data*)GetData( id );

    if (data == NULL)
        return FALSE;

    HANDLE newFile = INVALID_HANDLE_VALUE;

    BOOL retval = FALSE;
    DWORD fileNameLength = (DWORD)wcslen( data->configFileName );

    WCHAR* newFileName = new (nothrow) WCHAR[fileNameLength + 5];
    WCHAR* oldFileName = new (nothrow) WCHAR[fileNameLength + 5];

    if (newFileName == NULL || oldFileName == NULL)
        return FALSE;

    wcscpy( newFileName, data->configFileName );
    wcscpy( &newFileName[fileNameLength], L".new" );
    wcscpy( oldFileName, data->configFileName );
    wcscpy( &oldFileName[fileNameLength], L".old" );

    // Create the new file.
    
    newFile = WszCreateFile( newFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );        
    
    if (newFile == INVALID_HANDLE_VALUE)
    {
        DWORD error = GetLastError();

        if (error == ERROR_PATH_NOT_FOUND)
        {
            // The directory does not exist, iterate through and try to create it.

            WCHAR* currentChar = newFileName;

            // Skip the first backslash

            while (*currentChar != L'\0')
            {
                if (*currentChar == L'\\')
                {
                    currentChar++;
                    break;
                }
                currentChar++;
            }

            // Iterate through trying to create each subdirectory.

            while (*currentChar != L'\0')
            {
                if (*currentChar == L'\\')
                {
                    *currentChar = L'\0';

                    if (!WszCreateDirectory( newFileName, NULL ))
                    {
                        DWORD error = GetLastError();

                        if (error != ERROR_ACCESS_DENIED && error != ERROR_ALREADY_EXISTS)
                        {
                            goto CLEANUP;
                        }
                    }

                    *currentChar = L'\\';
                }
                currentChar++;
            }

            newFile = WszCreateFile( newFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

            if (newFile == INVALID_HANDLE_VALUE)
            {
                goto CLEANUP;
            }

        }
        else
        {
            // Can't open or create the file, just bail.
            goto CLEANUP;
        }
    }
    
    // Write the data into it.

    if (WriteFileData( newFile, (PBYTE)buffer, (DWORD)bufferSize ) != S_OK)
    {
        // Write failed, destroy the file and bail.
        // Note: if the delete fails, we always do a CREATE_NEW
        // for this file so that should take care of it.  If not
        // we'll fail to write out future cache files.
        CloseHandle( newFile );
        WszDeleteFile( newFileName );
        goto CLEANUP;
    }

    FlushFileBuffers( newFile );
    CloseHandle( newFile );

    // Move the existing file out of the way
    
    if (!WszMoveFileEx( data->configFileName, oldFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ))
    {
        // If move fails for a reason other than not being able to find the file, bail out.
        // Also, if the old file didn't exist, we have no need to delete it.

        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            if (!WszDeleteFile( data->configFileName ))
                goto CLEANUP;
        }
    }

    // Move the new file into position

    if (!WszMoveFileEx( newFileName, data->configFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ))
    {
        goto CLEANUP;
    }

    if (data->configBuffer != NULL)
    {
        delete [] data->configBuffer;
    }

    data->configBuffer = new BYTE[bufferSize];

    memcpyNoGCRefs( data->configBuffer, buffer, bufferSize );
    data->sizeConfig = (DWORD)bufferSize;

    data->state = (Data::State)(data->state | Data::State::NewConfigFile);

    retval = TRUE;

CLEANUP:
    if (newFileName != NULL)
        delete [] newFileName;

    if (oldFileName != NULL)
        delete [] oldFileName;
        
    return retval;
}

BOOL COMSecurityConfig::EcallRecoverData( _RecoverData* args )
{
    return RecoverData( args->id );
}

BOOL COMSecurityConfig::RecoverData( INT32 id )
{
    Data* data = (Data*)GetData( id );

    BOOL retval = FALSE;

    if (data == NULL)
        return retval;

    DWORD fileNameLength = (DWORD)wcslen( data->configFileName );

    WCHAR* tempFileName = new (nothrow) WCHAR[fileNameLength + 10];
    WCHAR* oldFileName = new (nothrow) WCHAR[fileNameLength + 5];

    if (tempFileName == NULL || oldFileName == NULL)
        return retval;

    wcscpy( tempFileName, data->configFileName );
    wcscpy( &tempFileName[fileNameLength], L".old.temp" );
    wcscpy( oldFileName, data->configFileName );
    wcscpy( &oldFileName[fileNameLength], L".old" );

    HANDLE oldFile = WszCreateFile( oldFileName, 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );        

    if (oldFile == INVALID_HANDLE_VALUE)
    {
        goto CLEANUP;
    }

    CloseHandle( oldFile );

    if (!WszMoveFile( data->configFileName, tempFileName ))
    {
        goto CLEANUP;
    }

    if (!WszMoveFile( oldFileName, data->configFileName ))
    {
        goto CLEANUP;
    }

    if (!WszMoveFile( tempFileName, oldFileName ))
    {
        goto CLEANUP;
    }

    // We need to do some work to reset the unmanaged data object
    // so that the managed side of things behaves like you'd expect.
    // This basically means cleaning up the open resources and
    // doing the work to init on a different set of files.

    data->Reset();
    InitData( data, FALSE );

    retval = TRUE;

CLEANUP:
    if (tempFileName != NULL)
        delete [] tempFileName;

    if (oldFileName != NULL)
        delete [] oldFileName;

    return retval;
}


LPVOID COMSecurityConfig::GetRawData( _GetRawData* args )
{
    Data* data = (Data*)GetData( args->id );

    if (data == NULL)
        return NULL;

    if (data->configData != NULL)
    {
        U1ARRAYREF configData = (U1ARRAYREF)ObjectFromHandle( data->configData );

        if (configData == NULL && ((data->state & Data::State::UsingCacheFile) != 0))
        {
            // Read the config data out of the place it is stored in the cache.
            // Note: we open a new handle to the file to make sure we don't 
            // move the file pointer on the existing handle.

            HANDLE cache = INVALID_HANDLE_VALUE;

            if (data->header.sizeConfig == 0)
            {
                goto EXIT;
            }

            DWORD shareFlags;

            if (GetVersion() < 0x80000000)
            {
                shareFlags = FILE_SHARE_READ | FILE_SHARE_DELETE;
            }
            else
            {
                shareFlags = FILE_SHARE_READ;
            }

            if (!DuplicateHandle( GetCurrentProcess(),
                                  data->cache,
                                  GetCurrentProcess(),
                                  &cache,
                                  0,
                                  FALSE,
                                  DUPLICATE_SAME_ACCESS ))
            {
                _ASSERTE( FALSE && "Unable to duplicate cache file handle" );
                goto EXIT;
            }

            if (cache == INVALID_HANDLE_VALUE)
            {
                _ASSERTE( FALSE && "Unable to duplicate cache file handle, invalid handle" );
                goto EXIT;
            }

            if (SetFilePointer( cache, sizeof( CacheHeader ), NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
            {
                goto EXIT;
            }

            configData = (U1ARRAYREF)AllocateByteArray(data->header.sizeConfig);
            if (configData == NULL)
            {
                goto EXIT;
            }
    
            if (ReadFileData( cache, (PBYTE)(configData->GetDirectPointerToNonObjectElements()), data->header.sizeConfig ) != S_OK)
            {
                configData = NULL;
                goto EXIT;
            }

            StoreObjectInHandle( data->configData, (OBJECTREF)configData );
EXIT:
            if (cache != INVALID_HANDLE_VALUE)
                CloseHandle( cache );
        }

        RETURN( configData, OBJECTREF );
    }
    else
    {
        RETURN( NULL, OBJECTREF );
    }
}


DWORD COMSecurityConfig::EcallGetQuickCacheEntry( _SetGetQuickCacheEntry* args )
{
    return GetQuickCacheEntry( args->id, args->type );
}


DWORD COMSecurityConfig::GetQuickCacheEntry( INT32 id, QuickCacheEntryType type )
{
    Data* data = (Data*)GetData( id );

    if (data == NULL || (data->state & Data::State::UsingCacheFile) == 0)
        return 0;

    return (DWORD)(data->header.quickCache & type);
}

void COMSecurityConfig::EcallSetQuickCache( _SetGetQuickCacheEntry* args )
{
    SetQuickCache( args->id, args->type );
}


void COMSecurityConfig::SetQuickCache( INT32 id, QuickCacheEntryType type )
{
    Data* data = (Data*)GetData( id );

    if (data == NULL)
        return;

    if ((DWORD)type != data->header.quickCache)
    {
        BEGIN_ENSURE_PREEMPTIVE_GC();
        COMSecurityConfig::dataLock_->Enter();
        data->state = (Data::State)(Data::State::CacheUpdated | data->state);
        data->header.quickCache = type;
        COMSecurityConfig::dataLock_->Leave();
        END_ENSURE_PREEMPTIVE_GC();
    }
}

static HANDLE OpenCacheFile( Data* data )
{
    HANDLE retval = NULL;

    BEGIN_ENSURE_PREEMPTIVE_GC();

    COMSecurityConfig::dataLock_->Enter();

    if (data->cache != INVALID_HANDLE_VALUE)
    {
        retval = data->cache;
        goto EXIT;
    }

    _ASSERTE( FALSE && "This case should never happen" );

    data->cache = WszCreateFile( data->cacheFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    
    if (data->cache == INVALID_HANDLE_VALUE)
    {
        goto EXIT;
    }

    // Check whether the cache has changed since we first looked at it.
    // If it has but the config file hasn't, then we need to start fresh.
    // However, if the config file has changed then we have to ignore it.

    if (CacheOutOfDate( &data->cacheFileTime, data->cache, NULL ))
    {
        if (CacheOutOfDate( &data->configFileTime, data->configFileName, NULL ))
        {
            goto EXIT;
        }

        if (ReadFileData( data->cache, (BYTE*)&data->header, sizeof( CacheHeader ) ) != S_OK)
        {
            goto EXIT;
        }

        data->cacheCurrentPosition = sizeof( CacheHeader );

        if (data->oldCacheEntries != NULL)
        {
            ArrayList::Iterator iter = data->oldCacheEntries->Iterate();
    
            while (iter.Next())
            {
                delete (CacheEntry*)iter.GetElement();
            }
    
            delete data->oldCacheEntries;
            data->oldCacheEntries = new ArrayList();
        }
    }

    retval = data->cache;

EXIT:
    COMSecurityConfig::dataLock_->Leave();
    END_ENSURE_PREEMPTIVE_GC();
    return retval;
}

static BYTE* CompareEntry( CacheEntry* entry, DWORD numEvidence, DWORD evidenceSize, BYTE* evidenceBlock, HANDLE cache, DWORD* size)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE (entry);

    if (entry->header.numItemsInKey == numEvidence &&
        entry->header.keySize == evidenceSize)
    {
        if (entry->key == NULL)
        {
            // We were lazy in reading the entry. Read the key now.
            entry->key = new BYTE[entry->header.keySize];
            if (entry->key == NULL)
                COMPlusThrowOM();

            _ASSERTE (cache != INVALID_HANDLE_VALUE);

            if (SetFilePointer( cache, entry->cachePosition, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
                return NULL;

            if (ReadFileData( cache, entry->key, entry->header.keySize ) != S_OK)
                return NULL;

            entry->cachePosition += entry->header.keySize;
        }
        
        _ASSERTE (entry->key);
        
        if (memcmp( entry->key, evidenceBlock, entry->header.keySize ) == 0)
        {
            if (entry->data == NULL)
            {
                // We were lazy in reading the entry. Read the data also.
                entry->data = new BYTE[entry->header.dataSize];

                if (entry->data == NULL)
                    COMPlusThrowOM();

                if (SetFilePointer( cache, entry->cachePosition, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
                    return NULL;

                if (ReadFileData( cache, entry->data, entry->header.dataSize ) != S_OK)
                    return NULL;

                entry->cachePosition += entry->header.dataSize;
            }

            entry->used = TRUE;
            *size = entry->header.dataSize;

            return entry->data;
        }
    }
    return NULL;
}


BOOL COMSecurityConfig::GetCacheEntry( _GetCacheEntry* args )
{
    THROWSCOMPLUSEXCEPTION();

    HANDLE cache = INVALID_HANDLE_VALUE;
    BOOL success = FALSE;
    DWORD size = -1;

    DWORD numEvidence = args->numEvidence;
    DWORD evidenceSize = args->evidence->GetNumComponents() * sizeof( WCHAR );
    BYTE* evidenceBlock = new(throws) BYTE[evidenceSize];
    memcpyNoGCRefs( evidenceBlock, args->evidence->GetDirectPointerToNonObjectElements(), evidenceSize );

    *args->policy = NULL;

    BYTE* retval = NULL;

    Data* data = (Data*)GetData( args->id );

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (data == NULL)
    {
        goto CLEANUP;
    }

    ArrayList::Iterator iter;

    if ((data->state & Data::State::UsingCacheFile) == 0)
    {
        // We know we don't have anything in the config file, so
        // let's just look through the new entries to make sure we
        // aren't getting any repeats.

        // Then try the existing new entries

        iter = data->newCacheEntries->Iterate();

        while (iter.Next())
        {
            // newCacheEntries do not need the cache file so pass in NULL.
            retval = CompareEntry( (CacheEntry*)iter.GetElement(), numEvidence, evidenceSize, evidenceBlock, NULL, &size );

            if (retval != NULL)
            {
                success = TRUE;
                goto CLEANUP;
            }
        }

        goto CLEANUP;
    }

    // Its possible that the old entries were not read in completely
    // so we keep the cache file open before iterating through the
    // old entries.

    cache = OpenCacheFile( data );

    if ( cache == NULL )
    {
        goto CLEANUP;
    }

    // First, iterator over the old entries

    COMSecurityConfig::dataLock_->Enter();

    iter = data->oldCacheEntries->Iterate();

    while (iter.Next())
    {
        retval = CompareEntry( (CacheEntry*)iter.GetElement(), numEvidence, evidenceSize, evidenceBlock, cache, &size );

        if (retval != NULL)
        {
            success = TRUE;
            goto UNLOCKING_CLEANUP;
        }
    }

    COMSecurityConfig::dataLock_->Leave();

    // Then try the existing new entries

    iter = data->newCacheEntries->Iterate();

    while (iter.Next())
    {
        // newCacheEntries do not need the cache file so pass in NULL.
        retval = CompareEntry( (CacheEntry*)iter.GetElement(), numEvidence, evidenceSize, evidenceBlock, NULL, &size );

        if (retval != NULL)
        {
            success = TRUE;
            goto CLEANUP;
        }
    }

    // Finally, try loading existing entries from the file

    COMSecurityConfig::dataLock_->Enter();

    if (SetFilePointer( cache, data->cacheCurrentPosition, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER)
    {
        goto UNLOCKING_CLEANUP;
    }

    do
    {
        CacheEntry* entry = LoadNextEntry( cache, data );

        if (entry == NULL)
        {
            data->state = (Data::State)(Data::State::CacheExhausted | data->state);
            break;
        }

        retval = CompareEntry( entry, numEvidence, evidenceSize, evidenceBlock, cache, &size );

        if (retval != NULL)
        {
            success = TRUE;
            break;
        }
    } while (TRUE);

UNLOCKING_CLEANUP:
    COMSecurityConfig::dataLock_->Leave();

CLEANUP:
    END_ENSURE_PREEMPTIVE_GC();

    delete [] evidenceBlock;

    if (success && retval != NULL)
    {
        _ASSERTE( size != -1 );
        *args->policy = (CHARARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_CHAR, size);
        memcpyNoGCRefs( (*args->policy)->GetDirectPointerToNonObjectElements(), retval, size );
    }

    return success;
}

void COMSecurityConfig::AddCacheEntry( _AddCacheEntry* args )
{
    Data* data = (Data*)GetData( args->id );

    if (data == NULL)
        return;

    // In order to limit how large a long running app can become,
    // we limit the total memory held by the new cache entries list.
    // For now this limit corresponds with how large the max cache file
    // can be.

    DWORD sizeOfEntry = sizeof( WCHAR ) * args->evidence->GetNumComponents() +
                        sizeof( WCHAR ) * args->policy->GetNumComponents() +
                        sizeof( CacheEntryHeader );

    if (data->newEntriesSize + sizeOfEntry >= MAX_CACHEFILE_SIZE)
        return;

    CacheEntry* entry = new(nothrow) CacheEntry();

    if (entry == NULL)
        return;

    entry->header.numItemsInKey = args->numEvidence;
    entry->header.keySize = sizeof( WCHAR ) * args->evidence->GetNumComponents();
    entry->header.dataSize = sizeof( WCHAR ) * args->policy->GetNumComponents();

    entry->key = new(nothrow) BYTE[entry->header.keySize];
    entry->data = new(nothrow) BYTE[entry->header.dataSize];

    if (entry->key == NULL || entry->data == NULL)
    {
        delete entry;
        return;
    }

    memcpyNoGCRefs( entry->key, args->evidence->GetDirectPointerToNonObjectElements(), entry->header.keySize );
    memcpyNoGCRefs( entry->data, args->policy->GetDirectPointerToNonObjectElements(), entry->header.dataSize );

    BEGIN_ENSURE_PREEMPTIVE_GC();
    COMSecurityConfig::dataLock_->Enter();

    // Check the size again to handle the race.

    if (data->newEntriesSize + sizeOfEntry >= MAX_CACHEFILE_SIZE)
    {
        delete entry;
    }
    else
    {
        data->state = (Data::State)(Data::State::CacheUpdated | data->state);
        data->newCacheEntries->Append( entry );
        data->newEntriesSize += sizeOfEntry;
    }

    COMSecurityConfig::dataLock_->Leave();
    END_ENSURE_PREEMPTIVE_GC();
}


DWORD COMSecurityConfig::GetCacheSecurityOn( _GetCacheSecurityOn* args )
{
    Data* data = (Data*)GetData( args->id );

    if (data == NULL)
        return -1;

    return data->header.isSecurityOn;
}


void COMSecurityConfig::SetCacheSecurityOn( _SetCacheSecurityOn* args )
{
    Data* data = (Data*)GetData( args->id );
    
    if (data == NULL)
        return;

    data->state = (Data::State)(Data::State::CacheUpdated | data->state);
    data->header.isSecurityOn = args->value;
}

void COMSecurityConfig::Init( void )
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE( dataLock_ == NULL );

    dataLock_ = ::new Crst( "Security Policy Cache Lock", CrstSecurityPolicyCache, FALSE, FALSE );

    if (dataLock_ == NULL)
        COMPlusThrowOM();
}

void COMSecurityConfig::Cleanup( void )
{
    ArrayList::Iterator iter = entries_.Iterate();

    COMSecurityConfig::dataLock_->Enter();

    while (iter.Next())
    {
        ((Data*) iter.GetElement())->Cleanup();
    }

	COMSecurityConfig::dataLock_->Leave();
}

void COMSecurityConfig::Delete( void )
{
    ArrayList::Iterator iter = entries_.Iterate();

    while (iter.Next())
    {
        delete (Data*) iter.GetElement();
    }

    if (dataLock_ != NULL)
    {
        ::delete dataLock_;
        dataLock_ = NULL;
    }
}

LPVOID COMSecurityConfig::EcallGenerateFilesAutomatically( _NoArgs* )
{
	if (configCreated_)
	{
		RETURN( FALSE, BOOL );
	}

	// There is no need to synchronize here as returning true twice
	// is acceptable since they would produce the same result.

	configCreated_ = TRUE;

    RETURN( !(SystemDomain::GetCurrentDomain()->IsCompilationDomain() || (g_pConfig && g_pConfig->RequireZaps())), BOOL );
}

LPVOID COMSecurityConfig::EcallGetMachineDirectory( _NoArgs* )
{
    WCHAR machine[MAX_PATH];
    size_t machineCount = MAX_PATH;

    BOOL result = GetMachineDirectory( machine, machineCount );

    _ASSERTE( result );
    _ASSERTE( wcslen( machine ) != 0 );

    OBJECTREF machineObj;
    
    if (result)
        machineObj = (OBJECTREF)COMString::NewString( machine );
    else
        machineObj = NULL;

    RETURN( machineObj, OBJECTREF );
}

LPVOID COMSecurityConfig::EcallGetUserDirectory( _NoArgs* )
{
    WCHAR user[MAX_PATH];
    size_t userCount = MAX_PATH;

    BOOL result = GetUserDirectory( user, userCount, FALSE );

    OBJECTREF userObj;
    
    if (result)
        userObj = (OBJECTREF)COMString::NewString( user );
    else
        userObj = NULL;
    

    RETURN( userObj, OBJECTREF );
}

#define SHIMDLL L"mscoree.dll"
#define SHIMFUNCNAME "GetCORSystemDirectory"
typedef HRESULT (WINAPI *SHIMFUNC)( LPWSTR pbuffer, DWORD cchBuffer, DWORD* dwlength );

BOOL COMSecurityConfig::GetMachineDirectory( WCHAR* buffer, size_t bufferCount )
{
    DWORD length;
    SHIMFUNC lpShimFunc;
    BOOL retval = FALSE;
    
    HMODULE hModule = WszGetModuleHandle( SHIMDLL );
        
    if (hModule == NULL)
    {
        _ASSERTE(!"Unable to load shim!" );
        goto CLEANUP;
    }
        
    lpShimFunc = (SHIMFUNC)GetProcAddress( hModule, SHIMFUNCNAME );
        
    if (lpShimFunc == NULL)
    {
        goto CLEANUP;
    }

    if (FAILED(lpShimFunc( buffer, (DWORD)bufferCount, &length )))
    {
        goto CLEANUP;
    }

    // Make sure we have enough buffer to concat the string.
    // Note the length including the terminating zero. 
    if( (bufferCount - wcslen(buffer) - 1) < wcslen(L"config\\") )
    	goto CLEANUP;
    
    wcscat( buffer, L"config\\" );

    retval = TRUE;

CLEANUP:

    return retval;;
}


BOOL COMSecurityConfig::GetUserDirectory( WCHAR* buffer, size_t bufferCount, BOOL fTryDefault )
{
    WCHAR scratchBuffer[MAX_PATH];
    DWORD size = MAX_PATH;
    BOOL retval = FALSE;
    DWORD dwBufferCount = (DWORD)bufferCount;

    // If we're on NT, 2K, or Whister, call GetUserDir()
    // On 9x/ME we build our own directory.

    if (GetVersion() < 0x80000000)
    {
	    if (!GetUserDir(buffer, bufferCount, TRUE, fTryDefault))
            goto CLEANUP;
    }
    else
    {
        DWORD nRet = WszGetWindowsDirectory( buffer, (UINT)bufferCount );
        if (nRet == 0 || nRet > bufferCount)
        {
            _ASSERTE(!"WszGetWindowsDirectory didn't work right!");
            goto CLEANUP;
        }

        if (!WszGetUserName( scratchBuffer, &size ))
        {
            wcscpy( scratchBuffer, L"DefaultUser" );
            size = (DWORD)wcslen( L"DefaultUser" );
            goto CLEANUP;
        }

        if (bufferCount < wcslen( buffer ) + size + 1)
        {
            goto CLEANUP;
        }

        wcscat( buffer, L"\\" );
        wcscat( buffer, scratchBuffer );
    }

    wcscpy( scratchBuffer, L"\\Microsoft\\CLR Security Config\\v" );
    wcscat( scratchBuffer, VER_SBSFILEVERSION_WSTR );
    wcscat( scratchBuffer, L"\\" );

    if (bufferCount < wcslen( buffer ) + wcslen( scratchBuffer ) + 1)
    {
        goto CLEANUP;
    }

    wcscat( buffer, scratchBuffer );

    retval = TRUE;

CLEANUP:
    return retval;
}      

#define REPORTEVENTDLL L"advapi32.dll"
#define REPORTEVENTFUNCNAME "ReportEventW"
typedef BOOL (WINAPI *REPORTEVENTFUNC)( HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCTSTR *lpStrings, LPVOID lpRawData );

WCHAR dotNetRuntimeHeader[] = L".NET Runtime version ";
WCHAR dotNetRuntimeFooter[] = L" - ";

BOOL COMSecurityConfig::WriteToEventLog( WCHAR* message )
{
    _ASSERTE( message != NULL );

    DWORD dwVersion = GetVersion();
    HANDLE h; 
    BOOL retval = FALSE;

    if (dwVersion >= 0x80000000)
    {
        return FALSE;
    }


    h = RegisterEventSourceA(NULL,  // uses local computer 
             ".NET Runtime");           // source name 

 
    if (h != NULL)
    {
        HMODULE hModule = WszLoadLibrary( REPORTEVENTDLL );
            
        if (hModule == NULL)
        {
            DeregisterEventSource(h);
            return FALSE;
        }
            
        REPORTEVENTFUNC lpReportEventFunc = (REPORTEVENTFUNC)GetProcAddress( hModule, REPORTEVENTFUNCNAME );
            
        if (lpReportEventFunc == NULL)
        {
            DeregisterEventSource(h);
            FreeLibrary( hModule );
            return FALSE;
        }

        // Now append on the version information.
        Assembly* assembly = SystemDomain::SystemAssembly();

        if (assembly != NULL && assembly->m_Context != NULL)
        {

            // We need a buffer that is long enough to fit:
            // 1. the message (wcslen( message ))
            // 2. the runtime header statement (wcslen( dotNetRuntimeHeader ))
            // 3. 4 dwords for the version (4 * MAX_NUM_LENGTH)
            // 4. 3 periods to separate version numbers (3)
            // 5. the runtime footer statement (wcslen( dotNetRuntimeFooter ))
            // 6. trailing null (1)

            size_t scratchBufferSize = wcslen( message ) + wcslen( dotNetRuntimeHeader ) + 4 * MAX_NUM_LENGTH + 3 + wcslen( dotNetRuntimeFooter ) + 1;

            WCHAR* scratchBuffer = new (nothrow) WCHAR[scratchBufferSize];

            if (scratchBuffer != NULL)
            {
                wcscpy( scratchBuffer, dotNetRuntimeHeader );
                wcscat( scratchBuffer, VER_FILEVERSION_WSTR );
                wcscat( scratchBuffer, dotNetRuntimeFooter );
                wcscat( scratchBuffer, message );

                _ASSERTE( wcslen( scratchBuffer ) + 1 <= scratchBufferSize );
    
                retval = lpReportEventFunc(
                        h,                                        // event log handle 
                        EVENTLOG_WARNING_TYPE,                    // event type 
                        0,                                        // category zero 
                        (DWORD)1000,                              // event identifier 
                        NULL,                                     // no user security identifier 
                        1,                                        // one substitution string 
                        0,                                        // no data 
                        (LPCWSTR *)&scratchBuffer,                // pointer to string array 
                        NULL);                                    // pointer to data 

                delete [] scratchBuffer;
            }
        }
        else
        {
            _ASSERTE(!"Assembly does not exist or it does not have context");
        }
            
        DeregisterEventSource( h );

        FreeLibrary( hModule );

    }
             
    return retval;
}


BOOL COMSecurityConfig::EcallWriteToEventLog( _WriteToEventLog* args )
{
    static WCHAR messageBuf[1024];
    static WCHAR* message;

    BOOL retval = FALSE;
   
    BEGIN_ENSURE_COOPERATIVE_GC();

    if (args->message->GetStringLength() >= 1024)
    {
        message = new (nothrow) WCHAR[args->message->GetStringLength() + 1];
    }
    else
    {
        message = messageBuf;
    }

    END_ENSURE_COOPERATIVE_GC();

    if (message == NULL)
        return retval;

    wcscpy( message, args->message->GetBuffer() );

    retval = WriteToEventLog( message );

    if (message != messageBuf)
    {
        delete [] message;
    }

    return retval;
}


LPVOID COMSecurityConfig::EcallGetStoreLocation( _GetStoreLocation* args )
{
    WCHAR path[MAX_PATH];
    size_t pathCount = MAX_PATH;

    BOOL result = GetStoreLocation( args->id, path, pathCount );

    _ASSERTE( result );
    _ASSERTE( wcslen( path ) != 0 );

    OBJECTREF pathObj;
    
    if (result)
        pathObj = (OBJECTREF)COMString::NewString( path );
    else
        pathObj = NULL;

    RETURN( pathObj, OBJECTREF );
}

BOOL COMSecurityConfig::GetStoreLocation( INT32 id, WCHAR* buffer, size_t bufferCount )
{
    Data* data = (Data*)GetData( id );

    if (data == NULL)
        return FALSE;

    if (wcslen( data->configFileName ) > bufferCount - 1)
        return FALSE;

    wcscpy( buffer, data->configFileName );

    return TRUE;
}


void COMSecurityConfig::EcallTurnCacheOff( _TurnCacheOff* args )
{
    AppDomain* pDomain;
    Assembly* callerAssembly = SystemDomain::GetCallersAssembly( (StackCrawlMark*)args->stackmark, &pDomain );

    _ASSERTE( callerAssembly != NULL);

    ApplicationSecurityDescriptor* pSecDesc = pDomain->GetSecurityDescriptor();

    _ASSERTE( pSecDesc != NULL );

    pSecDesc->DisableQuickCache();
}


LPVOID __stdcall COMSecurityConfig::DebugOut( _DebugOut* args )
{
    THROWSCOMPLUSEXCEPTION();
    
    HANDLE file = VMWszCreateFile( args->file, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if (file == INVALID_HANDLE_VALUE)
    {
        RETURN(E_FAIL, DWORD);
    }
    
    SetFilePointer( file, 0, NULL, FILE_END );
    
    DWORD bytesWritten;
    
    if (!WriteFile( file, args->message->GetBuffer(), args->message->GetStringLength() * sizeof(WCHAR), &bytesWritten, NULL ))
    {
        CloseHandle( file );
        RETURN(E_FAIL,DWORD);
    }
    
    if (args->message->GetStringLength() * sizeof(WCHAR) != bytesWritten)
    {
        CloseHandle( file );
        RETURN(E_FAIL, DWORD);
    }
    
    CloseHandle( file );
    
    RETURN( S_OK, DWORD );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comreflectioncommon.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Author: Simon Hall (t-shall)
// Date: April 15, 1998
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "ReflectWrap.h"
#include "COMReflectionCommon.h"
#include "COMMember.h"
#include "ReflectUtil.h"
#include "field.h"

#include "wsperf.h"

#define TABLESIZE 29
extern const DWORD g_rgPrimes[];

// CheckVisibility
// This is an internal routine that will check an accessor list for public visibility
static bool CheckVisibility(EEClass* pEEC,IMDInternalImport *pInternalImport, mdToken event);

static bool IsMemberStatic(EEClass* pEEC,IMDInternalImport *pInternalImport, mdToken event);

// getNode
// The method will return a new Node object.
ReflectBaseHash::Node* ReflectBaseHash::getNode()
{
    THROWSCOMPLUSEXCEPTION();

    // If nothing in the free list create some new nodes
    if (!_freeList) {
        Node* p = (Node*) _pBaseDomain->GetReflectionHeap()->AllocMem(sizeof(Node) * ALLOC_MAX);
        if (!p)
            COMPlusThrowOM();
        
        WS_PERF_UPDATE_DETAIL("ReflectBaseHash:getNode", sizeof(Node)*ALLOC_MAX, p);

        if (!_allocationList)
            _allocationList = p;
        else {
            Node* q = _allocationList;
            while (q->next)
                q = q->next;
            q->next = p;
        }
        _freeList = &p[1];
        for (int i=1;i<ALLOC_MAX-1;i++)
            p[i].next = &p[i+1];
        p[ALLOC_MAX-1].next = 0;
    }
    // return the first entry in the first list
    Node* p = _freeList;
    _freeList = _freeList->next;
    return p;
}

// init
// Allocate the hash table using size as an approx
//  value for the table size.
bool ReflectBaseHash::init(BaseDomain *pDomain, DWORD size) 
{
    _pBaseDomain = pDomain;
    DWORD i = 0;
    int cBytes; 
    while (g_rgPrimes[i] < size) i++;
    _hashSize = g_rgPrimes[i];
    cBytes = sizeof(Node) * _hashSize; 
    _table = (Node**) _pBaseDomain->GetReflectionHeap()->AllocMem(cBytes);
    if (!_table)
        return false;
    memset(_table,0,cBytes);
    WS_PERF_UPDATE_DETAIL("ReflectBaseHash:node*hashSize", cBytes, _table);
    return true;
}

void ReflectBaseHash::internalAdd(const void* key, void* data)
{
    DWORD bucket = getHash(key);
    bucket %= _hashSize;
    // Get node will throw an exception if it fails
    Node* p = getNode();
    p->data = data;
    p->next = _table[bucket];
    _table[bucket] = p;     
}

void* ReflectBaseHash::operator new(size_t s, void *pBaseDomain)
{
    void *pTmp;
    WS_PERF_SET_HEAP(REFLECT_HEAP);    
    pTmp = ((BaseDomain*)pBaseDomain)->GetReflectionHeap()->AllocMem(s);
    WS_PERF_UPDATE_DETAIL("ReflectBaseHash:refheap new", s, pTmp);
    return pTmp;
}

void ReflectBaseHash::operator delete(void* p, size_t s)
{
    _ASSERTE(!"Delete in Loader Heap");
}

//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

/*=============================================================================
** GetMaxCount
**
** The maximum number of MethodDescs that might be returned by GetCtors
**
** pVMC - the EEClass to calculate the count for
**/
DWORD ReflectCtors::GetMaxCount(EEClass* pVMC)
{
    return pVMC->GetNumMethodSlots();
}

/*=============================================================================
** GetCtors
**
** This will compile a table that includes all of the implemented and
** inherited methods for a class that are not included in the class' Vtable.
**
** pVMC - the EEClass to get the methods for
** rgpMD - where to write the table
** bImplementedOnly - only return those methods that are implemented by pVMC
**/
ReflectMethodList* ReflectCtors::GetCtors(ReflectClass* pRC)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass*        pVMC = pRC->GetClass();
    DWORD           i;
    DWORD           dwCurIndex;
    MethodDesc**    rgpMD;

    //_ASSERTE(!pVMC->IsThunking());

    // Get the maximum number of methods possible
    dwCurIndex = ReflectCtors::GetMaxCount(pVMC);

    // Allocate array on the stack
    rgpMD = (MethodDesc**) _alloca(sizeof(MethodDesc*) * dwCurIndex);
    DWORD dwCurMethodAttrs;

    for(i = 0, dwCurIndex = 0; i < pVMC->GetNumMethodSlots(); i++)
    {
        // Get the MethodDesc for current method
        MethodDesc* pCurMethod = pVMC->GetUnknownMethodDescForSlot(i);
        if (pCurMethod == NULL)
            continue;

        dwCurMethodAttrs = pCurMethod->GetAttrs();

        if(!IsMdRTSpecialName(dwCurMethodAttrs))
            continue;

        // Check to see that this ctor is defined in current class
        if (pVMC != pCurMethod->GetClass())
            continue;

        // Verify the constructor
        LPCUTF8 szName = pCurMethod->GetName();
        if (strcmp(COR_CTOR_METHOD_NAME,szName) != 0 &&
            strcmp(COR_CCTOR_METHOD_NAME,szName) != 0)
            continue;


        rgpMD[dwCurIndex++] = pCurMethod;
    }

    ReflectMethodList* pCache = (ReflectMethodList*) 
        pVMC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectMethodList) + 
        (sizeof(ReflectMethod) * (dwCurIndex - 1)));
    if (!pCache)
        COMPlusThrowOM();
    WS_PERF_UPDATE_DETAIL("ReflectCtors:GetCTors", sizeof(ReflectMethodList) + (sizeof(ReflectMethod) * (dwCurIndex - 1)), pCache);
    pCache->dwMethods = dwCurIndex;
    pCache->dwTotal = dwCurIndex;
    for (i=0;i<dwCurIndex;i++) {
        pCache->methods[i].pMethod = rgpMD[i];
        pCache->methods[i].szName = pCache->methods[i].pMethod->GetName((USHORT) i);
        pCache->methods[i].dwNameCnt = (DWORD)strlen(pCache->methods[i].szName);
        pCache->methods[i].attrs = pCache->methods[i].pMethod->GetAttrs();
        pCache->methods[i].pSignature = 0;
        pCache->methods[i].pNext = 0;
        if (i > 0) 
            pCache->methods[i - 1].pNext = &pCache->methods[i]; // link the ctors together so we can access them either way (array or list)
        pCache->methods[i].pIgnNext = 0;
        pVMC->GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pCache->methods[i].pMethodObj));
        _ASSERTE(!pCache->methods[i].pMethod->GetMethodTable()->HasSharedMethodTable());
        pCache->methods[i].typeHnd = TypeHandle(pCache->methods[i].pMethod->GetMethodTable());
    }
    return pCache;
}

//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

// GetMaxCount
// Get the total possible methods that we may support.
DWORD ReflectMethods::GetMaxCount(EEClass* pEEC)
{
    // We walk only the Method slots on the object itself and ignore
    //  all parents.
    DWORD cnt = pEEC->GetNumMethodSlots();
    pEEC = pEEC->GetParentClass();
    while (pEEC) {
        DWORD vtableSlots = pEEC->GetNumVtableSlots();
        DWORD totalSlots = pEEC->GetNumMethodSlots();
        cnt += totalSlots - vtableSlots;
        pEEC = pEEC->GetParentClass();
    }
    return cnt;
}

// GetMethods
// This method will return the list of all methods associated with
//  the class
ReflectMethodList* ReflectMethods::GetMethods(ReflectClass* pRC,int array)
{
    THROWSCOMPLUSEXCEPTION();

    int             i;
    DWORD           dwCurIndex;
    DWORD           dwNonRollup;
    MethodDesc**    rgpMD;
    USHORT*         rgpSlots;
    DWORD           bValueClass;
    HashElem**      rgpTable;
    HashElem*       pHashElem = NULL;

    EEClass*        pEEC = pRC->GetClass();

    // Get the maximum number of methods possible
    //  NOTE: All classes will have methods.
    dwCurIndex = ReflectMethods::GetMaxCount(pEEC);

    // Allocate array on the stack
    // We need to remember the slot number here also.
    rgpMD = (MethodDesc**) _alloca(sizeof(MethodDesc*) * dwCurIndex);
    rgpSlots = (USHORT*) _alloca(sizeof(USHORT) * dwCurIndex);
    ZeroMemory(rgpSlots,sizeof(USHORT) * dwCurIndex);

    // Allocate the hash table on the stack
    rgpTable = (HashElem**) _alloca(sizeof(HashElem*) * TABLESIZE);
    ZeroMemory(rgpTable, sizeof(HashElem*) * TABLESIZE);

    DWORD dwCurMethodAttrs;
    BOOL fIsInterface = pEEC->IsInterface();

    bValueClass = pEEC->IsValueClass();
    DWORD vtableSlots = pEEC->GetNumVtableSlots();
    DWORD totalSlots = pEEC->GetNumMethodSlots();

    // It is important for newslot support that the order we add the methods 
    // to the hashtable be:
    //  1- Virtual methods first.
    //  2- Non virtuals on the current class.
    //  3- Non virtuals on the base classes.

    // We walk the VTable slots backward.  This is so that we can find the most
    //  recent thing so we can implement hide by name or hide by name/value
    dwCurIndex = 0;
    for (i=(int)vtableSlots-1;i >= 0; i--) {

        // Get the MethodDesc for current method
        //  Is the special case still valid?  Can we have empty slots?
        MethodDesc* pCurMethod = pEEC->GetUnknownMethodDescForSlot(i);
        if (NULL == pCurMethod)
            continue;

        if(pCurMethod->IsDuplicate()) {
            if (pCurMethod->GetSlot() != i)
                continue;
        }

        dwCurMethodAttrs = pCurMethod->GetAttrs();

        // Skip pass all things marked special, these are things like
        // constructors.
        if (IsMdRTSpecialName(dwCurMethodAttrs))
            continue;

        // Passed the filters, now try to add to the hash table.
        // Allocate memory on the stack if the previous addelem was successful
        if(!pHashElem)
            pHashElem = (HashElem*) _alloca(sizeof(HashElem));

        // Save this method and the slot.
        if (InternalHash(pEEC,pCurMethod,rgpTable,&pHashElem)) {
            rgpSlots[dwCurIndex] = i;
            rgpMD[dwCurIndex++] = pCurMethod;
        }
    }

    // build the non-virtual part of the table
    for (i=(int)vtableSlots;i<(int)totalSlots;i++) {
        // Get the MethodDesc for current method
        MethodDesc* pCurMethod = pEEC->GetUnknownMethodDescForSlot(i);
        if(pCurMethod == NULL)
            continue;

        // Filter out methods whose actual slot is not equal to their
        // stored slot.  This was introduced to filter out the additional
        // copy of Equals introduced by the value type Equals loader hack.
        if (pCurMethod->GetSlot() != i)
            continue;

        dwCurMethodAttrs = pCurMethod->GetAttrs();
        if (bValueClass) {
            if (pCurMethod->IsVirtual())
                continue;
        }
            //if (!pCurMethod->IsUnboxingStub() && !pCurMethod->IsStatic() && 
            //  !pCurMethod->IsPrivate() && pCurMethod->GetClass() == pEEC)
            //  continue;

        // Skip all constructors
        //@TODO: Shouldn't we verify this is a constructor?
        if(IsMdRTSpecialName(dwCurMethodAttrs))
            continue;

        // Passed the filters, now try to add to the hash table.
        // Allocate memory on the stack if the previous addelem was successful
        if(!pHashElem)
            pHashElem = (HashElem*) _alloca(sizeof(HashElem));

        if (InternalHash(pEEC,pCurMethod,rgpTable,&pHashElem)) {
            rgpSlots[dwCurIndex] = i;
            rgpMD[dwCurIndex++] = pCurMethod;
        }
    }

    // Now get all of the public and family non-virtuals out
    //  of our parents...
    // If we are building an interface we skip all the parent methods.
    if (!fIsInterface) {
        EEClass* parentEEC = pEEC->GetParentClass();
        while (parentEEC) {
            vtableSlots = parentEEC->GetNumVtableSlots();
            totalSlots = parentEEC->GetNumMethodSlots();
            // build the non-virtual part of the table
            for (i=(int)vtableSlots;i<(int)totalSlots;i++) {
                // Get the MethodDesc for current method
                MethodDesc* pCurMethod = parentEEC->GetUnknownMethodDescForSlot(i);
                if(pCurMethod == NULL)
                    continue;

                // Filter out methods whose actual slot is not equal to their
                // stored slot.  This was introduced to filter out the additional
                // copy of Equals introduced by the value type Equals loader hack.
                if (pCurMethod->GetSlot() != i)
                    continue;

                dwCurMethodAttrs = pCurMethod->GetAttrs();
                if (!IsMdPublic(dwCurMethodAttrs)) {
                    if (!(IsMdFamANDAssem(dwCurMethodAttrs) || IsMdFamily(dwCurMethodAttrs) ||
                            IsMdFamORAssem(dwCurMethodAttrs)))
                        continue;
                }

                // Skip all constructors
                //@TODO: Shouldn't we verify this is a constructor?
                if(IsMdRTSpecialName(dwCurMethodAttrs))
                    continue;

                // Prevent static methods from being here.
                if (IsMdStatic(dwCurMethodAttrs))
                    continue;

                // Passed the filters, now try to add to the hash table.
                // Allocate memory on the stack if the previous addelem was successful
                if(!pHashElem)
                    pHashElem = (HashElem*) _alloca(sizeof(HashElem));

                if (InternalHash(parentEEC,pCurMethod,rgpTable,&pHashElem)) {
                    rgpSlots[dwCurIndex] = i;
                    rgpMD[dwCurIndex++] = pCurMethod;
                }
            }
            parentEEC = parentEEC->GetParentClass();
        }
        dwNonRollup = dwCurIndex;


        // Calculate the rollup for statics.
        parentEEC = pEEC->GetParentClass();
        while (parentEEC) {
            vtableSlots = parentEEC->GetNumVtableSlots();
            totalSlots = parentEEC->GetNumMethodSlots();
            // build the non-virtual part of the table
            for (i=(int)vtableSlots;i<(int)totalSlots;i++) {
                // Get the MethodDesc for current method
                MethodDesc* pCurMethod = parentEEC->GetUnknownMethodDescForSlot(i);
                if (pCurMethod == NULL)
                    continue;

                // Filter out methods whose actual slot is not equal to their
                // stored slot.  This was introduced to filter out the additional
                // copy of Equals introduced by the value type Equals loader hack.
                if (pCurMethod->GetSlot() != i)
                    continue;

                // Prevent static methods from being here.
                dwCurMethodAttrs = pCurMethod->GetAttrs();
                if (!IsMdStatic(dwCurMethodAttrs))
                    continue;

                if (!IsMdPublic(dwCurMethodAttrs)) {
                    if (!(IsMdFamANDAssem(dwCurMethodAttrs) || IsMdFamily(dwCurMethodAttrs) ||
                            IsMdFamORAssem(dwCurMethodAttrs)))
                        continue;
                }

                // Skip all constructors
                //@TODO: Shouldn't we verify this is a constructor?
                if(IsMdRTSpecialName(dwCurMethodAttrs))
                    continue;

                // Passed the filters, now try to add to the hash table.
                // Allocate memory on the stack if the previous addelem was successful
                if(!pHashElem)
                    pHashElem = (HashElem*) _alloca(sizeof(HashElem));

                if (InternalHash(parentEEC,pCurMethod,rgpTable,&pHashElem)) {
                    rgpSlots[dwCurIndex] = i;
                    rgpMD[dwCurIndex++] = pCurMethod;
                }
            }
            parentEEC = parentEEC->GetParentClass();
        }
    }
    else {
        dwNonRollup = dwCurIndex;
    }
    // Allocate the method list and populate it.
    ReflectMethodList* pCache = (ReflectMethodList*) 
        pEEC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectMethodList) + 
        (sizeof(ReflectMethod) * (dwCurIndex - 1)));
    if (!pCache)
        COMPlusThrowOM();
    WS_PERF_UPDATE_DETAIL("ReflectCtors:GetMethods", sizeof(ReflectMethodList) + (sizeof(ReflectMethod) * (dwCurIndex - 1)), pCache);

    pCache->dwMethods = dwNonRollup;
    pCache->dwTotal = dwCurIndex;
    for (i=0;i<(int)dwCurIndex;i++) {
        pCache->methods[i].pMethod = rgpMD[i];
        pCache->methods[i].szName = pCache->methods[i].pMethod->GetName(rgpSlots[i]);
        pCache->methods[i].dwNameCnt = (DWORD)strlen(pCache->methods[i].szName);
        pCache->methods[i].attrs = pCache->methods[i].pMethod->GetAttrs();
        pCache->methods[i].dwFlags = 0;
        pCache->methods[i].pSignature = 0;
        pCache->methods[i].pNext = 0;
        pCache->methods[i].pIgnNext = 0;
        pEEC->GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pCache->methods[i].pMethodObj));
        if (!array) 
            pCache->methods[i].typeHnd = TypeHandle(pCache->methods[i].pMethod->GetMethodTable());
        else
            pCache->methods[i].typeHnd = TypeHandle();
    }
    pCache->hash.Init(pCache);

    return pCache;
}

// InternalHash
// This will add a field value to the hash table
bool ReflectMethods::InternalHash(EEClass* pEEC,MethodDesc* pCurMethod,
        HashElem** rgpTable,HashElem** pHashElem)
{

    ZeroMemory(*pHashElem,sizeof(HashElem));
    (*pHashElem)->m_szKey = pCurMethod->GetName();
    (*pHashElem)->pCurMethod = pCurMethod;

    // Add the FieldDesc to the array
    if (AddElem(rgpTable, *pHashElem))
    {
        // If successful add, then indicate that more memory is needed on the stack
        // on the next time around.
        *pHashElem = NULL;
        return true;
    }
    return false;
}

// Add an element to the hash table.  
bool ReflectMethods::AddElem(HashElem** rgpTable, HashElem* pElem)
{
    _ASSERTE(rgpTable);
    _ASSERTE(pElem);

    DWORD      dwID       = GetHashCode(pElem);
    DWORD      dwBucket   = dwID % TABLESIZE;
    HashElem** ppCurElem;

    for(ppCurElem = &rgpTable[dwBucket]; *ppCurElem; ppCurElem = &((*ppCurElem)->m_pNext))
    {
        // If their IDs match, check to see if the actual keys
        if((*ppCurElem)->m_dwID == dwID)
        {
            // This assert will enforce the rule that all virtual methods must be
            // added before any non virtual methods.
            _ASSERTE((*ppCurElem)->pCurMethod->IsVirtual() || !pElem->pCurMethod->IsVirtual());

            if (CheckForEquality(pElem,*ppCurElem))
            {
                // Check to see if this is an overriden method or a newslot method.
                if ((*ppCurElem)->pCurMethod->IsVirtual() && 
                    pElem->pCurMethod->IsVirtual() && 
                    !IsMdNewSlot(pElem->pCurMethod->GetAttrs()))
                {
                    return false;
                }
            }
        }
    }

    *ppCurElem = pElem;
    pElem->m_dwID = dwID;
    pElem->m_pNext = NULL;
    return true;
}

DWORD ReflectMethods::GetHashCode(HashElem* pElem)
{
    DWORD dwHashCode = 0;

    // Hash all of the same name into the same bucket.
    if (pElem->m_szKey) {
        const char* p = pElem->m_szKey;
        while (*p) {
            dwHashCode = _rotl(dwHashCode, 5) + *p;
            p++;
        }
    }
    return dwHashCode;
};

int ReflectMethods::CheckForEquality(HashElem* p1, HashElem* p2)
{
    if (p1->m_szKey) {
        if (!p2->m_szKey)
            return 0;
        if (strcmp(p1->m_szKey,p2->m_szKey) != 0)
            return 0;
    }

    // Compare the signatures to see if they are equal.
    PCCOR_SIGNATURE  pP1Sig;
    PCCOR_SIGNATURE  pP2Sig;
    DWORD            cP1Sig;
    DWORD            cP2Sig;
    
    p1->pCurMethod->GetSig(&pP1Sig, &cP1Sig);
    p2->pCurMethod->GetSig(&pP2Sig, &cP2Sig);
    return MetaSig::CompareMethodSigs(pP1Sig,cP1Sig,p1->pCurMethod->GetModule(),
            pP2Sig,cP2Sig,p2->pCurMethod->GetModule());
};

//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

// GetMaxCount
// Calculate the maximum amount of fields we would have
DWORD ReflectFields::GetMaxCount(EEClass* pVMC)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pVMC);

    // Set it to zero
    DWORD cFD = 0;

    cFD = pVMC->GetNumInstanceFields();

    do
    {
        cFD += pVMC->GetNumStaticFields();
        cFD += g_pRefUtil->GetStaticFieldsCount(pVMC);
    } while((pVMC = pVMC->GetParentClass()) != NULL);

    return cFD;
}

// GetFields
// This method will return all of the methods defined for a Type.
//  It basically walks the EEClas looking at the fields and then walks
//  up the parent chain for the protected and publics.  We hide fields
//  based upon Name/Type.
ReflectFieldList* ReflectFields::GetFields(EEClass* pEEC)
{
    THROWSCOMPLUSEXCEPTION();

    HashElem**  rgpTable;
    HashElem*   pHashElem = NULL;
    LPUTF8      pszKey    = NULL;
    DWORD       i;
    DWORD       dwCurIndex  = 0;
    DWORD       dwRealFields;
    DWORD       dwNumParentInstanceFields = 0;
    EEClass*    pCurEEC = pEEC;

    // Get the maximum number of methods possible
    // If there are non-then we return
    dwCurIndex = ReflectFields::GetMaxCount(pEEC);
    if (dwCurIndex == 0)
        return 0;

    DWORD curFld = 0;
    FieldDesc** pFldLst = (FieldDesc**) _alloca(sizeof(FieldDesc*) * dwCurIndex);

    // Allocate the hash table on the stack
    rgpTable = (HashElem**) _alloca(sizeof(HashElem*) * TABLESIZE);
    ZeroMemory(rgpTable, sizeof(HashElem*) * TABLESIZE);

    // Process the Class itself

    // Since the parent's instance fields are not stored in the current fielddesc list,
    // we need to subtract them to find the real number of fields in the list
    if(pEEC->GetParentClass() != NULL)
        dwNumParentInstanceFields = (DWORD) pEEC->GetParentClass()->GetNumInstanceFields();
    else
        dwNumParentInstanceFields = 0;

    {
    FieldDescIterator fdIterator(pEEC, FieldDescIterator::INSTANCE_FIELDS);
    FieldDesc* pCurField;

    while ((pCurField = fdIterator.Next()) != NULL)
    {
        // Passed the filters, now try to add to the hash table.
        // Allocate memory on the stack if the previous addelem was successful
        if(!pHashElem)
            pHashElem = (HashElem*) _alloca(sizeof(HashElem));

        // Add all fields to the hash table and the list
        if (InternalHash(pCurField,rgpTable,&pHashElem))
            pFldLst[curFld++] = pCurField;
    }
    }

    // Add the static fields
    if (pCurEEC->GetParentClass() != NULL)
        dwNumParentInstanceFields = (DWORD) pCurEEC->GetParentClass()->GetNumInstanceFields();
    else
        dwNumParentInstanceFields = 0;

    {
    // Calculate the number of FieldDesc's in the current class
    FieldDescIterator fdIterator(pCurEEC, FieldDescIterator::STATIC_FIELDS);
    FieldDesc* pCurField;

    while ((pCurField = fdIterator.Next()) != NULL)
    {
        if(!pHashElem)
            pHashElem = (HashElem*) _alloca(sizeof(HashElem));

        if (InternalHash(pCurField,rgpTable,&pHashElem))
        {
            _ASSERTE(pCurField);
            pFldLst[curFld++] = pCurField;
        }
    }
    }

    // The following are the constant statics.  These are only found
    //  in the meta data.
    int cStatics;
    REFLECTCLASSBASEREF pRefClass = (REFLECTCLASSBASEREF) pCurEEC->GetExposedClassObject();
    ReflectClass* pRC = (ReflectClass*) pRefClass->GetData();
    FieldDesc* fld = g_pRefUtil->GetStaticFields(pRC,&cStatics);
    for (i=0;(int)i<cStatics;i++) {
        if(!pHashElem)
            pHashElem = (HashElem*) _alloca(sizeof(HashElem));
        // Get the FieldDesc for current field
        FieldDesc* pCurField = &fld[i];
        if (InternalHash(pCurField,rgpTable,&pHashElem)){
            _ASSERTE(pCurField);
            pFldLst[curFld++] = pCurField;
        }
    }

    // Now process the parent class...

    // If we're not looking for Ctors, then examine parent chain for inherited static fields
    pEEC = pCurEEC->GetParentClass();
    while (pEEC)
    {
        // Since the parent's instance fields are not stored in the current fielddesc list,
        // we need to subtract them to find the real number of fields in the list
        if(pEEC->GetParentClass() != NULL)
            dwNumParentInstanceFields = (DWORD) pEEC->GetParentClass()->GetNumInstanceFields();
        else
            dwNumParentInstanceFields = 0;

        FieldDescIterator fdIterator(pEEC, FieldDescIterator::INSTANCE_FIELDS);
        FieldDesc* pCurField;

        while ((pCurField = fdIterator.Next()) != NULL)
        {
            // Passed the filters, now try to add to the hash table.
            // Allocate memory on the stack if the previous addelem was successful
            if(!pHashElem)
                pHashElem = (HashElem*) _alloca(sizeof(HashElem));

            // IF the field is visiable add it (if its not hidden)
            DWORD attr = pCurField->GetAttributes();
            if (IsFdPublic(attr) || IsFdFamily(attr) || IsFdAssembly(attr) ||
                IsFdFamANDAssem(attr) || IsFdFamORAssem(attr)) {
                if (InternalHash(pCurField,rgpTable,&pHashElem))
                    pFldLst[curFld++] = pCurField;
            }
        }
        pEEC = pEEC->GetParentClass();
    }

    // Now add all of the statics (including static constants Blah!
    dwRealFields = curFld;

    // examine parent chain for inherited static fields
    pEEC = pCurEEC->GetParentClass();
    while (pEEC)
    {
        // Add the static fields
        if (pEEC->GetParentClass() != NULL)
            dwNumParentInstanceFields = (DWORD) pEEC->GetParentClass()->GetNumInstanceFields();
        else
            dwNumParentInstanceFields = 0;

        // Calculate the number of FieldDesc's in the current class
        FieldDescIterator fdIterator(pEEC, FieldDescIterator::STATIC_FIELDS);
        FieldDesc* pCurField;

        while ((pCurField = fdIterator.Next()) != NULL)
        {
            if(!pHashElem)
                pHashElem = (HashElem*) _alloca(sizeof(HashElem));

            DWORD dwCurFieldAttrs = pCurField->GetAttributes();
            if (!IsFdPublic(dwCurFieldAttrs)) {
                if (!(IsFdFamANDAssem(dwCurFieldAttrs) || IsFdFamily(dwCurFieldAttrs) ||
                        IsFdAssembly(dwCurFieldAttrs) || IsFdFamORAssem(dwCurFieldAttrs)))
                    continue;
            }
            if (InternalHash(pCurField,rgpTable,&pHashElem)){
                _ASSERTE(pCurField);
                pFldLst[curFld++] = pCurField;
            }
        }

        // The following are the constant statics.  These are only found
        //  in the meta data.
        int cStatics;
        REFLECTCLASSBASEREF pRefClass = (REFLECTCLASSBASEREF) pEEC->GetExposedClassObject();
        ReflectClass* pRC = (ReflectClass*) pRefClass->GetData();
        FieldDesc* fld = g_pRefUtil->GetStaticFields(pRC,&cStatics);
        for (i=0;(int)i<cStatics;i++) {
            if(!pHashElem)
                pHashElem = (HashElem*) _alloca(sizeof(HashElem));
            // Get the FieldDesc for current field
            FieldDesc* pCurField = &fld[i];
            DWORD dwCurFieldAttrs = pCurField->GetAttributes();
            if (!IsFdPublic(dwCurFieldAttrs)) {
                if (!(IsFdFamANDAssem(dwCurFieldAttrs) || IsFdFamily(dwCurFieldAttrs) ||
                        IsFdFamORAssem(dwCurFieldAttrs)))
                    continue;
            }
            if (InternalHash(pCurField,rgpTable,&pHashElem)){
                _ASSERTE(pCurField);
                pFldLst[curFld++] = pCurField;
            }
        }
        pEEC = pEEC->GetParentClass();
    }

    if (curFld == 0)
        return 0;

    ReflectFieldList* pCache = (ReflectFieldList*) 
        pCurEEC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectFieldList) + 
        (sizeof(ReflectField) * (curFld - 1)));
    if (!pCache)
        COMPlusThrowOM();
    WS_PERF_UPDATE_DETAIL("ReflectCtors:GetFields", sizeof(ReflectFieldList) + (sizeof(ReflectField) * (curFld - 1)), pCache);

    pCache->dwTotal = curFld;
    pCache->dwFields = dwRealFields;
    for (i=0;i<curFld;i++) {
        pCache->fields[i].pField = pFldLst[i];
        pCurEEC->GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pCache->fields[i].pFieldObj));
        pCache->fields[i].type = ELEMENT_TYPE_END;
        pCache->fields[i].dwAttr = 0;
    }
    return pCache;
}

// InternalHash
// This will add a field value to the hash table
bool ReflectFields::InternalHash(FieldDesc* pCurField,
        HashElem** rgpTable,HashElem** pHashElem)
{

    ZeroMemory(*pHashElem,sizeof(HashElem));
    (*pHashElem)->m_szKey = pCurField->GetName();
    (*pHashElem)->pCurField = pCurField;

    // Add the FieldDesc to the array
    if (AddElem(rgpTable, *pHashElem))
    {
        // If successful add, then indicate that more memory is needed on the stack
        // on the next time around.
        *pHashElem = NULL;
        return true;
    }
    return false;
}

// Add an element to the hash table.  
bool ReflectFields::AddElem(HashElem** rgpTable, HashElem* pElem)
{
    _ASSERTE(rgpTable);
    _ASSERTE(pElem);

    DWORD      dwID       = GetHashCode(pElem);
    DWORD      dwBucket   = dwID % TABLESIZE;
    HashElem** ppCurElem;

    // Find the end of the list for the current bucket.
    for(ppCurElem = &rgpTable[dwBucket]; *ppCurElem; ppCurElem = &((*ppCurElem)->m_pNext));

    *ppCurElem = pElem;
    pElem->m_dwID = dwID;
    pElem->m_pNext = NULL;
    return true;
}

DWORD ReflectFields::GetHashCode(HashElem* pElem)
{
    DWORD dwHashCode = 0;

    // Hash all of the same name into the same bucket.
    if (pElem->m_szKey) {
        const char* p = pElem->m_szKey;
        while (*p) {
            dwHashCode = _rotl(dwHashCode, 5) + *p;
            p++;
        }
    }
    return dwHashCode;
};

int ReflectFields::CheckForEquality(HashElem* p1, HashElem* p2)
{
    if (p1->m_szKey) {
        if (!p2->m_szKey)
            return 0;
        if (strcmp(p1->m_szKey,p2->m_szKey) != 0)
            return 0;
    }
    CorElementType p1T = p1->pCurField->GetFieldType();
    CorElementType p2T = p2->pCurField->GetFieldType();
    if (p1T != p2T)
        return 0;
    if (p1T == ELEMENT_TYPE_CLASS ||
        p1T == ELEMENT_TYPE_VALUETYPE) {
        if (p1->pCurField->GetTypeOfField() !=
            p2->pCurField->GetTypeOfField())
            return 0;
    }

    return 1;
};

//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

/*=============================================================================
** GetMaxCount
**
** The maximum number of EEClass pointers returned by GetInterfaces
**
** pVMC - the EEClass to calculate the count for
** bImplementedOnly - only return those interfaces that are implemented by pVMC
**/
//@TODO: For now, ignores bImplementedOnly and returns a count for all interfaces
DWORD ReflectInterfaces::GetMaxCount(EEClass* pVMC, bool bImplementedOnly)
{
    return (DWORD) pVMC->GetNumInterfaces();
}

/*=============================================================================
** GetInterfaces
**
** This will compile a table that includes all of the interfaces
** supported by the class.
**
** pVMC - the EEClass to get the methods for
** rgpMD - where to write the table
** bImplementedOnly - only return those interfaces that are implemented by pVMC
**/
//@TODO: For now, ignores bImplementedOnly and returns all interfaces
DWORD ReflectInterfaces::GetInterfaces(EEClass* pVMC, EEClass** rgpVMC, bool bImplementedOnly)
{
    DWORD           i;

    _ASSERTE(pVMC);
    _ASSERTE(rgpVMC);

    _ASSERTE(!pVMC->IsThunking());

    _ASSERTE("bImplementedOnly == true is NYI" && !bImplementedOnly);

    // Look for a matching interface
    for(i = 0; i < pVMC->GetNumInterfaces(); i++)
    {
        // Get an interface's EEClass
        EEClass* pVMCCurIFace = pVMC->GetInterfaceMap()[i].m_pMethodTable->GetClass();
        _ASSERTE(pVMCCurIFace);

        rgpVMC[i] = pVMCCurIFace;
    }
    return i;
}

// GetClassStringVars
// This routine converts the contents of a STRINGREF into a LPUTF8.  It returns
//  the size of the string
//  stringRef -- The string reference
//  szStr -- The output string.  This is allocated by the caller
//  cStr -- the size of the allocated string
//  pCnt -- output string size
LPUTF8 GetClassStringVars(STRINGREF stringRef, CQuickBytes *pBytes,
                          DWORD* pCnt, bool bEatWhitespace)
{
    WCHAR* wzStr = stringRef->GetBuffer();
    int len = stringRef->GetStringLength();
    _ASSERTE(pBytes);

    // If we have to eat the whitespace, do it.
    if (bEatWhitespace) {
        while(1) {
            if(COMCharacter::nativeIsWhiteSpace(wzStr[0])) {
                wzStr++;
                len--;
            }
            else
                break;
        }

        while(1) {
            if(COMCharacter::nativeIsWhiteSpace(wzStr[len-1]))
                len--;
            else
                break;
        }
    }
    
    *pCnt = WszWideCharToMultiByte(CP_UTF8, 0, wzStr, len,
                                   0, 0, 
                                   NULL, NULL);
    if (pBytes->Alloc(*pCnt + 1) == NULL)
        FatalOutOfMemoryError();
    LPSTR pStr = (LPSTR)pBytes->Ptr();

    *pCnt = WszWideCharToMultiByte(CP_UTF8, 0, wzStr, len,
                                   pStr, *pCnt, 
                                   NULL, NULL);

    // Null terminate the string
    pStr[*pCnt] = '\0';
    return pStr;
}

DWORD ReflectProperties::GetMaxCount(EEClass* pEEC)
{
    HRESULT hr;
    DWORD cnt = 0;
    while (pEEC) {
        HENUMInternal hEnum;

        // Get all of the associates
        hr = pEEC->GetMDImport()->EnumInit(mdtProperty,pEEC->GetCl(),&hEnum);
        if (FAILED(hr)) {
            _ASSERTE(!"GetAssociateCounts failed");
            return 0;
        }
        cnt += pEEC->GetMDImport()->EnumGetCount(&hEnum);
        pEEC->GetMDImport()->EnumClose(&hEnum);
        pEEC = pEEC->GetParentClass();

    }
    return cnt;
}

ReflectPropertyList* ReflectProperties::GetProperties(ReflectClass* pRC,
                                                      EEClass* pEEC)
{
    HRESULT             hr;
    ReflectProperty*    rgpProp;
    DWORD               dwCurIndex;
    DWORD               pos;
    DWORD               numProps;
    DWORD               cAssoc;
    bool                bVisible;
    EEClass*            p;
    DWORD               attr=0;

    // Find the Max Properties...
    dwCurIndex = GetMaxCount(pEEC);
    rgpProp = (ReflectProperty*) _alloca(sizeof(ReflectProperty) * dwCurIndex);

    // Allocate some signature stuff so we can check for duplicates
    PCCOR_SIGNATURE* ppSig = (PCCOR_SIGNATURE*) _alloca(sizeof(PCOR_SIGNATURE) * dwCurIndex);
    memset(ppSig,0,sizeof(PCOR_SIGNATURE) * dwCurIndex);
    ULONG* pcSig = (ULONG*) _alloca(sizeof(ULONG) * dwCurIndex);
    memset(pcSig,0,sizeof(ULONG) * dwCurIndex);
    Module** pSigMod = (Module**) _alloca(sizeof(Module*) * dwCurIndex);
    memset(pSigMod,0,sizeof(Module*) * dwCurIndex);

    // Walk all of the possible properties and collapse them
    pos = 0;
    bVisible = true;
    p = pEEC;

    // Start by adding the instance properties and the static properties of
    // the class we are getting properties for.
    while (p) {
        HENUMInternal hEnum;
        mdToken       Tok;

        // Get all of the associates
        hr = p->GetMDImport()->EnumInit(mdtProperty,p->GetCl(),&hEnum);
        if (FAILED(hr)) {
            _ASSERTE(!"GetAssociateCounts failed");
            return 0;
        }

        // Walk all of the properties on this object....
        cAssoc = p->GetMDImport()->EnumGetCount(&hEnum);
        for (DWORD i=0;i<cAssoc;i++) {
            LPCUTF8         szName;         // Pointer to name
            PCCOR_SIGNATURE pSig;
            ULONG cSig;
            p->GetMDImport()->EnumNext(&hEnum,&Tok);
            p->GetMDImport()->GetPropertyProps(Tok,&szName,&attr,&pSig,&cSig);

            // See if this is a duplicate Property
            bool dup = false;
            for (DWORD j=0;j<pos;j++) {
                if (strcmp(szName,rgpProp[j].szName) == 0) {
                    if (MetaSig::CompareMethodSigs(ppSig[j],pcSig[j],pSigMod[j],
                            pSig,cSig,p->GetModule()) != 0) { 
                        dup = true;
                        break;
                    }
                }
            }
            if (dup)
                continue;

            // If the property is visible then we need to add it to the list.
            if (bVisible || (CheckVisibility(pEEC,p->GetMDImport(),Tok) && !IsMemberStatic(pEEC, p->GetMDImport(), Tok))) {
                rgpProp[pos].propTok = Tok;
                rgpProp[pos].pModule = p->GetModule();
                rgpProp[pos].szName = szName;
                rgpProp[pos].pDeclCls = p;
                rgpProp[pos].pRC = pRC;
                rgpProp[pos].pSignature = ExpandSig::GetReflectSig(pSig,p->GetModule());
                rgpProp[pos].attr=attr;
                rgpProp[pos].pSetter=0;
                rgpProp[pos].pGetter=0;
                rgpProp[pos].pOthers=0;
                SetAccessors(&rgpProp[pos],p,pEEC);
                pcSig[pos] = cSig;
                ppSig[pos] = pSig;
                pSigMod[pos] = p->GetModule();
                pos++;
            }
        }

        // Close the enum on this object and move on to the parent class
        p->GetMDImport()->EnumClose(&hEnum);
        p = p->GetParentClass();
        bVisible = false;
    }

    // Remember the number of properties at this point.
    numProps = pos;

    // Now add the static properties of derived classes.
    p = pEEC->GetParentClass();
    while (p) {
        HENUMInternal hEnum;
        mdToken       Tok;

        // Get all of the associates
        hr = p->GetMDImport()->EnumInit(mdtProperty,p->GetCl(),&hEnum);
        if (FAILED(hr)) {
            _ASSERTE(!"GetAssociateCounts failed");
            return 0;
        }

        // Walk all of the properties on this object....
        cAssoc = p->GetMDImport()->EnumGetCount(&hEnum);
        for (DWORD i=0;i<cAssoc;i++) {
            LPCUTF8         szName;         // Pointer to name
            PCCOR_SIGNATURE pSig;
            ULONG cSig;
            p->GetMDImport()->EnumNext(&hEnum,&Tok);
            p->GetMDImport()->GetPropertyProps(Tok,&szName,&attr,&pSig,&cSig);

            // See if this is a duplicate Property
            bool dup = false;
            for (DWORD j=0;j<pos;j++) {
                if (strcmp(szName,rgpProp[j].szName) == 0) {
                    if (MetaSig::CompareMethodSigs(ppSig[j],pcSig[j],pSigMod[j],
                            pSig,cSig,p->GetModule()) != 0) { 
                        dup = true;
                        break;
                    }
                }
            }
            if (dup)
                continue;

            // Only add the property if it is static.
            if (!IsMemberStatic(pEEC, p->GetMDImport(), Tok))
                continue;

            // if the property is visible then we need to add it to the list.
            if (CheckVisibility(pEEC,p->GetMDImport(),Tok)) {
                rgpProp[pos].propTok = Tok;
                rgpProp[pos].pModule = p->GetModule();
                rgpProp[pos].szName = szName;
                rgpProp[pos].pDeclCls = p;
                rgpProp[pos].pRC = pRC;
                rgpProp[pos].pSignature = ExpandSig::GetReflectSig(pSig,p->GetModule());
                rgpProp[pos].attr=attr;
                rgpProp[pos].pSetter=0;
                rgpProp[pos].pGetter=0;
                rgpProp[pos].pOthers=0;
                SetAccessors(&rgpProp[pos],p,pEEC);
                pcSig[pos] = cSig;
                ppSig[pos] = pSig;
                pSigMod[pos] = p->GetModule();
                pos++;
            }
        }

        // Close the enum on this object and move on to the parent class
        p->GetMDImport()->EnumClose(&hEnum);
        p = p->GetParentClass();
    }

    ReflectPropertyList* pList;
    if (pos) {
        pList = (ReflectPropertyList*) 
                pEEC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectPropertyList) + 
                                                                 (pos - 1) * sizeof(ReflectProperty));
        WS_PERF_UPDATE_DETAIL("ReflectCtors:GetProperty", sizeof(ReflectPropertyList) + (sizeof(ReflectProperty) * (pos - 1)), pList);
        if (pList == NULL)
            FatalOutOfMemoryError();
        pList->dwProps = numProps;
        pList->dwTotal = pos;
        for (DWORD i=0;i<pos;i++) {
            memcpy(&pList->props[i],&rgpProp[i],sizeof(ReflectProperty));
            pEEC->GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pList->props[i].pPropObj));
        }
        return pList;
    }

    pList = (ReflectPropertyList*) 
            pEEC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectPropertyList));
    if (pList == NULL)
        FatalOutOfMemoryError();
    WS_PERF_UPDATE_DETAIL("ReflectCtors:GetProperty", sizeof(ReflectPropertyList), pList);
    pList->dwProps = 0;
    return pList;
}

// FindAccessor
// This method will find the specified property accessor
void ReflectProperties::SetAccessors(ReflectProperty* pProp,EEClass* baseClass,EEClass* targetClass)
{
    ULONG           cAssoc;
    ASSOCIATE_RECORD* pAssoc;

    {
        HENUMInternal   henum;

        // Get all of the associates
        pProp->pModule->GetMDImport()->EnumAssociateInit(pProp->propTok,&henum);

        cAssoc = pProp->pModule->GetMDImport()->EnumGetCount(&henum);

        // if no associates found then return null -- This is probably
        //  an unlikely situation.
        if (cAssoc == 0)
            return;

        // allocate the assocate record to recieve the output
        pAssoc = (ASSOCIATE_RECORD*) _alloca(sizeof(ASSOCIATE_RECORD) * cAssoc);

        pProp->pModule->GetMDImport()->GetAllAssociates(&henum,pAssoc,cAssoc);

        // close cursor before check the error
        pProp->pModule->GetMDImport()->EnumClose(&henum);
    }

    // This loop will search for an accessor based upon the signature
    // @TODO: right now just return the first get accessor.  We need
    //  to do matching here once that is written.
    ReflectMethodList* pML = pProp->pRC->GetMethods();
    for (ULONG i=0;i<cAssoc;i++) {
        MethodDesc* pMeth = baseClass->FindMethod(pAssoc[i].m_memberdef);
        if (pProp->pRC->GetClass()->IsValueClass()
            && !pMeth->IsUnboxingStub()) {
            MethodDesc* pMD = pProp->pRC->GetClass()->GetUnboxingMethodDescForValueClassMethod(pMeth);
            if (pMD)
                pMeth = pMD;
        }
        if (pProp->pDeclCls != targetClass) {           
            DWORD attr = pMeth->GetAttrs();
            if (IsMdPrivate(attr))
                continue;
            if (IsMdVirtual(attr)) {
                WORD slot = pMeth->GetSlot();
                if (slot <= pProp->pDeclCls->GetNumVtableSlots())
                    pMeth = targetClass->GetMethodDescForSlot(slot);
            }
        }

        if (pAssoc[i].m_dwSemantics & msSetter)
            pProp->pSetter = pML->FindMethod(pMeth);
        else if (pAssoc[i].m_dwSemantics & msGetter)
            pProp->pGetter = pML->FindMethod(pMeth);
        else if (pAssoc[i].m_dwSemantics &  msOther) {
            PropertyOtherList *pOther = (PropertyOtherList*)targetClass->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(PropertyOtherList));
            if (pOther == NULL)
                FatalOutOfMemoryError();
            pOther->pNext = pProp->pOthers;
            pOther->pMethod = pML->FindMethod(pMeth);
            pProp->pOthers = pOther;
        }
    }
}

// GetGlobals
// This method will return all of the global methods defined
//   in a module
ReflectMethodList* ReflectModuleGlobals::GetGlobals(Module* pMod)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pMT = pMod->GetMethodTable();
    int cnt = (pMT ? pMT->GetClass()->GetNumMethodSlots() : 0);

    // Allocate a ReflectMethodList* for all the global methods.  (This
    //  is a single allocation.  We need to adjust for 0 globals.)
    int alloc_cnt = cnt;

    if (alloc_cnt == 0)
        alloc_cnt = 1;

    ReflectMethodList* pMeths = (ReflectMethodList*) 
        pMod->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectMethodList) + 
        (sizeof(ReflectMethod) * (alloc_cnt - 1)));

    if (!pMeths)
        COMPlusThrowOM();
    WS_PERF_UPDATE_DETAIL("ReflectModuleGlobals:GetGlobals", sizeof(ReflectMethodList) + (sizeof(ReflectMethod) * (cnt)), pMeths);

    // Update the list of globals...
    pMeths->dwMethods = cnt;
    pMeths->dwTotal = cnt;
    for (unsigned int i=0;i<pMeths->dwMethods;i++) {
        MethodDesc* pM = pMT->GetMethodDescForSlot(i);
        pMeths->methods[i].pMethod = pM;
        pMeths->methods[i].szName = pM->GetName();
        pMeths->methods[i].dwNameCnt = (DWORD)strlen(pMeths->methods[i].szName);
        pMeths->methods[i].attrs = pM->GetAttrs();
        pMeths->methods[i].pSignature = 0;
        pMeths->methods[i].pNext = 0;
        pMeths->methods[i].pIgnNext = 0;
        pM->GetClass()->GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pMeths->methods[i].pMethodObj));
        pMeths->methods[i].typeHnd = TypeHandle(pM->GetMethodTable());
    }
    pMeths->hash.Init(pMeths);
    return pMeths;
}

// GetGlobalFields
// This method will return all of the global fields defined 
//  in a module
ReflectFieldList* ReflectModuleGlobals::GetGlobalFields(Module* pMod)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pMT = pMod->GetMethodTable();
    EEClass* pEEC = 0;
    DWORD dwNumFields = 0;
    if (pMT) {
        pEEC = pMT->GetClass();
        dwNumFields = (DWORD)(pEEC->GetNumInstanceFields() + pEEC->GetNumStaticFields());
    }

    // Allocate a ReflectMethodList* for all the global methods.  (This
    //  is a single allocation.  We need to adjust for 0 globals.)
    DWORD alloc_cnt = dwNumFields;

    if (alloc_cnt == 0)
        alloc_cnt = 1;

    ReflectFieldList* pFlds = (ReflectFieldList*) 
        pMod->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectFieldList) + 
        (sizeof(ReflectField) * (alloc_cnt - 1)));

    if (!pFlds)
        COMPlusThrowOM();
    WS_PERF_UPDATE_DETAIL("ReflectModuleGlobals:GetGlobalFields", sizeof(ReflectFieldList) + (sizeof(ReflectField) * (dwNumFields)), pFlds);

    // Update the list of globals fields...
    pFlds->dwFields = dwNumFields;

    // If we don't have any fields then don't try to iterate over them.
    if (dwNumFields > 0)
    {
        FieldDescIterator fdIterator(pEEC, FieldDescIterator::ALL_FIELDS);
        FieldDesc* pCurField;

        unsigned int i=0;    
        while ((pCurField = fdIterator.Next()) != NULL)
        {
            pFlds->fields[i].pField = pCurField;
            pMod->GetAssembly()->GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pFlds->fields[i].pFieldObj));
            ++i;
        }
        _ASSERTE(i==pFlds->dwFields);
    }

    return pFlds;
}

// Get
// This method will return a ReflectTypeList which represents all of the nested types
//  found for the type
ReflectTypeList* ReflectNestedTypes::Get(ReflectClass* pRC)
{
    EEClass* pEEC = pRC->GetClass();

    // find out the max nested classes
    ULONG cMax = MaxNests(pEEC);
    if (cMax == 0)
        return 0;
    
    // Get all of the tokens...
    EEClass** types;
    types = (EEClass**) _alloca(sizeof(EEClass*) * cMax);

    ULONG pos = 0;
    PopulateNests(pEEC,types,&pos);
    if (pos == 0)
        return 0;

    // Allocate the TypeList we will return
    ReflectTypeList* pCache = (ReflectTypeList*) 
        pEEC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectTypeList) + 
        (sizeof(EEClass*) * (pos - 1)));
    
    if (pCache == NULL)
        FatalOutOfMemoryError();

    for (unsigned int i=0;i<pos;i++) {
        pCache->types[i] = types[i];
    }
    pCache->dwTypes = pos;

    return pCache;
}

// This method will walk the hiearchy and find all of the possible
//  nested classes that could be present on an object.
ULONG ReflectNestedTypes::MaxNests(EEClass* pEEC)
{
    ULONG cnt = 0;
    while (pEEC) {
        cnt += pEEC->GetMDImport()->GetCountNestedClasses(pEEC->GetCl());
        pEEC = pEEC->GetParentClass();
    }
    return cnt;
}

void ReflectNestedTypes::PopulateNests(EEClass* pEEC,EEClass** typeArray,ULONG* pos)
{
    THROWSCOMPLUSEXCEPTION();

    // How many nests were defined on this class?
    ULONG cNests = pEEC->GetMDImport()->GetCountNestedClasses(pEEC->GetCl());
    if (cNests == 0)
        return;

    mdTypeRef* types;
    types = (mdTypeRef*) _alloca(sizeof(mdTypeRef) * cNests);

    ULONG cRet = pEEC->GetMDImport()->GetNestedClasses(pEEC->GetCl(),types,cNests);
    _ASSERTE(cRet == cNests);
    

    Module* pMod = pEEC->GetModule();
    ClassLoader* pLoader = pMod->GetClassLoader();

    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    for (unsigned int i=0;i<cNests;i++) {
        EEClass *pEEC;
        NameHandle nh (pMod,types[i]);
        pEEC = pLoader->LoadTypeHandle(&nh,&Throwable).GetClass();
        if (pEEC)
        {
            // we can have nested defined in metadata but ee does not know it yet in Reflection Emit scenario.
            _ASSERTE(pEEC->IsNested());
            typeArray[*pos] = pEEC;
            if (Throwable != NULL)
                COMPlusThrow(Throwable);
            (*pos)++;
        }
    }
    GCPROTECT_END();
}

// This method will return a ReflectPropertyList for all of the properties
//   that exist for a class.
//  NULL is returned if the class has not properties.
ReflectEventList* ReflectEvents::GetEvents(ReflectClass* pRC,EEClass* pEEC)
{
    HRESULT             hr;
    DWORD               pos;
    DWORD               numEvents;
    DWORD               cAssoc;
    EEClass*            p;
    DWORD               attr=0;
    bool                bVisible;

    // Find the Max Events...
    DWORD dwCurIndex = GetMaxCount(pEEC);

    ReflectEvent* rgpEvent = (ReflectEvent*) _alloca(sizeof(ReflectEvent) * dwCurIndex);

    // Allocate some signature stuff so we can check for duplicates
    Module** pSigMod = (Module**) _alloca(sizeof(Module*) * dwCurIndex);
    memset(pSigMod,0,sizeof(Module*) * dwCurIndex);

    // Walk all of the possible events and collapse them
    pos = 0;
    bVisible = true;
    p = pEEC;

    // Start by adding the instance events and the static events of
    // the class we are getting events for.
    while (p) {
        HENUMInternal hEnum;
        mdToken       Tok;

        // Get all of the associates
        hr = p->GetMDImport()->EnumInit(mdtEvent,p->GetCl(),&hEnum);
        if (FAILED(hr)) {
            _ASSERTE(!"GetAssociateCounts failed");
            return 0;
        }

        // Walk all of the properties on this object....
        cAssoc = p->GetMDImport()->EnumGetCount(&hEnum);
        for (DWORD i=0;i<cAssoc;i++) {
            LPCSTR      szName;             // Pointer to name
            DWORD       dwEventFlags;       // Flags
            mdToken     tkEventType;        // Pointer to the event type

            p->GetMDImport()->EnumNext(&hEnum,&Tok);
            p->GetMDImport()->GetEventProps(Tok,&szName,&dwEventFlags,&tkEventType);

            // See if this is a duplicate Event
            bool dup = false;
            for (DWORD j=0;j<pos;j++) {
                if (strcmp(szName,rgpEvent[j].szName) == 0) {
                    dup = true;
                    break;
                }
            }
            if (dup)
                continue;

            // If the event is visible then we must add it to the list.
            if (bVisible || (CheckVisibility(pEEC,p->GetMDImport(),Tok) && !IsMemberStatic(pEEC, p->GetMDImport(), Tok))) {
                rgpEvent[pos].eventTok = Tok;
                rgpEvent[pos].pModule = p->GetModule();
                rgpEvent[pos].szName = szName;
                rgpEvent[pos].pDeclCls = p;
                rgpEvent[pos].pRC = pRC;
                rgpEvent[pos].attr=dwEventFlags;
                rgpEvent[pos].pAdd=0;
                rgpEvent[pos].pRemove=0;
                rgpEvent[pos].pFire=0;
                SetAccessors(&rgpEvent[pos],p,pEEC);
                pSigMod[pos] = p->GetModule();
                pos++;
            }
        }

        // Close the enum on this object and move on to the parent class
        p->GetMDImport()->EnumClose(&hEnum);
        p = p->GetParentClass();
        bVisible = false;
    }    

    // Remember the number of events at this point.
    numEvents = pos;

    // Now add the static events of derived classes.
    p = pEEC->GetParentClass();
    while (p) {
        HENUMInternal hEnum;
        mdToken       Tok;

        // Get all of the associates
        hr = p->GetMDImport()->EnumInit(mdtEvent,p->GetCl(),&hEnum);
        if (FAILED(hr)) {
            _ASSERTE(!"GetAssociateCounts failed");
            return 0;
        }

        // Walk all of the properties on this object....
        cAssoc = p->GetMDImport()->EnumGetCount(&hEnum);
        for (DWORD i=0;i<cAssoc;i++) {
            LPCSTR      szName;             // Pointer to name
            DWORD       dwEventFlags;       // Flags
            mdToken     tkEventType;        // Pointer to the event type

            p->GetMDImport()->EnumNext(&hEnum,&Tok);
            p->GetMDImport()->GetEventProps(Tok,&szName,&dwEventFlags,&tkEventType);

            // See if this is a duplicate Event
            bool dup = false;
            for (DWORD j=0;j<pos;j++) {
                if (strcmp(szName,rgpEvent[j].szName) == 0) {
                    dup = true;
                    break;
                }
            }
            if (dup)
                continue;

            // Only add the property if it is static.
            if (!IsMemberStatic(pEEC, p->GetMDImport(), Tok))
                continue;

            // If the event is visible then we must add it to the list.
            if (CheckVisibility(pEEC,p->GetMDImport(),Tok)) {
                rgpEvent[pos].eventTok = Tok;
                rgpEvent[pos].pModule = p->GetModule();
                rgpEvent[pos].szName = szName;
                rgpEvent[pos].pDeclCls = p;
                rgpEvent[pos].pRC = pRC;
                rgpEvent[pos].attr=dwEventFlags;
                rgpEvent[pos].pAdd=0;
                rgpEvent[pos].pRemove=0;
                rgpEvent[pos].pFire=0;
                SetAccessors(&rgpEvent[pos],p,pEEC);
                pSigMod[pos] = p->GetModule();
                pos++;
            }
        }

        // Close the enum on this object and move on to the parent class
        p->GetMDImport()->EnumClose(&hEnum);
        p = p->GetParentClass();
    }

    ReflectEventList* pList;
    if (pos) {
        pList = (ReflectEventList*) 
                pEEC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectEventList) + 
                                                                 (pos - 1) * sizeof(ReflectEvent));
        WS_PERF_UPDATE_DETAIL("ReflectCtors:GetEvent", sizeof(ReflectEventList) + (sizeof(ReflectEvent) * (pos - 1)), pList);
        if (pList == NULL)
            FatalOutOfMemoryError();
        pList->dwEvents = numEvents;
        pList->dwTotal = pos;
        for (DWORD i=0;i<pos;i++) {
            memcpy(&pList->events[i],&rgpEvent[i],sizeof(ReflectEvent));
            pEEC->GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pList->events[i].pEventObj));
        }
        return pList;
    }
    return 0;
}

// GetMaxCount
// This method will calculate the maximum possible properties for a class
DWORD  ReflectEvents::GetMaxCount(EEClass* pEEC)
{
    HRESULT     hr;
    DWORD       cnt = 0;
    while (pEEC) {
        HENUMInternal hEnum;

        hr = pEEC->GetMDImport()->EnumInit(mdtEvent, pEEC->GetCl(), &hEnum);
        if (FAILED(hr)) {
            _ASSERTE(!"GetAssociateCounts failed");
            return 0;
        }
        cnt += pEEC->GetMDImport()->EnumGetCount(&hEnum);
        pEEC->GetMDImport()->EnumClose(&hEnum);
        pEEC = pEEC->GetParentClass();

    }
    return cnt;
}


// SetAccessors
// This method will find the specified property accessor
void ReflectEvents::SetAccessors(ReflectEvent* pEvent,EEClass* baseClass,EEClass* targetClass)
{
    ULONG               cAssoc;
    ASSOCIATE_RECORD*   pAssoc;

    {
        HENUMInternal   henum;

        // Get all of the associates
        pEvent->pModule->GetMDImport()->EnumAssociateInit(pEvent->eventTok,&henum);

        cAssoc = pEvent->pModule->GetMDImport()->EnumGetCount(&henum);

        // if no associates found then return null -- This is probably
        //  an unlikely situation.
        if (cAssoc == 0)
            return;

        // allocate the assocate record to recieve the output
        pAssoc = (ASSOCIATE_RECORD*) _alloca(sizeof(ASSOCIATE_RECORD) * cAssoc);

        pEvent->pModule->GetMDImport()->GetAllAssociates(&henum,pAssoc,cAssoc);

        // close cursor before check the error
        pEvent->pModule->GetMDImport()->EnumClose(&henum);
    }

    // This loop will search for an accessor based upon the signature
    // @TODO: right now just return the first get accessor.  We need
    //  to do matching here once that is written.
    ReflectMethodList* pML = pEvent->pRC->GetMethods();
    for (ULONG i=0;i<cAssoc;i++) {
        MethodDesc* pMeth = baseClass->FindMethod(pAssoc[i].m_memberdef);
        if (pEvent->pRC->GetClass()->IsValueClass()
            && !pMeth->IsUnboxingStub()) {
            MethodDesc* pMD = pEvent->pRC->GetClass()->GetUnboxingMethodDescForValueClassMethod(pMeth);
            if (pMD)
                pMeth = pMD;
        }
        if (pEvent->pDeclCls != targetClass) {           
            DWORD attr = pMeth->GetAttrs();
            if (IsMdPrivate(attr))
                continue;

            // If the method is virtual then get its slot and retrieve the
            // method desc at that slot in the current class.
            if (IsMdVirtual(attr))
            {
                WORD slot = pMeth->GetSlot();
                if (slot <= pEvent->pDeclCls->GetNumVtableSlots())
                    pMeth = targetClass->GetMethodDescForSlot(slot);
            }
        }

        if (pAssoc[i].m_dwSemantics & msAddOn)
            pEvent->pAdd = pML->FindMethod(pMeth);
        if (pAssoc[i].m_dwSemantics & msRemoveOn)
            pEvent->pRemove = pML->FindMethod(pMeth);
        if (pAssoc[i].m_dwSemantics & msFire)
            pEvent->pFire = pML->FindMethod(pMeth);
    }
}

// CheckVisibility
// This method will check to see if a property or an event is visible.  This is done by looking
//  at the visibility of the accessor methods.
bool CheckVisibility(EEClass* pEEC,IMDInternalImport *pInternalImport, mdToken event)
{
    ULONG               cAssoc;
    ULONG               cAccess;
    ULONG               i;
    ASSOCIATE_RECORD*   pAssoc;
    DWORD               attr;

    {
        HENUMInternal   henum;

        // Get all of the associates
        pInternalImport->EnumAssociateInit(event,&henum);
        cAssoc = pInternalImport->EnumGetCount(&henum);
        if (cAssoc == 0)
            return false;

        // allocate the assocate record to recieve the output
        pAssoc = (ASSOCIATE_RECORD*) _alloca(sizeof(ASSOCIATE_RECORD) * cAssoc);
        pInternalImport->GetAllAssociates(&henum,pAssoc,cAssoc);

        // free cursor before error checking
        pInternalImport->EnumClose(&henum);
    }

    // Loop back through the Assoc and create the Accessor list
    ULONG stat = 0;
    for (i=0,cAccess = 0;i<cAssoc;i++) {
        attr = pInternalImport->GetMethodDefProps(pAssoc[i].m_memberdef);
        if (IsMdPublic(attr) || IsMdFamily(attr) || IsMdFamORAssem(attr) || IsMdFamANDAssem(attr)) {
            return true;
        }
    }

    return false;
}

// IsMemberStatic
// This method checks to see if a property or an event is static.
bool IsMemberStatic(EEClass* pEEC,IMDInternalImport *pInternalImport, mdToken event)
{
    ULONG               cAssoc;
    ULONG               cAccess;
    ULONG               i;
    ASSOCIATE_RECORD*   pAssoc;
    DWORD               attr;

    {
        HENUMInternal   henum;

        // Get all of the associates
        pInternalImport->EnumAssociateInit(event,&henum);
        cAssoc = pInternalImport->EnumGetCount(&henum);
        if (cAssoc == 0)
            return false;

        // allocate the assocate record to recieve the output
        pAssoc = (ASSOCIATE_RECORD*) _alloca(sizeof(ASSOCIATE_RECORD) * cAssoc);
        pInternalImport->GetAllAssociates(&henum,pAssoc,cAssoc);

        // free cursor before error checking
        pInternalImport->EnumClose(&henum);
    }

    // If one associate is static then we consider the member to be static,
    ULONG stat = 0;
    for (i=0,cAccess = 0;i<cAssoc;i++) {
        attr = pInternalImport->GetMethodDefProps(pAssoc[i].m_memberdef);
        if (IsMdStatic(attr)) {
            return true;
        }
    }

    return false;
}

LPUTF8 NormalizeArrayTypeName(LPUTF8 strArrayTypeName, DWORD dwLength)
{
    THROWSCOMPLUSEXCEPTION();
    char *szPtr = strArrayTypeName + dwLength - 1;
    for (; szPtr > strArrayTypeName; szPtr--) {
        if (*szPtr == ']') {
            szPtr--;
            // Check that we're not seeing a quoted ']' that's part of the base type name.
            for (int slashes = 0; szPtr >= strArrayTypeName && *szPtr == '\\'; szPtr--)
                slashes++;
            // Odd number of slashes indicates quoting.
            if ((slashes % 2) == 1)
                break;
            for (int rank = 1; szPtr > strArrayTypeName && *szPtr != '['; szPtr--) {
                if (*szPtr == ',')
                    rank++;
                else if (*szPtr == '*') {
                    if (rank == 1 && szPtr[-1] == '[')
                        continue;
                    for (int i = 0; i < strArrayTypeName + dwLength - szPtr; i++)
                        szPtr[i] = szPtr[i + 1];
                }
                else 
                    return NULL;
            }
            if (szPtr <= strArrayTypeName)
                return NULL;
        }
        else if (*szPtr != '*' && *szPtr != '&')
            break;
    }
    return strArrayTypeName;
}




void MemberMethods::InitValue()
{
    hResult = GetAppDomain()->CreateHandle (NULL);
    hname = GetAppDomain()->CreateHandle (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comreflectioncommon.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMREFLECTIONCOMMON_H_
#define _COMREFLECTIONCOMMON_H_

// VM and other stuff
#include "COMUtilNative.h"
#include "ReflectWrap.h"


#ifdef _DEBUG
#include <stdio.h>
#endif // _DEBUG

class ReflectCtors;
class ReflectMethods;
class ReflectOtherMethods;
class ReflectFields;

// GetClassStringVars
// This method will extract the string from a STRINGREF and convert it to a UTF8 string
//  A QuickBytes buffer must be provided by the caller to hold the result.
extern LPUTF8 GetClassStringVars(STRINGREF stringRef, CQuickBytes *pBytes,
                                 DWORD* pCnt, bool bEatWhitespace = false);

// NormalizeArrayTypeName
//  Parse and normalize an array type name removing *, return the same string passed in.
//  The string can be shrinked and it is never reallocated.
//  For single dimensional array T[] != T[*], but for multi dimensional array
//  T[,] == T[*,*]
//  T[?] is not valid any more
extern LPUTF8 NormalizeArrayTypeName(LPUTF8 strArrayTypeName, DWORD dwLength);

// ReflectBasehash
// This class is a basic chaining hash implementation
#define ALLOC_MAX 16
class ReflectBaseHash
{
private:
    // Mode is a private structure that represnts
    //  the chains in the hash table.
    struct Node {
        void*   data;
        Node*   next;
    };

    int _hashSize;          // size of the hash table
    Node** _table;          // the hash table
    Node* _freeList;        // Free list of nodes
    Node* _allocationList;  // List of allocated nodes
    BaseDomain *_pBaseDomain; // The BaseDomain that owns this hash.

    // getNode
    // The method will return a new Node object.
    // This will throw an exception if it fails.
    Node* getNode();

protected:
    virtual int getHash(const void* key) = 0;
    virtual bool equals(const void* key, void* data) = 0;

    // This routine will add a new element to the table.
    void internalAdd(const void* key, void* data);

public:
    // init
    // Allocate the hash table using size as an approx
    //  value for the table size.
    bool init(BaseDomain *pDomain, DWORD size);

    // add
    // Add a new data element to the hash table.
    virtual void add(void* data) = 0;

    // lookup
    // This method will lookup an element in the hash table.  It returns
    //  null if that element is not found.
    void* lookup(const void* key) {
        DWORD bucket = getHash(key);
        bucket %= _hashSize;
        Node* p = _table[bucket];
        while (p) {
            if (equals(key, p->data))
                break;
            p = p->next;
        }
        return (p) ? p->data : 0;
    }

    // Override allocation routines to use the COMClass Heap.
    // DONT Call delete.
    void* operator new(size_t s, void *pBaseDomain);
    void operator delete(void*, size_t);
};

/*=============================================================================
** ReflectCtors
**
** This will compile a list of all of the constructors for a particular class
**/
class ReflectCtors
{
public:
    /*=============================================================================
    ** GetMaxCount
    **
    ** The maximum number of MethodDescs that might be returned by GetCtors
    **
    ** pVMC - the EEClass to calculate the count for
    **/
    static DWORD GetMaxCount(EEClass* pVMC);

    // GetCtors
    // This method will return the list of all constructors associated 
    //  with the class
    static ReflectMethodList* GetCtors(ReflectClass* pRC);
};

/*=============================================================================
** ReflectMethods
**
** This will compile a list of either *all* methods visible to a class, or all
** *implemented* methods visible to a class.
**/
class ReflectMethods
{
private:
    // This is the element that we us to hash the fields so we
    //  can build a table to find the hidden elements.
    struct HashElem
    {
        DWORD       m_dwID;
        LPCUTF8     m_szKey;
        MethodDesc* pCurMethod;
        HashElem*   m_pNext;
    };

    // GetHashCode
    // Calculate a hash code on the Hash Elem 
    static DWORD GetHashCode(HashElem* pElem);

    // InternalHash
    // This will add a field value to the hash table
    static bool InternalHash(EEClass* pEEC,MethodDesc* pCurField,HashElem** rgpTable,
        HashElem** pHashElem);

    // Add an element to the hash table.  
    static bool AddElem(HashElem** rgpTable, HashElem* pElem);
    static int CheckForEquality(HashElem* p1, HashElem* p2);

    // GetMaxCount
    // Get the total possible methods that we may support.
    static DWORD GetMaxCount(EEClass* pVMC);

public:

    // GetMethods
    // This method will return the list of all methods associated with
    //  the class
    static ReflectMethodList* GetMethods(ReflectClass* pRC,int array);

};

// ReflectProperties
// This class is a helper class which will construct all of the
//  visiable properties for a class.
class ReflectProperties
{
public:
    // This method will return a ReflectPropertyList for all of the properties
    //   that exist for a class.
    //  NULL is returned if the class has not properties.
    static ReflectPropertyList* GetProperties(ReflectClass* pRC,EEClass* pEEC);

private:
    // GetMaxCount
    // This method will calculate the maximum possible properties for a class
    static DWORD GetMaxCount(EEClass* pEEC);

    // SetAccessors
    // This method will set the accessor methods for this property.
    static void SetAccessors(ReflectProperty* pProp,EEClass* baseClass,EEClass* targetClass);
};

// ReflectEvents
// This class is a helper class which will construct all of the
//  visiable events for a class.
class ReflectEvents
{
public:
    // This method will return a ReflectPropertyList for all of the properties
    //   that exist for a class.
    //  NULL is returned if the class has not properties.
    static ReflectEventList* GetEvents(ReflectClass* pRC,EEClass* pEEC);

private:
    // GetMaxCount
    // This method will calculate the maximum possible properties for a class
    static DWORD GetMaxCount(EEClass* pEEC);

    // SetAccessors
    // This method will set the accessor methods for this event.
    static void SetAccessors(ReflectEvent* pEvent,EEClass* baseClass,EEClass* targetClass);
};

// ReflectFields
// This is a helper class that will create the ReflectFieldList for a Type.  
//  There is a single entry point that will return this list.
class ReflectFields
{
private:
    // This is the element that we us to hash the fields so we
    //  can build a table to find the hidden elements.
    struct HashElem
    {
        DWORD       m_dwID;
        LPCUTF8     m_szKey;
        FieldDesc*  pCurField;
        HashElem*   m_pNext;
    };

    // GetHashCode
    // Calculate a hash code on the Hash Elem 
    static DWORD GetHashCode(HashElem* pElem);

    // InternalHash
    // This will add a field value to the hash table
    static bool InternalHash(FieldDesc* pCurField,HashElem** rgpTable,HashElem** pHashElem);

    // Add an element to the hash table.  
    static bool AddElem(HashElem** rgpTable, HashElem* pElem);
    static int CheckForEquality(HashElem* p1, HashElem* p2);

    // This method will walk the parent hiearchy and calculate
    //  the maximum number of fields possible
    static DWORD GetMaxCount(EEClass* pVMC);

public:
    // GetFields
    // This method will return all of the methods defined for a Type.
    //  It basically walks the EEClas looking at the fields and then walks
    //  up the parent chain for the protected and publics.  We hide fields
    //  based upon Name/Type.
    static ReflectFieldList* GetFields(EEClass* pVMC);
};

/*=============================================================================
** ReflectInterfaces
**
** This will compile a list of all of the interfaces supported by a particular
** class.
**/
class ReflectInterfaces
{
public:
    /*=============================================================================
    ** GetMaxCount
    **
    ** The maximum number of EEClass pointers returned by GetInterfaces
    **
    ** pVMC - the EEClass to calculate the count for
    ** bImplementedOnly - only return those interfaces that are implemented by pVMC
    **/
    static DWORD GetMaxCount(EEClass* pVMC, bool bImplementedOnly);

    /*=============================================================================
    ** GetMethods
    **
    ** This will compile a table that includes all of the interfaces
    ** supported by the class.
    **
    ** pVMC - the EEClass to get the methods for
    ** rgpMD - where to write the table
    ** bImplementedOnly - only return those interfaces that are implemented by pVMC
    **/
    static DWORD GetInterfaces(EEClass* pVMC, EEClass** rgpVMC, bool bImplementedOnly);
};

// This class is a helper class that will build
//  the nested classes associated with a Class.
class ReflectNestedTypes
{
public :
    // Get
    // This method will return a ReflectTypeList which represents all of the nested types
    //  found for the type
    static ReflectTypeList* Get(ReflectClass* pRC);

private:
    // This method calculate the maximum number of
    //  nested classes that may be found.
    static ULONG MaxNests(EEClass* pEEC);

    // This method will find all of the visiable nested classes
    //  for a class.
    static void PopulateNests(EEClass* pEEC,EEClass** typeArray,ULONG* pos);
};

class ReflectModuleGlobals
{
public:
    // GetGlobals
    // This method will return all of the global methods defined
    //   in a module
    static ReflectMethodList* GetGlobals(Module* pMod); 

    // GetGlobalFields
    // This method will return all of the global fields defined 
    //  in a module
    static ReflectFieldList* GetGlobalFields(Module* pMod); 
};
#endif // _COMREFLECTIONCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comreflectioncache.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __COMReflectionCache_hpp__
#define __COMReflectionCache_hpp__

#include "common.h"
#include "SimpleRWLock.hpp"
#include "reflectwrap.h"

template <class Element, class CacheType, int CacheSize> class ReflectionCache
: public SimpleRWLock
{
public:
    ReflectionCache ()
        : SimpleRWLock (COOPERATIVE, LOCK_REFLECTCACHE)
    {
        index = 0;
        currentStamp = 0;
    }

    BOOL Init()
    {
        m_pResult = (CacheTable *) GetAppDomain()->GetLowFrequencyHeap()->AllocMem (CacheSize * sizeof(CacheTable));
        if (!m_pResult)
            return FALSE;

        m_pHashTable = (HashTable *) GetAppDomain()->GetLowFrequencyHeap()->AllocMem (CacheSize * sizeof(HashTable));
        if (!m_pHashTable)
            return FALSE;

        for (int i = 0; i < CacheSize; i ++)
            m_pHashTable[i].slot = -1;

        return TRUE;
    }

    BOOL GetFromCache (Element *pElement, CacheType& rv)
    {
        EnterRead ();
        
        rv = 0;
        int i = SlotInCache (pElement);
        BOOL fGotIt = (i != CacheSize);
        if (fGotIt)
        {
            rv = m_pResult[i].element.GetValue ();
            InterlockedIncrement (&currentStamp);
            m_pResult[i].stamp = currentStamp;
        }
        LeaveRead ();

        if (fGotIt)
            AdjustStamp (FALSE);
        return fGotIt;
    }
    
    void AddToCache (Element *pElement, CacheType obj)
    {
        EnterWrite ();
        InterlockedIncrement (&currentStamp);
        int i = SlotInCache (pElement);
        if (i == CacheSize)
        {
            int slot = index;
            // Not in cache.
            if (slot == CacheSize)
            {
                // Reuse a slot.
                slot = 0;
                long minStamp = m_pResult[0].stamp;
                for (i = 1; i < CacheSize; i ++)
                {
                    if (m_pResult[i].stamp < minStamp)
                    {
                        slot = i;
                        minStamp = m_pResult[i].stamp;
                    }
                }
            }
            else
                m_pResult[slot].element.InitValue ();
            m_pResult[slot].element = *pElement;
            m_pResult[slot].element.SetValue (obj);
            m_pResult[slot].stamp = currentStamp;

            UpdateHashTable (pElement->GetHash(), slot);
            if (index < CacheSize)
                index ++;
        }
        AdjustStamp (TRUE);
        LeaveWrite ();
    }

private:
    // Lock must have been taken before calling this.
    int SlotInCache (Element *pElement)
    {
        _ASSERTE (LockTaken());

        if (index == 0)
            return CacheSize;

        size_t hash = pElement->GetHash ();

        int slot = m_pHashTable[hash%CacheSize].slot;
        if (slot == -1)
            return CacheSize;
        
        if (m_pResult[slot].element == *pElement)
            return slot;
        
        for (int i = 0; i < index; i ++)
        {
            if (i != slot && m_pHashTable[i].hash == hash)
            {
                if (m_pResult[i].element == *pElement)
                    return i;
            }
        }

        return CacheSize;
    }

    void AdjustStamp (BOOL hasWriterLock)
    {
        if ((currentStamp & 0x40000000) == 0)
            return;
        if (!hasWriterLock)
        {
            _ASSERTE (!LockTaken());
            EnterWrite ();
        }
        else
            _ASSERTE (IsWriterLock());
        
        if (currentStamp & 0x40000000)
        {
            currentStamp >>= 1;
            for (int i = 0; i < index; i ++)
                m_pResult[i].stamp >>= 1;
        }
        if (!hasWriterLock)
            LeaveWrite ();
    }

    void UpdateHashTable ( SIZE_T hash, int slot)
    {
        _ASSERTE (IsWriterLock());
        m_pHashTable[slot].hash = hash;
        m_pHashTable[hash%CacheSize].slot = slot;
    }
    
    struct CacheTable
    {
        Element element;
        long stamp;
    } *m_pResult;
    struct HashTable
    {
        size_t hash;   // Record hash value for each slot
        int   slot;   // The slot corresponding to the hash.
    } *m_pHashTable;
    int index;
    long currentStamp;

};
    
#define ReflectionMaxArgs 5
struct MemberMethods
{
    ReflectClass *pRC;
    union
    {
        // On input, it is a pointer to string.
        // In cache, it is a handle to a string.
        STRINGREF *name;
        OBJECTHANDLE hname;
    };
    OBJECTHANDLE hResult;
    MethodTable *vArgType[ReflectionMaxArgs];
    int invokeAttr;
    int argCnt;

    MemberMethods ()
        : pRC (NULL), invokeAttr(0), argCnt (0)
    {
    }

    BOOL operator==(const MemberMethods& var) const
    {
        if (pRC != var.pRC || invokeAttr != var.invokeAttr
            || argCnt != var.argCnt)
            return FALSE;
        for (int i = 0; i < argCnt; i ++)
        {
            if (vArgType[i] != var.vArgType[i])
                return FALSE;
        }
        STRINGREF cachedName = (STRINGREF) ObjectFromHandle (hname);
        STRINGREF methodName = ObjectToSTRINGREF(*(StringObject**) var.name);
        if (cachedName->GetStringLength() != methodName->GetStringLength())
            return FALSE;
        if (wcsncmp (cachedName->GetBuffer(), methodName->GetBuffer(),
                     methodName->GetStringLength()) != 0)
            return FALSE;
        return TRUE;
    }

    MemberMethods& operator= (const MemberMethods& var)
    {
        pRC = var.pRC;
        invokeAttr = var.invokeAttr;
        argCnt = var.argCnt;
        StoreObjectInHandle (hname, ObjectToOBJECTREF(*(Object **)var.name));
        for (int i = 0; i < argCnt; i ++)
            vArgType[i] = var.vArgType[i];
        return *this;
    }

    OBJECTREF GetValue ()
    {
        return ObjectFromHandle (hResult);
    }

    void InitValue ();
    
    void SetValue (OBJECTREF obj)
    {
        StoreObjectInHandle (hResult, obj);
    }

    size_t GetHash ()
    {
        return (size_t)pRC + invokeAttr + argCnt;
    }
};

typedef ReflectionCache <MemberMethods, OBJECTREF, 128> MemberMethodsCache;

#define ReflectionMaxCachedNameLength 23
struct DispIDCacheElement
{
    MethodTable *pMT;
    int strNameLength;
    LCID lcid;
    DISPID DispId;
    WCHAR strName[ReflectionMaxCachedNameLength+1];
    DispIDCacheElement ()
        : pMT (NULL), strNameLength(0), lcid(0), DispId(0)
    {
    }

    BOOL operator==(const DispIDCacheElement& var) const
    {
        return (pMT == var.pMT && strNameLength == var.strNameLength
                && lcid == var.lcid && wcscmp (strName, var.strName) == 0);
    }

    DispIDCacheElement& operator= (const DispIDCacheElement& var)
    {
        _ASSERTE (var.strNameLength <= ReflectionMaxCachedNameLength);
        pMT = var.pMT;
        strNameLength = var.strNameLength;
        lcid = var.lcid;
        wcscpy (strName, var.strName);
        return *this;
    }

    DISPID GetValue ()
    {
        return DispId;
    }

    void InitValue ()
    {
    }
    
    void SetValue (DISPID Id)
    {
        DispId = Id;
    }

    size_t GetHash ()
    {
        return (size_t)pMT + strNameLength + (lcid << 4);
    }
};

typedef ReflectionCache <DispIDCacheElement, DISPID, 128> DispIDCache;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsecurityruntime.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMSecurityRuntime.cpp
**
** Author: Paul Kromann (paulkr)
**
** Purpose:
**
** Date:  March 21, 1998
**
===========================================================*/
#include "common.h"

#include "object.h"
#include "excep.h"
#include "vars.hpp"
#include "COMSecurityRuntime.h"
#include "security.h"
#include "gcscan.h"
#include "AppDomainHelper.h"


//-----------------------------------------------------------+
// P R I V A T E   H E L P E R S 
//-----------------------------------------------------------+

LPVOID GetSecurityObjectForFrameInternal(StackCrawlMark *stackMark, INT32 create, OBJECTREF *pRefSecDesc)
{ 
    THROWSCOMPLUSEXCEPTION();

    // This is a package protected method. Assumes correct usage.

    Thread *pThread = GetThread();
    AppDomain * pAppDomain = pThread->GetDomain();
    if (pRefSecDesc == NULL)
    {
        if (!Security::SkipAndFindFunctionInfo(stackMark, NULL, &pRefSecDesc, &pAppDomain))
            return NULL;
    }

    if (pRefSecDesc == NULL)
        return NULL;

    // Is security object frame in a different context?
    bool fSwitchContext = pAppDomain != pThread->GetDomain();

    if (create && *pRefSecDesc == NULL)
    {
        ContextTransitionFrame frame;

        COMSecurityRuntime::InitSRData();

        // If necessary, shift to correct context to allocate security object.
        if (fSwitchContext)
            pThread->EnterContextRestricted(pAppDomain->GetDefaultContext(), &frame, TRUE);

        *pRefSecDesc = AllocateObject(COMSecurityRuntime::s_srData.pFrameSecurityDescriptor);

        if (fSwitchContext)
            pThread->ReturnToContext(&frame, TRUE);
    }

    // If we found or created a security object in a different context, make a
    // copy in the current context.
    LPVOID rv;
    if (fSwitchContext && *pRefSecDesc != NULL)
        *((OBJECTREF*)&rv) = AppDomainHelper::CrossContextCopyFrom(pAppDomain, pRefSecDesc);
    else
        *((OBJECTREF*)&rv) = *pRefSecDesc;

    return rv;
}

LPVOID __stdcall COMSecurityRuntime::GetSecurityObjectForFrame(const GetSecurityObjectForFrameArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    return GetSecurityObjectForFrameInternal(args->stackMark, args->create, NULL);
}

void __stdcall COMSecurityRuntime::SetSecurityObjectForFrame(const SetSecurityObjectForFrameArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    // This is a package protected method. Assumes correct usage.

    OBJECTREF* pCurrentRefSecDesc;

    Thread *pThread = GetThread();
    AppDomain * pAppDomain = pThread->GetDomain();

    if (!Security::SkipAndFindFunctionInfo(args->stackMark, NULL, &pCurrentRefSecDesc, &pAppDomain))
        return;

    if (pCurrentRefSecDesc == NULL)
        return;

    COMSecurityRuntime::InitSRData();

    // Is security object frame in a different context?
    bool fSwitchContext = pAppDomain != pThread->GetDomain();

    if (fSwitchContext && args->pInputRefSecDesc != NULL)
        *(OBJECTREF*)&args->pInputRefSecDesc = AppDomainHelper::CrossContextCopyFrom(pAppDomain, (OBJECTREF*)&args->pInputRefSecDesc);

    // This is a stack based objectref
    // and therefore SetObjectReference
    // is not necessary.
    *pCurrentRefSecDesc = args->pInputRefSecDesc;
}


//-----------------------------------------------------------+
// I N I T I A L I Z A T I O N
//-----------------------------------------------------------+

COMSecurityRuntime::SRData COMSecurityRuntime::s_srData;

void COMSecurityRuntime::InitSRData()
{
    THROWSCOMPLUSEXCEPTION();

    if (s_srData.fInitialized == FALSE)
    {
        s_srData.pSecurityRuntime = g_Mscorlib.GetClass(CLASS__SECURITY_RUNTIME);
        s_srData.pFrameSecurityDescriptor = g_Mscorlib.GetClass(CLASS__FRAME_SECURITY_DESCRIPTOR);
        
        s_srData.pFSD_assertions = NULL;
        s_srData.pFSD_denials = NULL;
        s_srData.pFSD_restriction = NULL;
        s_srData.fInitialized = TRUE;
    }
}

//-----------------------------------------------------------
// Initialization of native security runtime.
// Called when SecurityRuntime is constructed.
//-----------------------------------------------------------
void __stdcall COMSecurityRuntime::InitSecurityRuntime(const InitSecurityRuntimeArgs *)
{
    InitSRData();
}

FieldDesc *COMSecurityRuntime::GetFrameSecDescField(DWORD dwAction)
{
    switch (dwAction)
    {
    case dclAssert:
        if (s_srData.pFSD_assertions == NULL)
            s_srData.pFSD_assertions = g_Mscorlib.GetField(FIELD__FRAME_SECURITY_DESCRIPTOR__ASSERT_PERMSET);
        return s_srData.pFSD_assertions;
        break;
        
    case dclDeny:
        if (s_srData.pFSD_denials == NULL)
            s_srData.pFSD_denials = g_Mscorlib.GetField(FIELD__FRAME_SECURITY_DESCRIPTOR__DENY_PERMSET);
        return s_srData.pFSD_denials;
        break;
        
    case dclPermitOnly:
        if (s_srData.pFSD_restriction == NULL)
            s_srData.pFSD_restriction = g_Mscorlib.GetField(FIELD__FRAME_SECURITY_DESCRIPTOR__RESTRICTION_PERMSET);
        return s_srData.pFSD_restriction;
        break;
        
    default:
        _ASSERTE(!"Unknown action requested in UpdateFrameSecurityObj");
        return NULL;
        break;
    }

}
//-----------------------------------------------------------+
// T E M P O R A R Y   M E T H O D S ! ! !
//-----------------------------------------------------------+

//-----------------------------------------------------------
// Warning!! This is passing out a reference to the permissions
// for the module. It must be deep copied before passing it out
//
// This only returns the declared permissions for the class
//-----------------------------------------------------------
LPVOID __stdcall COMSecurityRuntime::GetDeclaredPermissionsP(const GetDeclaredPermissionsArg *args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv;

    // An exception is thrown by the SecurityManager wrapper to ensure this case.
    _ASSERTE(args->pClass != NULL);
    _ASSERTE((CorDeclSecurity)args->iType > dclActionNil &&
             (CorDeclSecurity)args->iType <= dclMaximumValue);

    OBJECTREF or = args->pClass;
    EEClass* pClass = or->GetClass();
    _ASSERTE(pClass);
    _ASSERTE(pClass->GetModule());

    // Return the token that belongs to the Permission just asserted.
    OBJECTREF refDecls;
    HRESULT hr = SecurityHelper::GetDeclaredPermissions(pClass->GetModule()->GetMDImport(),
                                                        pClass->GetCl(),
                                                        (CorDeclSecurity)args->iType,
                                                        &refDecls);
    if (FAILED(hr))
        COMPlusThrowHR(hr);

    *((OBJECTREF*) &rv) = refDecls;
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsecurityruntime.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMSecurityRuntime.h
**
** Author: Paul Kromann (paulkr)
**
** Purpose:
**
** Date:  March 21, 1998
**
===========================================================*/
#ifndef __ComSecurityRuntime_h__
#define __ComSecurityRuntime_h__

#include "common.h"

#include "object.h"
#include "util.hpp"

// Field names inside managed class FrameSecurityDescriptor
#define ASSERT_PERMSET			"m_assertions"
#define DENY_PERMSET			"m_denials"
#define RESTRICTION_PERMSET		"m_restriction"

// Forward declarations to avoid pulling in too many headers.
class Frame;
enum StackWalkAction;


//-----------------------------------------------------------
// The COMSecurityRuntime implements all the native methods
// for the interpreted System/Security/SecurityRuntime.
//-----------------------------------------------------------
class COMSecurityRuntime
{
public:
    //-----------------------------------------------------------
    // Argument declarations for native methods.
    //-----------------------------------------------------------
    
    typedef struct _InitSecurityRuntimeArgs
    {
        OBJECTREF This;
    } InitSecurityRuntimeArgs;
    
    
    typedef struct _GetDeclaredPermissionsArg
    {
        OBJECTREF This;
        INT32     iType;
        OBJECTREF pClass;
    } GetDeclaredPermissionsArg;
    
    
    typedef struct _GetSecurityObjectForFrameArgs
    {
        INT32           create;
        StackCrawlMark* stackMark;
    } GetSecurityObjectForFrameArgs;

    typedef struct _SetSecurityObjectForFrameArgs
    {
        OBJECTREF       pInputRefSecDesc;
        StackCrawlMark* stackMark;
    } SetSecurityObjectForFrameArgs;


public:
    // Initialize the security engine. This is called when a SecurityRuntime
    // object is created, indicating that code-access security is to be
    // enforced. This should be called only once.
    static void     __stdcall InitSecurityRuntime(const InitSecurityRuntimeArgs *);


    // private helper for getting a security object
    static LPVOID   __stdcall GetSecurityObjectForFrame(const GetSecurityObjectForFrameArgs *);
    static void     __stdcall SetSecurityObjectForFrame(const SetSecurityObjectForFrameArgs *);

    static LPVOID   __stdcall GetDeclaredPermissionsP(const GetDeclaredPermissionsArg *);

    static BOOL IsInitialized() { return s_srData.fInitialized; }

    static FieldDesc* GetFrameSecDescField(DWORD dwAction);

    static void InitSRData();

protected:

	//-----------------------------------------------------------
	// Cached class and method pointers.
	//-----------------------------------------------------------
	typedef struct _SRData
	{
		BOOL		fInitialized;
		MethodTable * pSecurityRuntime;
		MethodTable * pFrameSecurityDescriptor;
		FieldDesc   * pFSD_assertions;	// Fields in FrameSecurityDescriptor
		FieldDesc   * pFSD_denials;
		FieldDesc   * pFSD_restriction;
	} SRData;

public:

	static SRData s_srData;

};


#endif /* __ComSecurityRuntime_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsecurityconfig.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
//   File:          COMSecurityConfig.h
//
//   Author:        Gregory Fee
//
//   Purpose:       Native implementation for security config access and manipulation
//
//   Date created : August 30, 2000
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMSecurityConfig_H_
#define _COMSecurityConfig_H_

#include "ArrayList.h"

class COMSecurityConfig
{
public:

    // Duplicated in System.Security.Util.Config.cool
    enum ConfigId
    {
        None = 0,
        MachinePolicyLevel = 1,
        UserPolicyLevel = 2,
        EnterprisePolicyLevel = 3
    };

    // Duplicated in System.Security.Util.Config.cool
    enum QuickCacheEntryType
    {
        ExecutionZoneMyComputer = 0x1,
        ExecutionZoneIntranet = 0x2,
        ExecutionZoneInternet = 0x4,
        ExecutionZoneTrusted = 0x8,
        ExecutionZoneUntrusted = 0x10,
        BindingRedirectsZoneMyComputer = 0x20,
        BindingRedirectsZoneIntranet = 0x40,
        BindingRedirectsZoneInternet = 0x80,
        BindingRedirectsZoneTrusted = 0x100,
        BindingRedirectsZoneUntrusted = 0x200,
        UnmanagedZoneMyComputer = 0x400,
        UnmanagedZoneIntranet = 0x800,
        UnmanagedZoneInternet = 0x1000,
        UnmanagedZoneTrusted = 0x2000,
        UnmanagedZoneUntrusted = 0x4000,
        ExecutionAll = 0x8000,
        BindingRedirectsAll = 0x10000,
        UnmanagedAll = 0x20000,
        SkipVerificationZoneMyComputer = 0x40000,
        SkipVerificationZoneIntranet = 0x80000,
        SkipVerificationZoneInternet = 0x100000,
        SkipVerificationZoneTrusted = 0x200000,
        SkipVerificationZoneUntrusted = 0x400000,
        SkipVerificationAll = 0x800000,
        FullTrustZoneMyComputer = 0x1000000,
        FullTrustZoneIntranet = 0x2000000,
        FullTrustZoneInternet = 0x4000000,
        FullTrustZoneTrusted = 0x8000000,
        FullTrustZoneUntrusted = 0x10000000,
        FullTrustAll = 0x20000000,
    };

    // Duplicated in System.Security.Util.Config.cool
    enum ConfigRetval
    {
        NoFile = 0,
        ConfigFile = 1,
        CacheFile = 2
    };

    struct _InitDataEx {
        DECLARE_ECALL_OBJECTREF_ARG( STRINGREF, cache );
        DECLARE_ECALL_OBJECTREF_ARG( STRINGREF, config );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static INT32 __stdcall EcallInitDataEx( _InitDataEx* );

    struct _InitData {
        DECLARE_ECALL_OBJECTREF_ARG( STRINGREF, config );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };
    
    static INT32 __stdcall EcallInitData( _InitData* );
    static ConfigRetval InitData( INT32 id, WCHAR* configFileName, WCHAR* cacheFileName );
    static ConfigRetval InitData( void* configData, BOOL addToList );

    struct _SaveCacheData {
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static BOOL __stdcall EcallSaveCacheData( _SaveCacheData* );
    static BOOL SaveCacheData( INT32 id );

    struct _ResetCacheData {
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static void __stdcall EcallResetCacheData( _ResetCacheData* );
    static void ResetCacheData( INT32 id );

    struct _ClearCacheData {
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static void __stdcall EcallClearCacheData( _ClearCacheData* );
    static void ClearCacheData( INT32 id );


    struct _SaveDataString {
        DECLARE_ECALL_OBJECTREF_ARG( STRINGREF, data );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static BOOL __stdcall EcallSaveDataString( _SaveDataString* );

    struct _SaveDataByte {
        DECLARE_ECALL_I4_ARG( INT32, length );
        DECLARE_ECALL_I4_ARG( INT32, offset );
        DECLARE_ECALL_OBJECTREF_ARG( U1ARRAYREF, data );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static BOOL __stdcall EcallSaveDataByte( _SaveDataByte* );

    static BOOL __stdcall SaveData( INT32 id, void* buffer, size_t bufferSize );

    struct _RecoverData {
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static BOOL __stdcall EcallRecoverData( _RecoverData* );
    static BOOL RecoverData( INT32 id );

    struct _GetRawData {
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static LPVOID __stdcall GetRawData( _GetRawData* );

    struct _SetGetQuickCacheEntry {
        DECLARE_ECALL_I4_ARG( QuickCacheEntryType, type );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static DWORD __stdcall EcallGetQuickCacheEntry( _SetGetQuickCacheEntry* );
    static DWORD GetQuickCacheEntry( INT32 id, QuickCacheEntryType type );
    static void __stdcall EcallSetQuickCache( _SetGetQuickCacheEntry* );
    static void SetQuickCache( INT32 id, QuickCacheEntryType type );

    struct _GetCacheEntry {
        DECLARE_ECALL_PTR_ARG( CHARARRAYREF*, policy );
        DECLARE_ECALL_OBJECTREF_ARG( CHARARRAYREF, evidence );
        DECLARE_ECALL_I4_ARG( DWORD, numEvidence );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static BOOL __stdcall GetCacheEntry( _GetCacheEntry* );

    struct _AddCacheEntry {
        DECLARE_ECALL_OBJECTREF_ARG( CHARARRAYREF, policy );
        DECLARE_ECALL_OBJECTREF_ARG( CHARARRAYREF, evidence );
        DECLARE_ECALL_I4_ARG( DWORD, numEvidence );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static void __stdcall AddCacheEntry( _AddCacheEntry* );

    struct _GetCacheSecurityOn {
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static DWORD __stdcall GetCacheSecurityOn( _GetCacheSecurityOn* );

    struct _SetCacheSecurityOn {
        DECLARE_ECALL_I4_ARG( INT32, value );
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static void __stdcall SetCacheSecurityOn( _SetCacheSecurityOn* );

    struct _NoArgs {
    };

    static LPVOID __stdcall EcallGetMachineDirectory( _NoArgs* );
    static LPVOID __stdcall EcallGetUserDirectory( _NoArgs* );
    static LPVOID __stdcall EcallGenerateFilesAutomatically( _NoArgs* );

    static BOOL GetMachineDirectory( WCHAR* buffer, size_t bufferCount );
    static BOOL GetUserDirectory( WCHAR* buffer, size_t bufferCount, BOOL fTryDefault );

    struct _WriteToEventLog{
        DECLARE_ECALL_OBJECTREF_ARG( STRINGREF, message );
    };

    static BOOL __stdcall EcallWriteToEventLog( _WriteToEventLog* );

    static BOOL WriteToEventLog( WCHAR* buffer );

    struct _GetStoreLocation {
        DECLARE_ECALL_I4_ARG( INT32, id );
    };

    static LPVOID __stdcall EcallGetStoreLocation( _GetStoreLocation* );
    static BOOL GetStoreLocation( INT32 id, WCHAR* buffer, size_t bufferCount );

    struct _TurnCacheOff {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackmark);
    };

    static void __stdcall EcallTurnCacheOff( _TurnCacheOff* );

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,  message);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,  file);
    } _DebugOut;    
    
    static LPVOID __stdcall DebugOut(_DebugOut*);   

    static void Init( void );
    static void Cleanup( void );
    static void Delete( void );

    static void* GetData( INT32 id );

    static ArrayList entries_;
    static Crst* dataLock_;

    static BOOL configCreated_;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comserialization.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMSerialization.cpp
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Contains helper methods to speed serialization
**
** Date:  August 6, 1999
** 
===========================================================*/
#include <common.h>
#include <winnls.h>
#include "excep.h"
#include "vars.hpp"
#include "COMString.h"
#include "COMStringCommon.h"
#include "COMSerialization.h"


WCHAR COMSerialization::base64[] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='};

/*==============================ByteArrayToString===============================
**Action: Convert a byte array into a string in Base64 notation
**Returns: A String in Base64 notation.
**Arguments: inArray -- The U1 array to process
**           offset  -- The starting position within the array.
**           length  -- The number of bytes to take from the array.
**Exceptions: ArgumentOutOfRangeException if offset and length aren't valid.
**            ArgumentNullException if inArray is null
==============================================================================*/
LPVOID __stdcall COMSerialization::ByteArrayToBase64String(_byteArrayToBase64StringArgs *args) {
    UINT32 inArrayLength;
    UINT32 stringLength;
    INT32 calcLength;
    STRINGREF outString;
    WCHAR *outChars;
    UINT8 *inArray;

    _ASSERTE(args);

    //Do data verfication
    if (args->inArray==NULL) {
        COMPlusThrowArgumentNull(L"inArray");
    }

    if (args->length<0) {
        COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_Index");
    }
    
    if (args->offset<0) {
        COMPlusThrowArgumentOutOfRange(L"offset", L"ArgumentOutOfRange_GenericPositive");
    }

    inArrayLength = args->inArray->GetNumComponents();

    if (args->offset > (INT32)(inArrayLength - args->length)) {
        COMPlusThrowArgumentOutOfRange(L"offset", L"ArgumentOutOfRange_OffsetLength");
    }

    //Create the new string.  This is the maximally required length.
    stringLength = (UINT32)((args->length*1.5)+2);
    
    outString=COMString::NewString(stringLength);
    outChars = outString->GetBuffer();
    calcLength = args->offset + (args->length - (args->length%3));
    
    inArray = (UINT8 *)args->inArray->GetDataPtr();

    int j=0;
    //Convert three bytes at a time to base64 notation.  This will consume 4 chars.
    for (int i=args->offset; i<calcLength; i+=3) {
			outChars[j] = base64[(inArray[i]&0xfc)>>2];
			outChars[j+1] = base64[((inArray[i]&0x03)<<4) | ((inArray[i+1]&0xf0)>>4)];
			outChars[j+2] = base64[((inArray[i+1]&0x0f)<<2) | ((inArray[i+2]&0xc0)>>6)];
			outChars[j+3] = base64[(inArray[i+2]&0x3f)];
			j += 4;
    }

    i =  calcLength; //Where we left off before
    switch(args->length%3){
    case 2: //One character padding needed
        outChars[j] = base64[(inArray[i]&0xfc)>>2];
        outChars[j+1] = base64[((inArray[i]&0x03)<<4)|((inArray[i+1]&0xf0)>>4)];
        outChars[j+2] = base64[(inArray[i+1]&0x0f)<<2];
        outChars[j+3] = base64[64]; //Pad
        j+=4;
        break;
    case 1: // Two character padding needed
        outChars[j] = base64[(inArray[i]&0xfc)>>2];
        outChars[j+1] = base64[(inArray[i]&0x03)<<4];
        outChars[j+2] = base64[64]; //Pad
        outChars[j+3] = base64[64]; //Pad
        j+=4;
        break;
    }

    //Set the string length.  This may leave us with some blank chars at the end of
    //the string, but that's cheaper than doing a copy.
    outString->SetStringLength(j);
    
    RETURN(outString,STRINGREF);
}


/*==============================StringToByteArray===============================
**Action: Convert a String in Base64 notation into a U1 array
**Returns: A newly allocated array containing the bytes found on the string.
**Arguments: inString -- The string to be converted
**Exceptions: ArgumentNullException if inString is null.
**            FormatException if inString's length is invalid (not a multiple of 4).
**            FormatException if inString contains an invalid Base64 number.
==============================================================================*/
LPVOID __stdcall COMSerialization::Base64StringToByteArray(_base64StringToByteArrayArgs *args) {
    _ASSERTE(args);

    INT32 inStringLength;

    if (args->inString==NULL) {
        COMPlusThrowArgumentNull(L"inString");
    }

    inStringLength = (INT32)args->inString->GetStringLength();
    if ((inStringLength<4) || ((inStringLength%4)>0)) {
        COMPlusThrow(kFormatException, L"Format_BadBase64Length");
    }
    
    WCHAR *c = args->inString->GetBuffer();

    INT32 *value = (INT32 *)(new int[inStringLength]);
    int iend = 0;
    int intA = (int)'A';
    int intZ = (int)'Z';
    int inta = (int)'a';
    int intz = (int)'z';
    int int0 = (int)'0';
    int int9 = (int)'9';
    int i;

    //Convert the characters on the stream into an array of integers in the range [0-63].
    for (i=0; i<inStringLength; i++){
        int ichar = (int)c[i];
        if ((ichar >= intA)&&(ichar <= intZ))
            value[i] = ichar - intA;
        else if ((ichar >= inta)&&(ichar <= intz))
            value[i] = ichar - inta + 26;
        else if ((ichar >= int0)&&(ichar <= int9))
            value[i] = ichar - int0 + 52;
        else if (c[i] == '+')
            value[i] = 62;
        else if (c[i] == '/')
            value[i] = 63;
        else if (c[i] == '='){
            value[i] = 0;
            iend++;
        }
        else
            COMPlusThrow(kFormatException, L"Format_BadBase64Char");
    }
    
    //Create the new byte array.  We can determine the size from the chars we read
    //out of the string.
    int blength = (((inStringLength-4)*3)/4)+(3-iend);
    U1ARRAYREF bArray = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, blength);
    U1 *b = (U1*)bArray->GetDataPtr();

    int j = 0;
    int b1;
    int b2;
    int b3;
    //Walk the byte array and convert the int's into bytes in the proper base-64 notation.
    for (i=0; i<(blength); i+=3){
        b1 = (UINT8)((value[j]<<2)&0xfc);
        b1 = (UINT8)(b1|((value[j+1]>>4)&0x03));
        b2 = (UINT8)((value[j+1]<<4)&0xf0);
        b2 = (UINT8)(b2|((value[j+2]>>2)&0x0f));
        b3 = (UINT8)((value[j+2]<<6)&0xc0);
        b3 = (UINT8)(b3|(value[j+3]));
        j+=4;
        b[i] = (UINT8)b1;
        if ((i+1)<blength)
            b[i+1] = (UINT8)b2;
        if ((i+2)<blength)
            b[i+2] = (UINT8)b3;
    }
    
    delete value;
    
    RETURN(bArray,U1ARRAYREF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comstreams.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMStreams.h
**
** Author:  Brian Grunkemeyer (BrianGru)
**
** Purpose: Native implementation for System.IO
**
** Date:  June 29, 1998
** 
===========================================================*/

#ifndef _COMSTREAMS_H
#define _COMSTREAMS_H

#ifdef FCALLAVAILABLE
#include "fcall.h"
#endif

#pragma pack(push, 4)

class COMStreams {
	struct GetCPMaxCharSizeArgs {
		DECLARE_ECALL_I4_ARG(UINT, codePage);
	};

    struct _GetFullPathHelper {
        DECLARE_ECALL_PTR_ARG( STRINGREF*, newPath );
        DECLARE_ECALL_I4_ARG( BOOL, fullCheck );
        DECLARE_ECALL_I4_ARG( DWORD, volumeSeparator );
        DECLARE_ECALL_I4_ARG( DWORD, altDirectorySeparator );
        DECLARE_ECALL_I4_ARG( DWORD, directorySeparator );
        DECLARE_ECALL_OBJECTREF_ARG( CHARARRAYREF, whitespaceChars );
        DECLARE_ECALL_OBJECTREF_ARG( CHARARRAYREF, invalidChars );
        DECLARE_ECALL_OBJECTREF_ARG( STRINGREF, path );
    };

  public:
	// Used by CodePageEncoding
	static FCDECL7(UINT32, BytesToUnicode, UINT codePage, U1Array* bytes0, UINT byteIndex, \
				   UINT byteCount, CHARArray* chars0, UINT charIndex, UINT charCount);
	static FCDECL7(UINT32, UnicodeToBytes, UINT codePage, CHARArray* chars0, UINT charIndex, \
				   UINT charCount, U1Array* bytes0, UINT byteIndex, UINT byteCount/*, LPBOOL lpUsedDefaultChar*/);
	static INT32 __stdcall GetCPMaxCharSize(const GetCPMaxCharSizeArgs *);

    // Used by Path
    static LPVOID _stdcall GetFullPathHelper( _GetFullPathHelper* args );
    static FCDECL1(BOOL, CanPathCircumventSecurity, StringObject * pString);

    // Used by FileStream
    static FCDECL0(BOOL, RunningOnWinNT);

    // Used by Console.
    static FCDECL1(INT, ConsoleHandleIsValid, HANDLE handle);
	static FCDECL0(INT, ConsoleInputCP);
	static FCDECL0(INT, ConsoleOutputCP);
};

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comstreams.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  COMStreams
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Streams native implementation
**
** Date:  June 29, 1998
** 
===========================================================*/
#include "common.h"
#include "excep.h"
#include "object.h"
#include <winbase.h>
#include "COMStreams.h"
#include "field.h"
#include "eeconfig.h"
#include "COMString.h"

union FILEPOS {
    struct {
        UINT32 posLo;
        INT32 posHi;
    };
    UINT64 pos;
};


FCIMPL0(BOOL, COMStreams::RunningOnWinNT)
    FC_GC_POLL_RET();
    return ::RunningOnWinNT();
FCIMPLEND


FCIMPL7(UINT32, COMStreams::BytesToUnicode, UINT codePage, U1Array* byteArray, UINT byteIndex, \
        UINT byteCount, CHARArray* charArray, UINT charIndex, UINT charCount)
    _ASSERTE(byteArray);
    _ASSERTE(byteIndex >=0);
    _ASSERTE(byteCount >=0);
    _ASSERTE(charIndex == 0 || (charIndex > 0 && charArray != NULL));
    _ASSERTE(charCount == 0 || (charCount > 0 && charArray != NULL));

    const char * bytes = (const char*) byteArray->GetDirectConstPointerToNonObjectElements();
    INT32 ret;

    if (charArray != NULL)
    {
        WCHAR* chars = (WCHAR*) charArray->GetDirectPointerToNonObjectElements();
        return WszMultiByteToWideChar(codePage, 0, bytes + byteIndex, 
            byteCount, chars + charIndex, charCount);
    }
    else 
        ret = WszMultiByteToWideChar(codePage, 0, bytes + byteIndex, byteCount, NULL, 0);

    FC_GC_POLL_RET();
    return ret;
FCIMPLEND


FCIMPL7(UINT32, COMStreams::UnicodeToBytes, UINT codePage, CHARArray* charArray, UINT charIndex, \
        UINT charCount, U1Array* byteArray, UINT byteIndex, UINT byteCount /*, LPBOOL lpUsedDefaultChar*/)
    _ASSERTE(charArray);
    _ASSERTE(charIndex >=0);
    _ASSERTE(charCount >=0);
    _ASSERTE(byteIndex == 0 || (byteIndex > 0 && byteArray != NULL));
    _ASSERTE(byteCount == 0 || (byteCount > 0 && byteArray != NULL));

    // WARNING: There's a bug in the OS's WideCharToMultiByte such that if you pass in a 
    // non-null lpUsedDefaultChar and a code page for a "DLL based encoding" (vs. a table 
    // based one?), WCtoMB will fail and GetLastError will give you E_INVALIDARG.  JulieB
    // said this is by design, mostly because no one got around to fixing it (1/24/2001 - 
    // email w/ JRoxe).  This sucks, so I've removed the parameter here to avoid the 
    // problem.    -- BrianGru, 2/20/2001
    //_ASSERTE(!(codePage == CP_UTF8 && lpUsedDefaultChar != NULL));

    const WCHAR * chars = (const WCHAR*) charArray->GetDirectConstPointerToNonObjectElements();
    INT32 ret;
    if (byteArray != NULL)
    {
        char* bytes = (char*) byteArray->GetDirectPointerToNonObjectElements();
        ret = WszWideCharToMultiByte(codePage, 0, chars + charIndex, charCount, bytes + byteIndex, byteCount, 0, NULL/*lpUsedDefaultChar*/);
    } 
    else 
        ret = WszWideCharToMultiByte(codePage, 0, chars + charIndex, charCount, NULL, 0, 0, 0);

    FC_GC_POLL_RET();
    return ret;
FCIMPLEND


FCIMPL0(INT, COMStreams::ConsoleInputCP)
{
    return GetConsoleCP();
}
FCIMPLEND

FCIMPL0(INT, COMStreams::ConsoleOutputCP)
{
    return GetConsoleOutputCP();
}
FCIMPLEND

INT32 COMStreams::GetCPMaxCharSize(const GetCPMaxCharSizeArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);
    CPINFO cpInfo;
    if (!GetCPInfo(args->codePage, &cpInfo)) {
        // CodePage is either invalid or not installed.
        // However, on NT4, UTF-7 & UTF-8 aren't defined.
        if (args->codePage == CP_UTF8)
            return 4;
        if (args->codePage == CP_UTF7)
            return 5;
        COMPlusThrow(kArgumentException, L"Argument_InvalidCP");
    }
    return cpInfo.MaxCharSize;
}

FCIMPL1(INT, COMStreams::ConsoleHandleIsValid, HANDLE handle)
{
    // Do NOT call this method on stdin!

    // Windows apps may have non-null valid looking handle values for stdin, stdout
    // and stderr, but they may not be readable or writable.  Verify this by 
    // calling ReadFile & WriteFile in the appropriate modes.
    // This must handle VB console-less scenarios & WinCE.
    if (handle==INVALID_HANDLE_VALUE)
        return FALSE;  // WinCE should return here.
    DWORD bytesWritten;
    byte junkByte = 0x41;
    BOOL bResult;
    bResult = WriteFile(handle, (LPCVOID) &junkByte, 0, &bytesWritten, NULL);
    // In Win32 apps w/ no console, bResult should be 0 for failure.
    return bResult != 0;
}
FCIMPLEND


// Note: Changing this code also affects Path.GetDirectoryName and Path.GetDirectoryRoot via FixupPath.
LPVOID
COMStreams::GetFullPathHelper( _GetFullPathHelper* args )
{
    THROWSCOMPLUSEXCEPTION();

    size_t pathLength = args->path->GetStringLength();

    if (pathLength >= MAX_PATH) // CreateFile freaks out for a path of 260. Only upto 259 works fine.
        COMPlusThrow( kPathTooLongException, IDS_EE_PATH_TOO_LONG );

    size_t numInvalidChars = args->invalidChars->GetNumComponents();
    WCHAR* invalidCharsBuffer = args->invalidChars->GetDirectPointerToNonObjectElements();
    size_t numWhiteChars = args->whitespaceChars->GetNumComponents();
    WCHAR* whiteSpaceBuffer = args->whitespaceChars->GetDirectPointerToNonObjectElements();
    WCHAR* pathBuffer = args->path->GetBuffer();
    WCHAR newBuffer[MAX_PATH+1];
    WCHAR finalBuffer[MAX_PATH+1];

#ifdef _DEBUG
    // To help debug problems better.
    memset(newBuffer, 0xcc, MAX_PATH * sizeof(WCHAR));
#endif

    unsigned int numSpaces = 0;
    bool fixupDirectorySeparator = false;
    bool fixupDotSeparator = true;
    size_t numDots = 0;
    size_t newBufferIndex = 0;
    unsigned int index = 0;

    // We need to trim whitespace off the end of the string.
    // To do this, we'll just start walking at the back of the
    // path looking for whitespace and stop when we're done.

    if (args->fullCheck)
    {
        for (; pathLength > 0; --pathLength)
        {
            bool foundMatch = false;

            for (size_t whiteIndex = 0; whiteIndex < numWhiteChars; ++whiteIndex)
            {
                if (pathBuffer[pathLength-1] == whiteSpaceBuffer[whiteIndex])
                {
                    foundMatch = true;
                    break;
                }
            }

            if (!foundMatch)
                break;
        }
    }

    if (pathLength == 0)
        COMPlusThrow( kArgumentException, IDS_EE_PATH_ILLEGAL );

   

    // Can't think of a no good way to do this in 1 loop
    // Do the argument validation in the first loop.
    if (args->fullCheck) {
        for (; index < pathLength; ++index)
        {
            WCHAR currentChar = pathBuffer[index];

            // Check for invalid characters by iterating through the
            // provided array and looking for matches.

            for (size_t invalidIndex = 0; invalidIndex < numInvalidChars; ++invalidIndex)
            {
                if (currentChar == invalidCharsBuffer[invalidIndex])
                    COMPlusThrow( kArgumentException, IDS_EE_PATH_HAS_IMPROPER_CHAR );
            }
        }
    }

    index = 0;
    // Number of significant chars other than potentially suppressible dots
    // and spaces since the last directory or volume separator char
    size_t numSigChars = 0;
    int lastSigChar = -1;  // Index of last significant character
    // Whether this segment of the path (not the complete path) started
    // with a volume separator char.  Reject "c:...".
    bool startedWithVolumeSeparator = false;
    bool firstSegment = true;

    // Fixup for Win9x since //server/share becomes c://server/share
    // This prevents our code from turning "\\server" into "\server".
    // On Win9x, //server/share becomes c://server/share
    if (pathBuffer[0] == (WCHAR)args->directorySeparator || pathBuffer[0] == (WCHAR)args->altDirectorySeparator)
    {
        newBuffer[newBufferIndex++] = L'\\';
        index++;
        lastSigChar = 0;
    }

    while (index < pathLength)
    {
        WCHAR currentChar = pathBuffer[index];

        // We handle both directory separators and dots specially.  For directory
        // separators, we consume consecutive appearances.  For dots, we consume
        // all dots beyond the second in succession.  All other characters are
        // added as is.  If addition we consume all spaces after the last other
        // character in a directory name up until the directory separator.

        if (currentChar == (WCHAR)args->directorySeparator || currentChar == (WCHAR)args->altDirectorySeparator)
        {
            // If we have a path like "123.../foo", remove the trailing dots.
            // However, if we found "c:\temp\..\bar" or "c:\temp\...\bar", don't.
            // Also remove trailing spaces from both files & directory names.
            // This was agreed on with the OS folks to fix undeletable directory
            // names ending in spaces.

            // If we saw a '\' as the previous last significant character and 
            // are simply going to write out dots, suppress them.
            // Interesting cases:
            // "\.. \" -> "\..\"   Remove trailing spaces
            // "\. .\" -> "\"      Remove trailing dot then space
            if (numSigChars == 0) {
                // Dot and space handling
                if (numSpaces > 0 && numDots > 0) {
                    // Search for ".." from the last significant character. If 
                    // we find 2 dots, emit them, else suppress everything.
                    bool foundDotDot = false;
                    unsigned int start = (lastSigChar >= 0) ? (unsigned int) lastSigChar : 0;
                    for(unsigned int i = start; i < index; i++) {
                        if (pathBuffer[i] == L'.' && pathBuffer[i + 1] == L'.') {
                            foundDotDot = true;
                            break;
                        }
                    }
                    if (foundDotDot) {
                        newBuffer[newBufferIndex++] = '.';
                        newBuffer[newBufferIndex++] = '.';
                        fixupDirectorySeparator = false;
                    }
                    // Continue in this case, potentially writing out '\'.
                }
                else {
                    // Reject "C:..."
                    if (startedWithVolumeSeparator && numDots > 2)
                        COMPlusThrow( kArgumentException, IDS_EE_PATH_ILLEGAL );

                    if (fixupDotSeparator)
                    {
                        if (numDots > 2)
                            numDots = 2; // reduce multiple dots to 2 dots
                    }
                    for (size_t count = 0; count < numDots; ++count)
                    {
                        newBuffer[newBufferIndex++] = '.';
                    }
                    if (numDots > 0)
                        fixupDirectorySeparator = false;
                }
            }
            numDots = 0;
            numSpaces = 0;  // Suppress trailing spaces

            fixupDotSeparator = true;

            if (!fixupDirectorySeparator)
            {                
                fixupDirectorySeparator = true;
                newBuffer[newBufferIndex++] = args->directorySeparator;
            }
            numSigChars = 0;
            lastSigChar = index;
            startedWithVolumeSeparator = false;
            firstSegment = false;
        }
        else if (currentChar == L'.') // Reduce only multiple .'s only after slash to 2 dots. For instance a...b is a valid file name.
        {
            numDots++;

            // Don't flush out non-terminal spaces here, because they may in
            // the end not be significant.  Turn "c:\ . .\foo" -> "c:\foo"
            // which is the conclusion of removing trailing dots & spaces,
            // as well as folding multiple '\' characters.
        }
        else if (currentChar == L' ')
        {
            numSpaces++;
        }
        else 
        {
            fixupDirectorySeparator = false;

            // To reject strings like "C:...\foo" and "C  :\foo"
            if (firstSegment && currentChar == (WCHAR) args->volumeSeparator) {
                // Only accept "C:", not "c :" or ":"
                char driveLetter = pathBuffer[index-1];
                bool validPath = ((numDots == 0) && (numSigChars >= 1) && (driveLetter != ' '));
                if (!validPath)
                    COMPlusThrow( kArgumentException, IDS_EE_PATH_ILLEGAL );
                startedWithVolumeSeparator = true;
                // We need special logic to make " c:" work, we should not fix paths like "  foo::$DATA"
                if (numSigChars > 1) { // Common case, simply do nothing
					unsigned int spaceCount = 0; // How many spaces did we write out, numSpaces has already been reset.
					while((spaceCount < newBufferIndex) && newBuffer[spaceCount] == ' ')
						spaceCount++;
					if (numSigChars - spaceCount == 1) {
						newBuffer[0] = driveLetter; // Overwrite spaces, we need a special case to not break "  foo" as a relative path.
						newBufferIndex=1;
					}
                }
				numSigChars = 0;
            }
            else {
                numSigChars += 1 + numDots + numSpaces;
            }

            // Copy any spaces & dots since the last significant character
            // to here.  Note we only counted the number of dots & spaces,
            // and don't know what order they're in.  Hence the copy.
            if (numDots > 0 || numSpaces > 0) {
				int numCharsToCopy = (lastSigChar >= 0) ? index - lastSigChar - 1 : index;
				if (numCharsToCopy > 0) {
					wcsncpy(newBuffer + newBufferIndex, pathBuffer + lastSigChar + 1, numCharsToCopy);
					newBufferIndex += numCharsToCopy;
				}
                numDots = 0;
                fixupDotSeparator = false;
                numSpaces = 0;
            }

            newBuffer[newBufferIndex++] = currentChar;
            lastSigChar = index;
        }

        index++;
    }

    // Drop any trailing dots and spaces from file & directory names, EXCEPT
    // we MUST make sure that "C:\foo\.." is correctly handled.
    // Also handle "C:\foo\." -> "C:\foo", while "C:\." -> "C:\"
    if (numSigChars == 0) {
        if (numDots >= 2) {
            // Reject "C:..."
            if (startedWithVolumeSeparator && numDots > 2)
                COMPlusThrow( kArgumentException, IDS_EE_PATH_ILLEGAL );

            bool foundDotDot = (numSpaces == 0);
            if (!foundDotDot) {
                unsigned int start = (lastSigChar >= 0) ? (unsigned int) lastSigChar : 0;
                for(unsigned int i = start; i < index; i++) {
                    if (pathBuffer[i] == L'.' && pathBuffer[i + 1] == L'.') {
                        foundDotDot = true;
                        break;
                    }
                }
            }
            if (foundDotDot) {
                newBuffer[newBufferIndex++] = L'.';
                newBuffer[newBufferIndex++] = L'.';
                numDots = 0;
            }
        }
        // Now handle cases like "C:\foo\. ." -> "C:\foo", "C:\." -> "C:\", "."
        if (numDots > 0) { // We need to not do this step for API's like Path.GetDirectoryName
            if ((args->fullCheck) && newBufferIndex >= 2 && newBuffer[newBufferIndex - 1] == (WCHAR) args->directorySeparator && newBuffer[newBufferIndex - 2] != (WCHAR) args->volumeSeparator) {
                newBufferIndex--;
                newBuffer[newBufferIndex] = L'\0';
            }
            else {
                if (numDots == 1)
                    newBuffer[newBufferIndex++] = L'.';
            }
                
        }
    }

    // If we ended up eating all the characters, bail out.
    if (newBufferIndex == 0)
        COMPlusThrow( kArgumentException, IDS_EE_PATH_ILLEGAL );
    
    newBuffer[newBufferIndex] = L'\0';

    _ASSERTE( newBufferIndex <= MAX_PATH && "Overflowed temporary path buffer" );

    /* Throw an ArgumentException for strings that can't be mapped into the ANSI
       code page correctly (meaning the above path canonicalization code and 
       therefore any security checks we later perform may fail) on Win9x.
       Some Unicode characters (ie, U+2044, FRACTION SLASH, looks like '/') look 
       like the ASCII equivalents and will be mapped accordingly. Additionally,
       reject characters like "a" with odd circles, accent marks, or lines on 
       top, such as U+00E0 - U+00E6 and U+0100 - U+0105. */
    if (RunningOnWin95() && ContainsUnmappableANSIChars(newBuffer)) {
        COMPlusThrow( kArgumentException, IDS_EE_PATH_HAS_IMPROPER_CHAR );
    }

    // Call the Win32 API to do the final canonicalization step.

    WCHAR* name;
    DWORD result = 1;
    DWORD retval;
    WCHAR * pFinal;
    size_t len;

    if (args->fullCheck)
    {
        result = WszGetFullPathName( newBuffer, MAX_PATH + 1, finalBuffer, &name );
        if (result + 1 < MAX_PATH + 1)  // May be necessary for empty strings
            finalBuffer[result + 1] = L'\0';
        pFinal = finalBuffer;
        len = result;
    }
    else {
        pFinal = newBuffer;
        len = newBufferIndex;
    }

    if (result) {
        /* Throw an ArgumentException for paths like \\, \\server, \\server\
           This check can only be properly done after canonicalizing, so 
           \\foo\.. will be properly rejected. */
        if (pFinal[0] == L'\\' && pFinal[1] == L'\\') {
            size_t startIndex = 2;
            while (startIndex < result) {
                if (pFinal[startIndex] == L'\\') {
                    startIndex++;
                    break;
                }
                else {
                    startIndex++;
                }
            }
            if (startIndex == result) {
                COMPlusThrow( kArgumentException, IDS_EE_PATH_INVALID_UNCPATH );
            }
        }
    }

    // Check our result and form the managed string as necessary.

    if (result >= MAX_PATH)
        COMPlusThrow( kPathTooLongException, IDS_EE_PATH_TOO_LONG );

    if (result == 0)
    {
        retval = GetLastError();
        // Catch really odd errors and give a somewhat reasonable error
        if (retval == 0)
            retval = ERROR_BAD_PATHNAME;
        *args->newPath = NULL;
    }
    else
    {
        retval = 0;

        if (args->fullCheck)
            *args->newPath = COMString::NewString( finalBuffer );
        else
            *args->newPath = COMString::NewString( newBuffer );
    }

    RETURN( retval, DWORD );
}

FCIMPL1(BOOL, COMStreams::CanPathCircumventSecurity, StringObject * pString)
    VALIDATEOBJECTREF(pString);

    // Note - only call this on Win9x.
    _ASSERTE(RunningOnWin95());

    // If we ever make strings not null-terminated, we've got some work.
    _ASSERTE(pString->GetBuffer()[pString->GetStringLength()] == L'\0');

    FC_GC_POLL_RET();
    return ContainsUnmappableANSIChars(pString->GetBuffer());
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comserialization.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMSerialization.h
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Contains helper methods to speed serialization
**
** Date:  August 5, 1999
** 
===========================================================*/

#ifndef _COMSERIALIZATION_H
#define _COMSERIALIZATION_H

class COMSerialization {
    
    public:
    
    static WCHAR base64[];

    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, length);
        DECLARE_ECALL_I4_ARG(INT32, offset);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, inArray);
    } _byteArrayToBase64StringArgs;
    static LPVOID __stdcall ByteArrayToBase64String(_byteArrayToBase64StringArgs *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, inString);
    } _base64StringToByteArrayArgs;
    static LPVOID __stdcall Base64StringToByteArray(_base64StringToByteArrayArgs *);
};

#endif _COMSERIALIZATION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comstringbuffer.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMStringBuffer.h
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Contains types and method signatures for the 
** StringBuffer class.
**
** Date:  March 12, 1998
** 
===========================================================*/

//
// Each function that we call through native only gets one argument,
// which is actually a pointer to it's stack of arguments.  Our structs
// for accessing these are defined below.
//


//
// The type signatures and methods for String Buffer
//

#ifndef _STRINGBUFFER_H
#define _STRINGBUFFER_H

#define CAPACITY_LOW  10000
#define CAPACITY_MID  15000
#define CAPACITY_HIGH 20000
#define CAPACITY_FIXEDINC 5000
#define CAPACITY_PERCENTINC 1.25



/*======================RefInterpretGetStringBufferValues=======================
**Intprets a StringBuffer.  Returns a pointer to the character array and the length
**of the string in the buffer.
**
**Args: (IN)ref -- the StringBuffer to be interpretted.
**      (OUT)chars -- a pointer to the characters in the buffer.
**      (OUT)length -- a pointer to the length of the buffer.
**Returns: void
**Exceptions: None.
==============================================================================*/
inline void RefInterpretGetStringBufferValues(STRINGBUFFERREF ref, WCHAR **chars, int *length) {
    *length = (ref)->GetStringRef()->GetStringLength();
    *chars  = (ref)->GetStringRef()->GetBuffer();
}
        
  



class COMStringBuffer {

private:


public:

    static MethodTable* s_pStringBufferClass;

    //
    // NATIVE HELPER METHODS
    //
    static FCDECL0(void*, GetCurrentThread);
    static STRINGREF GetThreadSafeString(STRINGBUFFERREF thisRef,void **currentThread);
    static INT32  NativeGetCapacity(STRINGBUFFERREF thisRef);
    static BOOL   NeedsAllocation(STRINGBUFFERREF thisRef, INT32 requiredSize);
    static void   ReplaceStringRef(STRINGBUFFERREF thisRef, void *currentThread,STRINGREF value);
	// Note the String can change if multiple threads hit a StringBuilder, hence we don't get the String from the StringBuffer to make it threadsafe against GC corruption
    static STRINGREF GetRequiredString(STRINGBUFFERREF *thisRef, STRINGREF thisString, int requiredCapacity);
    static INT32  NativeGetLength(STRINGBUFFERREF thisRef);
    static WCHAR* NativeGetBuffer(STRINGBUFFERREF thisRef);
    static void ReplaceBuffer(STRINGBUFFERREF *thisRef, WCHAR *newBuffer, INT32 newLength);
    static void ReplaceBufferAnsi(STRINGBUFFERREF *thisRef, CHAR *newBuffer, INT32 newCapacity);    
    static INT32 CalculateCapacity(STRINGBUFFERREF thisRef, int, int);
    static STRINGREF CopyString(STRINGBUFFERREF *thisRef, STRINGREF thisString, int newCapacity);
    static INT32 LocalIndexOfString(WCHAR *base, WCHAR *search, int strLength, int patternLength, int startPos);

	static STRINGBUFFERREF NewStringBuffer(INT32 size);
	
    //
    // CLASS INITIALIZERS
    //
    static HRESULT __stdcall LoadStringBuffer();

    //
    //CONSTRUCTORS
    //
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef); 
		DECLARE_ECALL_I4_ARG(INT32, capacity); 
		DECLARE_ECALL_I4_ARG(INT32, length); 
		DECLARE_ECALL_I4_ARG(INT32, startIndex); 
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
    } _makeFromStringArgs;
    static void __stdcall MakeFromString(_makeFromStringArgs *);    

    //
    // BUFFER STATE QUERIES AND MODIFIERS
    //
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef); 
        DECLARE_ECALL_I4_ARG(INT32, capacity);
    } _setCapacityArgs;
    static LPVOID __stdcall SetCapacity(_setCapacityArgs *);
    
    //
    // SEARCHES
    //

#if 0
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef); 
		DECLARE_ECALL_I4_ARG(INT32, options); 
		DECLARE_ECALL_I4_ARG(INT32, startIndex); 
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
    } _indexOfArgs;
    static INT32 __stdcall IndexOf(_indexOfArgs *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef); 
		DECLARE_ECALL_I4_ARG(INT32, options); 
		DECLARE_ECALL_I4_ARG(INT32, endIndex); 
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
    } _lastIndexOfArgs;
    static INT32 __stdcall LastIndexOf(_lastIndexOfArgs *);
#endif

    //
    // MODIFIERS
    //

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef); 
		DECLARE_ECALL_I4_ARG(INT32, count); 
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
		DECLARE_ECALL_I4_ARG(INT32, index); 
    } _insertStringArgs;
    static LPVOID __stdcall InsertString(_insertStringArgs *);

    
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef); 
        DECLARE_ECALL_I4_ARG(INT32, charCount); 
        DECLARE_ECALL_I4_ARG(INT32, startIndex); 
        DECLARE_ECALL_OBJECTREF_ARG(CHARARRAYREF, value);
        DECLARE_ECALL_I4_ARG(INT32, index); 
    } _insertCharArrayArgs;
    static LPVOID __stdcall InsertCharArray(_insertCharArrayArgs *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef); 
		DECLARE_ECALL_I4_ARG(INT32, length); 
		DECLARE_ECALL_I4_ARG(INT32, startIndex);
    } _removeArgs;
    static LPVOID __stdcall Remove(_removeArgs *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGBUFFERREF, thisRef);
        DECLARE_ECALL_I4_ARG(INT32, count); 
        DECLARE_ECALL_I4_ARG(INT32, startIndex);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, newValue); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, oldValue); 
    } _replaceStringArgs;
    static LPVOID __stdcall ReplaceString(_replaceStringArgs *args);



};

/*=================================GetCapacity==================================
**This function is designed to mask the fact that we have a null terminator on 
**the end of the strings and to provide external visibility of the capacity from
**native.
**
**Args: thisRef:  The stringbuffer for which to return the capacity.
**Returns:  The capacity of the StringBuffer.
**Exceptions: None.
==============================================================================*/
inline INT32 COMStringBuffer::NativeGetCapacity(STRINGBUFFERREF thisRef) {
    _ASSERTE(thisRef);
    return (thisRef->GetArrayLength()-1);
}


/*===============================NativeGetLength================================
**
==============================================================================*/
inline INT32 COMStringBuffer::NativeGetLength(STRINGBUFFERREF thisRef) {
    _ASSERTE(thisRef);
    return thisRef->GetStringRef()->GetStringLength();
}


/*===============================NativeGetBuffer================================
**
==============================================================================*/
inline WCHAR* COMStringBuffer::NativeGetBuffer(STRINGBUFFERREF thisRef) {
    _ASSERTE(thisRef);
    return thisRef->GetStringRef()->GetBuffer();
}

inline BOOL COMStringBuffer::NeedsAllocation(STRINGBUFFERREF thisRef, INT32 requiredSize) {
    INT32 currCapacity = NativeGetCapacity(thisRef);
    //Don't need <=.  NativeGetCapacity accounts for the terminating null.
    return currCapacity<requiredSize;}

inline void COMStringBuffer::ReplaceStringRef(STRINGBUFFERREF thisRef, void* currentThead,STRINGREF value) {
    thisRef->SetCurrentThread(currentThead);
    thisRef->SetStringRef(value);
}

#endif _STRINGBUFFER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comstring.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  COMString
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The implementation of the String class.
**
** Date:  March 9, 1998
** 
===========================================================*/
#include "common.h"

#include "object.h"
#include <winnls.h>
#include "utilcode.h"
#include "excep.h"
#include "frames.h"
#include "field.h"
#include "vars.hpp"
#include "COMStringCommon.h"
#include "COMString.h"
#include "COMStringBuffer.h"
#include "COMUtilNative.h"
#include "MetaSig.h"
#include "UtilCode.h"
#include "Excep.h"
#include "COMNlsInfo.h"


//
//
// FORWARD DECLARATIONS
//
//
int ArrayContains(WCHAR, WCHAR *, WCHAR *);
inline WCHAR* __fastcall wstrcopy (WCHAR*,WCHAR*, int);

//
//
// STATIC MEMBER VARIABLES
//
//
MethodTable *COMString::s_pStringMethodTable;
OBJECTHANDLE COMString::EmptyStringHandle=NULL;
LPCUTF8 ToStringMethod="ToString";


//The special string #defines are used as flag bits for weird strings that have bytes
//after the terminating 0.  The only case where we use this right now is the VB BSTR as
//byte array which is described in MakeStringAsByteArrayFromBytes.
#define SPECIAL_STRING_VB_BYTE_ARRAY 0x100
#define MARKS_VB_BYTE_ARRAY(x) ((x) & SPECIAL_STRING_VB_BYTE_ARRAY)
#define MAKE_VB_TRAIL_BYTE(x)  ((WCHAR)((x) | SPECIAL_STRING_VB_BYTE_ARRAY))
#define GET_VB_TRAIL_BYTE(x)   ((x) & 0xFF)


//
//
// CLASS INITIALIZER
//
//
/*==================================Terminate===================================
**
==============================================================================*/
void COMString::Stop() {
    if (EmptyStringHandle != NULL) {
        DestroyGlobalHandle(EmptyStringHandle);
        EmptyStringHandle = NULL;
    }
}

/*==============================GetStringFromClass==============================
**Action:  Gets a String from System/String.
**Args: StringName -- The name of the String to get from the class.
**      *StringHandle -- a pointer to the OBJECTHANDLE in which to store the 
**                       retrieved string.
**Returns: The retrieved STRINGREF.
**Exceptions: ExecutionEngineException if it's unable to get the requested String.
==============================================================================*/
STRINGREF COMString::GetStringFromClass(BinderFieldID id, OBJECTHANDLE *StringHandle) {
    THROWSCOMPLUSEXCEPTION();

    //Get the field descriptor and verify that we actually got one.
    FieldDesc *fd = g_Mscorlib.GetField(id);

    STRINGREF sTemp;
    //Get the value of the String.
    sTemp = (STRINGREF) fd->GetStaticOBJECTREF();
    //Create a GCHandle using the STRINGREF that we just got back.
    OBJECTHANDLE ohTemp = CreateGlobalHandle(NULL);
    StoreObjectInHandle(ohTemp, (OBJECTREF)sTemp);
    *StringHandle = ohTemp;
    //Return the StringRef that we just got.
    return sTemp;
}

//
//
//  CONSTRUCTORS
//
//

static void ProtectedCopy(BYTE *to, BYTE *from, DWORD len, 
                          WCHAR *argName, WCHAR *argMsg)
{
    THROWSCOMPLUSEXCEPTION();

    //Wrap it in a COMPLUS_TRY so we catch it if they try to walk us into bad memory.
    __try 
    {
        memcpyNoGCRefs(to, from, len);
}
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION 
               ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) 
    {
        COMPlusThrowArgumentOutOfRange(argName, argMsg);
}
}

static DWORD ProtectedWcslen(LPCWSTR s, WCHAR *argName, WCHAR *argMsg)
{
    THROWSCOMPLUSEXCEPTION();

    //Wrap it in a COMPLUS_TRY so we catch it if they try to walk us into bad memory.
    __try 
    {
        return (DWORD)wcslen(s);
}
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION 
               ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) 
    {
        COMPlusThrowArgumentOutOfRange(argName, argMsg);
    }

    return 0;
    }


/*=============================StringInitCharArray==============================
**This is actually the String constructor.  See JenH's changes to ceegen to see
**how this is supported.
**
**Arguments:  value -- an array of characters.
**            startIndex -- the place within value where the string starts.
**            length -- the number of characters to be copied from value.
**Returns:    A new string with length characters copied from value.
**Exceptions: NullReferenceException if value is null.
**            IndexOutOfRangeException if startIndex or length is less than 0 or
**            the sum of them is outside value.
**            OutOfMemory if we can't allocate space for the new string.          
==============================================================================*/
FCIMPL4(Object *, COMString::StringInitCharArray, 
        StringObject *thisString, I2Array *value, INT32 startIndex, INT32 length)
{
  _ASSERTE(thisString == 0);        // this is the string constructor, we allocate it
  STRINGREF pString;
  VALIDATEOBJECTREF(value);

  //Do Null and Bounds Checking.
  if (!value) {
      FCThrowArgumentNull(L"value");
  }

  if (startIndex<0) {
      FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
  } 
  if (length<0) {
      FCThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_NegativeLength");
  }
  if ((startIndex)>(INT32)value->GetNumComponents() - length) {
      FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
  }

  //Get the start of the string in the array and create a new String.

  I2ARRAYREF v = (I2ARRAYREF) ObjectToOBJECTREF(value);
  HELPER_METHOD_FRAME_BEGIN_RET_1(v);
  pString = NewString(&v, startIndex, length, length);
  HELPER_METHOD_FRAME_END();

  return OBJECTREFToObject(pString);
}
FCIMPLEND

/*===============================StringInitChars================================
**A string constructor which takes an array of characters and constructs a new
**string from all of the chars in the array.
**
**Arguments:  typedef struct {I2ARRAYREF value;} _stringInitCharsArgs;
**Returns:    A new string with all of the characters copied from value.
**Exceptions: NullReferenceException if value is null.
**            OutOfMemory if we can't allocate space for the new string.          
==============================================================================*/
FCIMPL2(Object *, COMString::StringInitChars, StringObject *stringThis, I2Array *value)
{
  _ASSERTE(stringThis == 0);      // This is the constructor 
  VALIDATEOBJECTREF(value);
  STRINGREF pString;
  int startIndex=0;
  int length;

  I2ARRAYREF v = (I2ARRAYREF) ObjectToOBJECTREF(value);
  HELPER_METHOD_FRAME_BEGIN_RET_1(v);

  //Do Null and Bounds Checking.
  if (!v) {
      pString = GetEmptyString();
  }
  else {
      length = v->GetNumComponents();
      pString = NewString(&v, startIndex, length, length);
  }

  HELPER_METHOD_FRAME_END();
    
  return OBJECTREFToObject(pString);
}
FCIMPLEND


/*===========================StringInitWCHARPtrPartial===========================
**Action:  Takes a wchar *, startIndex, and length and turns this into a string.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL4(Object *, COMString::StringInitWCHARPtrPartial, StringObject *thisString,
        WCHAR *ptr, INT32 startIndex, INT32 length)
{
    _ASSERTE(thisString == 0);        // this is the string constructor, we allocate it
    STRINGREF pString;

    if (length<0) {
        FCThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_NegativeLength");
    }

    if (startIndex<0) {
        FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
    }

    WCHAR *pFrom = ptr + startIndex;
    if (pFrom < ptr) {
        // This means that the pointer operation has had an overflow
        FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_PartialWCHAR");
    }

    HELPER_METHOD_FRAME_BEGIN_RET_0();

    pString = AllocateString(length+1);
    

    ProtectedCopy((BYTE *)pString->GetBuffer(), (BYTE *) (pFrom), length * sizeof(WCHAR),
                  L"ptr", L"ArgumentOutOfRange_PartialWCHAR");

    pString->SetStringLength(length);
    _ASSERTE(pString->GetBuffer()[length]==0);

    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(pString);
}
FCIMPLEND

/*===========================StringInitSBytPtrPartialEx===========================
**Action:  Takes a byte *, startIndex, length, and encoding and turns this into a string.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL5(Object *, COMString::StringInitSBytPtrPartialEx, StringObject *thisString,
        I1 *ptr, INT32 startIndex, INT32 length, Object *encoding)
{
    _ASSERTE(thisString == 0);        // this is the string constructor, we allocate it
    STRINGREF pString;
    VALIDATEOBJECTREF(encoding);

    HELPER_METHOD_FRAME_BEGIN_RET_1(encoding);
    THROWSCOMPLUSEXCEPTION();
    
    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__STRING__CREATE_STRING);
    
    INT64 args[] = {
        ObjToInt64(ObjectToOBJECTREF(encoding)),
        length,
        startIndex,
        (INT64)ptr
    };

    pString = (STRINGREF)Int64ToObj(pMD->Call(args, METHOD__STRING__CREATE_STRING));
    HELPER_METHOD_FRAME_END();
    return OBJECTREFToObject(pString);
}
FCIMPLEND


/*=============================StringInitCharHelper=============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
STRINGREF __stdcall COMString::StringInitCharHelper(LPCSTR pszSource, INT32 length) {
    
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString=NULL;
    DWORD     dwSizeRequired=0;

    _ASSERTE(length>=-1);

    if (!pszSource || length == 0) {
        return GetEmptyString();
    } 
    else if ((size_t)pszSource < 64000) {
        COMPlusThrow(kArgumentException, L"Arg_MustBeStringPtrNotAtom");
    }       

    {
    COMPLUS_TRY {
        if (length==-1) {
            length = (INT32)strlen(pszSource);
			if (length == 0) {
				return GetEmptyString();
			}
        } 
        
        dwSizeRequired=WszMultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszSource, length, NULL, 0);
    } COMPLUS_CATCHEX(COMPLUS_CATCH_ALWAYS_CATCH) {
        COMPlusThrowArgumentOutOfRange(L"ptr", L"ArgumentOutOfRange_PartialWCHAR");
    } COMPLUS_END_CATCH
    }
	if (dwSizeRequired == 0) {
        COMPlusThrow(kArgumentException, L"Arg_InvalidANSIString");
    }

    //MultiByteToWideChar includes the terminating null in the space required.
    pString = AllocateString(dwSizeRequired+1);

    {
    COMPLUS_TRY {
        dwSizeRequired = WszMultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCSTR)pszSource, length, pString->GetBuffer(), dwSizeRequired);
    } COMPLUS_CATCHEX(COMPLUS_CATCH_ALWAYS_CATCH) {
        COMPlusThrowArgumentOutOfRange(L"ptr", L"ArgumentOutOfRange_PartialWCHAR");
    } COMPLUS_END_CATCH
    }
	if (dwSizeRequired == 0) {
        COMPlusThrow(kArgumentException, L"Arg_InvalidANSIString");
    }

    pString->SetStringLength(dwSizeRequired);
    _ASSERTE(pString->GetBuffer()[dwSizeRequired]==0);

    return pString;
}



/*==============================StringInitCharPtr===============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL2(Object *, COMString::StringInitCharPtr, StringObject *stringThis, INT8 *ptr)
{
    _ASSERTE(stringThis == 0);      // This is the constructor 
    Object *result;
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    result = OBJECTREFToObject(StringInitCharHelper((LPCSTR)ptr, -1));
    HELPER_METHOD_FRAME_END();    
    return result;
}
FCIMPLEND
    
/*===========================StringInitCharPtrPartial===========================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL4(Object *, COMString::StringInitCharPtrPartial, StringObject *stringThis, INT8 *ptr,
        INT32 startIndex, INT32 length)
{
    _ASSERTE(stringThis == 0);      // This is the constructor
    STRINGREF pString;

    //Verify the args.
    if (startIndex<0) {
        FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
    }

    if (length<0) {
        FCThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_NegativeLength");
    }

    LPCSTR pBase = (LPCSTR)ptr;
    LPCSTR pFrom = pBase + startIndex;
    if (pFrom < pBase) {
        // Check for overflow of pointer addition
        FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_PartialWCHAR");
    }

    HELPER_METHOD_FRAME_BEGIN_RET_0();
    pString = StringInitCharHelper(pFrom, length);
    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(pString);
}
FCIMPLEND

    

/*==============================StringInitWCHARPtr===============================
**Action: Takes a wchar * which points at a null-terminated array of wchar's and
**        turns this into a string.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL2(Object *, COMString::StringInitWCHARPtr, StringObject *thisString, WCHAR *ptr)
{
    _ASSERTE(thisString == 0);        // this is the string constructor, we allocate it
    STRINGREF pString = NULL;

    HELPER_METHOD_FRAME_BEGIN_RET_0();

    if (!ptr) {
        pString = GetEmptyString();
    } 
    else if ((size_t) ptr < 64000) {
        THROWSCOMPLUSEXCEPTION();
        COMPlusThrow(kArgumentException, L"Arg_MustBeStringPtrNotAtom");
    }
    else {
        DWORD nch;

        nch = ProtectedWcslen(ptr, L"ptr", L"ArgumentOutOfRange_PartialWCHAR");

        pString = AllocateString( nch + 1);
    
        memcpyNoGCRefs(pString->GetBuffer(), ptr, nch*sizeof(WCHAR));
        pString->SetStringLength(nch);
        _ASSERTE(pString->GetBuffer()[nch]==0);
    }
    
    HELPER_METHOD_FRAME_END();
    
    return OBJECTREFToObject(pString);
}
FCIMPLEND


/*=============================StringInitCharCount==============================
**Action: Create a String with length characters and initialize all of those 
**        characters to ch.  
**Returns: A string initialized as described
**Arguments: 
**          length -- the length of the string to be created.
**          ch     -- the character with which to initialize the entire string.
**Exceptions: ArgumentOutOfRangeException if length is less than 0.
==============================================================================*/
FCIMPL3(Object *, COMString::StringInitCharCount, StringObject *stringThis, 
        WCHAR ch, INT32 length);
{
    _ASSERTE(stringThis == 0);      // This is the constructor 
    _ASSERTE(ch>=0);

    if (length<0) {
        FCThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_MustBeNonNegNum");
    }

    STRINGREF pString;

    HELPER_METHOD_FRAME_BEGIN_RET_0();

    THROWSCOMPLUSEXCEPTION();

    pString = NewString(length);
    DWORD dwChar = (ch << 16) | ch;

    //Let's set this a DWORD at a time.
    WCHAR *pBuffer = pString->GetBuffer();
    DWORD *pdwBuffer = (DWORD *)pBuffer;

    int l = length;

    BOOL oddLength = (length % 2 == 1);
    // If we got a string of odd length, substract the length by two first so that
    // we won't run past the buffer that we allocated.
    // For example, if the length of the string is 1,
    // we should make it -1, so that the while loop that follows
    // won't fill two Unicode characters by accident.
    if (oddLength) {
        l -= 2;
        oddLength = TRUE;
    }
    while (l>0) {
        *pdwBuffer=dwChar;
        pdwBuffer++;
        l-=2;
    }

    //Handle the case where we have an odd number of characters.
    if (oddLength) {
        pBuffer[length-1]=ch;
    }

    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(pString);
}
FCIMPLEND

// If allocation logging is on, then calls to FastAllocateString are diverted to this ecall
// method. This allows us to log the allocation, something that the earlier fcall didnt.
LPVOID __stdcall COMString::SlowAllocateString(_slowAllocateStringArgs* args) 
{
    LPVOID ret = NULL;
    STRINGREF s = NewString(args->length);
    *((STRINGREF *)&ret) = s;
    return ret;
}

/*==================================NewString===================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
STRINGREF COMString::NewString(INT32 length) {

    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;

    if (length<0) {
        return NULL;
    } else {
        pString = AllocateString(length+1);
        pString->SetStringLength(length);
        _ASSERTE(pString->GetBuffer()[length] == 0);

        return pString;
    }        
}


/*==================================NewString===================================
**Action: Many years ago, VB didn't have the concept of a byte array, so enterprising
**        users created one by allocating a BSTR with an odd length and using it to 
**        store bytes.  A generation later, we're still stuck supporting this behavior.
**        The way that we do this is to take advantage of the difference between the 
**        array length and the string length.  The string length will always be the 
**        number of characters between the start of the string and the terminating 0.
**        If we need an odd number of bytes, we'll take one wchar after the terminating 0.
**        (e.g. at position StringLength+1).  The high-order byte of this wchar is 
**        reserved for flags and the low-order byte is our odd byte. This function is
**        used to allocate a string of that shape, but we don't actually mark the 
**        trailing byte as being in use yet.
**Returns: A newly allocated string.  Null if length is less than 0.
**Arguments: length -- the length of the string to allocate
**           bHasTrailByte -- whether the string also has a trailing byte.
**Exceptions: OutOfMemoryException if AllocateString fails.
==============================================================================*/
STRINGREF COMString::NewString(INT32 length, BOOL bHasTrailByte) {
    INT32 allocLen=0;
    WCHAR *buffer;

    THROWSCOMPLUSEXCEPTION();
    TRIGGERSGC();

    STRINGREF pString;
    if (length<0) {
        return NULL;
    } else {
        allocLen = length + (bHasTrailByte?1:0);
        pString = AllocateString(allocLen+1);
        pString->SetStringLength(length);
        buffer = pString->GetBuffer();
        buffer[length]=0;
        if (bHasTrailByte) {
            buffer[length+1]=0;
        }
    }

    return pString;
}

//========================================================================
// Creates a System.String object and initializes from
// the supplied null-terminated C string.
//
// Maps NULL to null. This function does *not* return null to indicate
// error situations: it throws an exception instead.
//========================================================================
STRINGREF COMString::NewString(const WCHAR *pwsz)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pwsz)
    {
        return NULL;
    }
    else
    {

        DWORD nch = (DWORD)wcslen(pwsz);
        if (nch==0) {
            return GetEmptyString();
        }
        _ASSERTE(!g_pGCHeap->IsHeapPointer((BYTE *) pwsz) ||
                 !"pwsz can not point to GC Heap");
        STRINGREF pString = AllocateString( nch + 1);

        memcpyNoGCRefs(pString->GetBuffer(), pwsz, nch*sizeof(WCHAR));
        pString->SetStringLength(nch);
        _ASSERTE(pString->GetBuffer()[nch] == 0);
        return pString;
    }
}

STRINGREF COMString::NewString(const WCHAR *pwsz, int length) {
    THROWSCOMPLUSEXCEPTION();

    if (!pwsz)
    {
        return NULL;
    }
    else if (length==0) {
        return GetEmptyString();
    } else {
        _ASSERTE(!g_pGCHeap->IsHeapPointer((BYTE *) pwsz) ||
                 !"pwsz can not point to GC Heap");
        STRINGREF pString = AllocateString( length + 1);

        memcpyNoGCRefs(pString->GetBuffer(), pwsz, length*sizeof(WCHAR));
        pString->SetStringLength(length);
        _ASSERTE(pString->GetBuffer()[length] == 0);
        return pString;
    }
}    

STRINGREF COMString::NewString(LPCUTF8 psz)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(psz);
    int length = (int)strlen(psz);
    if (length == 0) {
        return GetEmptyString();
    }
    CQuickBytes qb;
    WCHAR* pwsz = (WCHAR*) qb.Alloc((length) * sizeof(WCHAR));
	if (!pwsz) {
        COMPlusThrowOM();
	}
    length = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, psz, length, pwsz, length);
	if (length == 0) {
        COMPlusThrow(kArgumentException, L"Arg_InvalidUTF8String");
	}
    return NewString(pwsz, length);
}

STRINGREF COMString::NewString(LPCUTF8 psz, int cBytes)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(psz);
    _ASSERTE(cBytes >= 0);
    if (cBytes == 0) {
        return GetEmptyString();
    }
    CQuickBytes qb;
    WCHAR* pwsz = (WCHAR*) qb.Alloc((cBytes) * sizeof(WCHAR));
	if (!pwsz) {
        COMPlusThrowOM();
	}
    int length = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, psz, cBytes, pwsz, cBytes);
	if (length == 0) {
        COMPlusThrow(kArgumentException, L"Arg_InvalidUTF8String");
	}
    return NewString(pwsz, length);
}

STRINGREF COMString::NewStringFloat(const WCHAR *pwsz, int decptPos, int sign, WCHAR decpt) {
    int length;
    STRINGREF pString;
    int idx=0;
    WCHAR *buffer;
    int i=0;

    THROWSCOMPLUSEXCEPTION();

    if (!pwsz) {
        return NULL;
    }
    
    length = (int)(wcslen(pwsz) + (sign!=0) + 1); //+1 for the decpt;
    if (decptPos<0) {
        length+=(-decptPos);
    }
    _ASSERTE(!g_pGCHeap->IsHeapPointer((BYTE *) pwsz) ||
             !"pwsz can not point to GC Heap");
    pString = AllocateString(length+1);
    buffer = pString->GetBuffer();
    if (sign!=0) {
        buffer[idx++]='-';
    }

    if (decptPos<=0) {
        buffer[idx++]='0';
        buffer[idx++]=decpt;
        for (int j=0; j<(-decptPos); j++, idx++) {
            buffer[idx]='0';
        }
    } else {
        for (i=0; i<decptPos; i++,idx++) {
            buffer[idx]=pwsz[i];
        }
        buffer[idx++]=decpt;
    }
    length = (int)wcslen(pwsz);
    for (;i<length; i++, idx++) { 
        buffer[idx]=pwsz[i];
    }
    _ASSERTE(buffer[idx]==0);
    pString->SetStringLength(idx);
    return pString;
}

STRINGREF COMString::NewStringExponent(const WCHAR *pwsz, int decptPos, int sign, WCHAR decpt) {

    int length;
    STRINGREF pString;
    int idx=0;
    WCHAR *buffer; 
    int i;

    THROWSCOMPLUSEXCEPTION();

    if (!pwsz) {
        return NULL;
    }
    
    length = (int)(wcslen(pwsz) + (sign!=0) + 1 + 5); //+1 for the decpt; /+5 for the exponent.
    _ASSERTE(!g_pGCHeap->IsHeapPointer((BYTE *) pwsz) ||
             !"pwsz can not point to GC Heap");
    pString = AllocateString(length+1);
    buffer = pString->GetBuffer();
    if (sign!=0) {
        buffer[idx++]='-';
    }
    buffer[idx++]=pwsz[0];
    buffer[idx++]=decpt;

    length = (int)wcslen(pwsz);
    for (i=1;i<length; i++, idx++) { 
        buffer[idx]=pwsz[i];
    }
    buffer[idx++]='e';
    if (decptPos<0) {
        buffer[idx++]='-';
    } else {
        buffer[idx++]='+';
    }

    if (decptPos!=0) {
        decptPos--;
    }
    if (decptPos<0) {
        decptPos=-decptPos;
    }
    for (i=idx+2; i>=idx; i--) {
        buffer[i]=decptPos%10+'0';
        decptPos=decptPos/10;
    }

    _ASSERTE(buffer[idx+3]==0);
    pString->SetStringLength(idx+3);
    
    return pString;
}


STRINGREF COMString::NewString(STRINGREF *srChars, int start, int length) {
    THROWSCOMPLUSEXCEPTION();
    return NewString(srChars, start, length, length);
}

STRINGREF COMString::NewString(STRINGREF *srChars, int start, int length, int capacity) {
    THROWSCOMPLUSEXCEPTION();


    if (length==0 && capacity==0) {
        return GetEmptyString();
    }

    STRINGREF pString = AllocateString( capacity + 1);

    memcpyNoGCRefs(pString->GetBuffer(),&(((*srChars)->GetBuffer())[start]), length*sizeof(WCHAR));
    pString->SetStringLength(length);
    _ASSERTE(pString->GetBuffer()[length] == 0);

    return pString;
}

STRINGREF COMString::NewString(I2ARRAYREF *srChars, int start, int length) {
    THROWSCOMPLUSEXCEPTION();
    return NewString(srChars, start, length, length);
}

STRINGREF COMString::NewString(I2ARRAYREF *srChars, int start, int length, int capacity) {
    THROWSCOMPLUSEXCEPTION();

    if (length==0 && capacity==0) {
        return GetEmptyString();
    }

    STRINGREF pString = AllocateString( capacity + 1);
    
    memcpyNoGCRefs(pString->GetBuffer(),&(((*srChars)->GetDirectPointerToNonObjectElements())[start]), length*sizeof(WCHAR));
    pString->SetStringLength(length);
    _ASSERTE(pString->GetBuffer()[length] == 0);

    return pString;
}

//
//
// COMPARATORS
//
//
bool WcharCompareHelper (STRINGREF thisStr, STRINGREF valueStr)
{
    DWORD *thisChars, *valueChars;
    int thisLength, valueLength;

    //Get all of our required data.
    RefInterpretGetStringValuesDangerousForGC(thisStr, (WCHAR**)&thisChars, &thisLength);
    RefInterpretGetStringValuesDangerousForGC(valueStr, (WCHAR**)&valueChars, &valueLength);

    //If they're different lengths, they're not an exact match.
    if (thisLength!=valueLength) {
        return false;
    }
  
    // Loop comparing a DWORD (2 WCHARs) at a time.
    while ((thisLength -= 2) >= 0)
    {
        if (*thisChars != *valueChars)
            return false;
        ++thisChars;
        ++valueChars;
    }

    // Handle an extra WCHAR.
    if (thisLength == -1)
        return (*((WCHAR *) thisChars) == *((WCHAR *) valueChars));

    return true;
}

/*===============================IsFastSort===============================
**Action: Call the helper to walk the string and see if we have any high chars.
**Returns: void.  The appropriate bits are set on the String.
**Arguments: vThisRef - The string to be checked.
**Exceptions: None.
==============================================================================*/
FCIMPL1(BOOL, COMString::IsFastSort, StringObject* thisRef) {
    VALIDATEOBJECTREF(thisRef);
    _ASSERTE(thisRef!=NULL);
    INT32 state = thisRef->GetHighCharState();
    if (IS_STRING_STATE_UNDETERMINED(state)) {
        INT32 value = InternalCheckHighChars(STRINGREF(thisRef));
        FC_GC_POLL_RET();
        return IS_FAST_SORT(value);
    }
    else {
        FC_GC_POLL_NOT_NEEDED();
        return IS_FAST_SORT(state); //This can indicate either high chars or special sorting chars.
    }
}
FCIMPLEND

/*===============================ValidModifiableString===============================*/

#ifdef _DEBUG 
FCIMPL1(bool, COMString::ValidModifiableString, StringObject* thisRef) {
    FC_GC_POLL_NOT_NEEDED();
    _ASSERTE(thisRef!=NULL);
    VALIDATEOBJECTREF(thisRef);
        // we disallow these bits to be set because stringbuilder is going to modify the
        // string, which will invalidate them.  
    bool ret = (IS_STRING_STATE_UNDETERMINED(thisRef->GetHighCharState()));
    return(ret);
}
FCIMPLEND
#endif


/*=================================EqualsObject=================================
**Args:  typedef struct {STRINGREF thisRef; OBJECTREF value;} _equalsObjectArgs;
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL2(INT32, COMString::EqualsObject, StringObject* thisStr, StringObject* valueStr) 
{
    VALIDATEOBJECTREF(thisStr);
    VALIDATEOBJECTREF(valueStr);

    INT32 ret = false;
    if (thisStr == NULL)
        FCThrow(kNullReferenceException);

    if (!valueStr)
    {
        FC_GC_POLL_RET();
        return ret;
    }

    //Make sure that value is a String.
    if (thisStr->GetMethodTable()!=valueStr->GetMethodTable()) 
    {
        FC_GC_POLL_RET();
        return ret;
    }
    
    ret = WcharCompareHelper (STRINGREF(thisStr), STRINGREF(valueStr));
    FC_GC_POLL_RET();
    return ret;
}
FCIMPLEND
#else
INT32 __stdcall COMString::EqualsObject(COMString::_equalsObjectArgs *args) {
    THROWSCOMPLUSEXCEPTION();

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    //Ensure that value is actually valid.  Note thisRef hopefully isn't null.
    if (!args->value) {
        return false;
    }

    //Make sure that value is a String.
    if (args->thisRef->GetMethodTable()!=args->value->GetMethodTable()) {
        return false;
    }
    
    return EqualsString((_equalsStringArgs *) args);
}
#endif // #ifdef FCALLAVAILABLE

/*=================================EqualsString=================================
**Args:  typedef struct {STRINGREF thisRef; STRINGREF valueRef;} _equalsStringArgs;
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL2(INT32, COMString::EqualsString, StringObject* thisStr, StringObject* valueStr) 
{
    VALIDATEOBJECTREF(thisStr);
    VALIDATEOBJECTREF(valueStr);

    INT32 ret = false;
    if (NULL==thisStr)
        FCThrow(kNullReferenceException);
        
    if (!valueStr)
    {
        FC_GC_POLL_RET();
        return ret;
    }

    ret = WcharCompareHelper (STRINGREF(thisStr), STRINGREF(valueStr));
    FC_GC_POLL_RET();
    return ret;
}
FCIMPLEND
#else
INT32 __stdcall COMString::EqualsString(COMString::_equalsStringArgs *args) {
    
    THROWSCOMPLUSEXCEPTION();

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    //Ensure that value is actually valid.
    if (!args->value) {
        return false;
    }
    
    return WcharCompareHelper (args->thisRef, args->value);
}
#endif //#ifdef FCALLAVAILABLE

BOOL COMString::CaseInsensitiveCompHelper(WCHAR *strAChars, WCHAR *strBChars, INT32 aLength, INT32 bLength, INT32 *result) {
        WCHAR charA;
        WCHAR charB;
        WCHAR *strAStart;
            
        strAStart = strAChars;

        *result = 0;

        //setup the pointers so that we can always increment them.
        //We never access these pointers at the negative offset.
        strAChars--;
        strBChars--;

        do {
            strAChars++; strBChars++;

            charA = *strAChars;
            charB = *strBChars;
                
            //Case-insensitive comparison on chars greater than 0x80 
            //requires a locale-aware casing operation and we're not going there.
            if (charA>=0x80 || charB>=0x80) {
                return FALSE;
            }
              
            //Do the right thing if they differ in case only.
            //We depend on the fact that the uppercase and lowercase letters in the
            //range which we care about (A-Z,a-z) differ only by the 0x20 bit. 
            //The check below takes the xor of the two characters and determines if this bit
            //is only set on one of them.
            //If they're different cases, we know that we need to execute only
            //one of the conditions within block.
            if ((charA^charB)&0x20) {
                if (charA>='A' && charA<='Z') {
                    charA |=0x20;
                } else if (charB>='A' && charB<='Z') {
                    charB |=0x20;
                }
            }
        } while (charA==charB && charA!=0);
            
        //Return the (case-insensitive) difference between them.
        if (charA!=charB) {
            *result = (int)(charA-charB);
            return TRUE;
        }

        //The length of b was unknown because it was just a pointer to a null-terminated string.
        //If we get here, we know that both A and B are pointing at a null.  However, A can have
        //an embedded null.  Check the number of characters that we've walked in A against the 
        //expected length.
        if (bLength==-1) {
            if ((strAChars - strAStart)!=aLength) {
                *result = 1;
                return TRUE;
            }
            *result=0;
            return TRUE;
        }

        *result = (aLength - bLength);
        return TRUE;
}

/*================================CompareOrdinal===============================
**Args: typedef struct {STRINGREF strA; STRINGREF strB;} _compareOrdinalArgs;
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL3(INT32, COMString::FCCompareOrdinal, StringObject* strA, StringObject* strB, BOOL bIgnoreCase) {
    VALIDATEOBJECTREF(strA);
    VALIDATEOBJECTREF(strB);
    DWORD *strAChars, *strBChars;
    INT32 strALength, strBLength;

    //Checks for null are handled in the managed code.
    RefInterpretGetStringValuesDangerousForGC(strA, (WCHAR **) &strAChars, &strALength);
    RefInterpretGetStringValuesDangerousForGC(strB, (WCHAR **) &strBChars, &strBLength);

    //Handle the comparison where we wish to ignore case.
    if (bIgnoreCase) {
        INT32 result;
        if (CaseInsensitiveCompHelper((WCHAR *)strAChars, (WCHAR *)strBChars, strALength, strBLength, &result)) {
            return result;
        } else {
            //This will happen if we have characters greater than 0x7F.
            FCThrow(kArgumentException);
        }
               
    }
    
    // If the strings are the same length, compare exactly the right # of chars.
    // If they are different, compare the shortest # + 1 (the '\0').
    int count = strALength;
    if (count > strBLength)
        count = strBLength;
    ptrdiff_t diff = (char *)strAChars - (char *)strBChars;
    
    // Loop comparing a DWORD at a time.
    while ((count -= 2) >= 0)
    {
		if ((*((DWORD* )((char *)strBChars + diff)) - *strBChars) != 0)
        {
            LPWSTR ptr1 = (WCHAR*)((char *)strBChars + diff);
            LPWSTR ptr2 = (WCHAR*)strBChars;
            if (*ptr1 != *ptr2) {
                return ((int)*ptr1 - (int)*ptr2);
            }
            return ((int)*(ptr1+1) - (int)*(ptr2+1));
        }
		++strBChars;
    }
    
    // Handle an extra WORD.
    int c;
    if (count == -1)
        if ((c = *((WCHAR *) ((char *)strBChars + diff)) - *((WCHAR *) strBChars)) != 0)
            return c;
    FC_GC_POLL_RET();
    return strALength - strBLength;
}
FCIMPLEND
#else
INT32 __stdcall COMString::CompareOrdinal(COMString::_compareOrdinalArgs *args) {
    DWORD *strAChars, *strBChars;
    int strALength, strBLength;
    
    _ASSERTE(args);

    // This runtime test is handled in the managed code.
    _ASSERTE(args->strA != NULL && args->strB != NULL);

    RefInterpretGetStringValuesDangerousForGC(args->strA, (WCHAR **) &strAChars, &strALength);
    RefInterpretGetStringValuesDangerousForGC(args->strB, (WCHAR **) &strBChars, &strBLength);

    // If the strings are the same length, compare exactly the right # of chars.
    // If they are different, compare the shortest # + 1 (the '\0').
    int count = strALength;
    if (count > strBLength)
        count = strBLength;
    ptrdiff_t diff = (char *)strAChars - (char *)strBChars;

    // Loop comparing a DWORD at a time.
    while ((count -= 2) >= 0)
    {
        if ((*((DWORD* )((char *)strBChars + diff)) - *strBChars) != 0)
        {
            LPWSTR ptr1 = (WCHAR*)((char *)strBChars + diff);
            LPWSTR ptr2 = (WCHAR*)strBChars;
            if (*ptr1 != *ptr2) {
                return ((int)*ptr1 - (int)*ptr2);
            }
            return ((int)*(ptr1+1) - (int)*(ptr2+1));
        }
        ++strBChars;
    }

    int c;
    // Handle an extra WORD.
    if (count == -1)
        if ((c = *((short *) ((char *)strBChars + diff)) - *((short *) strBChars)) != 0)
            return c;
    return strALength - strBLength;
}
#endif

//This function relies on the fact that we put a terminating null on the end of
//all managed strings.
FCIMPL4(INT32, COMString::FCCompareOrdinalWC, StringObject* strA, WCHAR *strBChars, BOOL bIgnoreCase, BOOL *bSuccess) {
    VALIDATEOBJECTREF(strA);
    WCHAR *strAChars;
    WCHAR *strAStart;
    INT32 aLength;
    INT32 ret;

    *bSuccess = 1;

    //Argument Checking
    if (strA==NULL) {
        FCThrow(kArgumentNullException);
    }

    if (strBChars==NULL) {
        FCThrow(kArgumentNullException);
    }

    //Get our data.
    RefInterpretGetStringValuesDangerousForGC(strA, (WCHAR **) &strAChars, &aLength);

    //Record the start pointer for some comparisons at the end.
    strAStart = strAChars;

    if (!bIgnoreCase) { //Handle the case-sensitive comparison first
        while ( *strAChars==*strBChars && *strAChars!='\0') {
            strAChars++; strBChars++;
        }
        if (*strAChars!=*strBChars) {
            ret = INT32(*strAChars - *strBChars);
        }
        
        //We've reached a terminating null in string A, so we need to ensure that 
        //String B isn't a substring of A.  (A may have an embedded null.  B is 
        //known to be a null-terminated string.)  We do this by comparing the number
        //of characters which we walked in A with the expected length.
        else if ( (strAChars - strAStart) != aLength) {
            ret = 1;
        }
        else {
            //The two strings were equal.
            ret = 0;
        }
    } else { //Handle the case-insensitive comparison separately.
        if (!CaseInsensitiveCompHelper(strAChars, strBChars, aLength, -1, &ret)) {
            //This will happen if we have characters greater than 0x7F. This indicates that the function failed.
            // We don't throw an exception here. You can look at the success value returned to do something meaningful.
            *bSuccess = 0;
            ret = 1;
        }
    }
    FC_GC_POLL_RET();
    return ret;
}
FCIMPLEND

INT32 DoLookup(wchar_t charA, wchar_t charB) {
    
    if ((charA ^ charB) & 0x20) {
        //We may be talking about a special case
        if (charA>='A' && charA<='Z') {
            return charB - charA;
        }

        if (charA>='a' && charA<='z') {
            return charB - charA;
        }
    }

    return charA-charB;
}

/*================================CompareOrdinalEx===============================
**Args: typedef struct {STRINGREF thisRef; INT32 options; INT32 length; INT32 valueOffset;\
        STRINGREF value; INT32 thisOffset;} _compareOrdinalArgsEx;
==============================================================================*/

FCIMPL5(INT32, COMString::CompareOrdinalEx, StringObject* strA, INT32 indexA, StringObject* strB, INT32 indexB, INT32 count)
{
    VALIDATEOBJECTREF(strA);
    VALIDATEOBJECTREF(strB);
    DWORD *strAChars, *strBChars;
    int strALength, strBLength;
    
    // This runtime test is handled in the managed wrapper.
    _ASSERTE(strA != NULL && strB != NULL);

    //If any of our indices are negative throw an exception.
    if (count<0) 
    {
        FCThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_MustBePositive");
    }
    if (indexA < 0) 
    {
        FCThrowArgumentOutOfRange(L"indexA", L"ArgumentOutOfRange_MustBePositive");
    }
    if (indexB < 0) 
    {
        FCThrowArgumentOutOfRange(L"indexB", L"ArgumentOutOfRange_MustBePositive");
    }

    RefInterpretGetStringValuesDangerousForGC(strA, (WCHAR **) &strAChars, &strALength);
    RefInterpretGetStringValuesDangerousForGC(strB, (WCHAR **) &strBChars, &strBLength);

    int countA = count;
    int countB = count;
    
    //Do a lot of range checking to make sure that everything is kosher and legit.
    if (count  > (strALength - indexA)) {
        countA = strALength - indexA;
        if (countA < 0)
            FCThrowArgumentOutOfRange(L"indexA", L"ArgumentOutOfRange_Index");
    }
    
    if (count > (strBLength - indexB)) {
        countB = strBLength - indexB;
        if (countB < 0)
            FCThrowArgumentOutOfRange(L"indexB", L"ArgumentOutOfRange_Index");
    }

    count = (countA < countB) ? countA : countB;

    // Set up the loop variables.
    strAChars = (DWORD *) ((WCHAR *) strAChars + indexA);
    strBChars = (DWORD *) ((WCHAR *) strBChars + indexB);

    ptrdiff_t diff = (char *)strAChars - (char *)strBChars;

    // Loop comparing a DWORD at a time.
    while ((count -= 2) >= 0)
    {
        if ((*((DWORD* )((char *)strBChars + diff)) - *strBChars) != 0)
        {
            LPWSTR ptr1 = (WCHAR*)((char *)strBChars + diff);
            LPWSTR ptr2 = (WCHAR*)strBChars;
            if (*ptr1 != *ptr2) {
                return ((int)*ptr1 - (int)*ptr2);
            }
            return ((int)*(ptr1+1) - (int)*(ptr2+1));
        }
        ++strBChars;
    }

    int c;
    // Handle an extra WORD.
    if (count == -1) {
        if ((c = *((WCHAR *) ((char *)strBChars + diff)) - *((WCHAR *) strBChars)) != 0)
            return c;
    }

    
    FC_GC_POLL_RET();
    return countA - countB;

}
FCIMPLEND

/*=================================IndexOfChar==================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
    
FCIMPL4 (INT32, COMString::IndexOfChar, StringObject* thisRef, INT32 value, INT32 startIndex, INT32 count )
{
    VALIDATEOBJECTREF(thisRef);
    if (thisRef==NULL)
        FCThrow(kNullReferenceException);

    WCHAR *thisChars;
    int thisLength;

    RefInterpretGetStringValuesDangerousForGC(thisRef, &thisChars, &thisLength);

    if (startIndex < 0 || startIndex > thisLength) {
        FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
    }

    if (count   < 0 || count > thisLength - startIndex) {
        FCThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Count");
    }
    
    int endIndex = startIndex + count;
    for (int i=startIndex; i<endIndex; i++) 
    {
        if (thisChars[i]==value) 
        {
            FC_GC_POLL_RET();
            return i;
        }
    }

    FC_GC_POLL_RET();
    return -1;
}
FCIMPLEND    

/*===============================IndexOfCharArray===============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL4(INT32, COMString::IndexOfCharArray, StringObject* thisRef, CHARArray* valueRef, INT32 startIndex, INT32 count )
{
    VALIDATEOBJECTREF(thisRef);
    VALIDATEOBJECTREF(valueRef);

    if (thisRef==NULL)
        FCThrow(kNullReferenceException);
    if (valueRef==NULL)
        FCThrow(kArgumentNullException);

    WCHAR *thisChars;
    WCHAR *valueChars;
    WCHAR *valueEnd;
    int valueLength;
    int thisLength;

    RefInterpretGetStringValuesDangerousForGC(thisRef, &thisChars, &thisLength);

    if (startIndex<0 || startIndex>thisLength) {
        FCThrow(kArgumentOutOfRangeException);
    }
    
    if (count   < 0 || count > thisLength - startIndex) {
        FCThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Count");
    }
    

    int endIndex = startIndex + count;

    valueLength = valueRef->GetNumComponents();
    valueChars = (WCHAR *)valueRef->GetDataPtr();
    valueEnd = valueChars+valueLength;
    
    for (int i=startIndex; i<endIndex; i++) {
        if (ArrayContains(thisChars[i], valueChars, valueEnd) >= 0) {
            FC_GC_POLL_RET();
            return i;
        }
    }

    FC_GC_POLL_RET();
    return -1;
}
FCIMPLEND


/*===============================LastIndexOfChar================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
    
FCIMPL4(INT32, COMString::LastIndexOfChar, StringObject* thisRef, INT32 value, INT32 startIndex, INT32 count )
{
    VALIDATEOBJECTREF(thisRef);
    WCHAR *thisChars;
    int thisLength;

    if (thisRef==NULL) {
        FCThrow(kNullReferenceException);
    }

    RefInterpretGetStringValuesDangerousForGC(thisRef, &thisChars, &thisLength);

    if (thisLength == 0) {
        FC_GC_POLL_RET();
        return -1;
    }


    if (startIndex<0 || startIndex>=thisLength) {
        FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
    }
   
    if (count<0 || count - 1 > startIndex) {
        FCThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Count");
    }

    int endIndex = startIndex - count + 1;

    //We search [startIndex..EndIndex]
    for (int i=startIndex; i>=endIndex; i--) {
        if (thisChars[i]==value) {
            FC_GC_POLL_RET();
            return i;
        }
    }

    FC_GC_POLL_RET();
    return -1;
}
FCIMPLEND
/*=============================LastIndexOfCharArray=============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
    
FCIMPL4(INT32, COMString::LastIndexOfCharArray, StringObject* thisRef, CHARArray* valueRef, INT32 startIndex, INT32 count )
{
    VALIDATEOBJECTREF(thisRef);
    VALIDATEOBJECTREF(valueRef);
    WCHAR *thisChars, *valueChars, *valueEnd;
    int thisLength, valueLength;

    if (thisRef==NULL) {
        FCThrow(kNullReferenceException);
    }

    if (valueRef==NULL)
        FCThrow(kArgumentNullException);

    RefInterpretGetStringValuesDangerousForGC(thisRef, &thisChars, &thisLength);

    if (thisLength == 0) {
        return -1;
    }

    if (startIndex<0 || startIndex>=thisLength) {
        FCThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
    }

    if (count<0 || count - 1 > startIndex) {
        FCThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Count");
    }
   

    valueLength = valueRef->GetNumComponents();
    valueChars = (WCHAR *)valueRef->GetDataPtr();
    valueEnd = valueChars+valueLength;

    int endIndex = startIndex - count + 1;

    //We search [startIndex..EndIndex]
    for (int i=startIndex; i>=endIndex; i--) {
        if (ArrayContains(thisChars[i],valueChars, valueEnd) >= 0) {
            FC_GC_POLL_RET();
            return i;
        }
    }

    FC_GC_POLL_RET();
    return -1;
}
FCIMPLEND
/*==================================GETCHARAT===================================
**Returns the character at position index.  Thows IndexOutOfRangeException as
**appropriate.
**
**Args:typedef struct {STRINGREF thisRef; int index;} _getCharacterAtArgs;
==============================================================================*/
FCIMPL2(INT32, COMString::GetCharAt, StringObject* str, INT32 index) {
    FC_GC_POLL_NOT_NEEDED();
    VALIDATEOBJECTREF(str);
    if (str == NULL) {
        FCThrow(kNullReferenceException);
    }
    _ASSERTE(str->GetMethodTable() == g_pStringClass);

    if ((unsigned) index < (unsigned) str->GetStringLength())
    //Return the appropriate character.
      return str->GetBuffer()[index];

    // TODO: Jay wants this to be ArgumentOutOfRange, but that is 
    // a pain for the intrinsic.  For now we will make the intrisic happy
    // if we really care what EH is thrown we can fix it
    FCThrow(kIndexOutOfRangeException);
}
FCIMPLEND


/*==================================LENGTH=================================== */

FCIMPL1(INT32, COMString::Length, StringObject* str) {
    FC_GC_POLL_NOT_NEEDED();
    if (str == NULL)
        FCThrow(kNullReferenceException);

    return str->GetStringLength();
}
FCIMPLEND

/*===========================GetPreallocatedCharArray===========================
**We don't ever allocate in this method, so we don't need to worry about GC.
** Range checks are done before this function is called.
**
**Args: typedef struct {STRINGREF thisRef; INT32 length; INT32 bufferStartIndex; I2ARRAYREF buffer;} _getPreallocatedCharArrayArgs;
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL5(void, COMString::GetPreallocatedCharArray, StringObject* str, INT32 startIndex,
        I2Array* buffer, INT32 bufferStartIndex, INT32 length) {
    VALIDATEOBJECTREF(str);
    VALIDATEOBJECTREF(buffer);
    // Get our values;
    WCHAR *thisChars;
    int thisLength;
    RefInterpretGetStringValuesDangerousForGC(str, &thisChars, &thisLength);

    // Copy everything into the buffer at the proper location.
    wstrcopy((WCHAR *)&(buffer->m_Array[bufferStartIndex]),(WCHAR *)&(thisChars[startIndex]),length);
    FC_GC_POLL();
}
FCIMPLEND

#else
void __stdcall COMString::GetPreallocatedCharArray(COMString::_getPreallocatedCharArrayArgs *args) {
  WCHAR *thisChars;
  int thisLength;
  
  THROWSCOMPLUSEXCEPTION();

  _ASSERTE(args);

  //Get our values;
  RefInterpretGetStringValuesDangerousForGC(args->thisRef, &thisChars, &thisLength);

  //Copy everything into the buffer at the proper location.
  memcpyNoGCRefs(&(args->buffer->m_Array[args->bufferStartIndex]),&(thisChars[args->startIndex]),args->length*sizeof(WCHAR));
}
#endif

/*===============================CopyToByteArray================================
**We don't ever allocate in this method, so we don't need to worry about GC.
**
**Args: String this, int sourceIndex, byte[] destination, int destinationIndex, int charCount)
==============================================================================*/
FCIMPL5(void, COMString::InternalCopyToByteArray, StringObject* str, INT32 startIndex,
        U1Array* buffer, INT32 bufferStartIndex, INT32 charCount) {
    VALIDATEOBJECTREF(str);
    VALIDATEOBJECTREF(buffer);
    _ASSERTE(str != NULL);
    _ASSERTE(str->GetMethodTable() == g_pStringClass);
    _ASSERTE(buffer != NULL);
    _ASSERTE(startIndex >= 0);
    _ASSERTE(bufferStartIndex >= 0);
    _ASSERTE(bufferStartIndex >= 0);
    _ASSERTE(charCount >= 0);

        //Get our values;
    WCHAR *thisChars;
    int thisLength;
    RefInterpretGetStringValuesDangerousForGC(str, &thisChars, &thisLength);

    _ASSERTE(!(bufferStartIndex > (INT32)(buffer->GetNumComponents()-charCount*sizeof(WCHAR))));
    _ASSERTE(!(charCount>thisLength - startIndex));

    //Copy everything into the buffer at the proper location.
    memcpyNoGCRefs(&(buffer->m_Array[bufferStartIndex]),&(thisChars[startIndex]),charCount*sizeof(WCHAR));
    FC_GC_POLL();
}
FCIMPLEND

//
//
//  CREATORS
//
//


/*==============================MakeSeparatorList===============================
**Args: baseString -- the string to parse for the given list of separator chars.
**      Separator  -- A string containing all of the split characters.
**      list       -- a pointer to a caller-allocated array of ints for split char indicies.
**      listLength -- the number of slots allocated in list.
**Returns: A list of all of the places within baseString where instances of characters
**         in Separator occur.  
**Exceptions: None.
**N.B.:  This just returns silently if the caller hasn't allocated enough space
**       for the int list.
==============================================================================*/
int MakeSeparatorList(STRINGREF baseString, CHARARRAYREF Separator, int *list, int listLength) {
    int i;
    int foundCount=0;
    WCHAR *thisChars = baseString->GetBuffer();
    int thisLength = baseString->GetStringLength();

    if (!Separator || Separator->GetNumComponents()==0) {
        //If they passed null or an empty string, look for whitespace.
        for (i=0; i<thisLength && foundCount < listLength; i++) {
            if (COMNlsInfo::nativeIsWhiteSpace(thisChars[i])) {
                list[foundCount++]=i;
            }
        }
    } else {
        WCHAR *searchChars = (WCHAR *)Separator->GetDataPtr();
        int searchLength = Separator->GetNumComponents();
        //If they passed in a string of chars, actually look for those chars.
        for (i=0; i<thisLength && foundCount < listLength; i++) {
            if (ArrayContains(thisChars[i],searchChars,searchChars+searchLength) >= 0) {
                list[foundCount++]=i;
            }
        }
    }
    return foundCount;
}

/*====================================Split=====================================
**Args: typedef struct {STRINGREF thisRef; STRINGREF separator} _splitArgs;
==============================================================================*/
LPVOID __stdcall COMString::Split(_splitArgs *args) {
    int numReplaces;
    int numActualReplaces;
    int *sepList;
    int currIndex=0;
    int arrIndex=0;
    WCHAR *thisChars;
    int thisLength;
    int i;
    PTRARRAYREF splitStrings;
    STRINGREF temp;
    LPVOID lpvReturn;
    CQuickBytes BufferHolder;
    
    THROWSCOMPLUSEXCEPTION();
    
    //If any of this happens, we're really busted.
    _ASSERTE(args);

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    if (args->count<0) {
        COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_NegativeCount");
    }

    //Allocate space and fill an array of ints with a list of everyplace within our String
    //that a separator character occurs.
    sepList = (int *)BufferHolder.Alloc(args->thisRef->GetStringLength()*sizeof(int));
    if (!sepList) {
        COMPlusThrowOM();
    }
    numReplaces = MakeSeparatorList(args->thisRef, args->separator, sepList, (INT32)args->thisRef->GetStringLength());
    //Handle the special case of no replaces.
    if (0==numReplaces) {
        splitStrings = (PTRARRAYREF)AllocateObjectArray(1,g_pStringClass);
        if (!splitStrings) {
            COMPlusThrowOM();
        }
        splitStrings->SetAt(0, (OBJECTREF)args->thisRef);
        RETURN(splitStrings, PTRARRAYREF);
    }        

    RefInterpretGetStringValuesDangerousForGC(args->thisRef, &thisChars, &thisLength);

    args->count--;
    numActualReplaces=(numReplaces<args->count)?numReplaces:args->count;

    //Allocate space for the new array.
    //+1 for the string from the end of the last replace to the end of the String.
    splitStrings = (PTRARRAYREF)AllocateObjectArray(numActualReplaces+1,g_pStringClass);

    GCPROTECT_BEGIN(splitStrings);

    for (i=0; i<numActualReplaces && currIndex<thisLength; i++) {
        temp = (STRINGREF)NewString(&args->thisRef, currIndex, sepList[i]-currIndex );
        splitStrings->SetAt(arrIndex++, (OBJECTREF)temp);
        currIndex=sepList[i]+1;
    }

    //Handle the last string at the end of the array if there is one.

    if (currIndex<thisLength && numActualReplaces >= 0) {
        temp = (STRINGREF)NewString(&args->thisRef, currIndex, thisLength-currIndex);
        splitStrings->SetAt(arrIndex, (OBJECTREF)temp);
    } else if (arrIndex==numActualReplaces) {
        //We had a separator character at the end of a string.  Rather than just allowing
        //a null character, we'll replace the last element in the array with an empty string.
        temp = GetEmptyString();
        splitStrings->SetAt(arrIndex, (OBJECTREF)temp);
    }


    *((PTRARRAYREF *)(&lpvReturn))=splitStrings;
    GCPROTECT_END();
    return lpvReturn;
}

/*==============================SUBSTRING==================================
**Creates a substring of the current string.  The new string starts at position
**start and runs for length characters.  The current string is unaffected.
**This method throws an IndexOutOfRangeException if start is less than 0, if
**length is less than 0 or if start+length is greater than the length of the
**current string.
**
**Args:typedef struct {STRINGREF thisRef; int length; int start;} _substringArgs;
=========================================================================*/
LPVOID __stdcall COMString::Substring(COMString::_substringArgs *args) {
  STRINGREF Local;
  int thisLength;

  THROWSCOMPLUSEXCEPTION();
  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }

  //Get our data.
  thisLength = args->thisRef->GetStringLength();

  //Bounds Checking.
  //The args->start>=thisLength is necessary for the case where length is 0 and start is one beyond the end
  //of the legal range.
  if (args->start<0) {
      COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
  }

  if (args->length<0) {
      COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_NegativeLength");
  } 

  if (args->start > thisLength-args->length) {
      COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_IndexLength");
  }

  //Create the new string and copy the piece in which we're interested.
  Local = NewString(&(args->thisRef), args->start,args->length);

  //Force the info into an LPVOID to return.
  RETURN(Local,STRINGREF);

}

/*==================================JoinArray===================================
**This is used to stitch together an array of Strings into a single string 
**including some joining character between each pair.  
**e.g.: a + separator + b + separator + c.  Reads the array until it reaches
**the end of the array or until it finds a null element.
**
**Args: typedef struct {STRINGREF joiner; PTRARRAYREF value;} _joinArrayArgs;
**Returns:  A new string stitched togeter in the pattern documented above.
**Exceptions:See ConcatenateJoinHelperArray in COMStringHelper.cpp
==============================================================================*/
LPVOID __stdcall COMString::JoinArray(COMString::_joinArrayArgs *args) {
    STRINGREF temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    //They didn't really mean to pass a null.  They meant to pass the empty string.
    if (!args->joiner) {
        args->joiner = GetEmptyString();
    }

    //Range check the array
    if (args->value==NULL) {
        COMPlusThrowArgumentNull(L"value",L"ArgumentNull_String");
    }

    if (args->startIndex<0) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
    }
    if (args->count<0) {
        COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_NegativeCount");
    } 

    if (args->startIndex > (INT32)args->value->GetNumComponents() - args->count) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_IndexCountBuffer");
    }

    //Let ConcatenateJoinHelperArray do most of the real work.
    //We use a temp variable because macros & function calls are recipes for disaster.
    temp = ConcatenateJoinHelperArray(&(args->value), &(args->joiner), args->startIndex, args->count);

    RETURN(temp,STRINGREF);

}


/*==================================PadHelper===================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID COMString::PadHelper(_padHelperArgs *args) {
    WCHAR *thisChars, *padChars;
    INT32 thisLength;
    STRINGREF Local=NULL;

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    RefInterpretGetStringValuesDangerousForGC(args->thisRef, &thisChars, &thisLength);

    //Don't let them pass in a negative totalWidth
    if (args->totalWidth<0) {
        COMPlusThrowArgumentOutOfRange(L"totalWidth", L"ArgumentOutOfRange_NeedNonNegNum");
    }

    //If the string is longer than the length which they requested, give them
    //back the old string.
    if (args->totalWidth<thisLength) {
        RETURN(args->thisRef, STRINGREF);
    }

    if (args->isRightPadded) {
        Local = NewString(&(args->thisRef), 0, thisLength, args->totalWidth);
        padChars = Local->GetBuffer();
        for (int i=thisLength; i<args->totalWidth; i++) {
            padChars[i] = args->paddingChar;
        }
        Local->SetStringLength(args->totalWidth);
        padChars[args->totalWidth]=0;
    } else {
        Local = NewString(args->totalWidth);
        INT32 startingPos = args->totalWidth-thisLength;
        padChars = Local->GetBuffer();
        // Reget thisChars, since if NewString triggers GC, thisChars may become trash.
        RefInterpretGetStringValuesDangerousForGC(args->thisRef, &thisChars, &thisLength);
        memcpyNoGCRefs(padChars+startingPos, thisChars, thisLength * sizeof(WCHAR));
        for (int i=0; i<startingPos; i++) {
            padChars[i] = args->paddingChar;
        }
    }

    RETURN(Local,STRINGREF);
}
    

    
    

/*==================================TrimHelper==================================
**Trim removes the characters in value from the left, right or both ends of 
**the given string (thisRef).    
**trimType is actually an enum which can be set to TRIM_LEFT, TRIM_RIGHT or
**TRIM_BOTH.
**
**Returns a new string with the specified characters removed.  thisRef is 
**unchanged.
**
==============================================================================*/
LPVOID COMString::TrimHelper(_trimHelperArgs *args) {
  WCHAR *thisChars, *trimChars;
  int thisLength, trimLength;

  THROWSCOMPLUSEXCEPTION();
  _ASSERTE(args);
  _ASSERTE(args->trimChars);

  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }

  RefInterpretGetStringValuesDangerousForGC(args->thisRef, &thisChars, &thisLength);

  trimLength = args->trimChars->GetNumComponents();
  trimChars = (WCHAR *)args->trimChars->GetDataPtr();
  

  //iRight will point to the first non-trimmed character on the right
  //iLeft will point to the first non-trimmed character on the Left
  int iRight=thisLength-1;  
  int iLeft=0;

  //Trim specified characters.
  if (args->trimType==TRIM_START || args->trimType==TRIM_BOTH) {
      for (iLeft=0; iLeft<thisLength && (ArrayContains(thisChars[iLeft],trimChars,trimChars+trimLength) >= 0); iLeft++);
  }
  if (args->trimType==TRIM_END || args->trimType==TRIM_BOTH) {
      for (iRight=thisLength-1; iRight>iLeft-1 && (ArrayContains(thisChars[iRight],trimChars,trimChars+trimLength) >= 0); iRight--);
  }

  //Create a new STRINGREF and initialize it from the range determined above.
  int len = iRight-iLeft+1;
  STRINGREF Local;
  if (len == thisLength) // Don't allocate a new string is the trimmed string has not changed.
      Local = args->thisRef;
  else
      Local = NewString(&(args->thisRef), iLeft, len);

  RETURN(Local,STRINGREF);
}


/*===================================Replace====================================
**Action: Replaces all instances of oldChar with newChar.
**Returns: A new String with all instances of oldChar replaced with newChar
**Arguments: oldChar -- the character to replace
**           newChar -- the character with which to replace oldChar.
**Exceptions: None
==============================================================================*/
LPVOID COMString::Replace(_replaceArgs *args) {
    STRINGREF newString;
    int length;
    WCHAR *oldBuffer;
    WCHAR *newBuffer;

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    //Get the length and allocate a new String
    //We will definitely do an allocation here, but there's nothing which 
    //requires GC_PROTECT.
    length = args->thisRef->GetStringLength();
    newString = NewString(length);

    //Get the buffers in both of the Strings.
    oldBuffer = args->thisRef->GetBuffer();
    newBuffer = newString->GetBuffer();

    //Copy the characters, doing the replacement as we go.
    for (int i=0; i<length; i++) {
        newBuffer[i]=(oldBuffer[i]==args->oldChar)?args->newChar:oldBuffer[i];
    }
    
    RETURN(newString,STRINGREF);
}


/*====================================Insert====================================
**Action:Inserts a new string into the given string at position startIndex
**       Inserting at String.length is equivalent to appending the string.
**Returns: A new string with value inserted.
**Arguments: value -- the string to insert
**           startIndex -- the position at which to insert it.
**Exceptions: ArgumentException if startIndex is not a valid index or value is null.
==============================================================================*/
LPVOID COMString::Insert(_insertArgs *args) {
    STRINGREF newString;
    int thisLength, newLength, valueLength;
    WCHAR *newChars;
    WCHAR *thisChars;
    WCHAR *valueChars;
    
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    //Check the Arguments
    thisLength = args->thisRef->GetStringLength();
    if (args->startIndex<0 || args->startIndex>thisLength) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
    }
    if (!args->value) {
        COMPlusThrowArgumentNull(L"value",L"ArgumentNull_String");
    }

    //Allocate a new String.
    valueLength = args->value->GetStringLength();
    newLength = thisLength + valueLength;
    newString = NewString(newLength);

    //Get the buffers to access the characters directly.
    newChars = newString->GetBuffer();
    thisChars = args->thisRef->GetBuffer();
    valueChars = args->value->GetBuffer();

    //Copy all of the characters to the appropriate locations.
    memcpyNoGCRefs(newChars, thisChars, (args->startIndex*sizeof(WCHAR)));
    newChars+=args->startIndex;
    memcpyNoGCRefs(newChars, valueChars, valueLength*sizeof(WCHAR));
    newChars+=valueLength;
    memcpyNoGCRefs(newChars, thisChars+args->startIndex, (thisLength - args->startIndex)*sizeof(WCHAR));

    //Set the String length and return;
    //We'll count on the fact that Strings are 0 initialized to set the terminating null.
    newString->SetStringLength(newLength);
    RETURN(newString,STRINGREF);
}


/*====================================Remove====================================
**Action: Removes a range from args->startIndex to args->startIndex+args->count
**        from this string.
**Returns: A new string with the specified range removed.
**Arguments: startIndex -- the position from which to start.
**           count -- the number of characters to remove
**Exceptions: ArgumentException if startIndex and count do not specify a valid
**            range.
==============================================================================*/
LPVOID COMString::Remove(_removeArgs *args) {
    STRINGREF newString;
    int thisLength, newLength;
    WCHAR *newChars;
    WCHAR *thisChars;
    
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    //Range check everything;
    thisLength = args->thisRef->GetStringLength();
    if (args->count<0) {
        COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_NegativeCount");
    }
    if (args->startIndex<0) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
    }

    if ((args->count) > (thisLength-args->startIndex)) {
        COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_IndexCount");
    }

    //Calculate the new length and allocate a new string.
    newLength = thisLength - args->count;
    newString = NewString(newLength);

    //Get pointers to the character arrays.
    thisChars = args->thisRef->GetBuffer();
    newChars = newString->GetBuffer();

    //Copy the appropriate characters to the correct locations.
    memcpyNoGCRefs (newChars, thisChars, args->startIndex * sizeof (WCHAR));  
    memcpyNoGCRefs (&(newChars[args->startIndex]), &(thisChars[args->startIndex + args->count]), (thisLength-(args->startIndex + args->count))*sizeof(WCHAR));

    //Set the string length, null terminator and exit.
    newString->SetStringLength(newLength);
    _ASSERTE(newChars[newLength]==0);

    RETURN(newString, STRINGREF);
}

//
//
// OBJECT FUNCTIONS
//
//

/*=================================GetHashCode==================================
**Calculates the hash code for this particular string and returns it as an int.
**The hashcode calculation is currently done by adding the integer value of the
**characters in the string mod the maximum positive integer.
**
**Returns a hash value for this String generated with the alogithm described above.
**
**Args: None (Except for the string reference.)
**
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL1(INT32, COMString::GetHashCode, StringObject* str) {
  VALIDATEOBJECTREF(str);
  if (str == NULL) {
      FCThrow(kNullReferenceException);
  }

  WCHAR *thisChars;
  int thisLength;

  _ASSERTE(str);
  
  //Get our values;
  RefInterpretGetStringValuesDangerousForGC(str, &thisChars, &thisLength);

  // HashString looks for a terminating null.  We've generally said all strings
  // will be null terminated.  Enforce that.
  _ASSERTE(thisChars[thisLength] == L'\0' && "String should have been null-terminated.  This one was created incorrectly");
  INT32 ret = (INT32) HashString(thisChars);
  FC_GC_POLL_RET();
  return(ret);
}
FCIMPLEND
#else
INT32 __stdcall COMString::GetHashCode(_getHashCodeArgs *args) {
  WCHAR *thisChars;
  int thisLength;

  THROWSCOMPLUSEXCEPTION();

  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }
  
  //Get our values;
  RefInterpretGetStringValuesDangerousForGC(args->thisRef, &thisChars, &thisLength);

  // HashString looks for a terminating null.  We've generally said all strings
  // will be null terminated.  Enforce that.
  _ASSERTE(thisChars[thisLength] == L'\0' && "String should have been null-terminated.  This one was created incorrectly");
  return (INT32) HashString(thisChars);
}
#endif

//
//
// HELPER METHODS
//
//


/*=============================CreationHelperFixed==============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
STRINGREF COMString::CreationHelperFixed(STRINGREF *a, STRINGREF *b, STRINGREF *c) {
    STRINGREF newString = NULL;
    int newLength=0;
    WCHAR *newStringChars;
    int aLen, bLen, cLen = 0;
    
    _ASSERTE(a!=NULL);
    _ASSERTE(b!=NULL);
    _ASSERTE((*a)!=NULL);
    _ASSERTE((*b)!=NULL);

    newLength+=(aLen=(*a)->GetStringLength());
    newLength+=(bLen=(*b)->GetStringLength());
    if (c) {
        newLength+=(cLen=(*c)->GetStringLength());
    }

    newString = AllocateString( newLength + 1);
    newString->SetStringLength(newLength);
    newStringChars = newString->GetBuffer();

    memcpyNoGCRefs(newStringChars, (*a)->GetBuffer(), aLen*sizeof(WCHAR));
    newStringChars+=aLen;
    memcpyNoGCRefs(newStringChars, (*b)->GetBuffer(), bLen*sizeof(WCHAR));
    newStringChars+=bLen;
    if (c) {
        memcpyNoGCRefs(newStringChars, (*c)->GetBuffer(), cLen*sizeof(WCHAR));
        newStringChars+=cLen;
    }

    _ASSERTE(*newStringChars==0);

    return newString;
}

    
inline 
WCHAR *__fastcall wstrcopy (WCHAR* dmem, WCHAR* smem, int charCount)
{
    if (charCount >= 8)
    {
        charCount -= 8;
        do
        {
            ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
            ((DWORD *)dmem)[1] = ((DWORD *)smem)[1];
            ((DWORD *)dmem)[2] = ((DWORD *)smem)[2];
            ((DWORD *)dmem)[3] = ((DWORD *)smem)[3];
            dmem += 8;
            smem += 8;
        }
        while ((charCount -= 8) >= 0);
    }
    if (charCount & 4)
    {
        ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
        ((DWORD *)dmem)[1] = ((DWORD *)smem)[1];
        dmem += 4;
        smem += 4;
    }
    if (charCount & 2)
    {
        ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
        dmem += 2;
        smem += 2;
    }
    if (charCount & 1)
    {
        ((WORD *)dmem)[0] = ((WORD *)smem)[0];
        dmem += 1;
        smem += 1;
    }

    return dmem;
}

#ifdef FCALLAVAILABLE
FCIMPL3(void, COMString::FillString, StringObject* strDest, int destPos, StringObject* strSrc)
{
    VALIDATEOBJECTREF(strDest);
    VALIDATEOBJECTREF(strSrc);
    _ASSERTE(strSrc && strSrc->GetMethodTable() == g_pStringClass);
    _ASSERTE(strDest && strDest->GetMethodTable() == g_pStringClass);
    _ASSERTE(strSrc->GetStringLength() <= strDest->GetArrayLength() - destPos);

    wstrcopy(strDest->GetBuffer() + destPos, strSrc->GetBuffer(), strSrc->GetStringLength());
    FC_GC_POLL();
}
FCIMPLEND
#endif

#ifdef FCALLAVAILABLE
FCIMPL3(void, COMString::FillStringChecked, StringObject* strDest, int destPos, StringObject* strSrc)
{
    VALIDATEOBJECTREF(strDest);
    VALIDATEOBJECTREF(strSrc);
    _ASSERTE(strSrc && strSrc->GetMethodTable() == g_pStringClass);
    _ASSERTE(strDest && strDest->GetMethodTable() == g_pStringClass);

    if (! (strSrc->GetStringLength() <= strDest->GetArrayLength() - destPos) )
    {
        FCThrowVoid(kIndexOutOfRangeException);
    }

    wstrcopy(strDest->GetBuffer() + destPos, strSrc->GetBuffer(), strSrc->GetStringLength());
    FC_GC_POLL();
}
FCIMPLEND
#endif


#ifdef FCALLAVAILABLE
FCIMPL4(void, COMString::FillStringEx, StringObject* strDest, int destPos, StringObject* strSrc, INT32 strLength)
{
    VALIDATEOBJECTREF(strDest);
    VALIDATEOBJECTREF(strSrc);
    _ASSERTE(strSrc && strSrc->GetMethodTable() == g_pStringClass);
    _ASSERTE(strDest && strDest->GetMethodTable() == g_pStringClass);
    _ASSERTE(strLength <= (INT32)(strDest->GetArrayLength() - destPos));

    wstrcopy(strDest->GetBuffer() + destPos, strSrc->GetBuffer(), strLength);
    FC_GC_POLL();
}
FCIMPLEND
#endif

#ifdef FCALLAVAILABLE
FCIMPL5(void, COMString::FillStringArray, StringObject* strDest, INT32 destBase, CHARArray* carySrc, int srcBase, int srcCount)
{
    VALIDATEOBJECTREF(strDest);
    VALIDATEOBJECTREF(carySrc);
    _ASSERTE(strDest && strDest->GetMethodTable() == g_pStringClass);
    _ASSERTE(unsigned(srcCount) < strDest->GetArrayLength() - destBase);
 
    wstrcopy((WCHAR*)strDest->GetBuffer()+destBase, (WCHAR*)carySrc->GetDirectPointerToNonObjectElements() + srcBase, srcCount);
    FC_GC_POLL();
}
FCIMPLEND
#else
void __stdcall COMString::FillStringArray(_fillStringArray *args) {
{
    wstrcopy( args->pvSrc->GetBuffer(), (WCHAR*)args->pvDest->GetDirectPointerToNonObjectElements() + args->base, args->count );
}
#endif

#ifdef FCALLAVAILABLE
FCIMPL5(void, COMString::FillSubstring, StringObject* strDest, int destBase, StringObject* strSrc, INT32 srcBase, INT32 srcCount)
{
    VALIDATEOBJECTREF(strDest);
    VALIDATEOBJECTREF(strSrc);
    _ASSERTE(strDest && strDest->GetMethodTable() == g_pStringClass);
    _ASSERTE(strSrc && strSrc->GetMethodTable() == g_pStringClass);
    _ASSERTE(unsigned(srcCount) < strDest->GetArrayLength() - destBase);

    wstrcopy((WCHAR*)strDest->GetBuffer() + destBase, (WCHAR*)strSrc->GetBuffer() + srcBase, srcCount);
    FC_GC_POLL();
}
FCIMPLEND
#endif


/*===============================SmallCharToUpper===============================
**Action: Uppercases a string composed entirely of characters less than 0x80.  This is
**        designed to be used only internally by some of the security functions that
**        can't go through our normal codepaths because they can't load the nlp files
**        from the assemblies until security is fully initialized.
**Returns: void
**Arguments: pvStrIn -- the string to be uppercased
**           pvStrOut-- a pointer to the string into which to put the result.  This
**           string must be preallocated to the correct length and we assume that it is
**           already 0 terminated.
**Exceptions: None.
==============================================================================*/
FCIMPL2(void, COMString::SmallCharToUpper, StringObject* strIn, StringObject* strOut) {
    VALIDATEOBJECTREF(strIn);
    VALIDATEOBJECTREF(strOut);
    _ASSERTE(strIn && strIn->GetMethodTable() == g_pStringClass);
    _ASSERTE(strOut && strOut->GetMethodTable() == g_pStringClass);

    //
    // Get StringRefs out of the pointers that we've been passed and 
    // verify that they're the same length.
    //
    _ASSERTE(strIn->GetStringLength()==strOut->GetStringLength());
    //
    // Get the length and pointers to each of the buffers.  Walk the length
    // of the string and copy the characters from the inBuffer to the outBuffer,
    // capitalizing it if necessary.  We assert that all of our characters are
    // less than 0x80.
    //
    int length = strIn->GetStringLength();
    WCHAR *inBuff = strIn->GetBuffer();
    WCHAR *outBuff = strOut->GetBuffer();
    WCHAR c;

    INT32 UpMask = ~0x20;
    for(int i=0; i<length; i++) {
        c = inBuff[i];
        _ASSERTE(c<0x80);

        //
        // 0x20 is the difference between upper and lower characters in the lower
        // 128 ASCII characters. And this bit off to make the chars uppercase.
        //
        if (c>='a' && c<='z') {
            c&=UpMask;
        }
        outBuff[i]=c;
    }

    _ASSERTE(outBuff[length]=='\0');
    FC_GC_POLL();
}
FCIMPLEND

/*=============================CreationHelperArray==============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
STRINGREF COMString::CreationHelperArray(PTRARRAYREF *value) {
    int numElems,i;
    int currStringLength;
    int newLength=0;
    int nullStringLength;
    STRINGREF newString;
    STRINGREF currString;
    STRINGREF nullString;
    WCHAR *newStringChars;

    //Get a reference to the null string.
    nullString = GetEmptyString();
    nullStringLength = nullString->GetStringLength();

    //Figure out the total length of the strings in (*value).
    for (numElems=0; numElems<(INT32)((*value)->GetNumComponents()); numElems++) {
        if (!((*value)->m_Array[numElems])) {
            newLength += nullStringLength;
        } else {
            newLength+=((STRINGREF)((*value)->m_Array[numElems]))->GetStringLength();
        }
    }

    //Create a new String
    newString = AllocateString( newLength + 1);
    newString->SetStringLength(newLength);
    newStringChars = newString->GetBuffer();

    _ASSERTE(newStringChars[newLength]==0);

    //Reget the reference since this may have changed during allocation.
    nullString = GetEmptyString();

    //Loop through all of the strings in the array.
    //If one of them is null, insert the nullString (currently, this is the same as the
    //empty string.
    for (i=0; i<numElems; i++) {
        //Attach the actual String and advance the pointer.
        if (!((*value)->m_Array[i])) {
            currString = nullString;
        } else {
            currString = (STRINGREF)((*value)->m_Array[i]);
        }
        currStringLength = currString->GetStringLength();
        memcpyNoGCRefs(newStringChars, currString->GetBuffer(), (currStringLength*sizeof(WCHAR)));
        newStringChars +=currStringLength;
    }

    return newString;
}

/*================================ArrayContains=================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
int ArrayContains(WCHAR searchChar, WCHAR *begin, WCHAR *end) {
    WCHAR *save = begin;
    while (begin < end)
    {
        if (*begin == searchChar)
            return (int) (begin - save);
        ++begin;
    }
    return -1;
}



/*==========================ConcatenateJoinHelperArray==========================
**Args:  value  -- the array of Strings to concatenate
**       joiner -- the (possibly 0-length) string to insert between each string in value.
**Returns:  A string with all of the strings in value concatenated into one giant
**        String.  Each string may be joined by joiner.
==============================================================================*/
STRINGREF COMString::ConcatenateJoinHelperArray(PTRARRAYREF *value, STRINGREF *joiner, INT32 startIndex, INT32 count) {
    int numElems,i;
    int newLength=0;
    int elemCount;
    STRINGREF newString;
    STRINGREF currString;
    STRINGREF nullString;
    WCHAR *newStringChars;
    WCHAR *endStringChars;
    WCHAR *joinerChars;
    INT32 joinerLength;

    THROWSCOMPLUSEXCEPTION();


    _ASSERTE(value);
    _ASSERTE(joiner);
    _ASSERTE(startIndex>=0);
    _ASSERTE(count>=0);
    _ASSERTE(startIndex<=(int)(*value)->GetNumComponents()-count);

    //Get a reference to the null string.
    nullString = GetEmptyString();
    if (*joiner==NULL) {
        *joiner=nullString;
    }

    //If count is 0, that skews a whole bunch of the calculations below, so just special case that
    //and get out of here.
    if (count==0) {
        return nullString;
    }

    //Figure out the total length of the strings in (*value).
    elemCount = startIndex + count;
    for (numElems=startIndex; numElems<elemCount; numElems++) {
        if (((*value)->m_Array[numElems])!=NULL) {
            newLength+=((STRINGREF)((*value)->m_Array[numElems]))->GetStringLength();
        }
    }
    numElems=count;

    //Add enough room for the joiner.
    joinerLength = (*joiner)->GetStringLength();
    newLength += (numElems-1) * joinerLength;


    //Did we overflow?
    // Note that we may not catch all overflows with this check (since
    // we could have wrapped around the 4gb range any number of times
    // and landed back in the positive range.) But for other reasons,
    // we have to do an overflow check before each append below anyway
    // so those overflows will get caught down there.
    if ( (newLength < 0) || ((newLength + 1) < 0) ) {
        COMPlusThrow(kOutOfMemoryException);
    }

    //Create a new String
    newString = AllocateString( newLength + 1);
    newString->SetStringLength(newLength);
    newStringChars = newString->GetBuffer();
    endStringChars = newStringChars + newLength;

    //If this is an empty string, just return.
    if (newLength==0) {
        return newString;
    }

    //Attach the actual String and advance the pointer.
    //Special casing this outside of the loop simplifies the logic of when to 
    //attach the joiner.
    if (((*value)->m_Array[startIndex])!=NULL) {
        currString = (STRINGREF)((*value)->m_Array[startIndex]);

        if ( ((DWORD)(endStringChars - newStringChars)) < currString->GetStringLength() )
        {
            COMPlusThrow(kIndexOutOfRangeException);
        }

        memcpyNoGCRefs(newStringChars, currString->GetBuffer(), (currString->GetStringLength()*sizeof(WCHAR)));
        newStringChars +=currString->GetStringLength();
    }
    
    //Get the joiner characters;
    joinerChars = (*joiner)->GetBuffer();
    
    //Put the first (and possibly only) element into the result string.
    for (i=startIndex+1; i<elemCount; i++) {
        //Attach the joiner.  May not do anything if the joiner is 0 length
        if ( ((DWORD)(endStringChars - newStringChars)) < (DWORD)joinerLength )
        {
            COMPlusThrow(kIndexOutOfRangeException);
        }

        memcpyNoGCRefs(newStringChars,joinerChars,(joinerLength*sizeof(WCHAR)));
        newStringChars += joinerLength;

        //Append the actual string.
        if (((*value)->m_Array[i])!=NULL) {
            currString = (STRINGREF)((*value)->m_Array[i]);
            if ( ((DWORD)(endStringChars - newStringChars)) < currString->GetStringLength() )
            {
                COMPlusThrow(kIndexOutOfRangeException);
            }
            memcpyNoGCRefs(newStringChars, currString->GetBuffer(), (currString->GetStringLength()*sizeof(WCHAR)));
            newStringChars +=currString->GetStringLength();
        }
    }

    _ASSERTE(*newStringChars=='\0');
    return newString;
}

/*================================ReplaceString=================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall COMString::ReplaceString(_replaceStringArgs *args){
  int *replaceIndex;
  int index=0;
  int count=0;
  int newBuffLength=0;
  int replaceCount=0;
  int readPos, writePos;
  int indexAdvance=0;
  WCHAR *thisBuffer, *oldBuffer, *newBuffer, *retValBuffer;
  int thisLength, oldLength, newLength;
  int endIndex;
  CQuickBytes replaceIndices;
  STRINGREF thisString=NULL;
  
  THROWSCOMPLUSEXCEPTION();

  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }

  //Verify all of the arguments.
  if (!args->oldValue) {
    COMPlusThrowArgumentNull(L"oldValue", L"ArgumentNull_Generic");
  }

  //If they asked to replace oldValue with a null, replace all occurances
  //with the empty string.
  if (!args->newValue) {
      args->newValue = COMString::GetEmptyString();
  }

  RefInterpretGetStringValuesDangerousForGC(args->thisRef, &thisBuffer, &thisLength);
  RefInterpretGetStringValuesDangerousForGC(args->oldValue, &oldBuffer, &oldLength);
  RefInterpretGetStringValuesDangerousForGC(args->newValue, &newBuffer, &newLength);

  //Record the endIndex so that we don't need to do this calculation all over the place.
  endIndex = thisLength;

  //If our old Length is 0, we won't know what to replace
  if (oldLength==0) {
      COMPlusThrowArgumentException(L"oldValue", L"Argument_StringZeroLength");
  }

  //replaceIndex is made large enough to hold the maximum number of replacements possible:
  //The case where every character in the current buffer gets replaced.
  replaceIndex = (int *)replaceIndices.Alloc((thisLength/oldLength+1)*sizeof(int));
  if (!replaceIndex) {
	  COMPlusThrowOM();
  }

  index=0;
  while (((index=COMStringBuffer::LocalIndexOfString(thisBuffer,oldBuffer,thisLength,oldLength,index))>-1) && (index<=endIndex-oldLength)) {
      replaceIndex[replaceCount++] = index;
      index+=oldLength;
  }

  if (replaceCount == 0)
    RETURN(args->thisRef, STRINGREF);

  //Calculate the new length of the string and ensure that we have sufficent room.
  INT64 retValBuffLength = thisLength - ((oldLength - newLength) * (INT64)replaceCount);
  if (retValBuffLength > 0x7FFFFFFF)
       COMPlusThrowOM();

  STRINGREF retValString = COMString::NewString((INT32)retValBuffLength);
  retValBuffer = retValString->GetBuffer();

  //Get the update buffers for all the Strings since the allocation could have triggered a GC.
  thisBuffer = args->thisRef->GetBuffer();
  newBuffer = args->newValue->GetBuffer();
  oldBuffer = args->oldValue->GetBuffer();
  
  
  //Set replaceHolder to be the upper limit of our array.
  int replaceHolder = replaceCount;
  replaceCount=0;

  //Walk the array forwards copying each character as we go.  If we reach an instance
  //of the string being replaced, replace the old string with the new string.
  readPos = 0;
  writePos = 0;
  int previousIndex = 0;
  while (readPos<thisLength) {
    if (replaceCount<replaceHolder&&readPos==replaceIndex[replaceCount]) {
      replaceCount++;
      readPos+=(oldLength);
      memcpyNoGCRefs(&retValBuffer[writePos], newBuffer, newLength*sizeof(WCHAR));
      writePos+=(newLength);
    } else {
      retValBuffer[writePos++] = thisBuffer[readPos++];
    }
  }
  retValBuffer[retValBuffLength]='\0';

  retValString->SetStringLength(retValBuffLength);
  retValString->ResetHighCharState();
  RETURN(retValString,STRINGREF);
}


/*=============================InternalHasHighChars=============================
**Action:  Checks if the string can be sorted quickly.  The requirements are that 
**         the string contain no character greater than 0x80 and that the string not
**         contain an apostrophe or a hypen.  Apostrophe and hyphen are excluded so that
**         words like co-op and coop sort together.
**Returns: Void.  The side effect is to set a bit on the string indicating whether or not
**         the string contains high chars.
**Arguments: The String to be checked.
**Exceptions: None
==============================================================================*/
INT32 COMString::InternalCheckHighChars(STRINGREF inString) {
    WCHAR *chars;
    WCHAR c;
    INT32 length;
    
    RefInterpretGetStringValuesDangerousForGC(inString, (WCHAR **) &chars, &length);

    INT32 stringState = STRING_STATE_FAST_OPS;

    for (int i=0; i<length; i++) {
        c = chars[i];
        if (c>=0x80) {
            inString->SetHighCharState(STRING_STATE_HIGH_CHARS);
            return STRING_STATE_HIGH_CHARS;
        } else if (HighCharTable[(int)c]) {
            //This means that we have a character which forces special sorting,
            //but doesn't necessarily force slower casing and indexing.  We'll
            //set a value to remember this, but we need to check the rest of
            //the string because we may still find a charcter greater than 0x7f.
            stringState = STRING_STATE_SPECIAL_SORT;
        }
    }

    inString->SetHighCharState(stringState);
    return stringState;
}

/*=============================TryConvertStringDataToUTF8=============================
**Action:   If the string has no high chars, converts the string into UTF8. If a 
**          high char is found, just returns false. In either case, the high char state
**          on the stringref is set appropriately
**Returns:  bool. True - Success
            False - Caller has to use OS API
**Arguments:inString - String to be checked
**          outString - Caller allocated space where the result will be placed
**          outStrLen - Number of bytes allocated    
==================================================================================*/
bool COMString::TryConvertStringDataToUTF8(STRINGREF inString, LPUTF8 outString, DWORD outStrLen){

    WCHAR   *buf = inString->GetBuffer();
    DWORD   strLen = inString->GetStringLength();
    bool    bSuccess = true;
    if (HAS_HIGH_CHARS(inString->GetHighCharState())) {
        return false;
    }    
    
    bool    bNeedCheck = IS_STRING_STATE_UNDETERMINED(inString->GetHighCharState());
    // Should be at least strLen + 1
    _ASSERTE(outStrLen > strLen);

    if (outStrLen <= strLen)
        return false;
    
    // First try to do it yourself..if high char found, return false
    for (DWORD index = 0; index < strLen; index++){
        
        if (bNeedCheck && (buf[index] >= 0x80 || HighCharTable[ (int)buf[index]])){
            bSuccess = false;
            break;
        }

        outString[index] = (char)buf[index];
    }

    //The actual algorithm for setting the string state has gotten more compilcated and isn't
    //germane to this function, so if we don't get success, we'll simply bail and not set
    //the string state.
    if (bSuccess)
    {
        outString[strLen] = '\0';
        if(bNeedCheck)
        {
            // It only makes sense to set this if the string is undetermined (raid 122192)
            inString->SetHighCharState(STRING_STATE_FAST_OPS);
        }
    }
    
    return bSuccess;
}


/*============================InternalTrailByteCheck============================
**Action: Many years ago, VB didn't have the concept of a byte array, so enterprising
**        users created one by allocating a BSTR with an odd length and using it to 
**        store bytes.  A generation later, we're still stuck supporting this behavior.
**        The way that we do this is to take advantage of the difference between the 
**        array length and the string length.  The string length will always be the 
**        number of characters between the start of the string and the terminating 0.
**        If we need an odd number of bytes, we'll take one wchar after the terminating 0.
**        (e.g. at position StringLength+1).  The high-order byte of this wchar is 
**        reserved for flags and the low-order byte is our odd byte.
**         
**Returns: True if a trail byte has been assigned to this string.  If outBuff was provided
**         it is set to point to the trailing character containing the trail byte.  
**Arguments: str -- The string being examined.
**           outBuff -- An out param for a pointer to the location of the trailing char.
**Exceptions: None.
==============================================================================*/
BOOL COMString::InternalTrailByteCheck(STRINGREF str, WCHAR **outBuff) {
    if (str==NULL) {
        return FALSE;
    }

    if (outBuff) { 
        *outBuff=NULL;
    }

    INT32 arrayLen  = str->GetArrayLength();
    INT32 stringLen = str->GetStringLength();

    //The difference between the arrayLength and the stringLength is normally 1 (the 
    //terminating null).  If it's two or greater, we may have a trail byte, or we may
    //just have a string created from a StringBuilder.  If we find this difference,
    //we need to check the high byte of the first character after the terminating null.
    if ((arrayLen-stringLen)>=2) {
        WCHAR *buffer = str->GetBuffer();
        if (outBuff) {
            *outBuff = &(buffer[stringLen+1]);
        }
        if (MARKS_VB_BYTE_ARRAY(buffer[stringLen+1])) {
            return TRUE;
        }
    }
    return FALSE;
}

/*=================================HasTrailByte=================================
**Action: Use InternalCheckTrailByte to see if the given string has a trail byte.
**Returns: True if <CODE>str</CODE> contains a VB trail byte, false otherwise.
**Arguments: str -- The string to be examined.
**Exceptions: None
==============================================================================*/
BOOL COMString::HasTrailByte(STRINGREF str) {
    return InternalTrailByteCheck(str,NULL);
}

/*=================================GetTrailByte=================================
**Action:  If <CODE>str</CODE> contains a vb trail byte, returns a copy of it.  
**Returns: True if <CODE>str</CODE> contains a trail byte.  *bTrailByte is set to 
**         the byte in question if <CODE>str</CODE> does have a trail byte, otherwise
**         it's set to 0.
**Arguments: str -- The string being examined.
**           bTrailByte -- An out param to hold the value of the trail byte.
**Exceptions: None.
==============================================================================*/
BOOL COMString::GetTrailByte(STRINGREF str, BYTE *bTrailByte) {
    _ASSERTE(bTrailByte);
    WCHAR *outBuff=NULL;
    *bTrailByte=0;

    if (InternalTrailByteCheck(str, &outBuff)) {
        *bTrailByte=GET_VB_TRAIL_BYTE(*outBuff);
        return TRUE;
    }

    return FALSE;
}

/*=================================SetTrailByte=================================
**Action: Sets the trail byte if <CODE>str</CODE> has enough room to contain one.
**Returns: True if the trail byte could be set, false otherwise.
**Arguments: str -- The string into which to set the trail byte.
**           bTrailByte -- The trail byte to be added to the string.
**Exceptions: None.
==============================================================================*/
BOOL COMString::SetTrailByte(STRINGREF str, BYTE bTrailByte) {
    WCHAR *outBuff=NULL;

    InternalTrailByteCheck(str, &outBuff);
    if (outBuff) {
        *outBuff = (MAKE_VB_TRAIL_BYTE(bTrailByte));
        return TRUE;
    }

    return FALSE;
}



//The following characters have special sorting weights when combined with other
//characters, which means we can't use our fast sorting algorithm on them.  
//Most of these are pretty rare control characters, but apostrophe and hyphen
//are fairly common and force us down the slower path.  This is because we want
//"word sorting", which means that "coop" and "co-op" sort together, instead of
//separately as they would if we were doing a string sort.
//      0x0001   6    3    2   2   0  ;Start Of Heading
//      0x0002   6    4    2   2   0  ;Start Of Text
//      0x0003   6    5    2   2   0  ;End Of Text
//      0x0004   6    6    2   2   0  ;End Of Transmission
//      0x0005   6    7    2   2   0  ;Enquiry
//      0x0006   6    8    2   2   0  ;Acknowledge
//      0x0007   6    9    2   2   0  ;Bell
//      0x0008   6   10    2   2   0  ;Backspace

//      0x000e   6   11    2   2   0  ;Shift Out
//      0x000f   6   12    2   2   0  ;Shift In
//      0x0010   6   13    2   2   0  ;Data Link Escape
//      0x0011   6   14    2   2   0  ;Device Control One
//      0x0012   6   15    2   2   0  ;Device Control Two
//      0x0013   6   16    2   2   0  ;Device Control Three
//      0x0014   6   17    2   2   0  ;Device Control Four
//      0x0015   6   18    2   2   0  ;Negative Acknowledge
//      0x0016   6   19    2   2   0  ;Synchronous Idle
//      0x0017   6   20    2   2   0  ;End Of Transmission Block
//      0x0018   6   21    2   2   0  ;Cancel
//      0x0019   6   22    2   2   0  ;End Of Medium
//      0x001a   6   23    2   2   0  ;Substitute
//      0x001b   6   24    2   2   0  ;Escape
//      0x001c   6   25    2   2   0  ;File Separator
//      0x001d   6   26    2   2   0  ;Group Separator
//      0x001e   6   27    2   2   0  ;Record Separator
//      0x001f   6   28    2   2   0  ;Unit Separator

//      0x0027   6  128    2   2   0  ;Apostrophe-Quote
//      0x002d   6  130    2   2   0  ;Hyphen-Minus

//      0x007f   6   29    2   2   0  ;Delete

BOOL COMString::HighCharTable[]= {
    FALSE,     /* 0x0, 0x0 */
        TRUE, /* 0x1, */
        TRUE, /* 0x2, */
        TRUE, /* 0x3, */
        TRUE, /* 0x4, */
        TRUE, /* 0x5, */
        TRUE, /* 0x6, */
        TRUE, /* 0x7, */
        TRUE, /* 0x8, */
        FALSE, /* 0x9,   */
        FALSE, /* 0xA,  */
        FALSE, /* 0xB, */
        FALSE, /* 0xC, */
        FALSE, /* 0xD,  */
        TRUE, /* 0xE, */
        TRUE, /* 0xF, */
        TRUE, /* 0x10, */
        TRUE, /* 0x11, */
        TRUE, /* 0x12, */
        TRUE, /* 0x13, */
        TRUE, /* 0x14, */
        TRUE, /* 0x15, */
        TRUE, /* 0x16, */
        TRUE, /* 0x17, */
        TRUE, /* 0x18, */
        TRUE, /* 0x19, */
        TRUE, /* 0x1A, */
        TRUE, /* 0x1B, */
        TRUE, /* 0x1C, */
        TRUE, /* 0x1D, */
        TRUE, /* 0x1E, */
        TRUE, /* 0x1F, */
        FALSE, /*0x20,  */
        FALSE, /*0x21, !*/
        FALSE, /*0x22, "*/
        FALSE, /*0x23,  #*/
        FALSE, /*0x24,  $*/
        FALSE, /*0x25,  %*/
        FALSE, /*0x26,  &*/
        TRUE,  /*0x27, '*/
        FALSE, /*0x28, (*/
        FALSE, /*0x29, )*/
        FALSE, /*0x2A **/
        FALSE, /*0x2B, +*/
        FALSE, /*0x2C, ,*/
        TRUE,  /*0x2D, -*/
        FALSE, /*0x2E, .*/
        FALSE, /*0x2F, /*/
        FALSE, /*0x30, 0*/
        FALSE, /*0x31, 1*/
        FALSE, /*0x32, 2*/
        FALSE, /*0x33, 3*/
        FALSE, /*0x34, 4*/
        FALSE, /*0x35, 5*/
        FALSE, /*0x36, 6*/
        FALSE, /*0x37, 7*/
        FALSE, /*0x38, 8*/
        FALSE, /*0x39, 9*/
        FALSE, /*0x3A, :*/
        FALSE, /*0x3B, ;*/
        FALSE, /*0x3C, <*/
        FALSE, /*0x3D, =*/
        FALSE, /*0x3E, >*/
        FALSE, /*0x3F, ?*/
        FALSE, /*0x40, @*/
        FALSE, /*0x41, A*/
        FALSE, /*0x42, B*/
        FALSE, /*0x43, C*/
        FALSE, /*0x44, D*/
        FALSE, /*0x45, E*/
        FALSE, /*0x46, F*/
        FALSE, /*0x47, G*/
        FALSE, /*0x48, H*/
        FALSE, /*0x49, I*/
        FALSE, /*0x4A, J*/
        FALSE, /*0x4B, K*/
        FALSE, /*0x4C, L*/
        FALSE, /*0x4D, M*/
        FALSE, /*0x4E, N*/
        FALSE, /*0x4F, O*/
        FALSE, /*0x50, P*/
        FALSE, /*0x51, Q*/
        FALSE, /*0x52, R*/
        FALSE, /*0x53, S*/
        FALSE, /*0x54, T*/
        FALSE, /*0x55, U*/
        FALSE, /*0x56, V*/
        FALSE, /*0x57, W*/
        FALSE, /*0x58, X*/
        FALSE, /*0x59, Y*/
        FALSE, /*0x5A, Z*/
        FALSE, /*0x5B, [*/
        FALSE, /*0x5C, \*/
        FALSE, /*0x5D, ]*/
        FALSE, /*0x5E, ^*/
        FALSE, /*0x5F, _*/
        FALSE, /*0x60, `*/
        FALSE, /*0x61, a*/
        FALSE, /*0x62, b*/
        FALSE, /*0x63, c*/
        FALSE, /*0x64, d*/
        FALSE, /*0x65, e*/
        FALSE, /*0x66, f*/
        FALSE, /*0x67, g*/
        FALSE, /*0x68, h*/
        FALSE, /*0x69, i*/
        FALSE, /*0x6A, j*/
        FALSE, /*0x6B, k*/
        FALSE, /*0x6C, l*/
        FALSE, /*0x6D, m*/
        FALSE, /*0x6E, n*/
        FALSE, /*0x6F, o*/
        FALSE, /*0x70, p*/
        FALSE, /*0x71, q*/
        FALSE, /*0x72, r*/
        FALSE, /*0x73, s*/
        FALSE, /*0x74, t*/
        FALSE, /*0x75, u*/
        FALSE, /*0x76, v*/
        FALSE, /*0x77, w*/
        FALSE, /*0x78, x*/
        FALSE, /*0x79, y*/
        FALSE, /*0x7A, z*/
        FALSE, /*0x7B, {*/
        FALSE, /*0x7C, |*/
        FALSE, /*0x7D, }*/
        FALSE, /*0x7E, ~*/
        TRUE, /*0x7F, */
        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comstringcommon.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMStringCommon
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Macros and function headers common to all types of
** strings.
**
** Date:  March 30, 1998
** 
===========================================================*/
#ifndef  _COMSTRINGCOMMON_H
#define _COMSTRINGCOMMON_H
//
// The following constants will need to be visible from managed code at some point.
// How do we go about making constants visible outside of our class?
//
#define TRIM_START 0
#define TRIM_END 1
#define TRIM_BOTH 2
#define CASE_INSENSITIVE_BIT 1
#define LOCALE_INSENSITIVE_BIT 2
//"Locale"
#define CASE_AND_LOCALE 0
//"IgnoreCase"
#define CASE_INSENSITIVE 1
//"Exact"
#define LOCALE_INSENSITIVE 2
//No longer used.
#define CASE_AND_LOCALE_INSENSTIVE 3


INT32 RefInterpretGetLength(OBJECTREF);
//WCHAR *RefInterpretGetCharPointer(OBJECTREF);
//BOOL RefInterpretGetValues(OBJECTREF, WCHAR **, int *);

/*====================================RETURN====================================
**This macro is designed to handle the funky returns from ecall functions.
**value is the type to be returned, and is expected to be OBJECTREF, STRINGREF,
**etc.  Type is the type of the return (e.g. STRINGREF). The name for the return
**value (r_-v) is deliberately obtuse so that it is less likely that developers
**have used a value by the same name in their code.
==============================================================================*/
#define RETURN(value, type) \
   {LPVOID r_v_; \
   *((type *)(&r_v_))=value; \
                                 return r_v_;}

#endif _COMSTRINGCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comstringbuffer.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  COMStringBuffer
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The implementation of the StringBuffer class.
**
** Date:  March 9, 1998
** 
===========================================================*/
#include "common.h"

#include "object.h"
#include <winnls.h>
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMString.h"
#include "COMStringCommon.h"
#include "COMStringBuffer.h"

#define DEFAULT_CAPACITY 16
#define DEFAULT_MAX_CAPACITY 0x7FFFFFFF

//
//Static Class Variables
//
MethodTable* COMStringBuffer::s_pStringBufferClass;

FCIMPL0(void*, COMStringBuffer::GetCurrentThread)
    return ::GetThread();
FCIMPLEND

/*==============================CalculateCapacity===============================
**Calculates the new capacity of our buffer.  If the size of the buffer is 
**less than a fixed number (10000 in this case), we just double the buffer until
**we have enough space.  Once we get larger than 10000, we use a series of heuristics
**to determine the most appropriate size.
**
**Args:  currentCapacity:  The current capacity of the buffer
**       requestedCapacity: The minimum required capacity of the buffer
**Returns: The new capacity of the buffer.
**Exceptions: None.
==============================================================================*/
INT32 COMStringBuffer::CalculateCapacity (STRINGBUFFERREF thisRef, INT32 currentCapacity, INT32 requestedCapacity) {
    THROWSCOMPLUSEXCEPTION();

    INT32 newCapacity=currentCapacity;
    INT32 maxCapacity=thisRef->GetMaxCapacity();
    
    //This unfortunate situation can occur if they manually set the capacity to 0.
    if (newCapacity<=0) {
        newCapacity=DEFAULT_CAPACITY; 
    }

    if (requestedCapacity>maxCapacity) {
        COMPlusThrowArgumentOutOfRange(L"capacity", L"ArgumentOutOfRange_Capacity");
    }

    //Double until we find something bigger than what we need.
    while (newCapacity<requestedCapacity && newCapacity>0) {
        newCapacity*=2;
    }
    //Check if we overflowed.
    if (newCapacity<=0) {
        COMPlusThrowArgumentOutOfRange(L"capacity", L"ArgumentOutOfRange_NegativeCapacity");
    }
    
    //Also handle the unlikely case where we double so much that we're larger
    //than maxInt.
    if (newCapacity<=maxCapacity && newCapacity>0) {
        return newCapacity;
    }
    
    return maxCapacity;
}


/*==================================CopyString==================================
**Action: Creates a new copy of the string and then clears the dirty bit.
**        The Allocated String has a capacity of exactly newCapacity (we assume that
**        the checks for maxCapacity have been done elsewhere.)  If newCapacity is smaller
**        than the current size of the String, we truncate the String.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
STRINGREF COMStringBuffer::CopyString(STRINGBUFFERREF *thisRef, STRINGREF CurrString, int newCapacity) {
  int CurrLen;
  int copyLength;
  STRINGREF Local;

  _ASSERTE(newCapacity>=0);
  _ASSERTE(newCapacity<=(*thisRef)->GetMaxCapacity());
  
  //Get the data out of our current String.
  CurrLen = CurrString->GetStringLength();

  //Calculate how many characters to copy.  If we have enough capacity to 
  //accomodate all of our current String, we'll take the entire thing, otherwise
  //we'll just take the most that we can fit.
   if (newCapacity>=CurrLen) {
       copyLength = CurrLen;
   } else {
       _ASSERTE(!"Copying less than the full String.  Was this intentional?");
       copyLength = newCapacity;
   }

   //CurrString needs to be protected because it is used in NewString only *after*
   //we allocate a new string.
  GCPROTECT_BEGIN(CurrString);
  Local = COMString::NewString(&CurrString, 0, copyLength, newCapacity);
  GCPROTECT_END(); //CurrString

  return Local;
}

STRINGREF COMStringBuffer::GetRequiredString(STRINGBUFFERREF *thisRef, STRINGREF thisString, int requiredCapacity) {
    INT32 currCapacity = thisString->GetArrayLength()-1;
    if ((currCapacity>=requiredCapacity)) {
        return thisString;
    }
    return CopyString(thisRef, thisString, CalculateCapacity((*thisRef), currCapacity, requiredCapacity));
}

/*================================ReplaceBuffer=================================
**This is a helper function designed to be used by N/Direct it replaces the entire
**contents of the String with a new string created by some native method.  This 
**will not be exposed through the StringBuilder class.
==============================================================================*/
void COMStringBuffer::ReplaceBuffer(STRINGBUFFERREF *thisRef, WCHAR *newBuffer, INT32 newLength) {
    STRINGREF thisString = NULL;
    WCHAR *thisChars;

    _ASSERTE(thisRef);
    _ASSERTE(*thisRef);
    _ASSERTE(newBuffer);
    _ASSERTE(newLength>=0);

    THROWSCOMPLUSEXCEPTION();

    void *tid;
    thisString = GetThreadSafeString(*thisRef,&tid);

    //This will ensure that we have enough space and take care of the CopyOnWrite
    //if needed.
    thisString = GetRequiredString(thisRef, thisString, newLength);
    thisChars = thisString->GetBuffer();

    //memcpy should blithely ignore any nulls which it finds in newBuffer.
    memcpyNoGCRefs(thisChars, newBuffer, newLength*sizeof(WCHAR));
    thisChars[newLength]='\0';
    thisString->SetStringLength(newLength);
    INT32 currCapacity = thisString->GetArrayLength()-1;
    if (!(newLength == 0 && currCapacity ==0)) {
        thisString->SetHighCharState(STRING_STATE_UNDETERMINED);
    }
    ReplaceStringRef(*thisRef, tid, thisString);
}


/*================================ReplaceBufferAnsi=================================
**This is a helper function designed to be used by N/Direct it replaces the entire
**contents of the String with a new string created by some native method.  This 
**will not be exposed through the StringBuilder class.
**
**This version does Ansi->Unicode conversion along the way. Although
**making it a member of COMStringBuffer exposes more stringbuffer internals
**than necessary, it does avoid requiring a temporary buffer to hold
**the Ansi->Unicode conversion.
==============================================================================*/
void COMStringBuffer::ReplaceBufferAnsi(STRINGBUFFERREF *thisRef, CHAR *newBuffer, INT32 newCapacity) {
    STRINGREF thisString;
    WCHAR *thisChars;

    _ASSERTE(thisRef);
    _ASSERTE(*thisRef);
    _ASSERTE(newBuffer);
    _ASSERTE(newCapacity>=0);

    THROWSCOMPLUSEXCEPTION();

    void *tid;
    thisString = GetThreadSafeString(*thisRef,&tid);

    //This will ensure that we have enough space and take care of the CopyOnWrite
    //if needed.
    thisString = GetRequiredString(thisRef, thisString, newCapacity);
    thisChars = thisString->GetBuffer();


    // NOTE: This call to MultiByte also writes out the null terminator
    // which is currently part of the String representation.
    INT32 ncWritten = MultiByteToWideChar(CP_ACP,
                                          MB_PRECOMPOSED,
                                          newBuffer,
                                          -1,
                                          thisChars,
                                          newCapacity+1);

    if (ncWritten == 0)
    {
        // Normally, we'd throw an exception if the string couldn't be converted.
        // In this particular case, we paper over it instead. The reason is
        // that most likely reason a P/Invoke-called api returned a
        // poison string is that the api failed for some reason, and hence
        // exercised its right to leave the buffer in a poison state.
        // Because P/Invoke cannot discover if an api failed, it cannot
        // know to ignore the buffer on the out marshaling path.
        // Because normal P/Invoke procedure is for the caller to check error
        // codes manually, we don't want to throw an exception on him.
        // We certainly don't want to randomly throw or not throw based on the
        // nondeterministic contents of a buffer passed to a failing api.
        *thisChars = L'\0';
        ncWritten++;
    }
    thisString->SetStringLength(ncWritten - 1);
	_ASSERTE(IS_STRING_STATE_UNDETERMINED(thisString->GetHighCharState()));
    ReplaceStringRef(*thisRef, tid, thisString);
}



//
//
// Private Quasi-Constructors.
//
//
//

/*================================MakeFromString================================
**We can't have native constructors, so the managed constructor calls
**this method.  If args->value is null, we simply create an empty string with
**a default length.  If it does contain data, we allocate space for twice this
**amount of data, copy the data, associate it with the StringBuffer and clear
**the CopyOnWrite bit.
**
**Returns void.  It's sideeffects are visible through the changes made to thisRef
**
**Args: typedef struct {STRINGBUFFERREF thisRef; INT32 capacity; INT32 length; INT32 startIndex; STRINGREF value;} _makeFromStringArgs;
==============================================================================*/
void __stdcall COMStringBuffer::MakeFromString(COMStringBuffer::_makeFromStringArgs *args) {
  STRINGREF Local;
  INT32 capacity;
  INT32 newCapacity;
  INT32 length;

  _ASSERTE(args);

  THROWSCOMPLUSEXCEPTION();
  _ASSERTE(args->thisRef);

  //Figure out the actual length.  This is valueLength if args->length is -1 (which indicates that we're using
  //the entire string) or args->length, which indicates that we're using part of the string.  Check to ensure
  //that the part which we're using isn't larger than the actual String.
  int valueLength = (!args->value) ? 0 : args->value->GetStringLength(); 
  length = ((-1==args->length)?valueLength:args->length);
  if ((args->startIndex<0)) {
      COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
  }

  if (args->startIndex>valueLength-length) {
      COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_IndexLength");
  }

  //Figure out the capacity requested.
  capacity = ((args->capacity<=0))?DEFAULT_CAPACITY:args->capacity;
  args->thisRef->SetMaxCapacity(DEFAULT_MAX_CAPACITY);

  //Handle a null string by creating a default string and setting the length to 0
  if (!args->value) {
      //NullString needs to be protected because it is used in NewString only *after*
      //we allocate a new string.
      STRINGREF EmptyString = COMString::GetEmptyString();
      GCPROTECT_BEGIN(EmptyString);
      Local = COMString::NewString(&EmptyString,0,EmptyString->GetStringLength(),capacity);
      GCPROTECT_END();//NullString
  } else {

      newCapacity=CalculateCapacity(args->thisRef, capacity,length);
      
      Local=COMString::NewString(&args->value,args->startIndex, length, newCapacity);
  }
  
  //Set the StringRef and clear the CopyOnWrite bit.
  args->thisRef->SetStringRef(Local);
  

}

// GetThreadSafeString
STRINGREF COMStringBuffer::GetThreadSafeString(STRINGBUFFERREF thisRef,void** currentThread) {
    STRINGREF thisString = thisRef->GetStringRef();
    *currentThread = ::GetThread();
    if (thisRef->GetCurrentThread() != *currentThread) {
        INT32 currCapacity = thisString->GetArrayLength()-1;
        thisString = CopyString(&thisRef, thisString, currCapacity);
    }
    return thisString;
}

//
// BUFFER STATE QUERIES AND MODIFIERS
//


/*=================================SetCapacity==================================
**Action: Sets the capacity to be args->capacity.  If capacity is < the current length,
**        throws an ArgumentException;
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall COMStringBuffer::SetCapacity(_setCapacityArgs *args) {
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    }

    void *tid;
    STRINGREF thisString = GetThreadSafeString(args->thisRef,&tid);

    //Verify that our capacity is greater than 0 and that we can fit our
    //current string into the new capacity.
    if (args->capacity<0) {
        COMPlusThrowArgumentOutOfRange(L"capacity", L"ArgumentOutOfRange_NegativeCapacity");
    }

    if (args->capacity< (INT)thisString->GetStringLength()) {
        COMPlusThrowArgumentOutOfRange(L"capacity", L"ArgumentOutOfRange_SmallCapacity");
    }

    if (args->capacity>args->thisRef->GetMaxCapacity()) {
        COMPlusThrowArgumentOutOfRange(L"capacity", L"ArgumentOutOfRange_Capacity");
    }

    INT32 currCapacity = thisString->GetArrayLength()-1;
    //If we already have the correct capacity, bail out early.
    if (args->capacity==currCapacity) {
        RETURN(args->thisRef, STRINGBUFFERREF);
    }
    
    //Allocate a new String with the capacity and copy all of our old characters
    //into it.  We've already guaranteed that our String will fit within that capacity.
    STRINGREF newString = CopyString(&args->thisRef,thisString, args->capacity);
    ReplaceStringRef(args->thisRef, tid, newString);

    RETURN(args->thisRef, STRINGBUFFERREF);
}


/*==============================InsertStringBuffer==============================
**Insert args->value into this buffer at location args->index.  Move all characters
**after args->index so that nothing gets overwritten.
**
**Returns a pointer to the current StringBuffer.
**
**Args:typedef struct {STRINGBUFFERREF thisRef; INT32 count; int index; STRINGREF value;} _insertStringBufferArgs;
==============================================================================*/
LPVOID __stdcall COMStringBuffer::InsertString(_insertStringArgs *args){
  WCHAR *thisChars, *valueChars;
  STRINGREF thisString = NULL;
  int thisLength, valueLength;
  int length;
  
  THROWSCOMPLUSEXCEPTION();

  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }
  
  //If value isn't null, get all of our required values.
  if (!args->value) {
	if (args->index == 0 && args->count==0) {
         RETURN(args->thisRef, STRINGBUFFERREF);
	}
	COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
  }

  void *tid;
  thisString = GetThreadSafeString(args->thisRef,&tid);
  thisLength = thisString->GetStringLength();
  valueLength = args->value->GetStringLength();

  //Range check the index.
  if (args->index<0 || args->index > (INT32)thisLength) {
      COMPlusThrowArgumentOutOfRange(L"index", L"ArgumentOutOfRange_Index");
  }

  if (args->count<1) {
      COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_GenericPositive");
  }

  //Calculate the new length, ensure that we have the space and set the space variable for this buffer
  length = thisLength + (valueLength*args->count);
  thisString = GetRequiredString(&args->thisRef, thisString, length);
  
  //Get another pointer to the buffer in case it changed during LocalEnsure
  //Assumes that thisRef points to a StringBuffer.
  thisChars = thisString->GetBuffer();
  valueChars = args->value->GetBuffer();
  thisString->SetStringLength(length);

  //Copy the old characters over to make room and then insert the new characters.
  memmove(&(thisChars[args->index+(valueLength*args->count)]),&(thisChars[args->index]),(thisLength-args->index)*sizeof(WCHAR));
  for (int i=0; i<args->count; i++) {
      memcpyNoGCRefs(&(thisChars[args->index+(i*valueLength)]),valueChars,valueLength*sizeof(WCHAR));
  }
  thisChars[length]='\0';
  _ASSERTE(IS_STRING_STATE_UNDETERMINED(thisString->GetHighCharState()));

  ReplaceStringRef(args->thisRef, tid, thisString);
    
  //Force the info into an LPVOID to return.
  RETURN(args->thisRef,STRINGBUFFERREF);
}



/*===============================InsertCharArray================================
**Action: Inserts the characters from value into this at position index.  The characters
**        are taken from value starting at position startIndex and running for count
**        characters.
**Returns: A reference to this with the new characters inserted.
**Arguments:
**Exceptions: ArgumentException if index is outside of the range of this.
**            ArgumentException if count<0, startIndex<0 or startIndex+count>value.length
==============================================================================*/
LPVOID __stdcall COMStringBuffer::InsertCharArray(_insertCharArrayArgs *args) {
  WCHAR *thisChars, *valueChars;
  STRINGREF thisString = NULL;
  int thisLength, valueLength;
  int length;
  
  THROWSCOMPLUSEXCEPTION();

  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }

  void *tid;
  thisString = GetThreadSafeString(args->thisRef,&tid);
  thisLength = thisString->GetStringLength();

  //Range check the index.
  if (args->index<0 || args->index > (INT32)thisLength) {
      COMPlusThrowArgumentOutOfRange(L"index", L"ArgumentOutOfRange_Index");
  }
  
  //If they passed in a null char array, just jump out quickly.
  if (!args->value) {
	  if (args->startIndex == 0 && args->charCount==0) {
         RETURN(args->thisRef, STRINGBUFFERREF);
	}
	COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
  }


  //Range check the array.
  if (args->startIndex<0) {
      COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
  }

  if (args->charCount<0) {
      COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_GenericPositive");
  }

  if (args->startIndex > ((INT32)args->value->GetNumComponents()-args->charCount)) {
      COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
  }
  
  length = thisLength + args->charCount;
  thisString = GetRequiredString(&args->thisRef, thisString, length);  

  thisChars = thisString->GetBuffer();
  valueChars = (WCHAR *)(args->value->GetDataPtr());
  valueLength = args->charCount;

  //Copy the old characters over to make room and then insert the new characters.
  memmove(&(thisChars[args->index+valueLength]),&(thisChars[args->index]),(thisLength-args->index)*sizeof(WCHAR));
  memcpyNoGCRefs(&(thisChars[args->index]), &(valueChars[args->startIndex]), valueLength*sizeof(WCHAR));
    thisChars[length]='\0';
  thisString->SetStringLength(length);  
  _ASSERTE(IS_STRING_STATE_UNDETERMINED(thisString->GetHighCharState()));
  
  ReplaceStringRef(args->thisRef, tid, thisString);

  RETURN(args->thisRef, STRINGBUFFERREF);
}

/*=============================REMOVEBUFFER================================
**Removes all of the args->length characters starting at args->startIndex.
**
**Returns a pointer to the current buffer.
**
**Args:typedef struct {STRINGBUFFERREF thisRef; int length; int startIndex;} _removeBufferArgs;
=========================================================================*/
LPVOID __stdcall COMStringBuffer::Remove(_removeArgs *args){
  WCHAR *thisChars;
  int thisLength;
  int newLength;
  STRINGREF thisString = NULL;

  THROWSCOMPLUSEXCEPTION();

  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }

  void *tid;
  thisString = GetThreadSafeString(args->thisRef,&tid);
  thisLength = thisString->GetArrayLength() - 1;

   
  //Get the needed values
  thisChars = thisString->GetBuffer();
  thisLength = thisString->GetStringLength();
  
  if (args->length<0) {
      COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_NegativeLength");
  } 

  if (args->startIndex<0) {
      COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex");
  }

  if ((args->length) > (thisLength-args->startIndex)) {
      COMPlusThrowArgumentOutOfRange(L"index", L"ArgumentOutOfRange_Index");
  }

  //Move the remaining characters to the left and set the string length.
  memcpyNoGCRefs(&(thisChars[args->startIndex]),&(thisChars[args->startIndex+args->length]), (thisLength-(args->startIndex+args->length))*sizeof(WCHAR));
  newLength=thisLength-args->length;

  thisString->SetStringLength(newLength);
  thisChars[newLength]='\0';
  _ASSERTE(IS_STRING_STATE_UNDETERMINED(thisString->GetHighCharState()));

  ReplaceStringRef(args->thisRef, tid, thisString);

  //Force the info into an LPVOID to return.
  RETURN(args->thisRef,STRINGBUFFERREF);
}

/*==============================LocalIndexOfString==============================
**Finds search within base and returns the index where it was found.  The search
**starts from startPos and we return -1 if search isn't found.  This is a direct 
**copy from COMString::IndexOfString, but doesn't require that we build up
**an instance of indexOfStringArgs before calling it.  
**
**Args:
**base -- the string in which to search
**search -- the string for which to search
**strLength -- the length of base
**patternLength -- the length of search
**startPos -- the place from which to start searching.
**
==============================================================================*/
INT32 COMStringBuffer::LocalIndexOfString(WCHAR *base, WCHAR *search, int strLength, int patternLength, int startPos) {
  int iThis, iPattern;
  for (iThis=startPos; iThis < (strLength-patternLength+1); iThis++) {
    for (iPattern=0; iPattern<patternLength && base[iThis+iPattern]==search[iPattern]; iPattern++);
    if (iPattern == patternLength) return iThis;
  }
  return -1;
}

/*================================ReplaceString=================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall COMStringBuffer::ReplaceString(_replaceStringArgs *args){
  int *replaceIndex;
  int index=0;
  int count=0;
  INT64 newBuffLength=0;
  int replaceCount=0;
  int readPos, writePos;
  int indexAdvance=0;
  WCHAR *thisBuffer, *oldBuffer, *newBuffer;
  int thisLength, oldLength, newLength;
  int endIndex;
  CQuickBytes replaceIndices;
  STRINGREF thisString=NULL;

  THROWSCOMPLUSEXCEPTION();

  if (args->thisRef==NULL) {
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
  }

  //Verify all of the arguments.
  if (!args->oldValue) {
    COMPlusThrowArgumentNull(L"oldValue", L"ArgumentNull_Generic");
  }

  //If they asked to replace oldValue with a null, replace all occurances
  //with the empty string.
  if (!args->newValue) {
      args->newValue = COMString::GetEmptyString();
  }

  void *tid;
  thisString = GetThreadSafeString(args->thisRef,&tid);
  thisLength = thisString->GetStringLength();
  thisBuffer = thisString->GetBuffer();

  RefInterpretGetStringValuesDangerousForGC(args->oldValue, &oldBuffer, &oldLength);
  RefInterpretGetStringValuesDangerousForGC(args->newValue, &newBuffer, &newLength);

  //Range check our String.
  if (args->startIndex<0 || args->startIndex>thisLength) {
      COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
  }
  
  if (args->count<0 || args->startIndex > thisLength - args->count) {
      COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Index");
  }

  //Record the endIndex so that we don't need to do this calculation all over the place.
  endIndex = args->startIndex + args->count;

  //If our old Length is 0, we won't know what to replace
  if (oldLength==0) {
      COMPlusThrowArgumentException(L"oldValue", L"Argument_StringZeroLength");
  }

  //replaceIndex is made large enough to hold the maximum number of replacements possible:
  //The case where every character in the current buffer gets replaced.
  replaceIndex = (int *)replaceIndices.Alloc((thisLength/oldLength+1)*sizeof(int));

  //Calculate all of the indices where our oldStrings end.  Finding the
  //ending is important because we're about to walk the string backwards.
  //If we're going to be walking the array backwards, we need to record the
  //end of the matched string, hence indexAdvance.
  if (newLength>oldLength) {
      indexAdvance = oldLength - 1;
  }

  index=args->startIndex;
  while (((index=LocalIndexOfString(thisBuffer,oldBuffer,thisLength,oldLength,index))>-1) && (index<=endIndex-oldLength)) {
      replaceIndex[replaceCount++] = index + indexAdvance;
      index+=oldLength;
  }

  //Calculate the new length of the string and ensure that we have sufficent room.
  newBuffLength = thisLength - ((oldLength - newLength) * (INT64)replaceCount);
  if (newBuffLength > 0x7FFFFFFF)
       COMPlusThrowOM();

  thisString = GetRequiredString(&args->thisRef, thisString, (INT32)newBuffLength);

  //Get another pointer to the buffer in case it changed during the assure.
  thisBuffer = thisString->GetBuffer();
  newBuffer = args->newValue->GetBuffer();

  //Handle the case where our new string is longer than the old string.
  //This requires walking the buffer backwards in order to do an in-place
  //replacement.
  if (newLength > oldLength) {
    //Decrement replaceCount so that we can use it as an actual index into our array.
    replaceCount--;

    //Walk the array backwards copying each character as we go.  If we reach an instance
    //of the string being replaced, replace the old string with the new string.
    readPos = thisLength-1;
    writePos = newBuffLength-1; 
    while (readPos>=0) {
      if (replaceCount>=0&&readPos==replaceIndex[replaceCount]) {
    replaceCount--;
    readPos-=(oldLength);
    writePos-=(newLength);
    memcpyNoGCRefs(&thisBuffer[writePos+1], newBuffer, newLength*sizeof(WCHAR));
      } else {
    thisBuffer[writePos--] = thisBuffer[readPos--];
      }
    }
    thisBuffer[newBuffLength]='\0';
    //Set the new String length and return.
    thisString->SetStringLength(newBuffLength);
	_ASSERTE(IS_STRING_STATE_UNDETERMINED(thisString->GetHighCharState()));

    ReplaceStringRef(args->thisRef, tid, thisString);

    RETURN(args->thisRef,STRINGBUFFERREF);
  }

  //Handle the case where our old string is longer than or the same size as
  //the string with which we're about to replace it. This requires us to walk 
  //the buffer forward, differentiating it from the above case which requires us
  //to walk the array backwards.
  
  //Set replaceHolder to be the upper limit of our array.
  int replaceHolder = replaceCount;
  replaceCount=0;

  //Walk the array forwards copying each character as we go.  If we reach an instance
  //of the string being replaced, replace the old string with the new string.
  readPos = 0;
  writePos = 0;
  while (readPos<thisLength) {
    if (replaceCount<replaceHolder&&readPos==replaceIndex[replaceCount]) {
      replaceCount++;
      readPos+=(oldLength);
      memcpyNoGCRefs(&thisBuffer[writePos], newBuffer, newLength*sizeof(WCHAR));
      writePos+=(newLength);
    } else {
      thisBuffer[writePos++] = thisBuffer[readPos++];
    }
  }
  thisBuffer[newBuffLength]='\0';

  thisString->SetStringLength(newBuffLength);
  _ASSERTE(IS_STRING_STATE_UNDETERMINED(thisString->GetHighCharState()));

  //Set the new String length and return.
  ReplaceStringRef(args->thisRef, tid, thisString);
  RETURN(args->thisRef,STRINGBUFFERREF);
}

/*==============================NewStringBuffer=================================
**Makes a new empty string buffer with the given capacity.  For EE use.
==============================================================================*/

STRINGBUFFERREF COMStringBuffer::NewStringBuffer(INT32 capacity) {
    STRINGREF Local;
    THROWSCOMPLUSEXCEPTION();

    STRINGBUFFERREF Buffer;

    Local = COMString::NewString(capacity);
    Local->SetStringLength(0); //This is a cheap hack to get the empty string.

    _ASSERTE(s_pStringBufferClass != NULL);

    GCPROTECT_BEGIN(Local);
    Buffer = (STRINGBUFFERREF) AllocateObject(s_pStringBufferClass);
    GCPROTECT_END();//Local

    Buffer->SetStringRef(Local);
    Buffer->SetCurrentThread(::GetThread());
    Buffer->SetMaxCapacity(capacity);

    return Buffer;
}


/*===============================LoadStringBuffer===============================
**Initialize the COMStringBuffer Class.  Stores a reference to the class in  
**a static member of COMStringBuffer.
**
**Returns S_OK if it succeeded.  E_FAIL if it is unable to initialze the class.
**
**Args: None
==============================================================================*/
HRESULT __stdcall COMStringBuffer::LoadStringBuffer() {
  
  // Load the StringBuffer
  COMStringBuffer::s_pStringBufferClass = g_Mscorlib.GetClass(CLASS__STRING_BUILDER);
  
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comstring.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMString.h
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Contains types and method signatures for the String class
**
** Date:  March 12, 1998
** 
===========================================================*/
#include "COMStringCommon.h"
#include "fcall.h"
#include "excep.h"
#include "COMVarArgs.h"
#include "binder.h"

#ifndef _COMSTRING_H
#define _COMSTRING_H
//
// Each function that we call through native only gets one argument,
// which is actually a pointer to it's stack of arguments.  Our structs
// for accessing these are defined below.
//

//
//These are the type signatures for String
//
//
// The method signatures for each of the methods we define.
// N.B.: There's a one-to-one mapping between the method signatures and the
// type definitions given above.
//



/*=================RefInterpretGetStringValuesDangerousForGC======================
**N.B.: This perfoms no range checking and relies on the caller to have done this.
**Args: (IN)ref -- the String to be interpretted.
**      (OUT)chars -- a pointer to the characters in the buffer.
**      (OUT)length -- a pointer to the length of the buffer.
**Returns: void.
**Exceptions: None.
==============================================================================*/
// !!!! If you use this function, you have to be careful because chars is a pointer 
// !!!! to the data buffer of ref.  If GC happens after this call, you need to make
// !!!! sure that you have a pin handle on ref, or use GCPROTECT_BEGINPINNING on ref.
#ifdef _DEBUG
inline void RefInterpretGetStringValuesDangerousForGC(STRINGREF ref, WCHAR **chars, int *length) {
	_ASSERTE(ref != NULL);
    *length = (ref)->GetStringLength();
    *chars  = (ref)->GetBuffer();
    ENABLESTRESSHEAP();
}
#endif

inline void RefInterpretGetStringValuesDangerousForGC(StringObject* ref, WCHAR **chars, int *length) {
    _ASSERTE(ref && ref->GetMethodTable() == g_pStringClass);
    *length = (ref)->GetStringLength();
    *chars  = (ref)->GetBuffer();
#ifdef _DEBUG
    ENABLESTRESSHEAP();
#endif
}

//The first two macros are essentially the same.  I just define both because 
//having both can make the code more readable.
#define IS_FAST_SORT(state) (!((state) & STRING_STATE_SPECIAL_SORT))
#define IS_SLOW_SORT(state) (((state) & STRING_STATE_SPECIAL_SORT))

//This macro should be used to determine things like indexing, casing, and encoding.
#define IS_FAST_OPS_EXCEPT_SORT(state) (((state)==STRING_STATE_SPECIAL_SORT) || ((state)==STRING_STATE_FAST_OPS))
#define IS_FAST_CASING(state) (((state)==STRING_STATE_SPECIAL_SORT) || ((state)==STRING_STATE_FAST_OPS))
#define IS_FAST_INDEX(state) (((state)==STRING_STATE_SPECIAL_SORT) || ((state)==STRING_STATE_FAST_OPS))
#define IS_STRING_STATE_UNDETERMINED(state) ((state)==STRING_STATE_UNDETERMINED)
#define HAS_HIGH_CHARS(state) ((state)==STRING_STATE_HIGH_CHARS)

class COMString {
//
// These are the method signatures for String
//
    static MethodTable *s_pStringMethodTable;
    static OBJECTHANDLE EmptyStringHandle;
    static LPCUTF8 StringClassSignature;

    private:
    static BOOL InternalTrailByteCheck(STRINGREF str, WCHAR **outBuff);

    
public:
    static BOOL     HighCharTable[];
    static STRINGREF GetEmptyString();
    static STRINGREF GetNullString();
    static STRINGREF GetStringFromClass(BinderFieldID id, OBJECTHANDLE *);
    static STRINGREF ConcatenateJoinHelperArray(PTRARRAYREF *value, STRINGREF *joiner, INT32 startIndex, INT32 count);
    static STRINGREF CreationHelperFixed(STRINGREF *a, STRINGREF *b, STRINGREF *c);
    static STRINGREF CreationHelperArray(PTRARRAYREF *);
        
    // Clear the object handle when the EE stops
    static void Stop();

    //
    // Constructors
    //
    static FCDECL4(Object *, StringInitCharArray, 
            StringObject *thisString, I2Array *value, INT32 startIndex, INT32 length);
    static FCDECL2(Object *, StringInitChars, 
                   StringObject *thisString, I2Array *value);
    static FCDECL2(Object *, StringInitWCHARPtr, StringObject *stringThis, WCHAR *ptr);
    static FCDECL4(Object *, StringInitWCHARPtrPartial, StringObject *thisString,
                   WCHAR *ptr, INT32 startIndex, INT32 length);
    static FCDECL5(Object *, StringInitSBytPtrPartialEx, StringObject *thisString,
                   I1 *ptr, INT32 startIndex, INT32 length, Object* encoding);
    static FCDECL2(Object *, StringInitCharPtr, StringObject *stringThis, INT8 *ptr);
    static FCDECL4(Object *, StringInitCharPtrPartial, StringObject *stringThis, INT8 *ptr,
                   INT32 startIndex, INT32 length);
    static FCDECL3(Object *, StringInitCharCount, StringObject *stringThis, 
                   WCHAR ch, INT32 length);

    // If allocation logging is on, then calls to FastAllocateString are diverted to this ecall
    // method. This allows us to log the allocation, something that the earlier fcall didnt.
    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, length);
    } _slowAllocateStringArgs;
    static LPVOID __stdcall SlowAllocateString(_slowAllocateStringArgs *args);

    //
    // Search/Query Methods
    //
    static FCDECL2(INT32, EqualsObject, StringObject* pThisRef, StringObject* vValueRef);
    static FCDECL2(INT32, EqualsString, StringObject* pThisRef, StringObject* vValueRef);
    static FCDECL3(INT32, FCCompareOrdinal, StringObject* strA, StringObject* strB, BOOL bIgnoreCase);
    static FCDECL3(void, FillString, StringObject* pvDest, int destPos, StringObject* pvSrc);
    static FCDECL3(void, FillStringChecked, StringObject* pvDest, int destPos, StringObject* pvSrc);
    static FCDECL4(void, FillStringEx, StringObject* pvDest, int destPos, StringObject* pvSrc, INT32 srcLength);
    static FCDECL5(void, FillSubstring, StringObject* pvDest, int destPos, StringObject* pvSrc, INT32 srcPos, INT32 srcCount);
    static FCDECL5(void, FillStringArray, StringObject* pvDest, int destBase, CHARArray* pvSrc, int srcBase, int srcCount);
    static FCDECL1(BOOL, IsFastSort, StringObject* pThisRef);
    static FCDECL1(bool, ValidModifiableString, StringObject* pThisRef);
        

    static FCDECL4(INT32, FCCompareOrdinalWC, StringObject* strA, WCHAR *strB, BOOL bIgnoreCase, BOOL *bSuccess);

	static FCDECL5(INT32, CompareOrdinalEx, StringObject* strA, INT32 indexA, StringObject* strB, INT32 indexB, INT32 count);
    
	static FCDECL4(INT32, IndexOfChar, StringObject* vThisRef, INT32 value, INT32 startIndex, INT32 count );

	static FCDECL4(INT32, LastIndexOfChar, StringObject* thisRef, INT32 value, INT32 startIndex, INT32 count );

	static FCDECL4(INT32, LastIndexOfCharArray, StringObject* thisRef, CHARArray* valueRef, INT32 startIndex, INT32 count );

    static FCDECL4(INT32, IndexOfCharArray, StringObject* vThisRef, CHARArray* value, INT32 startIndex, INT32 count );
    static FCDECL2(void, SmallCharToUpper, StringObject* pvStrIn, StringObject* pvStrOut);

	static FCDECL1(INT32, GetHashCode, StringObject* pThisRef);
	static FCDECL2(INT32, GetCharAt, StringObject* pThisRef, INT32 index);
	static FCDECL1(INT32, Length, StringObject* pThisRef);
	static FCDECL5(void, GetPreallocatedCharArray, StringObject* pThisRef, INT32 startIndex, 
				   I2Array* pBuffer, INT32 bufferStartIndex, INT32 length);
	static FCDECL5(void, InternalCopyToByteArray, StringObject* pThisRef, INT32 startIndex, 
				   U1Array* pBuffer, INT32 bufferStartIndex, INT32 charCount);



    //
    // Modifiers
    //
    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, count); 
        DECLARE_ECALL_I4_ARG(INT32, startIndex); 
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, value); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, joiner); 
    } 
    _joinArrayArgs;
    static LPVOID __stdcall JoinArray(_joinArrayArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef); 
        DECLARE_ECALL_I4_ARG(INT32, count); 
        DECLARE_ECALL_OBJECTREF_ARG(CHARARRAYREF, separator);
    } _splitArgs;
    static LPVOID __stdcall Split(_splitArgs *);
    

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef); 
        DECLARE_ECALL_I4_ARG(INT32, length); 
        DECLARE_ECALL_I4_ARG(INT32, start);
    } _substringArgs;
    static LPVOID __stdcall Substring(_substringArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef);
        DECLARE_ECALL_I4_ARG(INT32, isRightPadded);
        DECLARE_ECALL_I4_ARG(INT32, paddingChar);
        DECLARE_ECALL_I4_ARG(INT32, totalWidth);
    } _padHelperArgs;
    static LPVOID __stdcall PadHelper(_padHelperArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef); 
        DECLARE_ECALL_I4_ARG(INT32, trimType);
        DECLARE_ECALL_OBJECTREF_ARG(CHARARRAYREF, trimChars); 
    } _trimHelperArgs;
    static LPVOID __stdcall TrimHelper(_trimHelperArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef); 
        DECLARE_ECALL_I4_ARG(INT32, newChar);
        DECLARE_ECALL_I4_ARG(INT32, oldChar);
    } _replaceArgs;
    static LPVOID __stdcall Replace(_replaceArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, newValue); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, oldValue); 
    } _replaceStringArgs;
    static LPVOID __stdcall ReplaceString(_replaceStringArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value); 
        DECLARE_ECALL_I4_ARG(INT32, startIndex);
    } _insertArgs;
    static LPVOID __stdcall Insert(_insertArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, thisRef); 
        DECLARE_ECALL_I4_ARG(INT32, count);
        DECLARE_ECALL_I4_ARG(INT32, startIndex);
    } _removeArgs;
    static LPVOID __stdcall Remove(_removeArgs *args);

    
    //========================================================================
    // Creates a System.String object. All the functions that take a length 
	// or a count of bytes will add the null terminator after length 
	// characters. So this means that if you have a string that has 5 
	// characters and the null terminator you should pass in 5 and NOT 6.
    //========================================================================
    static STRINGREF NewString(INT32 length);
    static STRINGREF NewString(INT32 length, BOOL bHasTrailByte);
    static STRINGREF NewString(const WCHAR *pwsz);
    static STRINGREF NewString(const WCHAR *pwsz, int length);
    static STRINGREF NewString(LPCUTF8 psz);
    static STRINGREF NewString(LPCUTF8 psz, int cBytes);
    static STRINGREF NewString(STRINGREF *srChars, int start, int length);
    static STRINGREF NewString(STRINGREF *srChars, int start, int length, int capacity);
    static STRINGREF NewString(I2ARRAYREF *srChars, int start, int length);
    static STRINGREF NewString(I2ARRAYREF *srChars, int start, int length, int capacity);
    static STRINGREF NewStringFloat(const WCHAR *pwsz, int decptPos, int sign, WCHAR decpt);
    static STRINGREF NewStringExponent(const WCHAR *pwsz, int decptPos, int sign, WCHAR decpt);
    static STRINGREF StringInitCharHelper(LPCSTR pszSource, INT32 length);
    static void InitializeStringClass();
    static INT32 InternalCheckHighChars(STRINGREF inString);
    static bool TryConvertStringDataToUTF8(STRINGREF inString, LPUTF8 outString, DWORD outStrLen);

    static BOOL HasTrailByte(STRINGREF str);
    static BOOL GetTrailByte(STRINGREF str, BYTE *bTrailByte);
    static BOOL SetTrailByte(STRINGREF str, BYTE bTrailByte);
    static BOOL CaseInsensitiveCompHelper(WCHAR *, WCHAR *, int, int, int *);
};

/*================================GetEmptyString================================
**Get a reference to the empty string.  If we haven't already gotten one, we
**query the String class for a pointer to the empty string that we know was 
**created at startup.
**
**Args: None
**Returns: A STRINGREF to the EmptyString
**Exceptions: None
==============================================================================*/
inline STRINGREF COMString::GetEmptyString() {
    
    THROWSCOMPLUSEXCEPTION();

    //If we've never gotten a reference to the EmptyString, we need to go get one.
    if (EmptyStringHandle==NULL) {

        // N.B about app domains - what we're doing here is technically
        // illegal, because we're handing out one app domain's String.Empty
        // to every domain (via the global EmptyStringHandle.)  However, strings
        // are agile, and furthermore, every domain should end up with the same
        // value for String.Empty anyway since we intern all literals through the
        // global string table.

        GetStringFromClass(FIELD__STRING__EMPTY, &EmptyStringHandle);
    }
    //We've already have a reference to the EmptyString, so we can just return it.
    return (STRINGREF) ObjectFromHandle(EmptyStringHandle);
}

#endif _COMSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsystem.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMSystem.h
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Native methods on System.System
**
** Date:  March 30, 1998
**
===========================================================*/

#ifndef _COMSYSTEM_H
#define _COMSYSTEM_H

#include "fcall.h"

// Return values for CanAssignArrayType
enum AssignArrayEnum {
    AssignWrongType,
    AssignWillWork,
    AssignMustCast,
    AssignBoxValueClassOrPrimitive,
    AssignUnboxValueClassAndCast,
    AssignPrimitiveWiden,
};


//
// Each function that we call through native only gets one argument,
// which is actually a pointer to it's stack of arguments.  Our structs
// for accessing these are defined below.
//

class SystemNative
{

    friend class DebugStackTrace;

    struct ArrayCopyArgs
    {
        DECLARE_ECALL_I4_ARG(INT32,      m_iLength);
        DECLARE_ECALL_I4_ARG(INT32,      m_iDstIndex);
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, m_pDst);
        DECLARE_ECALL_I4_ARG(INT32,      m_iSrcIndex);
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, m_pSrc);
    };

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, inArray);
    } _getEmptyArrayForCloningArgs;

    struct ArrayClearArgs
    {
        DECLARE_ECALL_I4_ARG(INT32,      m_iLength);
        DECLARE_ECALL_I4_ARG(INT32,      m_iIndex);
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, m_pArray);
    };

    struct ExitArgs
    {
        DECLARE_ECALL_I4_ARG(INT32,      m_iExitCode);
    };

    struct GetEnvironmentVariableArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strVar);
    };

    struct DumpStackTraceInternalArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, m_pStackTrace);
    };

    struct CaptureStackTraceMethodArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, m_pStackTrace);
    };

    struct NoArgs
    {
    };

    struct AssemblyArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refAssembly);
    };

public:
    struct StackTraceElement {
        SLOT ip;
        DWORD sp;
        MethodDesc *pFunc;
    };

private:
    struct CaptureStackTraceData
    {
        // Used for the integer-skip version
        INT32   skip;

        INT32   cElementsAllocated;
        INT32   cElements;
        StackTraceElement* pElements;
        void*   pStopStack;   // use to limit the crawl

        CaptureStackTraceData() : skip(0), cElementsAllocated(0), cElements(0), pElements(NULL), pStopStack((void*)-1) {}
    };

public:
    // Functions on System.Array
    static void __stdcall ArrayCopy(const ArrayCopyArgs *);
    static void __stdcall ArrayClear(const ArrayClearArgs *);
    static LPVOID __stdcall GetEmptyArrayForCloning(_getEmptyArrayForCloningArgs *);

    // Functions on the System.Environment class
    static FCDECL0(UINT32, GetTickCount);
    static FCDECL0(INT64, GetWorkingSet);
    static void __stdcall Exit(ExitArgs *);
    static void __stdcall SetExitCode(ExitArgs *);
    static int __stdcall  GetExitCode(LPVOID noArgs);
    static LPVOID __stdcall GetCommandLineArgs(LPVOID noargs);
    static LPVOID __stdcall GetEnvironmentVariable(GetEnvironmentVariableArgs *);
    static LPVOID __stdcall GetEnvironmentCharArray(const void* /*no args*/);
    static LPVOID __stdcall GetVersionString(LPVOID /*no args*/);
    static OBJECTREF CaptureStackTrace(Frame *pStartFrame, void* pStopStack, CaptureStackTraceData *pData=NULL);

    static LPVOID __stdcall GetModuleFileName(NoArgs*);
    static LPVOID __stdcall GetDeveloperPath(NoArgs*);
    static LPVOID __stdcall GetRuntimeDirectory(NoArgs*);
    static LPVOID __stdcall GetHostBindingFile(NoArgs*);
    static INT32  __stdcall FromGlobalAccessCache(AssemblyArgs* args);

    static FCDECL0(BOOL, HasShutdownStarted);

    // The exit code for the process is communicated in one of two ways.  If the
    // entrypoint returns an 'int' we take that.  Otherwise we take a latched
    // process exit code.  This can be modified by the app via System.SetExitCode().
    static INT32 LatchedExitCode;

    // CaptureStackTraceMethod
    // Return a method info for the method were the exception was thrown
    static LPVOID __stdcall CaptureStackTraceMethod(CaptureStackTraceMethodArgs*);

private:
    static StackWalkAction CaptureStackTraceCallback(CrawlFrame *, VOID*);
    static LPUTF8 __stdcall FormatStackTraceInternal(DumpStackTraceInternalArgs *);

    // The following functions are all helpers for ArrayCopy
    static AssignArrayEnum CanAssignArrayType(const BASEARRAYREF pSrc, const BASEARRAYREF pDest);
    static void CastCheckEachElement(BASEARRAYREF pSrc, unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, unsigned int length);
    static void BoxEachElement(BASEARRAYREF pSrc, unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, unsigned int length);
    static void UnBoxEachElement(BASEARRAYREF pSrc, unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, unsigned int length, BOOL castEachElement);
    static void PrimitiveWiden(BASEARRAYREF pSrc, unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, unsigned int length);
};

inline void SetLatchedExitCode (INT32 code)
{
    SystemNative::LatchedExitCode = code;
}

inline INT32 GetLatchedExitCode (void)
{
    return SystemNative::LatchedExitCode;
}

#endif _COMSYSTEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsynchronizable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMSynchronizable.cpp
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Native methods on System.SynchronizableObject
**          and its subclasses.
**
** Date:  April 1, 1998
** 
===========================================================*/

#include "common.h"

#include <object.h>
#include "threads.h"
#include "excep.h"
#include "vars.hpp"
#include "field.h"
#include "security.h"
#include "COMSynchronizable.h"
#include "DbgInterface.h"
#include "COMDelegate.h"
#include "ReflectWrap.h"
#include "Remoting.h"
#include "EEConfig.h"
#include "threads.inl"

MethodTable* ThreadNative::m_MT = NULL;
MethodDesc* ThreadNative::m_SetPrincipalMethod;


// The two threads need to communicate some information.  Any object references must
// be declared to GC.
struct SharedState
{
    OBJECTHANDLE    m_Threadable;
    Thread         *m_Internal;
    OBJECTHANDLE    m_Principal;

    SharedState(OBJECTREF threadable, Thread *internal, OBJECTREF principal)
    {
        m_Threadable = internal->GetKickOffDomain()->CreateHandle(NULL);
        StoreObjectInHandle(m_Threadable, threadable);

        m_Internal = internal;
        m_Principal = internal->GetKickOffDomain()->CreateHandle(NULL);
        StoreObjectInHandle(m_Principal, principal);
    }

    ~SharedState()
    {
        // These handles are in the kickoff AppDomain which may have been unloaded (ASURT 128414)
        AppDomain *pKickOffDomain = m_Internal->GetKickOffDomain();        
        if(pKickOffDomain)
        {
            DestroyHandle(m_Threadable);
            DestroyHandle(m_Principal);
        }
    }

    static SharedState  *MakeSharedState(OBJECTREF threadable, Thread *internal, OBJECTREF principal);
};


// For the following helpers, we make no attempt to synchronize.  The app developer
// is responsible for managing his own race conditions.
//
// Note: if the internal Thread is NULL, this implies that the exposed object has
//       finalized and then been resurrected.
static inline BOOL ThreadNotStarted(Thread *t)
{
    return (t && t->IsUnstarted() && (t->GetThreadHandle() == INVALID_HANDLE_VALUE));
}

static inline BOOL ThreadIsRunning(Thread *t)
{
    return (t && (t->GetThreadHandle() != INVALID_HANDLE_VALUE));
}

static inline BOOL ThreadIsDead(Thread *t)
{
    return (t == 0 || t->IsDead());
}


// Map our exposed notion of thread priorities into the enumeration that NT uses.
static INT32 MapToNTPriority(INT32 ours)
{
    THROWSCOMPLUSEXCEPTION();

    INT32   NTPriority = 0;

    switch (ours)
    {
    case ThreadNative::PRIORITY_LOWEST:
        NTPriority = THREAD_PRIORITY_LOWEST;
        break;

    case ThreadNative::PRIORITY_BELOW_NORMAL:
        NTPriority = THREAD_PRIORITY_BELOW_NORMAL;
        break;

    case ThreadNative::PRIORITY_NORMAL:
        NTPriority = THREAD_PRIORITY_NORMAL;
        break;

    case ThreadNative::PRIORITY_ABOVE_NORMAL:
        NTPriority = THREAD_PRIORITY_ABOVE_NORMAL;
        break;

    case ThreadNative::PRIORITY_HIGHEST:
        NTPriority = THREAD_PRIORITY_HIGHEST;
        break;

    default:
        COMPlusThrow(kArgumentOutOfRangeException, L"Argument_InvalidFlag");
    }
    return NTPriority;
}


// Retrieve the handle from the internal thread.
HANDLE ThreadBaseObject::GetHandle()
{
    Thread  *thread = GetInternal();

    return (thread
            ? thread->GetThreadHandle()
            : INVALID_HANDLE_VALUE);
}

void ThreadNative::KickOffThread_Worker(KickOffThread_Args *args)
{
    args->retVal = 0;

    // we are saving the delagate and result primarily for debugging
    struct _gc {
        OBJECTREF orPrincipal;
        OBJECTREF orDelegate;
        OBJECTREF orResult;
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    GCPROTECT_BEGIN(gc);
    gc.orPrincipal = ObjectFromHandle(args->share->m_Principal);
    // Push the initial security principal object (if any) onto the
    // managed thread.
    if (gc.orPrincipal != NULL) {
        INT64 argsToSetPrincipal[2];
        argsToSetPrincipal[0] = ObjToInt64(args->pThread->GetExposedObject());
        argsToSetPrincipal[1] = ObjToInt64(gc.orPrincipal);
        m_SetPrincipalMethod->Call(argsToSetPrincipal, METHOD__THREAD__SET_PRINCIPAL_INTERNAL);
    }

    gc.orDelegate = ObjectFromHandle(args->share->m_Threadable);

    // We cannot call the Delegate Invoke method directly from ECall.  The
    //  stub has not been created for non multicast delegates.  Instead, we
    //  will invoke the Method on the OR stored in the delegate directly.
    // If there are changes to the signature of the ThreadStart delegate
    //  this code will need to change.  I've noted this in the Thread start
    //  class.
    INT64 arg[1];

    delete args->share;
    args->share = 0;

    MethodDesc *pMeth = ((DelegateEEClass*)( gc.orDelegate->GetClass() ))->m_pInvokeMethod;
    _ASSERTE(pMeth);
    arg[0] = ObjToInt64(gc.orDelegate);
    pMeth->Call(arg);
    GCPROTECT_END();
}



// When an exposed thread is started by Win32, this is where it starts.
ULONG __stdcall ThreadNative::KickOffThread(void *pass)
{
    ULONG retVal = 0;
    // Before we do anything else, get Setup so that we have a real thread.

    KickOffThread_Args args;
    // don't have a separate var becuase this can be updated in the worker
    args.share = (SharedState *) pass;
    Thread      *thread = args.share->m_Internal;
    args.pThread = thread;

    _ASSERTE(thread != NULL);

    // We have a sticky problem here.
    //
    // Under some circumstances, the context of 'this' doesn't match the context
    // of the thread.  Today this can only happen if the thread is marked for an
    // STA.  If so, the delegate that is stored in the object may not be directly
    // suitable for invocation.  Instead, we need to call through a proxy so that
    // the correct context transitions occur.
    //
    // All the changes occur inside HasStarted(), which will switch this thread
    // over to a brand new STA as necessary.  We have to notice this happening, so
    // we can adjust the delegate we are going to invoke on.

    BOOL         ok = thread->HasStarted();

    _ASSERTE(GetThread() == thread);        // Now that it's started
    _ASSERTE(ObjectFromHandle(args.share->m_Threadable) != NULL);

    // Note that we aren't reporting errors if the thread fails to start up properly.
    // The best we can do is quietly clean up our mess.  But the most likely reason
    // for (!ok) is that someone called Thread.Abort() on us before we got a call to
    // Thread.Start().
    if (ok)
    {
        COMPLUS_TRYEX(thread)
        {
			__try {
				AppDomain *pKickOffDomain = thread->GetKickOffDomain();
				// should always have a kickoff domain - a thread should never start in a domain that is unloaded
				// because otherwise it would have been collected because nobody can hold a reference to thread object
				// in a domain that has been unloaded. But it is possible that we started the unload, in which 
				// case this thread wouldn't be allowed in or would be punted anyway.
				if (! pKickOffDomain)
					// this doesn't actually do much, since it will be caught below, but it might leave a trace
					// as to why the thread didn't start
					COMPlusThrow(kAppDomainUnloadedException);
				if (pKickOffDomain != thread->GetDomain())
				{
					thread->DoADCallBack(pKickOffDomain->GetDefaultContext(), ThreadNative::KickOffThread_Worker, &args);
					retVal = args.retVal;
				}
				else
				{
					KickOffThread_Worker(&args);
					retVal = args.retVal;
				}
			} __except(ThreadBaseExceptionFilter(GetExceptionInformation(), thread, ManagedThread)) {
				_ASSERTE(!"ThreadBaseExceptionFilter returned EXECUTE_HANDLER.");
				FreeBuildDebugBreak();
			}
        }
        COMPLUS_CATCH
        {
            LOG((LF_EH, LL_INFO100, "ThreadNative::KickOffThread caught exception\n"));
            // fall through to thread destruction...
        }
        COMPLUS_END_CATCH
    }

    thread->ResetStopRequest();     // pointless, now

    COMPLUS_TRYEX(thread)
    {
        _ASSERTE(thread->PreemptiveGCDisabled());

        // GetExposedObject() will either throw, or we have a valid object.  Note
        // that we re-acquire it each time, since it may move during calls.
        thread->GetExposedObject()->EnterObjMonitor();
        thread->GetExposedObject()->PulseAll();
        thread->GetExposedObject()->LeaveObjMonitor();
    }
    COMPLUS_CATCH
    {
        _ASSERTE(FALSE);
        // just keep going...
    }
    COMPLUS_END_CATCH

    if (args.share)
        delete args.share;

    thread->EnablePreemptiveGC();
    DestroyThread(thread);

    return retVal;
}


// Start up a thread, which by now should be in the ThreadStore's Unstarted list.
void __stdcall ThreadNative::Start(StartArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    _ASSERTE(pargs != NULL);

    THREADBASEREF  or = pargs->m_pThis;
    Thread        *pCurThread = GetThread();
    Thread        *pNewThread = or->GetInternal();

    GCPROTECT_BEGIN( or );

    SharedState     *share = NULL;

    EE_TRY_FOR_FINALLY
    {
        HANDLE        h;
        DWORD         newThreadId;

        _ASSERTE(pCurThread != NULL);           // Current thread wandered in!

        pargs->m_pThis->EnterObjMonitor();
    
        // Is the thread already started?  You can't restart a thread.
        if (ThreadIsRunning(pNewThread) || ThreadIsDead(pNewThread))
            COMPlusThrow(kThreadStateException, IDS_EE_THREADSTART_STATE);

        // Carry over the state used by security to the new thread
        pNewThread->CarryOverSecurityInfo(pCurThread);

        // Generate code-access security stack to carry over to thread.

		CompressedStack* pCodeAccessStack = Security::GetDelayedCompressedStack();

		_ASSERTE (pCodeAccessStack != NULL || Security::IsSecurityOff());

		// Compressed stack might be null if security is off.
		if (pCodeAccessStack != NULL)
		{
			// Add permission stack object to thread.
			pNewThread->SetDelayedInheritedSecurityStack(pCodeAccessStack);

			// We need to release the compressed stack now since setting it will increment it
			pCodeAccessStack->Release();
		}

        OBJECTREF   threadable = or->GetDelegate();
        or->SetDelegate(NULL);

        // This can never happen, because we construct it with a valid one and then
        // we never let you change it (because SetStart is private).
        _ASSERTE(threadable != NULL);

        // Allocate this away from our stack, so we can unwind without affecting
        // KickOffThread.  It is inside a GCFrame, so we can enable GC now.
        share = SharedState::MakeSharedState(threadable, pNewThread, pargs->m_pPrincipal);
        if (share == NULL)
            COMPlusThrowOM();

        // As soon as we create the new thread, it is eligible for suspension, etc.
        // So it gets transitioned to cooperative mode before this call returns to
        // us.  It is our duty to start it running immediately, so that GC isn't blocked.

        h = pNewThread->CreateNewThread(0 /*stackSize override*/,
                                        KickOffThread, share, &newThreadId);

        _ASSERTE(h != NULL);        // CreateNewThread returns INVALID_HANDLE_VALUE for failure
        if (h == INVALID_HANDLE_VALUE)
            COMPlusThrowOM();

        _ASSERTE(pNewThread->GetThreadHandle() == h);

        // After we have established the thread handle, we can check m_Priority.
        // This ordering is required to eliminate the race condition on setting the
        // priority of a thread just as it starts up.
        ::SetThreadPriority(h, MapToNTPriority(pargs->m_pThis->m_Priority));

        // Before we do the resume, we need to take note of the new ThreadId.  This
        // is necessary because -- before the thread starts executing at KickofThread --
        // it may perform some DllMain DLL_THREAD_ATTACH notifications.  These could
        // call into managed code.  During the consequent SetupThread, we need to
        // perform the Thread::HasStarted call instead of going through the normal
        // 'new thread' pathway.
        _ASSERTE(pNewThread->GetThreadId() == 0);
        _ASSERTE(newThreadId != 0);

        pNewThread->SetThreadId(newThreadId);

        share = NULL;       // we have handed off ownership of the shared struct



        FastInterlockOr((ULONG *) &pNewThread->m_State, Thread::TS_LegalToJoin);

#ifdef _DEBUG
        DWORD   ret =
#endif
        ::ResumeThread(h);


        _ASSERTE(ret == 1);
    }
    EE_FINALLY
    {
        if (share != NULL)
            delete share;
        pargs->m_pThis->LeaveObjMonitor();
    } EE_END_FINALLY;

    GCPROTECT_END();
}

FCIMPL1(void, ThreadNative::Abort, ThreadBaseObject* pThis)
{
    THROWSCOMPLUSEXCEPTION();
	if (pThis == NULL)
        FCThrowVoid(kNullReferenceException);

    THREADBASEREF thisRef(pThis);
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    Thread *thread = thisRef->GetInternal();
    if (thread == NULL)
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_CANNOT_GET);
    thread->UserAbort(thisRef);

    HELPER_METHOD_FRAME_END_POLL();
}
FCIMPLEND

FCIMPL1(void, ThreadNative::ResetAbort, ThreadBaseObject* pThis)
{
	_ASSERTE(pThis);
	VALIDATEOBJECTREF(pThis);
    THROWSCOMPLUSEXCEPTION();
    Thread *thread = pThis->GetInternal();
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    if (thread == NULL)
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_CANNOT_GET);
    thread->UserResetAbort();
    HELPER_METHOD_FRAME_END_POLL();
}
FCIMPLEND

// You can only suspend a running thread.
void __stdcall ThreadNative::Suspend(NoArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    Thread  *thread = pargs->m_pThis->GetInternal();

    if (!ThreadIsRunning(thread))
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_SUSPEND_NON_RUNNING);

    thread->UserSuspendThread();
}


// You can only resume a thread that is in the user-suspended state.  (This puts a large
// burden on the app developer, but we want him to be thinking carefully about race
// conditions.  Precise errors give him a hope of sorting out his logic).
void __stdcall ThreadNative::Resume(NoArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(pargs != NULL);
    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    Thread  *thread = pargs->m_pThis->GetInternal();

    // UserResumeThread() will return 0 if there isn't a user suspension for us to
    // clear.
    if (!ThreadIsRunning(thread))
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_RESUME_NON_RUNNING);
        
    if (thread->UserResumeThread() == 0)
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_RESUME_NON_USER_SUSPEND);
}


// Note that you can manipulate the priority of a thread that hasn't started yet,
// or one that is running.  But you get an exception if you manipulate the priority
// of a thread that has died.
INT32 __stdcall ThreadNative::GetPriority(NoArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // validate the handle
    if (ThreadIsDead(pargs->m_pThis->GetInternal()))
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_DEAD_PRIORITY);

    return pargs->m_pThis->m_Priority;
}

void __stdcall ThreadNative::SetPriority(SetPriorityArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    int     priority;
    Thread *thread;

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // translate the priority (validating as well)
    priority = MapToNTPriority(pargs->m_iPriority);
    
    // validate the thread
    thread = pargs->m_pThis->GetInternal();

    if (ThreadIsDead(thread))
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_DEAD_PRIORITY);

    // Eliminate the race condition by establishing m_Priority before we check for if
    // the thread is running.  See ThreadNative::Start() for the other half.
    pargs->m_pThis->m_Priority = pargs->m_iPriority;

    HANDLE  h = thread->GetThreadHandle();

    if (h != INVALID_HANDLE_VALUE)
        ::SetThreadPriority(h, priority);
}

// This service can be called on unstarted and dead threads.  For unstarted ones, the
// next wait will be interrupted.  For dead ones, this service quietly does nothing.
void __stdcall ThreadNative::Interrupt(NoArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    Thread  *thread = pargs->m_pThis->GetInternal();

    if (thread == 0)
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_CANNOT_GET);

    thread->UserInterrupt();
}

INT32/*bool*/ __stdcall ThreadNative::IsAlive(NoArgs *pargs)
{
    _ASSERTE(pargs != NULL);
    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    Thread  *thread = pargs->m_pThis->GetInternal();

    if (thread == 0)
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_CANNOT_GET);

    return ThreadIsRunning(thread);
}

void __stdcall ThreadNative::Join(NoArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    DoJoin(pargs->m_pThis, INFINITE_TIMEOUT);
}

INT32/*bool*/ __stdcall ThreadNative::JoinTimeout(JoinTimeoutArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // validate the timeout
    if ((pargs->m_Timeout < 0) && (pargs->m_Timeout != INFINITE_TIMEOUT))
        COMPlusThrowArgumentOutOfRange(L"millisecondsTimeout", L"ArgumentOutOfRange_NeedNonNegOrNegative1");

    return DoJoin(pargs->m_pThis, pargs->m_Timeout);
}

void __stdcall ThreadNative::Sleep(SleepArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();

    // validate the sleep time
    if ((pargs->m_iTime < 0) && (pargs->m_iTime != INFINITE_TIMEOUT))
        COMPlusThrowArgumentOutOfRange(L"millisecondsTimeout", L"ArgumentOutOfRange_NeedNonNegOrNegative1");

    GetThread()->UserSleep(pargs->m_iTime);
}

LPVOID __stdcall ThreadNative::GetCurrentThread(LPVOID /*no args*/)
{
    THROWSCOMPLUSEXCEPTION();

    Thread      *pCurThread = GetThread();
    LPVOID       rv = NULL;

    _ASSERTE(pCurThread->PreemptiveGCDisabled());

    *((OBJECTREF *)&rv) = pCurThread->GetExposedObject();
    return rv;
}

__declspec(naked) LPVOID __fastcall ThreadNative::FastGetCurrentThread()
{
#ifdef _X86_
    __asm{
        call GetThread
        test eax, eax
        je exit
        mov eax, dword ptr [eax]Thread.m_ExposedObject
        test eax, eax
        je exit
        mov eax, dword ptr [eax]
exit:
        ret
    }
#else
    return NULL;
#endif
}

void __stdcall ThreadNative::SetStart(SetStartArgs *pargs)
{
    _ASSERTE(pargs != NULL);
    _ASSERTE(pargs->m_pThis != NULL);
    _ASSERTE(pargs->m_pDelegate != NULL); // Thread's constructor validates this

    if (pargs->m_pThis->m_InternalThread == NULL)
    {
        // if we don't have an internal Thread object associated with this exposed object,
        // now is our first opportunity to create one.
        Thread      *unstarted = SetupUnstartedThread();

        pargs->m_pThis->SetInternal(unstarted);
        unstarted->SetExposedObject((OBJECTREF) pargs->m_pThis);
    }

#ifdef APPDOMAIN_STATE
	// make sure that we have set the kickoff ID correctly if this is the unloadthread worker.
	// we have some weird bug (84321) where sometimes the kickoff domain for the thread created
	// in UnloadThreadWorker is the domain to be unloaded rather than the default domain.
	FieldDesc *pFD = COMDelegate::GetOR();
    OBJECTREF target = NULL;

#ifdef PROFILING_SUPPORTED
	GCPROTECT_BEGIN(target);
#endif

    pFD->GetInstanceField(pargs->m_pDelegate, &target);
	if (target != NULL && target->GetMethodTable() == g_Mscorlib.GetClass(CLASS__UNLOAD_THREAD_WORKER))
		_ASSERTE_ALL_BUILDS(pargs->m_pThis->m_InternalThread->GetKickOffDomain() == SystemDomain::System()->DefaultDomain());

#ifdef PROFILING_SUPPORTED
	GCPROTECT_END();
#endif

#endif

    // save off the delegate
    pargs->m_pThis->SetDelegate(pargs->m_pDelegate);
}


// Set whether or not this is a background thread.
void __stdcall ThreadNative::SetBackground(SetBackgroundArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // validate the thread
    Thread  *thread = pargs->m_pThis->GetInternal();

    if (ThreadIsDead(thread))
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_DEAD_PRIORITY);

    thread->SetBackground(pargs->m_isBackground);
}


// Return whether or not this is a background thread.
INT32/*bool*/ __stdcall ThreadNative::IsBackground(NoArgs *pargs)
{
    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // validate the thread
    Thread  *thread = pargs->m_pThis->GetInternal();

    if (ThreadIsDead(thread))
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_DEAD_PRIORITY);

    // booleanize
    return !!thread->IsBackground();
}


// Deliver the state of the thread as a consistent set of bits.
// This copied in VM\EEDbgInterfaceImpl.h's
//     CorDebugUserState GetUserState( Thread *pThread )
// , so propogate changes to both functions
INT32 __stdcall ThreadNative::GetThreadState(NoArgs *pargs)
{
    INT32               res = 0;
    Thread::ThreadState state;

    _ASSERTE(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // validate the thread.  Failure here implies that the thread was finalized
    // and then resurrected.
    Thread  *thread = pargs->m_pThis->GetInternal();

    if (!thread)
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_CANNOT_GET);

    // grab a snapshot
    state = thread->GetSnapshotState();

    if (state & Thread::TS_Background)
        res |= ThreadBackground;

    if (state & Thread::TS_Unstarted)
        res |= ThreadUnstarted;

    // Don't report a StopRequested if the thread has actually stopped.
    if (state & Thread::TS_Dead)
    {
        if (state & Thread::TS_AbortRequested)
            res |= ThreadAborted;
        else
            res |= ThreadStopped;
    }
    else
    {
        if (state & Thread::TS_AbortRequested)
            res |= ThreadAbortRequested;
        else
        if (state & Thread::TS_UserStopRequested)
            res |= ThreadStopRequested;
    }

    if (state & Thread::TS_Interruptible)
        res |= ThreadWaitSleepJoin;

    // Don't report a SuspendRequested if the thread has actually Suspended.
    if ((state & Thread::TS_UserSuspendPending) &&
        (state & Thread::TS_SyncSuspended)
       )
    {
        res |= ThreadSuspended;
    }
    else
    if (state & Thread::TS_UserSuspendPending)
    {
        res |= ThreadSuspendRequested;
    }

    return res;
}


// Indicate whether the thread will host an STA (this may fail if the thread has
// already been made part of the MTA, use GetApartmentState or the return state
// from this routine to check for this).
INT32 __stdcall ThreadNative::SetApartmentState(SetApartmentStateArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    BOOL    ok = TRUE;

    // Translate state input. ApartmentUnknown is not an acceptable input state.
    // Throw an exception here rather than pass it through to the internal
    // routine, which asserts.
    Thread::ApartmentState state = Thread::AS_Unknown;
    if (pargs->m_iState == ApartmentSTA)
        state = Thread::AS_InSTA;
    else if (pargs->m_iState == ApartmentMTA)
        state = Thread::AS_InMTA;
    else
        COMPlusThrow(kArgumentOutOfRangeException, L"ArgumentOutOfRange_Enum");

    Thread  *thread = pargs->m_pThis->GetInternal();
    if (!thread)
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_CANNOT_GET);

    pargs->m_pThis->EnterObjMonitor();

    // From this point on, exceptions would be bad.  We wouldn't unwind the fact
    // that we are inside the monitor.
    {
        CANNOTTHROWCOMPLUSEXCEPTION();
        {
            // We can only change the apartment if the thread is unstarted or
            // running, and if it's running we have to be in the thread's
            // context.
            if ((!ThreadNotStarted(thread) && !ThreadIsRunning(thread)) ||
                (!ThreadNotStarted(thread) && (::GetCurrentThreadId() != thread->GetThreadId())))
                ok = FALSE;
            else
                state = thread->SetApartment(state);
        }
    }

    pargs->m_pThis->LeaveObjMonitor();

    // Now it's safe to throw exceptions again.
    if (!ok)
        COMPlusThrow(kThreadStateException);

    // Translate state back into external form
    INT32 retVal = ApartmentUnknown;
    if (state == Thread::AS_InSTA)
        retVal = ApartmentSTA;
    else if (state == Thread::AS_InMTA)
        retVal = ApartmentMTA;
    else if (state == Thread::AS_Unknown)
        retVal = ApartmentUnknown;
    else
        _ASSERTE(!"Invalid state returned from SetApartment");

    return retVal;
}

// Return whether the thread hosts an STA, is a member of the MTA or is not
// currently initialized for COM.
INT32 __stdcall ThreadNative::GetApartmentState(NoArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();
    if (pargs->m_pThis==NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    Thread *thread = pargs->m_pThis->GetInternal();
    if (ThreadIsDead(thread))
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_DEAD_STATE);

    Thread::ApartmentState state = thread->GetApartment();

    // Translate state into external form
    INT32 retVal = ApartmentUnknown;
    if (state == Thread::AS_InSTA)
        retVal = ApartmentSTA;
    else if (state == Thread::AS_InMTA)
        retVal = ApartmentMTA;
    else if (state == Thread::AS_Unknown)
        retVal = ApartmentUnknown;
    else
        _ASSERTE(!"Invalid state returned from GetApartment");

    return retVal;
}

// Wait for the thread to die
BOOL ThreadNative::DoJoin(THREADBASEREF DyingThread, INT32 timeout)
{
    _ASSERTE(DyingThread != NULL);

    HANDLE   h;
    DWORD    dwTimeOut32;
    DWORD    rv = 0;
    Thread  *DyingInternal;

    THROWSCOMPLUSEXCEPTION();

    if (timeout < 0 && timeout != INFINITE_TIMEOUT)
        COMPlusThrow(kArgumentOutOfRangeException, L"ArgumentOutOfRange_NeedNonNegOrNegative1");

    DyingInternal = DyingThread->GetInternal();

    // Validate the handle.  It's valid to Join a thread that's not running -- so
    // long as it was once started.
    if (DyingInternal == 0 ||
        !(DyingInternal->m_State & Thread::TS_LegalToJoin))
    {
        COMPlusThrow(kThreadStateException, IDS_EE_THREAD_NOTSTARTED);
    }

    // Don't grab the handle until we know it has started, to eliminate the race
    // condition.
    h = DyingInternal->GetThreadHandle();

    if (ThreadIsDead(DyingInternal) || h == INVALID_HANDLE_VALUE)
        return TRUE;

    dwTimeOut32 = (timeout == INFINITE_TIMEOUT
                   ? INFINITE
                   : (DWORD) timeout);

    // There is a race here.  DyingThread is going to close its thread handle.
    // If we grab the handle and then DyingThread closes it, we will wait forever
    // in DoAppropriateWait.
    int RefCount = DyingInternal->IncExternalCount();
    h = DyingInternal->GetThreadHandle();
    if (RefCount == 1)
    {
        // !!! We resurrect the Thread Object.
        // !!! We will keep the Thread ref count to be 1 so that we will not try
        // !!! to destroy the Thread Object again.
        // !!! Do not call DecExternalCount here!
        _ASSERTE (h == INVALID_HANDLE_VALUE);
        return TRUE;
    }
    if (h == INVALID_HANDLE_VALUE)
    {
        DyingInternal->DecExternalCount(FALSE);
        return TRUE;
    }

    Thread *pCurThread = GetThread();
    pCurThread->EnablePreemptiveGC();

    COMPLUS_TRY {
    rv = pCurThread->DoAppropriateWait(1, &h, TRUE/*waitAll*/, dwTimeOut32,
                                       TRUE/*alertable*/);

    pCurThread->DisablePreemptiveGC();

    }
    COMPLUS_FINALLY {
    DyingInternal->DecExternalCount(FALSE);
    } COMPLUS_END_FINALLY
    return (rv == WAIT_OBJECT_0);
}


// This is a hokey factory service.  There are two reasons for its existence.  First,
// SharedState cannot be stack allocated because it will be passed between two
// threads.  One is free to return, before the other consumes it.
//
// Second, it's not possible to do a C++ 'new' in the same method as a COM catch/try.
// That's because they each use different try/fail (C++ vs. SEH).  So move it down
// here where hopefully it will not be inlined.
SharedState *SharedState::MakeSharedState(OBJECTREF threadable, Thread *internal, OBJECTREF principal)
{
    return new SharedState(threadable, internal, principal);
}


// We don't get a constructor for ThreadBaseObject, so we rely on the fact that this
// method is only called once, out of SetStart.  Since SetStart is private/native
// and only called from the constructor, we'll only get called here once to set it
// up and once (with NULL) to tear it down.  The 'null' can only come from Finalize
// because the constructor throws if it doesn't get a valid delegate.
void ThreadBaseObject::SetDelegate(OBJECTREF delegate)
{
#ifdef APPDOMAIN_STATE
	if (delegate != NULL)
	{
		AppDomain *pDomain = delegate->GetAppDomain();
		Thread *pThread = GetInternal();
		AppDomain *kickoffDomain = pThread->GetKickOffDomain();
		_ASSERTE_ALL_BUILDS(! pDomain || pDomain == kickoffDomain);
		_ASSERTE_ALL_BUILDS(kickoffDomain == GetThread()->GetDomain());
	}
#endif

    SetObjectReferenceUnchecked( (OBJECTREF *)&m_Delegate, delegate );

    // If the delegate is being set then initialize the other data members.
    if (m_Delegate != NULL)
    {
        // Initialize the thread priority to normal.
        m_Priority = ThreadNative::PRIORITY_NORMAL;
    }
}


// If the exposed object is created after-the-fact, for an existing thread, we call
// InitExisting on it.  This is the other "construction", as opposed to SetDelegate.
void ThreadBaseObject::InitExisting()
{
    switch (::GetThreadPriority(GetHandle()))
    {
    case THREAD_PRIORITY_LOWEST:
    case THREAD_PRIORITY_IDLE:
        m_Priority = ThreadNative::PRIORITY_LOWEST;
        break;

    case THREAD_PRIORITY_BELOW_NORMAL:
        m_Priority = ThreadNative::PRIORITY_BELOW_NORMAL;
        break;

    case THREAD_PRIORITY_NORMAL:
        m_Priority = ThreadNative::PRIORITY_NORMAL;
        break;

    case THREAD_PRIORITY_ABOVE_NORMAL:
        m_Priority = ThreadNative::PRIORITY_ABOVE_NORMAL;
        break;

    case THREAD_PRIORITY_HIGHEST:
    case THREAD_PRIORITY_TIME_CRITICAL:
        m_Priority = ThreadNative::PRIORITY_HIGHEST;
        break;

    case THREAD_PRIORITY_ERROR_RETURN:
    default:
        _ASSERTE(FALSE);
        m_Priority = ThreadNative::PRIORITY_NORMAL;
        break;
    }

}

            
void __stdcall ThreadNative::Finalize(NoArgs *pargs)
{
    _ASSERTE(pargs->m_pThis != NULL);
    Thread     *thread = pargs->m_pThis->GetInternal();

    // Prevent multiple calls to Finalize
    // Objects can be resurrected after being finalized.  However, there is no
    // race condition here.  We always check whether an exposed thread object is
    // still attached to the internal Thread object, before proceeding.
    if (!thread)
        return;

    pargs->m_pThis->SetDelegate(NULL);

    // During process shutdown, we finalize even reachable objects.  But if we break
    // the link between the System.Thread and the internal Thread object, the runtime
    // may not work correctly.  In particular, we won't be able to transition between
    // contexts and domains to finalize other objects.  Since the runtime doesn't
    // require that Threads finalize during shutdown, we need to disable this.  If
    // we wait until phase 2 of shutdown finalization (when the EE is suspended and
    // will never resume) then we can simply skip the side effects of Thread
    // finalization.
    if ((g_fEEShutDown & ShutDown_Finalize2) == 0)
    {
        if (GetThread() != thread)
        {
            pargs->m_pThis->SetInternal(NULL);
        }

        thread->RemoveAllDomainLocalStores();

        // we no longer need to keep the thread object alive.
        if (thread)
            thread->DecExternalCount(FALSE);
    }
}


LPVOID __stdcall ThreadNative::GetDomainLocalStore(LPVOID /* no args */ )
{
    LPVOID rv = NULL;

    Thread* thread = GetThread();
    
    if (thread && thread->m_pDLSHash && thread->GetDomain())
    {
        HashDatum Data;

        Thread *pCurThread = GetThread();
        BOOL toggleGC = pCurThread->PreemptiveGCDisabled();
        
        if (toggleGC)
            pCurThread->EnablePreemptiveGC();
        ThreadStore::LockDLSHash();
        if (toggleGC)
            pCurThread->DisablePreemptiveGC();

        if (thread->m_pDLSHash->GetValue(thread->GetDomain()->GetId(), &Data))
        {
            LocalDataStore *pLDS = (LocalDataStore *) Data;
            *((OBJECTREF*) &rv) = (OBJECTREF) pLDS->GetRawExposedObject();
            _ASSERTE(rv != NULL);
        }
        ThreadStore::UnlockDLSHash();
    }

    return rv;
}

void __stdcall ThreadNative::SetDomainLocalStore(SetDLSArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    Thread* thread = GetThread();
    
    if (thread && thread->GetDomain())
    {
        Thread *pCurThread = GetThread();
        BOOL toggleGC = pCurThread->PreemptiveGCDisabled();
        
        if (toggleGC)
            pCurThread->EnablePreemptiveGC();
        ThreadStore::LockDLSHash();
        if (toggleGC)
            pCurThread->DisablePreemptiveGC();

        if (!thread->m_pDLSHash)
        {
            thread->m_pDLSHash = new EEIntHashTable();
            if (!thread->m_pDLSHash)
            {
                ThreadStore::UnlockDLSHash();
                COMPlusThrowOM();
            }
            LockOwner lock = {g_pThreadStore->GetDLSHashCrst(),IsOwnerOfCrst};
            thread->m_pDLSHash->Init(3,&lock);
        }

        LocalDataStore *pLDS = ((LOCALDATASTOREREF) args->m_pLocalDataStore)->GetLocalDataStore();
        if (!pLDS)
        {
            pLDS = new LocalDataStore();
            if (!pLDS)
            {
                ThreadStore::UnlockDLSHash();
                COMPlusThrowOM();
            }

            StoreFirstObjectInHandle(pLDS->m_ExposedTypeObject, args->m_pLocalDataStore);
            ((LOCALDATASTOREREF) args->m_pLocalDataStore)->SetLocalDataStore(pLDS);
        }

        thread->m_pDLSHash->InsertValue(thread->GetDomain()->GetId(), (HashDatum) pLDS);
        ThreadStore::UnlockDLSHash();
    }
}


LPVOID __stdcall ThreadNative::GetDomain(LPVOID noargs)
{
    LPVOID rv = NULL;

    Thread* thread = GetThread();
    
    if ((thread) && (thread->GetDomain()))
        *((APPDOMAINREF*) &rv) = (APPDOMAINREF) thread->GetDomain()->GetExposedObject();

    return rv;
}

__declspec(naked) LPVOID __fastcall ThreadNative::FastGetDomain()
{
#ifdef _X86_
    __asm {
        call GetThread
        test eax, eax
        je exit
        mov eax, dword ptr [eax]Thread.m_pDomain
        test eax, eax
        je exit
        mov eax, dword ptr [eax]AppDomain.m_ExposedObject
        test eax, eax
        je exit
        mov eax, dword ptr [eax]
exit:
        ret
    }
#else
    return NULL;
#endif
}


// This is just a helper method that lets BCL get to the managed context
// from the contextID.
LPVOID __stdcall ThreadNative::GetContextFromContextID(
                          GetContextFromContextIDArgs *pArgs)
{   
    _ASSERTE(pArgs != NULL);
    LPVOID rv = NULL;
    Context *pCtx = (Context *)pArgs->m_ContextID;
    // Get the managed context backing this unmanaged context
    *((CONTEXTBASEREF*) &rv) = (CONTEXTBASEREF) pCtx->GetExposedObjectRaw();

    // This assert maintains the following invariant:
    // Only default unmanaged contexts can have a null managed context
    // (All non-deafult contexts are created as managed contexts first, and then
    // hooked to the unmanaged context)
    _ASSERTE((rv != NULL) || (pCtx->GetDomain()->GetDefaultContext() == pCtx));

    return rv;    
}

FCIMPL5(BOOL, ThreadNative::EnterContextFromContextID, ThreadBaseObject* refThis, ContextBaseObject* refContext, LPVOID contextID, INT32 appDomainId, ContextTransitionFrame* pFrame)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(refThis != NULL);
	VALIDATEOBJECTREF(refThis);
    Thread *pThread = refThis->GetInternal();   
    Context *pCtx = (Context *)contextID;


    _ASSERTE(pCtx && (refContext == NULL || pCtx->GetExposedObjectRaw() == NULL || 
             ObjectToOBJECTREF(refContext) == pCtx->GetExposedObjectRaw()));

    // set vptr for frame
    *(void**)(pFrame) = ContextTransitionFrame::GetMethodFrameVPtr();

    // If we have a non-zero appDomain index, this is a x-domain call
    // We must verify that the AppDomain is not unloaded
    if (appDomainId != 0)
    {
        //
        // NOTE: there is a potential race between the time we retrieve the app domain pointer,
        // and the time which this thread enters the domain.
        // 
        // To solve the race, we rely on the fact that there is a thread sync 
        // between releasing an app domain's handle, and destroying the app domain.  Thus
        // it is important that we not go into preemptive gc mode in that window.
        // 

        AppDomain* pAppDomain = SystemDomain::GetAppDomainAtId(appDomainId);

        if (pAppDomain == NULL && pThread == GCHeap::GetFinalizerThread())
            // check if the appdomain being unloaded has this ID so finalizer
            // thread might be allowed in
        {
            AppDomain *pUnloadingDomain = SystemDomain::System()->AppDomainBeingUnloaded();
            if (pUnloadingDomain && pUnloadingDomain->GetId())
                pAppDomain = pUnloadingDomain;
        }

        if (pAppDomain == NULL || !pAppDomain->CanThreadEnter(pThread))
            FCThrowRes(kAppDomainUnloadedException, L"Remoting_AppDomainUnloaded");
    }
    
    // Verify that the Context is valid. 
    if ( !Context::ValidateContext(pCtx) )
        FCThrowRes(kRemotingException, L"Remoting_InvalidContext");
    
    LOG((LF_APPDOMAIN, LL_INFO1000, "ThreadNative::EnterContextFromContextID: %8.8x, %8.8x pushing frame %8.8x\n", refContext, pCtx, pFrame));
    // install our frame. We have to put it here before we put the helper frame on
    pFrame->Push();
        ;
    // Set the VM conext

    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();
    pThread->EnterContextRestricted(pCtx, pFrame, FALSE);
    HELPER_METHOD_FRAME_END_POLL();
    return TRUE;
}
FCIMPLEND

FCIMPL2(BOOL, ThreadNative::ReturnToContextFromContextID, ThreadBaseObject* refThis, ContextTransitionFrame* pFrame)
{
    _ASSERTE(refThis != NULL);
	VALIDATEOBJECTREF(refThis);
    Thread *pThread = refThis->GetInternal();
    BOOL bRet = FALSE;

    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();
    // Reset the VM context
    pThread->ReturnToContext(pFrame, FALSE);
    HELPER_METHOD_FRAME_END_POLL();

#ifdef _DEBUG
    Context *pCtx = pFrame->GetReturnContext();
#endif

    LOG((LF_APPDOMAIN, LL_INFO1000, "ThreadNative::ReturnIntoContextFromContextID: %8.8x popping frame %8.8x\n", pCtx, pFrame));
    _ASSERTE(pThread->GetFrame() == pFrame);
    pFrame->Pop();
    _ASSERTE(Context::ValidateContext(pCtx));

    return TRUE;
}
FCIMPLEND

FCIMPL1(void, ThreadNative::InformThreadNameChange, ThreadBaseObject* thread)
{
	VALIDATEOBJECTREF(thread);
#ifdef DEBUGGING_SUPPORTED
    Thread *pThread = thread->GetInternal();
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    _ASSERTE(NULL != g_pDebugInterface);
    g_pDebugInterface->NameChangeEvent (NULL, pThread);
    HELPER_METHOD_FRAME_END_POLL();
#endif // DEBUGGING_SUPPORTED
}
FCIMPLEND

FCIMPL2(BOOL, ThreadNative::IsRunningInDomain, ThreadBaseObject* thread, int domainId)
{
	VALIDATEOBJECTREF(thread);
    Thread *pThread = thread->GetInternal();
    Frame *pFrame;
    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();
    AppDomain *pDomain = SystemDomain::GetAppDomainAtId(domainId);
    pFrame = pThread->IsRunningIn(pDomain, NULL);
    HELPER_METHOD_FRAME_END_POLL();
    return pFrame != NULL;
}
FCIMPLEND

FCIMPL1(BOOL, ThreadNative::IsThreadpoolThread, ThreadBaseObject* thread)
{
    Thread *pThread = thread->GetInternal();
	return pThread->IsThreadPoolThread() != FALSE;
}
FCIMPLEND


FCIMPL1(void, ThreadNative::SpinWait, int iterations)
{
	for(int i = 0; i < iterations; i++) 
		pause();
}
FCIMPLEND


void
ThreadNative::SetCompressedStack( SetCompressedStackArgs* args )
{
	VALIDATEOBJECTREF(args->m_pThis);
    Thread *pThread = args->m_pThis->GetInternal();
    if (args->unmanagedCompressedStack == NULL)
    {
        CompressedStack* stack = pThread->GetDelayedInheritedSecurityStack();
        if (stack != NULL)
            pThread->DeductSecurityInfo( stack->GetOverridesCount(), stack->GetAppDomainStack() );
    }
    else
    {
        pThread->AppendSecurityInfo( args->unmanagedCompressedStack->GetOverridesCount(), args->unmanagedCompressedStack->GetAppDomainStack() );
    }
    pThread->SetDelayedInheritedSecurityStack( args->unmanagedCompressedStack );
}

LPVOID
ThreadNative::GetCompressedStack( GetCompressedStackArgs* args )
{
	VALIDATEOBJECTREF(args->m_pThis);
    Thread *pThread = args->m_pThis->GetInternal();
    CompressedStack* stack = pThread->GetDelayedInheritedSecurityStack();
    if (stack != NULL)
        stack->AddRef();
    return stack;
}



static inline void MemoryBarrierImpl(void)
{
    // We use an InterlockedExchange to provide a memory barrier here.
    LONG dummy;
    InterlockedExchange(&dummy, 0);
}

FCIMPL0(void, ThreadNative::MemoryBarrier)
{
    MemoryBarrierImpl();
    FC_GC_POLL();
}
FCIMPLEND

FCIMPL1(unsigned char, ThreadNative::VolatileReadByte, unsigned char *address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    unsigned char tmp = *address;
    FC_GC_POLL_RET();
    return tmp;
}
FCIMPLEND

FCIMPL1(short, ThreadNative::VolatileReadShort, short *address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    short tmp = *address;
    FC_GC_POLL_RET();
    return tmp;
}
FCIMPLEND

FCIMPL1(int, ThreadNative::VolatileReadInt, int *address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    int tmp = *address;
    FC_GC_POLL_RET();
    return tmp;
}
FCIMPLEND

FCIMPL1(INT64, ThreadNative::VolatileReadLong, INT64 *address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    INT64 tmp = *address;
    FC_GC_POLL_RET();
    return tmp;
}
FCIMPLEND

FCIMPL1(Object *, ThreadNative::VolatileReadObjPtr, Object **address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    Object *pAddr = *address;
    FC_GC_POLL_AND_RETURN_OBJREF(pAddr);        
}
FCIMPLEND

FCIMPL1(void *, ThreadNative::VolatileReadPtr, void **address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    void *tmp = *address;
    FC_GC_POLL_RET();
    return tmp;
}
FCIMPLEND

FCIMPL1(float, ThreadNative::VolatileReadFloat, float *address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    float tmp = *address;
    FC_GC_POLL_RET();
    return tmp;
}
FCIMPLEND

FCIMPL1(double, ThreadNative::VolatileReadDouble, double *address)
{
    if (address == NULL)
        FCThrow(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    double tmp = *address;
    FC_GC_POLL_RET();
    return tmp;
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWriteByte, unsigned char *address, unsigned char value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.    
    *address = value;
    FC_GC_POLL();
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWriteShort, short *address, short value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    *address = value;
    FC_GC_POLL();
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWriteInt, int *address, int value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.    
    *address = value;
    FC_GC_POLL();
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWriteLong, INT64 *address, INT64 value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    *address = value;
    FC_GC_POLL();
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWritePtr, void **address, void *value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    *address = value;
    FC_GC_POLL();
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWriteObjPtr, Object **address, Object *value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.
    // Value is an objectref
    SetObjectReferenceUnchecked((OBJECTREF *)address, ObjectToOBJECTREF(value));            
    FC_GC_POLL();
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWriteFloat, float *address, float value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.        
    *address = value;
    FC_GC_POLL();    
}
FCIMPLEND

FCIMPL2(void, ThreadNative::VolatileWriteDouble, double *address, double value)
{
    if (address == NULL)
        FCThrowVoid(kNullReferenceException);
    
    MemoryBarrierImpl();  // Call MemoryBarrierImpl to ensure the proper semantic in a portable way.    
    *address = value;
    FC_GC_POLL();
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comtypelibconverter.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMTypeLibConverter.h
**
**
** Purpose: Definition of the native methods used by the 
**          typelib converter.
**
** 
===========================================================*/

#ifndef _COMTYPELIBCONVERTER_H
#define _COMTYPELIBCONVERTER_H

#include "vars.hpp"
#include "ecall.h"

struct ITypeLibImporterNotifySink;
class ImpTlbEventInfo;

enum TlbImporterFlags
{
    TlbImporter_PrimaryInteropAssembly      = 0x00000001,   // Generate a PIA.
    TlbImporter_UnsafeInterfaces            = 0x00000002,   // Generate unsafe interfaces.
    TlbImporter_SafeArrayAsSystemArray      = 0x00000004,   // Safe array import control.
    TlbImporter_TransformDispRetVals        = 0x00000008,   // Disp only itf [out, retval] transformation.
    TlbImporter_ValidFlags                  = TlbImporter_PrimaryInteropAssembly | 
                                              TlbImporter_UnsafeInterfaces | 
                                              TlbImporter_SafeArrayAsSystemArray |
                                              TlbImporter_TransformDispRetVals
};

enum TlbExporterFlags
{
    TlbExporter_OnlyReferenceRegistered     = 0x00000001,   // Only reference an external typelib if it is registered.
};

class COMTypeLibConverter
{
private:
    struct _ConvertAssemblyToTypeLib {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, NotifySink); 
        DECLARE_ECALL_I4_ARG(DWORD, Flags); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, TypeLibName); 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, Assembly); 
    };

    struct _ConvertTypeLibToMetadataArgs {
        DECLARE_ECALL_PTR_ARG(OBJECTREF *, pEventItfInfoList);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, NotifySink); 
        DECLARE_ECALL_I4_ARG(TlbImporterFlags, Flags); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, Namespace);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, ModBldr); 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, AsmBldr); 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, TypeLib); 
    };

public:
    static LPVOID   		ConvertAssemblyToTypeLib(_ConvertAssemblyToTypeLib *pArgs);
    static void				ConvertTypeLibToMetadata(_ConvertTypeLibToMetadataArgs *pArgs);

private:
	static void				Init();
    static void             GetEventItfInfoList(CImportTlb *pImporter, Assembly *pAssembly, OBJECTREF *pEventItfInfoList);
	static OBJECTREF		GetEventItfInfo(CImportTlb *pImporter, Assembly *pAssembly, ImpTlbEventInfo *pImpTlbEventInfo);
    static HRESULT          TypeLibImporterWrapper(ITypeLib *pITLB, LPCWSTR szFname, LPCWSTR szNamespace, IMetaDataEmit *pEmit, Assembly *pAssembly, Module *pModule, ITypeLibImporterNotifySink *pNotify, TlbImporterFlags flags, CImportTlb **ppImporter);

	static BOOL				m_bInitialized;
};

#endif  _COMTYPELIBCONVERTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsynchronizable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMSynchronizable.h
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Native methods on System.SynchronizableObject
**          and its subclasses.
**
** Date:  April 1, 1998
** 
===========================================================*/

#ifndef _COMSYNCHRONIZABLE_H
#define _COMSYNCHRONIZABLE_H

#include "field.h"          // For FieldDesc definition.

//
// Each function that we call through native only gets one argument,
// which is actually a pointer to its stack of arguments.  Our structs
// for accessing these are defined below.
//

struct SharedState;

class ThreadNative
{
friend class ThreadBaseObject;

    struct NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
    };

    struct StartArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, m_pStackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_pPrincipal);
    };

    struct SetPriorityArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
        DECLARE_ECALL_I4_ARG(INT32, m_iPriority);
    };

#pragma pack(push, 1)
    struct JoinTimeoutArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
        DECLARE_ECALL_I4_ARG(INT32, m_Timeout);
    };
#pragma pack(pop)

    struct SleepArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, m_iTime);
    };

    struct SetDLSArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_pLocalDataStore);
    };

    struct SetStartArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_pDelegate);
    };

    struct SetBackgroundArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
        DECLARE_ECALL_I4_ARG(INT32, m_isBackground);   // boolean, really
    };

    struct SetApartmentStateArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
        DECLARE_ECALL_I4_ARG(INT32, m_iState);
    };

    struct GetContextFromContextIDArgs
    {
        DECLARE_ECALL_I4_ARG(LPVOID, m_ContextID);
    };

    struct SetCompressedStackArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
        DECLARE_ECALL_PTR_ARG(CompressedStack*, unmanagedCompressedStack);
    };

    struct GetCompressedStackArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, m_pThis);
    };

public:

    enum
    {
        PRIORITY_LOWEST = 0,
        PRIORITY_BELOW_NORMAL = 1,
        PRIORITY_NORMAL = 2,
        PRIORITY_ABOVE_NORMAL = 3,
        PRIORITY_HIGHEST = 4,
    };

    enum
    {
        ThreadStopRequested = 1,
        ThreadSuspendRequested = 2,
        ThreadBackground = 4,
        ThreadUnstarted = 8,
        ThreadStopped = 16,
        ThreadWaitSleepJoin = 32,
        ThreadSuspended = 64,
        ThreadAbortRequested = 128,
        ThreadAborted = 256,
    };

    enum
    {
        ApartmentSTA = 0,
        ApartmentMTA = 1,
        ApartmentUnknown = 2
    };

    static FCDECL1(void, Abort, ThreadBaseObject* pThis);
    static FCDECL1(void, ResetAbort, ThreadBaseObject* pThis);
    static void __stdcall Start(StartArgs *);
    static void __stdcall Suspend(NoArgs *);
    static void __stdcall Resume(NoArgs *);
    static INT32 __stdcall GetPriority(NoArgs *);
    static void __stdcall SetPriority(SetPriorityArgs *);
    static void __stdcall Interrupt(NoArgs *);
    static INT32/*bool*/ __stdcall IsAlive(NoArgs *);
    static void __stdcall Join(NoArgs *);
    static INT32/*bool*/ __stdcall JoinTimeout(JoinTimeoutArgs *);
    static void __stdcall Sleep(SleepArgs *);
    static LPVOID __stdcall GetCurrentThread(LPVOID /*no args*/);
    static LPVOID __fastcall FastGetCurrentThread();
    static void __stdcall Finalize(NoArgs *);
    static LPVOID __stdcall GetDomainLocalStore(LPVOID /* no args */ );
    static void __stdcall SetDomainLocalStore(SetDLSArgs *);
    static void __stdcall SetStart(SetStartArgs *);
    static void __stdcall SetBackground(SetBackgroundArgs *);
    static INT32/*bool*/ __stdcall IsBackground(NoArgs *);
    static INT32 __stdcall GetThreadState(NoArgs *);
    static INT32 __stdcall GetThreadContext(NoArgs *);
    static INT32 __stdcall SetApartmentState(SetApartmentStateArgs *);
    static INT32 __stdcall GetApartmentState(NoArgs *);
    static LPVOID __stdcall GetDomain(const LPVOID /* no args */ );
    static LPVOID __fastcall FastGetDomain();
    static void __stdcall SetCompressedStack(SetCompressedStackArgs *);
    static LPVOID __stdcall GetCompressedStack(GetCompressedStackArgs *);
    
    static LPVOID __stdcall GetContextFromContextID(GetContextFromContextIDArgs *);
    static FCDECL5(BOOL, ThreadNative::EnterContextFromContextID, ThreadBaseObject* refThis, ContextBaseObject*, LPVOID contextID, INT32 appDomainIndex, ContextTransitionFrame* pFrame);
    static FCDECL2(BOOL, ThreadNative::ReturnToContextFromContextID, ThreadBaseObject* refThis, ContextTransitionFrame* pFrame);
    static FCDECL1(void, ThreadNative::InformThreadNameChange, ThreadBaseObject* thread);
    static FCDECL2(BOOL, ThreadNative::IsRunningInDomain, ThreadBaseObject* thread, int domainId);
    static FCDECL1(BOOL, ThreadNative::IsThreadpoolThread, ThreadBaseObject* thread);
    static FCDECL1(void, ThreadNative::SpinWait, int iterations);

    static FCDECL1(unsigned char, ThreadNative::VolatileReadByte, unsigned char *address);
    static FCDECL1(short, ThreadNative::VolatileReadShort, short *address);
    static FCDECL1(int, ThreadNative::VolatileReadInt, int *address);
    static FCDECL1(INT64, ThreadNative::VolatileReadLong, INT64 *address);
    static FCDECL1(void *, ThreadNative::VolatileReadPtr, void **address);
    static FCDECL1(Object *, ThreadNative::VolatileReadObjPtr, Object **address);
    static FCDECL1(float, ThreadNative::VolatileReadFloat, float *address);
    static FCDECL1(double, ThreadNative::VolatileReadDouble, double *address);
    
    static FCDECL2(void, ThreadNative::VolatileWriteByte, unsigned char *address, unsigned char value);
    static FCDECL2(void, ThreadNative::VolatileWriteShort, short *address, short value);
    static FCDECL2(void, ThreadNative::VolatileWriteInt, int *address, int value);
    static FCDECL2(void, ThreadNative::VolatileWriteLong, INT64 *address, INT64 value);
    static FCDECL2(void, ThreadNative::VolatileWritePtr, void **address, void *value);
    static FCDECL2(void, ThreadNative::VolatileWriteObjPtr, Object **address, Object *value);
    static FCDECL2(void, ThreadNative::VolatileWriteFloat, float *address, float value);
    static FCDECL2(void, ThreadNative::VolatileWriteDouble, double *address, double value);

    static FCDECL0(void, ThreadNative::MemoryBarrier);
    
public:
    static MethodTable* m_MT;
    static MethodDesc*  m_SetPrincipalMethod;
    static void __stdcall InitThread()
    {
        THROWSCOMPLUSEXCEPTION();
        if (m_MT == NULL) {
            m_MT = g_pThreadClass = g_Mscorlib.GetClass(CLASS__THREAD);
            m_SetPrincipalMethod = g_Mscorlib.GetMethod(METHOD__THREAD__SET_PRINCIPAL_INTERNAL);
        }
    }

private:

    struct KickOffThread_Args {
        Thread *pThread;
        SharedState *share;
        ULONG retVal;
    };

    static void __stdcall KickOffThread_Worker(KickOffThread_Args*);
    static ULONG __stdcall KickOffThread(void *pass);
    static BOOL DoJoin(THREADBASEREF DyingThread, INT32 timeout);
};


#endif _COMSYNCHRONIZABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comthreadpool.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMThreadPool.cpp
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.ThreadPool
**          and its inner classes
**
** Date:  August, 1999
** 
===========================================================*/

/********************************************************************************************************************/
#include "common.h"
#include "COMDelegate.h"
#include "COMThreadPool.h"
#include "Win32ThreadPool.h"
#include "class.h"
#include "object.h"
#include "field.h"
#include "ReflectWrap.h"
#include "excep.h"
#include "security.h"
#include "EEConfig.h"

/*****************************************************************************************************/
#ifdef _DEBUG
void LogCall(MethodDesc* pMD, LPCUTF8 api)
{
    LPCUTF8 cls  = pMD->GetClass() ? pMD->GetClass()->m_szDebugClassName
                                   : "GlobalFunction";
    LPCUTF8 name = pMD->GetName();

    LOG((LF_THREADPOOL,LL_INFO1000,"%s: ", api));
    LOG((LF_THREADPOOL, LL_INFO1000,
         " calling %s.%s\n", cls, name));
}
#else
#define LogCall(pMd,api) 
#endif

/*****************************************************************************************************/
DelegateInfo *DelegateInfo::MakeDelegateInfo(OBJECTREF delegate, 
                                             AppDomain *pAppDomain, 
                                             OBJECTREF state,
                                             OBJECTREF waitEvent,
                                             OBJECTREF registeredWaitHandle)
{
	THROWSCOMPLUSEXCEPTION();
    DelegateInfo* delegateInfo = (DelegateInfo*) ThreadpoolMgr::GetRecycledMemory(ThreadpoolMgr::MEMTYPE_DelegateInfo);
    _ASSERTE(delegateInfo);
	if (NULL == delegateInfo)
		COMPlusThrow(kOutOfMemoryException);
    delegateInfo->m_appDomainId = pAppDomain->GetId();

    delegateInfo->m_delegateHandle = pAppDomain->CreateHandle(NULL);
    StoreObjectInHandle(delegateInfo->m_delegateHandle, delegate);

    delegateInfo->m_stateHandle = pAppDomain->CreateHandle(NULL);
    StoreObjectInHandle(delegateInfo->m_stateHandle, state);

    delegateInfo->m_eventHandle = pAppDomain->CreateHandle(NULL);
    StoreObjectInHandle(delegateInfo->m_eventHandle, waitEvent);

    delegateInfo->m_registeredWaitHandle = pAppDomain->CreateHandle(NULL);
    StoreObjectInHandle(delegateInfo->m_registeredWaitHandle, registeredWaitHandle);

    delegateInfo->m_compressedStack = NULL;
    delegateInfo->m_overridesCount = 0;
    delegateInfo->m_hasSecurityInfo = FALSE;

    return delegateInfo;
}

/*****************************************************************************************************/
FCIMPL2(VOID, ThreadPoolNative::CorGetMaxThreads,DWORD* workerThreads, DWORD* completionPortThreads)
{
    ThreadpoolMgr::GetMaxThreads(workerThreads,completionPortThreads);
    return;
}
FCIMPLEND

/*****************************************************************************************************/
FCIMPL2(BOOL, ThreadPoolNative::CorSetMinThreads,DWORD workerThreads, DWORD completionPortThreads)
{
    return ThreadpoolMgr::SetMinThreads(workerThreads,completionPortThreads);
}
FCIMPLEND

/*****************************************************************************************************/
FCIMPL2(VOID, ThreadPoolNative::CorGetMinThreads,DWORD* workerThreads, DWORD* completionPortThreads)
{
    ThreadpoolMgr::GetMinThreads(workerThreads,completionPortThreads);
    return;
}
FCIMPLEND

/*****************************************************************************************************/
FCIMPL2(VOID, ThreadPoolNative::CorGetAvailableThreads,DWORD* workerThreads, DWORD* completionPortThreads)
{
    ThreadpoolMgr::GetAvailableThreads(workerThreads,completionPortThreads);
    return;
}
FCIMPLEND

/*****************************************************************************************************/

struct RegisterWaitForSingleObjectCallback_Args
{
    DelegateInfo *delegateInfo;
    BOOL TimerOrWaitFired;
};

void RegisterWaitForSingleObjectCallback_Worker(RegisterWaitForSingleObjectCallback_Args *args)
{
    Thread *pThread = GetThread();
    if ((args->delegateInfo)->m_hasSecurityInfo)
    {
        _ASSERTE( Security::IsSecurityOn() && "This block should only be called if security is on" );
        pThread->SetDelayedInheritedSecurityStack( (args->delegateInfo)->m_compressedStack );
        pThread->CarryOverSecurityInfo( (args->delegateInfo)->m_compressedStack->GetOverridesCount(), (args->delegateInfo)->m_compressedStack->GetAppDomainStack() );
        if (!(args->delegateInfo)->m_compressedStack->GetPLSOptimizationState())
            pThread->SetPLSOptimizationState( FALSE );
    }

    OBJECTREF orDelegate = ObjectFromHandle(((DelegateInfo*) args->delegateInfo)->m_delegateHandle);
    OBJECTREF orState = ObjectFromHandle(((DelegateInfo*) args->delegateInfo)->m_stateHandle);


    INT64 arg[3];

    MethodDesc *pMeth = ((DelegateEEClass*)(orDelegate->GetClass() ))->m_pInvokeMethod;
    _ASSERTE(pMeth);

    // Get the OR on which we are going to invoke the method and set it
    //  as the first parameter in arg above.
    unsigned short argIndex = 0;
    if (!pMeth->IsStatic())
        arg[argIndex++] = ObjToInt64(orDelegate);
    arg[argIndex++] = (INT64) args->TimerOrWaitFired;
    arg[argIndex++] = (INT64) OBJECTREFToObject(orState);

    // Call the method...

	LogCall(pMeth,"RWSOCallback");

    pMeth->Call(arg);
}

VOID RegisterWaitForSingleObjectCallback(PVOID delegateInfo,  BOOL TimerOrWaitFired)
{
    Thread* pThread = SetupThreadPoolThread(WorkerThread);
    _ASSERTE(pThread != NULL);
    _ASSERTE(pThread == GetThread());

    // This thread should not have any locks held at entry point.
    _ASSERTE(pThread->m_dwLockCount == 0);
    
    _ASSERTE(delegateInfo != NULL);
    _ASSERTE(((DelegateInfo*) delegateInfo)->m_delegateHandle != NULL);

    BEGIN_COOPERATIVE_GC(pThread);

    //
    // NOTE: there is a potential race between the time we retrieve the app domain pointer,
    // and the time which this thread enters the domain.
    // 
    // To solve the race, we rely on the fact that there is a thread sync (via GC)
    // between releasing an app domain's handle, and destroying the app domain.  Thus
    // it is important that we not go into preemptive gc mode in that window.
    // 

    AppDomain* appDomain = SystemDomain::GetAppDomainAtId(((DelegateInfo*) delegateInfo)->m_appDomainId);
    if (appDomain != NULL)
    {
        COMPLUS_TRYEX(pThread)
        {
            __try 
            {
                __try
                {
                    RegisterWaitForSingleObjectCallback_Args args = {(DelegateInfo*) delegateInfo, TimerOrWaitFired};
                    if (pThread->GetDomain() != appDomain)
				    {
                        pThread->DoADCallBack(appDomain->GetDefaultContext(), RegisterWaitForSingleObjectCallback_Worker, &args);
                    }
				    else
                        RegisterWaitForSingleObjectCallback_Worker(&args);
                }
                __except(ThreadBaseExceptionFilter(GetExceptionInformation(), pThread, ThreadPoolThread)) 
                {
                    _ASSERTE(!"ThreadBaseExceptionFilter returned EXCEPITON_EXECUTE_HANDLER");
                }
            }
            __finally
            {
                pThread->SetDelayedInheritedSecurityStack( NULL );
                pThread->ResetSecurityInfo();
                pThread->SetPLSOptimizationState( TRUE );
            }
        }
        COMPLUS_CATCH
        {
            // quietly swallow the exception
            if (pThread->IsAbortRequested())
                pThread->UserResetAbort();
        }
        COMPLUS_END_CATCH
    }

    END_COOPERATIVE_GC(pThread);


    // We should have released all locks.
    _ASSERTE(g_fEEShutDown || pThread->m_dwLockCount == 0);
}

void ThreadPoolNative::Init()
{

}

#ifdef SHOULD_WE_CLEANUP
void ThreadPoolNative::ShutDown()
{
	ThreadpoolMgr::Terminate();
}
#endif /* SHOULD_WE_CLEANUP */

LPVOID __stdcall ThreadPoolNative::CorRegisterWaitForSingleObject(RegisterWaitForSingleObjectsArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs != NULL);

    if(pArgs->waitObject == NULL || pArgs->delegate == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    _ASSERTE(pArgs->registeredWaitObject != NULL);

    ULONG flag = pArgs->executeOnlyOnce ? WAIT_SINGLE_EXECUTION | WAIT_FREE_CONTEXT : WAIT_FREE_CONTEXT;

    HANDLE hWaitHandle = ((WAITHANDLEREF)(OBJECTREFToObject(pArgs->waitObject)))->GetWaitHandle();
    _ASSERTE(hWaitHandle);

    Thread* pCurThread = GetThread();
    _ASSERTE( pCurThread);

    AppDomain* appDomain = pCurThread->GetDomain();
    _ASSERTE(appDomain);

    DelegateInfo* delegateInfo = DelegateInfo::MakeDelegateInfo(pArgs->delegate,
                                                                appDomain,
                                                                pArgs->state, 
                                                                pArgs->waitObject,
																pArgs->registeredWaitObject);
    
    if (Security::IsSecurityOn() && pArgs->compressStack)
    {
        delegateInfo->SetThreadSecurityInfo( GetThread(), pArgs->stackMark );
    }


    HANDLE handle;

    if (!(ThreadpoolMgr::RegisterWaitForSingleObject(&handle,
                                          hWaitHandle,
                                          RegisterWaitForSingleObjectCallback,
                                          (PVOID) delegateInfo,
                                          (ULONG) pArgs->timeout,
                                          flag)))
   
    {
        _ASSERTE(GetLastError() != ERROR_CALL_NOT_IMPLEMENTED);
        delegateInfo->Release();
        ThreadpoolMgr::RecycleMemory((LPVOID*)delegateInfo, ThreadpoolMgr::MEMTYPE_DelegateInfo);

        COMPlusThrowWin32();
    }

   return (LPVOID) handle;

}


/********************************************************************************************************************/

static void QueueUserWorkItemCallback_Worker(PVOID delegateInfo)
{
    Thread *pThread = GetThread();

    // This thread should not have any locks held at entry point.
    _ASSERTE(pThread->m_dwLockCount == 0);

    if (((DelegateInfo*)delegateInfo)->m_hasSecurityInfo)
    {
        _ASSERTE( Security::IsSecurityOn() && "This block should only be called if security is on" );
        pThread->SetDelayedInheritedSecurityStack( ((DelegateInfo*)delegateInfo)->m_compressedStack );
        pThread->CarryOverSecurityInfo( ((DelegateInfo*) delegateInfo)->m_compressedStack->GetOverridesCount(), ((DelegateInfo*) delegateInfo)->m_compressedStack->GetAppDomainStack() );
        if (!((DelegateInfo*) delegateInfo)->m_compressedStack->GetPLSOptimizationState())
            pThread->SetPLSOptimizationState( FALSE );
    }

    OBJECTREF orDelegate = ObjectFromHandle(((DelegateInfo*) delegateInfo)->m_delegateHandle);
    OBJECTREF orState = ObjectFromHandle(((DelegateInfo*) delegateInfo)->m_stateHandle);

    ((DelegateInfo*)delegateInfo)->Release();
    ThreadpoolMgr::RecycleMemory((LPVOID*)delegateInfo, ThreadpoolMgr::MEMTYPE_DelegateInfo);

    INT64 arg[2];

    MethodDesc *pMeth = ((DelegateEEClass*)(orDelegate->GetClass() ))->m_pInvokeMethod;
    _ASSERTE(pMeth);

    // Get the OR on which we are going to invoke the method and set it
    //  as the first parameter in arg above.
    if (pMeth->IsStatic())
    {
        arg[0] = (INT64) OBJECTREFToObject(orState);
    }
    else
    {
        arg[0] = ObjToInt64(orDelegate);
        arg[1] = (INT64) OBJECTREFToObject(orState);
    }

    // Call the method...
	LogCall(pMeth,"QUWICallback");

    pMeth->Call(arg);
}

DWORD WINAPI  QueueUserWorkItemCallback(PVOID delegateInfo)
{
    Thread* pThread = SetupThreadPoolThread(WorkerThread);
    _ASSERTE(pThread != NULL);
    _ASSERTE(pThread == GetThread());
    _ASSERTE(delegateInfo != NULL);

    BEGIN_COOPERATIVE_GC(pThread);
            
    //
    // NOTE: there is a potential race between the time we retrieve the app domain pointer,
    // and the time which this thread enters the domain.
    // 
    // To solve the race, we rely on the fact that there is a thread sync (via GC)
    // between releasing an app domain's handle, and destroying the app domain.  Thus
    // it is important that we not go into preemptive gc mode in that window.
    // 

    AppDomain* appDomain = SystemDomain::GetAppDomainAtId(((DelegateInfo*) delegateInfo)->m_appDomainId);
    if (appDomain != NULL)
    {
        COMPLUS_TRYEX(pThread)
        {
            __try
            {
                __try 
                {
                    if (appDomain != pThread->GetDomain())
				    {
                        pThread->DoADCallBack(appDomain->GetDefaultContext(), QueueUserWorkItemCallback_Worker, delegateInfo);                
                    }
				    else
                        QueueUserWorkItemCallback_Worker(delegateInfo);
                } 
                __except(ThreadBaseExceptionFilter(GetExceptionInformation(), pThread, ThreadPoolThread))
                {
                    _ASSERTE(!"ThreadBaseExceptionFilter returned EXCEPTION_EXECUTE_HANDLER");
                }
            }
            __finally
            {
                pThread->SetDelayedInheritedSecurityStack( NULL );
                pThread->ResetSecurityInfo();
                pThread->SetPLSOptimizationState( TRUE );
            }
        }
        COMPLUS_CATCH
        {
                // quietly swallow the exception
            if (pThread->IsAbortRequested())
                pThread->UserResetAbort();
        }
        COMPLUS_END_CATCH

    }    

    END_COOPERATIVE_GC(pThread);

    
    // We should have released all locks.
    _ASSERTE(g_fEEShutDown || pThread->m_dwLockCount == 0);

    return ERROR_SUCCESS;       // @TODO: This should set the AsyncResult value ?
}


void __stdcall ThreadPoolNative::CorQueueUserWorkItem(QueueUserWorkItemArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs != NULL);
    if (pArgs->delegate == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    Thread* pCurThread = GetThread();
    _ASSERTE( pCurThread);

    AppDomain* appDomain = pCurThread->GetDomain();
    _ASSERTE(appDomain);

    DelegateInfo* delegateInfo = DelegateInfo::MakeDelegateInfo(pArgs->delegate,
                                                                appDomain,
                                                                pArgs->state, 
                                                                FALSE);

    if (Security::IsSecurityOn() && pArgs->compressStack)
    {
        delegateInfo->SetThreadSecurityInfo( GetThread(), pArgs->stackMark );
    }

    BOOL res = ThreadpoolMgr::QueueUserWorkItem(QueueUserWorkItemCallback,
                                      (PVOID) delegateInfo,
                                                0);
    if (!res)
    {
        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            OBJECTREF pThrowable;
            CreateExceptionObject(kNotSupportedException,&pThrowable);
            COMPlusThrow(pThrowable);
        }
        else
            COMPlusThrowWin32();
    }
    return;

}


/********************************************************************************************************************/

BOOL __stdcall ThreadPoolNative::CorUnregisterWait(UnregisterWaitArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs != NULL);
    HANDLE hWait = (HANDLE) pArgs->WaitHandle;  
    HANDLE objectToNotify = pArgs->objectToNotify;

    BOOL bToggleGC = FALSE;
    Thread* pThread = GetThread();
    
    if (pThread)
    {
	bToggleGC = pThread->PreemptiveGCDisabled();
        if (bToggleGC)
           pThread->EnablePreemptiveGC ();
    }

    BOOL retval = ThreadpoolMgr::UnregisterWaitEx(hWait,objectToNotify);

    if (bToggleGC)
           pThread->DisablePreemptiveGC ();

    return retval;

}

/********************************************************************************************************************/
void __stdcall ThreadPoolNative::CorWaitHandleCleanupNative(WaitHandleCleanupArgs *pArgs) 
{
	_ASSERTE(pArgs);
	HANDLE hWait = (HANDLE)pArgs->WaitHandle;
	ThreadpoolMgr::WaitHandleCleanup(hWait);
	return;
}
/********************************************************************************************************************/

struct BindIoCompletion_Args
{
    DWORD ErrorCode;
    DWORD numBytesTransferred;
    LPOVERLAPPED lpOverlapped;
    BOOL setStack;
};

void __stdcall BindIoCompletionCallbackStubEx(DWORD ErrorCode, 
                                            DWORD numBytesTransferred, 
                                            LPOVERLAPPED lpOverlapped,
                                            BOOL setStack);

static void BindIoCompletion_Wrapper(BindIoCompletion_Args *args)
{
    BindIoCompletionCallbackStubEx(args->ErrorCode, args->numBytesTransferred, args->lpOverlapped, args->setStack);
}

// The actual delegate is available to us at the end of the OVERLAPPED structure
// The  
void __stdcall BindIoCompletionCallbackStub(DWORD ErrorCode, 
                                            DWORD numBytesTransferred, 
                                            LPOVERLAPPED lpOverlapped)
{
    BindIoCompletionCallbackStubEx(ErrorCode, numBytesTransferred, lpOverlapped, TRUE);
}

void __stdcall BindIoCompletionCallbackStubEx(DWORD ErrorCode, 
                                              DWORD numBytesTransferred, 
                                              LPOVERLAPPED lpOverlapped,
                                              BOOL setStack)
{
    Thread* pThread = SetupThreadPoolThread(CompletionPortThread);
    _ASSERTE(pThread != NULL);
    _ASSERTE(pThread == GetThread());

    // This thread should not have any locks held at entry point.
    _ASSERTE(pThread->m_dwLockCount == 0);
    
    LOG((LF_SLOP, LL_INFO10000, "In IO_CallBackStub thread 0x%x retCode 0x%x, overlap 0x%x\n",  pThread, ErrorCode, lpOverlapped));

    struct data
    {
        INT32            appDomainID;
        OBJECTHANDLE     delegateHandle;
        CompressedStack *compressedStack;
        OBJECTHANDLE     userHandle;
    };
    
    data *pData = (data *) (lpOverlapped+1);
    _ASSERTE(pData->delegateHandle != NULL);

    BEGIN_ENSURE_COOPERATIVE_GC();

    // NOTE: there is a potential race between the time we retrieve the app domain pointer,
    // and the time which this thread enters the domain.
    // 
    // To solve the race, we rely on the fact that there is a thread sync (via GC)
    // between releasing an app domain's handle, and destroying the app domain.  Thus
    // it is important that we not go into preemptive gc mode in that window.
    // 
    AppDomain *appDomain = SystemDomain::GetAppDomainAtId(pData->appDomainID);
    if (appDomain != NULL)
    {
        COMPLUS_TRYEX(pThread)
        {
            __try
            {
                __try 
                {
                    if (setStack && pData->compressedStack != NULL)
                    {
                        pThread->SetDelayedInheritedSecurityStack( pData->compressedStack );
                        pThread->CarryOverSecurityInfo( pData->compressedStack->GetOverridesCount(), pData->compressedStack->GetAppDomainStack() );
                        if (!pData->compressedStack->GetPLSOptimizationState())
                            pThread->SetPLSOptimizationState( FALSE );
                    }

                    if (appDomain != pThread->GetDomain())
                    {
                        BindIoCompletion_Args args = {ErrorCode, numBytesTransferred, lpOverlapped, FALSE};
                        pThread->DoADCallBack(appDomain->GetDefaultContext(), BindIoCompletion_Wrapper, &args);
                    }
                    else
                    {
                        OBJECTREF orDelegate = ObjectFromHandle(pData->delegateHandle);
        
                        INT64 arg[4];

                        MethodDesc *pMeth = ((DelegateEEClass*)(orDelegate->GetClass() ))->m_pInvokeMethod;
                        _ASSERTE(pMeth);

                        // Get the OR on which we are going to invoke the method and set it
                        //  as the first parameter in arg above.
                        unsigned short argIndex = 0;
                        if (!pMeth->IsStatic())
                            arg[argIndex++] = ObjToInt64(orDelegate);
                        arg[argIndex++] = (INT64) lpOverlapped;
                        arg[argIndex++] = (INT64) numBytesTransferred;
                        arg[argIndex++] = (INT64) ErrorCode;

                        // Call the method...
				        LogCall(pMeth,"IOCallback");

                        pMeth->Call(arg);
                    }
                }
                __except(ThreadBaseExceptionFilter(GetExceptionInformation(), pThread, ThreadPoolThread)) 
                {
                    _ASSERTE(!"ThreadBaseExceptionFilter returned EXCEPITON_EXECUTE_HANDLER");
                }
            }
            __finally
            {
                if (setStack)
                {
                    pThread->SetDelayedInheritedSecurityStack( NULL );
                    pThread->ResetSecurityInfo();
                    pThread->SetPLSOptimizationState( TRUE );
                }
            }

        }
        COMPLUS_CATCH
        {
            // quietly swallow the exception
            if (pThread->IsAbortRequested())
                pThread->UserResetAbort();
        }
        COMPLUS_END_CATCH

    }
    END_ENSURE_COOPERATIVE_GC();

    // We should have released all locks.
    _ASSERTE(g_fEEShutDown || pThread->m_dwLockCount == 0);

    LOG((LF_SLOP, LL_INFO10000, "Leaving IO_CallBackStub thread 0x%x retCode 0x%x, overlap 0x%x\n",  pThread, ErrorCode, lpOverlapped));
}

BOOL __stdcall ThreadPoolNative::CorBindIoCompletionCallback(BindIOCompletionCallbackArgs *pArgs)
{
#ifdef PLATFORM_CE   /* BindIOCompletionCallback is not supported on WinCE */
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pThrowable;
    CreateExceptionObject(kNotSupportedException,&pThrowable);
    COMPlusThrow(pThrowable);
    return FALSE;
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs != NULL);
    HANDLE hFile = (HANDLE) pArgs->fileHandle;

    BOOL res = ThreadpoolMgr::BindIoCompletionCallback(hFile,
                                           (LPOVERLAPPED_COMPLETION_ROUTINE)BindIoCompletionCallbackStub,
                                           0);     // reserved, must be 0
    if (!res)
    {
        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            OBJECTREF pThrowable;
            CreateExceptionObject(kPlatformNotSupportedException,&pThrowable);
            COMPlusThrow(pThrowable);
        }
        else
            COMPlusThrowWin32();
    }
    return res;
#endif // !PLATFORM_CE
}
/********************************************************************************************************************/

void __stdcall ThreadPoolNative::CorThreadPoolCleanup(LPVOID /*No Args*/)
{
    //ThreadPoolCleanup(0);  //This is not a WINAPI
}
/********************************************************************************************************************/


/******************************************************************************************/
/*                                                                                        */
/*                              Timer Functions                                           */
/*                                                                                        */
/******************************************************************************************/
struct AddTimerCallback_Args
{
    PVOID delegateInfo;
    BOOL TimerOrWaitFired;
    BOOL setStack;
};

VOID WINAPI AddTimerCallbackEx(PVOID delegateInfo, BOOL TimerOrWaitFired, BOOL setStack);

void AddTimerCallback_Wrapper(AddTimerCallback_Args *args)
{
    AddTimerCallbackEx(args->delegateInfo, args->TimerOrWaitFired, args->setStack );
}

VOID WINAPI AddTimerCallback(PVOID delegateInfo, BOOL TimerOrWaitFired)
{
    AddTimerCallbackEx( delegateInfo, TimerOrWaitFired, TRUE );
}

VOID WINAPI AddTimerCallbackEx(PVOID delegateInfo, BOOL TimerOrWaitFired, BOOL setStack)
{
    Thread* pThread = SetupThreadPoolThread(WorkerThread);
    _ASSERTE(pThread != NULL);
    _ASSERTE(pThread == GetThread());

    // This thread should not have any locks held at entry point.
    _ASSERTE(pThread->m_dwLockCount == 0);
    
    _ASSERTE(delegateInfo != NULL);
    _ASSERTE(((DelegateInfo*) delegateInfo)->m_delegateHandle != NULL);

    BEGIN_ENSURE_COOPERATIVE_GC(); 

            // NOTE: there is a potential race between the time we retrieve the app domain pointer,
            // and the time which this thread enters the domain.
            // 
    // To solve the race, we rely on the fact that there is a thread sync (via GC)
            // between releasing an app domain's handle, and destroying the app domain.  Thus
            // it is important that we not go into preemptive gc mode in that window.
            // 
    AppDomain *appDomain = SystemDomain::GetAppDomainAtId(((DelegateInfo*) delegateInfo)->m_appDomainId);
    if (appDomain != NULL)
    {
        COMPLUS_TRYEX(pThread)
        {
            __try
            {
                __try 
                {

                    if (setStack && ((DelegateInfo*)delegateInfo)->m_hasSecurityInfo)
                    {
                        _ASSERTE( Security::IsSecurityOn() && "This block should only be called if security is on" );
                        pThread->SetDelayedInheritedSecurityStack( ((DelegateInfo*)delegateInfo)->m_compressedStack );
                        pThread->CarryOverSecurityInfo( ((DelegateInfo*) delegateInfo)->m_compressedStack->GetOverridesCount(), ((DelegateInfo*) delegateInfo)->m_compressedStack->GetAppDomainStack() );
                        if (!((DelegateInfo*) delegateInfo)->m_compressedStack->GetPLSOptimizationState())
                            pThread->SetPLSOptimizationState( FALSE );
                    }

                    if (appDomain != pThread->GetDomain())
                    {
                        AddTimerCallback_Args args = {delegateInfo, TimerOrWaitFired, FALSE};
                        pThread->DoADCallBack(appDomain->GetDefaultContext(), AddTimerCallback_Wrapper, &args);
                    }
                    else
                    {
                        OBJECTREF orDelegate = ObjectFromHandle(((DelegateInfo*) delegateInfo)->m_delegateHandle);
                        OBJECTREF orState = ObjectFromHandle(((DelegateInfo*) delegateInfo)->m_stateHandle);

                        INT64 arg[3];


				        MethodDesc *pMeth = ((DelegateEEClass*)( orDelegate->GetClass() ))->m_pInvokeMethod;
                        _ASSERTE(pMeth);
                        arg[0] = ObjToInt64(orDelegate);
                        arg[1] = ObjToInt64(orState);

                        // Call the method...
                        LogCall(pMeth,"TimerCallback");

				        pMeth->Call(arg);
                    }
                }
                __except(ThreadBaseExceptionFilter(GetExceptionInformation(), pThread, ThreadPoolThread)) 
                {
                    _ASSERTE(!"ThreadBaseExceptionFilter returned EXCEPTION_EXECUTE_HANDLER");
                }
            }
            __finally
            {
                if (setStack)
                {
                    pThread->SetDelayedInheritedSecurityStack( NULL );
                    pThread->ResetSecurityInfo();
                    pThread->SetPLSOptimizationState( TRUE );
                }
            }
        }
        COMPLUS_CATCH
        {
            // quietly swallow the exception
            if (pThread->IsAbortRequested())
                pThread->UserResetAbort();
        }
        COMPLUS_END_CATCH
    }
    END_ENSURE_COOPERATIVE_GC(); 

    // We should have released all locks.
    _ASSERTE(g_fEEShutDown || pThread->m_dwLockCount == 0);

}

VOID __stdcall TimerNative::CorCreateTimer(AddTimerArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs != NULL);

    Thread* pCurThread = GetThread();
    _ASSERTE( pCurThread);

    AppDomain* appDomain = pCurThread->GetDomain();
    _ASSERTE(appDomain);

    DelegateInfo* delegateInfo = DelegateInfo::MakeDelegateInfo(pArgs->delegate,
                                                                appDomain,
                                                                pArgs->state);
    
    if (Security::IsSecurityOn())
    {
        delegateInfo->SetThreadSecurityInfo( GetThread(), pArgs->stackMark );
    }
   
    HANDLE hNewTimer;
    BOOL res = ThreadpoolMgr::CreateTimerQueueTimer(&hNewTimer,
                                     AddTimerCallback ,
                                     (PVOID) delegateInfo,
                                     (ULONG) pArgs->dueTime,
                                     (ULONG) pArgs->period,
                                     0
                                     );
    if (!res)
    {
        delegateInfo->Release();
        ThreadpoolMgr::RecycleMemory((LPVOID*)delegateInfo, ThreadpoolMgr::MEMTYPE_DelegateInfo);

        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            OBJECTREF pThrowable;
            CreateExceptionObject(kNotSupportedException,&pThrowable);
            COMPlusThrow(pThrowable);
        }
        else
            COMPlusThrowWin32();
    }
    pArgs->pThis->SetDelegateInfo(delegateInfo);
    pArgs->pThis->SetTimerHandle(hNewTimer);
    return;
              
}

/******************************************************************************************/

struct TimerDeleteInfo
{
    DelegateInfo*  delegateInfo;
    HANDLE         waitObjectHandle;		// handle of the registered wait that needs to be deleted
    HANDLE         notifyHandle;
    HANDLE         surrogateEvent;

    TimerDeleteInfo(DelegateInfo* dI, HANDLE nh, HANDLE se)
    {
        delegateInfo = dI;
		waitObjectHandle = NULL;
        notifyHandle = nh;
        surrogateEvent = se;
    }

    ~TimerDeleteInfo()
    {
        CloseHandle(surrogateEvent);

        if (delegateInfo != NULL)
        {
            delegateInfo->Release();
            ThreadpoolMgr::RecycleMemory((LPVOID*)delegateInfo, ThreadpoolMgr::MEMTYPE_DelegateInfo);
        }
		ThreadpoolMgr::UnregisterWaitEx(waitObjectHandle,NULL);
    }
}; 

VOID WINAPI TimerNative::timerDeleteWorkItem(PVOID parameters, BOOL ignored /* since this is wait infinite*/)
{
    TimerDeleteInfo* timerDeleteInfo = (TimerDeleteInfo*) parameters;

    if (timerDeleteInfo->notifyHandle != NULL)
        SetEvent((HANDLE)timerDeleteInfo->notifyHandle);

    delete timerDeleteInfo;
	
	return;
}

BOOL __stdcall TimerNative::CorDeleteTimer(DeleteTimerArgs *pArgs)
{

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(pArgs);
    if (pArgs->pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    HANDLE timerHandle = pArgs->pThis->GetTimerHandle();
    if (timerHandle == NULL)        // this can happen if an exception is thrown in the timer constructor
        return FALSE;               // and the finalizer thread calls this through dispose
        
    HANDLE ev = WszCreateEvent(NULL, // security attributes
                               TRUE, // manual event
                               FALSE, // initial state is not signalled
                               NULL); // no name
    _ASSERTE(ev);
    if (!ev) 
        COMPlusThrowWin32();

    LONG deleted = InterlockedExchange(pArgs->pThis->GetAddressTimerDeleted(),TRUE);
    if (deleted)   // someone beat us to it
    {
        CloseHandle(ev);
        return FALSE;   // an application error, so return false.
    }

    BOOL res1,res2;
    DWORD errorCode = 0;

    Thread* pThread = GetThread();
    BOOL bToggleGC = FALSE;
    if (pThread)
        bToggleGC = pThread->PreemptiveGCDisabled ();
    if (bToggleGC)
        pThread->EnablePreemptiveGC ();

    res1 = ThreadpoolMgr::DeleteTimerQueueTimer(timerHandle, ev);

    if (bToggleGC)
        pThread->DisablePreemptiveGC ();
    
    if (!res1)
        errorCode = ::GetLastError();   // capture the error code so we can throw the right exception

    // NOTE: We are assuming that the error code is benign and the timer is still going to get deleted...
    TimerDeleteInfo* timerDeleteInfo;
    timerDeleteInfo = new TimerDeleteInfo(pArgs->pThis->GetDelegateInfo(),
                                          pArgs->notifyObjectHandle,
                                          ev);
    _ASSERTE(timerDeleteInfo != NULL);

	res2 = ThreadpoolMgr::RegisterWaitForSingleObject(&(timerDeleteInfo->waitObjectHandle),
		                                              ev,
													  timerDeleteWorkItem,
													  (LPVOID) timerDeleteInfo,
													  INFINITE,
													  (WAIT_SINGLE_EXECUTION |  WT_EXECUTEDEFAULT));

    // .... however, we are still reporting the failure as an exception except for ERROR_IO_PENDING 
    if (!res1 && errorCode != ERROR_IO_PENDING)
    {
        ::SetLastError(errorCode);
        COMPlusThrowWin32();
    }
    else if (!res2)
    {
        COMPlusThrowWin32();
    }
    return TRUE;
}



/******************************************************************************************/

BOOL __stdcall TimerNative::CorChangeTimer(ChangeTimerArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs);
    _ASSERTE(pArgs->pThis);

    if (pArgs->pThis->IsTimerDeleted())   
        return FALSE;
    BOOL status = ThreadpoolMgr::ChangeTimerQueueTimer(
                                            pArgs->pThis->GetTimerHandle(),
                                            (ULONG)pArgs->dueTime,
                                            (ULONG)pArgs->period);

    if (!status)
    {
        COMPlusThrowWin32();
    }
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comsystem.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMSystem.cpp
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Native methods on System.Runtime
**
** Date:  March 30, 1998
**
===========================================================*/
#include "common.h"

#include <object.h>
#include <winnls.h>
#include "ceeload.h"

#include "utilcode.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "classNames.h"
#include "COMSystem.h"
#include "COMString.h"
#include "COMVariant.h"    // for Element type to class lookup table.
#include "COMMember.h" // for SigFormat
#include "SigFormat.h"
#include "__product__.ver"
#include "eeconfig.h"
#include "assemblynative.hpp"

typedef struct {
    BASEARRAYREF src;
    BASEARRAYREF dest;
    OBJECTREF obj;
} Protect2Arrays;

typedef struct {
    BASEARRAYREF src;
    BASEARRAYREF dest;
    OBJECTREF obj;
    OBJECTREF enumClass;
} Protect2ArraysAndEnum;


// The exit code for the process is communicated in one of two ways.  If the
// entrypoint returns an 'int' we take that.  Otherwise we take a latched
// process exit code.  This can be modified by the app via System.SetExitCode().
INT32 SystemNative::LatchedExitCode;

LPVOID GetArrayElementPtr(OBJECTREF a)
{
    ASSERT(a != NULL);

    _ASSERTE(a->GetMethodTable()->IsArray());

    return ((BASEARRAYREF)a)->GetDataPtr();
}

LPVOID GetArrayElementPtr(const BASEARRAYREF a)
{
    ASSERT(a != NULL);

    _ASSERTE(a->GetMethodTable()->IsArray());

    return a->GetDataPtr();
}

// Returns an enum saying whether you can copy an array of srcType into destType.
AssignArrayEnum SystemNative::CanAssignArrayType(const BASEARRAYREF pSrc, const BASEARRAYREF pDest)
{
    _ASSERTE(pSrc != NULL);
    _ASSERTE(pDest != NULL);

    TypeHandle srcTH = pSrc->GetElementTypeHandle();
    TypeHandle destTH = pDest->GetElementTypeHandle();
    EEClass * srcType = srcTH.GetClass();
    EEClass * destType = destTH.GetClass();

    const CorElementType srcElType = srcTH.GetSigCorElementType();
    const CorElementType destElType = destTH.GetSigCorElementType();
    _ASSERTE(srcElType < ELEMENT_TYPE_MAX);
    _ASSERTE(destElType < ELEMENT_TYPE_MAX);


    // The next 50 lines are a little tricky.  Change them with great care.
    // Make sure you run the ArrayCopy BVT when changing this.

    if (srcTH == destTH)
        return AssignWillWork;
    // Value class boxing
    if (srcType->IsValueClass() && !destType->IsValueClass()) {
        if (srcTH.CanCastTo(destTH))
            return AssignBoxValueClassOrPrimitive;
        else 
            return AssignWrongType;
    }
    // Value class unboxing.
    if (!srcType->IsValueClass() && destType->IsValueClass()) {
        if (srcTH.CanCastTo(destTH))
            return AssignUnboxValueClassAndCast;
        else if (destTH.CanCastTo(srcTH))   // V extends IV. Copying from IV to V, or Object to V.
            return AssignUnboxValueClassAndCast;
        else
            return AssignWrongType;
    }
    // Copying primitives from one type to another
    if (CorTypeInfo::IsPrimitiveType(srcElType) && CorTypeInfo::IsPrimitiveType(destElType)) {
        if (InvokeUtil::CanPrimitiveWiden(destElType, srcElType))
            return AssignPrimitiveWiden;
        else
            return AssignWrongType;
    }
    // dest Object extends src
    if (srcTH.CanCastTo(destTH))
        return AssignWillWork;
    // src Object extends dest
    if (destTH.CanCastTo(srcTH))
        return AssignMustCast;
    // class X extends/implements src and implements dest.
    if (destType->IsInterface() && srcElType != ELEMENT_TYPE_VALUETYPE)
        return AssignMustCast;
    // class X implements src and extends/implements dest
    if (srcType->IsInterface() && destElType != ELEMENT_TYPE_VALUETYPE)
        return AssignMustCast;
    // Enum is stored as a primitive of type dest.
    if (srcTH.IsEnum() && srcTH.GetNormCorElementType() == destElType)
        return AssignWillWork;
    return AssignWrongType;
}

// Casts and assigns each element of src array to the dest array type.
void SystemNative::CastCheckEachElement(const BASEARRAYREF pSrc, const unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, const unsigned int len)
{
    THROWSCOMPLUSEXCEPTION();

    // pSrc is either a PTRARRAYREF or a multidimensional array.
    _ASSERTE(pSrc!=NULL && srcIndex>=0 && pDest!=NULL && len>=0);
    TypeHandle destTH = pDest->GetElementTypeHandle();
    MethodTable * pDestMT = destTH.GetMethodTable();
    _ASSERTE(pDestMT);
    // Cache last cast test to speed up cast checks.
    MethodTable * pLastMT = NULL;

    const BOOL destIsArray = destTH.IsArray();
    Object** const array = (Object**) pSrc->GetDataPtr();
    OBJECTREF obj;
    for(unsigned int i=srcIndex; i<srcIndex + len; ++i) {
        obj = ObjectToOBJECTREF(array[i]);

        // Now that we have grabbed obj, we are no longer subject to races from another
        // mutator thread.
        if (!obj)
            goto assign;

        MethodTable * pMT = obj->GetTrueMethodTable();
        if (pMT == pLastMT || pMT == pDestMT)
            goto assign;

        pLastMT = pMT;
        // Handle whether these are interfaces or not.
        if (pDestMT->IsInterface()) {
            // Check for o implementing dest.
            InterfaceInfo_t * srcMap = pMT->GetInterfaceMap();
            unsigned int numInterfaces = pMT->GetNumInterfaces();
            for(unsigned int iInterfaces=0; iInterfaces<numInterfaces; iInterfaces++) {
                if (srcMap[iInterfaces].m_pMethodTable == pDestMT)
                    goto assign;
            }
            goto fail;
        }
        else if (destIsArray) {
            TypeHandle srcTH = obj->GetTypeHandle();
            if (!srcTH.CanCastTo(destTH))
                goto fail;
        } 
        else {
            while (pMT != NULL) {
                if (pMT == pDestMT)
                    goto assign;
                pMT = pMT->GetParentMethodTable();
            }
            goto fail;
        }
assign:
        // It is safe to assign obj
        OBJECTREF * destData = (OBJECTREF*)(pDest->GetDataPtr()) + i - srcIndex + destIndex;
        SetObjectReference(destData, obj, pDest->GetAppDomain());
    }
    return;

fail:
    COMPlusThrow(kInvalidCastException, L"InvalidCast_DownCastArrayElement");
}


// Will box each element in an array of value classes or primitives into an array of Objects.
void __stdcall SystemNative::BoxEachElement(BASEARRAYREF pSrc, unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, unsigned int length)
{
    THROWSCOMPLUSEXCEPTION();

    // pDest is either a PTRARRAYREF or a multidimensional array.
    _ASSERTE(pSrc!=NULL && srcIndex>=0 && pDest!=NULL && destIndex>=0 && length>=0);
    TypeHandle srcTH = pSrc->GetElementTypeHandle();
    TypeHandle destTH = pDest->GetElementTypeHandle();
    _ASSERTE(srcTH.GetSigCorElementType() == ELEMENT_TYPE_CLASS || srcTH.GetSigCorElementType() == ELEMENT_TYPE_VALUETYPE || CorTypeInfo::IsPrimitiveType(pSrc->GetElementType()));
    _ASSERTE(!destTH.GetClass()->IsValueClass());

    // Get method table of type we're copying from - we need to allocate objects of that type.
    MethodTable * pSrcMT = srcTH.GetMethodTable();

    if (!pSrcMT->IsClassInited())
    {
        OBJECTREF throwable = NULL;
        BASEARRAYREF pSrcTmp = pSrc;
        BASEARRAYREF pDestTmp = pDest;
        GCPROTECT_BEGIN (pSrcTmp);
        GCPROTECT_BEGIN (pDestTmp);
        if (!pSrcMT->CheckRunClassInit(&throwable))
            COMPlusThrow(throwable);
        pSrc = pSrcTmp;
        pDest = pDestTmp;
        GCPROTECT_END ();
        GCPROTECT_END ();
    }

    const unsigned int srcSize = pSrcMT->GetClass()->GetNumInstanceFieldBytes();
    unsigned int srcArrayOffset = srcIndex * srcSize;
    // Number of bytes in array header.
    const int destDataOffset = pDest->GetDataPtrOffset(pDest->GetMethodTable());

    Protect2Arrays prot;
    prot.src = pSrc;
    prot.dest = pDest;
    prot.obj = NULL;

    GCPROTECT_BEGIN(prot);
    for (unsigned int i=destIndex; i < destIndex+length; i++, srcArrayOffset += srcSize) {
        prot.obj = AllocateObject(pSrcMT);
        BYTE* data = (BYTE*)prot.src->GetDataPtr() + srcArrayOffset;
        CopyValueClass(prot.obj->UnBox(), data, pSrcMT, prot.obj->GetAppDomain());

        OBJECTREF * destData = (OBJECTREF*)((prot.dest)->GetDataPtr()) + i;
        SetObjectReference(destData, prot.obj, prot.dest->GetAppDomain());
    }
    GCPROTECT_END();
}


// Unboxes from an Object[] into a value class or primitive array.
void __stdcall SystemNative::UnBoxEachElement(BASEARRAYREF pSrc, unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, unsigned int length, BOOL castEachElement)
{
    THROWSCOMPLUSEXCEPTION();

    // pSrc is either a PTRARRAYREF or a multidimensional array.
    _ASSERTE(pSrc!=NULL && srcIndex>=0 && pDest!=NULL && destIndex>=0 && length>=0);
    TypeHandle srcTH = pSrc->GetElementTypeHandle();
    TypeHandle destTH = pDest->GetElementTypeHandle();
    _ASSERTE(destTH.GetSigCorElementType() == ELEMENT_TYPE_CLASS || destTH.GetSigCorElementType() == ELEMENT_TYPE_VALUETYPE || CorTypeInfo::IsPrimitiveType(pDest->GetElementType()));
    _ASSERTE(!srcTH.GetClass()->IsValueClass());

    MethodTable * pDestMT = destTH.GetMethodTable();

    const unsigned int destSize = pDestMT->GetClass()->GetNumInstanceFieldBytes();
    BYTE* srcData = (BYTE*) pSrc->GetDataPtr() + srcIndex * sizeof(OBJECTREF);
    BYTE* data = (BYTE*) pDest->GetDataPtr() + destIndex * destSize;

    for(; length>0; length--, srcData += sizeof(OBJECTREF), data += destSize) {
        OBJECTREF obj = ObjectToOBJECTREF(*(Object**)srcData);
        // Now that we have retrieved the element, we are no longer subject to race
        // conditions from another array mutator.
        if (castEachElement)
        {
            if (!obj)
                goto fail;

            MethodTable * pMT = obj->GetTrueMethodTable();

            while (pMT != pDestMT)
            {
                pMT = pMT->GetParentMethodTable();
                if (!pMT)
                    goto fail;
            }
        }
        CopyValueClass(data, obj->UnBox(), pDestMT, pDest->GetAppDomain());
    }
    return;

fail:
    COMPlusThrow(kInvalidCastException, L"InvalidCast_DownCastArrayElement");
}


// Widen primitive types to another primitive type.
void __stdcall SystemNative::PrimitiveWiden(BASEARRAYREF pSrc, unsigned int srcIndex, BASEARRAYREF pDest, unsigned int destIndex, unsigned int length)
{
    // Get appropriate sizes, which requires method tables.
    TypeHandle srcTH = pSrc->GetElementTypeHandle();
    TypeHandle destTH = pDest->GetElementTypeHandle();

    const CorElementType srcElType = srcTH.GetSigCorElementType();
    const CorElementType destElType = destTH.GetSigCorElementType();
    const unsigned int srcSize = GetSizeForCorElementType(srcElType);
    const unsigned int destSize = GetSizeForCorElementType(destElType);

    BYTE* srcData = (BYTE*) pSrc->GetDataPtr() + srcIndex * srcSize;
    BYTE* data = (BYTE*) pDest->GetDataPtr() + destIndex * destSize;

    _ASSERTE(srcElType != destElType);  // We shouldn't be here if these are the same type.
    _ASSERTE(CorTypeInfo::IsPrimitiveType(srcElType) && CorTypeInfo::IsPrimitiveType(destElType));

    for(; length>0; length--, srcData += srcSize, data += destSize) {
        // We pretty much have to do some fancy datatype mangling every time here, for
        // converting w/ sign extension and floating point conversions.
        switch (srcElType) {
        case ELEMENT_TYPE_U1:
            if (destElType==ELEMENT_TYPE_R4)
                *(float*)data = *(UINT8*)srcData;
            else if (destElType==ELEMENT_TYPE_R8)
                *(double*)data = *(UINT8*)srcData;
            else {
                *(UINT8*)data = *(UINT8*)srcData;
                // @TODO PORTING: Endianness issue here w/ my pointer arithmetic
                memset(data+1, 0, destSize - 1);
            }
            break;


        case ELEMENT_TYPE_I1:
            switch (destElType) {
            case ELEMENT_TYPE_I2:
                *(INT16*)data = *(INT8*)srcData;
                break;

            case ELEMENT_TYPE_I4:
                *(INT32*)data = *(INT8*)srcData;
                break;

            case ELEMENT_TYPE_I8:
                *(INT64*)data = *(INT8*)srcData;
                break;

            case ELEMENT_TYPE_R4:
                *(float*)data = *(INT8*)srcData;
                break;

            case ELEMENT_TYPE_R8:
                *(double*)data = *(INT8*)srcData;
                break;

            default:
                _ASSERTE(!"Array.Copy from I1 to another type hit unsupported widening conversion");
            }
            break;          


        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_CHAR:
            if (destElType==ELEMENT_TYPE_R4)
                *(float*)data = *(UINT16*)srcData;
            else if (destElType==ELEMENT_TYPE_R8)
                *(double*)data = *(UINT16*)srcData;
            else {
                *(UINT16*)data = *(UINT16*)srcData;
                // @TODO PORTING: Endianness issue here w/ my pointer arithmetic
                memset(data+2, 0, destSize - 2);
            }
            break;


        case ELEMENT_TYPE_I2:
            switch (destElType) {
            case ELEMENT_TYPE_I4:
                *(INT32*)data = *(INT16*)srcData;
                break;

            case ELEMENT_TYPE_I8:
                *(INT64*)data = *(INT16*)srcData;
                break;

            case ELEMENT_TYPE_R4:
                *(float*)data = *(INT16*)srcData;
                break;

            case ELEMENT_TYPE_R8:
                *(double*)data = *(INT16*)srcData;
                break;

            default:
                _ASSERTE(!"Array.Copy from I2 to another type hit unsupported widening conversion");
            }
            break;


        case ELEMENT_TYPE_I4:
            switch (destElType) {
            case ELEMENT_TYPE_I8:
                *(INT64*)data = *(INT32*)srcData;
                break;

            case ELEMENT_TYPE_R4:
                *(float*)data = (float)*(INT32*)srcData;
                break;

            case ELEMENT_TYPE_R8:
                *(double*)data = *(INT32*)srcData;
                break;

            default:
                _ASSERTE(!"Array.Copy from I4 to another type hit unsupported widening conversion");
            }
            break;
        

        case ELEMENT_TYPE_U4:
            switch (destElType) {
            case ELEMENT_TYPE_I8:
            case ELEMENT_TYPE_U8:
                *(INT64*)data = *(UINT32*)srcData;
                break;

            case ELEMENT_TYPE_R4:
                *(float*)data = (float)*(UINT32*)srcData;
                break;

            case ELEMENT_TYPE_R8:
                *(double*)data = *(UINT32*)srcData;
                break;

            default:
                _ASSERTE(!"Array.Copy from U4 to another type hit unsupported widening conversion");
            }
            break;


        case ELEMENT_TYPE_I8:
            if (destElType == ELEMENT_TYPE_R4)
                *(float*) data = (float) *(INT64*)srcData;
            else {
                _ASSERTE(destElType==ELEMENT_TYPE_R8);
                *(double*) data = (double) *(INT64*)srcData;
            }
            break;
            

        case ELEMENT_TYPE_U8:
            // VC6.0 didn't implement UINT64 to float or double.  How lame.
            if (destElType == ELEMENT_TYPE_R4) {
                //*(float*) data = (float) *(UINT64*)srcData;
                INT64 srcVal = *(INT64*)srcData;
                float f = (float) srcVal;
                if (srcVal < 0)
                    f += 4294967296.0f * 4294967296.0f; // This is 2^64
                *(float*) data = f;
            }
            else {
                _ASSERTE(destElType==ELEMENT_TYPE_R8);
                //*(double*) data = (double) *(UINT64*)srcData;
                INT64 srcVal = *(INT64*)srcData;
                double d = (double) srcVal;
                if (srcVal < 0)
                    d += 4294967296.0 * 4294967296.0;   // This is 2^64
                *(double*) data = d;
            }
            break;


        case ELEMENT_TYPE_R4:
            *(double*) data = *(float*)srcData;
            break;
            
        default:
            _ASSERTE(!"Fell through outer switch in PrimitiveWiden!  Unknown primitive type for source array!");
        }
    }
}

//This is a replacement for the memmove intrinsic.
//It performs better than the CRT one and the inline version
void m_memmove(BYTE* dmem, BYTE* smem, int size)
{
    if (dmem <= smem)
    {
        // make sure the destination is dword aligned
        while ((((size_t)dmem ) & 0x3) != 0 && size >= 3)
        {
            *dmem++ = *smem++;
            size -= 1;
        }

        // copy 16 bytes at a time
        if (size >= 16)
        {
            size -= 16;
            do
            {
                ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
                ((DWORD *)dmem)[1] = ((DWORD *)smem)[1];
                ((DWORD *)dmem)[2] = ((DWORD *)smem)[2];
                ((DWORD *)dmem)[3] = ((DWORD *)smem)[3];
                dmem += 16;
                smem += 16;
            }
            while ((size -= 16) >= 0);
        }

        // still 8 bytes or more left to copy?
        if (size & 8)
        {
            ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
            ((DWORD *)dmem)[1] = ((DWORD *)smem)[1];
            dmem += 8;
            smem += 8;
        }

        // still 4 bytes or more left to copy?
        if (size & 4)
        {
            ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
            dmem += 4;
            smem += 4;
        }

        // still 2 bytes or more left to copy?
        if (size & 2)
        {
            ((WORD *)dmem)[0] = ((WORD *)smem)[0];
            dmem += 2;
            smem += 2;
        }

        // still 1 byte left to copy?
        if (size & 1)
        {
            dmem[0] = smem[0];
            dmem += 1;
            smem += 1;
        }
    }
    else
    {
        smem += size;
        dmem += size;

        // make sure the destination is dword aligned
        while ((((size_t)dmem) & 0x3) != 0 && size >= 3)
        {
            *--dmem = *--smem;
            size -= 1;
        }

        // copy 16 bytes at a time
        if (size >= 16)
        {
            size -= 16;
            do
            {
                dmem -= 16;
                smem -= 16;
                ((DWORD *)dmem)[3] = ((DWORD *)smem)[3];
                ((DWORD *)dmem)[2] = ((DWORD *)smem)[2];
                ((DWORD *)dmem)[1] = ((DWORD *)smem)[1];
                ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
            }
            while ((size -= 16) >= 0);
        }

        // still 8 bytes or more left to copy?
        if (size & 8)
        {
            dmem -= 8;
            smem -= 8;
            ((DWORD *)dmem)[1] = ((DWORD *)smem)[1];
            ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
        }

        // still 4 bytes or more left to copy?
        if (size & 4)
        {
            dmem -= 4;
            smem -= 4;
            ((DWORD *)dmem)[0] = ((DWORD *)smem)[0];
        }

        // still 2 bytes or more left to copy?
        if (size & 2)
        {
            dmem -= 2;
            smem -= 2;
            ((WORD *)dmem)[0] = ((WORD *)smem)[0];
        }

        // still 1 byte left to copy?
        if (size & 1)
        {
            dmem -= 1;
            smem -= 1;
            dmem[0] = smem[0];
        }
    }
}


void __stdcall SystemNative::ArrayCopy(const ArrayCopyArgs *pargs)
{
    BYTE *src;
    BYTE *dst;
    int  size;
    
    ASSERT(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();

    BASEARRAYREF pSrc = pargs->m_pSrc;
    BASEARRAYREF pDst = pargs->m_pDst;

    // cannot pass null for source or destination
    if (pSrc == NULL || pDst == NULL) {
        COMPlusThrowArgumentNull((pSrc==NULL ? L"source" : L"dest"), L"ArgumentNull_Array");
    }

    // source and destination must be arrays
    _ASSERTE(pSrc->GetMethodTable()->IsArray());
    _ASSERTE(pDst->GetMethodTable()->IsArray());

    if (pSrc->GetRank() != pDst->GetRank())
        COMPlusThrow(kRankException, L"Rank_MustMatch");

    // Variant is dead.
    _ASSERTE(pSrc->GetMethodTable()->GetClass() != COMVariant::s_pVariantClass);
    _ASSERTE(pDst->GetMethodTable()->GetClass() != COMVariant::s_pVariantClass);

    BOOL castEachElement = false;
    BOOL boxEachElement = false;
    BOOL unboxEachElement = false;
    BOOL primitiveWiden = false;

    int r;
    // Small perf optimization - we copy from one portion of an array back to
    // itself a lot when resizing collections, etc.  The cost of doing the type
    // checking is significant for copying small numbers of bytes (~half of the time
    // for copying 1 byte within one array from element 0 to element 1).
    if (pSrc == pDst)
        r = AssignWillWork;
    else
        r = CanAssignArrayType(pSrc, pDst);

    switch (r) {
    case AssignWrongType:
        COMPlusThrow(kArrayTypeMismatchException, L"ArrayTypeMismatch_CantAssignType");
        break;
        
    case AssignMustCast:
        castEachElement = true;
        break;
        
    case AssignWillWork:
        break;
        
    case AssignBoxValueClassOrPrimitive:
        boxEachElement = true;
        break;
        
    case AssignUnboxValueClassAndCast:
        castEachElement = true;
        unboxEachElement = true;
        break;
        
    case AssignPrimitiveWiden:
        primitiveWiden = true;
        break;

    default:
        _ASSERTE(!"Fell through switch in Array.Copy!");
    }

    // array bounds checking
    const unsigned int srcLen = pSrc->GetNumComponents();
    const unsigned int destLen = pDst->GetNumComponents();
    if (pargs->m_iLength < 0) {
        COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_NeedNonNegNum");
    }

    // Verify start indexes are non-negative.  Then do a sufficiency check.
    // We want to allow copying for 0 bytes into an array, and are flexible
    // in terms of checking the starting index when copying 0 bytes.
    int srcLB = pSrc->GetLowerBoundsPtr()[0];
    int destLB = pDst->GetLowerBoundsPtr()[0];
    if (pargs->m_iSrcIndex < srcLB || (pargs->m_iSrcIndex - srcLB < 0))
        COMPlusThrowArgumentOutOfRange(L"srcIndex", L"ArgumentOutOfRange_ArrayLB");
    if (pargs->m_iDstIndex < destLB || (pargs->m_iDstIndex - destLB < 0))
        COMPlusThrowArgumentOutOfRange(L"dstIndex", L"ArgumentOutOfRange_ArrayLB");
    if ((DWORD)(pargs->m_iSrcIndex - srcLB + pargs->m_iLength) > srcLen) {
        COMPlusThrow(kArgumentException, L"Arg_LongerThanSrcArray");
    }
    if ((DWORD)(pargs->m_iDstIndex - destLB + pargs->m_iLength) > destLen) {
        COMPlusThrow(kArgumentException, L"Arg_LongerThanDestArray");
    }

    if (pargs->m_iLength > 0) {
        // Casting and boxing are mutually exclusive.  But casting and unboxing may
        // coincide -- they are handled in the UnboxEachElement service.
        _ASSERTE(!boxEachElement || !castEachElement);
        if (unboxEachElement) {
            UnBoxEachElement(pSrc, pargs->m_iSrcIndex - srcLB, pDst, pargs->m_iDstIndex - destLB, pargs->m_iLength, castEachElement);
        }
        else if (boxEachElement) {
            BoxEachElement(pSrc, pargs->m_iSrcIndex - srcLB, pDst, pargs->m_iDstIndex - destLB, pargs->m_iLength);
        }
        else if (castEachElement) {
            _ASSERTE(!unboxEachElement);   // handled above
            CastCheckEachElement(pSrc, pargs->m_iSrcIndex - srcLB, pDst, pargs->m_iDstIndex - destLB, pargs->m_iLength);
        }
        else if (primitiveWiden) {
            PrimitiveWiden(pSrc, pargs->m_iSrcIndex - srcLB, pDst, pargs->m_iDstIndex - destLB, pargs->m_iLength);
        }
        else {
            src = (BYTE*)GetArrayElementPtr(pSrc);
            dst = (BYTE*)GetArrayElementPtr(pDst);
            size = pSrc->GetMethodTable()->GetComponentSize();
            m_memmove(dst + ((pargs->m_iDstIndex - destLB) * size), src + ((pargs->m_iSrcIndex - srcLB) * size), pargs->m_iLength * size);
            if (pDst->GetMethodTable()->ContainsPointers())
            {
                SetCardsAfterBulkCopy( (Object**) (dst + (pargs->m_iDstIndex * size)), pargs->m_iLength * size);
            }
        }
    }
}


void __stdcall SystemNative::ArrayClear(const ArrayClearArgs *pargs)
{
    ASSERT(pargs != NULL);

    THROWSCOMPLUSEXCEPTION();

    BASEARRAYREF pArray = pargs->m_pArray;

    // cannot pass null for array
    if (pArray == NULL) {
        COMPlusThrowArgumentNull(L"array", L"ArgumentNull_Array");
    }

    // array must be an array
    _ASSERTE(pArray->GetMethodTable()->IsArray());

    // array bounds checking
    int lb = pArray->GetLowerBoundsPtr()[0];
    if (pargs->m_iIndex < lb || (pargs->m_iIndex - lb) < 0 || pargs->m_iLength < 0) {
        COMPlusThrow(kIndexOutOfRangeException);
    }
    if ((pargs->m_iIndex - lb) > (int)pArray->GetNumComponents() - pargs->m_iLength) {
        COMPlusThrow(kIndexOutOfRangeException);
    }

    if (pargs->m_iLength > 0) {
        char* array = (char*)GetArrayElementPtr(pArray);

        int size = pArray->GetMethodTable()->GetComponentSize();
        ASSERT(size >= 1);

        ZeroMemory(array + (pargs->m_iIndex - lb) * size, pargs->m_iLength * size);
    }
}


/*===========================GetEmptyArrayForCloning============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall SystemNative::GetEmptyArrayForCloning(_getEmptyArrayForCloningArgs *args) {
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    if (args->inArray==NULL) {
        COMPlusThrowArgumentNull(L"inArray");
    }
    
    BASEARRAYREF outArray = (BASEARRAYREF)DupArrayForCloning(args->inArray);

    RETURN(outArray,BASEARRAYREF)
}

FCIMPL0(UINT32, SystemNative::GetTickCount)
    return ::GetTickCount();
FCIMPLEND


FCIMPL0(INT64, SystemNative::GetWorkingSet)
    DWORD memUsage = WszGetWorkingSet();
    return memUsage;
FCIMPLEND


void __stdcall SystemNative::Exit(ExitArgs *pargs)
{
    static LONG OneShot = 0;

    ASSERT(pargs != NULL);

    // The exit code for the process is communicated in one of two ways.  If the
    // entrypoint returns an 'int' we take that.  Otherwise we take a latched
    // process exit code.  This can be modified by the app via System.SetExitCode().
    SystemNative::LatchedExitCode = pargs->m_iExitCode;

    ForceEEShutdown();
}

void __stdcall SystemNative::SetExitCode(ExitArgs *pargs)
{
    ASSERT(pargs != NULL);

    // The exit code for the process is communicated in one of two ways.  If the
    // entrypoint returns an 'int' we take that.  Otherwise we take a latched
    // process exit code.  This can be modified by the app via System.SetExitCode().
    SystemNative::LatchedExitCode = pargs->m_iExitCode;
}

int __stdcall SystemNative::GetExitCode(LPVOID noArgs)
{
    // Return whatever has been latched so far.  This is uninitialized to 0.
    return SystemNative::LatchedExitCode;
}


LPVOID SystemNative::GetCommandLineArgs(LPVOID noargs)
{
    THROWSCOMPLUSEXCEPTION();
    LPWSTR commandLine = WszGetCommandLine();
    if (commandLine==NULL)
        COMPlusThrowOM();

    DWORD numArgs = 0;
    LPWSTR* argv = SegmentCommandLine(commandLine, &numArgs);
    _ASSERTE(argv != NULL);

#if !defined(PLATFORM_CE) && defined(_X86_)
    //
    // In WinWrap.h, we #define WszGetCommandLine to be GetCommandLineW for WinCE or
    // non-X86 platforms, which means that the memory pointed to by the returned 
    // pointer WAS NOT ALLOCATED BY US.  As a result, we should only be deleting 
    // it on non-CE X86.  
    //
    delete[] commandLine;
#endif  // !defined(PLATFORM_CE) && defined(_X86_)

#ifndef PLATFORM_CE
    _ASSERTE(numArgs > 0);   // No argv[0] on WinCE.
#endif
    PTRARRAYREF strArray = (PTRARRAYREF) AllocateObjectArray(numArgs, g_pStringClass);
    // Copy each argument into new Strings.
    GCPROTECT_BEGIN(strArray);
    for(unsigned int i=0; i<numArgs; i++) {
        STRINGREF str = COMString::NewString(argv[i]);
        STRINGREF * destData = ((STRINGREF*)(strArray->GetDataPtr())) + i;
        SetObjectReference((OBJECTREF*)destData, (OBJECTREF)str, strArray->GetAppDomain());
    }
    GCPROTECT_END();
    delete [] argv;
    RETURN(strArray, PTRARRAYREF);
}

// Note: Arguments checked in IL.
LPVOID __stdcall SystemNative::GetEnvironmentVariable(GetEnvironmentVariableArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT(pargs != NULL);

    STRINGREF value;

#ifdef PLATFORM_CE
    // This function is not supported on WinCE
    value = NULL;
#else // !PLATFORM_CE
    //Ensure that the class initializer has actually run.
    //This is a no-op if the initializer has been run before.
    OBJECTREF Throwable;
    if (!g_pStringClass->CheckRunClassInit(&Throwable))
        COMPlusThrow(Throwable);


    // Get the length of the environment variable.
    int len = WszGetEnvironmentVariable(pargs->m_strVar->GetBuffer(), NULL, 0);
    if (len == 0)
        value = NULL;
    else
    {
        // Allocate the string.
        value = COMString::NewString(len);

        // Get the value and reset the length (in case it changed).
        len = WszGetEnvironmentVariable(pargs->m_strVar->GetBuffer(), value->GetBuffer(), len);
        value->SetStringLength(len);
    }
#endif // !PLATFORM_CE
    RETURN(value, STRINGREF);
}

LPVOID SystemNative::GetEnvironmentCharArray(const void* /*no args*/)
{
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
    return NULL;
#else // !PLATFORM_CE
    WCHAR * strings = WszGetEnvironmentStrings();
    // Format for GetEnvironmentStrings is:
    // [=HiddenVar=value\0]* [Variable=value\0]* \0
    // See the description of Environment Blocks in MSDN's
    // CreateProcess page (null-terminated array of null-terminated strings).

    // Search for terminating \0\0 (two unicode \0's).
    WCHAR* ptr=strings;
    while (!(*ptr==0 && *(ptr+1)==0))
        ptr++;

    int len = (int)(ptr - strings + 1);

    CHARARRAYREF chars = (CHARARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_CHAR,len);
    WCHAR * buf = (WCHAR*) chars->GetDataPtr();
    memcpyNoGCRefs(buf, strings, len*sizeof(WCHAR));
    WszFreeEnvironmentStrings(strings);
    RETURN(chars, CHARARRAYREF);
#endif // !PLATFORM_CE
}


LPVOID __stdcall SystemNative::GetVersionString(LPVOID /*no args*/)
{
    STRINGREF s = COMString::NewString(VER_PRODUCTVERSION_WSTR);
    RETURN(s, STRINGREF);
}


// CaptureStackTraceMethod
// Return a method info for the method were the exception was thrown
LPVOID __stdcall SystemNative::CaptureStackTraceMethod(CaptureStackTraceMethodArgs* args)
{
    if (!args->m_pStackTrace)
        return NULL;

    // Skip any JIT helpers...
    
    // @todo: where did this class go?
    // MethodTable *pJithelperClass = g_Mscorlib.GetClass(CLASS__JIT_HELPERS);
    MethodTable *pJithelperClass = NULL;

    BASEARRAYREF pArray = args->m_pStackTrace;

    StackTraceElement *pElements = (StackTraceElement*)pArray->GetDataPtr();
    _ASSERTE(pElements || ! pArray->GetNumComponents());

    // array is allocated as stream of chars, so need to calculate real number of elems
    int numComponents = pArray->GetNumComponents()/sizeof(pElements[0]);
    MethodDesc* pMeth = NULL;
    for (int i=0; i < numComponents; i++) {

        pMeth= pElements[i].pFunc;
        _ASSERTE(pMeth);

        // Skip Jit Helper functions, since they can throw when you have
        // a bug in your code, such as an invalid cast.
        if (pMeth->GetMethodTable() == pJithelperClass)
            continue;

        break;
    }

    // Convert the method into a MethodInfo...
    OBJECTREF o = COMMember::g_pInvokeUtil->GetMethodInfo(pMeth);
    LPVOID          rv;
    *((OBJECTREF*) &rv) = o;
    return rv;
}

OBJECTREF SystemNative::CaptureStackTrace(Frame *pStartFrame, void* pStopStack, CaptureStackTraceData *pData)
{
    THROWSCOMPLUSEXCEPTION();

    CaptureStackTraceData localData;
    if (! pData) {
        pData = &localData;
    }
    pData->cElements = 0;
    pData->cElementsAllocated = 20;
    pData->pElements = new (throws) StackTraceElement[pData->cElementsAllocated];
    pData->pStopStack = pStopStack;
    GetThread()->StackWalkFrames(CaptureStackTraceCallback, pData, FUNCTIONSONLY, pStartFrame);
    if (! pData->cElements) {
        delete [] pData->pElements;
        return NULL;
    }

    // need to return this now as array of integers
    OBJECTREF arr = AllocatePrimitiveArray(ELEMENT_TYPE_I1, pData->cElements*sizeof(pData->pElements[0]));
    if (! arr) {
        delete [] pData->pElements;
        COMPlusThrowOM();
    }

    I1 *pI1 = (I1 *)((I4ARRAYREF)arr)->GetDirectPointerToNonObjectElements();
    memcpyNoGCRefs(pI1, pData->pElements, pData->cElements * sizeof(pData->pElements[0]));
    delete [] pData->pElements;
    return arr;
}

StackWalkAction SystemNative::CaptureStackTraceCallback(CrawlFrame* pCf, VOID* data)
{
    CaptureStackTraceData* pData = (CaptureStackTraceData*)data;

    if (pData->skip > 0) {
        pData->skip--;
        return SWA_CONTINUE;
    }

    //        How do we know what kind of frame we have?
    //        Can we always assume FramedMethodFrame?
    //        NOT AT ALL!!!, but we can assume it's a function
    //                       because we asked the stackwalker for it!
    MethodDesc* pFunc = pCf->GetFunction();

    if (pData->cElements >= pData->cElementsAllocated) {
        StackTraceElement* pTemp = new (nothrow) StackTraceElement[2*pData->cElementsAllocated];
        if (pTemp == NULL)
            return SWA_ABORT;
        memcpy(pTemp, pData->pElements, pData->cElementsAllocated * sizeof(StackTraceElement));
        delete [] pData->pElements;
        pData->pElements = pTemp;
        pData->cElementsAllocated *= 2;
    }    
    pData->pElements[pData->cElements].pFunc = pCf->GetFunction();
    if (pCf->IsFrameless())
        pData->pElements[pData->cElements].ip = *(pCf->GetRegisterSet()->pPC);
    else
        pData->pElements[pData->cElements].ip = (SLOT)((FramedMethodFrame*)(pCf->GetFrame()))->GetIP();
    ++pData->cElements;

    if (pCf->IsFrameless() && pCf->GetCodeManager() && 
            pData->pStopStack <= GetRegdisplaySP(pCf->GetRegisterSet()))  {
        // pStopStack only applies to jitted code
        // in general should always find an exact match against stack value, so assert if didn't
        _ASSERTE(pData->pStopStack == GetRegdisplaySP(pCf->GetRegisterSet()));
        return SWA_ABORT;
    }

    return SWA_CONTINUE;
}

static void CheckBufferSize(LPUTF8 &sz, int &cchAllocated, int cchNew)
{
    THROWSCOMPLUSEXCEPTION();

    // make sure there's enough room in the string buffer to hold the name
    if (cchNew > cchAllocated) {
        // at least double size
        if (cchNew < cchAllocated * 2) {
            cchNew = cchAllocated * 2;
        }
        LPUTF8 szNew = new (throws) CHAR[cchNew];
        memcpy(szNew, sz, cchAllocated);
        delete [] sz;
        sz = szNew;
        cchAllocated = cchNew;
    }
    
}

LPUTF8 SystemNative::FormatStackTraceInternal(DumpStackTraceInternalArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    int cchAllocated = 200;
    int cch = 0;
    LPUTF8 sz = new (throws) CHAR[cchAllocated];
    *sz = '\0';

    // @todo: where did this class go?
    // MethodTable *pJithelperClass = g_Mscorlib.GetClass(CLASS__JIT_HELPERS);
    MethodTable *pJithelperClass = NULL;

    BASEARRAYREF pArray = args->m_pStackTrace;

    StackTraceElement *pElements = (StackTraceElement*)pArray->GetDataPtr();
    _ASSERTE(pElements || ! pArray->GetNumComponents());

    // array is allocated as stream of chars, so need to calculate real number of elems
    int numComponents = pArray->GetNumComponents()/sizeof(pElements[0]);
    GCPROTECT_BEGININTERIOR (pElements);
    for (int i=0; i < numComponents; i++) {

        MethodDesc* pMeth = pElements[i].pFunc;
        _ASSERTE(pMeth);

        // Skip Jit Helper functions, since they can throw when you have
        // a bug in your code, such as an invalid cast.
        if (pMeth->GetMethodTable() == pJithelperClass)
            continue;

        LPCUTF8 szMethodName = pMeth->GetName(i);
        INT32 cchMethodName = (INT32)strlen(szMethodName);
        LPCUTF8 szClassName;
        DefineFullyQualifiedNameForClass();
        szClassName = GetFullyQualifiedNameForClass(pMeth->GetClass());

        if (szClassName == NULL) {
            delete [] sz;
            COMPlusThrowOM();
        }
        INT32 cchQualifiedName = (INT32)strlen(szClassName) + 1;

        // Get method argument types.
        SigFormat sigFormatter(pMeth, TypeHandle());
        const char * sig = sigFormatter.GetCStringParmsOnly();
        _ASSERTE(sig != NULL);
        int cchArgs = (int)strlen(sig);

        CheckBufferSize(sz, cchAllocated, cch + cchQualifiedName + cchMethodName + cchArgs + 3); //for "/;\0"
        // append the class and methods names and a comma

        strcpy(sz + cch, szClassName);
        cch += cchQualifiedName - 1;    // don't include null
        *(sz + cch++) = NAMESPACE_SEPARATOR_CHAR;
        memcpyNoGCRefs(sz + cch, szMethodName, cchMethodName);
        cch += cchMethodName;
        memcpyNoGCRefs(sz + cch, sig, cchArgs);
        cch += cchArgs;
        *(sz + cch++) = ';';
    }
    *(sz + cch++) = '\0';
    GCPROTECT_END();
    return sz;
}


LPVOID __stdcall SystemNative::GetModuleFileName(NoArgs *args)
{
    LPVOID rv = NULL;
    wchar_t wszFile[MAX_PATH];
    DWORD lgth = WszGetModuleFileName(NULL, wszFile, MAX_PATH);
    if(lgth) {
        *((STRINGREF*) &rv) = COMString::NewString(wszFile, lgth);
    }
    return rv;
}

LPVOID __stdcall SystemNative::GetDeveloperPath(NoArgs* args)
{
    LPVOID rv = NULL;
    LPWSTR pPath = NULL;
    DWORD lgth = 0;
    HRESULT hr = SystemDomain::System()->GetDevpathW(&pPath, &lgth);
    if(lgth) {
        *((STRINGREF*) &rv) = COMString::NewString(pPath, lgth);
    }
    return rv;
}

LPVOID __stdcall SystemNative::GetRuntimeDirectory(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv = NULL;
    wchar_t wszFile[MAX_PATH+1];
    DWORD dwFile = lengthof(wszFile);
    HRESULT hr = GetInternalSystemDirectory(wszFile, &dwFile);
    if(FAILED(hr)) {
        COMPlusThrowHR(hr);
    }
    dwFile--; // remove the trailing NULL
    if(dwFile) {
        *((STRINGREF*) &rv) = COMString::NewString(wszFile, dwFile);
    }
    return rv;
}

LPVOID __stdcall SystemNative::GetHostBindingFile(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv = NULL;
    LPCWSTR wszFile = g_pConfig->GetProcessBindingFile();
    if(wszFile) 
        *((STRINGREF*) &rv) = COMString::NewString(wszFile);
    return rv;
}

INT32 __stdcall SystemNative::FromGlobalAccessCache(AssemblyArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = AssemblyNative::ValidateThisRef((ASSEMBLYREF) args->refAssembly);
    INT32 rv = FALSE;
    IAssembly* pIAssembly = pAssembly->GetFusionAssembly();
    if(pIAssembly) {
        DWORD eLocation;
        if(SUCCEEDED(pIAssembly->GetAssemblyLocation(&eLocation)) &&
           ((eLocation & ASMLOC_LOCATION_MASK) == ASMLOC_GAC))
            rv = TRUE;
    }
            
    return rv;
}

FCIMPL0(BOOL, SystemNative::HasShutdownStarted)
    // Return true if the EE has started to shutdown and is now going to 
    // aggressively finalize objects referred to by static variables OR
    // if someone is unloading the current AppDomain AND we have started
    // finalizing objects referred to by static variables.
    return (g_fEEShutDown & ShutDown_Finalize2) || GetAppDomain()->IsFinalizing();
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comthreadpool.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMThreadPool.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.ThreadPool
**          and its inner classes
**
** Date:  August, 1999
** 
===========================================================*/

#ifndef _COMTHREADPOOL_H
#define _COMTHREADPOOL_H

#include <member-offset-info.h>

typedef VOID (*WAITORTIMERCALLBACK)(PVOID, BOOL); 

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
    extern FnType COM##FnName FnParamList ;                 
    
#include "tpoolfnsp.h"
#include "DelegateInfo.h"
#undef STRUCT_ENTRY

class ThreadPoolNative
{

#pragma pack(push,4)
    struct RegisterWaitForSingleObjectsArgs
    {
        DECLARE_ECALL_I4_ARG(BOOL, compressStack);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, registeredWaitObject);
        DECLARE_ECALL_I4_ARG(BOOL, executeOnlyOnce);
        DECLARE_ECALL_I8_ARG(INT64, timeout);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, state);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, delegate);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, waitObject);

    };
#pragma pack(pop)

    struct UnregisterWaitArgs
    {
        DECLARE_ECALL_PTR_ARG(LPVOID, objectToNotify);
        DECLARE_ECALL_PTR_ARG(LPVOID, WaitHandle);
    };

    struct WaitHandleCleanupArgs
    {
        DECLARE_ECALL_PTR_ARG(LPVOID, WaitHandle);
    };

    struct QueueUserWorkItemArgs
    {
        DECLARE_ECALL_I4_ARG(BOOL, compressStack);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, state);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, delegate);
    };
    struct BindIOCompletionCallbackArgs
    {
        DECLARE_ECALL_I4_ARG(HANDLE, fileHandle);
    };
    public:

    static void Init();
#ifdef SHOULD_WE_CLEANUP
    static void ShutDown();
#endif /* SHOULD_WE_CLEANUP */

    static FCDECL2(VOID, CorGetMaxThreads, DWORD* workerThreads, DWORD* completionPortThreads);
    static FCDECL2(BOOL, CorSetMinThreads, DWORD workerThreads, DWORD completionPortThreads);
    static FCDECL2(VOID, CorGetMinThreads, DWORD* workerThreads, DWORD* completionPortThreads);
    static FCDECL2(VOID, CorGetAvailableThreads, DWORD* workerThreads, DWORD* completionPortThreads);
    static LPVOID __stdcall CorRegisterWaitForSingleObject(RegisterWaitForSingleObjectsArgs *);
    static VOID __stdcall CorQueueUserWorkItem(QueueUserWorkItemArgs *);
    static BOOL __stdcall CorUnregisterWait(UnregisterWaitArgs *);
    static void __stdcall CorWaitHandleCleanupNative(WaitHandleCleanupArgs *);
    static BOOL __stdcall CorBindIoCompletionCallback(BindIOCompletionCallbackArgs *);
    static VOID __stdcall CorThreadPoolCleanup(LPVOID);
};

class TimerBaseNative;
typedef TimerBaseNative* TIMERREF;

class TimerBaseNative : public MarshalByRefObjectBaseObject 
{
    friend class TimerNative;
    friend class ThreadPoolNative;

    LPVOID          timerHandle;
    DelegateInfo*   delegateInfo;
    LONG            timerDeleted;

    __inline LPVOID         GetTimerHandle() {return timerHandle;}
    __inline void           SetTimerHandle(LPVOID handle) {timerHandle = handle;}
    __inline PLONG          GetAddressTimerDeleted() { return &timerDeleted;}
    __inline BOOL           IsTimerDeleted() { return timerDeleted;}

public:
    __inline DelegateInfo*  GetDelegateInfo() { return delegateInfo;}
    __inline void           SetDelegateInfo(DelegateInfo* delegate) { delegateInfo = delegate;}
};
class TimerNative
{
    friend struct MEMBER_OFFSET_INFO(TimerNative);
private:
    struct ChangeTimerArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(TIMERREF, pThis);
        DECLARE_ECALL_I4_ARG(INT32, period);
        DECLARE_ECALL_I4_ARG(INT32, dueTime);
    };
    struct DeleteTimerArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(TIMERREF, pThis);
        DECLARE_ECALL_PTR_ARG(LPVOID, notifyObjectHandle);    
    };
    struct AddTimerArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(TIMERREF, pThis);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_I4_ARG(INT32, period);
        DECLARE_ECALL_I4_ARG(INT32, dueTime);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, state);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, delegate);

    };
    struct NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(TIMERREF, pThis);
    };
 
    static VOID WINAPI TimerNative::timerDeleteWorkItem(PVOID,BOOL);
    public:
    static VOID __stdcall   CorCreateTimer(AddTimerArgs *);
    static BOOL __stdcall   CorChangeTimer(ChangeTimerArgs *);
    static BOOL __stdcall   CorDeleteTimer(DeleteTimerArgs *);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comtypelibconverter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMTypeLibConverter.cpp
**
**
** Purpose: Implementation of the native methods used by the 
**          typelib converter.
**
** 
===========================================================*/

#include "common.h"
#include "COMTypeLibConverter.h"
#include "ComPlusWrapper.h"
#include "COMString.h"
#include "assembly.hpp"
#include "DebugMacros.h"
#include <TlbImpExp.h>
#include "..\md\inc\imptlb.h"
#include <TlbUtils.h>

BOOL            COMTypeLibConverter::m_bInitialized = FALSE;

//*****************************************************************************
// Given the string persisted from a TypeLib export, recreate the assembly
//  reference.
//*****************************************************************************
mdAssemblyRef DefineAssemblyRefForExportedAssembly(
    LPCWSTR     pszFullName,            // Full name of the assembly.
    IUnknown    *pIMeta)                // Metadata emit interface.
{
    mdAssemblyRef ar=0;
    HRESULT     hr;                     // A result.
    IMetaDataAssemblyEmit   *pMeta=0;   // Emit interface.
    AssemblySpec spec;                  // "Name" of assembly.
    
    CQuickArray<char> rBuf;
    int iLen;    
    iLen = WszWideCharToMultiByte(CP_ACP,0, pszFullName,-1, 0,0, 0,0);
    IfFailGo(rBuf.ReSize(iLen+1));
    WszWideCharToMultiByte(CP_ACP,0, pszFullName,-1, rBuf.Ptr(),iLen+1, 0,0);
     
    // Restore the AssemblySpec data.
    //IfFailGo(spec.Init(pszFullName));
    IfFailGo(spec.Init(rBuf.Ptr()));
    
    // Make sure we have the correct pointer type.
    IfFailGo(pIMeta->QueryInterface(IID_IMetaDataAssemblyEmit, (void**)&pMeta));
    // Create the assemblyref token.
    IfFailGo(spec.EmitToken(pMeta, &ar));
        
ErrExit:
    if (pMeta)
        pMeta->Release();
    return ar;
} // mdAssemblyRef DefineAssemblyRefForExportedAssembly()

//*****************************************************************************
// Public helper function used by typelib converter to create AssemblyRef
//  for a referenced typelib.
//*****************************************************************************
extern mdAssemblyRef DefineAssemblyRefForImportedTypeLib(
    void        *pvAssembly,            // Assembly importing the typelib.
    void        *pvModule,              // Module importing the typelib.
    IUnknown    *pIMeta,                // IMetaData* from import module.
    IUnknown    *pIUnk,                 // IUnknown to referenced Assembly.
    BSTR        *pwzNamespace,          // The namespace of the resolved assembly.
    BSTR        *pwzAsmName,            // The name of the resolved assembly.
    Assembly    **AssemblyRef)          // The resolved assembly.        
{
    // This is a hack to allow an untyped param.  To really fix, move imptlb to this project,
    //  and out of the metadata project.  Once here, imptlb can just reference any of 
    //  the .h files in this project.
    Assembly    *pAssembly = reinterpret_cast<Assembly*>(pvAssembly);
    Module      *pTypeModule = reinterpret_cast<Module*>(pvModule);

    HRESULT     hr;
    Assembly    *pRefdAssembly = NULL;
    IMetaDataEmit *pEmitter = NULL;
    IMetaDataAssemblyEmit *pAssemEmitter = NULL;
    IMDInternalImport *pRefdMDImport = NULL;
    MethodTable *pAssemblyClass = NULL; //@todo -- get this.
    mdAssemblyRef ar = mdAssemblyRefNil;
    Module      *pManifestModule = NULL;
    HENUMInternal hTDEnum;
    HENUMInternal *phTDEnum = NULL;
    mdTypeDef   td = 0;
    LPCSTR      szName = NULL;
    LPCSTR      szNamespace = NULL;
    WCHAR       wszBuff[MAX_CLASSNAME_LENGTH];
    LPCWSTR     szRefdAssemblyName;

    BOOL        bDisable = !GetThread()->PreemptiveGCDisabled();
    if (bDisable)
        GetThread()->DisablePreemptiveGC();

    // Initialize the output strings to NULL.
    *pwzNamespace = NULL;
    *pwzAsmName = NULL;

    // Get the Referenced Assembly from the IUnknown.
    pRefdAssembly = ((ASSEMBLYREF)GetObjectRefFromComIP(pIUnk, pAssemblyClass))->GetAssembly();

    // Return the assembly if asked for
    if (AssemblyRef)
        *AssemblyRef = pRefdAssembly;

    // Get the manifest module for the importing and the referenced assembly.
    pManifestModule = pAssembly->GetSecurityModule();  
        
    // Define the AssemblyRef in the global assembly.
    pEmitter = pManifestModule->GetEmitter();
    _ASSERTE(pEmitter);
    IfFailGo(pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &pAssemEmitter));
    ar = pAssembly->AddAssemblyRef(pRefdAssembly, pAssemEmitter); 
    pAssemEmitter->Release();
    pAssemEmitter = 0;

    // Add the assembly ref token and the manifest module it is referring to the manifest module's rid map.
    if(!pManifestModule->StoreAssemblyRef(ar, pRefdAssembly))
        IfFailGo(E_OUTOFMEMORY);

    // Add assembly ref in module manifest.
    IfFailGo(pIMeta->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &pAssemEmitter));
    ar = pAssembly->AddAssemblyRef(pRefdAssembly, pAssemEmitter);    

    // Add the assembly ref token and the manifest module it is referring to the rid map of the module we are 
    // emiting into.
    if(!pTypeModule->StoreAssemblyRef(ar, pRefdAssembly))
        IfFailGo(E_OUTOFMEMORY);
    
    // Retrieve the first typedef in the assembly.
    Module *pRefdModule = pRefdAssembly->GetManifestModule();
    while (pRefdModule)
    {
        pRefdMDImport = pRefdModule->GetMDImport();

        IfFailGo(pRefdMDImport->EnumTypeDefInit(&hTDEnum));
        phTDEnum = &hTDEnum;

        if (pRefdMDImport->EnumNext(phTDEnum, &td) == true)
        {
            pRefdMDImport->GetNameOfTypeDef(td, &szName, &szNamespace);
            break;
        }

        pRefdMDImport->EnumTypeDefClose(phTDEnum);
        phTDEnum = NULL;

        pRefdModule = pRefdModule->GetNextModule();
    }

    // DefineAssemblyRefForImportedTypeLib should never be called for assemblies that
    // do not contain any types so we better have found one.
    _ASSERTE(szNamespace);

    // Give the namespace back to the caller.
    WszMultiByteToWideChar(CP_UTF8,0, szNamespace, -1, wszBuff, MAX_CLASSNAME_LENGTH);
    *pwzNamespace = SysAllocString(wszBuff);
    IfNullGo(*pwzNamespace);

    // Give the assembly name back to the caller.
    IfFailGo(pRefdAssembly->GetFullName(&szRefdAssemblyName));
    *pwzAsmName = SysAllocString(szRefdAssemblyName);
    IfNullGo(*pwzAsmName);

ErrExit:
    if (FAILED(hr))
    {
        if (*pwzNamespace)
            SysFreeString(*pwzNamespace);
        if (*pwzAsmName)
            SysFreeString(*pwzAsmName);
        ar = mdAssemblyRefNil;
    }
    if (pAssemEmitter)
        pAssemEmitter->Release();
    if (phTDEnum)
        pRefdMDImport->EnumTypeDefClose(phTDEnum);

    if (bDisable)
        GetThread()->EnablePreemptiveGC();

    return ar;
} // mdAssemblyRef DefineAssemblyRefForImportedTypeLib()

//*****************************************************************************
// Public helper function used by typelib converter to create COM Type
//  for a typeref.
//*****************************************************************************
HRESULT DefineCOMTypeForImportedTypeInfo(
    Assembly    *pAssembly,             // Assembly importing the typelib.
    LPCWSTR     szTypeRef)              // Name of the typeref.
{
    HRESULT     hr = E_NOTIMPL;
    return hr;

} // HRESULT DefineCOMTypeForImportedTypeInfo()


//*****************************************************************************
//*****************************************************************************
HRESULT COMTypeLibConverter::TypeLibImporterWrapper(
    ITypeLib    *pITLB,                 // Typelib to import.
    LPCWSTR     szFname,                // Name of the typelib, if known.
    LPCWSTR     szNamespace,            // Optional namespace override.
    IMetaDataEmit *pEmit,               // Metadata scope to which to emit.
    Assembly    *pAssembly,             // Assembly containing the imported module.
    Module      *pModule,               // Module we are emitting into.
    ITypeLibImporterNotifySink *pNotify,// Callback interface.
    TlbImporterFlags flags,             // Importer flags.
    CImportTlb  **ppImporter)           // The importer.
{
    HRESULT     hr;
    
    // Retrieve flag indicating whether runtime or linktime interface
    // security checks are required.
    BOOL bUnsafeInterfaces = (BOOL)(flags & TlbImporter_UnsafeInterfaces);

    // Determine if we import SAFEARRAY's as System.Array's.
    BOOL bSafeArrayAsSysArray = (BOOL)(flags & TlbImporter_SafeArrayAsSystemArray);

    // Determine if we are doing the [out,retval] transformation on disp only interfaces.
    BOOL bTransformDispRetVals = (BOOL)(flags & TlbImporter_TransformDispRetVals);

    // Create and initialize a TypeLib importer.
    CImportTlb *pImporter = CImportTlb::CreateImporter(szFname, pITLB, true /*m_OptionValue.m_GenerateTCEAdapters*/, bUnsafeInterfaces, bSafeArrayAsSysArray, bTransformDispRetVals);
    _ASSERTE(pImporter);

    // If a namespace is specified, use it.
    if (szNamespace)
        pImporter->SetNamespace(szNamespace);

    // Set the various pointers.
    hr = pImporter->SetMetaData(pEmit);
    _ASSERTE(SUCCEEDED(hr) && "Couldn't get IMetaDataEmit* from Module");
    pImporter->SetNotification(pNotify);
    pImporter->SetAssembly(pAssembly);
    pImporter->SetModule(pModule);

    // Do the conversion.
    hr = pImporter->Import();
    if (SUCCEEDED(hr))
        *ppImporter = pImporter;
    else
        delete pImporter;
    
    return (hr);
} // HRESULT COMTypeLibConverter::TypeLibImporterWrapper()

//*****************************************************************************
// A typelib exporter.
//*****************************************************************************
LPVOID COMTypeLibConverter::ConvertAssemblyToTypeLib(   // The typelib.
    _ConvertAssemblyToTypeLib *pArgs)           // Exporter args.
{
#ifdef PLATFORM_CE
    return 0;
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();
    
    Thread      *pThread = GetThread(); 
    HRESULT     hr;                     // A result.
    ITypeLib    *pTLB=0;                // The new typelib.
    ITypeLibExporterNotifySink *pINotify=0;// Callback parameter.
    Assembly    *pAssembly=0;           // Assembly to export.
    LPWSTR      szTypeLibName=0;        // The name for the typelib.
    LPVOID      RetObj = NULL;          // The object to return.

    GCPROTECT_BEGIN (RetObj);
    EE_TRY_FOR_FINALLY
    {
        // Make sure the COMTypeLibConverter has been initialized.
        if (!m_bInitialized)
            Init();

        // Validate flags
        if ( (pArgs->Flags & ~(TlbExporter_OnlyReferenceRegistered)) != 0 )
        {
            COMPlusThrowArgumentOutOfRange(L"flags", L"Argument_InvalidFlag");
        }

        // Retrieve the callback.
        if (pArgs->NotifySink == NULL)
	        COMPlusThrowArgumentNull(L"notifySink");
            //COMPlusThrowNonLocalized(kArgumentNullException, L"notifySink");
        pINotify = (ITypeLibExporterNotifySink*)GetComIPFromObjectRef(&pArgs->NotifySink, IID_ITypeLibExporterNotifySink);
        if (!pINotify)
            COMPlusThrow(kArgumentNullException, L"Arg_NoImporterCallback");
        
        // If a name was specified then copy it to a temporary string.
        if (pArgs->TypeLibName != NULL)
        {
            int TypeLibNameLen = pArgs->TypeLibName->GetStringLength();
            szTypeLibName = new WCHAR[TypeLibNameLen + 1];
            memcpyNoGCRefs(szTypeLibName, pArgs->TypeLibName->GetBuffer(), TypeLibNameLen * sizeof(WCHAR));
            szTypeLibName[TypeLibNameLen] = 0;
        }

        // Retrieve the assembly from the AssemblyBuilder argument.
        if (pArgs->Assembly == NULL)
            COMPlusThrowNonLocalized(kArgumentNullException, L"assembly");
        pAssembly = ((ASSEMBLYREF)pArgs->Assembly)->GetAssembly();
        _ASSERTE(pAssembly);

        // Switch to preemptive GC before we call out to COM.
        pThread->EnablePreemptiveGC();
        
        hr = ExportTypeLibFromLoadedAssembly(pAssembly, szTypeLibName, &pTLB, pINotify, pArgs->Flags);
        
        // Switch back to cooperative now that we are finished calling out.
        pThread->DisablePreemptiveGC();
        
        // If there was an error on import, turn into an exception.
        IfFailThrow(hr);

        // Make sure we got a typelib back.
        _ASSERTE(pTLB);

        // Convert the ITypeLib interface pointer to a COM+ object.
        *((OBJECTREF*) &RetObj) = GetObjectRefFromComIP(pTLB, NULL);
        
        // The COM+ object holds a refcount, so release this one.
        pTLB->Release();
    }
    EE_FINALLY
    {
        pThread->EnablePreemptiveGC();

        if (pINotify)
            pINotify->Release();

        if (szTypeLibName)
            delete[] szTypeLibName;
        

        pThread->DisablePreemptiveGC();
    }
    EE_END_FINALLY

    GCPROTECT_END();
    
    return RetObj;
#endif // !PLATFORM_CE
} // LPVOID COMTypeLibConverter::ConvertAssemblyToTypeLib()

//*****************************************************************************
// Import a typelib as metadata.  Doesn't add TCE adapters.
//*****************************************************************************
void COMTypeLibConverter::ConvertTypeLibToMetadata(_ConvertTypeLibToMetadataArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr;
    Thread      *pThread = GetThread(); 
    ITypeLibImporterNotifySink *pINotify = NULL;// Callback parameter.
    Module      *pModule = NULL;               // ModuleBuilder parameter.
    Assembly    *pAssembly = NULL;      // AssemblyBuilder parameter.
    ITypeLib    *pTLB = NULL;           // TypeLib parameter.
    REFLECTMODULEBASEREF pReflect;      // ReflectModule passed as param.
    HENUMInternal hEnum;                // To enumerate imported TypeDefs.
    LPWSTR      szNamespace = NULL;     // The namespace to put the type in.
    bool        bEnum=false;            // Is the enum open?
    int         cTypeDefs;              // Count of imported TypeDefs.
    int         i;                      // Loop control.
    mdTypeDef   cl;                     // An imported TypeDef.
    CImportTlb  *pImporter = NULL;      // The importer used to import the typelib.

    EE_TRY_FOR_FINALLY
    {
        // Make sure the COMTypeLibConverter has been initialized.
        if (!m_bInitialized)
            Init();

        // Validate the flags.
        if ((pArgs->Flags & ~TlbImporter_ValidFlags) != 0)
            COMPlusThrowArgumentOutOfRange(L"flags", L"Argument_InvalidFlag");

        // Retrieve the callback.
        _ASSERTE(pArgs->NotifySink != NULL);
        pINotify = (ITypeLibImporterNotifySink*)GetComIPFromObjectRef(&pArgs->NotifySink, IID_ITypeLibImporterNotifySink);
        if (!pINotify)
            COMPlusThrow(kArgumentNullException, L"Arg_NoImporterCallback");
        
        // Retrieve the Module from the ModuleBuilder argument.
        pReflect = (REFLECTMODULEBASEREF) pArgs->ModBldr;
        _ASSERTE(pReflect);
        pModule = (Module*) pReflect->GetData();
        _ASSERTE(pModule);
        
        // Retrieve the assembly from the AssemblyBuilder argument.
        _ASSERTE(pArgs->AsmBldr);
        pAssembly = ((ASSEMBLYREF)pArgs->AsmBldr)->GetAssembly();
        _ASSERTE(pAssembly);

        // Retrieve a pointer to the ITypeLib interface.
        pTLB = (ITypeLib*)GetComIPFromObjectRef(&pArgs->TypeLib, IID_ITypeLib);
        if (!pTLB)
            COMPlusThrow(kArgumentNullException, L"Arg_NoITypeInfo");

        // If a namespace was specified then copy it to a temporary string.
        if (pArgs->Namespace != NULL)
        {
            int NamespaceLen = pArgs->Namespace->GetStringLength();
            szNamespace = new WCHAR[NamespaceLen + 1];
            memcpyNoGCRefs(szNamespace, pArgs->Namespace->GetBuffer(), NamespaceLen * sizeof(WCHAR));
            szNamespace[NamespaceLen] = 0;
        }

        // Switch to preemptive GC before we call out to COM.
        pThread->EnablePreemptiveGC();
        
        // Have to wrap the CImportTlb object in a call, because it has a destructor.
        hr = TypeLibImporterWrapper(pTLB, NULL /*filename*/, szNamespace,
                                    pModule->GetEmitter(), pAssembly, pModule, pINotify,
                                    pArgs->Flags, &pImporter);

        // Switch back to cooperative now that we are finished calling out.
        pThread->DisablePreemptiveGC();
        
        // If there was an error on import, turn into an exception.
        IfFailThrow(hr);
        
        // Enumerate the types imported from the typelib, and add them to the assembly's available type table.
        IfFailThrow(pModule->GetMDImport()->EnumTypeDefInit(&hEnum));
        bEnum = true;
        cTypeDefs = pModule->GetMDImport()->EnumTypeDefGetCount(&hEnum);

        for (i=0; i<cTypeDefs; ++i)
        {
            IfFailThrow(pModule->GetMDImport()->EnumTypeDefNext(&hEnum, &cl));
            pAssembly->AddType(pModule, cl);
        }

        TypeHandle typeHnd;
        pModule->GetMDImport()->EnumReset(&hEnum);
        OBJECTREF pThrowable = NULL;
        GCPROTECT_BEGIN(pThrowable);
        for (i=0; i<cTypeDefs; ++i)
        {
            IfFailThrow(pModule->GetMDImport()->EnumTypeDefNext(&hEnum, &cl));
            // Load the EE class that represents the type, so that
            // the TypeDefToMethodTable rid map contains this entry
            // (They were going to be loaded, anyway, to generate comtypes)
            typeHnd = pAssembly->LoadTypeHandle(&NameHandle(pModule, cl), &pThrowable, FALSE);
            if (typeHnd.IsNull())
                COMPlusThrow(pThrowable);
        }
        GCPROTECT_END();

        // Retrieve the event interface list.
        GetEventItfInfoList(pImporter, pAssembly, pArgs->pEventItfInfoList);
    }
    EE_FINALLY
    {
        pThread->EnablePreemptiveGC();

        if (szNamespace)
            delete[] szNamespace;
        if (bEnum)
            pModule->GetMDImport()->EnumTypeDefClose(&hEnum);
        if (pTLB)
            pTLB->Release();
        if (pINotify)
            pINotify->Release();
        if (pImporter)
            delete pImporter;

        pThread->DisablePreemptiveGC();
    }
    EE_END_FINALLY
} // void COMTypeLibConverter::ConvertTypeLibToMetadata()

//*****************************************************************************
//*****************************************************************************
void COMTypeLibConverter::GetEventItfInfoList(CImportTlb *pImporter, Assembly *pAssembly, OBJECTREF *pEventItfInfoList)
{
    THROWSCOMPLUSEXCEPTION();

    Thread                          *pThread = GetThread();  
    UINT                            i;              
    CQuickArray<ImpTlbEventInfo*>   qbEvInfoList;

    _ASSERTE(pThread->PreemptiveGCDisabled());

    // Retrieve the Ctor and Add method desc's for the ArrayList.
    MethodDesc *pCtorMD = g_Mscorlib.GetMethod(METHOD__ARRAY_LIST__CTOR);
    MethodDesc *pAddMD = g_Mscorlib.GetMethod(METHOD__ARRAY_LIST__ADD);

    // Allocate the array list that will contain the event sources.
    SetObjectReference(pEventItfInfoList, 
                       AllocateObject(g_Mscorlib.GetClass(CLASS__ARRAY_LIST)),
                       SystemDomain::GetCurrentDomain());

    // Call the ArrayList constructor.
    INT64 CtorArgs[] = { 
        ObjToInt64(*pEventItfInfoList)
    };
    pCtorMD->Call(CtorArgs, METHOD__ARRAY_LIST__CTOR);

    // Retrieve the list of event interfaces.
    pImporter->GetEventInfoList(qbEvInfoList);

    // Iterate over TypeInfos.
    for (i = 0; i < qbEvInfoList.Size(); i++)
    {
        // Retrieve the event interface info for the current CoClass.
        OBJECTREF EventItfInfoObj = GetEventItfInfo(pImporter, pAssembly, qbEvInfoList[i]);
        _ASSERTE(EventItfInfoObj);

        // Add the event interface info to the list.
        INT64 AddArgs[] = { 
            ObjToInt64(*pEventItfInfoList),
            ObjToInt64(EventItfInfoObj)
        };
        pAddMD->Call(AddArgs, METHOD__ARRAY_LIST__ADD);  
    }
} // LPVOID COMTypeLibConverter::GetTypeLibEventSourceList()

//*****************************************************************************
// Initialize the COMTypeLibConverter.
//*****************************************************************************
void COMTypeLibConverter::Init()
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;

    // Ensure COM is started up.
    IfFailThrow(QuickCOMStartup());

    // Set the initialized flag to TRUE.
    m_bInitialized = TRUE;
} // void COMTypeLibConverter::Init()

//*****************************************************************************
// Given an imported class in an assembly, generate a list of event sources.
//*****************************************************************************
OBJECTREF COMTypeLibConverter::GetEventItfInfo(CImportTlb *pImporter, Assembly *pAssembly, ImpTlbEventInfo *pImpTlbEventInfo)
{
    THROWSCOMPLUSEXCEPTION();

    Thread      *pThread = GetThread();  
    OBJECTREF   RetObj = NULL;
    BSTR        bstrSrcItfName = NULL;
    HRESULT     hr = S_OK;

    _ASSERTE(pThread->PreemptiveGCDisabled());

    struct _gc {
        OBJECTREF EventItfInfoObj;
        STRINGREF EventItfNameStrObj;
        STRINGREF SrcItfNameStrObj;
        STRINGREF EventProvNameStrObj;
        OBJECTREF AssemblyObj;
        OBJECTREF SrcItfAssemblyObj;
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    GCPROTECT_BEGIN(gc)
    {
        // Retrieve the Ctor and Add method desc's for the EventSource.
        MethodDesc *pCtorMD = g_Mscorlib.GetMethod(METHOD__TCE_EVENT_ITF_INFO__CTOR);

        // Create the EventSource object.
        gc.EventItfInfoObj = AllocateObject(g_Mscorlib.GetClass(CLASS__TCE_EVENT_ITF_INFO));
                            
        // Retrieve the assembly object.
        gc.AssemblyObj = pAssembly->GetExposedObject();

        // Retrieve the source interface assembly object (may be the same assembly).
        gc.SrcItfAssemblyObj = pImpTlbEventInfo->SrcItfAssembly->GetExposedObject();


        // Prepare the constructor arguments.
        gc.EventItfNameStrObj = COMString::NewString(pImpTlbEventInfo->szEventItfName);       
        gc.SrcItfNameStrObj = COMString::NewString(pImpTlbEventInfo->szSrcItfName);       
        gc.EventProvNameStrObj = COMString::NewString(pImpTlbEventInfo->szEventProviderName);

        // Call the EventItfInfo constructor.
        INT64 CtorArgs[] = { 
            ObjToInt64(gc.EventItfInfoObj),
            ObjToInt64(gc.SrcItfAssemblyObj),
            ObjToInt64(gc.AssemblyObj),
            ObjToInt64(gc.EventProvNameStrObj),
            ObjToInt64(gc.SrcItfNameStrObj),
            ObjToInt64(gc.EventItfNameStrObj),
        };
        pCtorMD->Call(CtorArgs, METHOD__TCE_EVENT_ITF_INFO__CTOR);

        RetObj = gc.EventItfInfoObj;
    }
    GCPROTECT_END();

    return RetObj;
} // OBJECTREF COMTypeLibConverter::GetEventSourceInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comvarargs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This module contains the implementation of the native methods for the
//  varargs class(es)..
//
// Author: Brian Harry
////////////////////////////////////////////////////////////////////////////////
#ifndef _COMVARARGS_H_
#define _COMVARARGS_H_


struct VARARGS
{
	VASigCookie *ArgCookie;
	SigPointer	SigPtr;
	BYTE		*ArgPtr;
	int			RemainingArgs;
};

class COMVarArgs
{
public:
	struct _VarArgsIntArgs
	{
			DECLARE_ECALL_PTR_ARG(VARARGS *, _this);
			DECLARE_ECALL_I4_ARG(LPVOID, cookie); 
	};
	struct _VarArgs2IntArgs
	{
			DECLARE_ECALL_PTR_ARG(VARARGS *, _this);
			DECLARE_ECALL_I4_ARG(LPVOID, firstArg); 
			DECLARE_ECALL_I4_ARG(LPVOID, cookie); 
	};
	struct _VarArgsGetNextArgTypeArgs
	{
			DECLARE_ECALL_PTR_ARG(VARARGS *, _this);
	};
	struct _VarArgsGetNextArgArgs
	{
			DECLARE_ECALL_PTR_ARG(VARARGS *, _this);
			DECLARE_ECALL_PTR_ARG(TypedByRef *, value); 
	};

	struct _VarArgsGetNextArg2Args
	{
			DECLARE_ECALL_PTR_ARG(VARARGS *, _this);
			DECLARE_ECALL_PTR_ARG(TypeHandle, typehandle);
			DECLARE_ECALL_PTR_ARG(TypedByRef *, value); 
	};
	
	struct _VarArgsThisArgs
	{
			DECLARE_ECALL_PTR_ARG(VARARGS *, _this);
	};

	static void  Init2(_VarArgs2IntArgs *args);
	static void  Init(_VarArgsIntArgs *args);
	static int   GetRemainingCount(_VarArgsThisArgs *args);
	static void*  GetNextArgType(_VarArgsGetNextArgTypeArgs *args);
	static void  GetNextArg(_VarArgsGetNextArgArgs *args);
	static void  GetNextArg2(_VarArgsGetNextArg2Args *args);

	static void GetNextArgHelper(VARARGS *data, TypedByRef *value);
	static va_list MarshalToUnmanagedVaList(const VARARGS *data);
	static void    MarshalToManagedVaList(va_list va, VARARGS *dataout);
};


struct PARAMARRAY
{
	int			Count;
	BYTE		*ParamsPtr;
	BYTE		*Params[4];
	TypeHandle	Types[4];
};

class COMParamArray
{
public:
	struct _ParamArrayIntArgs
	{
			DECLARE_ECALL_PTR_ARG(PARAMARRAY *, _this);
			DECLARE_ECALL_I4_ARG(LPVOID, cookie); 
	};
	struct _ParamArrayGetArgArgs
	{
			DECLARE_ECALL_PTR_ARG(PARAMARRAY *, _this);
			DECLARE_ECALL_I4_ARG(INT32, index);
			DECLARE_ECALL_PTR_ARG(TypedByRef *, value); 
	};
	struct _ParamArrayThisArgs
	{
			DECLARE_ECALL_PTR_ARG(PARAMARRAY *, _this);
	};

	static void Init(_ParamArrayIntArgs *args);
	static int GetCount(_ParamArrayThisArgs *args);
	static void GetArg(_ParamArrayGetArgArgs *args);
};


#endif // _COMVARARGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comvarargs.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This module contains the implementation of the native methods for the
//  varargs class(es)..
//
// Author: Brian Harry
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMVariant.h"
#include "COMVarArgs.h"

static void InitCommon(VARARGS *data, VASigCookie* cookie);
static void AdvanceArgPtr(VARARGS *data);

////////////////////////////////////////////////////////////////////////////////
// ArgIterator constructor that initializes the state to support iteration
// of the args starting at the first optional argument.
////////////////////////////////////////////////////////////////////////////////
void COMVarArgs::Init(_VarArgsIntArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    VARARGS *data = args->_this;
    if (args->cookie == 0)
        COMPlusThrow(kArgumentException, L"InvalidOperation_HandleIsNotInitialized");


    VASigCookie *pCookie = *(VASigCookie**)(args->cookie);

    if (pCookie->mdVASig == NULL)
    {
        data->SigPtr = NULL;
        data->ArgCookie = NULL;
        data->ArgPtr = (BYTE*)((VASigCookieEx*)pCookie)->m_pArgs;
    }
    else
    {
        // Use common code to pick the cookie apart and advance to the ...
        InitCommon(data, (VASigCookie*)args->cookie);
        AdvanceArgPtr(data);
    }
}

////////////////////////////////////////////////////////////////////////////////
// ArgIterator constructor that initializes the state to support iteration
// of the args starting at the argument following the supplied argument pointer.
// Specifying NULL as the firstArg parameter causes it to start at the first
// argument to the call.
////////////////////////////////////////////////////////////////////////////////
void COMVarArgs::Init2(_VarArgs2IntArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    VARARGS *data = args->_this;
    if (args->cookie == 0)
        COMPlusThrow(kArgumentException, L"InvalidOperation_HandleIsNotInitialized");

    // Init most of the structure.
    InitCommon(data, (VASigCookie*)args->cookie);

    // If it is NULL, start at the first arg.
    if (args->firstArg != NULL)
    {
        // Advance to the specified arg.
        while (data->RemainingArgs > 0)
        {
            if (data->SigPtr.PeekElemType() == ELEMENT_TYPE_SENTINEL)
                COMPlusThrow(kArgumentException);

            // Adjust the frame pointer and the signature info.
            data->ArgPtr -= StackElemSize(data->SigPtr.SizeOf(data->ArgCookie->pModule));
            data->SigPtr.SkipExactlyOne();
            --data->RemainingArgs;

            // Stop when we get to where the user wants to be.
            if (data->ArgPtr == args->firstArg)
                break;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
// Initialize the basic info for processing a varargs parameter list.
////////////////////////////////////////////////////////////////////////////////
static void InitCommon(VARARGS *data, VASigCookie* cookie)
{
    // Save the cookie and a copy of the signature.
    data->ArgCookie = *((VASigCookie **) cookie);
    data->SigPtr.SetSig(data->ArgCookie->mdVASig);

    // Skip the calling convention, get the # of args and skip the return type.
    data->SigPtr.GetCallingConvInfo();
    data->RemainingArgs = data->SigPtr.GetData();
    data->SigPtr.SkipExactlyOne();

    // Get a pointer to the first arg (last on the stack frame).
    data->ArgPtr = (BYTE *) cookie + data->ArgCookie->sizeOfArgs;

    //@nice: This is currently used to make sure the EEClass table used
    // in GetNextArg is properly initialized.
    COMVariant::EnsureVariantInitialized();
}

////////////////////////////////////////////////////////////////////////////////
// After initialization advance the next argument pointer to the first optional
// argument.
////////////////////////////////////////////////////////////////////////////////
void AdvanceArgPtr(VARARGS *data)
{
    // Advance to the first optional arg.
    while (data->RemainingArgs > 0)
    {
        if (data->SigPtr.PeekElemType() == ELEMENT_TYPE_SENTINEL)
        {
            data->SigPtr.SkipExactlyOne();
            break;
        }

        // Adjust the frame pointer and the signature info.
        data->ArgPtr -= StackElemSize(data->SigPtr.SizeOf(data->ArgCookie->pModule));
        data->SigPtr.SkipExactlyOne();
        --data->RemainingArgs;
    }
}




////////////////////////////////////////////////////////////////////////////////
// Return the number of unprocessed args in the argument iterator.
////////////////////////////////////////////////////////////////////////////////
int COMVarArgs::GetRemainingCount(_VarArgsThisArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (!(args->_this->ArgCookie))
    {
        // this argiterator was created by marshaling from an unmanaged va_list -
        // can't do this operation
        COMPlusThrow(kNotSupportedException); 
    }
    return (args->_this->RemainingArgs);
}


////////////////////////////////////////////////////////////////////////////////
// Retrieve the type of the next argument without consuming it.
////////////////////////////////////////////////////////////////////////////////
void* COMVarArgs::GetNextArgType(_VarArgsGetNextArgTypeArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    VARARGS     data = *args->_this;
    TypedByRef  value;

    if (!(args->_this->ArgCookie))
    {
        // this argiterator was created by marshaling from an unmanaged va_list -
        // can't do this operation
        COMPlusThrow(kNotSupportedException);
    }


    // Make sure there are remaining args.
    if (data.RemainingArgs == 0)
        COMPlusThrow(kInvalidOperationException, L"InvalidOperation_EnumEnded");

    GetNextArgHelper(&data, &value);
    return value.type.AsPtr();
}

////////////////////////////////////////////////////////////////////////////////
// Retrieve the next argument and return it in a TypedByRef and advance the
// next argument pointer.
////////////////////////////////////////////////////////////////////////////////
void COMVarArgs::GetNextArg(_VarArgsGetNextArgArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (!(args->_this->ArgCookie))
    {
        // this argiterator was created by marshaling from an unmanaged va_list -
        // can't do this operation
        COMPlusThrow(kInvalidOperationException);
    }

    // Make sure there are remaining args.
    if (args->_this->RemainingArgs == 0)
        COMPlusThrow(kInvalidOperationException, L"InvalidOperation_EnumEnded");

    GetNextArgHelper(args->_this, args->value);
}



////////////////////////////////////////////////////////////////////////////////
// Retrieve the next argument and return it in a TypedByRef and advance the
// next argument pointer.
////////////////////////////////////////////////////////////////////////////////
void COMVarArgs::GetNextArg2(_VarArgsGetNextArg2Args *args)
{
    THROWSCOMPLUSEXCEPTION(); 

    CorElementType typ = args->typehandle.GetNormCorElementType();
    UINT size = 0;
    switch (typ)
    {
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
            size = 1;
            break;

        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
            size = 2;
            break;

        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_R4:
            size = 4;
            break;

        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_R8:
        case ELEMENT_TYPE_R:
            size = 8;
            break;

        case ELEMENT_TYPE_I:
        case ELEMENT_TYPE_U:
        case ELEMENT_TYPE_PTR:
            size = sizeof(LPVOID);
            break;

        case ELEMENT_TYPE_VALUETYPE:
            size = args->typehandle.AsMethodTable()->GetNativeSize();
            break;

        default:
			COMPlusThrow(kNotSupportedException, L"NotSupported_Type");
    }
    size = MLParmSize(size);
    args->value->data = (void*)args->_this->ArgPtr;
    args->value->type = args->typehandle;
    args->_this->ArgPtr += size;
}



////////////////////////////////////////////////////////////////////////////////
// This is a helper that uses a VARARGS tracking data structure to retrieve
// the next argument out of a varargs function call.  This does not check if
// there are any args remaining (it assumes it has been checked).
////////////////////////////////////////////////////////////////////////////////
void  COMVarArgs::GetNextArgHelper(VARARGS *data, TypedByRef *value)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pThrowable = NULL;
    GCPROTECT_BEGIN(pThrowable);

    unsigned __int8 elemType;

    _ASSERTE(data->RemainingArgs != 0);

    //@todo: Should this be lower down in the code?
    if (data->SigPtr.PeekElemType() == ELEMENT_TYPE_SENTINEL)
        data->SigPtr.GetElemType();

    // Get a pointer to the beginning of the argument.
    data->ArgPtr -= StackElemSize(data->SigPtr.SizeOf(data->ArgCookie->pModule));

    // Assume the ref pointer points directly at the arg on the stack.
    value->data = data->ArgPtr;

TryAgain:
    switch (elemType = data->SigPtr.PeekElemType())
    {
        case ELEMENT_TYPE_BOOLEAN:
        case ELEMENT_TYPE_CHAR:
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_R4:
        case ELEMENT_TYPE_R8:
        case ELEMENT_TYPE_STRING:
        value->type = GetTypeHandleForCVType(elemType);
        break;

        case ELEMENT_TYPE_I:
        value->type = ElementTypeToTypeHandle(ELEMENT_TYPE_I);
        break;

        case ELEMENT_TYPE_U:
        value->type = ElementTypeToTypeHandle(ELEMENT_TYPE_U);
        break;

            // Fix if R and R8 diverge
        case ELEMENT_TYPE_R:
        value->type = ElementTypeToTypeHandle(ELEMENT_TYPE_R8);
        break;

        case ELEMENT_TYPE_PTR:
        value->type = data->SigPtr.GetTypeHandle(data->ArgCookie->pModule, &pThrowable);
        if (value->type.IsNull()) {
            _ASSERTE(pThrowable != NULL);
            COMPlusThrow(pThrowable);
        }
        break;

        case ELEMENT_TYPE_BYREF:
        // Check if we have already processed a by-ref.
        if (value->data != data->ArgPtr)
        {
            _ASSERTE(!"Can't have a ByRef of a ByRef");
			COMPlusThrow(kNotSupportedException, L"NotSupported_Type");
        }

        // Dereference the argument to remove the indirection of the ByRef.
        value->data = *((void **) data->ArgPtr);

        // Consume and discard the element type.
        data->SigPtr.GetElemType();
        goto TryAgain;

        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS: {
        value->type = data->SigPtr.GetTypeHandle(data->ArgCookie->pModule, &pThrowable);
        if (value->type.IsNull()) {
            _ASSERTE(pThrowable != NULL);
            COMPlusThrow(pThrowable);
        }

            // TODO: seems like we made this illegal - vancem 
        if (elemType == ELEMENT_TYPE_CLASS && value->type.GetClass()->IsValueClass())
            value->type = g_pObjectClass;
        } break;

        case ELEMENT_TYPE_TYPEDBYREF:
        if (value->data != data->ArgPtr)
        {
            //@todo: Is this really an error?
            _ASSERTE(!"Can't have a ByRef of a TypedByRef");
			COMPlusThrow(kNotSupportedException, L"NotSupported_Type");
        }
        ((DWORD *) value)[0] = ((DWORD *) data->ArgPtr)[0];
        ((DWORD *) value)[1] = ((DWORD *) data->ArgPtr)[1];
        break;

        default:
        case ELEMENT_TYPE_SENTINEL:
			_ASSERTE(!"Unrecognized element type");
			COMPlusThrow(kNotSupportedException, L"NotSupported_Type");
        break;

        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_VALUEARRAY:
        {
            value->type = data->SigPtr.GetTypeHandle(data->ArgCookie->pModule, &pThrowable);
            if (value->type.IsNull()) {
                _ASSERTE(pThrowable != NULL);
                COMPlusThrow(pThrowable);
            }

            break;
        }

        case ELEMENT_TYPE_FNPTR:
        case ELEMENT_TYPE_OBJECT:
        _ASSERTE(!"Not implemented");
        COMPlusThrow(kNotSupportedException);
        break;
    }

    // Update the tracking stuff to move past the argument.
    --data->RemainingArgs;
    data->SigPtr.SkipExactlyOne();

    GCPROTECT_END();
}


/*static*/ void COMVarArgs::MarshalToManagedVaList(va_list va, VARARGS *dataout)
{
#ifndef _X86_
    _ASSERTE(!"NYI");
#else

    THROWSCOMPLUSEXCEPTION();

    dataout->SigPtr = NULL;
    dataout->ArgCookie = NULL;
    dataout->ArgPtr = (BYTE*)va;

#endif
}

////////////////////////////////////////////////////////////////////////////////
// Creates an unmanaged va_list equivalent. (WARNING: Allocated from the
// LIFO memory manager so this va_list is only good while that memory is in "scope".) 
////////////////////////////////////////////////////////////////////////////////
/*static*/ va_list COMVarArgs::MarshalToUnmanagedVaList(const VARARGS *data)
{
    THROWSCOMPLUSEXCEPTION();


    // Must make temporary copy so we don't alter the original
    SigPointer sp = data->SigPtr;

    // Calculate how much space we need for the marshaled stack. This actually overestimates
    // the value since it counts the fixed args as well as the varargs. But that's harmless.
    DWORD      cbAlloc = MetaSig::SizeOfActualFixedArgStack(data->ArgCookie->pModule , data->ArgCookie->mdVASig, FALSE);

    BYTE*      pdstbuffer = (BYTE*)(GetThread()->m_MarshalAlloc.Alloc(cbAlloc));

    int        remainingArgs = data->RemainingArgs;
    BYTE*      psrc = (BYTE*)(data->ArgPtr);

    if (sp.PeekElemType() == ELEMENT_TYPE_SENTINEL) 
    {
        sp.GetElemType();
    }

    BYTE*      pdst = pdstbuffer;
    while (remainingArgs--) 
    {
        CorElementType elemType = sp.PeekElemType();
        switch (elemType)
        {
            case ELEMENT_TYPE_I1:
            case ELEMENT_TYPE_U1:
            case ELEMENT_TYPE_I2:
            case ELEMENT_TYPE_U2:
            case ELEMENT_TYPE_I4:
            case ELEMENT_TYPE_U4:
            case ELEMENT_TYPE_I8:
            case ELEMENT_TYPE_U8:
            case ELEMENT_TYPE_R4:
            case ELEMENT_TYPE_R8:
            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_R:
            case ELEMENT_TYPE_PTR:
                {
                    DWORD cbSize = sp.SizeOf(data->ArgCookie->pModule);
                    cbSize = StackElemSize(cbSize);
                    psrc -= cbSize;
                    CopyMemory(pdst, psrc, cbSize);
                    pdst += cbSize;
                    sp.SkipExactlyOne();
                }
                break;

            default:
                // non-IJW data type - we don't support marshaling these inside a va_list.
                COMPlusThrow(kNotSupportedException);


        }
    }

#ifdef _X86_
    return (va_list)pdstbuffer;
#else
    _ASSERTE(!"NYI");
    DWORD makecompilerhappy = 0;
    return *(va_list*)&makecompilerhappy;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comutilnative.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMUtilNative
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A dumping ground for classes which aren't large
** enough to get their own file in the VM.
**
** Date:  April 8, 1998
** 
===========================================================*/
#ifndef _COMUTILNATIVE_H_
#define _COMUTILNATIVE_H_

#include <basetsd.h> // CHANGED, VC6.0
#include "object.h"
#include "util.hpp"
#include "cgensys.h"
#include "fcall.h"

//
//
// COMCHARACTER
//
//
class COMCharacter {
public:
    typedef struct {
                DECLARE_ECALL_I4_ARG(INT32, CharInfoType);
                DECLARE_ECALL_I2_ARG(WCHAR, c);
        } _getCharacterInfoArgs;
    //_OneCharArgs is a break from our normal naming convention, but there's nothing to be gained by creating
    //a separate typedef for n identical signatures.
    typedef struct {
                DECLARE_ECALL_I2_ARG(WCHAR, c);
        } _oneCharArgs;

        static LPVOID ToString(_oneCharArgs *);

    //These are here for support from native code.  They are never called from our managed classes.
    static BOOL nativeIsWhiteSpace(WCHAR c);
    static BOOL nativeIsDigit(WCHAR c);
    static WCHAR nativeToUpper(WCHAR c);
    static WCHAR nativeToLower(WCHAR c);
};

//This is an unfortunate hack to get around the fact that utilcode.h requires CharToUpper, but can't call
//nativeToUpper without including COMUtilNative.h
//@ToDo: Replace this with a call to COMLocale::internalToUpperChar;
inline WCHAR CharToUpper(WCHAR c) {
    return COMCharacter::nativeToUpper(c);
}

//
//
// PARSE NUMBERS
//
//

#define MinRadix 2
#define MaxRadix 36

class ParseNumbers {
    
    enum FmtFlags {
      LeftAlign = 0x1,  //Ensure that these conform to the values specified in the managed files.
      CenterAlign = 0x2,
      RightAlign = 0x4,
      PrefixSpace = 0x8,
      PrintSign = 0x10,
      PrintBase = 0x20,
      TreatAsUnsigned = 0x10,
      PrintAsI1 = 0x40,
      PrintAsI2 = 0x80,
      PrintAsI4 = 0x100,
      PrintRadixBase = 0x200,
      AlternateForm = 0x400};

public:

    static INT32 GrabInts(const INT32, WCHAR *, const int, int *, BOOL);
    static INT64 GrabLongs(const INT32, WCHAR *, const int, int *, BOOL);

    static FCDECL5(LPVOID, IntToString, INT32 l, INT32 radix, INT32 width, WCHAR paddingChar, INT32 flags);
    static FCDECL1(LPVOID, IntToDecimalString, INT32 l);
    static FCDECL5(LPVOID, LongToString, INT32 radix, INT32 width, INT64 l, WCHAR paddingChar, INT32 flags);
    static FCDECL4(INT32, StringToInt, StringObject * s, INT32 radix, INT32 flags, I4Array *currPos);
    static FCDECL4(INT64, StringToLong, StringObject * s, INT32 radix, INT32 flags, I4Array *currPos);
    static FCDECL4(INT64, RadixStringToLong, StringObject *s, INT32 radix, INT32 isTight, I4Array *currPos);

};

//
//
// EXCEPTION NATIVE
//
//
struct ExceptionData
{
    HRESULT hr;
    BSTR    bstrDescription;
        // TODO: how much of this needs to stay here?  Ask Raja.
    BSTR    bstrSource;
    BSTR    bstrHelpFile;
    DWORD   dwHelpContext;
        GUID    guid;
};

void FreeExceptionData(ExceptionData *pedata);

class ExceptionNative
{
    struct GetClassNameArgs
    {
                DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_pThis);
    };

public:


    static LPVOID        __stdcall GetClassName(GetClassNameArgs *);
        static BOOL      IsException(EEClass* pClass);
        // NOTE: caller cleans up any partially initialized BSTRs in pED
    static void      GetExceptionData(OBJECTREF, ExceptionData *);

        // Note: these are on the PInvoke class to hide these from the user.
        static EXCEPTION_POINTERS*  __stdcall GetExceptionPointers(void* noArgs);
        static INT32     __stdcall GetExceptionCode(void* noArgs);
};


//
//
// GUID NATIVE
//
//

class GuidNative
{
    typedef struct {
                DECLARE_ECALL_PTR_ARG(GUID*, thisPtr);
        } _CompleteGuidArgs;
public:
    static INT32 __stdcall CompleteGuid(_CompleteGuidArgs *);

        static void FillGUIDFromObject(GUID *pguid, OBJECTREF const *prefGuid);

        static void FillObjectFromGUID(GUID* poutGuid, const GUID *pguid);

        static OBJECTREF CreateGuidObject(const GUID *pguid);
};


//
// BitConverter
//
class BitConverter {
private:
    static U1ARRAYREF __stdcall ByteCopyHelper(int arraySize, void *data);
public:

    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, value); 
    } _CharToBytesArgs;
    static LPVOID __stdcall CharToBytes(_CharToBytesArgs *);    

    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, value); 
    } _I2ToBytesArgs;
    static LPVOID __stdcall I2ToBytes(_I2ToBytesArgs *);    

    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, value); 
    } _IntToBytesArgs;
    static LPVOID __stdcall I4ToBytes(_IntToBytesArgs *);    

    typedef struct {
        DECLARE_ECALL_I8_ARG(INT64, value); 
    } _I8ToBytesArgs;
    static LPVOID __stdcall I8ToBytes(_I8ToBytesArgs *);    

    typedef struct {
        DECLARE_ECALL_I4_ARG(UINT32, value); 
    } _U2ToBytesArgs;
    static LPVOID __stdcall U2ToBytes(_U2ToBytesArgs *);    

    typedef struct {
        DECLARE_ECALL_I4_ARG(UINT32, value); 
    } _U4ToBytesArgs;
    static LPVOID __stdcall U4ToBytes(_U4ToBytesArgs *);    

    typedef struct {
        DECLARE_ECALL_I8_ARG(UINT64, value); 
    } _U8ToBytesArgs;
    static LPVOID __stdcall U8ToBytes(_U8ToBytesArgs *);    

    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, StartIndex); 
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, value); 
    } _BytesToXXArgs;
    static INT32 __stdcall BytesToChar(_BytesToXXArgs *);    
    static INT32 __stdcall BytesToI2(_BytesToXXArgs *);    
    static INT32 __stdcall BytesToI4(_BytesToXXArgs *);    
    static INT64 __stdcall BytesToI8(_BytesToXXArgs *);
    static UINT32 __stdcall BytesToU2(_BytesToXXArgs *);    
    static UINT32 __stdcall BytesToU4(_BytesToXXArgs *);    
    static UINT64 __stdcall BytesToU8(_BytesToXXArgs *);
    static R4 __stdcall BytesToR4(_BytesToXXArgs *);
    static R8 __stdcall BytesToR8(_BytesToXXArgs *);

    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, Length); 
        DECLARE_ECALL_I4_ARG(INT32, StartIndex); 
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, value); 
    } _BytesToStringArgs;
    static LPVOID __stdcall BytesToString(_BytesToStringArgs *);

    static WCHAR base64[];
    static FCDECL3(Object*, ByteArrayToBase64String, U1Array* pInArray, INT32 offset, INT32 length);
    static FCDECL1(Object*, Base64StringToByteArray, StringObject* pvInString);
    static FCDECL5(INT32, ByteArrayToBase64CharArray, U1Array* pInArray, INT32 offsetIn, INT32 length, CHARArray* pOutArray, INT32 offsetOut);
    static FCDECL3(Object*, Base64CharArrayToByteArray, CHARArray* pInCharArray, INT32 offset, INT32 length);
    
    static INT32 ConvertToBase64Array(WCHAR *outChars,U1 *inData,UINT offset,UINT length);
    static INT32 ConvertBase64ToByteArray(INT32 *value,WCHAR *c,UINT offset,UINT length, UINT* trueLength);
    static INT32 ConvertByteArrayToByteStream(INT32 *value,U1* b,UINT length);
};


//
// Buffer
//
class Buffer {
private:
    struct _GetByteArgs
    {
                DECLARE_ECALL_I4_ARG(INT32, index);
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, array);
    };

    struct _SetByteArgs
    {
                DECLARE_ECALL_I1_ARG(BYTE, value);
                DECLARE_ECALL_I4_ARG(INT32, index);
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, array);
    };

    struct _ArrayArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, array);
    };

public:
    
    // BlockCopy
    // This method from one primitive array to another based
    //      upon an offset into each an a byte count.
    static FCDECL5(VOID, BlockCopy, ArrayBase *src, int srcOffset, ArrayBase *dst, int dstOffset, int count);
    static FCDECL5(VOID, InternalBlockCopy, ArrayBase *src, int srcOffset, ArrayBase *dst, int dstOffset, int count);
    
    static BYTE __stdcall GetByte(const _GetByteArgs *);
    static void __stdcall SetByte(_SetByteArgs * args);
    static INT32 __stdcall ByteLength(const _ArrayArgs *);
};

class GCInterface {
private:
    static BOOL m_cacheCleanupRequired;
    static MethodDesc *m_pCacheMethod;

    public:
    static BOOL IsCacheCleanupRequired();
    static void CleanupCache();
    static void SetCacheCleanupRequired(BOOL);
    
        // The following structure is provided to the stack skip function.  It will
        // skip until the frame below the supplied stack crawl mark.
        struct SkipStruct {
            StackCrawlMark *stackMark;
            MethodDesc*     pMeth;
        };
    
        typedef struct {
    } _emptyArgs;

    typedef struct {
        DECLARE_ECALL_I4_ARG(LPVOID, handle);
    } _getGenerationWRArgs;
    static int __stdcall GetGenerationWR(_getGenerationWRArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
    } _getGenerationArgs;
    static int __stdcall GetGeneration(_getGenerationArgs *args);
    static FCDECL1 (VOID, KeepAlive, Object *obj);
    
    static INT64 __stdcall GetTotalMemory(_emptyArgs *args);
    
    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, generation);
    } _collectGenerationArgs;
    static void __stdcall CollectGeneration(_collectGenerationArgs *args);

    typedef struct {
        DECLARE_ECALL_I4_ARG(INT32, collect);
    } _setShutdownFinalizationArgs;
    static void __stdcall SetShutdownFinalization(_setShutdownFinalizationArgs *args);

    static int __stdcall GetShutdownFinalization(_emptyArgs *args); 
    static int __stdcall GetMaxGeneration(_emptyArgs *args); 
    static void __stdcall RunFinalizers(LPVOID /*no args*/);

        struct _InternalGetCurrentMethodArgs {
                DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        };

    static StackWalkAction SkipMethods(CrawlFrame*, VOID*);
        static LPVOID __stdcall InternalGetCurrentMethod(_InternalGetCurrentMethodArgs* args);

#ifdef FCALLAVAILABLE
    static FCDECL1(int, FCSuppressFinalize, Object *obj);
#else
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(Object*, obj);
    } _SuppressFinalizeArgs;
    static int __stdcall SuppressFinalize(_SuppressFinalizeArgs *args);
#endif

#ifdef FCALLAVAILABLE
    static FCDECL1(int, FCReRegisterForFinalize, Object *obj);
#else
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(Object*, obj);
    } _ReRegisterForFinalizeArgs;
    static int __stdcall ReRegisterForFinalize(_ReRegisterForFinalizeArgs *args);
#endif

    static FCDECL0(void, NativeSetCleanupCache);

};

class COMInterlocked
{
public:
        static FCDECL1(UINT32, Increment32, UINT32 *location);
        static FCDECL1(UINT32, Decrement32, UINT32 *location);
        static FCDECL1(UINT64, Increment64, UINT64 *location);
        static FCDECL1(UINT64, Decrement64, UINT64 *location);
        static FCDECL2(UINT32, Exchange, UINT32 *location, UINT32 value);
        static FCDECL3(LPVOID, CompareExchange, LPVOID* location, LPVOID value, LPVOID comparand);
        static FCDECL2(R4, ExchangeFloat, R4 *location, R4 value);
        static FCDECL3_IRR(R4, CompareExchangeFloat, R4 *location, R4 value, R4 comparand);
        static FCDECL2(LPVOID, ExchangeObject, LPVOID* location, LPVOID value);
        static FCDECL3(LPVOID, CompareExchangeObject, LPVOID* location, LPVOID value, LPVOID comparand);
};

class ManagedLoggingHelper {

public:
    static FCDECL5(INT32, GetRegistryLoggingValues, BOOL *bLoggingEnabled, BOOL *bLogToConsole, INT32 *bLogLevel, BOOL *bPerfWarnings, BOOL *bCorrectnessWarnings);
};


class ValueTypeHelper {
public:
    static FCDECL1(LPVOID, GetMethodTablePtr, Object* obj);
    static FCDECL1(BOOL, CanCompareBits, Object* obj);
    static FCDECL2(BOOL, FastEqualsCheck, Object* obj1, Object* obj2);
};

#endif _COMUTILNATIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comutilnative.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:  COMUtilNative
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A dumping ground for classes which aren't large
** enough to get their own file in the EE.
**
** Date:  April 8, 1998
** 
===========================================================*/
#include "common.h"
#include "object.h"
#include "excep.h"
#include "vars.hpp"
#include "COMString.h"
#include "COMUtilNative.h"
#include "COMStringCommon.h"
#include "ComCallWrapper.h"
#include <winnls.h>
#include "utilcode.h"
#include "frames.h"
#include "field.h"
#include "gcscan.h"
#include "ndirect.h"  // for NDirectOnUnicodeSystem
#include "WinWrap.h"  // For WszWideCharToMultiByte
#include "gc.h"
#include "fcall.h"
#include "COMClass.h"
#include "InvokeUtil.h"
#include "comcache.h"
#include "eeconfig.h"
#include "COMMember.h"

#define MANAGED_LOGGING_ENABLE   L"LogEnable"
#define MANAGED_LOGGING_CONSOLE  L"LogToConsole"
#define MANAGED_LOGGING_FACILITY L"ManagedLogFacility"
#define MANAGED_LOGGING_LEVEL    L"LogLevel"

#define MANAGED_PERF_WARNINGS    L"BCLPerfWarnings"
#define MANAGED_CORRECTNESS_WARNINGS  L"BCLCorrectnessWarnings"

#define STACK_OVERFLOW_MESSAGE   L"StackOverflowException"

//  #if _DEBUG

//  #define ObjectToOBJECTREF(obj)     (OBJECTREF((obj),0))
//  #define OBJECTREFToObject(objref)  (*( (Object**) &(objref) ))
//  #define ObjectToSTRINGREF(obj)     (STRINGREF((obj),0))

//  #else   //_DEBUG

//  #define ObjectToOBJECTREF(obj)    (obj)
//  #define OBJECTREFToObject(objref) (objref)
//  #define ObjectToSTRINGREF(obj)    (obj)

//  #endif  //_DEBUG

// Prototype for m_memmove, which is defined in COMSystem.cpp and used here
// by Buffer's BlockCopy & InternalBlockCopy methods.
void m_memmove(BYTE* dmem, BYTE* smem, int size);

//
// GCPROTECT Helper Structs
//
typedef struct {
    OBJECTREF o1;
    STRINGREF s1;
    STRINGREF s2;
} ProtectTwoObjs;

struct Protect2Objs
{
    OBJECTREF o1;
    OBJECTREF o2;
};

struct Protect3Objs
{
    OBJECTREF o1;
    OBJECTREF o2;
    OBJECTREF o3;
};


//These are defined in System.ParseNumbers and should be kept in sync.
#define PARSE_TREATASUNSIGNED 0x200
#define PARSE_TREATASI1 0x400
#define PARSE_TREATASI2 0x800
#define PARSE_ISTIGHT 0x1000

// This is the global access
//InvokeUtil* g_pInvokeUtil = 0;

//
//
// COMCharacter and Helper functions
//
//


/*============================GetCharacterInfoHelper============================
**Determines character type info (digit, whitespace, etc) for the given char.
**Args:   c is the character on which to operate.
**        CharInfoType is one of CT_CTYPE1, CT_CTYPE2, CT_CTYPE3 and specifies the type
**        of information being requested.
**Returns: The bitmask returned by GetStringTypeEx.  The caller needs to know
**         how to interpret this.
**Exceptions: ArgumentException if GetStringTypeEx fails.
==============================================================================*/
INT32 GetCharacterInfoHelper(WCHAR c, INT32 CharInfoType) {
  unsigned short result=0;

  //If we're running on NT or something similarly intelligent
  if (OnUnicodeSystem()) {
    if (!GetStringTypeEx(LOCALE_USER_DEFAULT, CharInfoType, &(c), 1, &result)) {
      _ASSERTE(!"This should not happen, verify the arguments passed to GetStringTypeEx()");
    }
    return (INT32)result;
  }

  //If we're running on Win9x.
  char MBChar[3];
  int length;
  if (0==(length=WszWideCharToMultiByte(CP_ACP, 0, &c, 1, MBChar, 3, NULL, NULL))) {
      _ASSERTE(!"This should not happen, verify the arguments passed to WszWideCharToMultiByte()");
  }
  //We're relying on GetStringTypeExA being able to tell that MBChar is actually a multibyte char
  //and handling it appropriately.
  if (!GetStringTypeExA(LOCALE_USER_DEFAULT, CharInfoType, MBChar, 1, &result)) {
      _ASSERTE(!"This should not happen, verify the arguments passed to GetStringTypeExA()");
  }

  return (INT32)result;  
}


/*=============================CaseConversionHelper=============================
**Converts c to the appropriate case and returns the result.  This is locale and platform 
**aware.  Currently, we do some extremely inefficient mappings on Win95 that 
**should be eliminated.
**
**Args:     c is the character to be converted.
**          conversionType is LCMAP_UPPERCASE or LCMAP_LOWERCASE.
**Returns:  c converted to the appropriate case or c if c cannot be converted.
**Exceptions:  ArgumentException if any of the Win32 functions fail.
==============================================================================*/
WCHAR CaseConversionHelper(WCHAR c, INT32 conversionType) {
  WCHAR result;

  THROWSCOMPLUSEXCEPTION();

#ifdef PLATFORM_CE

  if (0==LCMapString(LOCALE_USER_DEFAULT, conversionType, &(c), 1, &result, 1)) 
  {
      COMPlusThrow(kArgumentException, L"Argument_ConversionOverflow");
  }
  return result;

#else // !PLATFORM_CE

  int length;
  char MBChar[3];
  
  //If we're running on NT or something similarly Unicode aware.
  if (OnUnicodeSystem()) {
    if (0==LCMapString(LOCALE_USER_DEFAULT, conversionType, &(c), 1, &result, 1)) {
      COMPlusThrow(kArgumentException, L"Argument_ConversionOverflow");
    }
    return result;
  }

  //If we're running on Win9x.
  if (0==(WszWideCharToMultiByte(CP_ACP, 0, &(c), 1, MBChar, 3, NULL, NULL))) {
    COMPlusThrow(kArgumentException, L"Argument_ConversionOverflow");
  }

  if (0==(length=LCMapStringA(LOCALE_USER_DEFAULT, conversionType, MBChar, 1, MBChar, 3))) {
    COMPlusThrow(kArgumentException, L"Argument_ConversionOverflow");
  }

  if (0==(WszMultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, MBChar, length, &result, 1))) {
    COMPlusThrow(kArgumentException, L"Argument_ConversionOverflow");
  }
  return result;

#endif // !PLATFORM_CE

}


/*==============================nativeIsWhiteSpace==============================
**The locally available version of IsWhiteSpace.  Designed to be called by other
**native methods.  The work is mostly done by GetCharacterInfoHelper
**Args:  c -- the character to check.
**Returns: true if c is whitespace, false otherwise.
**Exceptions:  Only those thrown by GetCharacterInfoHelper.
==============================================================================*/
BOOL COMCharacter::nativeIsWhiteSpace(WCHAR c) {
  return ((GetCharacterInfoHelper(c, CT_CTYPE1) & C1_SPACE)!=0);
}

/*================================nativeIsDigit=================================
**The locally available version of IsDigit.  Designed to be called by other
**native methods.  The work is mostly done by GetCharacterInfoHelper
**Args:  c -- the character to check.
**Returns: true if c is whitespace, false otherwise.
**Exceptions:  Only those thrown by GetCharacterInfoHelper.
==============================================================================*/
BOOL COMCharacter::nativeIsDigit(WCHAR c) {
  int result;
  return ((((result=GetCharacterInfoHelper(c, CT_CTYPE1))& C1_DIGIT)!=0));
}

/*==================================ToString====================================
**Creates a single character string from the specified character and returns it.
**Args:   typedef struct {WCHAR c;} _oneCharArgs;
**        c is the character convert to a string.
**Returns:  The new string containing c.
**Exceptions:  Any exception the allocator can throw.
==============================================================================*/
LPVOID COMCharacter::ToString(_oneCharArgs *args) {
    STRINGREF pString;

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    pString = AllocateString(2);

    pString->SetStringLength(1);
    pString->GetBuffer()[0] = args->c;
    _ASSERTE(pString->GetBuffer()[1] == 0);
    
    RETURN(pString, STRINGREF);
}

/*================================nativeToUpper=================================
**Converts c toUppercase and returns the result.  This is locale and platform 
**aware.  Currently, we do some extremely inefficient mappings on Win95 that 
**should be eliminated.
**
**Args:   typedef struct {WCHAR c;} _oneCharArgs;
**        c is the character to be converted.
**Returns:  c converted to an uppercase character or c.
**Exceptions:  ArgumentException if any of the Win32 functions fail.
==============================================================================*/
WCHAR COMCharacter::nativeToUpper(WCHAR c) {

  if (c < 0x80) { //If we're in 7-bit ascii we can optimize
    if (c>='a' && c <='z') {
      return c + 'A' - 'a';
    }
    return c;
  }
  return CaseConversionHelper(c, LCMAP_UPPERCASE);
}

/*================================nativeToLower=================================
**Converts c to lower case and returns the result.  This is locale and platform 
**aware.  Currently, we do some extremely inefficient mappings on Win95 that 
**should be eliminated.
**
**Args:   typedef struct {WCHAR c;} _oneCharArgs;
**        c is the character to be converted.
**Returns:  c converted to an lowercase character or c if c cannot be converted.
**Exceptions:  ArgumentException if any of the Win32 functions fail.
==============================================================================*/
WCHAR COMCharacter::nativeToLower(WCHAR c) {

  if (c < 0x80) { //If we're in 7-bit ascii we can optimize
      if (c>='A' && c<='Z') {
          return c + 'a' - 'A';
      }
      return c;
  }
  return CaseConversionHelper(c, LCMAP_LOWERCASE);
}




//
//
// PARSENUMBERS (and helper functions)
//
//

/*===================================IsDigit====================================
**Returns a boolean indicating whether the character passed in represents a   **
**digit.
==============================================================================*/
boolean IsDigit(WCHAR c, int radix, int *result) {
    if (c>='0' && c<='9') {
        *result = c-'0'; 
    } else {
        WCHAR d = COMCharacter::nativeToLower(c);
        if (d>='a' && d<='z') {
            //+10 is necessary because a is actually 10, etc.
            *result = d-'a'+10;
        } else {
            *result = -1;
        }
    }
    if ((*result >=0) && (*result < radix)) {
        return true;
    }
    return false;
}

// simple helper 

INT32 wtoi(WCHAR* wstr, DWORD length)
{   
    DWORD i = 0;
    int value;
    INT32 result = 0;

    while (i<length&&(IsDigit(wstr[i], 10 ,&value))) 
    {
        //Read all of the digits and convert to a number      
      result = result*10 + value;
      i++;
    }      

    return result;
}

//
//
// Formatting Constants
//
//

/*===================================GrabInts===================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
INT32 ParseNumbers::GrabInts(const INT32 radix, WCHAR *buffer, const int length, int *i, BOOL isUnsigned) {
  _ASSERTE(buffer);
  _ASSERTE(i && *i>=0);
  THROWSCOMPLUSEXCEPTION();
  UINT32 result=0;
  int value;
  UINT32 maxVal;

  _ASSERTE(radix==2 || radix==8 || radix==10 || radix==16);

  // Allow all non-decimal numbers to set the sign bit.
  if (radix==10 && !isUnsigned) {
      maxVal = (0x7FFFFFFF / 10);
      while (*i<length&&(IsDigit(buffer[*i],radix,&value))) {  //Read all of the digits and convert to a number
          // Check for overflows - this is sufficient & correct.
          if (result > maxVal || ((INT32)result)<0)
              COMPlusThrow(kOverflowException, L"Overflow_Int32");
          result = result*radix + value;
          (*i)++;
      }
      if ((INT32)result<0 && result!=0x80000000) {
          COMPlusThrow(kOverflowException, L"Overflow_Int32");
      }
  } else {
      maxVal = ((UINT32) -1) / radix;
      while (*i<length&&(IsDigit(buffer[*i],radix,&value))) {  //Read all of the digits and convert to a number
          // Check for overflows - this is sufficient & correct.
          if (result > maxVal)
              COMPlusThrow(kOverflowException, L"Overflow_UInt32");
          result = result*radix + value;
          (*i)++;
      }
  }      
  return (INT32) result;
}

/*==================================GrabLongs===================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
INT64 ParseNumbers::GrabLongs(const INT32 radix, WCHAR *buffer, const int length, int *i, BOOL isUnsigned) {
  _ASSERTE(buffer);
  _ASSERTE(i && *i>=0);
  THROWSCOMPLUSEXCEPTION();
  UINT64 result=0;
  int value;
  UINT64 maxVal;

  // Allow all non-decimal numbers to set the sign bit.
  if (radix==10 && !isUnsigned) {
      maxVal = (0x7FFFFFFFFFFFFFFF / 10);
      while (*i<length&&(IsDigit(buffer[*i],radix,&value))) {  //Read all of the digits and convert to a number
          // Check for overflows - this is sufficient & correct.
          if (result > maxVal || ((INT64)result)<0)
              COMPlusThrow(kOverflowException, L"Overflow_Int64");
          result = result*radix + value;
          (*i)++;
      }
      if ((INT64)result<0 && result!=0x8000000000000000) {
          COMPlusThrow(kOverflowException, L"Overflow_Int64");
      }
  } else {
      maxVal = ((UINT64) -1L) / radix;
      while (*i<length&&(IsDigit(buffer[*i],radix,&value))) {  //Read all of the digits and convert to a number
          // Check for overflows - this is sufficient & correct.
          if (result > maxVal)
              COMPlusThrow(kOverflowException, L"Overflow_UInt64");
          result = result*radix + value;
          (*i)++;
      }
  }      
  return (INT64) result;
}

/*================================EatWhiteSpace=================================
**
==============================================================================*/
void EatWhiteSpace(WCHAR *buffer, int length, int *i) {
  for (; *i<length && COMCharacter::nativeIsWhiteSpace(buffer[*i]); (*i)++);
}

/*================================LongToString==================================
**Args:typedef struct {INT32 flags; WCHAR paddingChar; INT32 width; INT32 radix; INT64 l} _LongToStringArgs;
==============================================================================*/
FCIMPL5(LPVOID, ParseNumbers::LongToString, INT32 radix, INT32 width, INT64 n, WCHAR paddingChar, INT32 flags)
{
    LPVOID rv;

    HELPER_METHOD_FRAME_BEGIN_RET_0();

    THROWSCOMPLUSEXCEPTION();

    boolean isNegative = false;
    int index=0;
    int numLength=0;
    int charVal;
    UINT64 l;
    INT32 i;
    INT32 buffLength=0;
    WCHAR buffer[67];//Longest possible string length for an integer in binary notation with prefix

    if (radix<MinRadix || radix>MaxRadix) {
        COMPlusThrowArgumentException(L"radix", L"Arg_InvalidBase");
    }

    //If the number is negative, make it positive and remember the sign.
    if (n<0) { 
        isNegative=true;
        // For base 10, write out -num, but other bases write out the
        // 2's complement bit pattern
        if (10==radix)
            l = (UINT64)(-n);
        else
            l = (UINT64)n;
    } else {
        l=(UINT64)n;
    }

    if (flags&PrintAsI1) {
        l = l&0xFF;
    } else if (flags&PrintAsI2) {
        l = l&0xFFFF;
    } else if (flags&PrintAsI4) {
        l=l&0xFFFFFFFF;
    }
  
    //Special case the 0.
    if (0==l) { 
        buffer[0]='0';
        index=1;
    } else {
        //Pull apart the number and put the digits (in reverse order) into the buffer.
        for (index=0; l>0; l=l/radix, index++) {  
            if ((charVal=(int)(l%radix))<10) {
                buffer[index] = (WCHAR)(charVal + '0');
            } else {
                buffer[index] = (WCHAR)(charVal + 'a' - 10);
            }
        }
    }

    //If they want the base, append that to the string (in reverse order)
    if (radix!=10 && ((flags&PrintBase)!=0)) {  
        if (16==radix) {
            buffer[index++]='x';
            buffer[index++]='0';
        } else if (8==radix) {
            buffer[index++]='0';
        } else if ((flags&PrintRadixBase)!=0) {
            buffer[index++]='#';
            buffer[index++]=((radix%10)+'0');
            buffer[index++]=((radix/10)+'0');
        }
    }
  
    if (10==radix) {
        if (isNegative) {               //If it was negative, append the sign.
            buffer[index++]='-';
        } else if ((flags&PrintSign)!=0) {   //else if they requested, add the '+';
            buffer[index++]='+';
        } else if ((flags&PrefixSpace)!=0) {  //If they requested a leading space, put it on.
            buffer[index++]=' ';
        }
    }

    //Figure out the size of our string.  
    if (width<=index) {
        buffLength=index;
    } else {
        buffLength=width;
    }

    STRINGREF Local = COMString::NewString(buffLength);
    WCHAR *LocalBuffer = Local->GetBuffer();

    //Put the characters into the String in reverse order
    //Fill the remaining space -- if there is any -- 
    //with the correct padding character.
    if ((flags&LeftAlign)!=0) {
        for (i=0; i<index; i++) {
            LocalBuffer[i]=buffer[index-i-1];
        }
        for (;i<buffLength; i++) {
            LocalBuffer[i]=paddingChar;
        }
    } else {
        for (i=0; i<index; i++) {
            LocalBuffer[buffLength-i-1]=buffer[i];
        }
        for (int j=buffLength-i-1; j>=0; j--) {
            LocalBuffer[j]=paddingChar;
        }
    }

    *((STRINGREF *)&rv)=Local;
  
    HELPER_METHOD_FRAME_END();
  
    return rv;
}
FCIMPLEND


/*==============================IntToDecimalString==============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL1(LPVOID, ParseNumbers::IntToDecimalString, INT32 n)
{
    LPVOID result;

    HELPER_METHOD_FRAME_BEGIN_RET_0();

   boolean isNegative = false;
    int index=0;
    int numLength=0;
    int charVal;
    WCHAR buffer[66];
    UINT32 l;
  
    //If the number is negative, make it positive and remember the sign.
    //If the number is MIN_VALUE, this will still be negative, so we'll have to
    //special case this later.
    if (n<0) { 
        isNegative=true;
        l=(UINT32)(-n);
    } else {
        l=(UINT32)n;
    }

    if (0==l) { //Special case the 0.
        buffer[0]='0';
        index=1;
    } else {
        do {
            charVal = l%10;
            l=l/10;
            buffer[index++]=(WCHAR)(charVal+'0');
        } while (l!=0);
    }
  
    if (isNegative) {               //If it was negative, append the sign.
        buffer[index++]='-';
    }
    
    STRINGREF Local = COMString::NewString(index);
    WCHAR *LocalBuffer = Local->GetBuffer();
    for (int j=0; j<index; j++) {
        LocalBuffer[j]=buffer[index-j-1];
    }

    result = OBJECTREFToObject(Local);

    HELPER_METHOD_FRAME_END();

    return result;
}
FCIMPLEND

FCIMPL5(LPVOID, ParseNumbers::IntToString, INT32 n, INT32 radix, INT32 width, WCHAR paddingChar, INT32 flags);
{
    LPVOID rv;

    HELPER_METHOD_FRAME_BEGIN_RET_0();

    THROWSCOMPLUSEXCEPTION();

    boolean isNegative = false;
    int index=0;
    int charVal;
    int buffLength;
    int i;
    UINT32 l;
    WCHAR buffer[66];  //Longest possible string length for an integer in binary notation with prefix

    if (radix<MinRadix || radix>MaxRadix) {
        COMPlusThrowArgumentException(L"radix", L"Arg_InvalidBase");
    }
  
    //If the number is negative, make it positive and remember the sign.
    //If the number is MIN_VALUE, this will still be negative, so we'll have to
    //special case this later.
    if (n<0) { 
        isNegative=true;
        // For base 10, write out -num, but other bases write out the
        // 2's complement bit pattern
        if (10==radix)
            l = (UINT32)(-n);
        else
            l = (UINT32)n;
    } else {
        l=(UINT32)n;
    }

    //The conversion to a UINT will sign extend the number.  In order to ensure
    //that we only get as many bits as we expect, we chop the number.
    if (flags&PrintAsI1) {
        l = l&0xFF;
    } else if (flags&PrintAsI2) {
        l = l&0xFFFF;
    } else if (flags&PrintAsI4) {
        l=l&0xFFFFFFFF;
    }
  
    if (0==l) { //Special case the 0.
        buffer[0]='0';
        index=1;
    } else {
        do {
            charVal = l%radix;
            l=l/radix;
            if (charVal<10) {
                buffer[index++] = (WCHAR)(charVal + '0');
            } else {
                buffer[index++] = (WCHAR)(charVal + 'a' - 10);
            }
        } while (l!=0);
    }
    if (radix!=10 && ((flags&PrintBase)!=0)) {  //If they want the base, append that to the string (in reverse order)
        if (16==radix) {
            buffer[index++]='x';
            buffer[index++]='0';
        } else if (8==radix) {
            buffer[index++]='0';
        }
    }
  
    if (10==radix) {
        if (isNegative) {               //If it was negative, append the sign.
            buffer[index++]='-';
        } else if ((flags&PrintSign)!=0) {   //else if they requested, add the '+';
            buffer[index++]='+';
        } else if ((flags&PrefixSpace)!=0) {  //If they requested a leading space, put it on.
            buffer[index++]=' ';
        }
    }

    //Figure out the size of our string.  
    if (width<=index) {
        buffLength=index;
    } else {
        buffLength=width;
    }

    STRINGREF Local = COMString::NewString(buffLength);
    WCHAR *LocalBuffer = Local->GetBuffer();

    //Put the characters into the String in reverse order
    //Fill the remaining space -- if there is any -- 
    //with the correct padding character.
    if ((flags&LeftAlign)!=0) {
        for (i=0; i<index; i++) {
            LocalBuffer[i]=buffer[index-i-1];
        }
        for (;i<buffLength; i++) {
            LocalBuffer[i]=paddingChar;
        }
    } else {
        for (i=0; i<index; i++) {
            LocalBuffer[buffLength-i-1]=buffer[i];
        }
        for (int j=buffLength-i-1; j>=0; j--) {
            LocalBuffer[j]=paddingChar;
        }
    }

    *((STRINGREF *)&rv)=Local;
  
    HELPER_METHOD_FRAME_END();
  
    return rv;
}
FCIMPLEND


/*===================================FixRadix===================================
**It's possible that we parsed the radix in a base other than 10 by accident.
**This method will take that number, verify that it only contained valid base 10
**digits, and then do the conversion to base 10.  If it contained invalid digits,
**they tried to pass us a radix such as 1A, so we throw a FormatException.
**
**Args: oldVal: The value that we had actually parsed in some arbitrary base.
**      oldBase: The base in which we actually did the parsing.
**
**Returns:  oldVal as if it had been parsed as a base-10 number.
**Exceptions: FormatException if either of the digits in the radix aren't
**            valid base-10 numbers.
==============================================================================*/
int FixRadix(int oldVal, int oldBase) {
    THROWSCOMPLUSEXCEPTION();
    int firstDigit = (oldVal/oldBase);
    int secondDigit = (oldVal%oldBase);
    if ((firstDigit>=10) || (secondDigit>=10)) {
        COMPlusThrow(kFormatException, L"Format_BadBase");
    }
    return (firstDigit*10)+secondDigit;
}

/*=================================StringToLong=================================
**Action:
**Returns:
**Exceptions:
==============================================================================*/
FCIMPL4(INT64, ParseNumbers::StringToLong, StringObject * s, INT32 radix, INT32 flags, I4Array *currPos)
{
  INT64 result = 0;

  HELPER_METHOD_FRAME_BEGIN_RET_2(s, currPos);
  
  int sign = 1;
  boolean radixChanged = false;
  WCHAR *input;
  int length;
  int i;
  int grabNumbersStart=0;
  INT32 r;

  THROWSCOMPLUSEXCEPTION();

  _ASSERTE((flags & PARSE_TREATASI1) == 0 && (flags & PARSE_TREATASI2) == 0);

  if (s) {
      //They're required to tell me where to start parsing.
      i = currPos->m_Array[0];  

      //Do some radix checking.
      //A radix of -1 says to use whatever base is spec'd on the number.
      //Parse in Base10 until we figure out what the base actually is.
      r = (-1==radix)?10:radix;

      if (r!=2 && r!=10 && r!=8 && r!=16) {
          COMPlusThrow(kArgumentException, L"Arg_InvalidBase");
      }

      RefInterpretGetStringValuesDangerousForGC(s, &input, &length);
 

      if (i<0 || i>=length) {
          COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
      }

      //Get rid of the whitespace and then check that we've still got some digits to parse.
      if (!(flags & PARSE_ISTIGHT)) {
          EatWhiteSpace(input,length,&i);
          if (i==length) {
              COMPlusThrow(kFormatException, L"Format_EmptyInputString");
          }
      }

  
      if (input[i]=='-') { //Check for a sign
	      if (r != 10) {
	            COMPlusThrow(kArgumentException, L"Arg_CannotHaveNegativeValue");
	      }
          if (flags & PARSE_TREATASUNSIGNED) {
              COMPlusThrow(kOverflowException, L"Overflow_NegativeUnsigned");
          }
          sign = -1;
          i++;
      } else if (input[i]=='+') {
          i++;
      }

      if ((radix==-1 || radix==16) && (i+1<length) && input[i]=='0') {
          if (input[i+1]=='x' || input [i+1]=='X') {
              r=16;
              i+=2;
          }
      }

      grabNumbersStart=i;
      result = GrabLongs(r,input,length,&i, (flags & PARSE_TREATASUNSIGNED));
      //Check if they passed us a string with no parsable digits.
      if (i==grabNumbersStart) {
          COMPlusThrow(kFormatException, L"Format_NoParsibleDigits");
      }

      if (flags & PARSE_ISTIGHT) {
          //If we've got effluvia left at the end of the string, complain.
          if (i<length) { 
              COMPlusThrow(kFormatException, L"Format_ExtraJunkAtEnd");
          }
      }

      //Put the current index back into the correct place. 
      currPos->m_Array[0]=i;
  
      //Return the value properly signed.
      if (result==0x8000000000000000 && sign==1 && r==10) {
          COMPlusThrow(kOverflowException, L"Overflow_Int64");
      }

      if (r == 10)
	      result *= sign;
    }
    else {
      result = 0;
    }


  HELPER_METHOD_FRAME_END();

  return result;
}
FCIMPLEND

/*=================================StringToInt==================================
**Action:
**Returns:
**Exceptions:
==============================================================================*/
FCIMPL4(INT32, ParseNumbers::StringToInt, StringObject * s, INT32 radix, INT32 flags, I4Array *currPos)
{
  INT32 result = 0;

  HELPER_METHOD_FRAME_BEGIN_RET_2(s, currPos);
  
  int sign = 1;
  boolean radixChanged = false;
  WCHAR *input;
  int length;
  int i;
  int grabNumbersStart=0;
  INT32 r;

  THROWSCOMPLUSEXCEPTION();

  // TreatAsI1 and TreatAsI2 are mutually exclusive.
  _ASSERTE(!((flags & PARSE_TREATASI1) != 0 && (flags & PARSE_TREATASI2) != 0));

  if (s) {
      //They're requied to tell me where to start parsing.
      i = currPos->m_Array[0];  

      //Do some radix checking.
      //A radix of -1 says to use whatever base is spec'd on the number.
      //Parse in Base10 until we figure out what the base actually is.
      r = (-1==radix)?10:radix;

      if (r!=2 && r!=10 && r!=8 && r!=16) {
          COMPlusThrow(kArgumentException, L"Arg_InvalidBase");
      }

      RefInterpretGetStringValuesDangerousForGC(s, &input, &length);
 

      if (i<0 || i>=length) {
          COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
      }

      //Get rid of the whitespace and then check that we've still got some digits to parse.
      if (!(flags & PARSE_ISTIGHT)) {
          EatWhiteSpace(input,length,&i);
          if (i==length) {
              COMPlusThrow(kFormatException, L"Format_EmptyInputString");
          }
      }

  
      if (input[i]=='-') { //Check for a sign
	       if (r != 10) {
	            COMPlusThrow(kArgumentException, L"Arg_CannotHaveNegativeValue");
	      }
          if (flags & PARSE_TREATASUNSIGNED) {
              COMPlusThrow(kOverflowException, L"Overflow_NegativeUnsigned");
          }
          sign = -1;
          i++;
      } else if (input[i]=='+') {
          i++;
      }
  
      //Consume the 0x if we're in an unknown base or in base-16.
      if ((radix==-1||radix==16) && (i+1<length) && input[i]=='0') {
          if (input[i+1]=='x' || input [i+1]=='X') {
              r=16;
              i+=2;
          }
      }

      grabNumbersStart=i;
      result = GrabInts(r,input,length,&i, (flags & PARSE_TREATASUNSIGNED));
      //Check if they passed us a string with no parsable digits.
      if (i==grabNumbersStart) {
          COMPlusThrow(kFormatException, L"Format_NoParsibleDigits");
      }

      if (flags & PARSE_ISTIGHT) {
          //      EatWhiteSpace(input,length,&i);
          //If we've got effluvia left at the end of the string, complain.
          if (i<(length)) { 
              COMPlusThrow(kFormatException, L"Format_ExtraJunkAtEnd");
          }
      }

      //Put the current index back into the correct place. 
      currPos->m_Array[0]=i;
  
      //Return the value properly signed.
      if (flags & PARSE_TREATASI1) {
          if ((UINT32)result > 0xFF)
              COMPlusThrow(kOverflowException, L"Overflow_SByte");
          _ASSERTE(sign==1 || r==10);  // result looks positive when parsed as an I4
          if (result >= 0x80)
              sign = -1;
      }
      else if (flags & PARSE_TREATASI2) {
          if ((UINT32)result > 0xFFFF)
              COMPlusThrow(kOverflowException, L"Overflow_Int16");
          _ASSERTE(sign==1 || r==10);  // result looks positive when parsed as an I4
          if (result >= 0x8000)
              sign = -1;
      }
      else if (result==0x80000000 && sign==1 && r==10) {
          COMPlusThrow(kOverflowException, L"Overflow_Int32");
      }
 
      if (r == 10)
	      result *= sign;
  }
  else {
      result = 0;
  }

  HELPER_METHOD_FRAME_END();
  
  return result;
}
FCIMPLEND

/*==============================RadixStringToLong===============================
**Args:typedef struct {I4ARRAYREF currPos; INT32 isTight; INT32 radix; STRINGREF s} _StringToIntArgs;
==============================================================================*/
FCIMPL4(INT64, ParseNumbers::RadixStringToLong, StringObject *s, INT32 radix, INT32 isTight, I4Array *currPos)
{
  INT64 result=0;

  HELPER_METHOD_FRAME_BEGIN_RET_2(s, currPos);
  
  int sign = 1;
  boolean radixChanged = false;
  WCHAR *input;
  int length;
  int i;
  int grabNumbersStart=0;
  INT32 r;


  THROWSCOMPLUSEXCEPTION();

  if (s) {
      //They're requied to tell me where to start parsing.
      i = currPos->m_Array[0];  

      //Do some radix checking.
      //A radix of -1 says to use whatever base is spec'd on the number.
      //Parse in Base10 until we figure out what the base actually is.
      r = (-1==radix)?10:radix;

      if (r<MinRadix || r > MaxRadix) {
          COMPlusThrow(kArgumentException, L"Argument_InvalidRadix");
      }

      RefInterpretGetStringValuesDangerousForGC(s, &input, &length);
 

      if (i<0 || i>=length) {
          COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
      }

      //Get rid of the whitespace and then check that we've still got some digits to parse.
      if (!isTight) {
          EatWhiteSpace(input,length,&i);
          if (i==length) {
              COMPlusThrow(kFormatException, L"Format_EmptyInputString");
          }
      }

  
      if (input[i]=='-') { //Check for a sign
        sign = -1;
        i++;
      } else if (input[i]=='+') {
          i++;
      }

      if (radix==-1) {
          if ((length>i+2)&&(('#'==input[i+1])||('#'==input[i+2]))) {
              grabNumbersStart=i;
              result=GrabInts(r,input,length,&i, 0);
              if (i==grabNumbersStart || input[i]!='#') {
                  COMPlusThrow(kFormatException, L"Format_NoParsibleDigits");
              }
              if (result<MinRadix || r > MaxRadix) {
                  COMPlusThrowArgumentException(L"radix", L"Arg_InvalidBase");
              }
              //We know because we called GrabInts that it's never outside of this range.
              r=(INT32)result;
              i++;
              //Do the grab numbers and check.
          } else if (length>(i+1)&&input[i]=='0') {
              if (input[i+1]=='x' || input [i+1]=='X') {
                  r=16;
                  i+=2;
              } else if (COMCharacter::nativeIsDigit(input[i+1])) {
                  r=8;
                  i++;
              }
          }
      }

      grabNumbersStart=i;
      result = GrabLongs(r,input,length,&i,0);
      //Check if they passed us a string with no parsable digits.
      if (i==grabNumbersStart) {
          COMPlusThrow(kFormatException, L"Format_NoParsibleDigits");
      }

      if (isTight) {
          //      EatWhiteSpace(input,length,&i);
          //If we've got effluvia left at the end of the string, complain.
          if (i<(length-1)) { 
              COMPlusThrow(kFormatException, L"Format_ExtraJunkAtEnd");
          }
      }

      //Put the current index back into the correct place. 
      currPos->m_Array[0]=i;
  
      //Return the value properly signed.
      result *= sign;
  } else {
      result = 0;
  }

  HELPER_METHOD_FRAME_END();
  
  return result;
  
}
FCIMPLEND

//
//
// EXCEPTION NATIVE
//
//
LPVOID __stdcall ExceptionNative::GetClassName(GetClassNameArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT(pargs != NULL);
    ASSERT(pargs->m_pThis != NULL);

    STRINGREF s;

    // get full class name
    DefineFullyQualifiedNameForClass();
    LPUTF8 sz = GetFullyQualifiedNameForClass(pargs->m_pThis->GetClass());
    if (sz == NULL)
        COMPlusThrowOM();

    // create COM+ string
    // make Wide String from a ansi string!
    s = COMString::NewString(sz);

    // force the stringref into an LPVOID
    RETURN(s, STRINGREF);
}

BSTR BStrFromString(STRINGREF s)
{
    WCHAR *wz;
    int cch;
    BSTR bstr;

    THROWSCOMPLUSEXCEPTION();

    if (s == NULL) {
        return NULL;
    }

    RefInterpretGetStringValuesDangerousForGC(s, &wz, &cch);
    
    bstr = SysAllocString(wz);
    if (bstr == NULL) {
        COMPlusThrowOM();
    }
    return bstr;
}


static HRESULT GetExceptionHResult(OBJECTREF objException) {
    _ASSERTE(objException != NULL);
    _ASSERTE(ExceptionNative::IsException(objException->GetClass()));

    FieldDesc *pFD = g_Mscorlib.GetField(FIELD__EXCEPTION__HRESULT);

    return pFD->GetValue32(objException);
}

static BSTR
GetExceptionDescription(OBJECTREF objException) {
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(objException != NULL);
    _ASSERTE(ExceptionNative::IsException(objException->GetClass()));

    BSTR bstrDescription;

    STRINGREF MessageString = NULL;
    GCPROTECT_BEGIN(MessageString)
    GCPROTECT_BEGIN(objException)
    {
        // read Exception.Message property
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__EXCEPTION__GET_MESSAGE);

        INT64 GetMessageArgs[] = { ObjToInt64(objException) };
        MessageString = (STRINGREF)Int64ToObj(pMD->Call(GetMessageArgs, METHOD__EXCEPTION__GET_MESSAGE));

        // if the message string is empty then use the exception classname.
        if (MessageString == NULL || MessageString->GetStringLength() == 0)
        {
            // call GetClassName
            pMD = g_Mscorlib.GetMethod(METHOD__EXCEPTION__GET_CLASS_NAME);
            INT64 GetClassNameArgs[] = { ObjToInt64(objException) };
            MessageString = (STRINGREF)Int64ToObj(pMD->Call(GetClassNameArgs, METHOD__EXCEPTION__GET_CLASS_NAME));
            _ASSERTE(MessageString != NULL && MessageString->GetStringLength() != 0);
        }

        // Allocate the description BSTR.
        int DescriptionLen = MessageString->GetStringLength();
        bstrDescription = SysAllocStringLen(MessageString->GetBuffer(), DescriptionLen);
    }
    GCPROTECT_END();
    GCPROTECT_END();

    return bstrDescription;
}

static BSTR
GetExceptionSource(OBJECTREF objException) {

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(objException != NULL);
    _ASSERTE(ExceptionNative::IsException(objException->GetClass()));

    // read Exception.Source property
    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__EXCEPTION__GET_SOURCE);

    INT64 GetSourceArgs[] = { ObjToInt64(objException) };
    return BStrFromString((STRINGREF)Int64ToObj(pMD->Call(GetSourceArgs, METHOD__EXCEPTION__GET_SOURCE)));
}

static void
GetExceptionHelp(OBJECTREF objException, BSTR *pbstrHelpFile, DWORD *pdwHelpContext) {

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(objException != NULL);
    _ASSERTE(ExceptionNative::IsException(objException->GetClass()));
    _ASSERTE(pbstrHelpFile);
    _ASSERTE(pdwHelpContext);

    *pdwHelpContext = 0;

    // read Exception.HelpLink property
    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__EXCEPTION__GET_HELP_LINK);

    INT64 GetHelpLinkArgs[] = { ObjToInt64(objException) };
    *pbstrHelpFile = BStrFromString((STRINGREF)Int64ToObj(pMD->Call(GetHelpLinkArgs, 
                                                                    METHOD__EXCEPTION__GET_HELP_LINK)));

    // parse the help file to check for the presence of helpcontext
    int len = SysStringLen(*pbstrHelpFile);
    int pos = len;
    WCHAR *pwstr = *pbstrHelpFile;
    if (pwstr)
    {
        BOOL fFoundPound = FALSE;

        for (pos = len - 1; pos >= 0; pos--)
        {
            if (pwstr[pos] == L'#')
            {
                fFoundPound = TRUE;
                break;
            }
        }

        if (fFoundPound)
        {
            int PoundPos = pos;
            int NumberStartPos = -1;
            BOOL bNumberStarted = FALSE;
            BOOL bNumberFinished = FALSE;
            BOOL bInvalidDigitsFound = FALSE;

            _ASSERTE(pwstr[pos] == L'#');
        
            // Check to see if the string to the right of the pound a valid number.
            for (pos++; pos < len; pos++)
            {
                if (bNumberFinished)
                {
                     if (!COMCharacter::nativeIsWhiteSpace(pwstr[pos]))
                     {
                         bInvalidDigitsFound = TRUE;
                         break;
                     }
                }
                else if (bNumberStarted)
                {
                    if (COMCharacter::nativeIsWhiteSpace(pwstr[pos]))
                    {
                        bNumberFinished = TRUE;
                    }
                    else if (!COMCharacter::nativeIsDigit(pwstr[pos]))
                    {
                        bInvalidDigitsFound = TRUE;
                        break;
                    }
                }
                else
                {
                    if (COMCharacter::nativeIsDigit(pwstr[pos]))
                    {
                        NumberStartPos = pos;
                        bNumberStarted = TRUE;
                    }
                    else if (!COMCharacter::nativeIsWhiteSpace(pwstr[pos]))
                    {
                        bInvalidDigitsFound = TRUE;
                        break;
                    }
                }
            }

            if (bNumberStarted && !bInvalidDigitsFound)
            {
                // Grab the help context and remove it from the help file.
                *pdwHelpContext = (DWORD)wtoi(&pwstr[NumberStartPos], len - NumberStartPos);

                // Allocate a new help file string of the right length.
                BSTR strOld = *pbstrHelpFile;
                *pbstrHelpFile = SysAllocStringLen(strOld, PoundPos);
                SysFreeString(strOld);
                if (!*pbstrHelpFile)
                    COMPlusThrowOM();
            }
        }
    }
}

// NOTE: caller cleans up any partially initialized BSTRs in pED
void ExceptionNative::GetExceptionData(OBJECTREF objException, ExceptionData *pED)
{
    _ASSERTE(objException != NULL);
    _ASSERTE(ExceptionNative::IsException(objException->GetClass()));
    _ASSERTE(pED != NULL);
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    THROWSCOMPLUSEXCEPTION();

    ZeroMemory(pED, sizeof(ExceptionData));

    if (objException->GetMethodTable() == g_pStackOverflowExceptionClass) {
        // In a low stack situation, most everything else in here will fail.
        // @TODO: We're not turning the guard page back on here, yet.
        pED->hr = COR_E_STACKOVERFLOW;
        pED->bstrDescription = SysAllocString(STACK_OVERFLOW_MESSAGE);
        return;
    }

    GCPROTECT_BEGIN(objException);
    pED->hr = GetExceptionHResult(objException);
    pED->bstrDescription = GetExceptionDescription(objException);
    pED->bstrSource = GetExceptionSource(objException);
    GetExceptionHelp(objException, &pED->bstrHelpFile, &pED->dwHelpContext);
    GCPROTECT_END();
    return;
}


HRESULT SimpleComCallWrapper::IErrorInfo_hr() {
    return GetExceptionHResult(this->GetObjectRef());
}

BSTR SimpleComCallWrapper::IErrorInfo_bstrDescription() {
    return GetExceptionDescription(this->GetObjectRef());
}

BSTR SimpleComCallWrapper::IErrorInfo_bstrSource() {
    return GetExceptionSource(this->GetObjectRef());
}

BSTR SimpleComCallWrapper::IErrorInfo_bstrHelpFile() {
    BSTR  bstrHelpFile;
    DWORD dwHelpContext;
    GetExceptionHelp(this->GetObjectRef(), &bstrHelpFile, &dwHelpContext);
    return bstrHelpFile;
}

DWORD SimpleComCallWrapper::IErrorInfo_dwHelpContext() {
    BSTR  bstrHelpFile;
    DWORD dwHelpContext;
    GetExceptionHelp(this->GetObjectRef(), &bstrHelpFile, &dwHelpContext);
    SysFreeString(bstrHelpFile);
    return dwHelpContext;
}

GUID SimpleComCallWrapper::IErrorInfo_guid() {
    return GUID_NULL;
}


BOOL ExceptionNative::IsException(EEClass* pVM)
{
    ASSERT(g_pExceptionClass != NULL);

    while (pVM != NULL && pVM != g_pExceptionClass->GetClass()) {
        pVM = pVM->GetParentClass();
    }

    return pVM != NULL;
}

EXCEPTION_POINTERS* ExceptionNative::GetExceptionPointers(void* noArgs)
{
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    _ASSERTE(pThread->GetHandlerInfo());
    return pThread->GetHandlerInfo()->m_pExceptionPointers;
}

INT32 ExceptionNative::GetExceptionCode(void* noArgs)
{
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    _ASSERTE(pThread->GetHandlerInfo());
    return pThread->GetHandlerInfo()->m_ExceptionCode;
}
//
//
// GUID NATIVE
//
//

INT32 __stdcall GuidNative::CompleteGuid(_CompleteGuidArgs *args)
{
#ifdef PLATFORM_CE
    // Windows CE does not implement CoCreateGuid.
    return FALSE;
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr;
    GUID idNext;

    _ASSERTE(args->thisPtr != NULL);

    hr = CoCreateGuid(&idNext);
    if (FAILED(hr))
        return FALSE;

    FillObjectFromGUID(args->thisPtr, &idNext);

    return TRUE;
#endif // !PLATFORM_CE
}

OBJECTREF GuidNative::CreateGuidObject(const GUID *pguid)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pClsGuid = g_Mscorlib.GetClass(CLASS__GUID);

    OBJECTREF refGuid = AllocateObject(pClsGuid);

    FillObjectFromGUID((GUID*)refGuid->GetData(), pguid);
    
    return refGuid;
}

void GuidNative::FillGUIDFromObject(GUID *pguid, const OBJECTREF *prefGuid)
{
    OBJECTREF refGuid = *prefGuid;

    GCPROTECT_BEGIN(refGuid);
    _ASSERTE(pguid != NULL && refGuid != NULL);
    _ASSERTE(refGuid->GetMethodTable() == g_Mscorlib.GetClass(CLASS__GUID));

    memcpyNoGCRefs(pguid, refGuid->GetData(), sizeof(GUID));

    GCPROTECT_END();
}

void GuidNative::FillObjectFromGUID(GUID *poutGuid, const GUID *pguid)
{
    _ASSERTE(pguid != NULL && poutGuid != NULL);

    memcpyNoGCRefs(poutGuid, pguid, sizeof(GUID));
}


//
// BitConverter Functions
//


/*================================ByteCopyHelper================================
**Action:  This is an internal helper routine that creates a byte array of the
**         correct size and stuffs the 2, 4, or 8 byte data chunk into it.
**Returns: A byte array filled with the value data.  
**Arguments:  arraysize -- the size of the array to create.
**            data -- the data to put into the array.  This must be a data chunk
**                    of the same size as arraysize.
**Exceptions: OutOfMemoryError if we run out of Memory.
**            InvalidCastException if arraySize is something besides 2,4,or 8.
==============================================================================*/
U1ARRAYREF __stdcall BitConverter::ByteCopyHelper(int arraySize, void *data) {
    U1ARRAYREF byteArray;
    void *dataPtr;
    THROWSCOMPLUSEXCEPTION();

    //Allocate a byteArray with 4 bytes.
    byteArray = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, arraySize);
    if (!byteArray) {
        COMPlusThrowOM();
    }

    //Copy the data into the array.
    dataPtr = byteArray->GetDataPtr();
    switch (arraySize) {
    case 2:
        *(INT16 *)dataPtr = *(INT16 *)data;
        break;
    case 4:
        *(INT32 *)dataPtr = *(INT32 *)data;
        break;
    case 8:
        *(INT64 *)dataPtr = *(INT64 *)data;
        break;
    default:
        _ASSERTE(!"Invalid arraySize passed to ByteCopyHelper!");
    }

    //Return the result;
    return byteArray;
}    



/*=================================CharToBytes==================================
**Action:  Convert a Char to an array of Bytes
**         All of the real work is done by ByteCopyHelper.
==============================================================================*/
LPVOID __stdcall BitConverter::CharToBytes(_CharToBytesArgs *args) {
    UINT16 temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    temp = (UINT16)args->value;
    RETURN(ByteCopyHelper(2,(void *)&temp),U1ARRAYREF);
}

/*==================================I2ToBytes===================================
**Action: Convert an I2 to an array of bytes.
**        All of the real work is done by ByteCopyHelper.
==============================================================================*/
LPVOID __stdcall BitConverter::I2ToBytes(_I2ToBytesArgs *args) {
    INT16 temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    temp = (INT16)args->value;
    RETURN(ByteCopyHelper(2,(void *)&temp),U1ARRAYREF);
}

/*==================================IntToBytes==================================
**Action: Convert an I4 to an array of bytes.
**        All of the real work is done by ByteCopyHelper
==============================================================================*/
LPVOID __stdcall BitConverter::I4ToBytes(_IntToBytesArgs *args) {
    INT32 temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    temp = args->value;
    RETURN(ByteCopyHelper(4,(void *)&temp),U1ARRAYREF);
}


/*==================================I8ToBytes===================================
**Action:  Convert an I8 to an array of bytes. 
**         All of the real work is done by ByteCopyHelper
==============================================================================*/
LPVOID __stdcall BitConverter::I8ToBytes(_I8ToBytesArgs *args) {
    INT64 temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    temp = args->value;
    RETURN(ByteCopyHelper(8,(void *)&temp),U1ARRAYREF);
}


/*==================================U2ToBytes===================================
**Action: Convert an U2 to array of bytes
**Returns: An array of 2 bytes.
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall BitConverter::U2ToBytes(_U2ToBytesArgs *args) {
    UINT16 temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    temp = (UINT16)args->value;
    RETURN(ByteCopyHelper(2,(void *)&temp),U1ARRAYREF);
}


/*==================================U4ToBytes===================================
**Action: Convert an U4 to an array of bytes
**Returns: An array of 4 bytes
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall BitConverter::U4ToBytes(_U4ToBytesArgs *args) {
    UINT32 temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    temp = args->value;
    RETURN(ByteCopyHelper(4,(void *)&temp),U1ARRAYREF);
}

/*==================================U8ToBytes===================================
**Action: Convert an U8 to an array of bytes
**Returns: An array of 8 bytes
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall BitConverter::U8ToBytes(_U8ToBytesArgs *args) {
    UINT64 temp;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    temp = args->value;
    RETURN(ByteCopyHelper(8,(void *)&temp),U1ARRAYREF);
}


/*==================================BytesToChar===================================
**Action:  Convert an array of Bytes to a U2.
**         See BytesToI4 for Arguments, Return value, and Exceptions.
==============================================================================*/
INT32 __stdcall BitConverter::BytesToChar(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);

    //Check our variable validity and boundary conditions.
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }
    
    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>(arrayLen-2)) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }

    //Get the data and cast it to an INT32 to return
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((UINT16 *)(DataPtr+args->StartIndex));
}

/*==================================BytesToI2===================================
**Action:  Convert an array of Bytes to an I2.
**         See BytesToI4 for Arguments, Return value, and Exceptions.
==============================================================================*/
INT32 __stdcall BitConverter::BytesToI2(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);

    //Check our variable validity and boundary conditions.
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>(arrayLen-2)) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    
    //Get the data and cast it to an INT32 to return
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((INT16 *)(DataPtr+args->StartIndex));
}



/*==================================BytesToI4===================================
**Action:  Convert an array of Bytes to an I4.
**Arguments: args->StartIndex -- the place in the byte array to start.
**           args->value -- the byte array on which to operate.
**Returns: An I4 constructed from the byte array.
**Exceptions: ArgumentException if args->value is null or we have indices out
**             of range.
==============================================================================*/
INT32 __stdcall BitConverter::BytesToI4(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);

    //Check our variable validity and boundary conditions.
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>arrayLen-4) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    //Get the data and cast it to an INT32 to return
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((INT32 *)(DataPtr+args->StartIndex));
}

/*==================================BytesToI8===================================
**Action:  Convert an array of Bytes to an I8.
**Arguments: args->StartIndex -- the place in the byte array to start.
**           args->value -- the byte array on which to operate.
**Returns: An I8 constructed from the byte array.
**Exceptions: ArgumentException if args->value is null or we have indices out
**             of range.
==============================================================================*/
INT64 __stdcall BitConverter::BytesToI8(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>arrayLen-8) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((INT64 *)(DataPtr+args->StartIndex));
}

/*==================================BytesToU2===================================
**Action:  Convert an array of Bytes to an U2.
**         See BytesToU4 for Arguments, Return value, and Exceptions.
==============================================================================*/
UINT32 __stdcall BitConverter::BytesToU2(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);

    //Check our variable validity and boundary conditions.
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
         COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>arrayLen-2) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    
    //Get the data and cast it to an INT32 to return
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((UINT16 *)(DataPtr+args->StartIndex));
}



/*==================================BytesToU4===================================
**Action:  Convert an array of Bytes to an U4.
**Arguments: args->StartIndex -- the place in the byte array to start.
**           args->value -- the byte array on which to operate.
**Returns: An U4 constructed from the byte array.
**Exceptions: ArgumentException if args->value is null or we have indices out
**             of range.
==============================================================================*/
UINT32 __stdcall BitConverter::BytesToU4(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);

    //Check our variable validity and boundary conditions.
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
         COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>arrayLen-4) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    //Get the data and cast it to an INT32 to return
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((UINT32 *)(DataPtr+args->StartIndex));
}

/*==================================BytesToU8===================================
**Action:  Convert an array of Bytes to an U8.
**Arguments: args->StartIndex -- the place in the byte array to start.
**           args->value -- the byte array on which to operate.
**Returns: An U8 constructed from the byte array.
**Exceptions: ArgumentException if args->value is null or we have indices out
**             of range.
==============================================================================*/
UINT64 __stdcall BitConverter::BytesToU8(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
         COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>arrayLen-8) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((UINT64 *)(DataPtr+args->StartIndex));
}

/*==================================BytesToR4===================================
**Action:  Convert an array of bytes to an R4.
**See BytesToI4 for arguments and exceptions.
==============================================================================*/
R4 __stdcall BitConverter::BytesToR4(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
         COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>arrayLen-4) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((R4 *)(DataPtr+args->StartIndex));
}

/*==================================BytesToR8===================================
**Action:  Convert an array of Bytes to an R8.
**See BytesToI4 for arguments and exceptions.
==============================================================================*/
R8 __stdcall BitConverter::BytesToR8(_BytesToXXArgs *args) {
    byte *DataPtr;
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(args);
    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
         COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index"); 
    }
    
    if (args->StartIndex>arrayLen-8) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    
    DataPtr = (byte *)args->value->GetDataPtr();
    return *((R8 *)(DataPtr+args->StartIndex));
}


/*=================================GetHexValue==================================
**Action:  Return the appropriate hex character for a given integer i.  i is 
**         assumed to be between 0 and 15.  This is an internal helper function.
**Arguments: i -- the integer to be converted.
**Returns: The character value for the hex digit represented by i.
**Exceptions: None.
==============================================================================*/
WCHAR GetHexValue(int i) {
    _ASSERTE(i>=0 && i<16);
    if (i<10) {
        return i + '0';
    } 
    return i-10+'A';
}

/*================================BytesToString=================================
**Action: Converts the array of bytes into a String.  We preserve the endian-ness
**        of the machine representation.
**Arguments: args->Length -- The length of the byte array to use.
**           args->StartIndex -- The place in the array to start.
**           args->value  -- The byte array.
**Returns: A string containing the representation of the byte array.
**Exceptions: ArgumentException if any of the ranges are invalid.
==============================================================================*/
LPVOID __stdcall BitConverter::BytesToString(_BytesToStringArgs *args) {
    WCHAR *ByteArray;
    INT32 realLength;
    byte *DataPtr;
    byte b;
    int i;
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    if (!args->value) {
        COMPlusThrowArgumentNull(L"byteArray");
    }

    int arrayLen = args->value->GetNumComponents();
    if (args->StartIndex<0 || args->StartIndex >= arrayLen) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_StartIndex"); 
    }

    realLength = args->Length;

    if (realLength<0) {
        COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_GenericPositive");
    }

    if (args->StartIndex > arrayLen - realLength) {
        COMPlusThrow(kArgumentException, L"Arg_ArrayPlusOffTooSmall");
    }
    
    if (0==realLength) {
        RETURN(COMString::GetEmptyString(),STRINGREF);
    }

    ByteArray = new (throws) WCHAR[realLength*3];
    
    DataPtr = (byte *)args->value->GetDataPtr();

    DataPtr += args->StartIndex;
    for (i=0; i<(realLength*3); i+=3, DataPtr++) {
        b = *DataPtr;
        ByteArray[i]= GetHexValue(b/16);
        ByteArray[i+1] = GetHexValue(b%16);
        ByteArray[i+2] = '-';
    }
    ByteArray[i-1]=0;

    STRINGREF str = COMString::NewString(ByteArray);
    delete [] ByteArray;
    RETURN(str,STRINGREF);
}

WCHAR BitConverter::base64[] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='};

/*===========================ByteArrayToBase64String============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL3(Object*, BitConverter::ByteArrayToBase64String, U1Array* pInArray, INT32 offset, INT32 length) {
    THROWSCOMPLUSEXCEPTION();

    STRINGREF  outString;
    LPVOID     rv=NULL;
    U1ARRAYREF inArray(pInArray);
    HELPER_METHOD_FRAME_BEGIN_RET_1(inArray);

    UINT32     inArrayLength;
    UINT32     stringLength;
    WCHAR *    outChars;
    UINT8 *    inData;

    //Do data verfication
    if (inArray==NULL) {
        COMPlusThrowArgumentNull(L"inArray");
    }

    if (length<0) {
        COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_Index");
    }
    
    if (offset<0) {
        COMPlusThrowArgumentOutOfRange(L"offset", L"ArgumentOutOfRange_GenericPositive");
    }

    inArrayLength = inArray->GetNumComponents();

    if (offset > (INT32)(inArrayLength - length)) {
        COMPlusThrowArgumentOutOfRange(L"offset", L"ArgumentOutOfRange_OffsetLength");
    }

    //Create the new string.  This is the maximally required length.
    stringLength = (UINT32)((length*1.5)+2);

    outString=COMString::NewString(stringLength);

    outChars = outString->GetBuffer();
        
    inData = (UINT8 *)inArray->GetDataPtr();

    int j = ConvertToBase64Array(outChars,inData,offset,length);
    //Set the string length.  This may leave us with some blank chars at the end of
    //the string, but that's cheaper than doing a copy.
    outString->SetStringLength(j);

    HELPER_METHOD_FRAME_END();
    return OBJECTREFToObject(outString);
}
FCIMPLEND

/*===========================ByteArrayToBase64CharArray============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL5(INT32, BitConverter::ByteArrayToBase64CharArray, U1Array* pInArray, INT32 offsetIn, INT32 length, CHARArray* pOutArray, INT32 offsetOut) {
    THROWSCOMPLUSEXCEPTION();

    U1ARRAYREF inArray(pInArray);
    CHARARRAYREF outArray(pOutArray);
    INT32      retVal;
    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();

    UINT32     inArrayLength;
    UINT32     outArrayLength;
    UINT32     numElementsToCopy;
    WCHAR*     outChars;
    UINT8*     inData;
    //Do data verfication
    if (inArray==NULL) {
        COMPlusThrowArgumentNull(L"inArray");
    }

        //Do data verfication
    if (outArray==NULL) {
        COMPlusThrowArgumentNull(L"outArray");
    }

    if (length<0) {
        COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_Index");
    }
    
    if (offsetIn<0) {
        COMPlusThrowArgumentOutOfRange(L"offsetIn", L"ArgumentOutOfRange_GenericPositive");
    }

    if (offsetOut<0) {
        COMPlusThrowArgumentOutOfRange(L"offsetOut", L"ArgumentOutOfRange_GenericPositive");
    }

    inArrayLength = inArray->GetNumComponents();

    if (offsetIn > (INT32)(inArrayLength - length)) {
        COMPlusThrowArgumentOutOfRange(L"offsetIn", L"ArgumentOutOfRange_OffsetLength");
    }

    //This is the maximally required length that must be available in the char array
    outArrayLength = outArray->GetNumComponents();

        // Length of the char buffer required
    numElementsToCopy = (UINT32)((length/3)*4 + ( ((length % 3) != 0) ? 1 : 0)*4);
    
    if (offsetOut > (INT32)(outArrayLength -  numElementsToCopy)) {
        COMPlusThrowArgumentOutOfRange(L"offsetOut", L"ArgumentOutOfRange_OffsetOut");
    }
    
    outChars = (WCHAR *)outArray->GetDataPtr();
    inData = (UINT8 *)inArray->GetDataPtr();

    retVal = ConvertToBase64Array(outChars,inData,offsetIn,length);

    HELPER_METHOD_FRAME_END_POLL();
    return retVal;
}
FCIMPLEND


// Comverts an array of bytes to base64 chars
INT32 BitConverter::ConvertToBase64Array(WCHAR *outChars,UINT8 *inData,UINT offset,UINT length)
{
        UINT calcLength = offset + (length - (length%3));
    int j=0;
    //Convert three bytes at a time to base64 notation.  This will consume 4 chars.
    for (UINT i=offset; i<calcLength; i+=3) {
                        outChars[j] = base64[(inData[i]&0xfc)>>2];
                        outChars[j+1] = base64[((inData[i]&0x03)<<4) | ((inData[i+1]&0xf0)>>4)];
                        outChars[j+2] = base64[((inData[i+1]&0x0f)<<2) | ((inData[i+2]&0xc0)>>6)];
                        outChars[j+3] = base64[(inData[i+2]&0x3f)];
                        j += 4;
    }

    i =  calcLength; //Where we left off before
    switch(length%3){
    case 2: //One character padding needed
        outChars[j] = base64[(inData[i]&0xfc)>>2];
        outChars[j+1] = base64[((inData[i]&0x03)<<4)|((inData[i+1]&0xf0)>>4)];
        outChars[j+2] = base64[(inData[i+1]&0x0f)<<2];
        outChars[j+3] = base64[64]; //Pad
        j+=4;
        break;
    case 1: // Two character padding needed
        outChars[j] = base64[(inData[i]&0xfc)>>2];
        outChars[j+1] = base64[(inData[i]&0x03)<<4];
        outChars[j+2] = base64[64]; //Pad
        outChars[j+3] = base64[64]; //Pad
        j+=4;
        break;
    }
        return j;

}


/*===========================Base64StringToByteArray============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL1(Object*, BitConverter::Base64StringToByteArray, StringObject* pInString) {
    THROWSCOMPLUSEXCEPTION();

    STRINGREF inString(pInString);
    U1ARRAYREF bArray;
    HELPER_METHOD_FRAME_BEGIN_RET_1(inString);

    if (inString==NULL) {
        COMPlusThrowArgumentNull(L"InString");
    }
    
    INT32 inStringLength = (INT32)inString->GetStringLength();
        // empty string should be a valid case, return an empty array for it

    if( inStringLength == 0) {
        bArray = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, inStringLength);        
    }
    else {
        if ((inStringLength<4) /*|| ((inStringLength%4)>0)*/) {
            COMPlusThrow(kFormatException, L"Format_BadBase64Length");
        }
        
        WCHAR *c = inString->GetBuffer();

        CQuickBytes valueHolder;
        INT32 *value = (INT32 *)(valueHolder.Alloc(inStringLength * sizeof(INT32)));
        if (!value) {
            COMPlusThrowOM();
        }

            // Convert the characters in the string into an array of integers in the range [0-63].
            // returns the number of extra padded characters that we will discard.
        UINT trueLength=0; //Length ignoring whitespace
        int iend = ConvertBase64ToByteArray(value,c,0,inStringLength, &trueLength);

        if (trueLength==0 || trueLength%4>0) {
            COMPlusThrow(kFormatException, L"Format_BadBase64CharArrayLength");
        }

        //Create the new byte array.  We can determine the size from the chars we read
        //out of the string.
        int blength = (((trueLength-4)*3)/4)+(3-iend);

        bArray = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, blength);
        U1 *b = (U1*)bArray->GetDataPtr();

        //Walk the byte array and convert the int's into bytes in the proper base-64 notation.
        ConvertByteArrayToByteStream(value,b,blength);
    }
    
    HELPER_METHOD_FRAME_END();    
    return OBJECTREFToObject(bArray);
}
FCIMPLEND

/*===========================Base64CharArrayToByteArray============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL3(Object*, BitConverter::Base64CharArrayToByteArray, CHARArray* pInCharArray, INT32 offset, INT32 length) {
    THROWSCOMPLUSEXCEPTION();

    CHARARRAYREF inCharArray(pInCharArray);
    U1ARRAYREF bArray;
    HELPER_METHOD_FRAME_BEGIN_RET_1(inCharArray);

    if (inCharArray==NULL) {
        COMPlusThrowArgumentNull(L"InArray");
    }
    
    if (length<0) {
        COMPlusThrowArgumentOutOfRange(L"length", L"ArgumentOutOfRange_Index");
    }
    
    if (offset<0) {
        COMPlusThrowArgumentOutOfRange(L"offset", L"ArgumentOutOfRange_GenericPositive");
    }

    UINT32     inArrayLength = inCharArray->GetNumComponents();

    if (offset > (INT32)(inArrayLength - length)) {
        COMPlusThrowArgumentOutOfRange(L"offset", L"ArgumentOutOfRange_OffsetLength");
    }
    
    if ((length<4) /*|| ((length%4)>0)*/) {
        COMPlusThrow(kFormatException, L"Format_BadBase64CharArrayLength");
    }
    
    CQuickBytes valueHolder;
    INT32 *value = (INT32 *)(valueHolder.Alloc(length * sizeof(INT32)));
    if (!value) {
        COMPlusThrowOM();
    }

    WCHAR *c = (WCHAR *)inCharArray->GetDataPtr();
    UINT trueLength=0; //Length excluding whitespace
    int iend = ConvertBase64ToByteArray(value,c,offset,length, &trueLength);

    if (trueLength%4>0) {
        COMPlusThrow(kFormatException, L"Format_BadBase64CharArrayLength");
    }

    //Create the new byte array.  We can determine the size from the chars we read
    //out of the string.
    int blength = (trueLength > 0) ? (((trueLength-4)*3)/4)+(3-iend) : 0;
    
    bArray = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, blength);
    U1 *b = (U1*)bArray->GetDataPtr();
    
    ConvertByteArrayToByteStream(value,b,blength);
    
    HELPER_METHOD_FRAME_END();
    
    return OBJECTREFToObject(bArray);
}
FCIMPLEND

#define IS_WHITESPACE(__c) ((__c)=='\t' || (__c)==' ' || (__c)=='\r' || (__c)=='\n')

//Convert the characters on the stream into an array of integers in the range [0-63].
INT32 BitConverter::ConvertBase64ToByteArray(INT32 *value,WCHAR *c,UINT offset,UINT length, UINT *nonWhiteSpaceChars)
{
        THROWSCOMPLUSEXCEPTION();

        int iend = 0;
        int intA = (int)'A';
    int intZ = (int)'Z';
    int inta = (int)'a';
    int intz = (int)'z';
    int int0 = (int)'0';
    int int9 = (int)'9';
    
    int currBytePos = 0;


    //Convert the characters on the stream into an array of integers in the range [0-63].
    for (UINT i=offset; i<length+offset; i++){
        int ichar = (int)c[i];
        if ((ichar >= intA)&&(ichar <= intZ))
            value[currBytePos++] = ichar - intA;
        else if ((ichar >= inta)&&(ichar <= intz))
            value[currBytePos++] = ichar - inta + 26;
        else if ((ichar >= int0)&&(ichar <= int9))
            value[currBytePos++] = ichar - int0 + 52;
        else if (c[i] == '+')
            value[currBytePos++] = 62;
        else if (c[i] == '/')
            value[currBytePos++] = 63;
        else if (IS_WHITESPACE(c[i])) 
            continue;
        else if (c[i] == '='){ 
			// throw for bad inputs like
			// ====, a===, ab=c
			// valid inputs are ab==,abc=
			int temp = (currBytePos - offset) % 4;
			if (temp == 3 || (temp == 2 && c[i+1]=='=')) {
				value[currBytePos++] = 0;
				iend++;
			} else {
                //We may have whitespace in the trailing characters, so take a slightly more expensive path
                //to determine this.
                //This presupposes that these characters can only occur at the end of the string.  Verify this assumption.
                bool foundEquals=false;
                for (UINT j = i+1; j<(length+offset); j++) {
                    if (IS_WHITESPACE(c[j])) {
                        continue;
                    } else if (c[j]=='=') {
                        if (foundEquals) {
                            COMPlusThrow(kFormatException, L"Format_BadBase64Char");
                        }
                        foundEquals=true;
                    } else {
                        COMPlusThrow(kFormatException, L"Format_BadBase64Char");
                    }
                }
				value[currBytePos++] = 0;
				iend++;
            }

			// We are done looking at a group of 4, only valid characters after this are whitespaces
			if ((currBytePos % 4) == 0) {
			   for (UINT j = i+1; j<(length+offset); j++) {
                    if (IS_WHITESPACE(c[j])) {
                        continue;
                    } else {
						COMPlusThrow(kFormatException, L"Format_BadBase64Char");
					}
			   }
			}
        }
        else
            COMPlusThrow(kFormatException, L"Format_BadBase64Char");
    }
    *nonWhiteSpaceChars = currBytePos;
    return iend;
}

//Walk the byte array and convert the int's into bytes in the proper base-64 notation.
INT32 BitConverter::ConvertByteArrayToByteStream(INT32 *value,U1 *b,UINT length)
{
        int j = 0;
    int b1;
    int b2;
    int b3;
    //Walk the byte array and convert the int's into bytes in the proper base-64 notation.
    for (UINT i=0; i<(length); i+=3){
        b1 = (UINT8)((value[j]<<2)&0xfc);
        b1 = (UINT8)(b1|((value[j+1]>>4)&0x03));
        b2 = (UINT8)((value[j+1]<<4)&0xf0);
        b2 = (UINT8)(b2|((value[j+2]>>2)&0x0f));
        b3 = (UINT8)((value[j+2]<<6)&0xc0);
        b3 = (UINT8)(b3|(value[j+3]));
        j+=4;
        b[i] = (UINT8)b1;
        if ((i+1)<length)
            b[i+1] = (UINT8)b2;
        if ((i+2)<length)
            b[i+2] = (UINT8)b3;
    }
        return j;
}    
    



// BlockCopy
// This method from one primitive array to another based
//  upon an offset into each an a byte count.
FCIMPL5(VOID, Buffer::BlockCopy, ArrayBase *src, int srcOffset, ArrayBase *dst, int dstOffset, int count)
{
    // Verify that both the src and dst are Arrays of primitive
    //  types.
    // @TODO: We need to check for booleans
    if (src==NULL || dst==NULL)
        FCThrowArgumentNullVoid((src==NULL) ? L"src" : L"dst");
        
    // We only want to allow arrays of primitives, no Objects.
    if (!CorTypeInfo::IsPrimitiveType(src->GetArrayClass()->GetElementType()) ||
        ELEMENT_TYPE_STRING == src->GetArrayClass()->GetElementType())
        FCThrowArgumentVoid(L"src", L"Arg_MustBePrimArray");

    if (!CorTypeInfo::IsPrimitiveType(dst->GetArrayClass()->GetElementType()) ||
        ELEMENT_TYPE_STRING == dst->GetArrayClass()->GetElementType())
        FCThrowArgumentVoid(L"dest", L"Arg_MustBePrimArray");

    // Size of the Arrays in bytes
    int srcLen = src->GetNumComponents() * src->GetMethodTable()->GetComponentSize();
    int dstLen = dst->GetNumComponents() * dst->GetMethodTable()->GetComponentSize();

    if (srcOffset < 0 || dstOffset < 0 || count < 0) {
        const wchar_t* str = L"srcOffset";
        if (dstOffset < 0) str = L"dstOffset";
        if (count < 0) str = L"count";
        FCThrowArgumentOutOfRangeVoid(str, L"ArgumentOutOfRange_NeedNonNegNum");
    }
    if (srcLen - srcOffset < count || dstLen - dstOffset < count) {
        FCThrowArgumentVoid(NULL, L"Argument_InvalidOffLen");
    }

    if (count > 0) {
        // Call our faster version of memmove, not the CRT one.
        m_memmove(dst->GetDataPtr() + dstOffset,
                  src->GetDataPtr() + srcOffset, count);
    }

    FC_GC_POLL();
}
FCIMPLEND


// InternalBlockCopy
// This method from one primitive array to another based
//  upon an offset into each an a byte count.
FCIMPL5(VOID, Buffer::InternalBlockCopy, ArrayBase *src, int srcOffset, ArrayBase *dst, int dstOffset, int count)
{
    _ASSERTE(src != NULL);
    _ASSERTE(dst != NULL);

    // Unfortunately, we must do a check to make sure we're writing within 
    // the bounds of the array.  This will ensure that we don't overwrite
    // memory elsewhere in the system nor do we write out junk.  This can
    // happen if multiple threads screw with our IO classes simultaneously
    // without being threadsafe.  Throw here.  -- Brian Grunkemeyer, 5/9/2001
    int srcLen = src->GetNumComponents() * src->GetMethodTable()->GetComponentSize();
    if (srcOffset < 0 || dstOffset < 0 || count < 0 || srcOffset > srcLen - count)
        FCThrowResVoid(kIndexOutOfRangeException, L"IndexOutOfRange_IORaceCondition");
    if (src == dst) {
        if (dstOffset > srcLen - count)
            FCThrowResVoid(kIndexOutOfRangeException, L"IndexOutOfRange_IORaceCondition");
    }
    else {
        int destLen = dst->GetNumComponents() * dst->GetMethodTable()->GetComponentSize();
        if (dstOffset > destLen - count)
            FCThrowResVoid(kIndexOutOfRangeException, L"IndexOutOfRange_IORaceCondition");
    }

    _ASSERTE(srcOffset >= 0);
    _ASSERTE((src->GetNumComponents() * src->GetMethodTable()->GetComponentSize()) - (unsigned) srcOffset >= (unsigned) count);
    _ASSERTE((dst->GetNumComponents() * dst->GetMethodTable()->GetComponentSize()) - (unsigned) dstOffset >= (unsigned) count);
    _ASSERTE(dstOffset >= 0);
    _ASSERTE(count >= 0);

    // Copy the data.
    // Call our faster version of memmove, not the CRT one.
    m_memmove(dst->GetDataPtr() + dstOffset,
              src->GetDataPtr() + srcOffset, count);

    FC_GC_POLL();
}
FCIMPLEND


// Gets a particular byte out of the array.  The array can't be an array of Objects - it
// must be a primitive array.
BYTE Buffer::GetByte(const _GetByteArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->array == NULL)
        COMPlusThrowArgumentNull(L"array");

    TypeHandle elementTH = args->array->GetElementTypeHandle();

    if (!CorTypeInfo::IsPrimitiveType(elementTH.GetNormCorElementType()))
        COMPlusThrow(kArgumentException, L"Arg_MustBePrimArray");

    const int elementSize = elementTH.GetClass()->GetNumInstanceFieldBytes();
    _ASSERTE(elementSize > 0);

    if (args->index < 0 || args->index >= (int)args->array->GetNumComponents()*elementSize)
        COMPlusThrowArgumentOutOfRange(L"index", L"ArgumentOutOfRange_Index");

    return *((BYTE*)args->array->GetDataPtr() + args->index);
}


// Sets a particular byte in an array.  The array can't be an array of Objects - it
// must be a primitive array.
void Buffer::SetByte(_SetByteArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->array == NULL)
        COMPlusThrowArgumentNull(L"array");

    TypeHandle elementTH = args->array->GetElementTypeHandle();

    if (!CorTypeInfo::IsPrimitiveType(elementTH.GetNormCorElementType()))
        COMPlusThrow(kArgumentException, L"Arg_MustBePrimArray");

    const int elementSize = elementTH.GetClass()->GetNumInstanceFieldBytes();
    _ASSERTE(elementSize > 0);

    if (args->index < 0 || args->index >= (int)args->array->GetNumComponents()*elementSize)
        COMPlusThrowArgumentOutOfRange(L"index", L"ArgumentOutOfRange_Index");

    *((BYTE*)args->array->GetDataPtr() + args->index) = args->value;
}


// Finds the length of an array in bytes.  Must be a primitive array.
INT32 Buffer::ByteLength(const _ArrayArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->array == NULL)
        COMPlusThrowArgumentNull(L"array");

    TypeHandle elementTH = args->array->GetElementTypeHandle();

    if (!CorTypeInfo::IsPrimitiveType(elementTH.GetNormCorElementType()))
        COMPlusThrow(kArgumentException, L"Arg_MustBePrimArray");

    const int elementSize = elementTH.GetClass()->GetNumInstanceFieldBytes();
    _ASSERTE(elementSize > 0);

    return args->array->GetNumComponents() * elementSize;
}

//
// GCInterface
//
BOOL GCInterface::m_cacheCleanupRequired=FALSE;
MethodDesc *GCInterface::m_pCacheMethod=NULL;


/*============================IsCacheCleanupRequired============================
**Action: Called by Thread::HaveExtraWorkForFinalizer to determine if we have
**        managed caches which should be cleared as a part of the finalizer thread
**        finishing it's work.
**Returns: BOOL.  True if the cache needs to be cleared.
**Arguments: None
**Exceptions: None
==============================================================================*/
BOOL GCInterface::IsCacheCleanupRequired() {
    return m_cacheCleanupRequired;
}

/*===========================SetCacheCleanupRequired============================
**Action: Sets the bit as to whether cache cleanup is required.
**Returns: void
**Arguments: None
**Exceptions: None
==============================================================================*/
void GCInterface::SetCacheCleanupRequired(BOOL bCleanup) {
    m_cacheCleanupRequired = bCleanup;
}


/*=================================CleanupCache=================================
**Action: Call the managed code in GC.FireCacheEvent to tell all of the managed
**        caches to go clean themselves up.  
**Returns:    Void
**Arguments:  None
**Exceptions: None.  We don't care if exceptions happen.  We'll trap, log, and
**            discard them.
==============================================================================*/
void GCInterface::CleanupCache() {

    //Let's set the bit to false.  This means that if any cache gets
    //created while we're clearing caches, it will set the bit again
    //and we'll remember to go clean it up.  
    SetCacheCleanupRequired(FALSE);

    //The EE shouldn't enter shutdown phase while the finalizer thread is active.
    //If this isn't true, I'll need some more complicated logic here.
    if (g_fEEShutDown) {
        return;
    }

    //If we don't have the method already, let's try to go get it.
    if (!m_pCacheMethod) {
        COMPLUS_TRY {
           m_pCacheMethod = g_Mscorlib.GetMethod(METHOD__GC__FIRE_CACHE_EVENT);
        } COMPLUS_CATCH {
            LOG((LF_BCL, LL_INFO10, "Caught an exception while trying to get the MethodDesc"));
        } COMPLUS_END_CATCH
        _ASSERTE(m_pCacheMethod);
    }

    //If we have the method let's call it and catch any errors.  We don't do anything
    //other than log these because we don't care.  If the cache clear fails, then either
    //we're shutting down or the failure will be propped up to user code the next
    //time that they try to access the cache.
    if (m_pCacheMethod) {
        COMPLUS_TRY {
            m_pCacheMethod->Call(NULL);//Static method has no arguments;
        } COMPLUS_CATCH {
            LOG((LF_BCL, LL_INFO10, "Got an exception while calling cache method"));
        } COMPLUS_END_CATCH
        LOG((LF_BCL, LL_INFO10, "Called cache cleanup method."));
    } else {
        LOG((LF_BCL, LL_INFO10, "Unable to get MethodDesc for cleanup"));
    }
}


/*============================NativeSetCleanupCache=============================
**Action: Sets the bit to say to clear the cache.  This is merely the wrapper
**        for managed code to call.
**Returns: void
**Arguments: None
**Exceptions: None
==============================================================================*/
FCIMPL0(void, GCInterface::NativeSetCleanupCache) {
    SetCacheCleanupRequired(TRUE);
}
FCIMPLEND

/*================================GetGeneration=================================
**Action: Returns the generation in which args->obj is found.
**Returns: The generation in which args->obj is found.
**Arguments: args->obj -- The object to locate.
**Exceptions: ArgumentException if args->obj is null.
==============================================================================*/
INT32 GCInterface::GetGeneration(_getGenerationArgs *args) {
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    if (args->obj==NULL) {
        COMPlusThrowArgumentNull(L"obj");
    }
    

    //This funky cast extracts the Object*.  It's required for the debug builds
    //where Object is not a parent of OBJECTREF.
    Object *rv;
    *((OBJECTREF *)&rv) = args->obj;

    return (INT32)g_pGCHeap->WhichGeneration(rv);
}
    

// InternalGetCurrentMethod
// Return the MethodInfo that represents the current method.
LPVOID __stdcall GCInterface::InternalGetCurrentMethod(_InternalGetCurrentMethodArgs* args)
{

    SkipStruct skip;
    skip.stackMark = args->stackMark;
    skip.pMeth = 0;
        StackWalkFunctions(GetThread(), SkipMethods, &skip);
    if (skip.pMeth == 0)
        return 0;

    OBJECTREF o = COMMember::g_pInvokeUtil->GetMethodInfo(skip.pMeth);
    LPVOID          rv;
    *((OBJECTREF*) &rv) = o;
    return rv;
}

// This method is called by the GetMethod function and will crawl backward
//  up the stack for integer methods.
StackWalkAction GCInterface::SkipMethods(CrawlFrame* frame, VOID* data)
{
    SkipStruct* pSkip = (SkipStruct*) data;

    //@TODO: Are frames always FramedMethodFrame?
    //       Not at all (FPG)
    MethodDesc *pFunc = frame->GetFunction();

    /* We asked to be called back only for functions */
    _ASSERTE(pFunc);

    // First check if the walk has skipped the required frames. The check
    // here is between the address of a local variable (the stack mark) and a
    // pointer to the EIP for a frame (which is actually the pointer to the
    // return address to the function from the previous frame). So we'll
    // actually notice which frame the stack mark was in one frame later. This
    // is fine for our purposes since we're always looking for the frame of the
    // caller of the method that actually created the stack mark.
    _ASSERTE((pSkip->stackMark == NULL) || (*pSkip->stackMark == LookForMyCaller));
    if ((pSkip->stackMark != NULL) &&
        ((size_t)frame->GetRegisterSet()->pPC) < (size_t)pSkip->stackMark)
        return SWA_CONTINUE;

    pSkip->pMeth = static_cast<MethodDesc*>(pFunc);

    return SWA_ABORT;
}


/*==================================KeepAlive===================================
**Action: A helper to extend the lifetime of an object to this call.  Note
**        that calling this method forces a reference to the object to remain
**        valid until this call happens, preventing some destructive premature
**        finalization problems.
==============================================================================*/
FCIMPL1 (VOID, GCInterface::KeepAlive, Object *obj) {
    return;
}
FCIMPLEND

/*===============================GetGenerationWR================================
**Action: Returns the generation in which the object pointed to by a WeakReference is found.
**Returns:
**Arguments: args->handle -- the OBJECTHANDLE to the object which we're locating.
**Exceptions: ArgumentException if handle points to an object which is not accessible.
==============================================================================*/
INT32 GCInterface::GetGenerationWR(_getGenerationWRArgs *args) {
    OBJECTREF temp;

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    _ASSERTE(args->handle);
    
    temp = ObjectFromHandle((OBJECTHANDLE) args->handle);    
    if (temp == NULL) {
        COMPlusThrowArgumentNull(L"weak handle");
    }
    
    //This funky cast extracts the Object*.  It's required for the debug builds
    //where Object is not a parent of OBJECTREF.
    Object *rv;
    *((OBJECTREF *)&rv) = temp;

    return (INT32)g_pGCHeap->WhichGeneration(rv);
}


/*================================GetTotalMemory================================
**Action: Returns the total number of bytes in use
**Returns: The total number of bytes in use
**Arguments: None
**Exceptions: None
==============================================================================*/
INT64 GCInterface::GetTotalMemory(_emptyArgs *args) {
    return (INT64) g_pGCHeap->GetTotalBytesInUse();
}

/*==============================CollectGeneration===============================
**Action: Collects all generations <= args->generation
**Returns: void
**Arguments: args->generation:  The maximum generation to collect
**Exceptions: Argument exception if args->generation is < 0 or > GetMaxGeneration();
==============================================================================*/
void GCInterface::CollectGeneration(_collectGenerationArgs *args) {
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    //We've already checked this in GC.cool, so we'll just assert it here.
    _ASSERTE(args->generation>=-1);

    //We don't need to check the top end because the GC will take care of that.
        
    g_pGCHeap->GarbageCollect(args->generation);
}


/*===============================GetMaxGeneration===============================
**Action: Returns the largest GC generation
**Returns: The largest GC Generation
**Arguments: None
**Exceptions: None
==============================================================================*/
INT32 __stdcall GCInterface::GetMaxGeneration(_emptyArgs *args) {
    return (INT32)g_pGCHeap->GetMaxGeneration();
}


/*================================RunFinalizers=================================
**Action: Run all Finalizers that haven't been run.
**Arguments: None
**Exceptions: None
==============================================================================*/
void __stdcall GCInterface::RunFinalizers(LPVOID /*no args*/)
{
     g_pGCHeap->FinalizerThreadWait();
}


/*==============================SuppressFinalize================================
**Action: Indicate that an object's finalizer should not be run by the system
**Arguments: Object of interest
**Exceptions: None
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL1(int, GCInterface::FCSuppressFinalize, Object *obj)
{
    if (obj == 0)
        FCThrow(kArgumentNullException);
    
    g_pGCHeap->SetFinalizationRun(obj);
    return 0;           // bogus return so that FCThrow macro can work
}
FCIMPLEND
#else
int __stdcall GCInterface::SuppressFinalize(_SuppressFinalizeArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->obj == 0)
        COMPlusThrowArgumentNull(L"obj");
    
    g_pGCHeap->SetFinalizationRun(OBJECTREFToObject(args->obj));
    return 0;
}
#endif


/*============================ReRegisterForFinalize==============================
**Action: Indicate that an object's finalizer should be run by the system.
**Arguments: Object of interest
**Exceptions: None
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL1(int, GCInterface::FCReRegisterForFinalize, Object *obj)
{
    if (obj == 0)
        FCThrow(kArgumentNullException);
    
    if (obj->GetMethodTable()->HasFinalizer())
        g_pGCHeap->RegisterForFinalization(-1, obj);

    return 0;           // bogus return so that FCThrow macro can work
}
FCIMPLEND
#else
int __stdcall GCInterface::ReRegisterForFinalize(_ReRegisterForFinalizeArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->obj == 0)
        COMPlusThrowArgumentNull(L"obj");
    
    if (args->obj->GetMethodTable()->HasFinalizer())
        g_pGCHeap->RegisterForFinalization(-1, OBJECTREFToObject(args->obj));

    return 0;
}
#endif


//
// COMInterlocked
//

FCIMPL1(UINT32,COMInterlocked::Increment32, UINT32 *location)
{
    return FastInterlockIncrement((LONG *) location);
}
FCIMPLEND

FCIMPL1(UINT32,COMInterlocked::Decrement32, UINT32 *location)
{
    return FastInterlockDecrement((LONG *) location);
}
FCIMPLEND

FCIMPL1(UINT64,COMInterlocked::Increment64, UINT64 *location)
{
    return FastInterlockIncrementLong((UINT64 *) location);
}
FCIMPLEND

FCIMPL1(UINT64,COMInterlocked::Decrement64, UINT64 *location)
{
    return FastInterlockDecrementLong((UINT64 *) location);
}
FCIMPLEND

FCIMPL2(UINT32,COMInterlocked::Exchange, UINT32 *location, UINT32 value)
{
    return FastInterlockExchange((LONG *) location, value);
}
FCIMPLEND

FCIMPL3(LPVOID,COMInterlocked::CompareExchange, LPVOID *location, LPVOID value, LPVOID comparand)
{
    return FastInterlockCompareExchange(location, value, comparand);
}
FCIMPLEND

FCIMPL2(R4,COMInterlocked::ExchangeFloat, R4 *location, R4 value)
{
    LONG ret = FastInterlockExchange((LONG *) location, *(LONG*)&value);
    return *(R4*)&ret;
}
FCIMPLEND

FCIMPL3_IRR(R4,COMInterlocked::CompareExchangeFloat, R4 *location, R4 value, R4 comparand)
{
    LPVOID ret = (LPVOID)FastInterlockCompareExchange((LPVOID*)(size_t)location, *(LPVOID*)(size_t*)&value, *(LPVOID*)(size_t*)&comparand);
    return *(R4*)(size_t*)&ret;
}
FCIMPLEND

FCIMPL2(LPVOID,COMInterlocked::ExchangeObject, LPVOID*location, LPVOID value)
{
    LPVOID ret = InterlockedExchangePointer(location, value);
    ErectWriteBarrier((OBJECTREF *)location, ObjectToOBJECTREF((Object *)value));
    return ret;
}
FCIMPLEND

FCIMPL3(LPVOID,COMInterlocked::CompareExchangeObject, LPVOID *location, LPVOID value, LPVOID comparand)
{
    // @todo: only set ref if is updated
    LPVOID ret = (LPVOID)FastInterlockCompareExchange((void **) location, (void *) value, (void *) comparand);
    if (ret == comparand)
    {
        ErectWriteBarrier((OBJECTREF *)location, ObjectToOBJECTREF((Object *)value));
    }
    return ret;
}
FCIMPLEND

FCIMPL5(INT32, ManagedLoggingHelper::GetRegistryLoggingValues, BOOL *bLoggingEnabled, BOOL *bLogToConsole, INT32 *iLogLevel, BOOL *bPerfWarnings, BOOL *bCorrectnessWarnings) {

    *bLoggingEnabled = FALSE;
    *bLogToConsole = FALSE;
    *iLogLevel = 0;
    INT32 logFacility=0;
    
    *bLoggingEnabled = (g_pConfig->GetConfigDWORD(MANAGED_LOGGING_ENABLE, 0)!=0);
    *bLogToConsole = (g_pConfig->GetConfigDWORD(MANAGED_LOGGING_CONSOLE, 0)!=0);
    *iLogLevel = (INT32)(g_pConfig->GetConfigDWORD(MANAGED_LOGGING_LEVEL, 0));
    logFacility = (INT32)(g_pConfig->GetConfigDWORD(MANAGED_LOGGING_FACILITY, 0));
    *bPerfWarnings = (g_pConfig->GetConfigDWORD(MANAGED_PERF_WARNINGS, 0)!=0);
    *bCorrectnessWarnings = (g_pConfig->GetConfigDWORD(MANAGED_CORRECTNESS_WARNINGS, 0)!=0);

    FC_GC_POLL_RET();
    return logFacility;
}
FCIMPLEND


FCIMPL1(LPVOID, ValueTypeHelper::GetMethodTablePtr, Object* obj)
    _ASSERTE(obj != NULL);
    return (LPVOID) obj->GetMethodTable();
FCIMPLEND

// Return true if the valuetype does not contain pointer and is tightly packed
FCIMPL1(BOOL, ValueTypeHelper::CanCompareBits, Object* obj)
    _ASSERTE(obj != NULL);
	MethodTable* mt = obj->GetMethodTable();
    return (!mt->ContainsPointers() && !mt->IsNotTightlyPacked());

FCIMPLEND

FCIMPL2(BOOL, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2)
    _ASSERTE(obj1 != NULL);
    _ASSERTE(obj2 != NULL);
    _ASSERTE(!obj1->GetMethodTable()->ContainsPointers());
	_ASSERTE(obj1->GetSize() == obj2->GetSize());

	TypeHandle pTh = obj1->GetTypeHandle();

	return (memcmp(obj1->GetData(),obj2->GetData(),pTh.GetSize()) == 0);
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comvariant.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  COMVariant
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Native Implementation of the Variant Class
**
** Date:  July 22, 1998
** 
===========================================================*/

#include "common.h"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMVariant.h"
#include "metasig.h"
#include "COMString.h"
#include "COMStringCommon.h"
#include "COMMember.h"
#include "field.h"

//
// Class Variable Initialization
//
EEClass *COMVariant::s_pVariantClass=NULL;
ArrayTypeDesc* COMVariant::s_pVariantArrayTypeDesc;
LPCUTF8 primitiveFieldName = "m_value";
LPCUTF8 ToStringName = "ToString";
LPCUTF8 EqualsName = "Equals";
LPCUTF8 ConstructorName = COR_CTOR_METHOD_NAME;
LPCUTF8 ChangeTypeName = "ChangeType";
static LPCUTF8 szOAVariantClass = "Microsoft.Win32.OAVariantLib";

MethodDesc* COMVariant::pChangeTypeMD = 0;
MethodDesc* COMVariant::pOAChangeTypeMD = 0;


//The Name of the classes and the eeClass that we've looked up
//for them.  The eeClass is initialized to null in all instances.
ClassItem CVClasses[] = {
    {CLASS__EMPTY,   NULL, NULL},  //CV_EMPTY
    {CLASS__VOID,    NULL, NULL},  //CV_VOID, Changing this to object messes up signature resolution very badly.
    {CLASS__BOOLEAN, NULL, NULL},  //CV_BOOLEAN
    {CLASS__CHAR,    NULL, NULL},  //CV_CHAR
    {CLASS__SBYTE,   NULL, NULL},  //CV_I1
    {CLASS__BYTE,    NULL, NULL},  //CV_U1
    {CLASS__INT16,   NULL, NULL},  //CV_I2
    {CLASS__UINT16,  NULL, NULL},  //CV_U2
    {CLASS__INT32,   NULL, NULL},  //CV_I4
    {CLASS__UINT32,  NULL, NULL},  //CV_UI4
    {CLASS__INT64,   NULL, NULL},  //CV_I8
    {CLASS__UINT64,  NULL, NULL},  //CV_UI8
    {CLASS__SINGLE,  NULL, NULL},  //CV_R4   
    {CLASS__DOUBLE,  NULL, NULL},  //CV_R8   
    {CLASS__STRING,  NULL, NULL},  //CV_STRING
    {CLASS__VOID,  NULL, NULL},  //CV_PTR...We treat this as void
    {CLASS__DATE_TIME,NULL, NULL},  //CV_DATETIME
    {CLASS__TIMESPAN,NULL, NULL},  //CV_TIMESPAN
    {CLASS__OBJECT,  NULL, NULL},  //CV_OBJECT
    {CLASS__DECIMAL, NULL, NULL},  //CV_DECIMAL
    {CLASS__CURRENCY,NULL, NULL},  //CV_CURRENCY
    {CLASS__OBJECT,  NULL, NULL},  //ENUM...We treat this as OBJECT
    {CLASS__MISSING, NULL, NULL},  //CV_MISSING
    {CLASS__NULL,    NULL, NULL},  //CV_NULL
    {CLASS__NIL, NULL, NULL},                    //CV_LAST
};

// The Attributes Table
//  20 bits for built in types and 12 bits for Properties
//  The properties are followed by the widening mask.  All types widen to them selves.
DWORD COMVariant::VariantAttributes[CV_LAST][2] = {
    {0x01,      0x00},                      // CV_EMPTY
    {0x02,      0x00},                      // CV_VOID
    {0x04,      CVA_Primitive | 0x0004},    // CV_BOOLEAN
    {0x08,      CVA_Primitive | 0x3F88},    // CV_CHAR (W = U2, CHAR, I4, U4, I8, U8, R4, R8) (U2 == Char)
    {0x10,      CVA_Primitive | 0x3550},    // CV_I1   (W = I1, I2, I4, I8, R4, R8) 
    {0x20,      CVA_Primitive | 0x3FE8},    // CV_U1   (W = CHAR, U1, I2, U2, I4, U4, I8, U8, R4, R8)
    {0x40,      CVA_Primitive | 0x3540},    // CV_I2   (W = I2, I4, I8, R4, R8)
    {0x80,      CVA_Primitive | 0x3F88},    // CV_U2   (W = U2, CHAR, I4, U4, I8, U8, R4, R8)
    {0x0100,    CVA_Primitive | 0x3500},    // CV_I4   (W = I4, I8, R4, R8)
    {0x0200,    CVA_Primitive | 0x3E00},    // CV_U4   (W = U4, I8, R4, R8)
    {0x0400,    CVA_Primitive | 0x3400},    // CV_I8   (W = I8, R4, R8)
    {0x0800,    CVA_Primitive | 0x3800},    // CV_U8   (W = U8, R4, R8)
    {0x1000,    CVA_Primitive | 0x3000},    // CV_R4   (W = R4, R8)
    {0x2000,    CVA_Primitive | 0x2000},    // CV_R8   (W = R8) 
    {0x4000,    0x00},                      // CV_STRING
    {0x8000,    0x00},                      // CV_PTR
    {0x01000,   0x00},                      // CV_DATETIME
    {0x020000,  0x00},                      // CV_TIMESPAN
    {0x040000,  0x00},                      // CV_OBJECT
    {0x080000,  0x00},                      // CV_DECIMAL
    {0x100000,  0x00},                      // CV_CURRENCY
    {0x200000,  0x00},                      // CV_MISSING
    {0x400000,  0x00}                       // CV_NULL
};
DWORD COMVariant::Attr_Mask     = 0xFF000000;
DWORD COMVariant::Widen_Mask    = 0x00FFFFFF;
//
// Current Conversions
// 

#ifdef FCALLAVAILABLE
FCIMPL1(R4, COMVariant::GetR4FromVar, VariantData* var) {
    _ASSERTE(var);
    return *(R4 *) var->GetData();
}
FCIMPLEND
#else
R4 COMVariant::GetR4FromVar(_getR4FromVarArgs *args) {
    _ASSERTE(args);
    _ASSERTE(args->var);

    return *(R4 *)args->var->GetData();
} 
#endif
    
#ifdef FCALLAVAILABLE
FCIMPL1(R8, COMVariant::GetR8FromVar, VariantData* var) {
    _ASSERTE(var);
    return *(R8 *) var->GetData();
}
FCIMPLEND
#else
R8 COMVariant::GetR8FromVar(_getR8FromVarArgs *args) {
    _ASSERTE(args);
    _ASSERTE(args->var);

    return *(R8 *)args->var->GetData();
}    
#endif


//
// Helper Routines
//

/*=================================LoadVariant==================================
**Action:  Initializes the variant class within the runtime.  Stores pointers to the
**         EEClass and MethodTable in static members of COMVariant
**
**Arguments: None
**
**Returns: S_OK if everything succeeded, else E_FAIL
**
**Exceptions: None.
==============================================================================*/
HRESULT __stdcall COMVariant::LoadVariant() {
    THROWSCOMPLUSEXCEPTION();

    // @perf: switch this to a method table if we ever care about this code again
    s_pVariantClass = g_Mscorlib.FetchClass(CLASS__VARIANT)->GetClass();
    s_pVariantArrayTypeDesc = g_Mscorlib.FetchType(TYPE__VARIANT_ARRAY).AsArray();

    // Fixup the ELEMENT_TYPE Void
    // We never create one of these, but we do depend on the value on the class being set properly in 
    // reflection.
    EEClass* pVoid = GetTypeHandleForCVType(CV_VOID).GetClass();
    pVoid->GetMethodTable()->m_NormType = ELEMENT_TYPE_VOID;


    // Run class initializers for Empty, Missing, and Null to set Value field
    OBJECTREF Throwable = NULL;
    if (!GetTypeHandleForCVType(CV_EMPTY).GetClass()->DoRunClassInit(&Throwable) ||
        !GetTypeHandleForCVType(CV_MISSING).GetClass()->DoRunClassInit(&Throwable) ||
        !GetTypeHandleForCVType(CV_NULL).GetClass()->DoRunClassInit(&Throwable) ||
        !pVoid->DoRunClassInit(&Throwable))
    {
        GCPROTECT_BEGIN(Throwable);
        COMPlusThrow(Throwable);
        GCPROTECT_END();
    }



    return S_OK;
}

// Returns System.Empty.Value.
OBJECTREF VariantData::GetEmptyObjectRef() const
{
    LPHARDCODEDMETASIG sig = &gsig_Fld_Empty;
    if (CVClasses[CV_EMPTY].ClassInstance==NULL)
        CVClasses[CV_EMPTY].ClassInstance = GetTypeHandleForCVType(CV_EMPTY).GetClass();
    FieldDesc * pFD = CVClasses[CV_EMPTY].ClassInstance->FindField("Value", sig);
    _ASSERTE(pFD);
    OBJECTREF obj = pFD->GetStaticOBJECTREF();
    _ASSERTE(obj!=NULL);
    return obj;
}


/*===============================GetMethodByName================================
**Action:  Get a method of name pwzMethodName from class eeMethodClass.  This 
**         method doesn't deal with two conversion methods of the same name with
**         different signatures.  We need to establish by fiat that such a thing
**         is impossible.
**Arguments:  eeMethodClass -- the class on which to look for the given method.
**            pwzMethodName -- the name of the method to find.
**Returns: A pointer to the MethodDesc for the appropriate method or NULL if the
**         named method isn't found.
**Exceptions: None.
==============================================================================*/
//@ToDo:  This code is very similar to COMClass::GetMethod.  Can we unify these?
MethodDesc *GetMethodByName(EEClass *eeMethodClass, LPCUTF8 pwzMethodName) {

    _ASSERTE(eeMethodClass);
    _ASSERTE(pwzMethodName);

    DWORD limit = eeMethodClass->GetNumMethodSlots();; 
    
    for (DWORD i = 0; i < limit; i++) {
        MethodDesc *pCurMethod = eeMethodClass->GetUnknownMethodDescForSlot(i);
        if (pCurMethod != NULL)
            if (strcmp(pwzMethodName, pCurMethod->GetName((USHORT) i)) == 0)
            return pCurMethod;
    }
    return NULL;  //We never found a matching method.
}


/*===============================VariantGetClass================================
**Action:  Given a cvType, returns the associated EEClass.  We cache this information
**         so once we've looked it up once, we can get it very quickly the next time.
**Arguments: cvType -- the type of the class to retrieve.
**Returns: An EEClass for the given CVType.  If we don't know what CVType represents
**         or if it's CV_UNKOWN or CV_VOID, we just return NULL.
**Exceptions: None.
==============================================================================*/
EEClass *COMVariant::VariantGetClass(const CVTypes cvType) {
    _ASSERTE(cvType>=CV_EMPTY);
    _ASSERTE(cvType<CV_LAST);
    return GetTypeHandleForCVType(cvType).GetClass();
}


/*===============================GetTypeFromClass===============================
**Action: The complement of VariantGetClass, takes an EEClass * and returns the 
**        associated CVType.
**Arguments: EEClass * -- a pointer to the class for which we want the CVType.
**Returns:  The CVType associated with the EEClass or CV_OBJECT if this can't be 
**          determined.
**Exceptions: None
==============================================================================*/
//@ToDo: Replace this method with a class lookup that's faster than a linear search.
CVTypes COMVariant::GetCVTypeFromClass(EEClass *eeCls) {

    if (!eeCls) {
        return CV_EMPTY;
    }
    //@ToDo:  incrementing an integer and casting it to a CVTypes is officially
    //        undefined, but it appears to work.  Revisit this on CE and other
    //        platforms.

    //We'll start looking from Variant.  Empty and Void are handled below.
    for (int i=CV_EMPTY; i<CV_LAST; i++) {      
        if (eeCls == GetTypeHandleForCVType((CVTypes)i).GetClass()) {
            return (CVTypes)i;
        }
    }

    // The 1 check is a complete hack because COM classic
    //  object may have an EEClass of 1.  If it is 1 we return
    //  CV_OBJECT
    if (eeCls != (EEClass*) 1 && eeCls->IsEnum())
        return CV_ENUM;
    return CV_OBJECT;
    
}

CVTypes COMVariant::GetCVTypeFromTypeHandle(TypeHandle th)
{

    if (th.IsNull()) {
        return CV_EMPTY;
    }

    //We'll start looking from Variant.  Empty and Void are handled below.
    for (int i=CV_EMPTY; i<CV_LAST; i++) {      
        if (th == GetTypeHandleForCVType((CVTypes)i)) {
            return (CVTypes) i;
        }
    }

    if (th.IsEnum())
        return CV_ENUM;

    return CV_OBJECT;
}

// This code should be moved out of Variant and into Type.
FCIMPL1(INT32, COMVariant::GetCVTypeFromClassWrapper, ReflectClassBaseObject* refType)
{
    VALIDATEOBJECTREF(refType);
    _ASSERTE(refType->GetData());

    ReflectClass* pRC = (ReflectClass*) refType->GetData();

    // Find out if this type is a primitive or a class object
    return pRC->GetCorElementType();
    
}
FCIMPLEND

/*==================================NewVariant==================================
**N.B.:  This method does a GC Allocation.  Any method calling it is required to
**       GC_PROTECT the OBJECTREF.
**
**Actions:  Allocates a new Variant and fills it with the appropriate data.  
**Returns:  A new Variant with all of the appropriate fields filled out.
**Exceptions: OutOfMemoryError if v can't be allocated.       
==============================================================================*/
void COMVariant::NewVariant(VariantData* dest, const CVTypes type, OBJECTREF *or, void *pvData) {
    
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE((type!=CV_EMPTY && type!=CV_NULL && type!=CV_MISSING) || or==NULL);  // Don't pass an object in for Empty.

    //If both arguments are null or both are specified, we're in an illegal situation.  Bail.
    //If all three are null, we're creating an empty variant
    if ((type >= CV_LAST || type < 0) || (or && pvData) || 
        (!or && !pvData && (type!=CV_EMPTY && type!=CV_NULL && type != CV_MISSING))) {
        COMPlusThrow(kArgumentException);
    }

    // TODO: This is a hack to work around a VC7 bug
    // Please remove this hack when the bug is fixed.
    OBJECTREF ObjNull;
    ObjNull = NULL;
    
    //Fill in the data.
    dest->SetType(type);
    if (or) {
        if (*or != NULL) {
            EEClass* pEEC = (*or)->GetClass();
            if (!pEEC->IsValueClass()) {
                dest->SetObjRef(*or);
            }
            else {
                if (pEEC==s_pVariantClass) {
                    VariantData* pVar = (VariantData *) (*or)->UnBox();
                    dest->SetObjRef(pVar->GetObjRef());
                    dest->SetFullTypeInfo(pVar->GetFullTypeInfo());
                    dest->SetDataAsInt64(pVar->GetDataAsInt64());
                    return;
                }
                void* UnboxData = (*or)->UnBox();
                CVTypes cvt = GetCVTypeFromClass(pEEC);
                if (cvt>=CV_BOOLEAN && cvt<=CV_U4) {
                    dest->SetObjRef(NULL);
                    dest->SetDataAsInt64(*((INT32 *)UnboxData));
                    dest->SetType(cvt);
                } else if ((cvt>=CV_I8 && cvt<=CV_R8) || (cvt==CV_DATETIME)
                           || (cvt==CV_TIMESPAN) || (cvt==CV_CURRENCY)) {
                    dest->SetObjRef(NULL);
                    dest->SetDataAsInt64(*((INT64 *)UnboxData));
                    dest->SetType(cvt);
                } else if (cvt == CV_ENUM) {
                    TypeHandle th = (*or)->GetTypeHandle();
                    dest->SetType(GetEnumFlags(th.AsClass()));
                    switch(th.GetNormCorElementType()) {
                    case ELEMENT_TYPE_I1:
                    case ELEMENT_TYPE_U1:
                        dest->SetDataAsInt64(*((INT8 *)UnboxData));
                        break;

                    case ELEMENT_TYPE_I2:
                    case ELEMENT_TYPE_U2:
                        dest->SetDataAsInt64(*((INT16 *)UnboxData));
                        break;

                    IN_WIN32(case ELEMENT_TYPE_U:)
                    IN_WIN32(case ELEMENT_TYPE_I:)
                    case ELEMENT_TYPE_I4:
                    case ELEMENT_TYPE_U4:
                        dest->SetDataAsInt64(*((INT32 *)UnboxData));
                        break;

                    IN_WIN64(case ELEMENT_TYPE_U:)
                    IN_WIN64(case ELEMENT_TYPE_I:)
                    case ELEMENT_TYPE_I8:
                    case ELEMENT_TYPE_U8:
                        dest->SetDataAsInt64(*((INT64 *)UnboxData));
                        break;
                        
                    default:
                        _ASSERTE(!"Unsupported enum type when calling NewVariant");
                    }
                    dest->SetObjRef(th.CreateClassObj());
               } else {
                    // Decimal and other boxed value classes handled here.
                    dest->SetObjRef(*or);
                    dest->SetData(0);
                }
                return;
            }
        }
        else {
            dest->SetObjRef(*or);
        }

        dest->SetDataAsInt64(0);
        return;
    }

    // This is the case for both a null OBJECTREF or a primitive type.
    switch (type) {
        // Must get sign extension correct for all types smaller than an Int32.
    case CV_I1:
        _ASSERTE(pvData);
        dest->SetObjRef(NULL);
        dest->SetDataAsInt8(*((INT8 *)pvData));
        break;

    case CV_U1:
    case CV_BOOLEAN:
        _ASSERTE(pvData);
        dest->SetObjRef(NULL);
        dest->SetDataAsUInt8(*((UINT8 *)pvData));
        break;

    case CV_I2:
        _ASSERTE(pvData);
        dest->SetObjRef(NULL);
        dest->SetDataAsInt16(*((INT16 *)pvData));
        break;

    case CV_U2:
    case CV_CHAR:
        _ASSERTE(pvData);
        dest->SetObjRef(NULL);
        dest->SetDataAsUInt16(*((UINT16 *)pvData));
        break;
        
    case CV_I4:
        _ASSERTE(pvData);
        dest->SetObjRef(NULL);
        dest->SetDataAsInt32(*((INT32 *)pvData));
        break;

    case CV_U4:
    case CV_R4:  // we need to do a bitwise copy only.
        _ASSERTE(pvData);
        dest->SetObjRef(NULL);
        dest->SetDataAsUInt32(*((UINT32 *)pvData));
        break;
        
    case CV_I8:
    case CV_U8:
    case CV_R8:  // we need to do a bitwise copy only.
    case CV_DATETIME:
    case CV_CURRENCY:
    case CV_TIMESPAN:
        _ASSERTE(pvData);
        dest->SetObjRef(NULL);
        dest->SetDataAsInt64(*((INT64 *)pvData));
        break;

    case CV_MISSING:
    case CV_NULL:
        {
            LPHARDCODEDMETASIG sig = &gsig_Fld_Missing;
            if (type==CV_NULL)
                sig = &gsig_Fld_Null;
            if (CVClasses[type].ClassInstance==NULL)
                CVClasses[type].ClassInstance = GetTypeHandleForCVType(type).GetClass();
            FieldDesc * pFD = CVClasses[type].ClassInstance->FindField("Value", sig);
            _ASSERTE(pFD);
            OBJECTREF obj = pFD->GetStaticOBJECTREF();
            _ASSERTE(obj!=NULL);
            dest->SetObjRef(obj);
            dest->SetDataAsInt64(0);
            return;
        }

    case CV_EMPTY:
    case CV_OBJECT:
    case CV_DECIMAL:
    case CV_STRING:
    {
        // TODO: This is a hack to work around a VC7 bug
        // Please remove this hack when the bug is fixed.
        // The code should be:
        // dest->SetObjRef(NULL);
        dest->SetObjRef(ObjNull);
        break;
    }
    
    case CV_VOID:
        _ASSERTE(!"Never expected Variants of type CV_VOID.");
        COMPlusThrow(kNotSupportedException, L"Arg_InvalidOleVariantTypeException");
        return;

    case CV_ENUM:   // Enums require the enum's RuntimeType.
    default:
        // Did you add any new CVTypes, such as CV_R or CV_I?
        _ASSERTE(!"This CVType in NewVariant requires a non-null OBJECTREF!");
        COMPlusThrow(kNotSupportedException, L"Arg_InvalidOleVariantTypeException");
        return;
    }
}


// We use byref here, because that TypeHandle::CreateClassObj
// may trigger GC.  If dest is on the GC heap, we have no way to protect
// dest.
void COMVariant::NewEnumVariant(VariantData* &dest,INT64 val, TypeHandle th)
{
    int type;
    // Find out what type we have.
    EEClass* pEEC = th.AsClass();
    type = GetEnumFlags(pEEC);


    dest->SetType(type);
    dest->SetDataAsInt64(val);
    dest->SetObjRef(th.CreateClassObj());
}

void COMVariant::NewPtrVariant(VariantData* &dest,INT64 val, TypeHandle th)
{
    int type;
    // Find out what type we have.
    type = CV_PTR;

    dest->SetType(type);
    dest->SetDataAsInt64(val);
    dest->SetObjRef(th.CreateClassObj());
}

int COMVariant::GetEnumFlags(EEClass* pEEC)
{

    _ASSERTE(pEEC);
    _ASSERTE(pEEC->IsEnum());

    FieldDescIterator fdIterator(pEEC, FieldDescIterator::INSTANCE_FIELDS);
    FieldDesc* p = fdIterator.Next();
    _ASSERTE(p);
    WORD fldCnt = pEEC->GetNumInstanceFields();
    _ASSERTE(fldCnt == 1);

    CorElementType cet = p[0].GetFieldType();
    switch (cet) {
    case ELEMENT_TYPE_I1:
        return (CV_ENUM | EnumI1);
    case ELEMENT_TYPE_U1:
        return (CV_ENUM | EnumU1);
    case ELEMENT_TYPE_I2:
        return (CV_ENUM | EnumI2);
    case ELEMENT_TYPE_U2:
        return (CV_ENUM | EnumU2);
    IN_WIN32(case ELEMENT_TYPE_I:)
    case ELEMENT_TYPE_I4:
        return (CV_ENUM | EnumI4);
    IN_WIN32(case ELEMENT_TYPE_U:)
    case ELEMENT_TYPE_U4:
        return (CV_ENUM | EnumU4);
    IN_WIN64(case ELEMENT_TYPE_I:)
    case ELEMENT_TYPE_I8:
        return (CV_ENUM | EnumI8);
    IN_WIN64(case ELEMENT_TYPE_U:)
    case ELEMENT_TYPE_U8:
        return (CV_ENUM | EnumU8);
    default:
        _ASSERTE(!"UNknown Type");
        return 0;
    }
}


void __stdcall COMVariant::RefAnyToVariant(_RefAnyToVariantArgs* args)
{
    THROWSCOMPLUSEXCEPTION();
    
    if (args->ptr == 0)
        COMPlusThrowArgumentNull(L"byrefValue");
    _ASSERTE(args->ptr != 0);
    _ASSERTE(args->var != 0);
    TypedByRef* typedByRef = (TypedByRef*) args->ptr;

    void* p = typedByRef->data;
    EEClass* cls = typedByRef->type.GetClass();
    BuildVariantFromTypedByRef(cls,p,args->var);
}

void COMVariant::BuildVariantFromTypedByRef(EEClass* cls,void* data,VariantData* var)
{

    if (cls == s_pVariantClass) {
        CopyValueClassUnchecked(var,data,s_pVariantClass->GetMethodTable());
        return;
    }
    CVTypes type = GetCVTypeFromClass(cls);
    if (type <= CV_R8 )
        NewVariant(var,type,0,data);
    else {
       if (type == CV_DATETIME || type == CV_TIMESPAN ||
            type == CV_CURRENCY) {
            NewVariant(var,type,0,data);
       }
       else {
            if (cls->IsValueClass()) {
                OBJECTREF retO = cls->GetMethodTable()->Box(data, FALSE);
                GCPROTECT_BEGIN(retO);
                COMVariant::NewVariant(var,&retO);
                GCPROTECT_END();
            }
            else {
                OBJECTREF o = ObjectToOBJECTREF(*((Object**)data));
                NewVariant(var,type,&o,0);
           }
       }
    }
    
}

void __stdcall COMVariant::VariantToTypedRefAnyEx(_VariantToTypedRefAnyExArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    VariantData newVar;

    EEClass* cls = args->typedByRef.type.GetClass();
    if (cls == s_pVariantClass) {
        void* p = args->typedByRef.data;
        CopyValueClassUnchecked(p,&args->var,s_pVariantClass->GetMethodTable());
        return;
    }
    CVTypes targetType = GetCVTypeFromClass(args->typedByRef.type.GetClass());
    CVTypes sourceType = (CVTypes) args->var.GetType();
    // see if we need to change the types
    if (targetType != sourceType) {
        if (!pChangeTypeMD)
            GetOAChangeTypeMethod();
        // Change type has a fixed signature that returns a new variant
        //  and takes a class
        MetaSig sig(pOAChangeTypeMD->GetSig(),pOAChangeTypeMD->GetModule());
        UINT    nStackBytes = sig.SizeOfVirtualFixedArgStack(TRUE);
        BYTE*   pNewArgs = (BYTE *) _alloca(nStackBytes);
        BYTE*   pDst= pNewArgs;


        // The short flag
        *(INT32 *) pDst = 0;
        pDst += sizeof(INT32);

        // This pointer is the variant passed in...
        *(INT32 *) pDst = targetType;
        pDst += sizeof(INT32);

        CopyValueClassUnchecked(pDst, &args->var, s_pVariantClass->GetMethodTable());
        pDst += sizeof(VariantData);

        // The return Variant
        *((void**) pDst) = &newVar;

        pOAChangeTypeMD->Call(pNewArgs,&sig);
    }
    else
        CopyValueClassUnchecked(&newVar, &args->var, s_pVariantClass->GetMethodTable());

    // Now set the value
    switch (targetType) {
    case CV_BOOLEAN:
    case CV_I1:
    case CV_U1:
    case CV_CHAR:
    case CV_I4:
    case CV_R4:
    case CV_I2:
        *(int*) args->typedByRef.data = (int) newVar.GetDataAsInt64();
        break;

    case CV_I8:
    case CV_R8:
    case CV_DATETIME:
    case CV_TIMESPAN:
    case CV_CURRENCY:
        *(INT64*) args->typedByRef.data = newVar.GetDataAsInt64();
        break;

    case CV_DECIMAL:
    case CV_EMPTY:
    case CV_STRING:
    case CV_VOID:
    case CV_OBJECT:
    default:
        *(OBJECTREF*) args->typedByRef.data = newVar.GetObjRef();
        break;
    }
}


// This version is an internal helper function in Variant as a helper function to 
// TypedReference class. We already have verified that the types are compatable.
void __stdcall COMVariant::VariantToTypedReferenceAnyEx(_VariantToTypedReferenceExArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    VariantData newVar;
    CVTypes targetType = GetCVTypeFromClass(args->typedReference.type.GetClass());
    CopyValueClassUnchecked(&newVar, &args->var, s_pVariantClass->GetMethodTable());

    // Now set the value
    switch (targetType) {
    case CV_BOOLEAN:
    case CV_I1:
    case CV_U1:
    case CV_CHAR:
    case CV_I4:
    case CV_R4:
    case CV_I2:
        *(int*) args->typedReference.data = (int) newVar.GetDataAsInt64();
        break;

    case CV_I8:
    case CV_R8:
    case CV_DATETIME:
    case CV_TIMESPAN:
    case CV_CURRENCY:
        *(INT64*) args->typedReference.data = newVar.GetDataAsInt64();
        break;

    case CV_DECIMAL:
    case CV_EMPTY:
    case CV_STRING:
    case CV_VOID:
    case CV_OBJECT:
    default:
        *(OBJECTREF*) args->typedReference.data = newVar.GetObjRef();
        break;
    }
}


void __stdcall COMVariant::VariantToRefAny(_VariantToRefAnyArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    VariantData newVar;
    if (args->ptr == 0)
        COMPlusThrowArgumentNull(L"byrefValue");
    TypedByRef* typedByRef = (TypedByRef*) args->ptr;
    EEClass* cls = typedByRef->type.GetClass();
    if (cls == s_pVariantClass) {
        void* p = typedByRef->data;
        CopyValueClassUnchecked(p,&args->var,s_pVariantClass->GetMethodTable());
        return;
    }
    CVTypes targetType = GetCVTypeFromClass(typedByRef->type.GetClass());
    CVTypes sourceType = (CVTypes) args->var.GetType();
    // see if we need to change the types
    if (targetType != sourceType) {
        if (!pChangeTypeMD)
            GetOAChangeTypeMethod();
        // Change type has a fixed signature that returns a new variant
        //  and takes a class
        MetaSig sig(pOAChangeTypeMD->GetSig(),pOAChangeTypeMD->GetModule());
        UINT    nStackBytes = sig.SizeOfVirtualFixedArgStack(TRUE);
        BYTE*   pNewArgs = (BYTE *) _alloca(nStackBytes);
        BYTE*   pDst= pNewArgs;


        // The short flag
        *(INT32 *) pDst = 0;
        pDst += sizeof(INT32);

        // This pointer is the variant passed in...
        *(INT32 *) pDst = targetType;
        pDst += sizeof(INT32);

        CopyValueClassUnchecked(pDst, &args->var, s_pVariantClass->GetMethodTable());
        pDst += sizeof(VariantData);

        // The return Variant
        *((void**) pDst) = &newVar;

        pOAChangeTypeMD->Call(pNewArgs,&sig);
    }
    else
        CopyValueClassUnchecked(&newVar, &args->var, s_pVariantClass->GetMethodTable());

    // Now set the value
    switch (targetType) {
    case CV_BOOLEAN:
    case CV_I1:
    case CV_U1:
    case CV_CHAR:
    case CV_I4:
    case CV_R4:
    case CV_I2:
        *(int*) typedByRef->data = (int) newVar.GetDataAsInt64();
        break;

    case CV_I8:
    case CV_R8:
    case CV_DATETIME:
    case CV_TIMESPAN:
    case CV_CURRENCY:
        *(INT64*) typedByRef->data = newVar.GetDataAsInt64();
        break;

    case CV_DECIMAL:
    case CV_EMPTY:
    case CV_STRING:
    case CV_VOID:
    case CV_OBJECT:
    default:
        *(OBJECTREF*) typedByRef->data = newVar.GetObjRef();
        break;
    }
}

void __stdcall COMVariant::TypedByRefToVariantEx(_TypedByRefToVariantExArgs* args)
{
    THROWSCOMPLUSEXCEPTION();
    CorElementType cType = args->value.type.GetNormCorElementType();
    // @TODO: We don't support pointers yet...
    if (cType == ELEMENT_TYPE_PTR) {
        COMPlusThrow(kNotSupportedException,L"NotSupported_ArrayOnly");
    }
    _ASSERTE(args->value.type.GetMethodTable() != 0);
    _ASSERTE(args->value.data != 0);
    EEClass* cls = args->value.type.GetClass();
    void* p = args->value.data;
    BuildVariantFromTypedByRef(cls,p,args->var);
}

// This will find the ChangeType method.  There
//  should only be one.
void COMVariant::GetChangeTypeMethod()
{
    _ASSERTE(s_pVariantClass);
    if (pChangeTypeMD)
        return;

    DWORD slotCnt = s_pVariantClass->GetNumVtableSlots();
    DWORD loopCnt = s_pVariantClass->GetNumMethodSlots() - slotCnt;
    for(DWORD i=0; i<loopCnt; i++) {
        // Get the MethodDesc for current method
        MethodDesc* pCurMethod = s_pVariantClass->GetUnknownMethodDescForSlot(i + slotCnt);
        if (strcmp(pCurMethod->GetName((USHORT) i),ChangeTypeName) == 0) {
            pChangeTypeMD = pCurMethod;
            //return;
        }
    }
    //_ASSERTE(!"ChangeType not found");
    return;

}
  
void COMVariant::GetOAChangeTypeMethod()
{
    EEClass* pOA = SystemDomain::SystemAssembly()->LookupTypeHandle(szOAVariantClass, NULL).GetClass();
    _ASSERTE(pOA);
    DWORD loopCnt = pOA->GetNumMethodSlots();
    for(DWORD i=0; i<loopCnt; i++) {
        // Get the MethodDesc for current method
        MethodDesc* pCurMethod = pOA->GetUnknownMethodDescForSlot(i);
        if (strcmp(pCurMethod->GetName((USHORT) i),ChangeTypeName) == 0) {
            if (IsMdPrivate(pCurMethod->GetAttrs())) {
                pOAChangeTypeMD = pCurMethod;
                break;
            }
        }
    }
    _ASSERTE(pOAChangeTypeMD);
    return;
}  


/*=================================SetFieldsR4==================================
**
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL2(void, COMVariant::SetFieldsR4, VariantData* var, R4 val) {
    INT64 tempData;

    _ASSERTE(var);
   tempData = *((INT32 *)(&val));
    var->SetData(&tempData);
    var->SetType(CV_R4);
}
FCIMPLEND
#else
void __stdcall COMVariant::SetFieldsR4(_setFieldsR4Args *args) {
    INT64 tempData;
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    tempData = *((INT32 *)(&args->val));
    args->var->SetData(&tempData);
    args->var->SetType(CV_R4);
}
#endif


/*=================================SetFieldsR8==================================
**
==============================================================================*/
#ifdef FCALLAVAILABLE
FCIMPL2(void, COMVariant::SetFieldsR8, VariantData* var, R8 val) {
    _ASSERTE(var);
    var->SetData((void *)(&val));
    var->SetType(CV_R8);
}
FCIMPLEND
#else
void __stdcall COMVariant::SetFieldsR8(_setFieldsR8Args *args) {
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);

    args->var->SetData((void *)(&args->val));
    args->var->SetType(CV_R8);
}
#endif


/*===============================SetFieldsObject================================
**
==============================================================================*/
#ifdef FCALLAVAILABLE
#ifdef PLATFORM_CE
#pragma optimize( "y", off )
#endif // PLATFORM_CE
FCIMPL2(void, COMVariant::SetFieldsObject, VariantData* var, Object* vVal) {

    _ASSERTE(var);
    OBJECTREF val = ObjectToOBJECTREF(vVal);

    EEClass *valClass;
    void *UnboxData;
    CVTypes cvt;
    TypeHandle typeHandle;

    valClass = val->GetClass();

    //If this isn't a value class, we should just skip out because we're not going
    //to do anything special with it.
    if (!valClass->IsValueClass()) {
        var->SetObjRef(val);
        typeHandle = TypeHandle(valClass->GetMethodTable());
        if (typeHandle==GetTypeHandleForCVType(CV_MISSING)) {
            var->SetType(CV_MISSING);
        } else if (typeHandle==GetTypeHandleForCVType(CV_NULL)) {
            var->SetType(CV_NULL);
        } else if (typeHandle==GetTypeHandleForCVType(CV_EMPTY)) {
            var->SetType(CV_EMPTY);
            var->SetObjRef(NULL);
        } else {
            var->SetType(CV_OBJECT);
        }
        return;  
    }

    _ASSERTE(valClass->IsValueClass());

    //If this is a primitive type, we need to unbox it, get the value and create a variant
    //with just those values.
    UnboxData = val->UnBox();

    ClearObjectReference (var->GetObjRefPtr());
    typeHandle = TypeHandle(valClass->GetMethodTable());
    CorElementType cet = typeHandle.GetSigCorElementType();
    if (cet>=ELEMENT_TYPE_BOOLEAN && cet<=ELEMENT_TYPE_STRING) {
        cvt = (CVTypes)cet;
    } else {
        // This could potentially load a type which could cause a GC.
        HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame
        cvt = GetCVTypeFromClass(valClass);
        HELPER_METHOD_FRAME_END();
    }
    var->SetType(cvt);


    //copy all of the data.
    // Copies must be done based on the exact number of bytes to copy.
    // We don't want to read garbage from other blocks of memory.
    //CV_I8 --> CV_R8, CV_DATETIME, CV_TIMESPAN, & CV_CURRENCY are all of the 8 byte quantities
    //If we don't find one of those ranges, we've found a value class 
    //of which we don't have inherent knowledge, so just slam that into an
    //ObjectRef.
    if (cvt>=CV_BOOLEAN && cvt<=CV_U1 && cvt != CV_CHAR) {
        var->SetDataAsInt64(*((UINT8 *)UnboxData));
    } else if (cvt==CV_CHAR || cvt>=CV_I2 && cvt<=CV_U2) {
        var->SetDataAsInt64(*((UINT16 *)UnboxData));
    } else if (cvt>=CV_I4 && cvt<=CV_U4 || cvt==CV_R4) {
        var->SetDataAsInt64(*((UINT32 *)UnboxData));
    } else if ((cvt>=CV_I8 && cvt<=CV_R8) || (cvt==CV_DATETIME)
               || (cvt==CV_TIMESPAN) || (cvt==CV_CURRENCY)) {
        var->SetDataAsInt64(*((INT64 *)UnboxData));
    } else if (cvt==CV_EMPTY || cvt==CV_NULL || cvt==CV_MISSING) {
        var->SetType(cvt);
    } else if (cvt==CV_ENUM) {
        //This could potentially allocate a new object, so we set up a frame.
        HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame
        GCPROTECT_BEGININTERIOR(var)
        var->SetDataAsInt64(*((INT32 *)UnboxData));
        var->SetObjRef(typeHandle.CreateClassObj());
        var->SetType(GetEnumFlags(typeHandle.AsClass()));
        GCPROTECT_END();
        HELPER_METHOD_FRAME_END();
    } else {
        // Decimals and other boxed value classes get handled here.
        var->SetObjRef(val);
    }

    FC_GC_POLL();
}
FCIMPLEND

#ifdef PLATFORM_CE
#pragma optimize( "y", on )
#endif // PLATFORM_CE
#else // !FCALLAVAILABLE
void __stdcall COMVariant::SetFieldsObject(_setFieldsObjectArgs *args) {
    EEClass *valClass;
    void *UnboxData;
    CVTypes cvt;
    TypeHandle typeHandle;

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);
    _ASSERTE(args->var!=NULL);

    valClass = args->val->GetClass();
    //If this isn't a value class, we should just skip out because we're not going
    //to do anything special with it.
    if (!valClass->IsValueClass()) {
        args->var->SetObjRef(args->val);
        args->var->SetType(CV_OBJECT);
        return;  // Variant.cool already set m_type to CV_OBJECT.
    }

    _ASSERTE(valClass->IsValueClass());

    //If this is a primitive type, we need to unbox it, get the value and create a variant
    //with just those values.
    UnboxData = args->val->UnBox();
    ClearObjectReference (args->var->GetObjRefPtr());
    typeHandle = TypeHandle(valClass->GetMethodTable());
    CorElementType cet = typeHandle.GetCorElementType();
    if (cet>=ELEMENT_TYPE_BOOLEAN && cet<=ELEMENT_TYPE_STRING) {
        cvt = (CVTypes)cet;
    } else {
        cvt = GetCVTypeFromClass(valClass);
    }
    args->var->SetType(cvt);

    //copy all of the data.
    // Copies must be done based on the exact number of bytes to copy.
    // We don't want to read garbage from other blocks of memory.
    //CV_I8 --> CV_R8, CV_DATETIME, CV_TIMESPAN, & CV_CURRENCY are all of the 8 byte quantities
    //If we don't find one of those ranges, we've found a value class 
    //of which we don't have inherent knowledge, so just slam that into an
    //ObjectRef.
    if (cvt>=CV_BOOLEAN && cvt<=CV_U1 && cvt != CV_CHAR) {
        args->var->SetDataAsInt64(*((INT8 *)UnboxData));
    } else if (cvt==CV_CHAR || cvt>=CV_I2 && cvt<=CV_U2) {
        args->var->SetDataAsInt64(*((INT16 *)UnboxData));
    } else if (cvt>=CV_I4 && cvt<=CV_U4 || cvt==CV_R4) {
        args->var->SetDataAsInt64(*((INT32 *)UnboxData));
    } else if ((cvt>=CV_I8 && cvt<=CV_R8) || (cvt==CV_DATETIME)
               || (cvt==CV_TIMESPAN) || (cvt==CV_CURRENCY)) {
        args->var->SetDataAsInt64(*((INT64 *)UnboxData));
    } else if (cvt==CV_EMPTY || cvt==CV_NULL || cvt==CV_MISSING) {
        //Do nothing.  The data's already been 0'd and the object reference set the null.
    } else if (cvt==CV_ENUM) {
        args->var->SetDataAsInt64(*((INT32 *)UnboxData));
        args->var->SetObjRef(typeHandle.CreateClassObj());
        args->var->SetType(GetEnumFlags(typeHandle.AsClass()));
    } else {
        // Decimals and other boxed value classes get handled here.
        args->var->SetObjRef(args->val);
    }
}
#endif // !FCALLAVAILABLE


/*=============================Create4BytePrimitive=============================
**Action:  
==============================================================================*/
OBJECTREF Create4BytePrimitive (INT64 data, EEClass *eec, CVTypes cvt) {
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF obj;
    MethodTable* pMT = eec->GetMethodTable();
    _ASSERTE(pMT);


    switch (cvt) {
    case CV_BOOLEAN:
    case CV_I1:
    case CV_U1:
    case CV_CHAR:
    case CV_I2:
    case CV_U2:
    case CV_I4:
    case CV_U4:
    case CV_R4:
        obj = pMT->Box(&data, FALSE);
        break;
    default:
        _ASSERTE(!"Unsupported 4 byte primitive type!");
        COMPlusThrow(kNotSupportedException);
        obj = NULL;
    };
    return obj;
    
}

/*=============================Create8BytePrimitive=============================
**
==============================================================================*/
OBJECTREF Create8BytePrimitive (INT64 data, EEClass *eec, CVTypes cvt) {
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF obj;
    MethodTable* pMT = eec->GetMethodTable();
    _ASSERTE(pMT);


    switch (cvt) {
    case CV_I8:
    case CV_U8:
    case CV_R8:
    case CV_CURRENCY:
    case CV_DATETIME:
    case CV_TIMESPAN:
        obj = pMT->Box(&data, FALSE);
        break;

    default:
        _ASSERTE(!"Unsupported 8 byte primitive type!");
        COMPlusThrow(kNotSupportedException);
        obj = NULL;
    };

    return obj;
}
    
/*================================GetBoxedObject================================
**Action:  Generates a boxed object (Int32, Double, etc) or returns the 
**         currently held object.  This is more useful if you're certain that you
**         really need an Object.
==============================================================================*/
OBJECTREF COMVariant::GetBoxedObject(VariantData* vRef) {
    INT64 data;
    CVTypes cvt;


    switch (cvt=vRef->GetType()) {
    case CV_BOOLEAN:
    case CV_I1:
    case CV_U1:
    case CV_U2:
    case CV_U4:
    case CV_CHAR:
    case CV_I4:
    case CV_R4:
    case CV_I2:
        data = *(INT64 *)vRef->GetData();
        return Create4BytePrimitive(data, vRef->GetEEClass(), cvt);

    case CV_I8:
    case CV_R8:
    case CV_U8:
    case CV_DATETIME:
    case CV_TIMESPAN:
    case CV_CURRENCY:
        data = *(INT64 *)vRef->GetData();
        return Create8BytePrimitive(data, vRef->GetEEClass(), cvt);

    case CV_ENUM: {
        OBJECTREF or = vRef->GetObjRef();
        _ASSERTE(or != NULL);
        ReflectClass* pRC = (ReflectClass*) ((REFLECTCLASSBASEREF) or)->GetData();
        _ASSERTE(pRC);
        EEClass* pEEC = pRC->GetClass();
        _ASSERTE(pEEC);
        MethodTable* mt = pEEC->GetMethodTable();
        _ASSERTE(mt);
        or = mt->Box(vRef->GetData());
        return or;
    }

    case CV_VOID:
    case CV_DECIMAL:
    case CV_EMPTY:
    case CV_STRING:
    case CV_OBJECT:
    default:
        //Check for void done as an assert instead of an extra branch on the switch table s.t. we don't expand the
        //jump table.
        _ASSERTE(cvt!=CV_VOID || "We shouldn't have been able to create an instance of a void.");
        return vRef->GetObjRef(); //We already have an object, so we'll just give it back.
    };
}

void __stdcall COMVariant::InitVariant(LPVOID)
{
    EnsureVariantInitialized();
}

LPVOID __stdcall COMVariant::BoxEnum(_BoxEnumArgs *args)
{
    LPVOID rv;

    _ASSERTE(args->var);
    CVTypes vType = (CVTypes) args->var->GetType();
    _ASSERTE(vType == CV_ENUM);
    _ASSERTE(args->var->GetObjRef() != NULL);

    ReflectClass* pRC = (ReflectClass*) ((REFLECTCLASSBASEREF) args->var->GetObjRef())->GetData();
    _ASSERTE(pRC);

    MethodTable* mt = pRC->GetClass()->GetMethodTable();
    _ASSERTE(mt);

    OBJECTREF retO = mt->Box(args->var->GetData(), FALSE);
    *((OBJECTREF *)&rv) = retO;
    return rv;
}

TypeHandle VariantData::GetTypeHandle()
{
    if (GetType() == CV_ENUM || GetType() == CV_PTR) {
        _ASSERTE(GetObjRef() != NULL);
        ReflectClass* pRC = (ReflectClass*) ((REFLECTCLASSBASEREF) GetObjRef())->GetData();
        _ASSERTE(pRC);
        return pRC->GetTypeHandle();

    }
    if (GetType() != CV_OBJECT)
        return TypeHandle(GetTypeHandleForCVType(GetType()).GetMethodTable());
    if (GetObjRef() != NULL)
        return GetObjRef()->GetTypeHandle();
    return TypeHandle(g_pObjectClass);
}


// Use this very carefully.  There is not a direct mapping between
//  CorElementType and CVTypes for a bunch of things.  In this case
//  we return CV_LAST.  You need to check this at the call site.
CVTypes COMVariant::CorElementTypeToCVTypes(CorElementType type)
{
    if (type <= ELEMENT_TYPE_STRING)
        return (CVTypes) type;
    if (type == ELEMENT_TYPE_CLASS || type == ELEMENT_TYPE_OBJECT)
        return (CVTypes) ELEMENT_TYPE_CLASS;
    return CV_LAST;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comvariant.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMVariant
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Headers for the Variant class.
**
** Date:  July 22, 1998
** 
===========================================================*/

#ifndef _COMVARIANT_H_
#define _COMVARIANT_H_

#include <cor.h>
#include "fcall.h"


//These types must be kept in sync with the CorElementTypes defined in cor.h
//NOTE: If you add values to this enum you need to look at COMOAVariant.cpp.  There is
//      a mapping between CV type and VT types found there.
//NOTE: This is also found in a table in OleVariant.cpp.
//NOTE: These are also found in Variant.cool
typedef enum {
    CV_EMPTY               = 0x0,                   // CV_EMPTY
    CV_VOID                = ELEMENT_TYPE_VOID,
    CV_BOOLEAN             = ELEMENT_TYPE_BOOLEAN,
    CV_CHAR                = ELEMENT_TYPE_CHAR,
    CV_I1                  = ELEMENT_TYPE_I1,
    CV_U1                  = ELEMENT_TYPE_U1,
    CV_I2                  = ELEMENT_TYPE_I2,
    CV_U2                  = ELEMENT_TYPE_U2,
    CV_I4                  = ELEMENT_TYPE_I4,
    CV_U4                  = ELEMENT_TYPE_U4,
    CV_I8                  = ELEMENT_TYPE_I8,
    CV_U8                  = ELEMENT_TYPE_U8,
    CV_R4                  = ELEMENT_TYPE_R4,
    CV_R8                  = ELEMENT_TYPE_R8,
    CV_STRING              = ELEMENT_TYPE_STRING,

    // For the rest, we map directly if it is defined in CorHdr.h and fill
    //  in holes for the rest.
    CV_PTR                 = ELEMENT_TYPE_PTR,
    CV_DATETIME            = 0x10,      // ELEMENT_TYPE_BYREF
    CV_TIMESPAN            = 0x11,      // ELEMENT_TYPE_VALUETYPE
    CV_OBJECT              = ELEMENT_TYPE_CLASS,
    CV_DECIMAL             = 0x13,      // ELEMENT_TYPE_UNUSED1
    CV_CURRENCY            = 0x14,      // ELEMENT_TYPE_ARRAY
    CV_ENUM                = 0x15,      //
    CV_MISSING             = 0x16,      //
    CV_NULL                = 0x17,      //
    CV_LAST                = 0x18,      //
} CVTypes;

// This enum defines the attributes of the various "known" variants
// These are alway bit maps -- Type map to the top 12 bits of the Variant Attributes
typedef enum {
    CVA_Primitive          = 0x01000000
} CVAttr;

// The following values are used to represent underlying
//  type of the Enum..
#define EnumI1          0x100000
#define EnumU1          0x200000
#define EnumI2          0x300000
#define EnumU2          0x400000
#define EnumI4          0x500000
#define EnumU4          0x600000
#define EnumI8          0x700000
#define EnumU8          0x800000
#define EnumMask        0xF00000


//ClassItem is used to store the CVType of a class and a 
//reference to the EEClass.  Used for conversion between
//the two internally.
typedef struct {
    BinderClassID ClassID;
    EEClass *ClassInstance;
        /* TypeHandle */ void * typeHandle;
} ClassItem;

ClassItem CVClasses[];

inline TypeHandle GetTypeHandleForCVType(const unsigned int elemType) 
{
        _ASSERTE(elemType < CV_LAST);
        if (CVClasses[elemType].typeHandle == 0) {
            CVClasses[elemType].typeHandle = TypeHandle(g_Mscorlib.FetchClass(CVClasses[elemType].ClassID)).AsPtr();
        }

        return (TypeHandle)CVClasses[elemType].typeHandle;
}

#pragma pack(push)
#pragma pack(1)

class COMVariant;

/***  Variant Design Restrictions  (ie, decisions we've had to re-do differently):
      1)  A Variant containing all zeros should be a valid Variant of type empty.
      2)  Variant must contain an OBJECTREF field for Objects, etc.  Since we
          have no way of expressing a union between an OBJECTREF and an int, we
          always box Decimals in a Variant.
      3)  The m_type field is not a CVType and will contain extra bits.  People
          should use VariantData::GetType() to get the CVType.
      4)  You should use SetObjRef and GetObjRef to manipulate the OBJECTREF field.
          These will handle write barriers correctly, as well as CV_EMPTY.
      

   Empty, Missing & Null:
      Variants of type CV_EMPTY will be all zero's.  This forces us to add in
   special cases for all functions that convert a Variant into an object (such
   as copying a Variant into an Object[]).  

      Variants of type Missing and Null will have their objectref field set to 
   Missing.Value and Null.Value respectively.  This simplifies the code in 
   Variant.cool and strewn throughout the EE.
*/

#define VARIANT_TYPE_MASK  0xFFFF
#define VARIANT_ARRAY_MASK 0x00010000
#define VT_MASK            0xFF000000
#define VT_BITSHIFT        24

struct VariantData {
    private:
    OBJECTREF   m_or;
    INT32       m_type;
    INT64       m_data;

    public:

    __forceinline VariantData() : m_type(0), m_data(0) {}

    __forceinline CVTypes GetType() const {
        return (CVTypes)(m_type & VARIANT_TYPE_MASK);
    }

    __forceinline void SetType(INT32 in) {
        m_type = in;
    }

    __forceinline INT32 GetFullTypeInfo() const {
        return m_type;
    }

    __forceinline void SetFullTypeInfo(INT32 in) {
        m_type = in;
    }



    __forceinline VARTYPE GetVT() const {
        VARTYPE vt = (m_type & VT_MASK) >> VT_BITSHIFT;
        if (vt & 0x80)
        {
            vt &= ~0x80;
            vt |= VT_ARRAY;
        }
        return vt;
    }
    __forceinline void SetVT(VARTYPE vt)
    {
        _ASSERTE(!(vt & VT_BYREF));
        _ASSERTE( (vt & ~VT_ARRAY) < 128 );
        if (vt & VT_ARRAY)
        {
            vt &= ~VT_ARRAY;
            vt |= 0x80;
        }
        m_type = (m_type & ~((INT32)VT_MASK)) | (vt << VT_BITSHIFT);
    }



    EEClass* GetEEClass() {
        if ((m_type&VARIANT_TYPE_MASK) != CV_OBJECT)
            return GetTypeHandleForCVType(m_type&VARIANT_TYPE_MASK).GetClass();
        if (m_or != NULL)
            return m_or->GetClass();
        return g_pObjectClass->GetClass();
    }

    TypeHandle GetTypeHandle();

    OBJECTREF GetEmptyObjectRef() const;

    __forceinline OBJECTREF GetObjRef() const {
        if (GetType() == CV_EMPTY)
            return GetEmptyObjectRef();
        return m_or;
    }

    __forceinline OBJECTREF *GetObjRefPtr() {
        return &m_or;
    }

    __forceinline void SetObjRef(OBJECTREF or) {
        if (or!=NULL) {
            SetObjectReferenceUnchecked(&m_or, or);
        } else {
            // Casting trick to avoid going thru overloaded operator= (which
            // in this case would trigger a false write barrier violation assert.)
            *(LPVOID*)&m_or=NULL;
        }
    }
    
    __forceinline void *GetData() const {
        return (void *)(&m_data);
    }

    __forceinline INT8 GetDataAsInt8() const {
        return (INT8)m_data;
    }
    
    __forceinline UINT8 GetDataAsUInt8() const {
        return (UINT8)m_data;
    }
    
    __forceinline INT16 GetDataAsInt16() const {
        return (INT16)m_data;
    }
    
    __forceinline UINT16 GetDataAsUInt16() const {
        return (UINT16)m_data;
    }
    
    __forceinline INT32 GetDataAsInt32() const {
        return (INT32)m_data;
    }
    
    __forceinline UINT32 GetDataAsUInt32() const {
        return (UINT32)m_data;
    }
    
    __forceinline INT64 GetDataAsInt64() const {
        return (INT64)m_data;
    }
    
    __forceinline UINT64 GetDataAsUInt64() const {
        return (UINT64)m_data;
    }
    
    __forceinline void SetData(void *in) {
        if (!in) {
            m_data=0;
        } else {
            m_data = *(INT64 *)in;
        }
    }

    // When possible, please use the most specific SetDataAsXxx function.
    // This is necessary to guarantee we do sign extension correctly
    // for all types smaller than 32 bits.  R4's, R8's, U8's, DateTimes,
    // Currencies, and TimeSpans can all be treated as ints of the appropriate 
    // size - sign extension is irrelevant in those cases.
    __forceinline void SetDataAsInt8(INT8 data) {
        m_data=data;
    }

    __forceinline void SetDataAsUInt8(UINT8 data) {
        m_data=data;
    }

    __forceinline void SetDataAsInt16(INT16 data) {
        m_data=data;
    }

    __forceinline void SetDataAsUInt16(UINT16 data) {
        m_data=data;
    }

    __forceinline void SetDataAsInt32(INT32 data) {
        m_data=data;
    }
    
    __forceinline void SetDataAsUInt32(UINT32 data) {
        m_data=data;
    }

    __forceinline void SetDataAsInt64(INT64 data) {
        m_data=data;
    }

    BOOL IsBoxed()
    {
        return ((m_type >   CV_R8) &&
                (m_type !=  CV_DATETIME) &&
                (m_type !=  CV_TIMESPAN) &&
                (m_type !=  CV_CURRENCY));
    }
};


#define GCPROTECT_BEGIN_VARIANTDATA(/*VARIANTDATA*/vd) do {            \
                GCFrame __gcframe(vd.GetObjRefPtr(),  \
                1,                                             \
                FALSE);                                         \
                DEBUG_ASSURE_NO_RETURN_IN_THIS_BLOCK


#define GCPROTECT_END_VARIANTDATA()                     __gcframe.Pop(); } while(0)




#pragma pack(pop)

//ConversionMethod is used to keep track of the name of the conversion
//method and the class on which it is found.
typedef struct {
    LPCUTF8 pwzConvMethodName;
    CVTypes ConvClass;
} ConversionMethod;

// These are the offsets into the array that defines the mask and attributes
//  of the built in primitives
#define VA_ATTR 1
#define VA_MASK 0

class OleVariant;
class COMVariant {
    friend OleVariant;
private:
    //
    // Private Helper Routines
    //
    static INT32 GetI4FromVariant(VariantData* v);
    static R8 GetR8FromVariant(VariantData* v);
    static R4 GetR4FromVariant(VariantData* v);
    static STRINGREF GetStringFromVariant(VariantData* v);

    // This is the private version of new Variant.  It is called by all the others.
    static void NewVariant(VariantData* dest, const CVTypes type, OBJECTREF *or, void *pvData);
    static STRINGREF CallObjToString(VariantData *);
    static HRESULT __stdcall LoadVariant();

    // This represents the change type method...
    static MethodDesc* pChangeTypeMD;
    static MethodDesc* pOAChangeTypeMD;
    static void GetChangeTypeMethod();
    static void GetOAChangeTypeMethod();

        static void BuildVariantFromTypedByRef(EEClass* pType,void* data,VariantData* var);

public:
    //
    // Static Variables
    //
    static EEClass* s_pVariantClass;
    static ArrayTypeDesc* s_pVariantArrayTypeDesc;

    //
    // Helper Routines
    //

    // Use this very carefully.  There is not a direct mapping between
    //  CorElementType and CVTypes for a bunch of things.  In this case
    //  we return CV_LAST.  You need to check this at the call site.
    static CVTypes CorElementTypeToCVTypes(CorElementType type);


    //
    // Initialization Methods
    // s_pVariantClass will be initialized to zero.  When the first
    //  variant is defined we will fill in this method table.
    static void EnsureVariantInitialized()
    {
        if (!s_pVariantClass)
            LoadVariant();
    }


#ifdef FCALLAVAILABLE
    static FCDECL2(void, SetFieldsR4, VariantData* vThisRef, R4 val);
    static FCDECL2(void, SetFieldsR8, VariantData* vThisRef, R8 val);
    static FCDECL2(void, SetFieldsObject, VariantData* vThisRef, Object* vVal);
    static FCDECL1(R4, GetR4FromVar, VariantData* var);
    static FCDECL1(R8, GetR8FromVar, VariantData* var);
#else
    //
    // SetFields
    //

#pragma pack(push)
#pragma pack(1)

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
        DECLARE_ECALL_R4_ARG(R4, val);
    } _setFieldsR4Args;
    static void __stdcall SetFieldsR4(_setFieldsR4Args *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
        DECLARE_ECALL_R8_ARG(R8, val);
    } _setFieldsR8Args;
    static void __stdcall SetFieldsR8(_setFieldsR8Args *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, val);
    } _setFieldsObjectArgs;
    static void __stdcall SetFieldsObject(_setFieldsObjectArgs *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
    } _getR4FromVarArgs;
    static R4 __stdcall GetR4FromVar(_getR4FromVarArgs *);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
    } _getR8FromVarArgs;
    static R8 __stdcall GetR8FromVar(_getR8FromVarArgs *);

 #pragma pack(pop)

#endif

#pragma pack(push)
#pragma pack(1)

    struct _RefAnyToVariantArgs {
        DECLARE_ECALL_I4_ARG(LPVOID, ptr); 
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
    };
    static void __stdcall RefAnyToVariant(_RefAnyToVariantArgs* args);

    struct _VariantToRefAnyArgs {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData, var);
        DECLARE_ECALL_I4_ARG(LPVOID, ptr); 
    };
    static void __stdcall VariantToRefAny(_VariantToRefAnyArgs* args);
        
    struct _VariantToTypedRefAnyExArgs {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData, var);
        DECLARE_ECALL_PTR_ARG(TypedByRef, typedByRef); 
    };
    static void __stdcall VariantToTypedRefAnyEx(_VariantToTypedRefAnyExArgs* args);

    struct _VariantToTypedReferenceExArgs {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData, var);
        DECLARE_ECALL_PTR_ARG(TypedByRef, typedReference); 
    };
    static void __stdcall VariantToTypedReferenceAnyEx(_VariantToTypedReferenceExArgs* args);

    struct _TypedByRefToVariantExArgs
    {
        DECLARE_ECALL_PTR_ARG(TypedByRef, value); 
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
    };
    static void __stdcall TypedByRefToVariantEx(_TypedByRefToVariantExArgs* args);
        
    static FCDECL1(INT32, GetCVTypeFromClassWrapper, ReflectClassBaseObject* refType);

    static void __stdcall InitVariant(LPVOID);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, var);
    } _BoxEnumArgs;
    static LPVOID __stdcall BoxEnum(_BoxEnumArgs *);

 #pragma pack(pop)
   
    //
    // Unary Operators
    //

    //
    // Binary Operators
    //

    //
    // Comparison Operators
    //

    //
    // Helper Methods
    //
    static void NewVariant(VariantData* dest, const CVTypes type);
    static void NewVariant(VariantData* dest,R4 val);
    static void NewVariant(VariantData* dest,R8 val);
    static void NewVariant(VariantData* dest,INT64 val, const CVTypes type);
    static void NewVariant(VariantData* dest,OBJECTREF *oRef);
    static void NewVariant(VariantData* dest,OBJECTREF *oRef, const CVTypes type);
    static void NewVariant(VariantData* dest,STRINGREF *sRef);
    static void NewVariant(VariantData** pDest,PVOID val, const CorElementType, EEClass*);
    static void NewEnumVariant(VariantData* &dest,INT64 val, TypeHandle);
    static void NewPtrVariant(VariantData* &dest,INT64 val, TypeHandle);

    static EEClass *VariantGetClass(const CVTypes cvType);
    static OBJECTREF GetBoxedObject(VariantData*);

    // GetCVTypeFromClass
    // This method will return the CVTypes from the Variant instance
    static CVTypes GetCVTypeFromClass(EEClass *);
    static CVTypes GetCVTypeFromTypeHandle(TypeHandle th);
    static int GetEnumFlags(EEClass*);
    // The Attributes Table
    static DWORD VariantAttributes[CV_LAST][2];
    static DWORD Attr_Mask;
    static DWORD Widen_Mask;
    
    inline static DWORD IsPrimitiveVariant(const CVTypes type)
    {
        return (CVA_Primitive & (VariantAttributes[type][VA_ATTR] & Attr_Mask));
    }

    
    inline static DWORD CanPrimitiveWiden(const CorElementType destType, const CVTypes srcType)
    {
        _ASSERTE(srcType < CV_LAST);
        _ASSERTE((CVTypes)destType < CV_LAST);
        return (VariantAttributes[destType][VA_MASK] &
                (VariantAttributes[srcType][VA_ATTR] & Widen_Mask));
    }

};




/*===============================GetI4FromVariant===============================
**Action: Gets an I4 from the data portion of the variant.  Does no checking to
**        ensure that this actually was a Variant of type CV_I4.
**Returns: An INT32 containing the integer representation of the first 4 bytes
**         of the data section
**Arguments: v -- the Variant from which to read the data
**Exceptions: None
==============================================================================*/
inline INT32 COMVariant::GetI4FromVariant(VariantData* v){
  void *voidTemp;
  voidTemp = v->GetData();
  return *((INT32 *)voidTemp);
}


/*===============================GetR4FromVariant===============================
**Action: Gets an R4 from the data portion of the variant.  Does no checking to
**        ensure that this actually was a Variant of type CV_R4.
**Returns: An R4 containing the float representation of the data section.
**Arguments: v -- the Variant from which to read the data
**Exceptions: None
==============================================================================*/
inline R4 COMVariant::GetR4FromVariant(VariantData* v) {

  void *voidTemp;
  voidTemp = v->GetData();
  return (*((R4 *)voidTemp));
}


/*===============================GetR8FromVariant===============================
**Action: Gets an R8 from the data portion of the variant.  Does no checking to
**        ensure that this actually was a Variant of type CV_R8.
**Returns: An R8 containing the float representation of the data section.
**Arguments: v -- the Variant from which to read the data
**Exceptions: None
==============================================================================*/
inline R8 COMVariant::GetR8FromVariant(VariantData* v) {

  void *voidTemp;
  voidTemp = v->GetData();
  return (*((R8 *)voidTemp));
}

/*=============================GetStringFromVariant=============================
**Action: Gets the Objectref portion of the variant.  Does no checking to ensure
**        that this is actually a CV_STRING
**Returns: The STRINGREF contained within the Variant.
**Arguments: v -- the Variant from which to read the data.
**Exceptions: None.
==============================================================================*/
inline STRINGREF COMVariant::GetStringFromVariant(VariantData* v) {
    return (STRINGREF)v->GetObjRef();
}

/*==================================NewVariant==================================
**
==============================================================================*/
inline void COMVariant::NewVariant(VariantData* dest, const CVTypes type) {
    _ASSERTE(type==CV_EMPTY || type==CV_MISSING || type==CV_NULL);
    NewVariant(dest, type, NULL, NULL);
}

/*==================================NewVariant==================================
**
==============================================================================*/
inline void COMVariant::NewVariant(VariantData* dest,INT64 val, const CVTypes type) {
    NewVariant(dest, type, NULL, &val);
}


/*==================================NewVariant==================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
inline void COMVariant::NewVariant(VariantData* dest, STRINGREF *sRef) {
    NewVariant(dest, CV_STRING, (OBJECTREF *)sRef, NULL);
}

/*==================================NewVariant==================================
**
==============================================================================*/
inline void COMVariant::NewVariant(VariantData* dest,OBJECTREF *oRef) {
    if ((*oRef) != NULL) {
        if ((*oRef)->GetClass() == GetTypeHandleForCVType(CV_STRING).GetClass()) {
            NewVariant(dest, CV_STRING, oRef, NULL);
            return;
        } 
        if ((*oRef)->GetClass() == GetTypeHandleForCVType(CV_DECIMAL).GetClass()) {
            NewVariant(dest, CV_DECIMAL, oRef, NULL);
            return;
        } 
    }
    NewVariant(dest, CV_OBJECT, oRef, NULL);
}


/*==================================NewVariant==================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
inline void COMVariant::NewVariant(VariantData* dest,OBJECTREF *oRef, const CVTypes type) { 
    NewVariant(dest, type, oRef, NULL);
}

/*==================================NewVariant==================================
**
==============================================================================*/
inline void COMVariant::NewVariant(VariantData* dest,R4 f) {
    INT64 tempData=0;
    tempData = *((INT32 *)((void *)(&f)));
    NewVariant(dest, CV_R4, NULL, &tempData);
}

/*==================================NewVariant==================================
**Action:  Helper funtion to create a new variant from the R8 passed in.
**Returns: A new variant populated with the value from the R8.
**Exceptions: None
==============================================================================*/
inline void COMVariant::NewVariant(VariantData* dest,R8 d) {
    INT64 tempData=0;
    tempData = *((INT64 *)((void *)(&d)));
    NewVariant(dest,CV_R8, NULL, &tempData);
}

/*==================================NewVariant==================================
**Action:  Helper funtion to create a new variant from an element type and a
           pointer to memory where the dat is.
**Returns: A new variant populated with the value in the val pointer
**Exceptions: OOM
**WARNING: can invoke a GC!!!
==============================================================================*/
inline void COMVariant::NewVariant(VariantData** pDest, PVOID val, const CorElementType eType, EEClass *pCls)
{
    switch (eType)
    {
    case ELEMENT_TYPE_BOOLEAN:
    case ELEMENT_TYPE_CHAR:
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
    case ELEMENT_TYPE_R4:
    case ELEMENT_TYPE_R8:
    {
        COMVariant::NewVariant(*pDest, COMVariant::CorElementTypeToCVTypes(eType), NULL, val);
        break;
    }
    case ELEMENT_TYPE_STRING:
    {
        COMVariant::NewVariant(*pDest, CV_STRING, (OBJECTREF *) val, NULL);
        break;
    }

    case ELEMENT_TYPE_SZARRAY:                      // Single Dim
    case ELEMENT_TYPE_ARRAY:                        // General Array
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_CLASS:                    // Class
    {
        COMVariant::NewVariant(*pDest, CV_OBJECT, (OBJECTREF *) val, NULL);
        break;
    }
    case ELEMENT_TYPE_VALUETYPE:
    {
        if (pCls == s_pVariantClass)
        {
            COMVariant::NewVariant(*pDest, CV_OBJECT, NULL, val);
            CopyValueClassUnchecked(*pDest, val, s_pVariantClass->GetMethodTable());
        }
        else
        {
            //
            // box the value class to put in the variant
            //
            _ASSERTE(CanBoxToObject(pCls->GetMethodTable()));

            _ASSERTE(!g_pGCHeap->IsHeapPointer((BYTE *) pDest) ||
                     !"(pDest) can not point to GC Heap");
            OBJECTREF pObj = FastAllocateObject(pCls->GetMethodTable());
            CopyValueClass(pObj->UnBox(), val, pObj->GetMethodTable(), pObj->GetAppDomain());

            COMVariant::NewVariant((*pDest), CV_OBJECT,  &pObj, NULL);
        }
        break;
    }
    case ELEMENT_TYPE_VOID:
    {
        (*pDest)->SetType(CV_NULL);
        break;
    }
    default:
        _ASSERTE(!"unsupported COR element type when trying to create Variant");
    }

}


#endif _COMVARIANT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comwaithandle.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** COMWaitHandle.cpp
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.WaitHandle
**
** Date:  August, 1999
**
===========================================================*/
#include "common.h"
#include "object.h"
#include "field.h"
#include "ReflectWrap.h"
#include "excep.h"
#include "COMWaitHandle.h"

BOOL __stdcall  WaitHandleNative::CorWaitOneNative(WaitOneArgs* pArgs)
{
    _ASSERTE(pArgs);
    _ASSERTE(pArgs->handle);

    Thread* pThread = SetupThread();
    _ASSERTE(pThread != NULL);
    _ASSERTE(pThread == GetThread());

	DWORD res;

	Context* targetContext = pThread->GetContext();
	_ASSERTE(targetContext);
	Context* defaultContext = pThread->GetDomain()->GetDefaultContext();
	_ASSERTE(defaultContext);
	if (pArgs->exitContext != NULL &&
		targetContext != defaultContext)
	{
		Context::WaitArgs waitOneArgs = {1, &pArgs->handle, TRUE, pArgs->timeout, TRUE, &res};
		Context::CallBackInfo callBackInfo = {Context::Wait_callback, (void*) &waitOneArgs};
		Context::RequestCallBack(defaultContext, &callBackInfo);
	}

	else
	{
		res = pThread->DoAppropriateWait(1,&pArgs->handle,TRUE,pArgs->timeout,TRUE /*alertable*/);
	}

    return ((res == WAIT_OBJECT_0) || (res == WAIT_ABANDONED));

}

int __stdcall  WaitHandleNative::CorWaitMultipleNative(WaitMultipleArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs);
    _ASSERTE(pArgs->waitObjects);

    Thread* pThread = SetupThread();
    _ASSERTE(pThread != NULL);
    _ASSERTE(pThread == GetThread());

    PTRARRAYREF pWaitObjects = (PTRARRAYREF)pArgs->waitObjects;  // array of objects on which to wait
    int numWaiters = pWaitObjects->GetNumComponents();

    if (pArgs->waitForAll && numWaiters > 1 && pThread->GetApartment() == Thread::AS_InSTA) {
        COMPlusThrow(kNotSupportedException, L"NotSupported_WaitAllSTAThread");
    }
    pWaitObjects = (PTRARRAYREF)pArgs->waitObjects;  // array of objects on which to wait

    HANDLE* internalHandles = (HANDLE*) _alloca(numWaiters*sizeof(HANDLE)); 

    for (int i=0;i<numWaiters;i++)
    {
        WAITHANDLEREF waitObject = (WAITHANDLEREF) (OBJECTREFToObject(pWaitObjects->m_Array[i]));
		if (waitObject == NULL)
			COMPlusThrow(kNullReferenceException);
		
		MethodTable *pMT = waitObject->GetMethodTable();
		if (pMT->IsTransparentProxyType())
			COMPlusThrow(kInvalidOperationException,L"InvalidOperation_WaitOnTransparentProxy");
        internalHandles[i] = waitObject->m_handle;
    }

    DWORD res;
	
	
	Context* targetContext = pThread->GetContext();
	_ASSERTE(targetContext);
	Context* defaultContext = pThread->GetDomain()->GetDefaultContext();
	_ASSERTE(defaultContext);
	if (pArgs->exitContext != NULL &&
		targetContext != defaultContext)
	{
		Context::WaitArgs waitMultipleArgs = {numWaiters, internalHandles, pArgs->waitForAll, pArgs->timeout, TRUE, &res};
		Context::CallBackInfo callBackInfo = {Context::Wait_callback, (void*) &waitMultipleArgs};
		Context::RequestCallBack(defaultContext, &callBackInfo);
	}
	else
	{
		res = pThread->DoAppropriateWait(numWaiters, internalHandles, pArgs->waitForAll, pArgs->timeout,TRUE /*alertable*/);
	}


    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comx509certificate.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//
//  File:
//  
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//---------------------------------------------------------------------------

#pragma once
#include <wincrypt.h>

class COMX509Certificate
{
    struct _SetX509CertificateArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, data);
    };

    struct _BuildFromContextArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(void*, handle);
    };

    struct _GetPublisherArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, filename);
    };
        
    static INT32 LoadCertificateContext(OBJECTREF* pSafeThis, PCCERT_CONTEXT pCert);

public:
    static INT32 __stdcall SetX509Certificate(_SetX509CertificateArgs *);
    static INT32 __stdcall BuildFromContext(_BuildFromContextArgs *);
    static void* GetPublisher( _GetPublisherArgs* );  
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\confighelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ConfigHelper.cpp
// 
//*****************************************************************************
//
// XML Helper so that NodeFactory can be implemented in Managed code  
//

#include "common.h"
#include "confighelper.h"


ConfigFactory::ConfigFactory(IConfigHandler *pFactory){
    m_pManagedFactory = pFactory;
    m_pManagedFactory->AddRef();    //AddRef the managed Factory interface
}

ConfigFactory::~ConfigFactory(){
    m_pManagedFactory->Release();   //Release the managed Factory interface
}


HRESULT STDMETHODCALLTYPE ConfigFactory::NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt)
{

    m_pManagedFactory->NotifyEvent(iEvt);
    return S_OK;
}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ConfigFactory::BeginChildren( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    m_pManagedFactory->BeginChildren(pNodeInfo->dwSize, 
                                     pNodeInfo->dwSubType, 
                                     pNodeInfo->dwType, 
                                     pNodeInfo->fTerminal, 
                                     pNodeInfo->pwcText, 
                                     pNodeInfo->ulLen, 
                                     pNodeInfo->ulNsPrefixLen);
    return S_OK;

}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ConfigFactory::EndChildren( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmptyNode,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    m_pManagedFactory->EndChildren(fEmptyNode, 
                                   pNodeInfo->dwSize, 
                                   pNodeInfo->dwSubType, 
                                   pNodeInfo->dwType, 
                                   pNodeInfo->fTerminal, 
                                   pNodeInfo->pwcText, 
                                   pNodeInfo->ulLen, 
                                   pNodeInfo->ulNsPrefixLen);

    return S_OK;
}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ConfigFactory::CreateNode( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
{
  
    XML_NODE_INFO* pNodeInfo = *apNodeInfo;
    DWORD i;
    WCHAR wstr[128]; 
    WCHAR *pString = wstr;
    DWORD dwString = sizeof(wstr)/sizeof(WCHAR);
    
    for( i = 0; i < cNumRecs; i++) { 
        if ( apNodeInfo[i]->ulLen >= dwString) {
            dwString = apNodeInfo[i]->ulLen+1;
            pString = (WCHAR*) alloca(sizeof(WCHAR) * dwString);
        }

        pString[apNodeInfo[i]->ulLen] = L'\0';
        wcsncpy(pString, apNodeInfo[i]->pwcText, apNodeInfo[i]->ulLen);

        if(i == 0) {
            m_pManagedFactory->CreateNode(apNodeInfo[i]->dwSize, 
                                          apNodeInfo[i]->dwSubType, 
                                          apNodeInfo[i]->dwType, 
                                          apNodeInfo[i]->fTerminal, 
                                          pString, 
                                          apNodeInfo[i]->ulLen, 
                                          apNodeInfo[i]->ulNsPrefixLen);
        }
        else {
            m_pManagedFactory->CreateAttribute(apNodeInfo[i]->dwSize, 
                                               apNodeInfo[i]->dwSubType, 
                                               apNodeInfo[i]->dwType, 
                                               apNodeInfo[i]->fTerminal, 
                                               pString, 
                                               apNodeInfo[i]->ulLen, 
                                               apNodeInfo[i]->ulNsPrefixLen);
        } // end of switch
    }
    return S_OK;
}

//
//Helper routines to call into managed Node Factory
//

HRESULT STDMETHODCALLTYPE ConfigHelper::Run(IConfigHandler *pFactory, LPCWSTR filename)
{
    HRESULT        hr = S_OK;  
    IXMLParser     *pIXMLParser = NULL;
    ConfigFactory  *helperfactory = NULL; 
    IStream *pFile = NULL ; 
    if (!pFactory){
        return E_POINTER;
    }

    hr = CreateConfigStream(filename, &pFile);
    if(FAILED(hr)) goto Exit;
    
    hr = GetXMLObject(&pIXMLParser);
    if(FAILED(hr)) goto Exit;

    helperfactory = new ConfigFactory(pFactory);
    if ( ! helperfactory) { 
            hr = E_OUTOFMEMORY; 
            goto Exit; 
        }
    helperfactory->AddRef(); // RefCount = 1 
    

    hr = pIXMLParser->SetInput(pFile); // filestream's RefCount=2
    if ( ! SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->SetFactory(helperfactory); // factory's RefCount=2
    if ( ! SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->Run(-1);
Exit:  
    if (hr==XML_E_MISSINGROOT)  //empty file
        hr=S_OK;

    if (pIXMLParser) { 
        pIXMLParser->Release();
        pIXMLParser= NULL ; 
    }
    if ( helperfactory) {
        helperfactory->Release();
        helperfactory=NULL;
    }
    if ( pFile) {
        pFile->Release();
        pFile=NULL;
    }
	if (hr==XML_E_MISSINGROOT)
		hr=S_OK;
    return hr;  
}

//
// Entrypoint to return an Helper interface which Managed code can call to build managed Node factory
//

LPVOID __stdcall ConfigNative::GetHelper(EmptyArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    // We are about to use COM functions, we need to start COM up.
    if (FAILED(QuickCOMStartup()))
        COMPlusThrowOM();

    ConfigHelper *pv = new ConfigHelper();
    if (pv) {
        MethodTable *pMT = g_Mscorlib.GetClass(CLASS__ICONFIG_HELPER);
        if(pMT) {
            //OBJECTREF ob = GetObjectRefFromComIP(pv, pMT);
            OBJECTREF ob = GetObjectRefFromComIP(pv, NULL);
            *((OBJECTREF*) &rv) = ob;
        }
        else 
            delete pv;
    }
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comx509certificate.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//
//  File:       COMX509Certificate.cpp
//  
//  Contents:   Native method implementations and helper code for
//              supporting CAPI based operations on X509 signatures
//              for use by the PublisherPermission in the CodeIdentity
//              permissions family.
//
//  Classes and   
//  Methods:    COMX509Certificate
//               |
//               +--SetX509Certificate
//
//  History:    06/10/1998  JerryK Created
//
//---------------------------------------------------------------------------

#include "common.h"
#include "object.h"
#include "excep.h"
#include "utilcode.h"
#include "field.h"
#include "COMString.h"
#include "COMX509Certificate.h"
#include "gcscan.h"
#include "CorPermE.h"
#include "CorPolicy.h"
#include "CorPerm.h"

#if _DEBUG
#define VIEW_COPIED_CERT_PROPS  0
void VMDebugCompByteArray(char*, char*, unsigned int);
#endif


#define _RAID_15982
#define TICKSTO1601 504910944000000000

void* COMX509Certificate::GetPublisher( _GetPublisherArgs* args )
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);

    PCOR_TRUST pCor = NULL;
    DWORD dwCor = 0;
    U1ARRAYREF cert = NULL;
    EE_TRY_FOR_FINALLY {
        HRESULT hr = ::GetPublisher(args->filename->GetBuffer(),
                                  NULL,
                                  COR_NOUI,
                                  &pCor,
                                  &dwCor);
        if(FAILED(hr) && hr != TRUST_E_SUBJECT_NOT_TRUSTED) COMPlusThrowHR(hr);
            
        if (pCor != NULL && pCor->pbSigner != NULL)
        {
            cert = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, pCor->cbSigner);
                
            memcpyNoGCRefs( cert->GetDirectPointerToNonObjectElements(), pCor->pbSigner, pCor->cbSigner );
        }
    }
    EE_FINALLY {
        if(pCor) FreeM(pCor);
    } EE_END_FINALLY;

    RETURN( cert, U1ARRAYREF );
}


//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     BuildFromContext( . . . . )
//  
//  Synopsis:   Native method for initializing the member fields of a
//              managed X509Certificate class from a cert context
//
//  Arguments:  [args] --  A _SetX509CertificateArgs structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        An integer representing the handle
//
//  Returns:    HRESULT code.
//
//  History:    09/30/1998  
// 
//---------------------------------------------------------------------------
INT32 __stdcall
COMX509Certificate::BuildFromContext(_BuildFromContextArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

#ifdef PLATFORM_CE
    return S_FALSE;
#else // !PLATFORM_CE

    PCCERT_CONTEXT     pCert = (PCCERT_CONTEXT) args->handle;
    return LoadCertificateContext(&(args->refThis), pCert);
#endif // !PLATFORM_CE
}


//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     SetX509Certificate( . . . . )
//  
//  Synopsis:   Native method for initializing the member fields of a
//              managed X509Certificate class.
//
//  Effects:    Decodes a byte array containing a certificate and
//              dissects out the appropriate fields to make them 
//              available to managed code.
// 
//  Arguments:  [args] --  A _SetX509CertificateArgs structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A byte array containing the certificate.
//
//  Returns:    HRESULT code.
//
//  History:    06/12/1998  JerryK  Created
// 
//---------------------------------------------------------------------------
INT32 __stdcall
COMX509Certificate::SetX509Certificate(_SetX509CertificateArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

#ifdef PLATFORM_CE
    return S_FALSE;
#else // !PLATFORM_CE
    HRESULT            result = S_OK;
    PCCERT_CONTEXT     pCert = NULL;
    DWORD              dwEncodingType = CRYPT_ASN_ENCODING|PKCS_7_ASN_ENCODING;

    // Figure out how many bytes are in the inbound array
    int length = args->data->GetNumComponents();

    // Create certificate context
    pCert = 
        CertCreateCertificateContext(
                             dwEncodingType,
                             (unsigned const char*)args->data->
                                         GetDirectPointerToNonObjectElements(),
                             length
                                    );
    if (pCert) {
        EE_TRY_FOR_FINALLY {
            result = LoadCertificateContext(&(args->refThis), pCert);
        }
        EE_FINALLY {
            CertFreeCertificateContext(pCert);
            pCert = NULL;
            if (GOT_EXCEPTION())
                _ASSERTE(!"Caught an exception while loading certificate context");
        } EE_END_FINALLY;
    }
    else {
        COMPlusThrow(kCryptographicException,L"Cryptography_X509_BadEncoding");
    }
    return result;
#endif // !PLATFORM_CE
}


INT32
COMX509Certificate::LoadCertificateContext(OBJECTREF* pSafeThis, PCCERT_CONTEXT pCert)
{
    THROWSCOMPLUSEXCEPTION();

#ifndef PLATFORM_CE

    LPWSTR             pName = NULL;
    DWORD              dwEncodingType = CRYPT_ASN_ENCODING|PKCS_7_ASN_ENCODING;
    FieldDesc*         pFD = NULL;

#if 0
    VMDebugOutputA("\tTried to create CertContext:  0x%p\n",pCert);
#endif

    if( !pCert || pCert->pCertInfo == NULL)
    {
        COMPlusThrowWin32();
    }

    // ************* Process Subject Field of Certificate *************
    // Get buffer size required for subject field
    DWORD dwSize = CertNameToStrW(dwEncodingType,            // Encoding Type
                                  &pCert->pCertInfo->Subject,// Name To Convert
                                  CERT_X500_NAME_STR,        // Desired type
                                  NULL,                      // Addr for return
                                  0);                        // Size of retbuf
    if(dwSize)
    {
        // Allocate space for the new name
        pName = new (throws) WCHAR[dwSize];

        // Convert certificate subject/name blob to null terminated string
        CertNameToStrW(dwEncodingType,
                       &pCert->pCertInfo->Subject,
                       CERT_X500_NAME_STR,
                       pName,
                       dwSize);

        if( dwSize )
        {
#if 0
            VMDebugOutputW(L"\tSubject:\t\t%ws\n", pName);
#endif

            // Get descriptor for the object field we're setting
            pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__NAME);

            // Make a runtime String object to hold the name
            STRINGREF StrName = COMString::NewString(pName);

            // Set the field
            pFD->SetRefValue((*pSafeThis), (OBJECTREF)StrName);
        }

        // Clean up
        delete [] pName;
        pName = NULL;
    }

    // ************* Process Issuer Field of Certificate *************
    // Get required buffer size for issuer field
    dwSize = CertNameToStrW(dwEncodingType,
                            &pCert->pCertInfo->Issuer,
                            CERT_X500_NAME_STR,
                            NULL,
                            0);
    if(dwSize)
    {
        pName = new (throws) WCHAR[dwSize];

        // Convert blob to get issuer
        CertNameToStrW(dwEncodingType,
                       &pCert->pCertInfo->Issuer,
                       CERT_X500_NAME_STR,
                       pName,
                       dwSize);

        if( dwSize )
        {
#if 0          
            VMDebugOutputW(L"\tIssuer:\t\t%ws\n", pName);
#endif
            // Get field descriptor
            pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__CA_NAME);

            // Create a String to hold the name
            STRINGREF IssuerName = COMString::NewString(pName);

            // Set field
            pFD->SetRefValue((*pSafeThis), (OBJECTREF)IssuerName);
        }

        // Clean up
        delete [] pName;
        pName = NULL;
    }

    // ************* Process Serial Number Field of Certificate *************

    pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__SERIAL_NUMBER);

    // Allocate a byte (I1) array for the serial number
    U1ARRAYREF pbSerialNumber = 
        (U1ARRAYREF)AllocatePrimitiveArray(
                                        ELEMENT_TYPE_U1,
                                        pCert->pCertInfo->SerialNumber.cbData);

    // Copy the serial number data into position
    memcpyNoGCRefs(pbSerialNumber->m_Array, 
           pCert->pCertInfo->SerialNumber.pbData,
           pCert->pCertInfo->SerialNumber.cbData);

#if 0
#if VIEW_COPIED_CERT_PROPS
    VMDebugOutputA("Serial Number:\n");
    VMDebugCompByteArray((char*)pbSerialNumber->m_Array,
                         (char*)pCert->pCertInfo->SerialNumber.pbData,
                         pCert->pCertInfo->SerialNumber.cbData);
#endif
#endif

    // Set the field in the object to point to this new array
    pFD->SetRefValue((*pSafeThis), (OBJECTREF)pbSerialNumber);

//      // ************* Process Dates *************
    // Number of ticks from 01/01/0001 CE (DateTime class convention) to 01/01/1601 CE (FILETIME struct convention)
    const __int64 lTicksTo1601 = TICKSTO1601;  

    pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__EFFECTIVE_DATE);
    
    pFD->SetValue64((*pSafeThis),
                     *((__int64*) &(pCert->pCertInfo->NotBefore)) + lTicksTo1601);
      
    pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__EXPIRATION_DATE);
    pFD->SetValue64((*pSafeThis),
                     *((__int64*) &(pCert->pCertInfo->NotAfter)) + lTicksTo1601); 
    

    // ************* Process Key Algorithm Field of Certificate *************
    char *pszKeyAlgo = 
                     pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    // Make a Unicode copy of the algorithm
    LPWSTR pwszKeyAlgo = NULL;
    int cchBufSize = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         pszKeyAlgo,
                                         -1,
                                         pwszKeyAlgo,
                                         0);
    pwszKeyAlgo = new (throws) WCHAR[cchBufSize];
    if( !MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pszKeyAlgo,
                             -1,
                             pwszKeyAlgo,
                             cchBufSize) )
    {
        delete [] pwszKeyAlgo;
        _ASSERTE(!"MBCS to Wide Conversion Failure!");
        COMPlusThrowWin32();
    }

    pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__KEY_ALGORITHM);

    // Make a runtime string to hold this
    STRINGREF StrKeyAlgo = COMString::NewString(pwszKeyAlgo);
    delete [] pwszKeyAlgo;

    // Set the field in the object to hold that string
    pFD->SetRefValue((*pSafeThis), (OBJECTREF)StrKeyAlgo);


    // ************* Process Key Parameters Field of Certificate *************
    if(pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData)
    {
        pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__KEY_ALGORITHM_PARAMS);

        U1ARRAYREF pbAlgoParams =
            (U1ARRAYREF)AllocatePrimitiveArray(
                                        ELEMENT_TYPE_U1,
                                        pCert->pCertInfo->
                                                SubjectPublicKeyInfo.Algorithm.
                                                             Parameters.cbData
                                                );

        memcpyNoGCRefs(
            pbAlgoParams->m_Array,
            pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData
              );

#if 0
#if VIEW_COPIED_CERT_PROPS
        VMDebugOutputA("Key Algorithm:\n");
        VMDebugCompByteArray((char*)pbAlgoParams->m_Array,
                             (char*)pCert->pCertInfo->SubjectPublicKeyInfo.
                                                  Algorithm.Parameters.pbData,
                             pCert->pCertInfo->SubjectPublicKeyInfo.
                                                  Algorithm.Parameters.cbData);
#endif
#endif
        // Set the field in the object to point to this array.
        pFD->SetRefValue((*pSafeThis), (OBJECTREF)pbAlgoParams);
    }

    // ************* Process Key Blob Field of Certificate *************

    pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__PUBLIC_KEY);

    U1ARRAYREF pbKeyBlob = 
        (U1ARRAYREF)
           AllocatePrimitiveArray(
                       ELEMENT_TYPE_U1,
                       pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
                                   );
    memcpyNoGCRefs(pbKeyBlob->m_Array,
           pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
           pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

#if 0
#if VIEW_COPIED_CERT_PROPS
    VMDebugOutputA("Key Blob:\n");
    VMDebugCompByteArray((char*)pbKeyBlob->m_Array,

                         (char*)pCert->pCertInfo->SubjectPublicKeyInfo.
                                                             PublicKey.pbData,
                         pCert->pCertInfo->SubjectPublicKeyInfo.
                                                             PublicKey.cbData);
#endif
#endif
    // Set the field in the object to point to this array.
    pFD->SetRefValue((*pSafeThis), (OBJECTREF)pbKeyBlob);


    // ************* Process Raw Cert Field of Certificate *************
    pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__DATA);

    U1ARRAYREF pbRawCert = 
        (U1ARRAYREF)
          AllocatePrimitiveArray(ELEMENT_TYPE_U1,
                        pCert->cbCertEncoded);

    memcpyNoGCRefs(pbRawCert->m_Array,
           pCert->pbCertEncoded,
           pCert->cbCertEncoded);
#if 0
#if VIEW_COPIED_CERT_PROPS
    VMDebugOutputA("Raw Cert:\n");
    VMDebugCompByteArray((char*)pbRawCert->m_Array,
                         (char*)args->data->GetDirectPointerToNonObjectElements(),
                         args->data->GetNumComponents());
#endif
#endif
    
    // Set the field in the object to point to this new array
    pFD->SetRefValue((*pSafeThis), (OBJECTREF)pbRawCert);
    

#ifdef _RAID_15982

    // CertGetCertificateContextProperty will load RSABASE.DLL, which will fail 
    // on German version of NT 4.0 SP 4.
    // This failure is caused by a dll address conflict between NTMARTA.DLL and
    // OLE32.DLL.
    // This failure is handled gracefully if we load ntmarta.dll and ole32.dll
    // ourself. The failure will cause a dialog box to popup if SOFTPUB.dll 
    // loads ole32.dll for the first time.

    // This work around needs to be removed once this issiue is resolved by
    // NT or OLE32.dll.

    WszLoadLibrary(L"OLE32.DLL");

#endif

    // ************* Process Hash of Cert Field of Certificate *************

    pFD = g_Mscorlib.GetField(FIELD__X509_CERTIFICATE__CERT_HASH);

    // Get the size of the byte buffer we need to hold the hash
    DWORD size = 0;
    if(!CertGetCertificateContextProperty(pCert,
                                          CERT_SHA1_HASH_PROP_ID,
                                          NULL,
                                          &size))
    {
        COMPlusThrowWin32();
    }
    // Allocate the buffer
    U1ARRAYREF pbCertHash = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, size);

    if(!CertGetCertificateContextProperty(pCert,
                                          CERT_HASH_PROP_ID,
                                          pbCertHash->m_Array,
                                          &size))
    {
        COMPlusThrowWin32();
    }
#if 0
#if VIEW_COPIED_CERT_PROPS
    VMDebugOutputA("Cert Hash (trivially equal):\n");
    VMDebugCompByteArray((char*)pbCertHash->m_Array,
                         (char*)pbCertHash->m_Array,
                         size);
#endif
#endif
    // Set the field in the object to point to this new array
    pFD->SetRefValue((*pSafeThis), (OBJECTREF)pbCertHash);


#if 0
    // DBG:  Tell the debugger we are leaving the function...
    VMDebugOutputA("***VMDBG:***  Leaving SetX509Certificate().  "
                   "HRESULT = %x\n",
                   S_OK);
#endif

#endif // !PLATFORM_CE

    return S_OK;
}



#if _DEBUG
static void
VMDebugCompByteArray(char* pbTarget, 
                     char* pbSource, 
                     unsigned int count)
{
    unsigned int i;

    VMDebugOutputA("\tTARGET:\n");
    VMDebugOutputA("\t\t");

    for( i=0; i<count; i++ )
    {
        VMDebugOutputA("%c ", (char*)pbTarget[i]);
    }
    VMDebugOutputA("\n");


    VMDebugOutputA("\tSOURCE:\n");
    VMDebugOutputA("\t\t");

    for( i=0; i< count; i++ )
    {
        VMDebugOutputA("%c ", (char*)pbSource[i]);
    }
    VMDebugOutputA("\n");
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\confighelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ConfigHelper.h
// 
//*****************************************************************************
//
// These are unmanaged definitions of interfaces used call Managed Node Factories
// If you make any changes please do corresponding changes in \src\bcl\system\__xmlparser.cs
//
#ifndef _CONFIGHELPER_H
#define _CONFIGHELPER_H

#include <mscoree.h>
#include <xmlparser.h>
#include <mscorcfg.h>
#include "unknwn.h"
#include "_reference.h"
#include "_unknown.h"


extern const GUID __declspec(selectany) IID_IConfigHandler = { /* afd0d21f-72f8-4819-99ad-3f255ee5006b */
    0xafd0d21f,
    0x72f8,
    0x4819,
    {0x99, 0xad, 0x3f, 0x25, 0x5e, 0xe5, 0x00, 0x6b}
  };

MIDL_INTERFACE("afd0d21f-72f8-4819-99ad-3f255ee5006b")
IConfigHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent(
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;

        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSubType,
            /* [in] */ DWORD dwType,
            /* [in] */ BOOL fTerminal,
            /* [in] */ LPCWSTR pwcText,
            /* [in] */ DWORD ulLen,
            /* [in] */ DWORD ulNsPrefixLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ BOOL  fEmpty,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSubType,
            /* [in] */ DWORD dwType,
            /* [in] */ BOOL fTerminal,
            /* [in] */ LPCWSTR pwcText,
            /* [in] */ DWORD ulLen,
            /* [in] */ DWORD ulNsPrefixLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSubType,
            /* [in] */ DWORD dwType,
            /* [in] */ BOOL fTerminal,
            /* [in] */ LPCWSTR pwcText,
            /* [in] */ DWORD ulLen,
            /* [in] */ DWORD ulNsPrefixLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSubType,
            /* [in] */ DWORD dwType,
            /* [in] */ BOOL fTerminal,
            /* [in] */ LPCWSTR pwcText,
            /* [in] */ DWORD ulLen,
            /* [in] */ DWORD ulNsPrefixLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateAttribute( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSubType,
            /* [in] */ DWORD dwType,
            /* [in] */ BOOL fTerminal,
            /* [in] */ LPCWSTR pwcText,
            /* [in] */ DWORD ulLen,
            /* [in] */ DWORD ulNsPrefixLen) = 0;

};

extern const GUID __declspec(selectany) IID_IConfigHelper = { /* bbd21636-8546-45b3-9664-1ec479893a6f */
    0xbbd21636,
    0x8546,
    0x45b3,
    {0x96, 0x64, 0x1e, 0xc4, 0x79, 0x89, 0x3a, 0x6f}
};

MIDL_INTERFACE("bbd21636-8546-45b3-9664-1ec479893a6f")
IConfigHelper : public IUnknown
{
public:
        virtual HRESULT STDMETHODCALLTYPE Run(
            /* [in] */ IConfigHandler *pFactory,
            /* [in] */ LPCWSTR filename) = 0;
};

class ConfigFactory : public _unknown<IXMLNodeFactory, &IID_IXMLNodeFactory>
{

public:
    ConfigFactory(IConfigHandler *pFactory);
    ~ConfigFactory();

    HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);

    HRESULT STDMETHODCALLTYPE BeginChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE EndChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ BOOL fEmptyNode,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE Error( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ HRESULT hrErrorCode,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
    {
        return hrErrorCode;
    }
    
    HRESULT STDMETHODCALLTYPE CreateNode( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ PVOID pNodeParent,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

public:
    IConfigHandler *m_pManagedFactory;
};


//---------------------------------------------------------------------------
class ConfigHelper : public _unknown<IConfigHelper, &IID_IConfigHelper>
{
public:
    HRESULT STDMETHODCALLTYPE Run(IConfigHandler *factory, LPCWSTR filename);
};

class ConfigNative
{
    struct EmptyArgs
    {
    };

public:
    static LPVOID __stdcall GetHelper(EmptyArgs *args);
};

#endif //  _CONFIGHELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comwaithandle.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMWaitHandle.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.WaitHandle
**
** Date:  August, 1999
** 
===========================================================*/

#ifndef _COM_WAITABLE_HANDLE_H
#define _COM_WAITABLE_HANDLE_H


class WaitHandleNative
{
    // The following should match the definition in the classlib (managed) file
private:

    struct WaitOneArgs
    {
        DECLARE_ECALL_I4_ARG(INT32 /*bool*/, exitContext);
        DECLARE_ECALL_I4_ARG(INT32, timeout);
        DECLARE_ECALL_I4_ARG(LPVOID, handle);
    };

	struct WaitMultipleArgs
	{
        DECLARE_ECALL_I4_ARG(INT32, waitForAll);
        DECLARE_ECALL_I4_ARG(INT32, exitContext);
        DECLARE_ECALL_I4_ARG(INT32, timeout);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, waitObjects);

	};


public:

    static BOOL __stdcall CorWaitOneNative(WaitOneArgs*);
	static INT32 __stdcall  CorWaitMultipleNative(WaitMultipleArgs *pArgs);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\context.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _H_CONTEXT_
#define _H_CONTEXT_

#include <member-offset-info.h>

class ComPlusWrapperCache;
class Context
{

friend class Thread;
friend class ThreadNative;
friend class ContextBaseObject;
friend class CRemotingServices;
friend struct PendingSync;
friend HRESULT InitializeMiniDumpBlock();
friend struct MEMBER_OFFSET_INFO(Context);

public:
    Context(AppDomain *pDomain);
    ~Context();    
    static BOOL Initialize();
#ifdef SHOULD_WE_CLEANUP
    static void Cleanup();
#endif /* SHOULD_WE_CLEANUP */

    // Get and Set the exposed System.Runtime.Remoting.Context
    // object which corresponds to this context.
    OBJECTREF   GetExposedObject();
    OBJECTREF   GetExposedObjectRaw();
    void        SetExposedObject(OBJECTREF exposed);
    // Query whether the exposed object exists
    BOOL IsExposedObjectSet()
    {
        return (ObjectFromHandle(m_ExposedObjectHandle) != NULL) ;
    }



    AppDomain* GetDomain()
    {
        return m_pDomain;
    }

    // Access the appropriate ComPlusWrapperCache for this context to use
    ComPlusWrapperCache              *GetComPlusWrapperCache();
    
    static LPVOID GetStaticFieldAddress(FieldDesc *pFD);
    static LPVOID GetStaticFieldAddrForDebugger(Thread *pTH, FieldDesc *pFD);

	// Functions to circumvent the memory-leak detecting allocator, since these
	// contexts could appear to leak on shutdown, but in reality they are not.

    void* operator new(size_t size, void* spot) {   return (spot); }

    static Context* CreateNewContext(AppDomain *pDomain);

	static void FreeContext(Context* victim)
	{
		victim->~Context();
		HeapFree(GetProcessHeap(), 0, victim);
	}

public:

    enum CallbackType {
        Wait_callback = 0,
        MonitorWait_callback = 1,
        ADTransition_callback = 2,
        
    } ;

    typedef struct {
        int     numWaiters;
        HANDLE* waitHandles;
        BOOL    waitAll;
        DWORD   millis;
        BOOL    alertable;
        DWORD*  pResult;    
    } WaitArgs;

    typedef struct {
        INT32       millis;          
        PendingSync *syncState;     
        BOOL*       pResult;
    } MonitorWaitArgs;

    typedef void (*ADCallBackFcnType)(LPVOID);
    struct ADCallBackArgs {
        ADCallBackFcnType pTarget;
        LPVOID pArguments;
    };

    typedef struct {
        enum CallbackType   callbackId;
        void*               callbackData;
    } CallBackInfo;

    static Context* SetupDefaultContext(AppDomain *pDomain);
    static void CleanupDefaultContext(AppDomain *pDomain);
    static void RequestCallBack(Context* targetCtxID, void* privateData);    

    // HACK:mprabhu: temporarily made public to get around the context GC issue 
    static BOOL ValidateContext(Context *pCtx);  

    inline STATIC_DATA *GetSharedStaticData() { return m_pSharedStaticData; }
    inline void SetSharedStaticData(STATIC_DATA *pData) { m_pSharedStaticData = pData; }

    inline STATIC_DATA *GetUnsharedStaticData() { return m_pUnsharedStaticData; }
    inline void SetUnsharedStaticData(STATIC_DATA *pData) { m_pUnsharedStaticData = pData; }

private:

    void SetDomain(AppDomain *pDomain)
    {
        m_pDomain = pDomain;
    }

    // Static helper functions:
    static BOOL InitializeFields();
    static BOOL InitContexts();
    static void EnterLock();
    static void LeaveLock();

    inline static MethodDesc *MDofDoCallBackFromEE() { return s_pDoCallBackFromEE; }
    static BOOL AllocateStaticFieldObjRefPtrs(FieldDesc *pFD, MethodTable *pMT, LPVOID pvAddress);
    inline static MethodDesc *MDofReserveSlot() { return s_pReserveSlot; }
    inline static MethodDesc *MDofManagedThreadCurrentContext() { return s_pThread_CurrentContext; }

    static void ExecuteWaitCallback(WaitArgs* waitArgs);
    static void ExecuteMonitorWaitCallback(MonitorWaitArgs* waitArgs);
    static BOOL GetStaticFieldAddressSpecial(FieldDesc *pFD, MethodTable *pMT, int *pSlot, LPVOID *ppvAddress);
    static LPVOID CalculateAddressForManagedStatic(int slot, Context *pContext = NULL);

    // Static Data Members:

    static BOOL s_fInitializedContext;
    static MethodTable *s_pContextMT;
    static MethodDesc *s_pDoCallBackFromEE;
    static MethodDesc *s_pReserveSlot;
    static MethodDesc *s_pThread_CurrentContext;
    static Crst *s_pContextCrst;
    static BYTE s_rgbContextCrstInstanceData[sizeof(Crst)];   
    

    // Non-static Data Members:
    STATIC_DATA* m_pUnsharedStaticData;     // Pointer to native context static data
    STATIC_DATA* m_pSharedStaticData;       // Pointer to native context static data

    // @TODO: CTS. Domains should really be policies on a context and not
    // entry in the context object. When AppDomains become an attribute of
    // a context then add the policy.
    AppDomain           *m_pDomain;

    OBJECTHANDLE        m_ExposedObjectHandle;
    //REVIEW: reqd?? OBJECTHANDLE    m_StrongHndToExposedObject;

    DWORD               m_Signature;
    // NOTE: please maintain the signature as the last member field!!!


    //---------------------------------------------------------
    // Context Methods called from managed world:
    //---------------------------------------------------------
    struct NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(CONTEXTBASEREF, m_pThis);
    };

    struct SetupInternalContextArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(CONTEXTBASEREF, m_pThis);
        DECLARE_ECALL_I4_ARG(BOOL, m_bDefault);
    };

    struct ExecuteCallBackArgs
    {
        DECLARE_ECALL_I4_ARG(LPVOID, m_privateData);
    };

public:
    // Functions called from BCL on a managed context object
    static void __stdcall SetupInternalContext(SetupInternalContextArgs *);
    static void __stdcall CleanupInternalContext(NoArgs *);
    static void __stdcall ExecuteCallBack(ExecuteCallBackArgs *);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\coverage.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COVERAGE_H_
#define _COVERAGE_H_



// Please see coverage.cpp for info on this file
class COMCoverage {
public:


    typedef struct {
                DECLARE_ECALL_I4_ARG(INT32, id);
        } _CoverageArgs;

        static  unsigned __int64 nativeCoverBlock(_CoverageArgs *args);
};
#endif _COVERAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\contexts.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  Contexts.CPP:
 *
 *  Implementation for class Context
 */

#include "common.h"

#include "context.h"

#include "excep.h"
#include "compluswrapper.h"
#include "field.h"
#include "remoting.h"
#include "PerfCounters.h"
#include "specialstatics.h"

#define     NEW_CLS     1

#define IDS_CONTEXT_LOCK            "Context"           // Context lock                                      

BOOL Context::s_fInitializedContext;                    // Static fields inited?
Crst *Context::s_pContextCrst;                          // Lock for safe operations
BYTE Context::s_rgbContextCrstInstanceData[];    

MethodTable *Context::s_pContextMT;     // Method Table for the managed class
MethodDesc *Context::s_pDoCallBackFromEE;//Method Desc for requesting callbacks
MethodDesc *Context::s_pReserveSlot;    //Method Desc for reserving ctx static slots for objRef types

//Method Desc for managed Thread::Get_CurrentContext (property)
MethodDesc *Context::s_pThread_CurrentContext;

#define CONTEXT_SIGNATURE   (0x2b585443)    // CTX+
#define CONTEXT_DESTROYED   (0x2d585443)    // CTX-


Context::Context(AppDomain *pDomain)
{
    SetDomain(pDomain);
    m_Signature = CONTEXT_SIGNATURE;
    
    // This needs to be a LongWeakHandle since we want to be able
    // to run finalizers on Proxies while the Context itself 
    // unreachable. When running the finalizer we will have to 
    // transition into the context like a regular remote call.
    // If this is a short weak handle, it ceases being updated
    // as soon as the context is unreachable. By making it a strong
    // handle, it is updated till the context::finalize is run.

    m_ExposedObjectHandle = pDomain->CreateLongWeakHandle(NULL);

    // Set the pointers to the static data storage
    m_pUnsharedStaticData = NULL;
    m_pSharedStaticData = NULL;
    
    COUNTER_ONLY(GetPrivatePerfCounters().m_Context.cContexts++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Context.cContexts++);
}

Context::~Context()
{
    DestroyLongWeakHandle(m_ExposedObjectHandle);

    SetDomain(NULL);
    
    m_Signature = CONTEXT_DESTROYED;

    // Cleanup the static data storage
    if(m_pUnsharedStaticData)
    {
        for(WORD i = 0; i < m_pUnsharedStaticData->cElem; i++)
        {
            //delete (LPVOID)m_pUnsharedStaticData->dataPtr[i];
			HeapFree(GetProcessHeap(), 0, (LPVOID)m_pUnsharedStaticData->dataPtr[i]);
        }
		HeapFree(GetProcessHeap(), 0, m_pUnsharedStaticData);
        //delete m_pUnsharedStaticData;
        m_pUnsharedStaticData = NULL;
    }

    if(m_pSharedStaticData)
    {
        for(WORD i = 0; i < m_pSharedStaticData->cElem; i++)
        {
			HeapFree(GetProcessHeap(), 0, m_pSharedStaticData->dataPtr[i]);
	        //delete (LPVOID)m_pSharedStaticData->dataPtr[i];
        }
        HeapFree(GetProcessHeap(), 0, m_pSharedStaticData);
        //delete m_pSharedStaticData; 
        m_pSharedStaticData = NULL;
    }
    
    COUNTER_ONLY(GetPrivatePerfCounters().m_Context.cContexts--);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Context.cContexts--);
}

// static
Context* Context::CreateNewContext(AppDomain *pDomain)
{
    void *p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Context));
    if (p == NULL) FailFast(GetThread(), FatalOutOfMemory);
    return new (p) Context(pDomain);
}

// static
BOOL Context::Initialize()
{
    s_fInitializedContext = FALSE;

    // Initialize the context critical section
    s_pContextCrst = new (&s_rgbContextCrstInstanceData) 
                      Crst(IDS_CONTEXT_LOCK,CrstRemoting, TRUE, FALSE);

    if(!s_pContextCrst)
        return FALSE;

    return TRUE;
}

//static
BOOL Context::ValidateContext(Context *pCtx)
{

    _ASSERTE(pCtx != NULL);
    BOOL bRet = FALSE;
    EE_TRY_FOR_FINALLY
    {
        if (pCtx->m_Signature == CONTEXT_SIGNATURE)
        {
            bRet = TRUE;
        }
    }
    EE_FINALLY
    {
        if (GOT_EXCEPTION()) 
        {
            // This is a bogus context!
            bRet = FALSE;
        }
    } EE_END_FINALLY;
    return bRet;
}

// static
Context *Context::SetupDefaultContext(AppDomain *pDomain)
{
    Context *pCtx = ::new Context(pDomain);
    _ASSERTE(pDomain != NULL);
    return pCtx;
}

void Context::CleanupDefaultContext(AppDomain *pDomain)
{
    delete pDomain->GetDefaultContext();
}

void Context::EnterLock()
{

    s_pContextCrst->Enter();
}

void Context::LeaveLock()
{
    s_pContextCrst->Leave();
}

//+----------------------------------------------------------------------------
//
//  Method:     Context::Cleanup    public
//
//  Synopsis:   Clean up the context related data structures
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
void Context::Cleanup()
{
    if (s_pContextCrst)
    {
        delete s_pContextCrst;
        s_pContextCrst = NULL;
    }
}
#endif /* SHOULD_WE_CLEANUP */

//+----------------------------------------------------------------------------
//
//  Method:     Context::InitializeFields    private
//
//  Synopsis:   Extract the method descriptors and fields of Context class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL Context::InitializeFields()
{
    BOOL fReturn = TRUE;

    // Acquire the lock 
    Thread *t = GetThread();
    BOOL toggleGC = (t && t->PreemptiveGCDisabled());
    if (toggleGC)
        t->EnablePreemptiveGC();
    s_pContextCrst->Enter();
    if (toggleGC)
        t->DisablePreemptiveGC();

    if(!s_fInitializedContext)
    {
        s_pContextMT = g_Mscorlib.GetClass(CLASS__CONTEXT);

        // Cache the methodDesc for Context.DoCallBackFromEE
        s_pDoCallBackFromEE = g_Mscorlib.GetMethod(METHOD__CONTEXT__CALLBACK);

        s_pReserveSlot = g_Mscorlib.GetMethod(METHOD__CONTEXT__RESERVE_SLOT);

        // NOTE: CurrentContext is a static property on System.Threading.Thread
        s_pThread_CurrentContext = g_Mscorlib.GetMethod(METHOD__THREAD__GET_CURRENT_CONTEXT);
            
        // *********   NOTE   ************ 
        // This must always be the last statement in this block to prevent races
        // 
        s_fInitializedContext = TRUE;
        // ********* END NOTE ************        
    }

    // Leave the lock 
    LeaveLock();

    LOG((LF_REMOTING, LL_INFO10, "Context::InitializeFields returning %d\n", fReturn));
    return fReturn;
}



// This is called by the managed context constructor
void Context::SetupInternalContext(SetupInternalContextArgs *pArgs)
{

    _ASSERTE(pArgs != NULL);
    _ASSERTE(pArgs->m_pThis != NULL);
    _ASSERTE(pArgs->m_pThis->m_internalContext == NULL);


    // Make sure we have initialized pMT, checked offsets etc.
    InitializeFields();
    Context *pCtx;
    if (pArgs->m_bDefault)
    {
        // We have to hook this up with the internal default
        // context for the current appDomain
        pCtx = GetThread()->GetDomain()->GetDefaultContext();
    }
    else
    {
        // Create the unmanaged backing context object
        pCtx = Context::CreateNewContext(GetThread()->GetDomain());
    }


    // Set the managed & unmanaged objects to point at each other.
    pArgs->m_pThis->SetInternalContext(pCtx);
    pCtx->SetExposedObject((OBJECTREF) pArgs->m_pThis);


    // Set the AppDomain field in the Managed context object
    pArgs->m_pThis->SetExposedDomain(
                        GetThread()->GetDomain()->GetExposedObject());

    COUNTER_ONLY(GetPrivatePerfCounters().m_Context.cContexts++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Context.cContexts++);
}

// This is called by the managed context finalizer
void Context::CleanupInternalContext(NoArgs *pArgs)
{
    _ASSERTE(pArgs != NULL);
    _ASSERTE(pArgs->m_pThis != NULL);

    CONTEXTBASEREF refCtx = pArgs->m_pThis;

    Context *pCtx = refCtx->m_internalContext;
    _ASSERTE(pCtx != NULL);
    if (ValidateContext(pCtx) == TRUE)
    {
        LOG((LF_APPDOMAIN, LL_INFO1000, "Context::CleanupInternalContext: %8.8x, %8.8x\n", refCtx, pCtx));
        Context::FreeContext(pCtx);
    }
    COUNTER_ONLY(GetPrivatePerfCounters().m_Context.cContexts--);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Context.cContexts--);
}


// Access the appropriate wrapper cache for this context
ComPlusWrapperCache *Context::GetComPlusWrapperCache()
{
        _ASSERTE(GetDomain());
    return GetDomain()->GetComPlusWrapperCache();
}


OBJECTREF Context::GetExposedObject()
{
    THROWSCOMPLUSEXCEPTION();
    Thread *pCurThread = GetThread();

    // REVIEW: This will create an uninitialized object ... we should
    // either get rid of the managed constructor for contexts (since it
    // is almost useless now ... or else call the Constructor from here).

    _ASSERTE(pCurThread->PreemptiveGCDisabled());

    if (ObjectFromHandle(m_ExposedObjectHandle) == NULL)
    {
        // Ensure that we have inited the methodTable etc
        InitializeFields();

#if 0
        // Allocate the exposed context object.
        CONTEXTBASEREF ctx = (CONTEXTBASEREF) AllocateObject(
                                                Context::s_pContextMT);
        // BUGBUG: We need to call the constructor here
#else

        // This call should fault in the managed context for the thread
        CONTEXTBASEREF ctx = (CONTEXTBASEREF) 
            Int64ToObj(
                MDofManagedThreadCurrentContext()->Call(
                    NULL,
                    METHOD__THREAD__GET_CURRENT_CONTEXT));
#endif


        GCPROTECT_BEGIN(ctx);

        // Take a lock to make sure that only one thread creates the object.
        pCurThread->EnablePreemptiveGC();
        // This locking may be too severe!
        EnterLock();       
        pCurThread->DisablePreemptiveGC();

        // Check to see if another thread has not already created the exposed object.
        if (ObjectFromHandle(m_ExposedObjectHandle) == NULL)
        {
            // Keep a weak reference to the exposed object.
            StoreObjectInHandle(m_ExposedObjectHandle, (OBJECTREF) ctx);
            
            ctx->SetInternalContext(this);
        }
        LeaveLock();
        GCPROTECT_END();
        
    }
    return ObjectFromHandle(m_ExposedObjectHandle);
}

// This will NOT create the exposed object if there isn't one!
OBJECTREF Context::GetExposedObjectRaw()
{
    return ObjectFromHandle(m_ExposedObjectHandle);
}

void Context::SetExposedObject(OBJECTREF exposed)
{
    _ASSERTE(exposed != NULL);
    _ASSERTE(ObjectFromHandle(m_ExposedObjectHandle) == NULL);
    StoreObjectInHandle(m_ExposedObjectHandle, exposed);
}

// This is called by EE to transition into a context(possibly in
// another appdomain) and execute the method Context::ExecuteCallBack
// with the private data provided to this method
void Context::RequestCallBack(Context* targetCtxID, void* privateData)
{
    THROWSCOMPLUSEXCEPTION(); 
    _ASSERTE(ValidateContext((Context*)targetCtxID));

    // Ensure that we have inited the methodTable, methodDesc-s etc
    InitializeFields(); 

    // Get the current context of the thread. This is assumed as
    // the context where the request originated
    Context *pCurrCtx = GetCurrentContext();

    // Check that the target context is not the same (presumably the caller has checked for it).
    _ASSERTE(pCurrCtx != targetCtxID);

    // Check if we might be going to a context in another appDomain.
    size_t targetDomainID = 0;
    AppDomain *pCurrDomain = pCurrCtx->GetDomain();
    AppDomain *pTargetDomain = ((Context*)targetCtxID)->GetDomain();
    
    if (pCurrDomain != pTargetDomain)
    {
        targetDomainID = pTargetDomain->GetId();
    }

    INT64 args[3];
    // args in reverse order
    args[2] = (INT64) targetCtxID;
    args[1] = (INT64) privateData;
    args[0] = (INT64) targetDomainID;
    
    // we need to be co-operative mode for jitting
    Thread* pCurThread = GetThread();
    _ASSERTE(pCurThread);
    BOOL cooperativeGCMode = pCurThread->PreemptiveGCDisabled();
    if (!cooperativeGCMode)
        pCurThread->DisablePreemptiveGC();

    (MDofDoCallBackFromEE()->Call(args, METHOD__CONTEXT__CALLBACK));

    if (!cooperativeGCMode)
        pCurThread->EnablePreemptiveGC();

}

/*** Definitions of callback executions for the various callbacks that are known to EE  ***/

// Callback for waits on waithandle
void Context::ExecuteWaitCallback(WaitArgs* waitArgs)
{

    Thread* pCurThread; 
    pCurThread = GetThread();
    _ASSERTE(pCurThread != NULL);
    // DoAppropriateWait switches to preemptive GC before entering the wait
    *(waitArgs->pResult) = pCurThread->DoAppropriateWait( waitArgs->numWaiters,
                                                          waitArgs->waitHandles,
                                                          waitArgs->waitAll,
                                                          waitArgs->millis,
                                                          waitArgs->alertable);
}

// Callback for monitor wait on objects
void Context::ExecuteMonitorWaitCallback(MonitorWaitArgs* waitArgs)
{
    Thread* pCurThread; 
    pCurThread = GetThread();
    _ASSERTE(pCurThread != NULL);
    BOOL toggleGC = pCurThread->PreemptiveGCDisabled();
    if (toggleGC)
        pCurThread->EnablePreemptiveGC();
    *(waitArgs->pResult) = pCurThread->Block(waitArgs->millis,
                                             waitArgs->syncState);
    if (toggleGC)
        pCurThread->DisablePreemptiveGC();
}

// This is where a call back request made by EE in Context::RequestCallBack
// actually gets "executed". 
// At this point we have done a real context transition from the threads
// context when RequestCallBack was called to the destination context.
void __stdcall Context::ExecuteCallBack(ExecuteCallBackArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION(); 
    _ASSERTE(pArgs != NULL);
    _ASSERTE(pArgs->m_privateData);
    

    switch (((CallBackInfo*) pArgs->m_privateData)->callbackId)
    {
        case Wait_callback:
            {
                WaitArgs* waitArgs; 
                waitArgs = (WaitArgs*) ((CallBackInfo*) pArgs->m_privateData)->callbackData;
                ExecuteWaitCallback(waitArgs);
            }
            break;
        case MonitorWait_callback:
            {
                MonitorWaitArgs* waitArgs; 
                waitArgs = (MonitorWaitArgs*) ((CallBackInfo*) pArgs->m_privateData)->callbackData;
                ExecuteMonitorWaitCallback(waitArgs);
            }
            break;
        case ADTransition_callback:
            {
                ADCallBackArgs* pCallArgs = (ADCallBackArgs*)(((CallBackInfo*) pArgs->m_privateData)->callbackData); 
                pCallArgs->pTarget(pCallArgs->pArguments);
            }
            break;
        // Add other callback types here
        default:
            _ASSERTE(!"Invalid callback type");
            break;
    }
    // This is EE's entry point to do whatever it wanted to do in
    // the targetContext. This will return back into the managed 
    // world and transition back into the original context.
}

//+----------------------------------------------------------------------------
//
//  Method:     Context::GetStaticFieldAddress   private
//
//  Synopsis:   Get the address of the field relative to the current context.
//              If an address has not been assigned yet then create one.
//
//  History:    15-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
LPVOID Context::GetStaticFieldAddress(FieldDesc *pFD)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL fThrow = FALSE;
    LPVOID pvAddress = NULL;    
    Context *pCtx = NULL;    
    STATIC_DATA *pData;
    MethodTable *pMT = pFD->GetMethodTableOfEnclosingClass();
    BOOL fIsShared = pMT->IsShared();
    WORD wClassOffset = pMT->GetClass()->GetContextStaticOffset();
    WORD currElem = 0; 

    // NOTE: if you change this method, you must also change
    // GetStaticFieldAddrForDebugger below.

    // Retrieve the current context 
    pCtx = GetCurrentContext();
    _ASSERTE(NULL != pCtx);

    _ASSERTE(!s_pContextCrst->OwnedByCurrentThread());

    // Acquire the context lock before accessing the static data pointer
    Thread *t = GetThread();
    BOOL toggleGC = (t && t->PreemptiveGCDisabled());
    if (toggleGC)
        t->EnablePreemptiveGC();
    s_pContextCrst->Enter();
    if (toggleGC)
        t->DisablePreemptiveGC();

    if(!fIsShared)
    {
        pData = pCtx->m_pUnsharedStaticData;
    }
    else
    {
        pData = pCtx->m_pSharedStaticData;
    }
    
    if(NULL != pData)
    {
        currElem = pData->cElem;
    }

    // Check whether we have allocated space for storing a pointer to
    // this class' context static store    
    if(wClassOffset >= currElem)
    {
        // Allocate space for storing pointers 
        WORD wNewElem = (currElem == 0 ? 4 : currElem*2);
        // Ensure that we grow to a size larger than the index we intend to use
        while (wNewElem <= wClassOffset)
        {
            wNewElem = 2*wNewElem;
        }
        //STATIC_DATA *pNew = (STATIC_DATA *)new BYTE[sizeof(STATIC_DATA) + wNewElem*sizeof(LPVOID)]; 

        STATIC_DATA *pNew = (STATIC_DATA *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BYTE)*(sizeof(STATIC_DATA) + wNewElem*sizeof(LPVOID)));

        if (pNew == NULL) FailFast(GetThread(), FatalOutOfMemory);

        pNew->cElem = wNewElem;     // Set the new count.
        if(NULL != pData)
        {
            // Copy the old data into the new data
            memcpy(&pNew->dataPtr[0], &pData->dataPtr[0], currElem*sizeof(LPVOID));
        }
        // Zero init any new elements.
        memset(&pNew->dataPtr[currElem], 0x00, (wNewElem - currElem)* sizeof(LPVOID));

        // Delete the old data
        //delete pData;
        HeapFree(GetProcessHeap(), 0, pData);
  
        // Update the locals
        pData = pNew;

        // Reset the pointers in the context object to point to the 
        // new memory
        if(!fIsShared)
        {
            pCtx->m_pUnsharedStaticData = pData;
        }
        else
        {
            pCtx->m_pSharedStaticData = pData;
        }            
    }
    
    // Check whether we have to allocate space for 
    // the context local statics of this class
    if(NULL == pData->dataPtr[wClassOffset])
    {
        // Allocate memory for context static fields
        //pData->dataPtr[wClassOffset] = (LPVOID)new BYTE[pMT->GetClass()->GetContextLocalStaticsSize()];
        pData->dataPtr[wClassOffset] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BYTE)*(pMT->GetClass()->GetContextLocalStaticsSize()));
        if (pData->dataPtr[wClassOffset] == NULL) FailFast(GetThread(), FatalOutOfMemory);

        // Initialize the memory allocated for the fields
        memset(pData->dataPtr[wClassOffset], 0x00, pMT->GetClass()->GetContextLocalStaticsSize());
    }
    
    _ASSERTE(NULL != pData->dataPtr[wClassOffset]);
    // We have allocated static storage for this data
    // Just return the address by getting the offset into the data
    pvAddress = (LPVOID)((LPBYTE)pData->dataPtr[wClassOffset] + pFD->GetOffset());

    // For object and value class fields we have to allocate storage in the
    // __StaticContainer class in the managed heap
#ifdef NEW_CLS
    if(pFD->IsObjRef() || pFD->IsByValue())
    {
        // Ensure that we have inited the methodDesc for ReserveSlot etc
        InitializeFields();
        // in this case *pvAddress == bucket|index
        int *pSlot = (int*)pvAddress;
        pvAddress = NULL;
        fThrow = GetStaticFieldAddressSpecial(pFD, pMT, pSlot, &pvAddress);

        if (pFD->IsByValue())
        {
            _ASSERTE(pvAddress != NULL);
            pvAddress = (*((OBJECTREF*)pvAddress))->GetData();
        }
        // ************************************************
        // ************** WARNING *************************
        // Do not provoke GC from here to the point JIT gets
        // pvAddress back
        // ************************************************
        _ASSERTE(*pSlot > 0);
    }
#else
    if((pFD->IsObjRef() || pFD->IsByValue()) && (NULL == *(LPVOID *)pvAddress))
    {
        fThrow = AllocateStaticFieldObjRefPtrs(pFD, pMT, pvAddress);
    }

    if((pFD->IsObjRef() || pFD->IsByValue()) && !fThrow)
    {
        _ASSERTE(NULL != pvAddress);
        // Indirect to get the address of the object in the managed heap
        pvAddress = *(LPVOID *)pvAddress;
    }
#endif // NEW_CLS
    
    s_pContextCrst->Leave();

    // Check if we have to throw an exception
    if(fThrow)
    {
        COMPlusThrowOM();
    }
    _ASSERTE(NULL != pvAddress);
    _ASSERTE(!s_pContextCrst->OwnedByCurrentThread());

    return pvAddress;
}



//+----------------------------------------------------------------------------
//       
//  Method:     Context::GetStaticFieldAddrForDebugger   private
//
//  Synopsis:   Get the address of the field relative to the context given a thread. 
//              If an address has not been assigned, return NULL.
//              No creating is allowed.
//
//  History:    04-May-2001   MeichinT      Created
//
//+----------------------------------------------------------------------------
LPVOID Context::GetStaticFieldAddrForDebugger(Thread *pTH, FieldDesc *pFD)
{    
    LPVOID pvAddress = NULL;    
    Context *pCtx = NULL;    
    STATIC_DATA *pData;
    MethodTable *pMT = pFD->GetMethodTableOfEnclosingClass();
    BOOL fIsShared = pMT->IsShared();
    WORD wClassOffset = pMT->GetClass()->GetContextStaticOffset();
    WORD currElem = 0; 

    // Retrieve the context with a given thread 
    pCtx = pTH->GetContext();
    _ASSERTE(NULL != pCtx);

    if(!fIsShared)
    {
        pData = pCtx->m_pUnsharedStaticData;
    }
    else
    {
        pData = pCtx->m_pSharedStaticData;
    }
    
    if(NULL != pData)
    {
        currElem = pData->cElem;
    }

    // Check whether we have allocated space for storing a pointer to
    // this class' context static store    
    if(wClassOffset >= currElem || NULL == pData->dataPtr[wClassOffset])
    {
        return NULL;
    }
    
    _ASSERTE(NULL != pData->dataPtr[wClassOffset]);

    // We have allocated static storage for this data
    // Just return the address by getting the offset into the data
    pvAddress = (LPVOID)((LPBYTE)pData->dataPtr[wClassOffset] + pFD->GetOffset());

    if(pFD->IsObjRef() || pFD->IsByValue())
    {
        // If Context is not initialized, just return NULL.
        if (!s_fInitializedContext)
            return NULL;

        if (NULL == *(LPVOID *)pvAddress)
        {
            pvAddress = NULL;
            LOG((LF_SYNC, LL_ALWAYS, "dbgr: pvAddress = NULL"));
        }
        else
        {
            pvAddress = CalculateAddressForManagedStatic(*(int*)pvAddress, pCtx);
            LOG((LF_SYNC, LL_ALWAYS, "dbgr: pvAddress = %lx", pvAddress));
            if (pFD->IsByValue())
            {
                _ASSERTE(pvAddress != NULL);
                pvAddress = (*((OBJECTREF*)pvAddress))->GetData();
            }
        }
    }

    return pvAddress;
}

//+----------------------------------------------------------------------------
//
//  Method:     Context::AllocateStaticFieldObjRefPtrs   private
//
//  Synopsis:   Allocate an entry in the __StaticContainer class in the
//              managed heap for static objects and value classes
//
//  History:    28-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL Context::AllocateStaticFieldObjRefPtrs(FieldDesc *pFD, MethodTable *pMT, LPVOID pvAddress)
{
    BOOL fThrow = FALSE;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();    

    // Retrieve the object ref pointers from the app domain.
    OBJECTREF *pObjRef = NULL;

    COMPLUS_TRY 
    {
        // Reserve some object ref pointers.
        GetAppDomain()->AllocateStaticFieldObjRefPtrs(1, &pObjRef);


        // to a boxed version of the value class.  This allows the standard GC
        // algorithm to take care of internal pointers in the value class.
        if (pFD->IsByValue())
        {
    
            // Extract the type of the field
            TypeHandle  th;        
            PCCOR_SIGNATURE pSig;
            DWORD       cSig;
            pFD->GetSig(&pSig, &cSig);
            FieldSig sig(pSig, pFD->GetModule());

            OBJECTREF throwable = NULL;
            GCPROTECT_BEGIN(throwable);
            th = sig.GetTypeHandle(&throwable);
            if (throwable != NULL)
                COMPlusThrow(throwable);
            GCPROTECT_END();

            OBJECTREF obj = AllocateObject(th.AsClass()->GetMethodTable());
            SetObjectReference( pObjRef, obj, GetAppDomain() );                      
        }

        *(ULONG_PTR *)pvAddress =  (ULONG_PTR)pObjRef;
    } 
    COMPLUS_CATCH
    {
        fThrow = TRUE;
    }            
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return fThrow;
}


// This is used for context relative statics that are object refs 
// These are stored in a structure in the managed context. The first
// time over an index and a bucket are determined and subsequently 
// remembered in the location for the field in the per-context-per-class
// data structure.
// Here we map back from the index to the address of the object ref.
LPVOID Context::CalculateAddressForManagedStatic(int slot, Context *pContext)
{
    BEGINFORBIDGC();
    OBJECTREF *pObjRef;
    int bucket = (slot>>16);
    int index = (0x0000ffff&slot);
    // Now determine the address of the static field 
    PTRARRAYREF bucketRef = NULL;

    if (pContext == NULL)
        pContext = GetCurrentContext();

    _ASSERTE(pContext);

    bucketRef = ((CONTEXTBASEREF)pContext->GetExposedObjectRaw())->GetContextStaticsHolder();
    // walk the chain to our bucket
    while (bucket--)
    {
        bucketRef = (PTRARRAYREF) bucketRef->GetAt(0);
    }
    // Index 0 is used to point to the next bucket!
    _ASSERTE(index > 0);
    pObjRef = ((OBJECTREF*)bucketRef->GetDataPtr())+index;
    ENDFORBIDGC();
    return (LPVOID) pObjRef;
}

//+----------------------------------------------------------------------------
//
//  Method:     Context::GetStaticFieldAddressSpecial private
//
//  Synopsis:   Allocate an entry in the __StaticContainer class in the
//              managed heap for static objects and value classes
//
//  History:    28-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------

// NOTE: At one point we used to allocate these in the long lived handle table
// which is per-appdomain. However, that causes them to get rooted and not 
// cleaned up until the appdomain gets unloaded. This is not very desirable 
// since a context static object may hold a reference to the context itself or
// to a proxy in the context causing a whole lot of garbage to float around.
// Now (2/13/01) these are allocated from a managed structure rooted in each
// managed context.
BOOL Context::GetStaticFieldAddressSpecial(
    FieldDesc *pFD, MethodTable *pMT, int *pSlot, LPVOID *ppvAddress)
{
    BOOL fThrow = FALSE;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();    

    COMPLUS_TRY 
    {
        OBJECTREF *pObjRef = NULL;
        BOOL bNewSlot = (*pSlot == 0);
        if (bNewSlot)
        {
            // ! this line will trigger a GC, don't move it down
            // ! without protecting the args[] and other OBJECTREFS
            MethodDesc * pMD = MDofReserveSlot();
            
            // We need to assign a location for this static field. 
            // Call the managed helper
            INT64 args[1] = {
                ObjToInt64(GetCurrentContext()->GetExposedObject())
            };
            
            // The managed ReserveSlot methods counts on this!
            _ASSERTE(s_pContextCrst->OwnedByCurrentThread());

            _ASSERTE(args[0] != 0);

            *pSlot = (int) pMD->Call(args, METHOD__CONTEXT__RESERVE_SLOT);
        
            _ASSERTE(*pSlot>0);
        

            // to a boxed version of the value class.This allows the standard GC
            // algorithm to take care of internal pointers in the value class.
            if (pFD->IsByValue())
            {
                // Extract the type of the field
                TypeHandle  th;        
                PCCOR_SIGNATURE pSig;
                DWORD       cSig;
                pFD->GetSig(&pSig, &cSig);
                FieldSig sig(pSig, pFD->GetModule());

                OBJECTREF throwable = NULL;
                GCPROTECT_BEGIN(throwable);
                th = sig.GetTypeHandle(&throwable);
                if (throwable != NULL)
                    COMPlusThrow(throwable);
                GCPROTECT_END();

                OBJECTREF obj = AllocateObject(th.AsClass()->GetMethodTable());
                pObjRef = (OBJECTREF*)CalculateAddressForManagedStatic(*pSlot);
                SetObjectReference( pObjRef, obj, GetAppDomain() );
            }
            else
            {
                pObjRef = (OBJECTREF*)CalculateAddressForManagedStatic(*pSlot);
            }
        }
        else
        {
            // If the field already has a location assigned we go through here
            pObjRef = (OBJECTREF*)CalculateAddressForManagedStatic(*pSlot);
        }
        *(ULONG_PTR *)ppvAddress =  (ULONG_PTR)pObjRef;
    } 
    COMPLUS_CATCH
    {
        fThrow = TRUE;
    }            
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return fThrow;
}

#ifdef ENABLE_PERF_COUNTERS

FCIMPL0(LPVOID, GetPrivateContextsPerfCountersEx)
    return (LPVOID)GetPrivateContextsPerfCounters();
}

FCIMPL0(LPVOID, GetGlobalContextsPerfCountersEx)
    return (LPVOID)GetGlobalContextsPerfCounters();
}

#else
FCIMPL0(LPVOID, GetPrivateContextsPerfCountersEx)
    return NULL;
}

FCIMPL0(LPVOID, GetGlobalContextsPerfCountersEx)
    return NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\corhost.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorHost.cpp
//
// Implementation for the meta data dispenser code.
//
//*****************************************************************************
#include "common.h"
#include "mscoree.h"
#include "corhost.h"
#include "excep.h"
#include "threads.h"
#include "jitinterface.h"
#include "cormap.hpp"
#include "permset.h"
#include "MDConverter.h"
#include "COMString.h"
#include "PEVerifier.h"
#include "EEConfig.h"
#include "dbginterface.h"
#include "ComCallWrapper.h"

extern void STDMETHODCALLTYPE EEShutDown(BOOL fIsDllUnloading);
extern HRESULT STDMETHODCALLTYPE CoInitializeEE(DWORD fFlags);
extern void PrintToStdOutA(const char *pszString);
extern void PrintToStdOutW(const WCHAR *pwzString);


IGCThreadControl *CorHost::m_CachedGCThreadControl = 0;
IGCHostControl *CorHost::m_CachedGCHostControl = 0;
IDebuggerThreadControl *CorHost::m_CachedDebuggerThreadControl = 0;
DWORD *CorHost::m_DSTArray = 0;
DWORD CorHost::m_DSTCount = 0;
DWORD CorHost::m_DSTArraySize = 0;

CorHost::CorHost() :
    m_cRef(0),
    m_pMDConverter(NULL),
    m_Started(FALSE),
    m_pValidatorMethodDesc(0)
{
}

//*****************************************************************************
// ICorRuntimeHost
//*****************************************************************************

// *** ICorRuntimeHost methods ***
// Returns an object for configuring the runtime prior to 
// it starting. If the runtime has been initialized this
// routine returns an error. See ICorConfiguration.
HRESULT CorHost::GetConfiguration(ICorConfiguration** pConfiguration)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (!pConfiguration)
        return E_POINTER;

    if (!m_Started)
    {
        *pConfiguration = (ICorConfiguration *) this;
        AddRef();
        return S_OK;
    }

    // Cannot obtain configuration after the runtime is started
    return E_FAIL;
}

// Starts the runtime. This is equivalent to CoInitializeEE();
HRESULT CorHost::Start()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    m_Started = TRUE;
    return CoInitializeEE(COINITEE_DEFAULT);
}

// Terminates the runtime, This is equivalent CoUninitializeCor();
HRESULT CorHost::Stop()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    CoUninitializeCor();
    return S_OK;
}

// Creates a domain in the runtime. The identity array is 
// a pointer to an array TYPE containing IIdentity objects defining
// the security identity.
HRESULT CorHost::CreateDomain(LPCWSTR pwzFriendlyName,
                              IUnknown* pIdentityArray, // Optional
                              IUnknown ** pAppDomain)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    return CreateDomainEx(pwzFriendlyName,
                          NULL,
                          NULL,
                          pAppDomain);
}
    
    
HRESULT CorHost::GetDomainsExposedObject(AppDomain* pDomain, IUnknown** pAppDomain)
{

    HRESULT hr = S_OK;
    IUnknown* punk = NULL;

    Thread* pThread = GetThread();
    if (!pThread)
        return E_UNEXPECTED;
    BOOL fWasGCEnabled = !pThread->PreemptiveGCDisabled();
    if (fWasGCEnabled)
        pThread->DisablePreemptiveGC();
    
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();
    COMPLUS_TRY {
        OBJECTREF ref = NULL;
        GCPROTECT_BEGIN(ref);
        DECLARE_ALLOCA_CONTEXT_TRANSITION_FRAME(pFrame);
        // ok to do this here as we are just grabbing a wrapper. No managed code will run
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), pFrame, TRUE);
        ref = pDomain->GetExposedObject();
        IfFailThrow(QuickCOMStartup());   
        punk = GetComIPFromObjectRef(&ref, ComIpType_Unknown, NULL);
        pThread->ReturnToContext(pFrame, TRUE);
        GCPROTECT_END();
    }
    COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH
          
    if (fWasGCEnabled)
        pThread->EnablePreemptiveGC();

    if(SUCCEEDED(hr)) *pAppDomain = punk;

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

    
// Returns the default domain.
HRESULT CorHost::GetDefaultDomain(IUnknown ** pAppDomain)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if( pAppDomain == NULL) return E_POINTER;

    HRESULT hr = E_UNEXPECTED;

    if (SystemDomain::System()) {
        AppDomain* pCom = SystemDomain::System()->DefaultDomain();
        if(pCom)
            hr = GetDomainsExposedObject(pCom, pAppDomain);
    }

    return hr;
}

// Returns the default domain.
HRESULT CorHost::CurrentDomain(IUnknown ** pAppDomain)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
   if( pAppDomain == NULL) return E_POINTER;

    HRESULT hr = E_UNEXPECTED;
            
    IUnknown* punk = NULL;
    AppDomain* pCom = ::GetAppDomain();
    if(pCom)
        hr = GetDomainsExposedObject(pCom, pAppDomain);

    return hr;
}

// Enumerate currently existing domains. 
HRESULT CorHost::EnumDomains(HDOMAINENUM *hEnum)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if(hEnum == NULL) return E_POINTER;

    AppDomainIterator *pEnum = new (nothrow) AppDomainIterator();
    if(pEnum) {
        *hEnum = (HDOMAINENUM) pEnum;
        return S_OK;
    }

    *hEnum = NULL;
    return E_OUTOFMEMORY;
}

    
// Returns S_FALSE when there are no more domains. A domain
// is passed out only when S_OK is returned.
HRESULT CorHost::NextDomain(HDOMAINENUM hEnum,
                            IUnknown** pAppDomain)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if(hEnum == NULL || pAppDomain == NULL) return E_POINTER;

    HRESULT hr;
    AppDomainIterator *pEnum = (AppDomainIterator *) hEnum;

    if (pEnum->Next()) {
        AppDomain* pDomain = pEnum->GetDomain();
        hr = GetDomainsExposedObject(pDomain, pAppDomain);
    }
    else
        hr = S_FALSE;
    
    return hr;
}

// Creates a domain in the runtime. The identity array is 
// a pointer to an array TYPE containing IIdentity objects defining
// the security identity.
HRESULT CorHost::CreateDomainEx(LPCWSTR pwzFriendlyName,
                                IUnknown* pSetup, // Optional
                                IUnknown* pEvidence, // Optional
                                IUnknown ** pAppDomain)
{
    HRESULT hr;
    if(!pwzFriendlyName) return E_POINTER;
    if(pAppDomain == NULL) return E_POINTER;
    if(g_RefCount == 0) return E_FAIL;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    // This will set up a managed thread object if one does not already exist
    // for this particular thread.
    Thread* pThread = SetupThread();

    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    if (FAILED(hr = QuickCOMStartup()))
        goto Exit;

    BOOL fWasGCEnabled = !pThread->PreemptiveGCDisabled();
    if (fWasGCEnabled)
        pThread->DisablePreemptiveGC();

    COMPLUS_TRY {
        
        struct _gc {
            STRINGREF pName;
            OBJECTREF pSetup;
            OBJECTREF pEvidence;
            APPDOMAINREF pDomain;
        } gc;
        ZeroMemory(&gc, sizeof(gc));

        GCPROTECT_BEGIN(gc);
        gc.pName = COMString::NewString(pwzFriendlyName);
        
        if(pSetup) 
            gc.pSetup = GetObjectRefFromComIP(pSetup);
        if(pEvidence)
            gc.pEvidence = GetObjectRefFromComIP(pEvidence);
        
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__CREATE_DOMAIN);
        
        INT64 args[3] = {
            ObjToInt64(gc.pSetup),
            ObjToInt64(gc.pEvidence),
            ObjToInt64(gc.pName)
        };
        gc.pDomain = (APPDOMAINREF) ObjectToOBJECTREF((Object*) pMD->Call(args, METHOD__APP_DOMAIN__CREATE_DOMAIN));
        IfFailThrow(QuickCOMStartup());   
        *pAppDomain = GetComIPFromObjectRef((OBJECTREF*) &gc.pDomain, ComIpType_Unknown, NULL);
        GCPROTECT_END();
    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH

    if (fWasGCEnabled)
        pThread->EnablePreemptiveGC();


Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// Close the enumeration releasing resources
HRESULT CorHost::CloseEnum(HDOMAINENUM hEnum)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if(hEnum) {
        AppDomainIterator* pEnum = (AppDomainIterator*) hEnum;
        delete pEnum;
    }
    return S_OK;
}
    
    
HRESULT CorHost::CreateDomainSetup(IUnknown **pAppDomainSetup)
{
    HRESULT hr;

    if (!pAppDomainSetup)
        return E_POINTER;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();
    // Create the domain. 
    Thread* pThread = GetThread();
    if (!pThread)
        IfFailGo(E_UNEXPECTED);

    IfFailGo(QuickCOMStartup());

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        struct _gc {
            OBJECTREF pSetup;
        } gc;
        ZeroMemory(&gc, sizeof(gc));

        MethodTable* pMT = g_Mscorlib.GetClass(CLASS__APPDOMAIN_SETUP);
        GCPROTECT_BEGIN(gc);
        gc.pSetup = AllocateObject(pMT);
        IfFailThrow(QuickCOMStartup());   
        *pAppDomainSetup = GetComIPFromObjectRef((OBJECTREF*) &gc.pSetup, ComIpType_Unknown, NULL);
        GCPROTECT_END();
    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH
          
    END_ENSURE_COOPERATIVE_GC();

 ErrExit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

HRESULT CorHost::CreateEvidence(IUnknown **pEvidence)
{
    HRESULT hr;
    if (!pEvidence)
        return E_POINTER;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();
    // Create the domain. 
    Thread* pThread = GetThread();
    if (!pThread)
        IfFailGo(E_UNEXPECTED);

    IfFailGo(QuickCOMStartup());

    BOOL fWasGCEnabled = !pThread->PreemptiveGCDisabled();
    if (fWasGCEnabled)
        pThread->DisablePreemptiveGC();

    COMPLUS_TRY {
        struct _gc {
            OBJECTREF pEvidence;
        } gc;
        ZeroMemory(&gc, sizeof(gc));

        MethodTable* pMT = g_Mscorlib.GetClass(CLASS__EVIDENCE);
        GCPROTECT_BEGIN(gc);
        gc.pEvidence = AllocateObject(pMT);
        IfFailThrow(QuickCOMStartup());   
        *pEvidence = GetComIPFromObjectRef((OBJECTREF*) &gc.pEvidence, ComIpType_Unknown, NULL);
        GCPROTECT_END();
    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH
          
    if (fWasGCEnabled)
        pThread->EnablePreemptiveGC();

ErrExit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}


HRESULT CorHost::UnloadDomain(IUnknown *pUnkDomain)
{
    HRESULT hr = S_OK;
    if(!pUnkDomain) return E_POINTER;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();
    Thread* pThread = GetThread();
    if (!pThread)
        IfFailGo(E_UNEXPECTED);

    IfFailGo(QuickCOMStartup());

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
		// unload doesn't need to switch to the domain to be unloaded
		OBJECTREF pRef = NULL;
		GCPROTECT_BEGIN(pRef);
		pRef = GetObjectRefFromComIP(pUnkDomain);
		MethodDesc* pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__UNLOAD);
		INT64 arg = ObjToInt64((OBJECTREF) pRef);
		pMD->Call(&arg, METHOD__APP_DOMAIN__UNLOAD);
		GCPROTECT_END();
    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH
          
    END_ENSURE_COOPERATIVE_GC();

ErrExit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

//*****************************************************************************
// Fiber Methods
//*****************************************************************************

HRESULT CorHost::CreateLogicalThreadState()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
#ifdef _DEBUG
    _ASSERTE (GetThread() == 0 || GetThread()->HasRightCacheStackBase());
#endif
    Thread  *thread = NULL;

    thread = SetupThread();
    if (thread)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}

    
HRESULT CorHost::DeleteLogicalThreadState()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    Thread *pThread = GetThread();
    if (!pThread)
        return E_UNEXPECTED;

    pThread->OnThreadTerminate(FALSE);
    return S_OK;
}


HRESULT CorHost::SwitchInLogicalThreadState(DWORD *pFiberCookie)
{
    if (!pFiberCookie)
        return E_POINTER;

    CANNOTTHROWCOMPLUSEXCEPTION();

    // Case Cookie to thread object and add to tls
#ifdef _DEBUG
    LPVOID tls = TlsGetValue(GetThreadTLSIndex());
    _ASSERT(tls == NULL);
#endif

    if (TlsSetValue(GetThreadTLSIndex(), pFiberCookie))
    {
        Thread *pThread = GetThread();
        if (!pThread)
            return E_UNEXPECTED;

        // We redundantly keep the domain in its own TLS slot, for faster access from
        // stubs
         LPVOID pDomain = pThread->GetDomain();

        TlsSetValue(GetAppDomainTLSIndex(), pDomain);

#ifdef _DEBUG
        // Make debugging easier
        ((Thread *) pFiberCookie)->SetThreadId(::GetCurrentThreadId());
#endif
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT CorHost::SwitchOutLogicalThreadState(DWORD **pFiberCookie)
{
    // If the user of this fiber wants to switch it out then we better be in
    // preemptive mode,
     if (!pFiberCookie)
        return E_POINTER;
   
    CANNOTTHROWCOMPLUSEXCEPTION();
    if (!GetThread())
        return E_UNEXPECTED;
    _ASSERTE(!(GetThread()->PreemptiveGCDisabled()));

    // Get tls and cast to dword - set out param
    LPVOID tls = TlsGetValue(GetThreadTLSIndex());
    _ASSERT(tls);

    if (tls == NULL)
        return E_FAIL;

    *pFiberCookie = (DWORD *)tls;
    
    TlsSetValue(GetThreadTLSIndex(),NULL);

    return S_OK;
}

HRESULT CorHost::LocksHeldByLogicalThread(DWORD *pCount)
{
    if (!pCount)
        return E_POINTER;

    CANNOTTHROWCOMPLUSEXCEPTION();
    Thread* pThread = GetThread();
    if (pThread == NULL)
        *pCount = 0;
    else
        *pCount = pThread->m_dwLockCount;
    return S_OK;
}

//*****************************************************************************
// ICorConfiguration
//*****************************************************************************

// *** ICorConfiguration methods ***


HRESULT CorHost::SetGCThreadControl(IGCThreadControl *pGCThreadControl)
{
    if (!pGCThreadControl)
        return E_POINTER;

    CANNOTTHROWCOMPLUSEXCEPTION();
    if (m_CachedGCThreadControl)
        m_CachedGCThreadControl->Release();

    m_CachedGCThreadControl = pGCThreadControl;

    if (m_CachedGCThreadControl)
        m_CachedGCThreadControl->AddRef();

    return S_OK;
}

HRESULT CorHost::SetGCHostControl(IGCHostControl *pGCHostControl)
{
    if (!pGCHostControl)
        return E_POINTER;

    CANNOTTHROWCOMPLUSEXCEPTION();
    if (m_CachedGCHostControl)
        m_CachedGCHostControl->Release();

    m_CachedGCHostControl = pGCHostControl;

    if (m_CachedGCHostControl)
        m_CachedGCHostControl->AddRef();

    return S_OK;
}

HRESULT CorHost::SetDebuggerThreadControl(IDebuggerThreadControl *pDebuggerThreadControl)
{
    if (!pDebuggerThreadControl)
        return E_POINTER;

    CANNOTTHROWCOMPLUSEXCEPTION();

#ifdef DEBUGGING_SUPPORTED
    // Can't change the debugger thread control object once its been set.
    if (m_CachedDebuggerThreadControl != NULL)
        return E_INVALIDARG;

    m_CachedDebuggerThreadControl = pDebuggerThreadControl;

    // If debugging is already initialized then provide this interface pointer to it.
    // It will also addref the new one and release the old one.
    if (g_pDebugInterface)
        g_pDebugInterface->SetIDbgThreadControl(pDebuggerThreadControl);

    if (m_CachedDebuggerThreadControl)
        m_CachedDebuggerThreadControl->AddRef();

    return S_OK;
#else // !DEBUGGING_SUPPORTED
    return E_NOTIMPL;
#endif // !DEBUGGING_SUPPORTED
}


HRESULT CorHost::AddDebuggerSpecialThread(DWORD dwSpecialThreadId)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
#ifdef DEBUGGING_SUPPORTED
    // If it's already in the list, don't add it again.
    if (IsDebuggerSpecialThread(dwSpecialThreadId))
        return (S_OK);

    // Grow the array if necessary.
    if (m_DSTCount >= m_DSTArraySize)
    {
        // There's probably only ever gonna be one or two of these
        // things, so we'll start small.
        DWORD newSize = (m_DSTArraySize == 0) ? 2 : m_DSTArraySize * 2;

        DWORD *newArray = new (nothrow) DWORD[newSize];
        if (!newArray)
            return E_OUTOFMEMORY;

        // If we're growing instead of starting, then copy the old array.
        if (m_DSTArray)
        {
            memcpy(newArray, m_DSTArray, m_DSTArraySize * sizeof(DWORD));
            delete [] m_DSTArray;
        }

        // Update to the new array and size.
        m_DSTArray = newArray;
        m_DSTArraySize = newSize;
    }

    // Save the new thread ID.
    m_DSTArray[m_DSTCount++] = dwSpecialThreadId;

    return (RefreshDebuggerSpecialThreadList());
#else // !DEBUGGING_SUPPORTED
    return E_NOTIMPL;
#endif // !DEBUGGING_SUPPORTED
}
// Helper function to update the thread list in the debugger control block
HRESULT CorHost::RefreshDebuggerSpecialThreadList()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
#ifdef DEBUGGING_SUPPORTED
    HRESULT hr = S_OK;

    if (g_pDebugInterface)
    {
        // Inform the debugger services that this list has changed
        hr = g_pDebugInterface->UpdateSpecialThreadList(
            m_DSTCount, m_DSTArray);

        _ASSERTE(SUCCEEDED(hr));
    }

    return (hr);
#else // !DEBUGGING_SUPPORTED
    return E_NOTIMPL;
#endif // !DEBUGGING_SUPPORTED
}

// Clean up debugger special thread list, called at shutdown
#ifdef SHOULD_WE_CLEANUP
void CorHost::CleanupDebuggerSpecialThreadList()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if (m_DSTArray != NULL)
    {
        delete [] m_DSTArray;
        m_DSTArray = NULL;
        m_DSTArraySize = 0;
    }
}
#endif /* SHOULD_WE_CLEANUP */

// Helper func that returns true if the thread is in the debugger special thread list
BOOL CorHost::IsDebuggerSpecialThread(DWORD dwThreadId)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    for (DWORD i = 0; i < m_DSTCount; i++)
    {
        if (m_DSTArray[i] == dwThreadId)
            return (TRUE);
    }

    return (FALSE);
}


// Clean up any debugger thread control object we may be holding, called at shutdown.
void CorHost::CleanupDebuggerThreadControl()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    
    if (m_CachedDebuggerThreadControl != NULL)
    {
        // Note: we don't release the IDebuggerThreadControl object if we're cleaning up from
        // our DllMain. The DLL that implements the object may already have been unloaded.
        // Leaking the object is okay... the PDM doesn't care.
        if (!g_fProcessDetach)
            m_CachedDebuggerThreadControl->Release();
        
        m_CachedDebuggerThreadControl = NULL;
    }
}

//*****************************************************************************
// IUnknown
//*****************************************************************************

ULONG CorHost::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRef));
}

ULONG CorHost::Release()
{
    ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
    if (!cRef) {
        if (m_pMDConverter)
            delete m_pMDConverter;
        delete this;
    }

    return (cRef);
}

HRESULT CorHost::QueryInterface(REFIID riid, void **ppUnk)
{
    if (!ppUnk)
        return E_POINTER;

    CANNOTTHROWCOMPLUSEXCEPTION();
    *ppUnk = 0;

    // Deliberately do NOT hand out ICorConfiguration.  They must explicitly call
    // GetConfiguration to obtain that interface.
    if (riid == IID_IUnknown)
        *ppUnk = (IUnknown *) (ICorRuntimeHost *) this;
    else if (riid == IID_ICorRuntimeHost)
        *ppUnk = (ICorRuntimeHost *) this;
    else if (riid == IID_ICorThreadpool)
        *ppUnk = (ICorThreadpool *) this;
    else if (riid == IID_IGCHost)
        *ppUnk = (IGCHost *) this;
    else if (riid == IID_IValidator)
        *ppUnk = (IValidator *) this;
    else if (riid == IID_IDebuggerInfo)
        *ppUnk = (IDebuggerInfo *) this;
    else if (riid == IID_IMetaDataConverter) {
        if (NULL == m_pMDConverter) {
            m_pMDConverter = new (nothrow) CMetaDataConverter(this);
            if (!m_pMDConverter)
                return E_OUTOFMEMORY;
        }
        *ppUnk = (IMetaDataConverter *) m_pMDConverter;
    }

    // This is a private request for the ICorDBPrivHelper interface, which
    // we will need to create before we return it.
    else if (riid == IID_ICorDBPrivHelper)
    {
        // GetDBHelper will new the helper class if necessary, and return
        // the pointer.  It will return null if it runs out of memory.
        ICorDBPrivHelperImpl *pHelper = ICorDBPrivHelperImpl::GetDBHelper();

        if (!pHelper)
            return (E_OUTOFMEMORY);

        else
        {
            // GetDBHelper succeeded, so we cast the newly create object to
            // the DBHelper interface and addref it before returning it.
            *ppUnk = (ICorDBPrivHelper *)pHelper;
            pHelper->AddRef();

            // We return here, since this is a special case and we don't want
            // to hit the AddRef call below.
            return (S_OK);
        }
    }

    else
        return (E_NOINTERFACE);
    AddRef();
    return (S_OK);
}


//*****************************************************************************
// Called by the class factory template to create a new instance of this object.
//*****************************************************************************
HRESULT CorHost::CreateObject(REFIID riid, void **ppUnk)
{ 
    CANNOTTHROWCOMPLUSEXCEPTION();
    HRESULT     hr;
    CorHost *pCorHost = new (nothrow) CorHost();
    if (!pCorHost)
        return (E_OUTOFMEMORY);

    // Create the config object if not already done.
    if (!g_pConfig)
    {
        extern CRITICAL_SECTION g_LockStartup;

        // Take the startup lock and check again.
        EnterCriticalSection(&g_LockStartup);

        if (!g_pConfig)
        {
            g_pConfig = new EEConfig();
            if (g_pConfig == NULL)
            {
                delete pCorHost;
                LeaveCriticalSection(&g_LockStartup);
                return (E_OUTOFMEMORY);
            }
        }

        LeaveCriticalSection(&g_LockStartup);
    }

    hr = pCorHost->QueryInterface(riid, ppUnk);
    if (FAILED(hr))
        delete pCorHost;
    return (hr);
}


//-----------------------------------------------------------------------------
// MapFile - Maps a file into the runtime in a non-standard way
//-----------------------------------------------------------------------------
HRESULT CorHost::MapFile(HANDLE hFile, HMODULE* phHandle)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    return CorMap::MapFile(hFile, phHandle);
}

//*****************************************************************************
// ICorDBPrivHelperImpl methods
//*****************************************************************************

// Declare the static member variable that will hold on to the object as long
// as it is being used by someone.
ICorDBPrivHelperImpl *ICorDBPrivHelperImpl::m_pDBHelper = NULL;

///////////////////////////////////////////////////////////////////////////////
// ctor/dtor

ICorDBPrivHelperImpl::ICorDBPrivHelperImpl() : m_refCount(0)
{
}

///////////////////////////////////////////////////////////////////////////////
// IUnknown methods

ULONG STDMETHODCALLTYPE ICorDBPrivHelperImpl::AddRef()
{
    return (InterlockedIncrement((long *) &m_refCount));
}

ULONG STDMETHODCALLTYPE ICorDBPrivHelperImpl::Release()
{
    long refCount = InterlockedDecrement((long *) &m_refCount);

    if (refCount == 0)
    {
        m_pDBHelper = NULL;
        delete this;
    }

    return (refCount);
}

//
// This will only recognise one IID
//
HRESULT STDMETHODCALLTYPE ICorDBPrivHelperImpl::QueryInterface(
    REFIID id, void **pInterface)
{
    if (!pInterface)
        return E_POINTER;

    CANNOTTHROWCOMPLUSEXCEPTION();
    if (id == IID_ICorDBPrivHelper)
        *pInterface = (ICorDBPrivHelper *)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown *)(ICorDBPrivHelper *)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return (S_OK);
}

///////////////////////////////////////////////////////////////////////////////
// ICorDBPrivHelper methods

HRESULT STDMETHODCALLTYPE ICorDBPrivHelperImpl::CreateManagedObject(
    /*in*/  WCHAR *wszAssemblyName,
    /*in*/  WCHAR *wszModuleName,
    /*in*/  mdTypeDef classToken,
    /*in*/  void *rawData,
    /*out*/ IUnknown **ppUnk)
{
    _ASSERTE(TypeFromToken((mdTypeDef)classToken) == mdtTypeDef);
    _ASSERTE(wszAssemblyName && wszModuleName && ppUnk);

    if (!wszAssemblyName || !wszModuleName || classToken == mdTokenNil) 
        return E_INVALIDARG;

    if (!ppUnk) 
        return E_POINTER;

    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    // This will set up a managed thread object if one does not already exist
    // for this particular thread.
    Thread* pThread = SetupThread();

    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    // Start up COM Interop
    if (FAILED(hr = QuickCOMStartup()))
        goto Exit;

    {
    // Don't want to be interrupted...
    BOOL fWasGCEnabled = !pThread->PreemptiveGCDisabled();

    if (fWasGCEnabled)
        pThread->DisablePreemptiveGC();
    
    Assembly  *pAssembly;
    Module    *pModule;
     
    if (GetAppDomain() == NULL)
        hr = E_INVALIDARG;
    else
    {
        // Try and load the assembly, given the name provided.
        OBJECTREF pThrowable = NULL;
        GCPROTECT_BEGIN(pThrowable);

        hr = AssemblySpec::LoadAssembly(wszAssemblyName, &pAssembly, &pThrowable);

        GCPROTECT_END();

        if (SUCCEEDED(hr))
        {
            _ASSERTE(pAssembly);

            // Try and load the module, given the name provided.
            hr = pAssembly->GetModuleFromFilename(wszModuleName, &pModule);

            if (SUCCEEDED(hr))
            {
                _ASSERTE(pModule);

                // If the class isn't known,then don't try and create it.
                if (!pModule->GetMDImport()->IsValidToken(classToken))
                    hr = E_INVALIDARG;
                else
                {                    
                    COMPLUS_TRY
                    {
                        OBJECTREF obj = NULL;
                        GCPROTECT_BEGIN(obj);

                        // Now try and get the TypeHandle for the given token
                        NameHandle nameHandle(pModule, classToken);
                        TypeHandle typeHandle =
                            pAssembly->LoadTypeHandle(&nameHandle, &obj);

                        // If an exception was thrown at some point, convert
                        // it to an HRESULT
                        if (obj != NULL)
                            hr = SecurityHelper::MapToHR(obj);

                        // No longer need the object, can be GC'd if desired
                        obj = NULL;

                        if (SUCCEEDED(hr))
                        {
                            _ASSERTE(typeHandle.AsMethodTable());
                            MethodTable *pMT = typeHandle.AsMethodTable();
        
                            if (!pMT->GetClass()->IsValueClass() ||
                                pMT->ContainsPointers())
                                hr = CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS;

                            if (SUCCEEDED(hr))
                            {
                                // Now run the class initialiser
                                if (!pMT->CheckRunClassInit(&obj))
                                    hr = SecurityHelper::MapToHR(obj);

                                // No longer need the object, can be GC'd if
                                // desired
                                obj = NULL;

                                if (SUCCEEDED(hr))
                                {
                                    // If successful, allocate an instance of
                                    // the class
                                    
                                    // This may throw an
                                    // OutOfMemoryException, but the below
                                    // COMPLUS_CATCH should handle it.  If
                                    // the class is a ValueClass, the
                                    // created object will be a boxed
                                    // ValueClass.
                                    obj = AllocateObject(pMT);

                                    // Now create a COM wrapper around
                                    // this object.  Note that this can
                                    // also throw.
                                    *ppUnk = GetComIPFromObjectRef(&obj,
                                                                   ComIpType_Unknown,
                                                                   NULL);
                                    _ASSERTE(ppUnk);

                                    // This is the nasty part. We're gonna
                                    // copy the raw data we're given over
                                    // the new instance of the value
                                    // class...
                                    CopyValueClass(obj->UnBox(), rawData, pMT, obj->GetAppDomain());

                                    // No longer need the object, can be GC'd
                                    // if desired
                                    obj = NULL;
                                }
                            }
                        }

                        GCPROTECT_END();  // obj
                    }
                    COMPLUS_CATCH
                    {
                        // If there's an exception, convert it to an HR
                        hr = SecurityHelper::MapToHR(GETTHROWABLE());
                    }
                    COMPLUS_END_CATCH
                }
            }
        }
    }
    
    if (fWasGCEnabled)
        pThread->EnablePreemptiveGC();

    }
Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return (hr);
}

HRESULT STDMETHODCALLTYPE ICorDBPrivHelperImpl::GetManagedObjectContents(
        /* in */ IUnknown *pObject,
        /* in */ void *rawData,
        /* in */ ULONG32 dataSize)
{

    if (!pObject || !rawData)
        return E_POINTER;

    if (dataSize == 0)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    // This will set up a managed thread object if one does not already exist
    // for this particular thread.
    Thread* pThread = SetupThread();

    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    {
    // Don't want to be interrupted...
    BOOL fWasGCEnabled = !pThread->PreemptiveGCDisabled();

    if (fWasGCEnabled)
        pThread->DisablePreemptiveGC();
    
    OBJECTREF obj = NULL;
    GCPROTECT_BEGIN(obj);

    COMPLUS_TRY
    {
        // Get the Object out of the IUnknown.
        obj = GetObjectRefFromComIP(pObject, NULL);
        
        MethodTable *pMT = obj->GetMethodTable();
    
        if (!pMT->GetClass()->IsValueClass() ||
            pMT->ContainsPointers() ||
            (pMT->GetClass()->GetNumInstanceFieldBytes() != dataSize))
            hr = CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS;

        // This is the nasty part. We're gonna copy the raw data out
        // of the object and pass it out.
        if (SUCCEEDED(hr))
        {
            memcpy(rawData, obj->UnBox(), dataSize);
        }
    }
    COMPLUS_CATCH
    {
        // If there's an exception, convert it to an HR
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    }
    COMPLUS_END_CATCH

    obj = NULL;
    GCPROTECT_END();  // obj
    
    if (fWasGCEnabled)
        pThread->EnablePreemptiveGC();

    }
Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return (hr);
}

///////////////////////////////////////////////////////////////////////////////
// Helper methods

ICorDBPrivHelperImpl *ICorDBPrivHelperImpl::GetDBHelper()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if (!m_pDBHelper)
        m_pDBHelper = new (nothrow) ICorDBPrivHelperImpl();

    return m_pDBHelper;
}

///////////////////////////////////////////////////////////////////////////////
// IDebuggerInfo::IsDebuggerAttached
HRESULT CorHost::IsDebuggerAttached(BOOL *pbAttached)
{
    if (pbAttached == NULL)
        return E_INVALIDARG;

    *pbAttached = (CORDebuggerAttached() != 0);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cormap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorMap.cpp
//
// Implementation for mapping in files without using system services
//
//*****************************************************************************
#include "common.h"
#include "CorMap.hpp"
#include "eeconfig.h"
#include "zapmonitor.h"
#include "safegetfilesize.h"
#include "strongname.h"

DWORD                   CorMap::m_spinLock = 0;
BOOL                    CorMap::m_fInitialized = FALSE;
CRITICAL_SECTION        CorMap::m_pCorMapCrst;
#ifdef _DEBUG
DWORD                   CorMap::m_fInsideMapLock = 0;
#endif

DWORD                   CorMap::m_dwIndex = 0;
DWORD                   CorMap::m_dwSize = 0;
EEUnicodeStringHashTable*  CorMap::m_pOpenFiles = NULL;

#define BLOCK_SIZE 20
#define BLOCK_NUMBER 20


/*********************************************************************************/
// Unfortunately LoadLibrary has heuristics where it slaps a 'dll' on files without
// an extension.  To avoid such issues, we will only allow file names that have
// exensions.   Because win9x LoadLibrary defines the 'fileName' as the part beyond 
// the last '/' or '\', we use that as our definition.  This could cause some paths
// (like fo.o/bar to be rejected, but this is no great loss.  The important part is
// that any file with a extension will work properly 

BOOL CorMap::ValidDllPath(LPCWSTR pPath) 
{
    BOOL ret = FALSE;

    LPCWSTR ptr = &pPath[wcslen(pPath)];        // start at the end of the string
    while(ptr > pPath) {
        --ptr;
        if (*ptr == '.')
            return TRUE;
        if (*ptr == '\\' || *ptr == '/')
            return FALSE;
    }
    return FALSE;
}

HRESULT STDMETHODCALLTYPE RuntimeOpenImage(LPCWSTR pszFileName, HCORMODULE* hHandle)
{
    HRESULT hr;
    IfFailRet(CorMap::Attach());
    return CorMap::OpenFile(pszFileName, CorLoadOSMap, hHandle);
}

HRESULT STDMETHODCALLTYPE RuntimeOpenImageInternal(LPCWSTR pszFileName, HCORMODULE* hHandle, DWORD *pdwLength)
{
    HRESULT hr;
    IfFailRet(CorMap::Attach());
    return CorMap::OpenFile(pszFileName, CorLoadOSMap, hHandle, pdwLength);
}

HRESULT STDMETHODCALLTYPE RuntimeReleaseHandle(HCORMODULE hHandle)
{
    HRESULT hr;
    IfFailRet(CorMap::Attach());
    return CorMap::ReleaseHandle(hHandle);
}

HRESULT STDMETHODCALLTYPE RuntimeReadHeaders(PBYTE hAddress, IMAGE_DOS_HEADER** ppDos,
                                             IMAGE_NT_HEADERS** ppNT, IMAGE_COR20_HEADER** ppCor,
                                             BOOL fDataMap, DWORD dwLength)
{
    HRESULT hr;
    IfFailRet(CorMap::Attach());
    return CorMap::ReadHeaders(hAddress, ppDos, ppNT, ppCor, fDataMap, dwLength);
}

CorLoadFlags STDMETHODCALLTYPE RuntimeImageType(HCORMODULE hHandle)
{
    if(FAILED(CorMap::Attach()))
       return CorLoadUndefinedMap;
       
    return CorMap::ImageType(hHandle);
}

HRESULT STDMETHODCALLTYPE RuntimeOSHandle(HCORMODULE hHandle, HMODULE* hModule)
{
    HRESULT hr;
    IfFailRet(CorMap::Attach());
    return CorMap::BaseAddress(hHandle, hModule);
}

HRESULT RuntimeGetAssemblyStrongNameHash(PBYTE pbBase,
                                         LPWSTR szwFileName,
                                         BOOL fFileMap,
                                         BYTE *pbHash,
                                         DWORD *pcbHash)
{
    HRESULT hr;

    IfFailGo(CorMap::Attach());

    // First we need to get the COR20 header stuff to see if this module has a strong name signature.
    IMAGE_DOS_HEADER   *pDOS       = NULL;
    IMAGE_NT_HEADERS   *pNT        = NULL;
    IMAGE_COR20_HEADER *pCorHeader = NULL;
    IfFailGo(CorMap::ReadHeaders(pbBase, &pDOS, &pNT, &pCorHeader, fFileMap, 0));

    // If there is a strong name signature, we need to use it
    PBYTE               pbSNSig    = NULL;
    ULONG               cbSNSig    = 0;
    if (SUCCEEDED(hr = CorMap::GetStrongNameSignature(pbBase, pNT, pCorHeader, fFileMap, pbHash, pcbHash)))
        return hr;

ErrExit:
    return (hr);
}

HRESULT RuntimeGetAssemblyStrongNameHashForModule(HCORMODULE   hModule,
                                                  BYTE        *pbSNHash,
                                                  DWORD       *pcbSNHash)
{
    HRESULT hr;

    IfFailGo(CorMap::Attach());

    WCHAR szwFileName[_MAX_PATH+1];
    DWORD cchFileName;
    CorMap::GetFileName(hModule, &szwFileName[0], _MAX_PATH, &cchFileName);

    // Get the base address of the module
    PBYTE pbBase;
    IfFailGo(CorMap::BaseAddress(hModule, (HMODULE *) &pbBase));

    // Now try and get the actual strong name hash
    CorLoadFlags clf = CorMap::ImageType(hModule);
    BOOL fFileMap = clf == CorLoadDataMap ||
                    clf == CorLoadOSMap;

    IfFailGo(RuntimeGetAssemblyStrongNameHash(pbBase, szwFileName, fFileMap, pbSNHash, pcbSNHash));

ErrExit:
    return hr;
}


EXTERN_C PIMAGE_SECTION_HEADER Cor_RtlImageRvaToSection(PIMAGE_NT_HEADERS NtHeaders,
                                                        ULONG Rva,
                                                        ULONG FileLength)
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (FileLength &&
            ((NtSection->PointerToRawData > FileLength)) ||
            (NtSection->SizeOfRawData > FileLength - NtSection->PointerToRawData))
            return NULL;
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData)
            return NtSection;
        
        ++NtSection;
    }

    return NULL;
}

EXTERN_C PIMAGE_SECTION_HEADER Cor_RtlImageRvaRangeToSection(PIMAGE_NT_HEADERS NtHeaders,
                                                             ULONG Rva, ULONG Range,
                                                             ULONG FileLength)
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    if (!Range)
        return Cor_RtlImageRvaToSection(NtHeaders, Rva, FileLength);

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {
        if (FileLength &&
            ((NtSection->PointerToRawData > FileLength) ||
             (NtSection->SizeOfRawData > FileLength - NtSection->PointerToRawData)))
            return NULL;
        if (Rva >= NtSection->VirtualAddress &&
            Rva + Range <= NtSection->VirtualAddress + NtSection->SizeOfRawData)
            return NtSection;
        
        ++NtSection;
    }

    return NULL;
}

EXTERN_C DWORD Cor_RtlImageRvaToOffset(PIMAGE_NT_HEADERS NtHeaders,
                                       ULONG Rva,
                                       ULONG FileLength)
{
    PIMAGE_SECTION_HEADER NtSection = Cor_RtlImageRvaToSection(NtHeaders,
                                                               Rva,
                                                               FileLength);

    if (NtSection)
        return ((Rva - NtSection->VirtualAddress) +
                NtSection->PointerToRawData);
    else
        return NULL;
}

EXTERN_C PBYTE Cor_RtlImageRvaToVa(PIMAGE_NT_HEADERS NtHeaders,
                                   PBYTE Base,
                                   ULONG Rva,
                                   ULONG FileLength)
{
    PIMAGE_SECTION_HEADER NtSection = Cor_RtlImageRvaToSection(NtHeaders,
                                                               Rva,
                                                               FileLength);

    if (NtSection)
        return (Base +
                (Rva - NtSection->VirtualAddress) +
                NtSection->PointerToRawData);
    else
        return NULL;
}


HRESULT CorMap::Attach()
{
    EnterSpinLock ();
    if(m_fInitialized == FALSE) {
        InitializeCriticalSection(&m_pCorMapCrst);
        m_fInitialized = TRUE;
    }
    LeaveSpinLock();
    return S_OK;
}

#ifdef SHOULD_WE_CLEANUP
// NOT thread safe.
void CorMap::Detach()
{
    if(m_pOpenFiles) {
        delete m_pOpenFiles;
        m_pOpenFiles = NULL;
    }

    EnterSpinLock ();
    if(m_fInitialized) {
        DeleteCriticalSection(&m_pCorMapCrst);
        m_fInitialized = FALSE;
    }
    LeaveSpinLock();
}
#endif /* SHOULD_WE_CLEANUP */


DWORD CorMap::CalculateCorMapInfoSize(DWORD dwFileName)
{
    // Align the value with the size of the architecture
    DWORD cbInfo = (dwFileName + 1) * sizeof(WCHAR) + sizeof(CorMapInfo);
    DWORD algn = MAX_NATURAL_ALIGNMENT - 1;
    cbInfo = (cbInfo + algn) & ~algn;
    return cbInfo;
}

HRESULT CorMap::LoadImage(HANDLE hFile, 
                          CorLoadFlags flags, 
                          PBYTE *hMapAddress, 
                          LPCWSTR pFileName, 
                          DWORD dwFileName)
{
    HRESULT hr = S_OK;
    if(flags == CorLoadOSImage) {
        DWORD cbInfo = CalculateCorMapInfoSize(dwFileName);
        PBYTE pMapInfo = SetImageName((PBYTE) NULL,
                                      cbInfo,
                                      pFileName, dwFileName,
                                      flags,
                                      0,
                                      hFile);
        if (!pMapInfo)
            hr = E_OUTOFMEMORY;
        else if(hMapAddress)
            *hMapAddress = pMapInfo;
    }
    else if(flags == CorLoadImageMap) {
        if(MapImageAsData(hFile, CorLoadDataMap, hMapAddress, pFileName, dwFileName))
            hr = LayoutImage(*hMapAddress, *hMapAddress);
        else {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr))
                hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        }
    }
    else {
        if(!MapImageAsData(hFile, flags, hMapAddress, pFileName, dwFileName)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr))
                hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        }
    }
    return hr;
}


PBYTE CorMap::SetImageName(PBYTE hMemory, 
                           DWORD cbInfo, 
                           LPCWSTR pFileName, 
                           DWORD dwFileName, 
                           CorLoadFlags flags, 
                           DWORD dwFileSize,
                           HANDLE hFile)
{
    PBYTE pFile;
    PBYTE hAddress;
    if(flags == CorLoadOSMap || flags == CorLoadOSImage) {
        hAddress = new (nothrow) BYTE[cbInfo+1];
        if (!hAddress)
            return NULL;

        ZeroMemory(hAddress, cbInfo);
        GetMapInfo((HCORMODULE)(hAddress+cbInfo))->hFileToHold=INVALID_HANDLE_VALUE;
    }
    else
        hAddress = hMemory;

    pFile = hAddress + cbInfo;

    // Copy in the name and include the null terminator
    if(dwFileName) {
        WCHAR* p2 = (WCHAR*) hAddress;
        WCHAR* p1 = (WCHAR*) pFileName;
        while(*p1) {
            *p2++ = towlower(*p1++);
        }
        *p2 = '\0';
    }
    else
        *((char*)hAddress) = '\0';
    
    // Set the pointer to the file name
    CorMapInfo* ptr = GetMapInfo((HCORMODULE) pFile);
    ptr->pFileName = (LPWSTR) hAddress;
    ptr->SetCorLoadFlags(flags);
    ptr->dwRawSize = dwFileSize;
    if(!ptr->HoldFile(hFile))
        return NULL;

    if(flags == CorLoadOSMap || flags == CorLoadOSImage)
        ptr->hOSHandle = (HMODULE) hMemory;

    return pFile;
}

BOOL CorMap::MapImageAsData(HANDLE hFile, CorLoadFlags flags, PBYTE *hMapAddress, LPCWSTR pFileName, DWORD dwFileName)
{

    PBYTE hAddress = NULL;
    BOOL fResult = FALSE;
    HANDLE hMapFile = NULL;
    PVOID pBaseAddress = 0;
    DWORD dwAccessMode = 0;

    // String size + null terminator + a pointer to the string
    DWORD cbInfo = CalculateCorMapInfoSize(dwFileName);
    DWORD dwFileSize = SafeGetFileSize(hFile, 0);
    if (dwFileSize == 0xffffffff)
        return FALSE;

    if(flags == CorLoadOSMap) {

        hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if(hMapFile == NULL)
            return FALSE;
        dwAccessMode = FILE_MAP_READ;
    }
    else if(flags == CorLoadDataMap) {
        IMAGE_DOS_HEADER dosHeader;
        IMAGE_NT_HEADERS ntHeader;
        DWORD cbRead = 0;
        DWORD cb = 0;

        if((dwFileSize >= sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS)) &&
           ReadFile(hFile, &dosHeader, sizeof(dosHeader), &cbRead, NULL) &&
           (cbRead == sizeof(dosHeader)) &&
           (dosHeader.e_magic == IMAGE_DOS_SIGNATURE) &&
           (dosHeader.e_lfanew != 0) &&
           (dwFileSize - sizeof(IMAGE_NT_HEADERS) >= (DWORD) dosHeader.e_lfanew) &&
           (SetFilePointer(hFile, dosHeader.e_lfanew, NULL, FILE_BEGIN) != 0xffffffff) &&
           (ReadFile(hFile, &ntHeader, sizeof(ntHeader), &cbRead, NULL)) &&
           (cbRead == sizeof(ntHeader)) &&
           (ntHeader.Signature == IMAGE_NT_SIGNATURE) &&
           (ntHeader.FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_NT_OPTIONAL_HEADER) &&
           (ntHeader.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC))
        {
            cb = ntHeader.OptionalHeader.SizeOfImage + cbInfo;

            // create our swap space in the system swap file
            hMapFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, cb, NULL);
            
            if (!hMapFile)
                return FALSE;

            // Align cbInfo to page size so we don't screw up alignment of regular part of image
            cbInfo = (cbInfo + (OS_PAGE_SIZE-1)) & ~(OS_PAGE_SIZE-1);
            pBaseAddress = (PVOID)((size_t)ntHeader.OptionalHeader.ImageBase - cbInfo);
            dwAccessMode = FILE_MAP_WRITE;
        }
    }

        
    /* Try to map the image at the preferred base address */
    hAddress = (PBYTE) MapViewOfFileEx(hMapFile, dwAccessMode, 0, 0, 0, pBaseAddress);
    if (!hAddress)
    {
        //That didn't work; maybe the preferred address was taken. Try to
        //map it at any address.
        hAddress = (PBYTE) MapViewOfFile(hMapFile, dwAccessMode, 0, 0, 0);
    }
    
    if (!hAddress)
        goto exit;
    
    // Move the pointer up to the place we will be loading
    hAddress = SetImageName(hAddress, 
                            cbInfo, 
                            pFileName, dwFileName, 
                            flags, 
                            dwFileSize,
                            hFile);
    if (hAddress) {
        if (flags == CorLoadDataMap) {
            DWORD cbRead = 0;
            // When we map to an arbitrary location we need to read in the contents
            if((SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff) ||
               (!ReadFile(hFile, hAddress, dwFileSize, &cbRead, NULL)) ||
               (cbRead != dwFileSize))
                goto exit;
        }

        if(hMapAddress)
            *hMapAddress = hAddress;
    
        fResult = TRUE;
    }
    else
        SetLastError(ERROR_OUTOFMEMORY);

 exit:
    if (hMapFile)
        CloseHandle(hMapFile);
    return fResult;
}

HRESULT CorMap::MemoryMapImage(HCORMODULE hAddress, HCORMODULE* pResult)
{
    HRESULT hr = S_OK;
    BEGIN_ENSURE_PREEMPTIVE_GC();
    Enter();
    END_ENSURE_PREEMPTIVE_GC();
    *pResult = NULL;
    CorMapInfo* ptr = GetMapInfo(hAddress);
    DWORD refs = ptr->References();

    LOG((LF_CLASSLOADER, LL_INFO10, "Remapping file: \"%ws\", %0x, %d (references)\n", ptr->pFileName, ptr, ptr->References()));

    if(refs == -1) 
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACCESS);
    else if(refs > 1) {
        // If we have more then one ref we need to create a new one.
        CorMapInfo* pCurrent;
        hr = FindFileName(ptr->pFileName, &pCurrent);
        if(FAILED(hr)) {
            // if we are no longer in the table then we will assume we where the one in the table;
            pCurrent = ptr;
            pCurrent->AddRef();
            hr = S_OK;
        }

        switch(ptr->Flags()) {
        case CorLoadOSMap:
        case CorLoadDataMap:
            if(pCurrent == ptr) {
                pCurrent->Release(); //don't need it anymore
                LOG((LF_CLASSLOADER, LL_INFO10, "I am the current mapping: \"%ws\", %0x, %d (references)\n", ptr->pFileName, ptr, ptr->References()));
                // Manually remove the entry and replace it with a new entry. Mark the 
                // old entry as KeepInTable so it does not remove itself from the
                // name hash table during deletion.
                RemoveMapHandle(ptr); // This never returns an error.

                DWORD length = GetFileNameLength(ptr);
                hr = OpenFileInternal(ptr->pFileName, length, 
                                      (ptr->Flags() == CorLoadDataMap) ? CorLoadImageMap : CorLoadOSImage,
                                      pResult);
                if (SUCCEEDED(hr))
                {
                    ptr->SetKeepInTable();
                    ptr->HoldFile(INVALID_HANDLE_VALUE); // lock transferred to pResult
                    ptr->Release();  // we were supposed to take ownership of ptr but we're not going to use it
                }
                else {
                    // Other threads may be trying to load this same file -
                    // put it back in the table on failure
                    _ASSERTE(ptr->References() > 1);
                    EEStringData str(length, ptr->pFileName);
                    m_pOpenFiles->InsertValue(&str, (HashDatum) ptr, FALSE);
                }
            }
            else {
                LOG((LF_CLASSLOADER, LL_INFO10, "I am NOT the current mapping: \"%ws\", %0x, %d (references)\n", ptr->pFileName, ptr, ptr->References()));
                ReleaseHandle(hAddress);
                *pResult = GetCorModule(pCurrent);
            }
            break;

        case CorReLoadOSMap:  // For Win9X
            pCurrent->Release();
            *pResult = hAddress;
            break;

        default:
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }

    }
    else {
        // if we only have one ref then we should never be reloading it
        _ASSERTE(ptr->Flags() != CorReLoadOSMap);

        // Check to see if we are the only reference or the last of a 
        // series of references. If we are still in the list then we
        // are the only reference
        //
        // This needs to be changed to be the same as when there are multiple references (see above)
        if (*ptr->pFileName == 0) { // byte array images have no name 
            if(SUCCEEDED(hr = LayoutImage((PBYTE) hAddress, (PBYTE) hAddress)))
                *pResult = hAddress;
        }
        else {
            CorMapInfo* pCurrent;
            IfFailGo(FindFileName(ptr->pFileName, &pCurrent));
            if(pCurrent == ptr) {
                if(SUCCEEDED(hr = LayoutImage((PBYTE) hAddress, (PBYTE) hAddress))) {
                    _ASSERTE(ptr->References() == 2);
                    *pResult = hAddress;
                }
                pCurrent->Release();
            }
            else {
                ReleaseHandle(hAddress);
                *pResult = GetCorModule(pCurrent);
            }
        }
    }
 ErrExit:
    Leave();
    return hr;
}

HRESULT CorMap::LayoutImage(PBYTE hAddress,    // Destination of mapping
                            PBYTE pSource)     // Source, different the pSource for InMemory images
{
    HRESULT hr = S_OK;
    CorMapInfo* ptr = GetMapInfo((HCORMODULE) hAddress);
    CorLoadFlags flags = ptr->Flags();

    if(flags == CorLoadOSMap) {
        // Release the OS resources except for the CorMapInfo memeory
        /*hr = */ReleaseHandleResources(ptr, FALSE);
 
       // We lazily load the OS handle
        ptr->hOSHandle = NULL;
        ptr->SetCorLoadFlags(CorLoadOSImage);
        hr = S_FALSE;
    }
    else if(flags == CorLoadDataMap) {
            
        // If we've done our job right, hAddress should be page aligned.
        _ASSERTE(((SIZE_T)hAddress & (OS_PAGE_SIZE-1)) == 0);

        // We can only layout images data images and only ones that
        // are not backed by the file.

        IMAGE_DOS_HEADER* dosHeader;
        IMAGE_NT_HEADERS* ntHeader;
        IMAGE_COR20_HEADER* pCor;
        IMAGE_SECTION_HEADER* rgsh;
        
        IfFailRet(ReadHeaders((PBYTE) pSource, &dosHeader, &ntHeader, &pCor, TRUE, ptr->dwRawSize));

        rgsh = (IMAGE_SECTION_HEADER*) (pSource + dosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS));

        if((PBYTE) hAddress != pSource) {
            DWORD cb = dosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) +
                sizeof(IMAGE_SECTION_HEADER)*ntHeader->FileHeader.NumberOfSections;
            memcpy((void*) hAddress, pSource, cb);

            // Write protect the headers
            DWORD oldProtection;
            if (!VirtualProtect((void *) hAddress, cb, PAGE_READONLY, &oldProtection))
                return HRESULT_FROM_WIN32(GetLastError());
        }

        // now let's loop for each loadable sections
        for (int i = ntHeader->FileHeader.NumberOfSections - 1; i >= 0; i--)
        {
            size_t loff, cbVirt, cbPhys;
            size_t dwAddr;
            
            loff   = rgsh[i].PointerToRawData + (size_t) pSource;
            cbVirt = rgsh[i].Misc.VirtualSize;
            cbPhys = min(rgsh[i].SizeOfRawData, cbVirt);
            dwAddr = (size_t) rgsh[i].VirtualAddress + (size_t) hAddress;
            
            size_t dataExtent = loff+rgsh[i].SizeOfRawData;
            if(dwAddr >= loff && dwAddr - loff <= cbPhys) {
                // Overlapped copy
                MoveMemory((void*) dwAddr, (void*) loff, cbPhys);
            }
            else {
                // Separate copy
                memcpy((void*) dwAddr, (void*) loff, cbPhys);
            }

            if ((rgsh[i].Characteristics & IMAGE_SCN_MEM_WRITE) == 0) {
                // Write protect the section
                DWORD oldProtection;
                if (!VirtualProtect((void *) dwAddr, cbVirt, PAGE_READONLY, &oldProtection))
                    return HRESULT_FROM_WIN32(GetLastError());
            }
        }

        // Now manually apply base relocs if necessary
        hr = ApplyBaseRelocs(hAddress, ntHeader, ptr);

        ptr->SetCorLoadFlags(CorLoadImageMap);
    }
    return hr;
}

BOOL CorMap::LoadMemoryImageW9x(PBYTE pUnmappedPE, DWORD dwUnmappedPE, LPCWSTR pImageName, DWORD dwImageName, HCORMODULE* hMapAddress)
{    
    IMAGE_DOS_HEADER* dosHeader;
    IMAGE_NT_HEADERS* ntHeader;

    PBYTE hAddress;
    UINT_PTR pOffset;
    HANDLE hMapFile = NULL;

    // String size + null terminator + a pointer to the string
    DWORD cbInfo = CalculateCorMapInfoSize(dwImageName);
    // Align cbInfo to page size so we don't screw up alignment of regular part of image
    cbInfo = (cbInfo + (OS_PAGE_SIZE-1)) & ~(OS_PAGE_SIZE-1);

    dosHeader = (IMAGE_DOS_HEADER*) pUnmappedPE;
    
    if(pUnmappedPE &&
       (dwUnmappedPE >= sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS)) &&
       (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) &&
       (dwUnmappedPE - sizeof(IMAGE_NT_HEADERS) >= (DWORD) dosHeader->e_lfanew)) {
        
        pOffset = (UINT_PTR) dosHeader->e_lfanew + (UINT_PTR) pUnmappedPE;

        ntHeader = (IMAGE_NT_HEADERS*) pOffset;
        if((dwUnmappedPE >= (DWORD) (pOffset - (UINT_PTR) dosHeader) + sizeof(IMAGE_NT_HEADERS)) &&
           (ntHeader->Signature == IMAGE_NT_SIGNATURE) &&
           (ntHeader->FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_NT_OPTIONAL_HEADER) &&
           (ntHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC)) 
        {
            DWORD destSize = ntHeader->OptionalHeader.SizeOfImage;

            // We can't trust SizeOfImage yet, so make sure we allocate at least enough space
            // for the raw image
            if (dwUnmappedPE > destSize)
                destSize = dwUnmappedPE;

            DWORD cb = destSize + cbInfo;
                
            //!!!!! M9 HACK: Remove once compilers support manifests and lm is not used
            //!!!!! to place manifests at the tail end of the image
            //!!!!! 
                
            // create our swap space in the system swap file
            hMapFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, cb, NULL);
            if (!hMapFile)
                return FALSE;
                
            /* Try to map the image at the preferred base address */
            hAddress = (PBYTE) MapViewOfFileEx(hMapFile, FILE_MAP_WRITE, 0, 0, cb, 
                                               (PVOID)((size_t)ntHeader->OptionalHeader.ImageBase - cbInfo));
            if (!hAddress)
            {
                //That didn't work; maybe the preferred address was taken. Try to
                //map it at any address.
                hAddress = (PBYTE) MapViewOfFileEx(hMapFile, FILE_MAP_WRITE, 0, 0, cb, (PVOID)NULL);
            }
                
            if (!hAddress)
                goto exit;
                
            hAddress = SetImageName(hAddress, 
                                    cbInfo,
                                    pImageName, dwImageName,
                                    CorLoadDataMap, dwUnmappedPE,
                                    INVALID_HANDLE_VALUE);
            if (!hAddress)
                SetLastError(ERROR_OUTOFMEMORY);
            else {
                memcpyNoGCRefs(hAddress, pUnmappedPE, dwUnmappedPE);
                if(hMapAddress)
                    *hMapAddress = (HCORMODULE) hAddress;
                CloseHandle(hMapFile);
                return TRUE;
            }
        }
    }

 exit:
    if (hMapFile)
        CloseHandle(hMapFile);
    return FALSE;

}

HRESULT CorMap::OpenFile(LPCWSTR szPath, CorLoadFlags flags, HCORMODULE *ppHandle, DWORD *pdwLength)
{
    if(szPath == NULL || ppHandle == NULL)
        return E_POINTER;

    HRESULT hr;
    WCHAR pPath[_MAX_PATH];
    DWORD size = sizeof(pPath) / sizeof(WCHAR);

    hr = BuildFileName(szPath, (LPWSTR) pPath, &size);
    IfFailRet(hr);

    BEGIN_ENSURE_PREEMPTIVE_GC();
    Enter();
    END_ENSURE_PREEMPTIVE_GC();

    hr = OpenFileInternal(pPath, size, flags, ppHandle, pdwLength);
    Leave();
    return hr;
}

HRESULT CorMap::OpenFileInternal(LPCWSTR pPath, DWORD size, CorLoadFlags flags, HCORMODULE *ppHandle, DWORD *pdwLength)
{
    HRESULT hr;
    CorMapInfo* pResult = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    Thread *thread = GetThread();
    BOOL    toggleGC = (thread && thread->PreemptiveGCDisabled());

    LOG((LF_CLASSLOADER, LL_INFO10, "Open Internal: \"%ws\", flags = %d\n", pPath, flags));
    
    if (toggleGC)
        thread->EnablePreemptiveGC();

    IfFailGo(InitializeTable());

    if(flags == CorReLoadOSMap) {
        hr = E_FAIL;
        flags = CorLoadImageMap;
    }
    else {
        hr = FindFileName((LPCWSTR) pPath, &pResult);
#ifdef _DEBUG
        if(pResult == NULL)
            LOG((LF_CLASSLOADER, LL_INFO10, "Did not find a preloaded info, hr = %x\n", hr));
        else
            LOG((LF_CLASSLOADER, LL_INFO10, "Found mapinfo: \"%ws\", hr = %x\n", pResult->pFileName,hr));
#endif
    }

    if(FAILED(hr) || pResult == NULL) {
            // It is absolutely necessary that CreateFile and LoadLibrary to load the same file.
            // Make certain it is a name that LoadLibrary will not munge.
        hFile = WszCreateFile((LPCWSTR) pPath,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            hr = HRESULT_FROM_WIN32(GetLastError());
        else {
            // Start up the image, this will store off the handle so we do not have
            // to close it unless there was an error.
            HCORMODULE mappedData;
            hr = LoadImage(hFile, flags, (PBYTE*) &mappedData, (LPCWSTR) pPath, size);
            
            if(SUCCEEDED(hr)) {
                pResult = GetMapInfo(mappedData);
                hr = AddFile(pResult);
                //_ASSERTE(hr != S_FALSE);
            }
        }
    }
    else {
        CorLoadFlags image = pResult->Flags();
        if(image == CorLoadImageMap || image == CorLoadOSImage)
            hr = S_FALSE;
    }

    if(SUCCEEDED(hr) && pResult) {
        *ppHandle = GetCorModule(pResult);
        if (pdwLength)
            *pdwLength = pResult->dwRawSize;
    }

 ErrExit:

    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (toggleGC)
        thread->DisablePreemptiveGC();

    return hr;
}

HRESULT CorMap::VerifyDirectory(IMAGE_NT_HEADERS* pNT, IMAGE_DATA_DIRECTORY *dir, DWORD dwForbiddenCharacteristics) 
{
    // Under CE, we have no NT header.
    if (pNT == NULL)
        return S_OK;

    int section_num = 1;
    int max_section = pNT->FileHeader.NumberOfSections;

    // @TODO: need to use 64 bit version??
    IMAGE_SECTION_HEADER* pCurrSection = IMAGE_FIRST_SECTION(pNT);
    IMAGE_SECTION_HEADER* prevSection = NULL;

    if (dir->VirtualAddress == 0 && dir->Size == 0)
        return S_OK;

    // find which section the (input) RVA belongs to
    while (dir->VirtualAddress >= pCurrSection->VirtualAddress 
           && section_num <= max_section)
    {
        section_num++;
        prevSection = pCurrSection;
        pCurrSection++;
    }

    // check if (input) size fits within section size
    if (prevSection)     
    {
        if (dir->VirtualAddress <= prevSection->VirtualAddress + prevSection->Misc.VirtualSize)
        {
            if ((dir->VirtualAddress
                <= prevSection->VirtualAddress + prevSection->Misc.VirtualSize - dir->Size)
                && ((prevSection->Characteristics & dwForbiddenCharacteristics) == 0))
                return S_OK;
        }
    }   

    return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
}

HRESULT CorMap::ReadHeaders(PBYTE hAddress, IMAGE_DOS_HEADER** ppDos,
                            IMAGE_NT_HEADERS** ppNT, IMAGE_COR20_HEADER** ppCor,
                            BOOL fDataMap, DWORD dwLength)
{
    _ASSERTE(ppDos);
    _ASSERTE(ppNT);
    _ASSERTE(ppCor);

    IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER*) hAddress;
    
    if ((pDOS->e_magic != IMAGE_DOS_SIGNATURE) ||
        (pDOS->e_lfanew == 0))
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    *ppDos = pDOS;

    // @TODO: LoadLibrary() does the appropriate header verification,
    // except probably not on Win9X.  Is that good enough?
    if (!fDataMap) {
        MEMORY_BASIC_INFORMATION mbi;
        ZeroMemory(&mbi, sizeof(MEMORY_BASIC_INFORMATION));
        VirtualQuery(hAddress, &mbi, sizeof(MEMORY_BASIC_INFORMATION));
        dwLength = mbi.RegionSize;
    }

    if (dwLength &&
        ((UINT) (pDOS->e_lfanew ) > (UINT) dwLength - sizeof(IMAGE_NT_HEADERS)))
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*) (pDOS->e_lfanew + hAddress);
    if ((pNT->Signature != IMAGE_NT_SIGNATURE) ||
        (pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER) ||
        (pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC))
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    IMAGE_DATA_DIRECTORY *entry 
      = &pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER];
    
    if (entry->VirtualAddress == 0 || entry->Size == 0
        || entry->Size < sizeof(IMAGE_COR20_HEADER))
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    *ppNT = pNT;    // this needs to be set before we call VerifyDirectory

    //verify RVA and size of the COM+ header
    HRESULT hr;
    IfFailRet(VerifyDirectory(pNT, entry, IMAGE_SCN_MEM_WRITE));

    DWORD offset;
    if(fDataMap)
        offset = Cor_RtlImageRvaToOffset(pNT, entry->VirtualAddress, dwLength);
    else 
        offset = entry->VirtualAddress;

    *ppCor = (IMAGE_COR20_HEADER *) (offset + hAddress);
    return S_OK;
}

HRESULT CorMap::GetStrongNameSignature(PBYTE pbBase,
                                       IMAGE_NT_HEADERS *pNT,
                                       IMAGE_COR20_HEADER *pCor,
                                       BOOL fFileMap,
                                       BYTE **ppbSNSig,
                                       DWORD *pcbSNSig)
{
    HRESULT hr = E_FAIL;
    *ppbSNSig = NULL;
    *pcbSNSig = 0;

    if (pCor->StrongNameSignature.Size != 0 &&
        pCor->StrongNameSignature.VirtualAddress)
    {
        if (pCor->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED)
        {
            *pcbSNSig = pCor->StrongNameSignature.Size;
            DWORD offset = pCor->StrongNameSignature.VirtualAddress;
            if (fFileMap)
                offset = Cor_RtlImageRvaToOffset(pNT, pCor->StrongNameSignature.VirtualAddress, 0);
            *ppbSNSig = pbBase + offset;
            hr = S_OK;
        }

        // In the case that it's delay signed, we return this hresult as a special flag
        // to whoever is asking for the signature so that they can do some special case
        // work (like using the MVID as the hash and letting the loader determine if
        // delay signed assemblies are allowed).
        else
        {
            hr = CORSEC_E_INVALID_STRONGNAME;
        }
    }
    else
        hr = CORSEC_E_MISSING_STRONGNAME;

    return hr;
}

HRESULT CorMap::GetStrongNameSignature(PBYTE pbBase,
                                       IMAGE_NT_HEADERS *pNT,
                                       IMAGE_COR20_HEADER *pCor,
                                       BOOL fFileMap,
                                       BYTE *pbHash,
                                       DWORD *pcbHash)
{
    PBYTE pbSNSig;
    DWORD cbSNSig;
    HRESULT hr;

    if (SUCCEEDED(hr = GetStrongNameSignature(pbBase, pNT, pCor, fFileMap, &pbSNSig, &cbSNSig)))
    {
        if (pcbHash)
        {
            if (pbHash && cbSNSig <= *pcbHash)
                memcpy(pbHash, pbSNSig, cbSNSig);
            else
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

            *pcbHash = cbSNSig;
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
// openFile - maps pszFileName to memory, returns ptr to it (read-only)
// (Approximates LoadLibrary for Win9X)
// Caller must call FreeLibrary((HINSTANCE) *hMapAddress) and may need to delete[] szFilePath when finished.
//-----------------------------------------------------------------------------
HRESULT CorMap::OpenRawImage(PBYTE pUnmappedPE, DWORD dwUnmappedPE, LPCWSTR pwszFileName, HCORMODULE *hHandle, BOOL fResource/*=FALSE*/)
{
    HRESULT hr = S_OK;
    HCORMODULE hMod = NULL;
    _ASSERTE(hHandle);
    if(hHandle == NULL) return E_POINTER;

    Thread *thread = GetThread();
    BOOL    toggleGC = (thread && thread->PreemptiveGCDisabled());

    if (toggleGC)
        thread->EnablePreemptiveGC();

    int length = 0;
    if(pwszFileName) length = (int)wcslen(pwszFileName);
    hr = LoadFile(pUnmappedPE, dwUnmappedPE, pwszFileName, length, fResource, hHandle);

    if (toggleGC)
        thread->DisablePreemptiveGC();

    return hr;
}

HRESULT CorMap::LoadFile(PBYTE pUnmappedPE, DWORD dwUnmappedPE, LPCWSTR pImageName,
                         DWORD dwImageName, BOOL fResource, HCORMODULE *phHandle)
{
   // @TODO: CTS, change locking to multi-reader single writer.
    //        This will speed up getting duplicates. We can also
    //        do asynchronous mappings in LoadImage
    //        We need to find the actual file which causes us
    //        to search through the system libraries. This
    //        needs to be done faster.

    HRESULT hr = S_OK;

    CorMapInfo* pResult = NULL;
    WCHAR pPath[_MAX_PATH];
    DWORD size = sizeof(pPath) / sizeof(WCHAR);

    IfFailRet(InitializeTable());

    if(pImageName) {
        IfFailRet(BuildFileName(pImageName, (LPWSTR) pPath, &size));
        pImageName = pPath;
        dwImageName = size;
    }


    BEGIN_ENSURE_PREEMPTIVE_GC();
    Enter();
    END_ENSURE_PREEMPTIVE_GC();
    if(pImageName) 
        hr = FindFileName(pImageName, &pResult);

    if(FAILED(hr) || pResult == NULL) {
        HCORMODULE mappedData;

        BOOL fResult;
        if (fResource)
            fResult = LoadMemoryResource(pUnmappedPE, dwUnmappedPE, pImageName, dwImageName, &mappedData);
        else 
            fResult = LoadMemoryImageW9x(pUnmappedPE, dwUnmappedPE, pImageName, dwImageName, &mappedData);

        if (!fResult) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr))
                hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        }
        else {
            pResult = GetMapInfo(mappedData);
            if(pImageName) 
                hr = AddFile(pResult);
            else
            {
                pResult->AddRef();
                hr = S_OK;
            }
        }
    }
    Leave();

    if(SUCCEEDED(hr))
        *phHandle = GetCorModule(pResult);
        
    return hr;
}

// For loading a file that is a CLR resource, not a PE file.
BOOL CorMap::LoadMemoryResource(PBYTE pbResource, DWORD dwResource, 
                                LPCWSTR pImageName, DWORD dwImageName, HCORMODULE* hMapAddress)
{
    if (!pbResource)
        return FALSE;

    DWORD cbNameSize = CalculateCorMapInfoSize(dwImageName);
    DWORD cb = dwResource + cbNameSize;

    HANDLE hMapFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, cb, NULL);
    if (!hMapFile)
        return FALSE;
                    
    PBYTE hAddress = (PBYTE) MapViewOfFileEx(hMapFile, FILE_MAP_WRITE, 0, 0, cb, (PVOID)NULL);
    if (!hAddress) {
        CloseHandle(hMapFile);
        return FALSE;
    }

    // Move the pointer up to the place we will be loading
    hAddress = SetImageName(hAddress,
                            cbNameSize,
                            pImageName,
                            dwImageName,
                            CorLoadDataMap,
                            dwResource,
                            INVALID_HANDLE_VALUE);
    if (!hAddress) {
        SetLastError(ERROR_OUTOFMEMORY);
        CloseHandle(hMapFile);
        return FALSE;
    }

    // Copy the data
    memcpy((void*) hAddress, pbResource, dwResource);
    *hMapAddress = (HCORMODULE) hAddress;

    CloseHandle(hMapFile);
    return TRUE;
}

HRESULT CorMap::ApplyBaseRelocs(PBYTE hAddress, IMAGE_NT_HEADERS *pNT, CorMapInfo* ptr)
{
    if(ptr->RelocsApplied() == TRUE)
        return S_OK;

    // @todo: 64 bit - are HIGHLOW relocs 32 or 64 bit?  can delta be > 32 bit?

    SIZE_T delta = (SIZE_T) (hAddress - pNT->OptionalHeader.ImageBase);
    if (delta == 0)
        return S_FALSE;

    if (GetAppDomain()->IsCompilationDomain())
    {
        // For a compilation domain, we treat the image specially.  Basically we don't
        // care about base relocs, except for one special case - the TLS directory. 
        // We can find this one by hand, and we need to work in situations even where
        // base relocs have been stripped.  So basically no matter what the base relocs
        // say we just fix up this one section.

        IMAGE_DATA_DIRECTORY *tls = &pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
        if (tls->VirtualAddress != 0 && tls->Size > 0)
        {
            IMAGE_TLS_DIRECTORY *pDir = (IMAGE_TLS_DIRECTORY*) (tls->VirtualAddress + hAddress);
            if (pDir != NULL)
            {
                DWORD oldProtection;
                if (VirtualProtect((VOID *) pDir, sizeof(*pDir), PAGE_READWRITE,
                                   &oldProtection))
                {
                    pDir->StartAddressOfRawData += delta;
                    pDir->EndAddressOfRawData += delta;
                    pDir->AddressOfIndex += delta;
                    pDir->AddressOfCallBacks += delta;

                    VirtualProtect((VOID *) pDir, sizeof(*pDir), oldProtection,
                                   &oldProtection);
                }
            }
        }

        ptr->SetRelocsApplied();
        return S_FALSE;
    }
    
    // 
    // If base relocs have been stripped, we must fail.
    // 

    if (pNT->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) {
        ptr->SetRelocsApplied();
        STRESS_ASSERT(0);   // TODO remove after bug 93333 is fixed
        BAD_FORMAT_ASSERT(!"Relocs stripped");
        return COR_E_BADIMAGEFORMAT;
    }

    //
    // Look for a base relocs section.
    //

    IMAGE_DATA_DIRECTORY *dir 
      = &pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

    if (dir->VirtualAddress != 0)
    {
        BYTE *relocations = hAddress + dir->VirtualAddress;
        BYTE *relocationsEnd = relocations + dir->Size;

        while (relocations < relocationsEnd)
        {
            IMAGE_BASE_RELOCATION *r = (IMAGE_BASE_RELOCATION*) relocations;

            SIZE_T pageAddress = (SIZE_T) (hAddress + r->VirtualAddress);

            DWORD oldProtection;
            
            // The +1 on PAGE_SIZE forces the subsequent page to change protection rights
            // as well - this fixes certain cases where the final write occurs across a page boundary.
            if (VirtualProtect((VOID *) pageAddress, PAGE_SIZE+1, PAGE_READWRITE,
                               &oldProtection))
            {
                USHORT *fixups = (USHORT *) (r+1);
                USHORT *fixupsEnd = (USHORT *) ((BYTE*)r + r->SizeOfBlock);

                while (fixups < fixupsEnd)
                {
                    if ((*fixups>>12) != IMAGE_REL_BASED_ABSOLUTE)
                    {
                        // Only support HIGHLOW fixups for now
                        _ASSERTE((*fixups>>12) == IMAGE_REL_BASED_HIGHLOW);

                        if ((*fixups>>12) != IMAGE_REL_BASED_HIGHLOW) {
                            ptr->SetRelocsApplied();
                            STRESS_ASSERT(0);   // TODO remove after bug 93333 is fixed
                            BAD_FORMAT_ASSERT(!"Bad Reloc");
                            return COR_E_BADIMAGEFORMAT;
                        }

                        SIZE_T *address = (SIZE_T*)(pageAddress + ((*fixups)&0xfff));

                        if ((*address < pNT->OptionalHeader.ImageBase) ||
                            (*address >= (pNT->OptionalHeader.ImageBase
                                          + pNT->OptionalHeader.SizeOfImage))) {
                            ptr->SetRelocsApplied();
                            STRESS_ASSERT(0);   // TODO remove after bug 93333 is fixed
                            BAD_FORMAT_ASSERT(!"Bad Reloc");
                            return COR_E_BADIMAGEFORMAT;
                        }

                        *address += delta;

                        if ((*address < (SIZE_T) hAddress) ||
                            (*address >= ((SIZE_T) hAddress 
                                          + pNT->OptionalHeader.SizeOfImage))) {
                            ptr->SetRelocsApplied();
                            STRESS_ASSERT(0);   // TODO remove after bug 93333 is fixed
                            BAD_FORMAT_ASSERT(!"Bad Reloc");
                            return COR_E_BADIMAGEFORMAT;
                        }
                    }

                    fixups++;
                }

                VirtualProtect((VOID *) pageAddress, PAGE_SIZE+1, oldProtection,
                               &oldProtection);
            }

            relocations += (r->SizeOfBlock+3)&~3; // pad to 4 bytes
        }
    }

    // If we find an IAT with more than 2 entries (which we expect from our loader
    // thunk), fail the load.

    if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress != 0
         && (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size > 
             (2*sizeof(IMAGE_THUNK_DATA)))) {
        ptr->SetRelocsApplied();
        return COR_E_FIXUPSINEXE;
    }

    // If we have a TLS section, fail the load.

    if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != 0
        && pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size > 0) {
        ptr->SetRelocsApplied();
        return COR_E_FIXUPSINEXE;
    }
    

    ptr->SetRelocsApplied();
    return S_OK;
}

//-----------------------------------------------------------------------------
// mapFile - maps an hFile to memory, returns ptr to it (read-only)
// Caller must call FreeLibrary((HINSTANCE) *hMapAddress) when finished.
// @todo: does FreeLibrary() really work to clean up?
//-----------------------------------------------------------------------------
HRESULT CorMap::MapFile(HANDLE hFile, HMODULE *phHandle)
{
    _ASSERTE(phHandle);
    if(phHandle == NULL) return E_POINTER;

    PBYTE pMapAddress = NULL;
    BEGIN_ENSURE_PREEMPTIVE_GC();
    Enter();
    END_ENSURE_PREEMPTIVE_GC();
    HRESULT hr = LoadImage(hFile, CorLoadImageMap, &pMapAddress, NULL, 0);
    Leave();
    if(SUCCEEDED(hr))
        *phHandle = (HMODULE) pMapAddress;
    return hr;
}

HRESULT CorMap::InitializeTable()
{
   HRESULT hr = S_OK;
   // @TODO: CTS, add these to the system heap 
   if(m_pOpenFiles == NULL) {
       BEGIN_ENSURE_PREEMPTIVE_GC();
       Enter();
       END_ENSURE_PREEMPTIVE_GC();
       if(m_pOpenFiles == NULL) {
           m_pOpenFiles = new (nothrow) EEUnicodeStringHashTable();
           if(m_pOpenFiles == NULL) 
               hr = E_OUTOFMEMORY;
           else {
               LockOwner lock = {&m_pCorMapCrst, IsOwnerOfOSCrst};
               if(!m_pOpenFiles->Init(BLOCK_SIZE, &lock))
                   hr = E_OUTOFMEMORY;
           }
       }
       Leave();
   }

   return hr;
}

HRESULT CorMap::BuildFileName(LPCWSTR pszFileName, LPWSTR pPath, DWORD* dwPath)
{
    // Strip off any file protocol
    if(_wcsnicmp(pszFileName, L"file://", 7) == 0) {
        pszFileName = pszFileName+7;
        if(*pszFileName == L'/') pszFileName++;
    }
    
    // Get the absolute file name, size does not include the null terminator
    LPWSTR fileName;
    DWORD dwName = WszGetFullPathName(pszFileName, *dwPath, pPath, &fileName);
    if(dwName == 0) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    else if(dwName > *dwPath) {
        *dwPath = dwName + 1;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    *dwPath = dwName + 1;
    
    WCHAR* ptr = pPath;
    while(*ptr) {
        *ptr = towlower(*ptr);
        ptr++;
    }
    return S_OK;
}

HRESULT CorMap::FindFileName(LPCWSTR pszFileName, CorMapInfo** pHandle)
{
    _ASSERTE(pHandle);
    _ASSERTE(pszFileName);
    _ASSERTE(m_fInitialized);
    _ASSERTE(m_fInsideMapLock > 0);

    HRESULT hr;
    HashDatum data;
    DWORD dwName = 0;
    *pHandle = NULL;

    LOG((LF_CLASSLOADER, LL_INFO10, "FindFileName: \"%ws\", %d\n", pszFileName, wcslen(pszFileName)+1));

    EEStringData str((DWORD)wcslen(pszFileName)+1, pszFileName);
    if(m_pOpenFiles->GetValue(&str, &data)) {
        *pHandle = (CorMapInfo*) data;
        (*pHandle)->AddRef();
        hr = S_OK;
    }
    else
        hr = E_FAIL;

    return hr;
}

        
HRESULT CorMap::AddFile(CorMapInfo* ptr)
{
    HRESULT hr;

    _ASSERTE(m_fInsideMapLock > 0);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);

    LPCWSTR psName = ptr->pFileName;
    DWORD length = GetFileNameLength(psName, (UINT_PTR) ptr);
    
    LOG((LF_CLASSLOADER, LL_INFO10, "Adding file to Open list: \"%ws\", %0x, %d\n", psName, ptr, length));

    EEStringData str(length, psName);
    HashDatum pData;
    if(m_pOpenFiles->GetValue(&str, &pData)) {
        ptr->AddRef();
        return S_FALSE;
    }

    
    pData = (HashDatum) ptr;       
    if(m_pOpenFiles->InsertValue(&str, pData, FALSE)) {
        ptr->AddRef();
        hr = S_OK;
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT CorMap::ReleaseHandleResources(CorMapInfo* ptr, BOOL fDeleteHandle)
{
    _ASSERTE(ptr);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);

    CorLoadFlags flags = ptr->Flags();
    HRESULT hr = S_OK;
    HANDLE hModule = NULL;
    HCORMODULE pChild;

    if(fDeleteHandle)
        ptr->HoldFile(INVALID_HANDLE_VALUE);

    switch(flags) {
    case CorLoadOSImage:
        if(ptr->hOSHandle) {
            if (!g_fProcessDetach)
                FreeLibrary(ptr->hOSHandle);
            ptr->hOSHandle = NULL;
        }
        if(fDeleteHandle) 
            delete (PBYTE) GetMemoryStart(ptr);
        break;
    case CorLoadOSMap:
        if(ptr->hOSHandle) {
            hModule = ptr->hOSHandle;
            ptr->hOSHandle = NULL;
        }
        if(fDeleteHandle)
            delete (PBYTE) GetMemoryStart(ptr);
        break;
    case CorReLoadOSMap:
        pChild = (HCORMODULE) ptr->hOSHandle;
        if(pChild) 
            ReleaseHandle(pChild);
        break;
    case CorLoadDataMap:
    case CorLoadImageMap:
        hModule = (HMODULE) GetMemoryStart(ptr);
    }
    
    if(hModule != NULL && !UnmapViewOfFile(hModule)) // Filename is the beginning of the mapped data
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}

HRESULT CorMap::RemoveMapHandle(CorMapInfo*  pInfo)
{
    _ASSERTE(pInfo);
    _ASSERTE((pInfo->References() & 0xffff0000) == 0);

    _ASSERTE(m_fInsideMapLock > 0);

    if(m_pOpenFiles == NULL || pInfo->KeepInTable()) return S_OK;
    
    LPCWSTR fileName = pInfo->pFileName;
    DWORD length = GetFileNameLength(fileName, (UINT_PTR) pInfo);

    EEStringData str(length, fileName);
    m_pOpenFiles->DeleteValue(&str);
    
    return S_OK;
}

DWORD CorMap::GetFileNameLength(CorMapInfo* ptr)
{
    _ASSERTE(ptr);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);
    return GetFileNameLength(ptr->pFileName, (UINT_PTR) ptr);
}

DWORD CorMap::GetFileNameLength(LPCWSTR name, UINT_PTR start)
{
    DWORD length;

    length = (DWORD)(start - (UINT_PTR) (name)) / sizeof(WCHAR);

    WCHAR* tail = ((WCHAR*)name) + length - 1;
    while(tail >= name && *tail == L'\0') tail--; // remove all nulls

    if(tail > name)
        length = (DWORD)(tail - name + 2); // the last character and the null character back in
    else
        length = 0;

    return length;
}

void CorMap::GetFileName(HCORMODULE pHandle, WCHAR *psBuffer, DWORD dwBuffer, DWORD *pLength)
{
    DWORD length = 0;
    CorMapInfo* pInfo = GetMapInfo(pHandle);
    _ASSERTE((pInfo->References() & 0xffff0000) == 0);

    LPWSTR name = pInfo->pFileName;

    if (name)
    {
        length = GetFileNameLength(name, (UINT_PTR) pInfo);
        if(dwBuffer > 0) {
            length = length > dwBuffer ? dwBuffer : length;
            memcpy(psBuffer, name, length*sizeof(WCHAR));
        }
    }

    *pLength = length;
}

void CorMap::GetFileName(HCORMODULE pHandle, char* psBuffer, DWORD dwBuffer, DWORD *pLength)
{
    DWORD length = 0;
    CorMapInfo* pInfo = (((CorMapInfo *) pHandle) - 1);
    _ASSERTE((pInfo->References() & 0xffff0000) == 0);

    LPWSTR name = pInfo->pFileName;
    if (*name)
    {
        length = GetFileNameLength(name, (UINT_PTR) pInfo);
        length = WszWideCharToMultiByte(CP_UTF8, 0, name, length, psBuffer, dwBuffer, 0, NULL);
    }

    *pLength = length;
}

CorLoadFlags CorMap::ImageType(HCORMODULE pHandle)
{
    CorMapInfo* ptr = GetMapInfo(pHandle);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);
    return ptr->Flags();
}

HRESULT CorMap::BaseAddress(HCORMODULE pHandle, HMODULE* pModule)
{
    HRESULT hr = S_OK;
    CorMapInfo* ptr = GetMapInfo(pHandle);
    _ASSERTE(pModule);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);
    HMODULE hMod = NULL;

    switch(ptr->Flags()) {
    case CorLoadOSImage:
        if(ptr->hOSHandle == NULL) {
            if(!ptr->pFileName || !ValidDllPath(ptr->pFileName)) {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
                break;
            }

#if ZAPMONITOR_ENABLED
            // Temporarily remove protection as it may cause LoadLibrary to barf
            ZapMonitor::SuspendAll();
#endif
            // If LoadLibrary succeeds then the hOSHandle should be set by the
            // ExecuteDLL() entry point
            
            // Don't even bother trying to call the Dll entry point for
            // verifiable images since they can not have a DllMain
            DWORD loadLibraryFlags = LOAD_WITH_ALTERED_SEARCH_PATH;
            if (RunningOnWinNT() && ptr->verifiable == 1)
                loadLibraryFlags |= DONT_RESOLVE_DLL_REFERENCES;

#ifdef _DEBUG           
            if(!g_pConfig->UseBuiltInLoader())
#endif
                hMod = WszLoadLibraryEx(ptr->pFileName, 
                                        NULL, loadLibraryFlags);
#if ZAPMONITOR_ENABLED
            // Temporarily remove protection as it may cause LoadLibrary to barf
            ZapMonitor::ResumeAll();
#endif
            if(hMod == NULL) {
                if (gRunningOnStatus == RUNNING_ON_WIN95) {
                    if(ptr->hOSHandle == NULL) {
                        // Our HCORMODULE is redirected to another HCORMODULE
                        BEGIN_ENSURE_PREEMPTIVE_GC();
                        Enter();
                        END_ENSURE_PREEMPTIVE_GC();
                        if(ptr->hOSHandle == NULL) {
                            HCORMODULE pFile;
                            DWORD length = GetFileNameLength(ptr->pFileName, (UINT_PTR) ptr);
                            hr = OpenFileInternal(ptr->pFileName, length, CorReLoadOSMap, (HCORMODULE*) &pFile);
                            if(SUCCEEDED(hr)) {
                                if(ptr->hOSHandle == NULL) {
                                    ptr->hOSHandle = (HMODULE) pFile;
                                     // Set the flag last to avoid race conditions
                                    // when getting the handle
                                    ptr->SetCorLoadFlags(CorReLoadOSMap);
                                    // OpenFileInternal with CorReloadMap should read entire file into memory 
                                    // so we aren't going to use its content again and thus can release it
                                    GetMapInfo(pFile)->HoldFile(INVALID_HANDLE_VALUE);
                                }
                                if(ptr->hOSHandle != (HMODULE) pFile)
                                    ReleaseHandle(pFile);
                            }
                            else 
                                ptr->SetCorLoadFlags(CorLoadUndefinedMap);
                        }
                        Leave();
                    }
                }
                else {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ptr->SetCorLoadFlags(CorLoadUndefinedMap);
                }
            }
            else { 
                // If we're not on Win95, and if this is an executable, we need to 
                // manually apply relocs since the NT loader ignores them.
                // (The only case where this currently happens is in loading images for ngen
                // compilation)

                if (gRunningOnStatus != RUNNING_ON_WIN95) {
                    IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER*) hMod;
                    IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*) (pDOS->e_lfanew + (PBYTE) hMod);

                    if ((pNT->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0 &&
                        ptr->RelocsApplied() == FALSE) {
                        
                        // For executables we need to apply our own relocations. Only do this
                        // if they have not been previously done.
                        BEGIN_ENSURE_PREEMPTIVE_GC();
                        CorMap::Enter();
                        END_ENSURE_PREEMPTIVE_GC();
                        hr = ApplyBaseRelocs((PBYTE)hMod, pNT, ptr);
                        CorMap::Leave();
                        if (FAILED(hr)) {
                            FreeLibrary(hMod);
                            goto Exit;
                        }
                    }
                }

                HMODULE old = (HMODULE) InterlockedExchangePointer(&(ptr->hOSHandle), hMod);
                
                // If there was a previous value then release a count on it.
                if(old != NULL) {
                    _ASSERTE(old == hMod);
                    FreeLibrary(old);
                }
            }
            // We don't want to hold on to the file handle any longer than necessary since it blocks
            // renaming of the DLL, which means that installers will fail.   Once we have done the 
            // LoadLibrary we have a weaker lock that will insure that the bits of the file are not changed
            // but does allow renaming. 
            ptr->HoldFile(INVALID_HANDLE_VALUE);
        }
        *pModule = ptr->hOSHandle;
        break;
    case CorReLoadOSMap:
    case CorLoadOSMap:
       *pModule = ptr->hOSHandle;
       break;
    case CorLoadUndefinedMap:
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        break;
    default:
        *pModule = (HMODULE) pHandle;
        break;
    }

Exit:
    return hr;
}

size_t CorMap::GetRawLength(HCORMODULE pHandle)
{
    CorMapInfo* ptr = GetMapInfo(pHandle);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);
    return ptr->dwRawSize;
}

HRESULT CorMap::AddRefHandle(HCORMODULE pHandle)
{
    _ASSERTE(pHandle);
    CorMapInfo* ptr = GetMapInfo(pHandle);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);
    ptr->AddRef();
    return S_OK;
}

HRESULT CorMap::ReleaseHandle(HCORMODULE pHandle)
{
    _ASSERTE(pHandle);
    CorMapInfo* ptr = GetMapInfo(pHandle);
    _ASSERTE((ptr->References() & 0xffff0000) == 0);
    ptr->Release();
    return S_OK;
}

void CorMap::EnterSpinLock ()
{ 
    while (1)
    {
        if (InterlockedExchange ((LPLONG)&m_spinLock, 1) == 1)
            __SwitchToThread(5); // @TODO: Spin here first...
        else
            return;
    }
}

//---------------------------------------------------------------------------------
//

ULONG CorMapInfo::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRef));
}

ULONG CorMapInfo::Release()
{

   BEGIN_ENSURE_PREEMPTIVE_GC();
   CorMap::Enter();
   END_ENSURE_PREEMPTIVE_GC();
    
   ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
   if (!cRef) {


       CorMap::RemoveMapHandle(this);
       CorMap::ReleaseHandleResources(this, TRUE);
   }

   BEGIN_ENSURE_PREEMPTIVE_GC();
   CorMap::Leave();
   END_ENSURE_PREEMPTIVE_GC();

   return (cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cormap.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  CorMap.cpp
**
** Purpose: We use a special handle to differentiate between
**          files mapped by the system or mapped by the EE. 
**          The map keeps track of handles opened by the COR
**          runtime
**
** Date:  May 16, 1999
**
===========================================================*/
#ifndef _CORMAP_H
#define _CORMAP_H

#include <wtypes.h>
#include <winbase.h>
#include "MetaData.h"

// Layout for Cor memory mapped image
// ----------------------------------
//
//  [name (null terminated)
//    :
//  ]
//  ptr-to-name
//  image-start   <---- This address is returned with lower bit set
//    :
//

class CorMap;

struct CorMapInfo
{
    friend CorMap;
private:
    LPWSTR         pFileName;
    DWORD          dwRawSize;
    ULONG          m_cRef;                 // Ref count.
    HMODULE        hOSHandle;
    WORD           flags;
    WORD           verifiable;
    HANDLE         hFileToHold;

public:

    BOOL HoldFile(HANDLE hFile)
    {
        HANDLE hFileToClose=hFileToHold;         
        BOOL bRet=TRUE;
        if(hFile!=INVALID_HANDLE_VALUE)
            bRet= ::DuplicateHandle(::GetCurrentProcess(), hFile, ::GetCurrentProcess(), &hFileToHold,
                         0 /*ignored*/, FALSE /*inherit*/, DUPLICATE_SAME_ACCESS);
        else
            hFileToHold=INVALID_HANDLE_VALUE;

        if (hFileToClose!=INVALID_HANDLE_VALUE)
            CloseHandle(hFileToClose);
        return bRet; 
    }

    CorLoadFlags  Flags()
    {
        return (CorLoadFlags) (flags & CorLoadMask);
    }
    void SetCorLoadFlags(CorLoadFlags f)
    {
        flags = (flags & ~CorLoadMask) | (f & CorLoadMask);
    }
    BOOL RelocsApplied()
    {
        return (flags & CorReLocsApplied) != 0 ? TRUE : FALSE;
    }
    void SetRelocsApplied()
    {
        flags |= CorReLocsApplied;
    }
    
    BOOL KeepInTable()
    {
        return (flags & CorKeepInTable) != 0 ? TRUE : FALSE;
    }
    void SetKeepInTable()
    {
        flags |= CorKeepInTable;
    }

    ULONG Release(void);
    ULONG AddRef(void); 
    ULONG References()
    {
        return m_cRef;
    }
};


class CorMap {
    friend CorMapInfo;

public:
    // Clean up all open files and memory
#ifdef SHOULD_WE_CLEANUP
    static void Detach();
#endif /* SHOULD_WE_CLEANUP */
    static HRESULT Attach();

    static HRESULT MapFile(HANDLE hFile, HMODULE* hHandle);

    static void GetFileName(HCORMODULE pHandle, char  *psBuffer, DWORD dwBuffer, DWORD *pLength);
    static void GetFileName(HCORMODULE pHandle, WCHAR *pwsBuffer, DWORD dwBuffer, DWORD *pLength);

    static HRESULT AddRefHandle(HCORMODULE pHandle);
    static HRESULT ReleaseHandle(HCORMODULE pHandle);

    static HRESULT OpenRawImage(PBYTE pUnmappedPE, DWORD dwUnmappedPE, LPCWSTR pwszFileName, HCORMODULE* hHandle, BOOL fResource=FALSE);
    static HRESULT OpenImage(HMODULE, HCORMODULE*);
    // 
    // Load the explicit path and maps it into memory. The image can be mapped as raw data or it cam be mapped into the
    // virtual address's
    //
    static HRESULT OpenFile(LPCWSTR pszFileName, CorLoadFlags flags, HCORMODULE* hHandle, DWORD *pdwLength = NULL);
    
    // Relocate the image into the proper locations. This will fail if ref count is greater then 1 because
    // a file cannot be remapped when another handle has access to the image.
    static HRESULT MemoryMapImage(HCORMODULE hModule, HCORMODULE* pResult);

    // Verify the exsistence of a directory
    static HRESULT VerifyDirectory(IMAGE_NT_HEADERS* pNT, IMAGE_DATA_DIRECTORY *dir, DWORD dwForbiddenCharacteristics);

    // Get the NT and COR headers from the image.
    static HRESULT ReadHeaders(PBYTE hAddress, 
                               IMAGE_DOS_HEADER** ppDos, 
                               IMAGE_NT_HEADERS** ppNT, 
                               IMAGE_COR20_HEADER** ppCor,
                               BOOL fDataMap,
                               DWORD dwLength);

    static HRESULT GetStrongNameSignature(PBYTE pbBase,
                                          IMAGE_NT_HEADERS *pNT,
                                          IMAGE_COR20_HEADER *pCor,
                                          BOOL fFileMap,
                                          BYTE **ppbSNSig,
                                          DWORD *pcbSNSig);

    static HRESULT GetStrongNameSignature(PBYTE pbBase,
                                          IMAGE_NT_HEADERS *pNT,
                                          IMAGE_COR20_HEADER *pCor,
                                          BOOL fFileMap,
                                          BYTE *pbHash,
                                          DWORD *pcbHash);

    // Get the Image type
    static CorLoadFlags ImageType(HCORMODULE pHandle);

    // Get the Raw Data size of the image
    static size_t GetRawLength(HCORMODULE pHandle);

    // Get the BaseAddress associated with cor module
    static HRESULT BaseAddress(HCORMODULE pHandle, HMODULE* ppModule);

    // @TODO: when fusion fixes referencing remove this call
    static DWORD HandleReferences(HCORMODULE hModule) 
    {
        CorMapInfo* ptr = GetMapInfo(hModule);
        if(ptr)
            return ptr->References();
        else
            return 0;
    }

    static void SetVerifiable(HCORMODULE hModule)
    {
        GetMapInfo(hModule)->verifiable = 1;
    }

    static void EnterSpinLock ();

    static void LeaveSpinLock () { InterlockedExchange ((LPLONG)&m_spinLock, 0); }

    static BOOL ValidDllPath(LPCWSTR pPath);

private:
    static HRESULT LoadImage(HANDLE hFile, CorLoadFlags flags, PBYTE *hMapAddress, LPCWSTR pFileName, DWORD dwFileName);
    static BOOL MapImageAsData(HANDLE hFile, CorLoadFlags flags, PBYTE *hMapAddress, LPCWSTR pFileName, DWORD dwFileName);

    static BOOL LoadMemoryImageW9x(PBYTE pUnmappedPE, DWORD dwUnmappedPE, LPCWSTR pImageName, DWORD dwImageName, HCORMODULE *hMapAddress);
    static BOOL LoadMemoryResource(PBYTE pbResource, DWORD dwResource, LPCWSTR pImageName, DWORD dwImageName, HCORMODULE* hMapAddress);
    static HRESULT ApplyBaseRelocs(PBYTE hAddress, IMAGE_NT_HEADERS *pNTHeader, CorMapInfo* ptr);

    // Routines for mapping in a module through LoadImageW9x;
    static HRESULT LoadFile(PBYTE pUnmappedPE, DWORD dwUnmappedPE, LPCWSTR pImageName,
                            DWORD dwImageName, BOOL fResource, HCORMODULE *phHandle);

    static DWORD GetFileNameLength(LPCWSTR name, UINT_PTR handle);
    static DWORD GetFileNameLength(CorMapInfo*);

    // Populates the CorMapInfo structure. It creates the necessary memory for OS loads
    static PBYTE SetImageName(PBYTE hAddress, DWORD cbInfo, 
                              LPCWSTR pFileName, DWORD dwFileName, 
                              CorLoadFlags flags, DWORD dwFileSize,
                              HANDLE hFile);

    // Open file, assumes the appropriate locking has occured
    static HRESULT OpenFileInternal(LPCWSTR pszFileName, DWORD dwFileName, CorLoadFlags flags, HCORMODULE* hHandle, DWORD *pdwLength = NULL);

    // Converts a file memory mapped as data into an image. 
    static HRESULT LayoutImage(PBYTE hAddress, PBYTE pSource);

    static HCORMODULE GetCorModule(CorMapInfo* ptr)
    {
        return (HCORMODULE) ((PBYTE) ptr + sizeof(CorMapInfo));
    }

    static CorMapInfo* GetMapInfo(HCORMODULE pHandle)
    {
        return (CorMapInfo*) ((PBYTE) pHandle - sizeof(CorMapInfo));
    }

    static void* GetMemoryStart(CorMapInfo* hnd)
    {
        return (void*) hnd->pFileName;
    }

    static void* GetMemoryStart(HCORMODULE hnd)
    {
        return (void*) GetMapInfo(hnd)->pFileName;
    }
    
    static LPCWSTR GetCorFileName(HCORMODULE hnd)
    {
        return (LPCWSTR) GetMapInfo(hnd)->pFileName;
    }

    // Creates a full path name. Ignores protocols at the front of the name
    static HRESULT BuildFileName(LPCWSTR pszFileName, LPWSTR pPath, DWORD* dwPath);

    // Return the number of bytes required to store a CorMapInfo Structure
    static DWORD CalculateCorMapInfoSize(DWORD dwFileName);

    // Free up OS resources associated with handle. If fDeleteHandle
    // is true and it is an OS mapping (data or image) then the
    // memory containing the handle is also releasde
    static HRESULT ReleaseHandleResources(CorMapInfo* ptr, BOOL fDeleteHandle);

    // Take a lock before these routines
    static HRESULT FindFileName(LPCWSTR pszFileName, CorMapInfo** pHandle);
    static HRESULT AddFile(CorMapInfo* ptr);
    static HRESULT RemoveMapHandle(CorMapInfo* ptr);

    static void Enter()
    { 
        if(m_fInitialized) {
            EnterCriticalSection(&m_pCorMapCrst);
#ifdef _DEBUG
            m_fInsideMapLock++;
#endif
        }
    }

    static void Leave()
    { 
        if(m_fInitialized) {
#ifdef _DEUBG
            m_fInsideMapLock--;
#endif
            LeaveCriticalSection(&m_pCorMapCrst); 
        }
    }

    static HRESULT InitializeTable();

    static DWORD           m_dwSize;
    static DWORD           m_dwIndex;
    static BOOL            m_fInitialized;
    static EEUnicodeStringHashTable* m_pOpenFiles;
    static CRITICAL_SECTION    m_pCorMapCrst;
    static DWORD           m_spinLock;
#ifdef _DEBUG
    static DWORD           m_fInsideMapLock;
#endif

};

#endif // _CORMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\crst.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CRST.H -
//
// Debug-instrumented hierarchical critical sections.
//
//
// The hierarchy:
// --------------
//    The EE divides critical sections into numbered groups or "levels."
//    Crsts that guard the lowest level data structures that don't
//    use other services are grouped into the lowest-numbered levels.
//    The higher-numbered levels are reserved for high-level crsts
//    that guard broad swatches of code. Multiple groups can share the
//    same number to indicate that they're disjoint (their locks will never
//    nest.)
//
//    The fundamental rule of the hierarchy that threads can only request
//    a crst whose level is lower than any crst currently held by the thread.
//    E.g. if a thread current holds a level-3 crst, he can try to enter
//    a level-2 crst, but not a level-4 crst, nor a different level-3
//    crst. This prevents the cyclic dependencies that lead to deadlock.
//
//
//
// To create a crst:
//
//    Crst *pcrst = new Crst("tag", level);
//
//      where the "tag" is a short string describing the purpose of the crst
//      (to aid debugging) and the level of the crst (a member of the CrstLevel
//      enum.)
//
//      By default, crsts don't support nested enters by the same thread. If
//      you need reentrancy, use the alternate form:
//
//    Crst *pcrst = new Crst("tag", level, TRUE);
//
//      Since reentrancies never block the caller, they're allowed to
//     "violate" the level ordering rule.
//
//
// To enter/leave a crst:
// ----------------------
//
//
//    pcrst->Enter();
//    pcrst->Leave();
//
// An assertion will fire on Enter() if a thread attempts to take locks
// in the wrong order.
//
// Finally, a few DEBUG-only methods:
//
// To assert taking a crst won't violate level order:
// --------------------------------------------------
//
//    _ASSERTE(pcrst->IsSafeToTake());
//
//    This is a good line to put at the start of any function that
//    enters a crst in some circumstances but not others. If it
//    always enters the crst, it's not necessary to call IsSafeToTake()
//    since Enter() does this for you.
//
// To assert that the current thread owns a crst:
// --------------------------------------------------
//
//   _ASSERTE(pcrst->OwnedByCurrentThread());


#ifndef __crst_h__
#define __crst_h__

#include "util.hpp"
#include "log.h"
#include <member-offset-info.h>

#define ShutDown_Start                          0x00000001
#define ShutDown_Finalize1                      0x00000002
#define ShutDown_Finalize2                      0x00000004
#define ShutDown_Profiler                       0x00000008
#define ShutDown_COM                            0x00000010
#define ShutDown_SyncBlock                      0x00000020
#define ShutDown_IUnknown                       0x00000040
#define ShutDown_Phase2                         0x00000080

extern bool g_fProcessDetach;
extern DWORD g_fEEShutDown;
extern bool g_fForbidEnterEE;
extern bool g_fFinalizerRunOnShutDown;

// Defined crst levels. Threads can acquire higher-numbered crsts before
// lower-numbered crsts but not vice-versa.
enum CrstLevel {
    CrstDummy                   = 00,        // For internal use only. Not a true level.
    CrstThreadIdDispenser       = 3,         // For the thin lock thread ids - needs to be less than CrstThreadStore
    CrstSyncClean               = 4,         // For cleanup of EE data at the end of GC
    CrstUniqueStack             = 5,         // For FastGCStress
    CrstStubInterceptor         = 10,        // stub tracker (debug)
    CrstStubTracker             = 10,        // stub tracker (debug)
    CrstSyncBlockCache          = 13,        // allocate a SyncBlock to an object -- taken inside CrstHandleTable
    CrstHandleTable             = 15,        // allocate / release a handle (called inside CrstSingleUseLock)
    CrstExecuteManRangeLock     = 19,
    CrstSyncHashLock            = 20,        // used for synchronized access to a hash table
    CrstSingleUseLock           = 20,        // one time initialization of data, locks use this level
    CrstModule                  = 20,
    CrstModuleLookupTable       = 20,
    CrstArgBasedStubCache       = 20,
    CrstAwareLockAlloc          = 20,        // global allocation of AwareLock semaphore
    CrstThread                  = 20,        // used during e.g. thread suspend
    CrstMLCache                 = 20,
    CrstPermissionLoad          = 20,        // Add precreated permissions to module
    CrstLazyStubMakerList       = 20,        // protects lazystubmaker list
    CrstUMThunkHash             = 20,
    CrstMUThunkHash             = 20,
    CrstReflection              = 20,        // Reflection memory setup
    CrstCompressedStack         = 20,        // For Security Compress Stack
    CrstSecurityPolicyCache     = 20,        // For Security policy cache
    CrstSigConvert              = 25,        // convert a gsig_ from text to binary
    CrstThreadStore             = 30,        // used to e.g. iterate over threads in system
    CrstAppDomainCache          = 35,
    CrstWrapperTemplate         = 35,        // Create a wrapper template for a class
    CrstMethodJitLock           = 35,
    CrstExecuteManLock          = 35,
    CrstSystemDomain            = 40,
    CrstAppDomainHandleTable    = 45,        // A lock to protect the large heap handle table at the app domain level
    CrstGlobalStrLiteralMap     = 45,        // A lock to protect the global string literal map.
    CrstAppDomainStrLiteralMap  = 50,        // A lock to protect the app domain specific string literal map.
    CrstDomainLocalBlock        = 50,
    CrstCompilationDomain       = 50,
    CrstClassInit               = 55,        // Class initializers
    CrstThreadDomainLocalStore  = 56,        // used to update the thread's domain local store list
    CrstEventStore              = 57,        // A lock to protect the store for events used for Object::Wait
    CrstCorFileMap              = 59,        //   we must prevent adding and removing assemblies concurrently to an appdomain
    CrstAssemblyLoader          = 60,        // DO NOT place another crst at this level
    CrstSharedBaseDomain        = 63,      
    CrstSystemBaseDomain        = 64,      
    CrstBaseDomain              = 65,      
    CrstCtxVTable               = 70,        // increase the size of context proxy vtable
    CrstClassHash               = 75,
    CrstClassloaderRequestQueue = 80,
    CrstCtxMgr                  = 85,        // CtxMgr manages list of Contexts
    CrstRemoting                = 90,        // Remoting infrastructure
    CrstInterop                 = 90,
    CrstClassFactInfoHash       = 95,        // Class factory hash lookup
    CrstStartup                 = 100,       // Initializes and uninitializes the EE
    
    // TODO cwb: X86 already avoids Crsts for synchronized code blocks.  Move the
    // non-X86 over to a similar plan and stop using these hierarchical locks.
    CrstSynchronized            = MAXSHORT, // an object is Synchronized

    CrstInterfaceVTableMap      = 10,       // synchronize access to InterfaceVTableMap
};

class Crst;

// The CRST.
class BaseCrst
{
    friend Crst;
    friend struct MEMBER_OFFSET_INFO(Crst);
    public:

    //-----------------------------------------------------------------
    // Initialize critical section
    //-----------------------------------------------------------------
    VOID Init(LPCSTR szTag, CrstLevel crstlevel, BOOL fAllowReentrancy, BOOL fAllowSameLevel)
    {
        InitializeCriticalSection(&m_criticalsection);
        DebugInit(szTag, crstlevel, fAllowReentrancy, fAllowSameLevel);
    }

    //-----------------------------------------------------------------
    // Clean up critical section
    //-----------------------------------------------------------------
    void Destroy()
    {
        // If this assert fired, a crst got deleted while some thread
        // still owned it.  This can happen if the process detaches from
        // our DLL.
#ifdef _DEBUG
        DWORD holderthreadid = m_holderthreadid;
        _ASSERTE(holderthreadid == 0 || g_fProcessDetach || g_fEEShutDown);
#endif

        DeleteCriticalSection(&m_criticalsection);
        
        LOG((LF_SYNC, INFO3, "Deleting 0x%x\n", this));
        DebugDestroy();
    }

    
    //-----------------------------------------------------------------
    // Acquire the lock.
    //-----------------------------------------------------------------
    void Enter();
    
    //-----------------------------------------------------------------
    // Release the lock.
    //-----------------------------------------------------------------
    void Leave()
    {
#ifdef _DEBUG
        _ASSERTE(OwnedByCurrentThread());
        _ASSERTE(m_entercount > 0);
        m_entercount--;
        if (!m_entercount) {
            m_holderthreadid = 0;
        }
        PreLeave ();

        char buffer[100];
        sprintf(buffer, "Leave in crst.h - %s", m_tag);
        
#endif //_DEBUG
        CRSTBUNLOCKCOUNTINCL();
        LeaveCriticalSection(&m_criticalsection);
#ifdef _DEBUG
        LOCKCOUNTDECL(buffer);
        CRSTEUNLOCKCOUNTINCL();
#endif
    }
    
    
    
#ifdef _DEBUG
    //-----------------------------------------------------------------
    // Check if attempting to take the lock would violate level order.
    //-----------------------------------------------------------------
    BOOL IsSafeToTake();
    
    //-----------------------------------------------------------------
    // Is the current thread the owner?
    //-----------------------------------------------------------------
    BOOL OwnedByCurrentThread()
    {
        return m_holderthreadid == GetCurrentThreadId();
    }
    
    //-----------------------------------------------------------------
    // For clients who want to assert whether they are in or out of the

    // region.
    //-----------------------------------------------------------------
    UINT GetEnterCount()
    {
        return m_entercount;
    }

#endif //_DEBUG
    
protected:    

#ifdef _DEBUG
    void DebugInit(LPCSTR szTag, CrstLevel crstlevel, BOOL fAllowReentrancy, BOOL fAllowSameLevel);
    void DebugDestroy();
#else
    void DebugInit(LPCSTR szTag, CrstLevel crstlevel, BOOL fAllowReentrancy, BOOL fAllowSameLevel) {}
    void DebugDestroy() {}
#endif


    CRITICAL_SECTION    m_criticalsection;
#ifdef _DEBUG
    enum {
        CRST_REENTRANCY = 0x1,
        CRST_SAMELEVEL = 0x2
    };

    char                m_tag[20];          // descriptive string 
    CrstLevel           m_crstlevel;        // what level is the crst in?
    DWORD               m_holderthreadid;   // current holder (or NULL)
    UINT                m_entercount;       // # of unmatched Enters
    DWORD               m_flags;            // Re-entrancy and same level
    BaseCrst           *m_next;             // link for global linked list
    BaseCrst           *m_prev;             // link for global linked list

    // Check for dead lock situation.
    BOOL                m_heldInSuspension; // may be held while the thread is
                                            // suspended.
    BOOL                m_enterInCoopGCMode;
    ULONG               m_ulReadyForSuspensionCount;
    
    void                PostEnter ();
    void                PreEnter ();
    void                PreLeave  ();
#endif //_DEBUG
    
    
    // Win 95 doesn't have TryEnterCriticalSection, so we call through a static
    // data member initialized at run time.
    // The stuff below is for doing this unfortunate complication
    typedef  WINBASEAPI BOOL WINAPI TTryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
    static  TTryEnterCriticalSection *m_pTryEnterCriticalSection;
    static TTryEnterCriticalSection *GetTryEnterCriticalSection();

private:
    void IncThreadLockCount ();
};


// The CRST.
class Crst : public BaseCrst
{
    friend BaseCrst;
    friend struct MEMBER_OFFSET_INFO(Crst);

    public:
    void *operator new(size_t size, void *pInPlace)
    {
        return pInPlace;
    }
    
    void operator delete(void *p)
    {
    }
    
    //-----------------------------------------------------------------
    // Constructor for non-reentrant crsts.
    //-----------------------------------------------------------------
    Crst(LPCSTR szTag, CrstLevel crstlevel) 
    {
        Init(szTag, crstlevel, FALSE, FALSE);
    }
    
    //-----------------------------------------------------------------
    // Constructor for reentrable crsts.
    //-----------------------------------------------------------------
    Crst(LPCSTR szTag, CrstLevel crstlevel, BOOL fAllowReentrancy, BOOL fAllowSameLevel)
    {
        Init(szTag, crstlevel, fAllowReentrancy, fAllowSameLevel); 
    }
    

    //-----------------------------------------------------------------
    // Destructor.
    //-----------------------------------------------------------------
    ~Crst()
    {
        Destroy();
    }

#ifdef _DEBUG
    // This Crst serves as a head-node for double-linked list of crsts.
    // We use its embedded critical-section to guard insertion and
    // deletion into this list.
    static Crst *m_pDummyHeadCrst;
    static BYTE m_pDummyHeadCrstMemory[sizeof(BaseCrst)];

    static void InitializeDebugCrst()
    {
        m_pDummyHeadCrst = new (&m_pDummyHeadCrstMemory) Crst("DummyHeadCrst", CrstDummy);
    }

#ifdef SHOULD_WE_CLEANUP
    static void DeleteDebugCrst()
    {
        delete m_pDummyHeadCrst;
    }
#endif /* SHOULD_WE_CLEANUP */

    
#endif
    
};

__inline BOOL IsOwnerOfCrst(LPVOID lock)
{
#ifdef _DEBUG
    return ((Crst*)lock)->OwnedByCurrentThread();
#else
    // This function should not be called on free build.
    DebugBreak();
    return TRUE;
#endif
}

__inline BOOL IsOwnerOfOSCrst(LPVOID lock)
{
#ifdef _DEBUG
    volatile static int bOnW95=-1;
    if (bOnW95==-1)
        bOnW95=RunningOnWin95();

    if (bOnW95) {
        // We can not determine if the current thread owns CRITICAL_SECTION on Win9x
        return TRUE;
    }
    else {
        CRITICAL_SECTION *pCrit = (CRITICAL_SECTION*)lock;
        return (size_t)pCrit->OwningThread == (size_t) GetCurrentThreadId();
    }
#else
    // This function should not be called on free build.
    DebugBreak();
    return TRUE;
#endif
}
#endif  __crst_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\coverage.cpp ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
#include "common.h"
#include "coverage.h"


//
//	This is part of the runtime test teams Code Coverge Tools. Due to the special nature of MSCORLIB.dll
//	We have to work around several issues (Like the initilization of the Secutiry Manager) to be able to get
//	Code coverage on mscorlib.dll
//
//	If you need more info on the function please see Craig Schertz (cschertz)
//

unsigned __int64  COMCoverage::nativeCoverBlock(_CoverageArgs *args)
{
	HMODULE ilcovnat = 0;
	if (args->id == 1)
	{
		ilcovnat = WszLoadLibrary(L"Ilcovnat.dll");

		if (ilcovnat)
		{
			return (unsigned __int64)GetProcAddress(ilcovnat, "CoverBlockNative");
		}
	}
	else if (args->id == 2)
	{
		ilcovnat = WszLoadLibrary(L"Ilcovnat.dll");

		if (ilcovnat)
		{
			return (unsigned __int64)GetProcAddress(ilcovnat, "BBInstrProbe");
		}
	}
	else if (args->id == 3)
	{
		ilcovnat = WszLoadLibrary(L"Ilcovnat.dll");
		if (ilcovnat)
		{
			return (unsigned __int64)GetProcAddress(ilcovnat, "CoverMonRegisterMscorlib");
		}
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\crst.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  CRST.CPP:
 *
 */

#include "common.h"

#include "crst.h"
#include "log.h"


// Win 95 doesn't have TryEnterCriticalSection, so we call through a static
// data member initialized at run time.
// The stuff below is for doing this unfortunate complication

BaseCrst::TTryEnterCriticalSection *BaseCrst::m_pTryEnterCriticalSection = Crst::GetTryEnterCriticalSection();

BOOL WINAPI OurTryEnterCriticalSection( LPCRITICAL_SECTION lpCriticalSection )
{
    LOCKCOUNTINCL("OurTryEnterCriticalSection in crst.cpp");
#undef EnterCriticalSection
    // We wrap EnterCriticalSection to increment our per-thread lock count.
    // We will increment this count after the m_pTryEnterCriticalSection call,
    // hence we do not want to inc the counter here.
    EnterCriticalSection(lpCriticalSection);
#define EnterCriticalSection EE_EnterCriticalSection
    return  TRUE;
}

//-----------------------------------------------------------------
// Acquire the lock.
//-----------------------------------------------------------------
void BaseCrst::Enter()
{
#ifdef _DEBUG
    PreEnter ();
#endif
    _ASSERTE(IsSafeToTake() || g_fEEShutDown);

#ifdef _DEBUG
    char buffer[100];
    sprintf(buffer, "Enter in crst.h - %s", m_tag);
    CRSTBLOCKCOUNTINCL();
    LOCKCOUNTINCL(buffer);
#endif

	static int bOnW95=-1;
	if (bOnW95==-1)
		bOnW95=RunningOnWin95();
    // Try spinning and yielding before eventually blocking.
    // The limit of 10 is largely arbitrary - feel free to tune if you have evidence
    // you're making things better - petersol
    for (int iter = 0; iter < 10; iter++)
    {
        DWORD i = 50;
        do
        {
            if (  (bOnW95||m_criticalsection.LockCount == -1 || 
                    (size_t)m_criticalsection.OwningThread == (size_t) GetCurrentThreadId())
                && m_pTryEnterCriticalSection(&m_criticalsection))
            {
				IncThreadLockCount();
                goto entered;
            }

            if (g_SystemInfo.dwNumberOfProcessors <= 1)
            {
                break;
            }
            // Delay by approximately 2*i clock cycles (Pentium III).
            // This is brittle code - future processors may of course execute this
            // faster or slower, and future code generators may eliminate the loop altogether.
            // The precise value of the delay is not critical, however, and I can't think
            // of a better way that isn't machine-dependent - petersol.
            int sum = 0;
            for (int delayCount = i; --delayCount; ) 
			{
                sum += delayCount;
				pause();			// indicate to the processor that we are spining 
			}
            if (sum == 0)
            {
                // never executed, just to fool the compiler into thinking sum is live here,
                // so that it won't optimize away the loop.
                static char dummy;
                dummy++;
            }
            // exponential backoff: wait 3 times as long in the next iteration
            i = i*3;
        }
        while (i < 20000*g_SystemInfo.dwNumberOfProcessors);

        extern BOOL __SwitchToThread (DWORD dwSleepMSec);
        __SwitchToThread(0);
    }
    // We've tried hard to enter - we need to eventually block to avoid wasting too much cpu
    // time.
    EnterCriticalSection(&m_criticalsection);
entered:
    CRSTELOCKCOUNTINCL();
#ifdef _DEBUG
    m_holderthreadid = GetCurrentThreadId();
    m_entercount++;
    PostEnter ();
#endif
}
    
BaseCrst::TTryEnterCriticalSection *BaseCrst::GetTryEnterCriticalSection()
{
    BaseCrst::TTryEnterCriticalSection *result = NULL;

#ifdef PLATFORM_WIN32
    HINSTANCE   hKernel32;         // The handle to kernel32.dll

    OnUnicodeSystem(); // initialize stuff for WszGetModuleHandle to work

	if (RunningOnWin95())
		return OurTryEnterCriticalSection;

    hKernel32 = WszGetModuleHandle(L"KERNEL32.DLL");
    if (hKernel32)
    {
        // we got the handle now let's get the address
        result = (BaseCrst::TTryEnterCriticalSection *)::GetProcAddress(hKernel32, "TryEnterCriticalSection");
    }
#endif // PLATFORM_WIN32

    if (NULL == result)
      result = OurTryEnterCriticalSection;
    
    return result;
}

void BaseCrst::IncThreadLockCount ()
{
    INCTHREADLOCKCOUNT();
}

#ifdef _DEBUG
void BaseCrst::PreEnter()
{
    if (g_pThreadStore->IsCrstForThreadStore(this))
        return;
    
    Thread* pThread = GetThread();
    if (pThread && m_heldInSuspension && pThread->PreemptiveGCDisabled())
        _ASSERTE (!"Deallock situation 1: lock may be held during GC, but not entered in PreemptiveGC mode");
}

void BaseCrst::PostEnter()
{
    if (g_pThreadStore->IsCrstForThreadStore(this))
        return;
    
    Thread* pThread = GetThread();
    if (pThread)
    {
        if (!m_heldInSuspension)
            m_ulReadyForSuspensionCount =
                pThread->GetReadyForSuspensionCount();
        if (!m_enterInCoopGCMode)
            m_enterInCoopGCMode = pThread->PreemptiveGCDisabled();
    }
}

void BaseCrst::PreLeave()
{
    if (g_pThreadStore->IsCrstForThreadStore(this))
        return;
    
    Thread* pThread = GetThread();
    if (pThread)
    {
        if (!m_heldInSuspension &&
            m_ulReadyForSuspensionCount !=
            pThread->GetReadyForSuspensionCount())
        {
            m_heldInSuspension = TRUE;
        }
        if (m_heldInSuspension && m_enterInCoopGCMode)
        {
            // The GC thread calls into the handle table to scan handles.  Sometimes
            // the GC thread is a random application thread that is provoking a GC.
            // Sometimes the GC thread is a secret GC thread (server or concurrent).
            // This can happen if a DllMain notification executes managed code, as in
            // an IJW scenario.  In the case of the secret thread, we will take this
            // lock in preemptive mode.
            //
            // Normally this would be a dangerous combination.  But, in the case of
            // this particular Crst, we only ever take the critical section on a thread
            // which is identified as the GC thread and which is therefore not subject
            // to GC suspensions.
            //
            // The easiest way to handle this is to weaken the assert for this precise
            // case.  The alternative would be to have a notion of locks that are
            // only ever taken by threads identified as the GC thread.
            if (m_crstlevel != CrstHandleTable ||
                pThread != g_pGCHeap->GetGCThread())
            {
                _ASSERTE (!"Deadlock situation 2: lock may be held during GC, but were not entered in PreemptiveGC mode earlier");
            }
        }
    }
}

Crst* Crst::m_pDummyHeadCrst = 0;
BYTE  Crst::m_pDummyHeadCrstMemory[sizeof(Crst)];

void BaseCrst::DebugInit(LPCSTR szTag, CrstLevel crstlevel, BOOL fAllowReentrancy, BOOL fAllowSameLevel)
{
    _ASSERTE((sizeof(BaseCrst) == sizeof(Crst)) && "m_pDummyHeadCrstMemory will not be large enough");

    if(szTag) {
        int lgth = (int)strlen(szTag) + 1;
        lgth = lgth >  sizeof(m_tag)/sizeof(m_tag[0]) ? sizeof(m_tag)/sizeof(m_tag[0]) : lgth;
        memcpy(m_tag, szTag, lgth);

        // Null terminate the string in case it got truncated
        m_tag[lgth-1] = 0;
    }
    
    m_crstlevel        = crstlevel;
    m_holderthreadid   = 0;
    m_entercount       = 0;
    m_flags = 0;
    if(fAllowReentrancy) m_flags |= CRST_REENTRANCY;
    if(fAllowSameLevel)  m_flags |= CRST_SAMELEVEL;
    
    
    LOG((LF_SYNC, INFO3, "ConstructCrst with this:0x%x\n", this));
    if ((BYTE*) this == Crst::m_pDummyHeadCrstMemory) {
        // Set list to empty.
        m_next = m_prev = this;
    } else {
        // Link this crst into the global list.
        if(Crst::m_pDummyHeadCrst) {
        LOCKCOUNTINCL("DebugInit in crst.cpp");								\
            EnterCriticalSection(&(Crst::m_pDummyHeadCrst->m_criticalsection));
            m_next = Crst::m_pDummyHeadCrst;
            m_prev = Crst::m_pDummyHeadCrst->m_prev;
        m_prev->m_next = this;
            Crst::m_pDummyHeadCrst->m_prev = this;
            LeaveCriticalSection(&(Crst::m_pDummyHeadCrst->m_criticalsection));
        LOCKCOUNTDECL("DebugInit in crst.cpp");								\
        }
        _ASSERTE(this != m_next);
        _ASSERTE(this != m_prev);
    }

    m_heldInSuspension = FALSE;
    m_enterInCoopGCMode = FALSE;
}

void BaseCrst::DebugDestroy()
{
    FillMemory(&m_criticalsection, sizeof(m_criticalsection), 0xcc);
    m_holderthreadid = 0xcccccccc;
    m_entercount     = 0xcccccccc;
    
    if ((BYTE*) this == Crst::m_pDummyHeadCrstMemory) {
        
        // m_DummyHeadCrst dies when global destructors are called.
        // It should be the last one to go.
        for (BaseCrst *pcrst = Crst::m_pDummyHeadCrst->m_next;
             pcrst != Crst::m_pDummyHeadCrst;
             pcrst = pcrst->m_next) {
            // TEXT and not L"..." as the JIT uses this file and it is still ASCII
            DbgWriteEx(TEXT("WARNING: Crst \"%hs\" at 0x%lx was leaked.\n"),
                       pcrst->m_tag,
                       (size_t)pcrst);
        }
        Crst::m_pDummyHeadCrst = NULL;
    } else {
        
        if(Crst::m_pDummyHeadCrst) {
        // Unlink from global crst list.
        LOCKCOUNTINCL("DebugDestroy in crst.cpp");								\
            EnterCriticalSection(&(Crst::m_pDummyHeadCrst->m_criticalsection));
        m_next->m_prev = m_prev;
        m_prev->m_next = m_next;
            m_next = (BaseCrst*)POISONC;
            m_prev = (BaseCrst*)POISONC;
            LeaveCriticalSection(&(Crst::m_pDummyHeadCrst->m_criticalsection));
        LOCKCOUNTDECL("DebugDestroy in crst.cpp");								\
        }
    }
}
    
//-----------------------------------------------------------------
// Check if attempting to take the lock would violate level order.
//-----------------------------------------------------------------
BOOL BaseCrst::IsSafeToTake()
{
    // If mscoree.dll is being detached
    if (g_fProcessDetach)
        return TRUE;

    DWORD threadId = GetCurrentThreadId();

    if (m_holderthreadid == threadId)
    {
        // If we already hold it, we can't violate level order.
        // Check if client wanted to allow reentrancy.
        if ((m_flags & CRST_REENTRANCY) == 0)
        {
            LOG((LF_SYNC, INFO3, "Crst Reentrancy violation on %s\n", m_tag));
        }
        return ((m_flags & CRST_REENTRANCY) != 0);
    }

    // @future: right now, we have to visit every crst ever created
    // to determine safeness: if this overhead becomes really
    // unbearable even in debug, we can switch to storing
    // an array of owned crsts in the Thread object: however, the current
    // approach allows Crsts to be used even without a Thread which
    // might be useful.

    // See if the current thread already owns a lower or sibling lock.
    BOOL fSafe = TRUE;
    if(Crst::m_pDummyHeadCrst) {
    LOCKCOUNTINCL("IsSafeToTake in crst.cpp");								\
        EnterCriticalSection(&(Crst::m_pDummyHeadCrst->m_criticalsection));
        BaseCrst *pcrst = Crst::m_pDummyHeadCrst->m_next;
        while ((BYTE*) pcrst != Crst::m_pDummyHeadCrstMemory)
    {
        if (pcrst->m_holderthreadid == threadId && 
            (pcrst->m_crstlevel < m_crstlevel || 
             (pcrst->m_crstlevel == m_crstlevel && (m_flags & CRST_SAMELEVEL) == 0)))
        {
            fSafe = FALSE;  //no need to search any longer.
            LOG((LF_SYNC, INFO3, "Crst Level violation between %s and %s\n",
                 m_tag, pcrst->m_tag));
            break;
        }
        pcrst = pcrst->m_next;
    }
        LeaveCriticalSection(&(Crst::m_pDummyHeadCrst->m_criticalsection));
    LOCKCOUNTDECL("IsSafeToTake in crst.cpp");								\
    }
    return fSafe;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ctxtcall.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Dec 06 11:12:56 2000
 */
/* Compiler settings for ctxtcall.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ctxtcall_h__
#define __ctxtcall_h__

/* Forward Declarations */ 

#ifndef __IContextCallback_FWD_DEFINED__
#define __IContextCallback_FWD_DEFINED__
typedef interface IContextCallback IContextCallback;
#endif 	/* __IContextCallback_FWD_DEFINED__ */


#ifndef __ITeardownNotification_FWD_DEFINED__
#define __ITeardownNotification_FWD_DEFINED__
typedef interface ITeardownNotification ITeardownNotification;
#endif 	/* __ITeardownNotification_FWD_DEFINED__ */


#ifndef __IComApartmentState_FWD_DEFINED__
#define __IComApartmentState_FWD_DEFINED__
typedef interface IComApartmentState IComApartmentState;
#endif 	/* __IComApartmentState_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_ctxtcall_0000 */
/* [local] */ 

typedef struct tagComCallData
    {
    DWORD dwDispid;
    DWORD dwReserved;
    void __RPC_FAR *pUserDefined;
    }	ComCallData;



extern RPC_IF_HANDLE __MIDL_itf_ctxtcall_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctxtcall_0000_v0_0_s_ifspec;

#ifndef __IContextCallback_INTERFACE_DEFINED__
#define __IContextCallback_INTERFACE_DEFINED__

/* interface IContextCallback */
/* [unique][uuid][object][local] */ 

typedef /* [ref] */ HRESULT ( __stdcall __RPC_FAR *PFNCONTEXTCALL )( 
    ComCallData __RPC_FAR *pParam);


EXTERN_C const IID IID_IContextCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001da-0000-0000-C000-000000000046")
    IContextCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ContextCallback( 
            /* [in] */ PFNCONTEXTCALL pfnCallback,
            /* [in] */ ComCallData __RPC_FAR *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ int iMethod,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ContextCallback )( 
            IContextCallback __RPC_FAR * This,
            /* [in] */ PFNCONTEXTCALL pfnCallback,
            /* [in] */ ComCallData __RPC_FAR *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ int iMethod,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        END_INTERFACE
    } IContextCallbackVtbl;

    interface IContextCallback
    {
        CONST_VTBL struct IContextCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextCallback_ContextCallback(This,pfnCallback,pParam,riid,iMethod,pUnk)	\
    (This)->lpVtbl -> ContextCallback(This,pfnCallback,pParam,riid,iMethod,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextCallback_ContextCallback_Proxy( 
    IContextCallback __RPC_FAR * This,
    /* [in] */ PFNCONTEXTCALL pfnCallback,
    /* [in] */ ComCallData __RPC_FAR *pParam,
    /* [in] */ REFIID riid,
    /* [in] */ int iMethod,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB IContextCallback_ContextCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextCallback_INTERFACE_DEFINED__ */


#ifndef __ITeardownNotification_INTERFACE_DEFINED__
#define __ITeardownNotification_INTERFACE_DEFINED__

/* interface ITeardownNotification */
/* [unique][object][local][uuid] */ 


EXTERN_C const IID IID_ITeardownNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a85e0fb6-8bf4-4614-b164-7b43ef43f5be")
    ITeardownNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TeardownHint( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITeardownNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITeardownNotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITeardownNotification __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITeardownNotification __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TeardownHint )( 
            ITeardownNotification __RPC_FAR * This);
        
        END_INTERFACE
    } ITeardownNotificationVtbl;

    interface ITeardownNotification
    {
        CONST_VTBL struct ITeardownNotificationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITeardownNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITeardownNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITeardownNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITeardownNotification_TeardownHint(This)	\
    (This)->lpVtbl -> TeardownHint(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITeardownNotification_TeardownHint_Proxy( 
    ITeardownNotification __RPC_FAR * This);


void __RPC_STUB ITeardownNotification_TeardownHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITeardownNotification_INTERFACE_DEFINED__ */


#ifndef __IComApartmentState_INTERFACE_DEFINED__
#define __IComApartmentState_INTERFACE_DEFINED__

/* interface IComApartmentState */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IComApartmentState;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7e220139-8dde-47ef-b181-08be603efd75")
    IComApartmentState : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterForTeardownHint( 
            /* [in] */ ITeardownNotification __RPC_FAR *pT,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG_PTR __RPC_FAR *pCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterForTeardownHint( 
            /* [in] */ ULONG_PTR cookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComApartmentStateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComApartmentState __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComApartmentState __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComApartmentState __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterForTeardownHint )( 
            IComApartmentState __RPC_FAR * This,
            /* [in] */ ITeardownNotification __RPC_FAR *pT,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG_PTR __RPC_FAR *pCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterForTeardownHint )( 
            IComApartmentState __RPC_FAR * This,
            /* [in] */ ULONG_PTR cookie);
        
        END_INTERFACE
    } IComApartmentStateVtbl;

    interface IComApartmentState
    {
        CONST_VTBL struct IComApartmentStateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComApartmentState_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComApartmentState_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComApartmentState_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComApartmentState_RegisterForTeardownHint(This,pT,dwFlags,pCookie)	\
    (This)->lpVtbl -> RegisterForTeardownHint(This,pT,dwFlags,pCookie)

#define IComApartmentState_UnregisterForTeardownHint(This,cookie)	\
    (This)->lpVtbl -> UnregisterForTeardownHint(This,cookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComApartmentState_RegisterForTeardownHint_Proxy( 
    IComApartmentState __RPC_FAR * This,
    /* [in] */ ITeardownNotification __RPC_FAR *pT,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ULONG_PTR __RPC_FAR *pCookie);


void __RPC_STUB IComApartmentState_RegisterForTeardownHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComApartmentState_UnregisterForTeardownHint_Proxy( 
    IComApartmentState __RPC_FAR * This,
    /* [in] */ ULONG_PTR cookie);


void __RPC_STUB IComApartmentState_UnregisterForTeardownHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComApartmentState_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\customattribute.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _CUSTOMATTRIBUTE_H_
#define _CUSTOMATTRIBUTE_H_

#include "fcall.h"

class COMCustomAttribute
{
public:
    struct _GetCustomAttributeListArgs {
        DECLARE_ECALL_I4_ARG(INT32, level); 
        DECLARE_ECALL_OBJECTREF_ARG(CUSTOMATTRIBUTEREF, caItem);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, caType);
        DECLARE_ECALL_PTR_ARG(LPVOID, module); 
        DECLARE_ECALL_I4_ARG(DWORD, token); 
    };

    struct _IsCADefinedArgs {
        DECLARE_ECALL_I4_ARG(DWORD, token);
        DECLARE_ECALL_PTR_ARG(LPVOID, module); 
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, caType); 
    };

    struct _CreateCAObjectArgs {
        DECLARE_ECALL_OBJECTREF_ARG(CUSTOMATTRIBUTEREF, refThis);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, assembly); 
        DECLARE_ECALL_PTR_ARG(INT32*, propNum); 
    };

    struct _GetDataForPropertyOrFieldArgs {
        DECLARE_ECALL_OBJECTREF_ARG(CUSTOMATTRIBUTEREF, refThis);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, isLast); 
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, type); 
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, value); 
        DECLARE_ECALL_PTR_ARG(BOOL*, isProperty); 
    };

    // custom attributes utility functions
    static FCDECL2(INT32, GetMemberToken, BaseObjectWithCachedData *pMember, INT32 memberType);
    static FCDECL2(LPVOID, GetMemberModule, BaseObjectWithCachedData *pMember, INT32 memberType);
    static FCDECL1(INT32, GetAssemblyToken, AssemblyBaseObject *assembly);
    static FCDECL1(LPVOID, GetAssemblyModule, AssemblyBaseObject *assembly);
    static FCDECL1(INT32, GetModuleToken, ReflectModuleBaseObject *module);
    static FCDECL1(LPVOID, GetModuleModule, ReflectModuleBaseObject *module);
    static FCDECL1(INT32, GetMethodRetValueToken, BaseObjectWithCachedData *method);

    static INT32 __stdcall IsCADefined(_IsCADefinedArgs *args);

    /*OBJECTREF*/
    static LPVOID __stdcall GetCustomAttributeList(_GetCustomAttributeListArgs*);

    /*OBJECTREF*/
    static LPVOID __stdcall CreateCAObject(_CreateCAObjectArgs*);

    /*STRINGREF*/
    static LPVOID __stdcall GetDataForPropertyOrField(_GetDataForPropertyOrFieldArgs*);
    
    // a list of methods usable from inside the runtime itself
public:
    static INT32 IsDefined(Module *pModule, 
                           mdToken token, 
                           TypeHandle attributeClass, 
                           BOOL checkAccess = FALSE);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\custommarshalerinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Custom marshaler information used when marshaling
**          a parameter with a custom marshaler. 
**  
**      //  %%Created by: dmortens
===========================================================*/

#ifndef _CUSTOMMARSHALERINFO_H_
#define _CUSTOMMARSHALERINFO_H_


#include "vars.hpp"
#include "list.h"


// This enumeration is used to retrieve a method desc from CustomMarshalerInfo::GetCustomMarshalerMD().
enum EnumCustomMarshalerMethods
{
    CustomMarshalerMethods_MarshalNativeToManaged = 0,
    CustomMarshalerMethods_MarshalManagedToNative,
    CustomMarshalerMethods_CleanUpNativeData,
    CustomMarshalerMethods_CleanUpManagedData,
    CustomMarshalerMethods_GetNativeDataSize,
    CustomMarshalerMethods_GetInstance,
    CustomMarshalerMethods_LastMember
};


class CustomMarshalerInfo
{
public:
    // Constructor and destructor.
    CustomMarshalerInfo(BaseDomain *pDomain, TypeHandle hndCustomMarshalerType, TypeHandle hndManagedType, LPCUTF8 strCookie, DWORD cCookieStrBytes);
    ~CustomMarshalerInfo();

    // CustomMarshalerInfo's are always allocated on the loader heap so we need to redefine
    // the new and delete operators to ensure this.
    void *operator new(size_t size, LoaderHeap *pHeap);
    void operator delete(void *pMem);

    // Helpers used to invoke the different methods in the ICustomMarshaler interface.
    OBJECTREF           InvokeMarshalNativeToManagedMeth(void *pNative);
    void               *InvokeMarshalManagedToNativeMeth(OBJECTREF MngObj);
    void                InvokeCleanUpNativeMeth(void *pNative);
    void                InvokeCleanUpManagedMeth(OBJECTREF MngObj);

    // Accessors.
    int                 GetNativeSize() { return m_NativeSize; }
    int                 GetManagedSize() { return m_hndManagedType.GetSize(); }
    TypeHandle          GetManagedType() { return m_hndManagedType; }
    BOOL                IsDataByValue() { return m_bDataIsByValue; }
    OBJECTHANDLE        GetCustomMarshaler() { return m_hndCustomMarshaler; }

    // Helper function to retrieve a custom marshaler method desc.
    static MethodDesc  *GetCustomMarshalerMD(EnumCustomMarshalerMethods Method, TypeHandle hndCustomMarshalertype); 

    // Link used to contain this CM info in a linked list.
    SLink               m_Link;

private:
    int                 m_NativeSize;
    TypeHandle          m_hndManagedType;
    OBJECTHANDLE        m_hndCustomMarshaler;
    MethodDesc         *m_pMarshalNativeToManagedMD;
    MethodDesc         *m_pMarshalManagedToNativeMD;
    MethodDesc         *m_pCleanUpNativeDataMD;
    MethodDesc         *m_pCleanUpManagedDataMD;
    BOOL                m_bDataIsByValue;
};


typedef SList<CustomMarshalerInfo, offsetof(CustomMarshalerInfo, m_Link), true> CMINFOLIST;


class EECMHelperHashtableKey
{
public:
    DWORD           m_cMarshalerTypeNameBytes;
    LPCSTR          m_strMarshalerTypeName;
    DWORD           m_cCookieStrBytes;
    LPCSTR          m_strCookie;
    BOOL            m_bSharedHelper;

    EECMHelperHashtableKey(DWORD cMarshalerTypeNameBytes, LPCSTR strMarshalerTypeName, DWORD cCookieStrBytes, LPCSTR strCookie, BOOL bSharedHelper) 
    : m_cMarshalerTypeNameBytes(cMarshalerTypeNameBytes)
    , m_strMarshalerTypeName(strMarshalerTypeName)
    , m_cCookieStrBytes(cCookieStrBytes)
    , m_strCookie(strCookie)
    , m_bSharedHelper(bSharedHelper) {}

    inline DWORD GetMarshalerTypeNameByteCount() const
    { return m_cMarshalerTypeNameBytes; }
    inline LPCSTR GetMarshalerTypeName() const
    { return m_strMarshalerTypeName; }
    inline LPCSTR GetCookieString() const
    { return m_strCookie; }
    inline ULONG GetCookieStringByteCount() const
    { return m_cCookieStrBytes; }
    inline BOOL IsSharedHelper() const
    { return m_bSharedHelper; }
};


class EECMHelperHashtableHelper
{
public:
    static EEHashEntry_t * AllocateEntry(EECMHelperHashtableKey *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void            DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL            CompareKeys(EEHashEntry_t *pEntry, EECMHelperHashtableKey *pKey);
    static DWORD           Hash(EECMHelperHashtableKey *pKey);
};


typedef EEHashTable<EECMHelperHashtableKey *, EECMHelperHashtableHelper, TRUE> EECMHelperHashTable;


class CustomMarshalerHelper
{
public:
    // Helpers used to invoke the different methods in the ICustomMarshaler interface.
    OBJECTREF           InvokeMarshalNativeToManagedMeth(void *pNative);
    void               *InvokeMarshalManagedToNativeMeth(OBJECTREF MngObj);
    void                InvokeCleanUpNativeMeth(void *pNative);
    void                InvokeCleanUpManagedMeth(OBJECTREF MngObj);

    // Accessors.
    int                 GetNativeSize() { return GetCustomMarshalerInfo()->GetNativeSize(); }
    int                 GetManagedSize() { return GetCustomMarshalerInfo()->GetManagedSize(); }
    TypeHandle          GetManagedType() { return GetCustomMarshalerInfo()->GetManagedType(); }
    BOOL                IsDataByValue() { return GetCustomMarshalerInfo()->IsDataByValue(); }

    virtual void Dispose( void ) = 0;

    // Helper function to retrieve the custom marshaler object.
    virtual CustomMarshalerInfo *GetCustomMarshalerInfo() = 0;

protected:
    ~CustomMarshalerHelper( void )
    {
    }
};


class NonSharedCustomMarshalerHelper : public CustomMarshalerHelper
{
public:
    // Constructor.
    NonSharedCustomMarshalerHelper(CustomMarshalerInfo *pCMInfo) : m_pCMInfo(pCMInfo) {}

    // CustomMarshalerHelpers's are always allocated on the loader heap so we need to redefine
    // the new and delete operators to ensure this.
    void *operator new(size_t size, LoaderHeap *pHeap);
    void operator delete(void *pMem);

    virtual void Dispose( void )
    {
        delete (NonSharedCustomMarshalerHelper*)this;
    }

protected:
    // Helper function to retrieve the custom marshaler object.
    virtual CustomMarshalerInfo *GetCustomMarshalerInfo() { return m_pCMInfo; }

private:
    CustomMarshalerInfo *m_pCMInfo;
};


class SharedCustomMarshalerHelper : public CustomMarshalerHelper
{
public:
    // Constructor.
    SharedCustomMarshalerHelper(Assembly *pAssembly, TypeHandle hndManagedType, LPCUTF8 strMarshalerTypeName, DWORD cMarshalerTypeNameBytes, LPCUTF8 strCookie, DWORD cCookieStrBytes);

    // CustomMarshalerHelpers's are always allocated on the loader heap so we need to redefine
    // the new and delete operators to ensure this.
    void *operator new(size_t size, LoaderHeap *pHeap);
    void operator delete(void *pMem);

    // Accessors.
    inline Assembly *GetAssembly() { return m_pAssembly; }
    inline TypeHandle GetManagedType() { return m_hndManagedType; }
    inline DWORD GetMarshalerTypeNameByteCount() { return m_cMarshalerTypeNameBytes; }
    inline LPCSTR GetMarshalerTypeName() { return m_strMarshalerTypeName; }
    inline LPCSTR GetCookieString() { return m_strCookie; }
    inline ULONG GetCookieStringByteCount() { return m_cCookieStrBytes; }

    virtual void Dispose( void )
    {
        delete (SharedCustomMarshalerHelper*)this;
    }

protected:
    // Helper function to retrieve the custom marshaler object.
    virtual CustomMarshalerInfo *GetCustomMarshalerInfo();

private:
    Assembly       *m_pAssembly;
    TypeHandle      m_hndManagedType;
    DWORD           m_cMarshalerTypeNameBytes;
    LPCUTF8         m_strMarshalerTypeName;
    DWORD           m_cCookieStrBytes;
    LPCUTF8         m_strCookie;
};


#endif // _CUSTOMMARSHALERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dataimage.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#include "dataimage.h"


DataImage::DataImage(Module *module, IDataStore *store)
  : m_module(module), m_dataStore(store),
    m_rangeTree(), m_pool(sizeof(MapEntry)),
    m_imageBaseMemory(NULL)
{
    m_sectionSizes = &m_sectionBases[1];
    ZeroMemory(m_sectionBases, sizeof(m_sectionBases));
    ZeroMemory(m_sizesByDescription, sizeof(m_sizesByDescription));
}

DataImage::~DataImage()
{
}

//
// Data is stored in the image store in two passes. 
//

//
// In the first pass, all objects are assigned locations in the
// data store.  This is done by calling StoreStructure on all
// structures which are being stored into the image.
//
// This would typically done by methods on the objects themselves,
// each of which stores itself and any objects it references.  
// Reference loops must be explicitly tested for using IsStored.
// (Each structure can be stored only once.)
//

HRESULT DataImage::Pad(ULONG size, Section section, 
                       Description description, int align)
{
    _ASSERTE((align & (align-1)) == 0); // make sure we're a power of 2

    if (size == 0)
        return S_OK;

    ULONG offset;

    if (align > 1)
    {
        m_sectionSizes[section] += align-1;
        m_sectionSizes[section] &= ~(align-1);
    }

    offset = m_sectionSizes[section];
    m_sectionSizes[section] += size;

    m_sizesByDescription[description] += size;

    return S_OK;
}

HRESULT DataImage::StoreStructure(void *data, ULONG size, Section section, 
                                  Description description, mdToken attribution, 
                                  int align)
{
    _ASSERTE((align & (align-1)) == 0); // make sure we're a power of 2

    if (size == 0)
        return S_OK;

    HRESULT hr;

    ULONG offset;

    int pad = 0;
    if (align > 1)
    {
        pad = m_sectionSizes[section];
        pad += align-1;
        pad &= ~(align-1);

        pad -= m_sectionSizes[section];
        m_sectionSizes[section] += pad;
    }

    offset = m_sectionSizes[section];
    m_sectionSizes[section] += size;

    MapEntry *entry = (MapEntry *) m_pool.AllocateElement();

    if (entry == NULL)
        return E_OUTOFMEMORY;

    entry->node.Init((SIZE_T)data, (SIZE_T)data + size);
    entry->section = section;
    entry->offset = offset;

    IfFailRet(m_rangeTree.AddNode(&entry->node));

    m_sizesByDescription[description] += size + pad;

    if (attribution != mdTokenNil)
        ReattributeStructure(attribution, size + pad);

    return S_OK;
}

HRESULT DataImage::StoreInternedStructure(void *data, ULONG size, Section section, 
                                          Description description, 
                                          mdToken attribution, int align)
{
    _ASSERTE((align & (align-1)) == 0); // make sure we're a power of 2

    if (size == 0)
        return S_OK;

    HRESULT hr;

    void *dup = m_internedTable.FindData(data, size);
    if (dup != NULL)
    {
        _ASSERTE(memcmp(data, dup, size) == 0);

        MapEntry *dupEntry = (MapEntry*) m_rangeTree.Lookup((SIZE_T)dup);
        _ASSERTE(dupEntry != NULL);   

        MapEntry *entry = (MapEntry *) m_pool.AllocateElement();

        if (entry == NULL)
            return E_OUTOFMEMORY;

        entry->node.Init((SIZE_T)data, (SIZE_T)data + size);
        entry->section = dupEntry->section;
        entry->offset = dupEntry->offset;

        IfFailRet(m_rangeTree.AddNode(&entry->node));

        return S_FALSE;
    }

    IfFailRet(m_internedTable.StoreData(data, size));

    return StoreStructure(data, size, section, description, attribution, align);
}

BOOL DataImage::IsStored(void *data)
{
    return m_rangeTree.Lookup((SIZE_T)data) != NULL;
}

BOOL DataImage::IsAnyStored(void *data, ULONG size)
{
    return m_rangeTree.Overlaps((SIZE_T)data, (SIZE_T)data + size);
}

void DataImage::ReattributeStructure(mdToken attribution, ULONG size, mdToken from)
{
    if (from != mdTokenNil)
        m_dataStore->AdjustAttribution(from, -(LONG)size);

    if (attribution != mdTokenNil)
        m_dataStore->AdjustAttribution(attribution, size);
}

HRESULT DataImage::CopyData()
{
    HRESULT hr;

    //
    // Make sure all sizes are 8 byte aligned (the max alignment we support)
    //

    ULONG *s = m_sectionSizes;
    ULONG *sEnd = m_sectionSizes + SECTION_COUNT;
    while (s < sEnd)
    {
        *s += 7;
        *s &= ~7;
        s++;
    }

    //
    // Change "sizes" array into "bases"
    // array by accumulating the sizes
    //

    s = m_sectionSizes+1;
    
    while (s < sEnd)
        *s++ += s[-1];

    m_sectionSizes = NULL;
    s--;

    IfFailRet(m_dataStore->Allocate(*s, m_sizesByDescription, (void**) &m_imageBaseMemory));

    MemoryPool::Iterator i(&m_pool);
    while (i.Next())
    {
        MapEntry *entry = (MapEntry*) i.GetElement();

        memcpy(GetMapEntryPointer(entry),
               (void *) entry->node.GetStart(), 
               entry->node.GetEnd() - entry->node.GetStart());
    }

    return S_OK;
}


HRESULT DataImage::FixupPointerField(void *pointerField, 
                                     void *pointerValue, 
                                     ReferenceDest dest,
                                     Fixup type,
                                     BOOL endInclusive)
{
    HRESULT hr;

    //
    // Find pointer contents of field
    //

    SIZE_T pointerAddress;

    if (pointerValue != NULL)
        pointerAddress = (SIZE_T) pointerValue;
    else
        pointerAddress = *(SIZE_T*) pointerField;

    //
    // Normalize the contents to a real pointer
    //

    switch (type)
    {
    case FIXUP_VA:
        break;

    case FIXUP_RVA:
        switch (dest)
        {
        case REFERENCE_IMAGE:
            pointerAddress += (SIZE_T) m_module->GetILBase();
            break;

        case REFERENCE_STORE:
            pointerAddress += (SIZE_T) m_imageBaseMemory;
            break;

        case REFERENCE_FUNCTION:
            // We don't have the address of the base, so just leave it an RVA since
            // we won't be transforming it anyway.
            break;
        }
        break;

    case FIXUP_RELATIVE:
        pointerAddress += (SIZE_T) pointerField;
        break;
        
    default:
        _ASSERTE(!"Unknown fixup type");
    }

    //
    // Don't fixup null pointers
    //

    if (pointerAddress == NULL)
        return S_OK;

    //
    // Find new address of field
    //

    SIZE_T fieldAddress = (SIZE_T) pointerField;

    MapEntry *fieldEntry = (MapEntry*) m_rangeTree.Lookup(fieldAddress);
    _ASSERTE(fieldEntry != NULL);   

    ULONG offset = (ULONG)(fieldAddress - fieldEntry->node.GetStart());

    SIZE_T *newField = (SIZE_T*) (GetMapEntryPointer(fieldEntry) + offset);

    //
    // Compute new pointer contents.  This should be an RVA into the destination.
    //

    SIZE_T newPointer = 0;
    switch (dest)
    {
    case REFERENCE_IMAGE:
        newPointer = pointerAddress - (SIZE_T) m_module->GetILBase();       

        //
        // We don't support absolute references into the image
        //

        _ASSERTE(type == FIXUP_RVA);
        break;

    case REFERENCE_FUNCTION:
        newPointer = pointerAddress;
        break;

    case REFERENCE_STORE:

        MapEntry *pointerEntry;
        if (endInclusive)
            pointerEntry = (MapEntry *) m_rangeTree.LookupEndInclusive(pointerAddress);
        else
            pointerEntry = (MapEntry *) m_rangeTree.Lookup(pointerAddress);

        if (pointerEntry == NULL)
        {
            // @todo: better error reporting here
            return E_POINTER;
        }

        _ASSERTE(pointerEntry != NULL); 

        newPointer = GetMapEntryAddress(pointerEntry)
          + (pointerAddress - pointerEntry->node.GetStart());
    }

    //
    // Set new field to new pointer
    //

    *newField = newPointer;

    //
    // Add a reloc for this field.
    //
    
    IfFailRet(m_dataStore->AddFixup((ULONG)(GetMapEntryAddress(fieldEntry) + offset),
                                    dest, type));

    return S_OK;
}

HRESULT DataImage::FixupPointerFieldMapped(void *pointerField,
                                           void *pointerValue, 
                                           ReferenceDest dest,
                                           Fixup type)
{
    HRESULT hr;


    //
    // Find pointer contents of field
    //

    SIZE_T pointerAddress = (SIZE_T) pointerValue;

    //
    // Find new address of field
    //

    SIZE_T fieldAddress = (SIZE_T) pointerField;

    MapEntry *fieldEntry = (MapEntry*) m_rangeTree.Lookup(fieldAddress);
    _ASSERTE(fieldEntry != NULL);   

    ULONG offset = (ULONG)(fieldAddress - fieldEntry->node.GetStart());

    SIZE_T *newField = (SIZE_T*) (GetMapEntryPointer(fieldEntry) + offset);

    //
    // Set new field to new pointer
    //

    *newField = pointerAddress;

    //
    // Add a reloc for this field.
    //
    
    IfFailRet(m_dataStore->AddFixup((ULONG)(GetMapEntryAddress(fieldEntry) + offset),
                                    dest, type));

    return S_OK;
}
                                           

HRESULT DataImage::FixupPointerFieldToToken(void *pointerField, 
                                            void *pointerValue, 
                                            Module *module, 
                                            mdToken tokenType)
{
    HRESULT hr;

    if (module == NULL)
        module = m_module;

    //
    // Find pointer contents of field
    //

    SIZE_T pointerAddress;

    if (pointerValue != NULL)
        pointerAddress = (SIZE_T) pointerValue;
    else
        pointerAddress = *(SIZE_T*) pointerField;

    //
    // Don't fixup null pointers
    //

    if (pointerAddress == NULL)
        return S_OK;

    //
    // Find new address of field
    //

    SIZE_T fieldAddress = (SIZE_T) pointerField;

    MapEntry *fieldEntry = (MapEntry*) m_rangeTree.Lookup(fieldAddress);
    _ASSERTE(fieldEntry != NULL);   

    SIZE_T offset = fieldAddress - fieldEntry->node.GetStart();

    SIZE_T *newField = (SIZE_T*) (GetMapEntryPointer(fieldEntry) + offset);

    //
    // Set new field to new pointer
    //

    *newField = pointerAddress;

    //
    // Add a reloc for this field.
    //
    
    IfFailRet(m_dataStore->AddTokenFixup((ULONG)(GetMapEntryAddress(fieldEntry) + offset),
                                         tokenType, module));

    return S_OK;
}

HRESULT DataImage::ZeroField(void *field, SIZE_T size)
{
    void *pointer = GetImagePointer(field);
    if (pointer == NULL)
        return E_POINTER;
    ZeroMemory(pointer, size);

    return S_OK;
}

void *DataImage::GetImagePointer(void *pointer)
{
    MapEntry *pointerEntry = (MapEntry*) m_rangeTree.Lookup((SIZE_T)pointer);

    if (pointerEntry == NULL)
        return NULL;

    SIZE_T offset = (SIZE_T) pointer - pointerEntry->node.GetStart();

    BYTE *newPointer = GetMapEntryPointer(pointerEntry) + offset;

    return (void *) newPointer;
}

SIZE_T DataImage::GetImageAddress(void *pointer)
{
    MapEntry *pointerEntry = (MapEntry *) m_rangeTree.Lookup((SIZE_T)pointer);

    if (pointerEntry == NULL)
        return 0;

    SIZE_T offset = (SIZE_T)pointer - pointerEntry->node.GetStart();

    SIZE_T newAddress = GetMapEntryAddress(pointerEntry) + offset;

    return newAddress;
}

HRESULT DataImage::Error(mdToken token, HRESULT hr, OBJECTREF *pThrowable)
{
    return m_dataStore->Error(token, hr, pThrowable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\customattribute.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#include "CustomAttribute.h"
#include "InvokeUtil.h"
#include "COMMember.h"
#include "SigFormat.h"
#include "COMString.h"
#include "Method.hpp"
#include "threads.h"
#include "excep.h"
#include "CorError.h"
#include "security.h"
#include "ExpandSig.h"
#include "classnames.h"
#include "fcall.h"
#include "assemblynative.hpp"


// internal utility functions defined atthe end of this file                                               
TypeHandle GetTypeHandleFromBlob(Assembly *pCtorAssembly,
                                    CorSerializationType objType, 
                                    BYTE **pBlob, 
                                    const BYTE *endBlob,
                                    Module *pModule);
int GetStringSize(BYTE **pBlob, const BYTE *endBlob);
INT64 GetDataFromBlob(Assembly *pCtorAssembly,
                      CorSerializationType type, 
                      TypeHandle th, 
                      BYTE **pBlob, 
                      const BYTE *endBlob, 
                      Module *pModule, 
                      BOOL *bObjectCreated);
void ReadArray(Assembly *pCtorAssembly,
               CorSerializationType arrayType, 
               int size, 
               TypeHandle th,
               BYTE **pBlob, 
               const BYTE *endBlob, 
               Module *pModule,
               BASEARRAYREF *pArray);
BOOL AccessCheck(Module *pTargetModule, mdToken tkCtor, EEClass *pCtorClass)
{
    bool fResult = true;

    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);

    // Security access check. Filter unless the attribute (and ctor)
    // are public or defined in the same assembly as the decorated
    // entity. Assume the attribute isn't decorating itself or its
    // descendents to make the access check simple.
    DWORD dwCtorAttrs;
    if (TypeFromToken(tkCtor) == mdtMemberRef) {
        MethodDesc* ctorMeth = NULL;
        pCtorClass->GetMethodDescFromMemberRef(pTargetModule, tkCtor, &ctorMeth, &Throwable);
        dwCtorAttrs = ctorMeth->GetAttrs();
    } else {
        _ASSERTE(TypeFromToken(tkCtor) == mdtMethodDef);
        dwCtorAttrs = pTargetModule->GetMDImport()->GetMethodDefProps(tkCtor);
    }
    Assembly *pCtorAssembly = pCtorClass->GetAssembly();
    Assembly *pTargetAssembly = pTargetModule->GetAssembly();

    if (pCtorAssembly != pTargetAssembly && !pCtorClass->IsExternallyVisible())
        fResult = false;
    else if (!IsMdPublic(dwCtorAttrs)) {
        if (pCtorAssembly != pTargetAssembly)
            fResult = false;
        else if (!IsMdAssem(dwCtorAttrs) && !IsMdFamORAssem(dwCtorAttrs))
            fResult = false;
    }

    // Additionally, if the custom attribute class comes from an assembly which
    // doesn't allow untrusted callers, we must check for the trust level of
    // decorated entity's assembly.
    if (fResult &&
        pCtorAssembly != pTargetAssembly &&
        !pCtorAssembly->AllowUntrustedCaller())
        fResult = pTargetAssembly->GetSecurityDescriptor()->IsFullyTrusted() != 0;

    GCPROTECT_END();

    return fResult;
}

// custom attributes utility functions
FCIMPL2(INT32, COMCustomAttribute::GetMemberToken, BaseObjectWithCachedData *pMember, INT32 memberType) {
    CANNOTTHROWCOMPLUSEXCEPTION();
    VALIDATEOBJECTREF(pMember);

    switch (memberType) {
    
    case MEMTYPE_Constructor:
    case MEMTYPE_Method:
        {
        ReflectMethod *pMem = (ReflectMethod*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetToken();
        }
    
    case MEMTYPE_Event:
        {
        ReflectEvent *pMem = (ReflectEvent*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetToken();
        }
    
    case MEMTYPE_Field:
        {
        ReflectField *pMem = (ReflectField*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetToken();
        }
    
    case MEMTYPE_Property:
        {
        ReflectProperty *pMem = (ReflectProperty*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetToken();
        }
    
    case MEMTYPE_TypeInfo:
    case MEMTYPE_NestedType:
        {
        ReflectClass *pMem = (ReflectClass*)((ReflectClassBaseObject*)pMember)->GetData();
        return pMem->GetToken();
        }
    
    default:
        _ASSERTE(!"what is this?");
    }

    return 0;
}
FCIMPLEND

FCIMPL2(LPVOID, COMCustomAttribute::GetMemberModule, BaseObjectWithCachedData *pMember, INT32 memberType) {
    CANNOTTHROWCOMPLUSEXCEPTION();
    VALIDATEOBJECTREF(pMember);

    switch (memberType) {
    
    case MEMTYPE_Constructor:
    case MEMTYPE_Method:
        {
        ReflectMethod *pMem = (ReflectMethod*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetModule();
        }
    
    case MEMTYPE_Event:
        {
        ReflectEvent *pMem = (ReflectEvent*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetModule();
        }
    
    case MEMTYPE_Field:
        {
        ReflectField *pMem = (ReflectField*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetModule();
        }
    
    case MEMTYPE_Property:
        {
        ReflectProperty *pMem = (ReflectProperty*)((ReflectBaseObject*)pMember)->GetData();
        return pMem->GetModule();
        }
    
    case MEMTYPE_TypeInfo:
    case MEMTYPE_NestedType:
        {
        ReflectClass *pMem = (ReflectClass*)((ReflectClassBaseObject*)pMember)->GetData();
        return pMem->GetModule();
        }
    
    default:
        _ASSERTE(!"Wrong MemberType for CA");
    }

    return NULL;
}
FCIMPLEND

FCIMPL1(INT32, COMCustomAttribute::GetAssemblyToken, AssemblyBaseObject *assembly) {
    CANNOTTHROWCOMPLUSEXCEPTION();
    VALIDATEOBJECTREF(assembly);
    mdAssembly token = 0;
    Assembly *pAssembly = assembly->GetAssembly();
    IMDInternalImport *mdImport = pAssembly->GetManifestImport();
    if (mdImport)
        mdImport->GetAssemblyFromScope(&token);
    return token;
}
FCIMPLEND

FCIMPL1(LPVOID, COMCustomAttribute::GetAssemblyModule, AssemblyBaseObject *assembly) {
    CANNOTTHROWCOMPLUSEXCEPTION();
    VALIDATEOBJECTREF(assembly);
    return (LPVOID)assembly->GetAssembly()->GetSecurityModule();
}
FCIMPLEND

FCIMPL1(INT32, COMCustomAttribute::GetModuleToken, ReflectModuleBaseObject *module) {
    CANNOTTHROWCOMPLUSEXCEPTION();
    VALIDATEOBJECTREF(module);
    mdModule token = 0;
    Module *pModule = (Module*)module->GetData();
    if (!pModule->IsResource())
        pModule->GetImporter()->GetModuleFromScope(&token);
    return token;
}
FCIMPLEND

FCIMPL1(LPVOID, COMCustomAttribute::GetModuleModule, ReflectModuleBaseObject *module) {
    CANNOTTHROWCOMPLUSEXCEPTION();
    VALIDATEOBJECTREF(module);
    return (LPVOID)module->GetData();
}
FCIMPLEND

FCIMPL1(INT32, COMCustomAttribute::GetMethodRetValueToken, BaseObjectWithCachedData *method) {
    ReflectMethod *pRM = (ReflectMethod*)((ReflectBaseObject*)method)->GetData();
    MethodDesc* pMeth = pRM->pMethod;
    mdMethodDef md = pMeth->GetMemberDef();
    IMDInternalImport* pInternalImport = pMeth->GetMDImport();
    Module* mod = pMeth->GetModule();

    // Get an enum on the Parameters.
    HENUMInternal   hEnum;
    HRESULT hr = pInternalImport->EnumInit(mdtParamDef, md, &hEnum);
    if (FAILED(hr)) 
        return 0;
    
    // Findout how many parameters there are.
    ULONG paramCount = pInternalImport->EnumGetCount(&hEnum);
    if (paramCount == 0) {
        pInternalImport->EnumClose(&hEnum);
        return 0;
    }

    // Get the parameter information for the first parameter.
    mdParamDef paramDef;
    pInternalImport->EnumNext(&hEnum, &paramDef);

    // get the Properties for the parameter.  If the sequence is not 0
    //  then we need to return;
    SHORT   seq;
    DWORD   revWord;
    pInternalImport->GetParamDefProps(paramDef,(USHORT*) &seq, &revWord);
    pInternalImport->EnumClose(&hEnum);

    // The parameters are sorted by sequence number.  If we don't get 0 then,
    //  nothing is defined for the return type.
    if (seq != 0) 
        return 0;
    return paramDef;
}
FCIMPLEND


INT32 __stdcall COMCustomAttribute::IsCADefined(_IsCADefinedArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    TypeHandle caTH;
    ReflectClass *pClass = (ReflectClass*)args->caType->GetData();
    if (pClass) 
        caTH = pClass->GetTypeHandle();
    return COMCustomAttribute::IsDefined((Module*)args->module, args->token, caTH, TRUE);
}

INT32 __stdcall COMCustomAttribute::IsDefined(Module *pModule,
                                              mdToken token,
                                              TypeHandle attributeClass,
                                              BOOL checkAccess)
{
    THROWSCOMPLUSEXCEPTION();
    IMDInternalImport *pInternalImport = pModule->GetMDImport();
    TypeHandle srcTH;
    BOOL isSealed = FALSE;
    BOOL isDefined = FALSE;

    HRESULT         hr;
    HENUMInternal   hEnum;
    TypeHandle caTH;
    
    // Get the enum first but don't get any values
    hr = pInternalImport->EnumInit(mdtCustomAttribute, token, &hEnum);
    if (SUCCEEDED(hr)) {
        ULONG cMax = pInternalImport->EnumGetCount(&hEnum);
        if (cMax) {
            // we have something to look at

            OBJECTREF Throwable = NULL;
            GCPROTECT_BEGIN(Throwable);

            if (!attributeClass.IsNull()) 
                isSealed = attributeClass.GetClass()->GetAttrClass() & tdSealed;

            // Loop through the Attributes and look for the requested one
            mdCustomAttribute cv;
            while (pInternalImport->EnumNext(&hEnum, &cv)) {
                //
                // fetch the ctor
                mdToken     tkCtor; 
                pInternalImport->GetCustomAttributeProps(cv, &tkCtor);

                mdToken tkType = TypeFromToken(tkCtor);
                if(tkType != mdtMemberRef && tkType != mdtMethodDef) 
                    continue; // we only deal with the ctor case

                //
                // get the info to load the type, so we can check whether the current
                // attribute is a subtype of the requested attribute
                hr = pInternalImport->GetParentToken(tkCtor, &tkType);
                if (FAILED(hr)) {
                    _ASSERTE(!"GetParentToken Failed, bogus metadata");
                    COMPlusThrow(kInvalidProgramException);
                }
                _ASSERTE(TypeFromToken(tkType) == mdtTypeRef || TypeFromToken(tkType) == mdtTypeDef);
                // load the type
                ClassLoader* pLoader = pModule->GetClassLoader();
                NameHandle name(pModule, tkType);
                Throwable = NULL;
                if (isSealed) {
                    if (TypeFromToken(tkType) == mdtTypeDef)
                        name.SetTokenNotToLoad(tdAllTypes);
                    caTH = pLoader->LoadTypeHandle(&name, NULL);
                    if (caTH.IsNull()) 
                        continue;
                }
                else {
                    caTH = pLoader->LoadTypeHandle(&name, &Throwable);
                }
                if (Throwable != NULL)
                    COMPlusThrow(Throwable);
                // a null class implies all custom attribute
                if (!attributeClass.IsNull()) {
                    if (isSealed) {
                        if (attributeClass != caTH)
                            continue;
                    }
                    else {
                        if (!caTH.CanCastTo(attributeClass))
                            continue;
                    }
                }

                // Security access check. Filter unless the attribute (and ctor)
                // are public or defined in the same assembly as the decorated
                // entity.
                if (!AccessCheck(pModule, tkCtor, caTH.GetClass()))
                    continue;

                //
                // if we are here we got one
                isDefined = TRUE;
                break;
            }
            GCPROTECT_END();
        }
        
        pInternalImport->EnumClose(&hEnum);
    }
    else {
        _ASSERTE(!"EnumInit Failed");
        FATAL_EE_ERROR();
    }
    
    return isDefined;
}

LPVOID __stdcall COMCustomAttribute::GetCustomAttributeList(_GetCustomAttributeListArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    struct _gcProtectData{
        CUSTOMATTRIBUTEREF ca;
        OBJECTREF Throwable;
    } gcData;
    gcData.ca = args->caItem;
    gcData.Throwable = NULL;

    Module *pModule = (Module*)args->module;
    IMDInternalImport *pInternalImport = pModule->GetMDImport();
    ReflectClass *pClass = NULL;
    if (args->caType != NULL)
        pClass = (ReflectClass*)args->caType->GetData();
    TypeHandle srcTH;
    BOOL isSealed = FALSE;
    // get the new inheritance level
    INT32 inheritLevel = args->level;

    HRESULT         hr;
    HENUMInternal   hEnum;
    TypeHandle caTH;
    
    // Get the enum first but don't get any values
    hr = pInternalImport->EnumInit(mdtCustomAttribute, args->token, &hEnum);
    if (SUCCEEDED(hr)) {
        ULONG cMax = pInternalImport->EnumGetCount(&hEnum);
        if (cMax) {
            // we have something to look at

            BOOL        fCheckedCaller = FALSE;
            Assembly   *pCaller = NULL;
            BOOL        fCheckedPerm = FALSE;
            BOOL        fHavePerm = FALSE;

            if (pClass != NULL) {
                isSealed = pClass->GetAttributes() & tdSealed;
                srcTH = pClass->GetTypeHandle();
            }

            // Loop through the Attributes and create the CustomAttributes
            mdCustomAttribute cv;
            GCPROTECT_BEGIN(gcData);
            while (pInternalImport->EnumNext(&hEnum, &cv)) {
                //
                // fetch the ctor
                mdToken     tkCtor; 
                pInternalImport->GetCustomAttributeProps(cv, &tkCtor);

                mdToken tkType = TypeFromToken(tkCtor);
                if(tkType != mdtMemberRef && tkType != mdtMethodDef) 
                    continue; // we only deal with the ctor case

                //
                // get the info to load the type, so we can check whether the current
                // attribute is a subtype of the requested attribute
                hr = pInternalImport->GetParentToken(tkCtor, &tkType);
                if (FAILED(hr)) {
                    _ASSERTE(!"GetParentToken Failed, bogus metadata");
                    COMPlusThrow(kInvalidProgramException);
                }
                _ASSERTE(TypeFromToken(tkType) == mdtTypeRef || TypeFromToken(tkType) == mdtTypeDef);
                // load the type
                ClassLoader* pLoader = pModule->GetClassLoader();
                gcData.Throwable = NULL;
                NameHandle name(pModule, tkType);
                if (isSealed) {
                    if (TypeFromToken(tkType) == mdtTypeDef)
                        name.SetTokenNotToLoad(tdAllTypes);
                    caTH = pLoader->LoadTypeHandle(&name, NULL);
                    if (caTH.IsNull()) 
                        continue;
                }
                else {
                    caTH = pLoader->LoadTypeHandle(&name, &gcData.Throwable);
                }
                if (gcData.Throwable != NULL)
                    COMPlusThrow(gcData.Throwable);
                // a null class implies all custom attribute
                if (pClass) {
                    if (isSealed) {
                        if (srcTH != caTH)
                            continue;
                    }
                    else {
                        if (!caTH.CanCastTo(srcTH))
                            continue;
                    }
                }

                // Security access check. Filter unless the attribute (and ctor)
                // are public or defined in the same assembly as the decorated
                // entity.
                if (!AccessCheck(pModule, tkCtor, caTH.GetClass()))
                    continue;

                //
                // if we are here the attribute is a good match, get the blob
                const void* blobData;
                ULONG blobCnt;
                pInternalImport->GetCustomAttributeAsBlob(cv, &blobData, &blobCnt);

                COMMember::g_pInvokeUtil->CreateCustomAttributeObject(caTH.GetClass(), 
                                                           tkCtor, 
                                                           blobData, 
                                                           blobCnt, 
                                                           pModule, 
                                                           inheritLevel,
                                                           (OBJECTREF*)&gcData.ca);
            }
            GCPROTECT_END();
        }
        
        pInternalImport->EnumClose(&hEnum);
    }
    else {
        _ASSERTE(!"EnumInit Failed");
        FATAL_EE_ERROR();
    }
    
    return *((LPVOID*)&gcData.ca);
}

//
// Create a custom attribute object based on the info in the CustomAttribute (managed) object
//
LPVOID __stdcall COMCustomAttribute::CreateCAObject(_CreateCAObjectArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");
    
    EEClass *pCAType = ((ReflectClass*)((REFLECTCLASSBASEREF)args->refThis->GetType())->GetData())->GetClass();
    Module *pModule = args->refThis->GetModule();

    // check if the class is abstract and if so throw
    if (pCAType->IsAbstract())
        COMPlusThrow(kCustomAttributeFormatException);
    
    // get the ctor
    mdToken tkCtor = args->refThis->GetToken();
    MethodDesc* ctorMeth = NULL;
    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    pCAType->GetMethodDescFromMemberRef(pModule, tkCtor, &ctorMeth, &Throwable);
    if (Throwable != NULL)
        COMPlusThrow(Throwable);
    else if (ctorMeth == 0 || !ctorMeth->IsCtor())
        COMPlusThrow(kMissingMethodException, L"MissingMethodCustCtor");

    // If the ctor has a security link demand attached, process it now (wrt to
    // the assembly to which the attribute is attached).
    if (ctorMeth->RequiresLinktimeCheck() &&
        !Security::LinktimeCheckMethod(pModule->GetAssembly(), ctorMeth, &Throwable))
        COMPlusThrow(Throwable);

    GCPROTECT_END();

    // Return the exposed assembly object for the managed code's use.
    *args->assembly = pModule->GetAssembly()->GetExposedObject();

    //
    // we got a valid ctor, check the sig and compare with the blob while building the arg list

    // make a sig object we can inspect
    PCCOR_SIGNATURE corSig = ctorMeth->GetSig();
    MetaSig sig = MetaSig(corSig, pCAType->GetModule());

    // get the blob
    BYTE *blob = (BYTE*)args->refThis->GetBlob();
    BYTE *endBlob = (BYTE*)args->refThis->GetBlob() + args->refThis->GetBlobCount();

    // get the number of arguments and allocate an array for the args
    INT64 *arguments = NULL;
    UINT argsNum = sig.NumFixedArgs() + 1; // make room for the this pointer
    UINT i = 1; // used to flag that we actually get the right number of arg from the blob
    arguments = (INT64*)_alloca(argsNum * sizeof(INT64));
    memset((void*)arguments, 0, argsNum * sizeof(INT64));
    OBJECTREF *argToProtect = (OBJECTREF*)_alloca(argsNum * sizeof(OBJECTREF));
    memset((void*)argToProtect, 0, argsNum * sizeof(OBJECTREF));
    // load the this pointer
    argToProtect[0] = AllocateObject(pCAType->GetMethodTable()); // this is the value to return after the ctor invocation

    if (blob) {
        if (blob < endBlob) {
            INT16 prolog = *(INT16*)blob;
            if (prolog != 1) 
                COMPlusThrow(kCustomAttributeFormatException);
            blob += 2;
        }
        if (argsNum > 1) {
            GCPROTECT_ARRAY_BEGIN(*argToProtect, argsNum);
            // loop through the args
            for (i = argsNum - 1; i > 0; i--) {
                CorElementType type = sig.NextArg();
                if (type == ELEMENT_TYPE_END) 
                    break;
                BOOL bObjectCreated = FALSE;
                TypeHandle th = sig.GetTypeHandle();
                if (th.IsArray())
                    // get the array element 
                    th = th.AsArray()->GetElementTypeHandle();
                INT64 data = GetDataFromBlob(ctorMeth->GetAssembly(), (CorSerializationType)type, th, &blob, endBlob, pModule, &bObjectCreated);
                if (bObjectCreated) 
                    argToProtect[i] = Int64ToObj(data);
                else
                    arguments[i] = data;
            }
            GCPROTECT_END();
            for (i = 1; i < argsNum; i++) {
                if (argToProtect[i] != NULL) {
                    _ASSERTE(arguments[i] == NULL);
                    arguments[i] = ObjToInt64(argToProtect[i]);
                }
            }
        }
    }
    arguments[0] = ObjToInt64(argToProtect[0]);
    if (i != argsNum)
        COMPlusThrow(kCustomAttributeFormatException);
    
    //
    // the argument array is ready

    // check if there are any named properties to invoke, if so set the by ref int passed in to point 
    // to the blob position where name properties start
    *args->propNum = 0;
    if (blob && blob != endBlob) {
        if (blob + 2  > endBlob) 
            COMPlusThrow(kCustomAttributeFormatException);
        *args->propNum = *(INT16*)blob;
        args->refThis->SetCurrPos(blob + 2 - (BYTE*)args->refThis->GetBlob());
        blob += 2;
    }
    if (*args->propNum == 0 && blob != endBlob) 
        COMPlusThrow(kCustomAttributeFormatException);
    
    // make the invocation to the ctor
    OBJECTREF ca = Int64ToObj(arguments[0]);
    if (pCAType->IsValueClass()) 
        arguments[0] = (INT64)OBJECTREFToObject(ca)->UnBox();
    GCPROTECT_BEGIN(ca);
    ctorMeth->Call(arguments, &sig);
    GCPROTECT_END();

    return *(LPVOID*)&ca;
}

/*STRINGREF*/
LPVOID __stdcall COMCustomAttribute::GetDataForPropertyOrField(_GetDataForPropertyOrFieldArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    if (args->isProperty == NULL) 
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");

    STRINGREF name = NULL;
    Module *pModule = args->refThis->GetModule();
    Assembly *pCtorAssembly = args->refThis->GetType()->GetMethodTable()->GetAssembly();
    BYTE *blob = (BYTE*)args->refThis->GetBlob() + args->refThis->GetCurrPos();
    BYTE *endBlob = (BYTE*)args->refThis->GetBlob() + args->refThis->GetBlobCount();
    MethodTable *pMTValue = NULL;
    CorSerializationType arrayType = SERIALIZATION_TYPE_BOOLEAN;
    BOOL bObjectCreated = FALSE;
    TypeHandle nullTH;

    if (blob + 2 > endBlob) 
        COMPlusThrow(kCustomAttributeFormatException);
    
    // get whether it is a field or a property
    CorSerializationType propOrField = (CorSerializationType)*blob;
    blob++;
    if (propOrField == SERIALIZATION_TYPE_FIELD) 
        *args->isProperty = FALSE;
    else if (propOrField == SERIALIZATION_TYPE_PROPERTY) 
        *args->isProperty = TRUE;
    else 
        COMPlusThrow(kCustomAttributeFormatException);
    
    // get the type of the field
    CorSerializationType type = (CorSerializationType)*blob;
    blob++;
    if (type == SERIALIZATION_TYPE_SZARRAY) {
        arrayType = (CorSerializationType)*blob;
        if (blob + 1 > endBlob) 
            COMPlusThrow(kCustomAttributeFormatException);
        blob++;
    }
    if (type == SERIALIZATION_TYPE_ENUM || arrayType == SERIALIZATION_TYPE_ENUM) {
        // get the enum type
        ReflectClassBaseObject *pEnum = (ReflectClassBaseObject*)OBJECTREFToObject(Int64ToObj(GetDataFromBlob(pCtorAssembly,
                                                                                                              SERIALIZATION_TYPE_TYPE, 
                                                                                                              nullTH, 
                                                                                                              &blob, 
                                                                                                              endBlob, 
                                                                                                              pModule, 
                                                                                                              &bObjectCreated)));
        _ASSERTE(bObjectCreated);
        EEClass* pEEEnum = ((ReflectClass*)pEnum->GetData())->GetClass();
        _ASSERTE(pEEEnum->IsEnum());
        pMTValue = pEEEnum->GetMethodTable();
        if (type == SERIALIZATION_TYPE_ENUM) 
            // load the enum type to pass it back
            *args->type = pEEEnum->GetExposedClassObject();
        else 
            nullTH = TypeHandle(pMTValue);
    }

    //
    // get the string representing the field/property name
    name = Int64ToString(GetDataFromBlob(pCtorAssembly,
                                         SERIALIZATION_TYPE_STRING, 
                                         nullTH, 
                                         &blob, 
                                         endBlob, 
                                         pModule, 
                                         &bObjectCreated));
    _ASSERTE(bObjectCreated || name == NULL);

    // create the object and return it
    GCPROTECT_BEGIN(name);
    switch (type) {
    case SERIALIZATION_TYPE_TAGGED_OBJECT:
        *args->type = g_Mscorlib.GetClass(CLASS__OBJECT)->GetClass()->GetExposedClassObject();
    case SERIALIZATION_TYPE_TYPE:
    case SERIALIZATION_TYPE_STRING:
        *args->value = Int64ToObj(GetDataFromBlob(pCtorAssembly,
                                                  type, 
                                                  nullTH, 
                                                  &blob, 
                                                  endBlob, 
                                                  pModule, 
                                                  &bObjectCreated));
        _ASSERTE(bObjectCreated || *args->value == NULL);
        if (*args->value == NULL) {
            // load the proper type so that code in managed knows which property to load
            if (type == SERIALIZATION_TYPE_STRING) 
                *args->type = g_Mscorlib.GetElementType(ELEMENT_TYPE_STRING)->GetClass()->GetExposedClassObject();
            else if (type == SERIALIZATION_TYPE_TYPE) 
                *args->type = g_Mscorlib.GetClass(CLASS__TYPE)->GetClass()->GetExposedClassObject();
        }
        break;
    case SERIALIZATION_TYPE_SZARRAY:
    {
        int arraySize = (int)GetDataFromBlob(pCtorAssembly, SERIALIZATION_TYPE_I4, nullTH, &blob, endBlob, pModule, &bObjectCreated);
        if (arraySize != -1) {
            _ASSERTE(!bObjectCreated);
            if (arrayType == SERIALIZATION_TYPE_STRING) 
                nullTH = TypeHandle(g_Mscorlib.GetElementType(ELEMENT_TYPE_STRING));
            else if (arrayType == SERIALIZATION_TYPE_TYPE) 
                nullTH = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPE));
            else if (arrayType == SERIALIZATION_TYPE_TAGGED_OBJECT)
                nullTH = TypeHandle(g_Mscorlib.GetClass(CLASS__OBJECT));
            ReadArray(pCtorAssembly, arrayType, arraySize, nullTH, &blob, endBlob, pModule, (BASEARRAYREF*)args->value);
        }
        if (*args->value == NULL) {
            TypeHandle arrayTH;
            switch (arrayType) {
            case SERIALIZATION_TYPE_STRING:
                arrayTH = TypeHandle(g_Mscorlib.GetElementType(ELEMENT_TYPE_STRING));
                break;
            case SERIALIZATION_TYPE_TYPE:
                arrayTH = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPE));
                break;
            case SERIALIZATION_TYPE_TAGGED_OBJECT:
                arrayTH = TypeHandle(g_Mscorlib.GetClass(CLASS__OBJECT));
                break;
            default:
                if (SERIALIZATION_TYPE_BOOLEAN <= arrayType && arrayType <= SERIALIZATION_TYPE_R8) 
                    arrayTH = TypeHandle(g_Mscorlib.GetElementType((CorElementType)arrayType));
            }
            if (!arrayTH.IsNull()) {
                arrayTH = SystemDomain::Loader()->FindArrayForElem(arrayTH, ELEMENT_TYPE_SZARRAY);
                *args->type = arrayTH.CreateClassObj();
            }
        }
        break;
    }
    default:
        if (SERIALIZATION_TYPE_BOOLEAN <= type && type <= SERIALIZATION_TYPE_R8) 
            pMTValue = g_Mscorlib.GetElementType((CorElementType)type);
        else if(type == SERIALIZATION_TYPE_ENUM)
            type = (CorSerializationType)pMTValue->GetNormCorElementType();
        else
            COMPlusThrow(kCustomAttributeFormatException);
        INT64 val = GetDataFromBlob(pCtorAssembly, type, nullTH, &blob, endBlob, pModule, &bObjectCreated);
        _ASSERTE(!bObjectCreated);
        *args->value = pMTValue->Box((void*)&val);
    }
    GCPROTECT_END();

    args->refThis->SetCurrPos(blob - (BYTE*)args->refThis->GetBlob());
    
    if (args->isLast && blob != endBlob) 
        COMPlusThrow(kCustomAttributeFormatException);

    return *(LPVOID*)&name;
}
    
// utility functions
TypeHandle GetTypeHandleFromBlob(Assembly *pCtorAssembly,
                                    CorSerializationType objType, 
                                    BYTE **pBlob, 
                                    const BYTE *endBlob,
                                    Module *pModule)
{
    THROWSCOMPLUSEXCEPTION();
    // we must box which means we must get the method table, switch again on the element type
    MethodTable *pMTType = NULL;
    TypeHandle nullTH;
    TypeHandle RtnTypeHnd;

    switch (objType) {
    case SERIALIZATION_TYPE_BOOLEAN:
    case SERIALIZATION_TYPE_I1:
    case SERIALIZATION_TYPE_U1:
    case SERIALIZATION_TYPE_CHAR:
    case SERIALIZATION_TYPE_I2:
    case SERIALIZATION_TYPE_U2:
    case SERIALIZATION_TYPE_I4:
    case SERIALIZATION_TYPE_U4:
    case SERIALIZATION_TYPE_R4:
    case SERIALIZATION_TYPE_I8:
    case SERIALIZATION_TYPE_U8:
    case SERIALIZATION_TYPE_R8:
    case SERIALIZATION_TYPE_STRING:
        pMTType = g_Mscorlib.GetElementType((CorElementType)objType);
        RtnTypeHnd = TypeHandle(pMTType);
        break;

    case ELEMENT_TYPE_CLASS:
        pMTType = g_Mscorlib.GetClass(CLASS__TYPE);
        RtnTypeHnd = TypeHandle(pMTType);
        break;

    case SERIALIZATION_TYPE_TAGGED_OBJECT:
        pMTType = g_Mscorlib.GetClass(CLASS__OBJECT);
        RtnTypeHnd = TypeHandle(pMTType);
        break;

    case SERIALIZATION_TYPE_TYPE:
    {
        int size = GetStringSize(pBlob, endBlob);
        if (size == -1) 
            return nullTH;
        if (size > 0) {
            if (*pBlob + size > endBlob) 
                COMPlusThrow(kCustomAttributeFormatException);
            LPUTF8 szName = (LPUTF8)_alloca(size + 1);
            memcpy(szName, *pBlob, size);
            *pBlob += size;
            szName[size] = 0;
            NameHandle name(szName);
            OBJECTREF Throwable = NULL;
            TypeHandle typeHnd;
            GCPROTECT_BEGIN(Throwable);

            typeHnd = pModule->GetAssembly()->FindNestedTypeHandle(&name, &Throwable);
            if (typeHnd.IsNull()) {
                Throwable = NULL;
                typeHnd = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(szName, FALSE, NULL, NULL, &Throwable);
                if (Throwable != NULL) 
                    COMPlusThrow(Throwable);
            }
            GCPROTECT_END();
            if (typeHnd.IsNull()) 
                COMPlusThrow(kCustomAttributeFormatException);
            RtnTypeHnd = typeHnd;

            // Security access check. Custom attribute assembly must follow the
            // usual rules for type access (type must be public, defined in the
            // same assembly or the accessing assembly must have the requisite
            // reflection permission).
            if (!IsTdPublic(typeHnd.GetClass()->GetProtection()) &&
                pModule->GetAssembly() != typeHnd.GetClass()->GetAssembly() &&
                !pModule->GetAssembly()->GetSecurityDescriptor()->CanRetrieveTypeInformation())
                RtnTypeHnd = nullTH;
        }
        else 
            COMPlusThrow(kCustomAttributeFormatException);
        break;
    }

    case SERIALIZATION_TYPE_ENUM:
    {
        //
        // get the enum type
        BOOL isObject = FALSE;
        ReflectClassBaseObject *pType = (ReflectClassBaseObject*)OBJECTREFToObject(Int64ToObj(GetDataFromBlob(pCtorAssembly,
                                                                                                              SERIALIZATION_TYPE_TYPE, 
                                                                                                              nullTH, 
                                                                                                              pBlob, 
                                                                                                              endBlob, 
                                                                                                              pModule, 
                                                                                                              &isObject)));
        _ASSERTE(isObject);
        EEClass* pEEType = ((ReflectClass*)pType->GetData())->GetClass();
        _ASSERTE((objType == SERIALIZATION_TYPE_ENUM) ? pEEType->IsEnum() : TRUE);
        RtnTypeHnd = TypeHandle(pEEType->GetMethodTable());
        break;
    }

    default:
        COMPlusThrow(kCustomAttributeFormatException);
    }

    return RtnTypeHnd;
}

// retrive the string size in a CA blob. Advance the blob pointer to point to
// the beginning of the string immediately following the size
int GetStringSize(BYTE **pBlob, const BYTE *endBlob)
{
    THROWSCOMPLUSEXCEPTION();
    int size = -1;

    // Null string - encoded as a single byte
    if (**pBlob != 0xFF) {
        if ((**pBlob & 0x80) == 0) 
            // encoded as a single byte
            size = **pBlob;
        else if ((**pBlob & 0xC0) == 0x80) {
            if (*pBlob + 1 > endBlob) 
                COMPlusThrow(kCustomAttributeFormatException);
            // encoded in two bytes
            size = (**pBlob & 0x3F) << 8;
            size |= *(++*pBlob); // This is in big-endian format
        }
        else {
            if (*pBlob + 3 > endBlob) 
                COMPlusThrow(kCustomAttributeFormatException);
            // encoded in four bytes
            size = (**pBlob & ~0xC0) << 32;
            size |= *(++*pBlob) << 16;
            size |= *(++*pBlob) << 8;
            size |= *(++*pBlob);
        }
    }

    if (*pBlob + 1 > endBlob) 
        COMPlusThrow(kCustomAttributeFormatException);
    *pBlob += 1;

    return size;
}

// read the whole array as a chunk
void ReadArray(Assembly *pCtorAssembly,
               CorSerializationType arrayType, 
               int size, 
               TypeHandle th,
               BYTE **pBlob, 
               const BYTE *endBlob, 
               Module *pModule,
               BASEARRAYREF *pArray)
{    
    THROWSCOMPLUSEXCEPTION();    
    
    BYTE *pData = NULL;
    INT64 element = 0;

    switch (arrayType) {
    case SERIALIZATION_TYPE_BOOLEAN:
    case SERIALIZATION_TYPE_I1:
    case SERIALIZATION_TYPE_U1:
        *pArray = (BASEARRAYREF)AllocatePrimitiveArray((CorElementType)arrayType, size);
        pData = (*pArray)->GetDataPtr();
        if (*pBlob + size > endBlob) 
            goto badBlob;
        memcpyNoGCRefs(pData, *pBlob, size);
        *pBlob += size;
        break;

    case SERIALIZATION_TYPE_CHAR:
    case SERIALIZATION_TYPE_I2:
    case SERIALIZATION_TYPE_U2:
        *pArray = (BASEARRAYREF)AllocatePrimitiveArray((CorElementType)arrayType, size);
        pData = (*pArray)->GetDataPtr();
        if (*pBlob + (size * 2) > endBlob) 
            goto badBlob;
        memcpyNoGCRefs(pData, *pBlob, size * 2);
        *pBlob += size * 2;
        break;

    case SERIALIZATION_TYPE_I4:
    case SERIALIZATION_TYPE_U4:
    case SERIALIZATION_TYPE_R4:
        *pArray = (BASEARRAYREF)AllocatePrimitiveArray((CorElementType)arrayType, size);
        pData = (*pArray)->GetDataPtr();
        if (*pBlob + (size * 4) > endBlob) 
            goto badBlob;
        memcpyNoGCRefs(pData, *pBlob, size * 4);
        *pBlob += size * 4;
        break;

    case SERIALIZATION_TYPE_I8:
    case SERIALIZATION_TYPE_U8:
    case SERIALIZATION_TYPE_R8:
        *pArray = (BASEARRAYREF)AllocatePrimitiveArray((CorElementType)arrayType, size);
        pData = (*pArray)->GetDataPtr();
        if (*pBlob + (size * 8) > endBlob) 
            goto badBlob;
        memcpyNoGCRefs(pData, *pBlob, size * 8);
        *pBlob += size * 8;
        break;

    case ELEMENT_TYPE_CLASS:
    case SERIALIZATION_TYPE_TYPE:
    case SERIALIZATION_TYPE_STRING:
    case SERIALIZATION_TYPE_SZARRAY:
    case SERIALIZATION_TYPE_TAGGED_OBJECT:
    {
        BOOL isObject;
        *pArray = (BASEARRAYREF)AllocateObjectArray(size, th);
        if (arrayType == SERIALIZATION_TYPE_SZARRAY) 
            // switch the th to be the proper one 
            th = th.AsArray()->GetElementTypeHandle();
        for (int i = 0; i < size; i++) {
            element = GetDataFromBlob(pCtorAssembly, arrayType, th, pBlob, endBlob, pModule, &isObject);
            _ASSERTE(isObject || element == NULL);
            ((PTRARRAYREF)(*pArray))->SetAt(i, Int64ToObj(element));
        }
        break;
    }

    case SERIALIZATION_TYPE_ENUM:
    {
        DWORD bounds = size;
        unsigned elementSize = th.GetSize();
        ClassLoader *cl = th.AsMethodTable()->GetAssembly()->GetLoader();
        TypeHandle arrayHandle = cl->FindArrayForElem(th, ELEMENT_TYPE_SZARRAY);
        if (arrayHandle.IsNull()) 
            goto badBlob;
        *pArray = (BASEARRAYREF)AllocateArrayEx(arrayHandle, &bounds, 1);
        pData = (*pArray)->GetDataPtr();
        size *= elementSize;
        if (*pBlob + size > endBlob) 
            goto badBlob;
        memcpyNoGCRefs(pData, *pBlob, size);
        *pBlob += size;
        break;
    }

    default:
    badBlob:
        COMPlusThrow(kCustomAttributeFormatException);
    }

}

// get data out of the blob according to a CorElementType
INT64 GetDataFromBlob(Assembly *pCtorAssembly,
                      CorSerializationType type, 
                      TypeHandle th, 
                      BYTE **pBlob, 
                      const BYTE *endBlob, 
                      Module *pModule, 
                      BOOL *bObjectCreated)
{
    THROWSCOMPLUSEXCEPTION();
    INT64 retValue = 0;
    *bObjectCreated = FALSE;
    TypeHandle nullTH;
    TypeHandle typeHnd;

    switch (type) {

    case SERIALIZATION_TYPE_BOOLEAN:
    case SERIALIZATION_TYPE_I1:
    case SERIALIZATION_TYPE_U1:
        if (*pBlob + 1 <= endBlob) {
            retValue = (INT64)**pBlob;
            *pBlob += 1;
            break;
        }
        goto badBlob;

    case SERIALIZATION_TYPE_CHAR:
    case SERIALIZATION_TYPE_I2:
    case SERIALIZATION_TYPE_U2:
        if (*pBlob + 2 <= endBlob) {
            retValue = (INT64)*(WCHAR*)*pBlob;
            *pBlob += 2;
            break;
        }
        goto badBlob;

    case SERIALIZATION_TYPE_I4:
    case SERIALIZATION_TYPE_U4:
    case SERIALIZATION_TYPE_R4:
        if (*pBlob + 4 <= endBlob) {
            retValue = (INT64)*(UINT32*)*pBlob;
            *pBlob += 4;
            break;
        }
        goto badBlob;

    case SERIALIZATION_TYPE_I8:
    case SERIALIZATION_TYPE_U8:
    case SERIALIZATION_TYPE_R8:
        if (*pBlob + 8 <= endBlob) {
            retValue = *(INT64*)*pBlob;
            *pBlob += 8;
            break;
        }
        goto badBlob;

    case SERIALIZATION_TYPE_STRING:
    stringType:
    {
        int size = GetStringSize(pBlob, endBlob);
        *bObjectCreated = TRUE;
        if (size > 0) {
            if (*pBlob + size > endBlob) 
                goto badBlob;
            retValue = ObjToInt64(COMString::NewString((LPCUTF8)*pBlob, size));
            *pBlob += size;
        }
        else if (size == 0) 
            retValue = ObjToInt64(COMString::NewString(0));
        else
            *bObjectCreated = FALSE;

        break;
    }

    // this is coming back from sig but it's not a serialization type, 
    // essentialy the type in the blob and the type in the sig don't match
    case ELEMENT_TYPE_VALUETYPE:
    {
        if (!th.IsEnum()) 
            goto badBlob;
        CorSerializationType enumType = (CorSerializationType)th.GetNormCorElementType();
        BOOL cannotBeObject = FALSE;
        retValue = GetDataFromBlob(pCtorAssembly, enumType, nullTH, pBlob, endBlob, pModule, &cannotBeObject);
        _ASSERTE(!cannotBeObject);
        break;
    }

    // this is coming back from sig but it's not a serialization type, 
    // essentialy the type in the blob and the type in the sig don't match
    case ELEMENT_TYPE_CLASS:
        if (th.IsArray())
            goto typeArray;
        else {
            MethodTable *pMT = th.AsMethodTable();
            if (pMT == g_Mscorlib.GetClass(CLASS__STRING)) 
                goto stringType;
            else if (pMT == g_Mscorlib.GetClass(CLASS__OBJECT)) 
                goto typeObject;
            else if (pMT == g_Mscorlib.GetClass(CLASS__TYPE)) 
                goto typeType;
        }

        goto badBlob;

    case SERIALIZATION_TYPE_TYPE:
    typeType:
    {
        typeHnd = GetTypeHandleFromBlob(pCtorAssembly, SERIALIZATION_TYPE_TYPE, pBlob, endBlob, pModule);
        if (!typeHnd.IsNull())
            retValue = ObjToInt64(typeHnd.CreateClassObj());
        *bObjectCreated = TRUE;
        break;
    }

    // this is coming back from sig but it's not a serialization type, 
    // essentialy the type in the blob and the type in the sig don't match
    case ELEMENT_TYPE_OBJECT:
    case SERIALIZATION_TYPE_TAGGED_OBJECT:
    typeObject:
    {
        // get the byte representing the real type and call GetDataFromBlob again
        if (*pBlob + 1 > endBlob) 
            goto badBlob;
        CorSerializationType objType = (CorSerializationType)**pBlob;
        *pBlob += 1;
        BOOL isObjectAlready = FALSE;
        switch (objType) {
        case SERIALIZATION_TYPE_SZARRAY:
        {
            if (*pBlob + 1 > endBlob) 
                goto badBlob;
            CorSerializationType arrayType = (CorSerializationType)**pBlob;
            *pBlob += 1;
            if (arrayType == SERIALIZATION_TYPE_TYPE) 
                arrayType = (CorSerializationType)ELEMENT_TYPE_CLASS;
            // grab the array type and make a type handle for it
            nullTH = GetTypeHandleFromBlob(pCtorAssembly, arrayType, pBlob, endBlob, pModule);
        }
        case SERIALIZATION_TYPE_TYPE:
        case SERIALIZATION_TYPE_STRING:
            // notice that the nullTH is actually not null in the array case (see case above)
            retValue = GetDataFromBlob(pCtorAssembly, objType, nullTH, pBlob, endBlob, pModule, bObjectCreated);
            _ASSERTE(*bObjectCreated || retValue == 0);
            break;
        case SERIALIZATION_TYPE_ENUM:
        {
            //
            // get the enum type
            typeHnd = GetTypeHandleFromBlob(pCtorAssembly, SERIALIZATION_TYPE_ENUM, pBlob, endBlob, pModule);
            _ASSERTE(typeHnd.IsTypeDesc() == false);
            
            // ok we have the class, now we go and read the data
            CorSerializationType objType = (CorSerializationType)typeHnd.AsMethodTable()->GetNormCorElementType();
            BOOL isObject = FALSE;
            retValue = GetDataFromBlob(pCtorAssembly, objType, nullTH, pBlob, endBlob, pModule, &isObject);
            _ASSERTE(!isObject);
            retValue= ObjToInt64(typeHnd.AsMethodTable()->Box((void*)&retValue));
            *bObjectCreated = TRUE;
            break;
        }
        default:
        {
            // the common primitive type case. We need to box the primitive
            typeHnd = GetTypeHandleFromBlob(pCtorAssembly, objType, pBlob, endBlob, pModule);
            _ASSERTE(typeHnd.IsTypeDesc() == false);
            retValue = GetDataFromBlob(pCtorAssembly, objType, nullTH, pBlob, endBlob, pModule, bObjectCreated);
            _ASSERTE(!*bObjectCreated);
            retValue= ObjToInt64(typeHnd.AsMethodTable()->Box((void*)&retValue));
            *bObjectCreated = TRUE;
            break;
        }
        }
        break;
    }

    case SERIALIZATION_TYPE_SZARRAY:
    typeArray:
    {
        // read size
        BOOL isObject = FALSE;
        int size = (int)GetDataFromBlob(pCtorAssembly, SERIALIZATION_TYPE_I4, nullTH, pBlob, endBlob, pModule, &isObject);
        _ASSERTE(!isObject);
        
        if (size != -1) {
            CorSerializationType arrayType;
            if (th.IsEnum()) 
                arrayType = SERIALIZATION_TYPE_ENUM;
            else
                arrayType = (CorSerializationType)th.GetNormCorElementType();
        
            BASEARRAYREF array = NULL;
            GCPROTECT_BEGIN(array);
            ReadArray(pCtorAssembly, arrayType, size, th, pBlob, endBlob, pModule, &array);
            retValue = ObjToInt64(array);
            GCPROTECT_END();
        }
        *bObjectCreated = TRUE;
        break;
    }

    default:
    badBlob:
        //TODO: generate a reasonable text string ("invalid blob or constructor")
        COMPlusThrow(kCustomAttributeFormatException);
    }

    return retValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\customerdebughelper.h ===
/****************************************************************
*
* Overview: CustomerDebugHelper implements the features of the
*           customer checked build by handling activation status,
*           and logs and reports.
*
* Created by: Edmund Chou (t-echou)
*
* Copyright (c) Microsoft, 2001
*
****************************************************************/


#ifndef _CUSTOMERDEBUGHELPER_
#define _CUSTOMERDEBUGHELPER_


// Enumeration of probes (ProbeID)
enum EnumProbes
{
    // Adding a probe requires 3 changes:
    //   (1) Add the probe to EnumProbes (CustomerDebugHelper.h)
    //   (2) Add the probe name to m_aProbeNames[] (CustomerDebugHelper.cpp)
    //   (3) Add the probe to machine.config with activation status in developerSettings

    CustomerCheckedBuildProbe_StackImbalance = 0,
    CustomerCheckedBuildProbe_CollectedDelegate,
    CustomerCheckedBuildProbe_InvalidIUnknown,
    CustomerCheckedBuildProbe_InvalidVariant,
    CustomerCheckedBuildProbe_Marshaling,
    CustomerCheckedBuildProbe_Apartment,
    CustomerCheckedBuildProbe_NotMarshalable,
    CustomerCheckedBuildProbe_DisconnectedContext,
    CustomerCheckedBuildProbe_FailedQI,
    CustomerCheckedBuildProbe_BufferOverrun,
    CustomerCheckedBuildProbe_ObjNotKeptAlive,
    CustomerCheckedBuildProbe_FunctionPtr,
    CUSTOMERCHECKEDBUILD_NUMBER_OF_PROBES
};



// Enumeration of parsing methods for customized probe enabling
enum EnumParseMethods
{
    // By default, all probes will not have any customized parsing to determine
    // activation.  A probe is either enabled or disabled indepedent of the calling
    // method.
    //
    // To specify a customized parsing method, set the parse method in 
    // m_aProbeParseMethods to one of the appropriate EnumParseMethods.  Then edit 
    // machine.config by setting attribute [probe-name].Params to semicolon 
    // seperated values.

    NO_PARSING = 0,
    GENERIC_PARSE,
    METHOD_NAME_PARSE,
    NUMBER_OF_PARSE_METHODS
};



// Param type for list of methods parameters relevant to a specific probe
// This allows for customized activation/deactivation of the customer checked
// build probe on different methods.

class Param
{

public:

    SLink   m_link;

    Param(LPCWSTR strParam)
    {
        m_str = strParam;
    }

    ~Param()
    {
        delete [] m_str;
    }

    LPCWSTR Value()
    {
        return m_str;
    }

private:

    LPCWSTR m_str;
};

typedef SList<Param, offsetof(Param, m_link), true> ParamsList;




// Mechanism for handling Customer Checked Build functionality
class CustomerDebugHelper
{

public:

    static const int I_UINT32_MAX_DIGITS = 8; // number of hexadecimal digits in 2^32

    // Constructor and destructor
    CustomerDebugHelper();
    ~CustomerDebugHelper();

    // Return and destroy instance of CustomerDebugHelper
    static CustomerDebugHelper* GetCustomerDebugHelper();
    static void Terminate();

    // Methods used to log/report
    void        LogInfo (LPCWSTR strMessage, EnumProbes ProbeID);
    void        ReportError (LPCWSTR strMessage, EnumProbes ProbeID);

    // Activation of customer-checked-build
    BOOL        IsEnabled();

    // Activation of specific probes
    BOOL        IsProbeEnabled  (EnumProbes ProbeID);
    BOOL        IsProbeEnabled  (EnumProbes ProbeID, LPCWSTR strEnabledFor);
    BOOL        EnableProbe     (EnumProbes ProbeID);
    BOOL        EnableProbe     (EnumProbes ProbeID, LPCWSTR strEnableFor);
    BOOL        DisableProbe    (EnumProbes ProbeID);
    BOOL        DisableProbe    (EnumProbes ProbeID, LPCWSTR strDisableFor);

private:
    // Read application configuration file
    HRESULT ReadAppConfigurationFile();
    LPWSTR GetConfigString(LPWSTR name);
    void OutputDebugString(LPCWSTR strMessage);
    HRESULT ManagedOutputDebugString(LPCWSTR pMessage);   
    BOOL UseManagedOutputDebugString();

    static CustomerDebugHelper* m_pCdh;
    
    EEUnicodeStringHashTable m_appConfigFile;

    Crst*       m_pCrst;

    int         m_iNumberOfProbes;
    int         m_iNumberOfEnabledProbes;
    
    LPCWSTR*    m_aProbeNames;              // Map ProbeID to probe name
    BOOL*       m_aProbeStatus;             // Map ProbeID to probe activation
    BOOL        m_allowDebugBreak;
    BOOL        m_bWin32OuputExclusive;
    BOOL        m_win32OutputDebugStringExclusively;

    // Used for custom enabling of probes
    ParamsList*         m_aProbeParams;    // Map of ProbeID to relevant parameters 
    EnumParseMethods*   m_aProbeParseMethods;       // Map of ProbeID to parsing methods

    BOOL IsProbeEnabled (EnumProbes ProbeID, LPCWSTR strEnabledFor, EnumParseMethods enCustomParse);
};

#endif // _CUSTOMERDEBUGHELPER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\custommarshalerinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Custom marshaler information used when marshaling
**          a parameter with a custom marshaler. 
**  
**      //  %%Created by: dmortens
===========================================================*/

#include "common.h"
#include "CustomMarshalerInfo.h"
#include "COMString.h"
#include "mlinfo.h"


//==========================================================================
// Implementation of the custom marshaler info class.
//==========================================================================

CustomMarshalerInfo::CustomMarshalerInfo(BaseDomain *pDomain, TypeHandle hndCustomMarshalerType, TypeHandle hndManagedType, LPCUTF8 strCookie, DWORD cCookieStrBytes)
: m_NativeSize(0)
, m_hndManagedType(hndManagedType)
, m_hndCustomMarshaler(NULL)
, m_pMarshalNativeToManagedMD(NULL)
, m_pMarshalManagedToNativeMD(NULL)
, m_pCleanUpNativeDataMD(NULL)
, m_pCleanUpManagedDataMD(NULL)
, m_bDataIsByValue(FALSE)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);

    // Make sure the custom marshaller implements ICustomMarshaler.
    if (!hndCustomMarshalerType.GetClass()->StaticSupportsInterface(g_Mscorlib.GetClass(CLASS__ICUSTOM_MARSHALER)))
    {
        DefineFullyQualifiedNameForClassW()
        GetFullyQualifiedNameForClassW(hndCustomMarshalerType.GetClass());
        COMPlusThrow(kApplicationException, IDS_EE_ICUSTOMMARSHALERNOTIMPL, _wszclsname_);
    }

    // Determine if this type is a value class.
    m_bDataIsByValue = m_hndManagedType.GetClass()->IsValueClass();

    // Custom marshalling of value classes is not currently supported.
    if (m_bDataIsByValue)
        COMPlusThrow(kNotSupportedException, L"NotSupported_ValueClassCM");

    // Run the <clinit> on the marshaler since it might not have run yet.
    if (!hndCustomMarshalerType.GetMethodTable()->CheckRunClassInit(&throwable))
    {
        _ASSERTE(!"Couldn't run the <clinit> for the CustomMarshaler class!");
        COMPlusThrow(throwable);
    }

    // Create a COM+ string that will contain the string cookie.
    STRINGREF CookieStringObj = COMString::NewString(strCookie, cCookieStrBytes);
    GCPROTECT_BEGIN(CookieStringObj);

    // Load the method desc's for all the methods in the ICustomMarshaler interface.
    m_pMarshalNativeToManagedMD = GetCustomMarshalerMD(CustomMarshalerMethods_MarshalNativeToManaged, hndCustomMarshalerType);
    m_pMarshalManagedToNativeMD = GetCustomMarshalerMD(CustomMarshalerMethods_MarshalManagedToNative, hndCustomMarshalerType);
    m_pCleanUpNativeDataMD = GetCustomMarshalerMD(CustomMarshalerMethods_CleanUpNativeData, hndCustomMarshalerType);
    m_pCleanUpManagedDataMD = GetCustomMarshalerMD(CustomMarshalerMethods_CleanUpManagedData, hndCustomMarshalerType);

    // Load the method desc for the static method to retrieve the instance.
    MethodDesc *pGetCustomMarshalerMD = GetCustomMarshalerMD(CustomMarshalerMethods_GetInstance, hndCustomMarshalerType);

    // Prepare the arguments that will be passed to GetCustomMarshaler.
    INT64 GetCustomMarshalerArgs[] = { 
        ObjToInt64(CookieStringObj)
    };

    // Call the GetCustomMarshaler method to retrieve the custom marshaler to use.
    OBJECTREF CustomMarshalerObj = Int64ToObj(pGetCustomMarshalerMD->Call(GetCustomMarshalerArgs));
    if (!CustomMarshalerObj)
    {
        DefineFullyQualifiedNameForClassW()
        GetFullyQualifiedNameForClassW(hndCustomMarshalerType.GetClass());
        COMPlusThrow(kApplicationException, IDS_EE_NOCUSTOMMARSHALER, _wszclsname_);
    }
    m_hndCustomMarshaler = pDomain->CreateHandle(CustomMarshalerObj);

    // Retrieve the size of the native data.
    if (m_bDataIsByValue)
    {
        // @TODO(DM): Call GetNativeDataSize() to retrieve the size of the native data.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }
    else
    {
        m_NativeSize = sizeof(void *);
    }

    GCPROTECT_END();
    GCPROTECT_END();
}


CustomMarshalerInfo::~CustomMarshalerInfo()
{
    if (m_hndCustomMarshaler)
    {
        DestroyHandle(m_hndCustomMarshaler);
        m_hndCustomMarshaler = NULL;
    }
}


void *CustomMarshalerInfo::operator new(size_t size, LoaderHeap *pHeap)
{
    return pHeap->AllocMem(sizeof(CustomMarshalerInfo));
}


void CustomMarshalerInfo::operator delete(void *pMem)
{
    // Instances of this class are always allocated on the loader heap so
    // the delete operator has nothing to do.
}


OBJECTREF CustomMarshalerInfo::InvokeMarshalNativeToManagedMeth(void *pNative)
{
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    if (!pNative)
        return NULL;

    INT64 Args[] = {
        ObjToInt64(ObjectFromHandle(m_hndCustomMarshaler)),
        (INT64)pNative
    };

    return Int64ToObj(m_pMarshalNativeToManagedMD->Call(Args));
}


void *CustomMarshalerInfo::InvokeMarshalManagedToNativeMeth(OBJECTREF MngObj)
{
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    void *RetVal = NULL;

    if (!MngObj)
        return NULL;

    INT64 Args[] = {
        ObjToInt64(ObjectFromHandle(m_hndCustomMarshaler)),
        ObjToInt64(MngObj)
    };

    RetVal = (void*)m_pMarshalManagedToNativeMD->Call(Args);

    return RetVal;
}


void CustomMarshalerInfo::InvokeCleanUpNativeMeth(void *pNative)
{
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    if (!pNative)
        return;

    INT64 Args[] = {
        ObjToInt64(ObjectFromHandle(m_hndCustomMarshaler)),
        (INT64)pNative
    };

    m_pCleanUpNativeDataMD->Call(Args);
}


void CustomMarshalerInfo::InvokeCleanUpManagedMeth(OBJECTREF MngObj)
{
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    if (!MngObj)
        return;

    INT64 Args[] = {
        ObjToInt64(ObjectFromHandle(m_hndCustomMarshaler)),
        ObjToInt64(MngObj)
    };

    m_pCleanUpManagedDataMD->Call(Args);
}


MethodDesc *CustomMarshalerInfo::GetCustomMarshalerMD(EnumCustomMarshalerMethods Method, TypeHandle hndCustomMarshalertype)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pMT = hndCustomMarshalertype.AsMethodTable();

    _ASSERTE(pMT->GetClass()->StaticSupportsInterface(g_Mscorlib.GetClass(CLASS__ICUSTOM_MARSHALER)));

    MethodDesc *pMD = NULL;

    switch (Method)
    {
    case CustomMarshalerMethods_MarshalNativeToManaged:
        pMD = pMT->GetMethodDescForInterfaceMethod(
                   g_Mscorlib.GetMethod(METHOD__ICUSTOM_MARSHALER__MARSHAL_NATIVE_TO_MANAGED));  
        break;
    case CustomMarshalerMethods_MarshalManagedToNative:
        pMD = pMT->GetMethodDescForInterfaceMethod(
                   g_Mscorlib.GetMethod(METHOD__ICUSTOM_MARSHALER__MARSHAL_MANAGED_TO_NATIVE));
        break;
    case CustomMarshalerMethods_CleanUpNativeData:
        pMD = pMT->GetMethodDescForInterfaceMethod(
                    g_Mscorlib.GetMethod(METHOD__ICUSTOM_MARSHALER__CLEANUP_NATIVE_DATA));
        break;

    case CustomMarshalerMethods_CleanUpManagedData:
        pMD = pMT->GetMethodDescForInterfaceMethod(
                    g_Mscorlib.GetMethod(METHOD__ICUSTOM_MARSHALER__CLEANUP_MANAGED_DATA));
        break;
    case CustomMarshalerMethods_GetNativeDataSize:
        pMD = pMT->GetMethodDescForInterfaceMethod(
                    g_Mscorlib.GetMethod(METHOD__ICUSTOM_MARSHALER__GET_NATIVE_DATA_SIZE));
        break;
    case CustomMarshalerMethods_GetInstance:
        // Must look this up by name since it's static
        pMD = pMT->GetClass()->FindMethod("GetInstance", &gsig_SM_Str_RetICustomMarshaler);
        if (!pMD)
        {
            DefineFullyQualifiedNameForClassW()
            GetFullyQualifiedNameForClassW(pMT->GetClass());
            COMPlusThrow(kApplicationException, IDS_EE_GETINSTANCENOTIMPL, _wszclsname_);
        }
        break;
    default:
        _ASSERTE(!"Unknown custom marshaler method");
    }

    _ASSERTE(pMD && "Unable to find specified CustomMarshaler method");

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

    // Return the specified method desc.
    return pMD;
}


//==========================================================================
// Implementation of the custom marshaler hashtable helper.
//==========================================================================

EEHashEntry_t * EECMHelperHashtableHelper::AllocateEntry(EECMHelperHashtableKey *pKey, BOOL bDeepCopy, void* pHeap)
{
    EEHashEntry_t *pEntry;

    if (bDeepCopy)
    {
        pEntry = (EEHashEntry_t *) new BYTE[sizeof(EEHashEntry) - 1 + 
            sizeof(EECMHelperHashtableKey) + pKey->GetMarshalerTypeNameByteCount() + pKey->GetCookieStringByteCount()];
        if (!pEntry)
            return NULL;

        EECMHelperHashtableKey *pEntryKey = (EECMHelperHashtableKey *) pEntry->Key;
        pEntryKey->m_cMarshalerTypeNameBytes = pKey->GetMarshalerTypeNameByteCount();
        pEntryKey->m_strMarshalerTypeName = (LPSTR) pEntry->Key + sizeof(EECMHelperHashtableKey);
        pEntryKey->m_cCookieStrBytes = pKey->GetCookieStringByteCount();
        pEntryKey->m_strCookie = (LPSTR) pEntry->Key + sizeof(EECMHelperHashtableKey) + pEntryKey->m_cMarshalerTypeNameBytes;
        pEntryKey->m_bSharedHelper = pKey->IsSharedHelper();
        memcpy((void*)pEntryKey->m_strMarshalerTypeName, pKey->GetMarshalerTypeName(), pKey->GetMarshalerTypeNameByteCount()); 
        memcpy((void*)pEntryKey->m_strCookie, pKey->GetCookieString(), pKey->GetCookieStringByteCount()); 
    }
    else
    {
        pEntry = (EEHashEntry_t *) 
            new BYTE[sizeof(EEHashEntry) - 1 + sizeof(EECMHelperHashtableKey)];
        if (!pEntry)
            return NULL;

        EECMHelperHashtableKey *pEntryKey = (EECMHelperHashtableKey *) pEntry->Key;
        pEntryKey->m_cMarshalerTypeNameBytes = pKey->GetMarshalerTypeNameByteCount();
        pEntryKey->m_strMarshalerTypeName = pKey->GetMarshalerTypeName();
        pEntryKey->m_cCookieStrBytes = pKey->GetCookieStringByteCount();
        pEntryKey->m_strCookie = pKey->GetCookieString();
        pEntryKey->m_bSharedHelper = pKey->IsSharedHelper();
    }

    return pEntry;
}


void EECMHelperHashtableHelper::DeleteEntry(EEHashEntry_t *pEntry, void* pHeap)
{
    delete[] pEntry;
}


BOOL EECMHelperHashtableHelper::CompareKeys(EEHashEntry_t *pEntry, EECMHelperHashtableKey *pKey)
{
    EECMHelperHashtableKey *pEntryKey = (EECMHelperHashtableKey *) pEntry->Key;

    if (pEntryKey->IsSharedHelper() != pKey->IsSharedHelper())
        return FALSE;

    if (pEntryKey->GetMarshalerTypeNameByteCount() != pKey->GetMarshalerTypeNameByteCount())
        return FALSE;

    if (memcmp(pEntryKey->GetMarshalerTypeName(), pKey->GetMarshalerTypeName(), pEntryKey->GetMarshalerTypeNameByteCount()) != 0)
        return FALSE;

    if (pEntryKey->GetCookieStringByteCount() != pKey->GetCookieStringByteCount())
        return FALSE;

    if (memcmp(pEntryKey->GetCookieString(), pKey->GetCookieString(), pEntryKey->GetCookieStringByteCount()) != 0)
        return FALSE;

    return TRUE;
}


DWORD EECMHelperHashtableHelper::Hash(EECMHelperHashtableKey *pKey)
{
    return (DWORD)
        (HashBytes((const BYTE *) pKey->GetMarshalerTypeName(), pKey->GetMarshalerTypeNameByteCount()) + 
        HashBytes((const BYTE *) pKey->GetCookieString(), pKey->GetCookieStringByteCount()) + 
        (pKey->IsSharedHelper() ? 1 : 0));
}


OBJECTREF CustomMarshalerHelper::InvokeMarshalNativeToManagedMeth(void *pNative)
{
    return GetCustomMarshalerInfo()->InvokeMarshalNativeToManagedMeth(pNative);
}


void *CustomMarshalerHelper::InvokeMarshalManagedToNativeMeth(OBJECTREF MngObj)
{
    void *RetVal = NULL;

    GCPROTECT_BEGIN(MngObj)
    {
        CustomMarshalerInfo *pCMInfo = GetCustomMarshalerInfo();
        RetVal = pCMInfo->InvokeMarshalManagedToNativeMeth(MngObj);
    }
    GCPROTECT_END();

    return RetVal;
}


void CustomMarshalerHelper::InvokeCleanUpNativeMeth(void *pNative)
{
    return GetCustomMarshalerInfo()->InvokeCleanUpNativeMeth(pNative);
}


void CustomMarshalerHelper::InvokeCleanUpManagedMeth(OBJECTREF MngObj)
{
    GCPROTECT_BEGIN(MngObj)
    {
        CustomMarshalerInfo *pCMInfo = GetCustomMarshalerInfo();
        pCMInfo->InvokeCleanUpManagedMeth(MngObj);
    }
    GCPROTECT_END();
}


void *NonSharedCustomMarshalerHelper::operator new(size_t size, LoaderHeap *pHeap)
{
    return pHeap->AllocMem(sizeof(NonSharedCustomMarshalerHelper));
}


void NonSharedCustomMarshalerHelper::operator delete(void *pMem)
{
    // Instances of this class are always allocated on the loader heap so
    // the delete operator has nothing to do.
}


SharedCustomMarshalerHelper::SharedCustomMarshalerHelper(Assembly *pAssembly, TypeHandle hndManagedType, LPCUTF8 strMarshalerTypeName, DWORD cMarshalerTypeNameBytes, LPCUTF8 strCookie, DWORD cCookieStrBytes)
: m_pAssembly(pAssembly)
, m_hndManagedType(hndManagedType)
, m_cMarshalerTypeNameBytes(cMarshalerTypeNameBytes)
, m_strMarshalerTypeName(strMarshalerTypeName)
, m_cCookieStrBytes(cCookieStrBytes)
, m_strCookie(strCookie)
{
}


void *SharedCustomMarshalerHelper::operator new(size_t size, LoaderHeap *pHeap)
{
    return pHeap->AllocMem(sizeof(SharedCustomMarshalerHelper));
}


void SharedCustomMarshalerHelper::operator delete(void *pMem)
{
    // Instances of this class are always allocated on the loader heap so
    // the delete operator has nothing to do.
}


CustomMarshalerInfo *SharedCustomMarshalerHelper::GetCustomMarshalerInfo()
{
    // Retrieve the marshalling data for the current app domain.
    EEMarshalingData *pMarshalingData = GetThread()->GetDomain()->GetMarshalingData();

    // Retrieve the custom marshaling information for the current shared custom
    // marshaling helper.
    return pMarshalingData->GetCustomMarshalerInfo(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\customerdebughelper.cpp ===
/****************************************************************
*
* Overview: CustomerDebugHelper implements the features of the
*           customer checked build by handling activation status,
*           and logs and reports.
*
* Created by: Edmund Chou (t-echou)
*
* Copyright (c) Microsoft, 2001
*
****************************************************************/


#include "common.h"
#include "utilcode.h"
#include "CustomerDebugHelper.h"
#include "EEConfig.h"
#include "EEConfigFactory.h"
#include "CorHlpr.h"
#include <xmlparser.h>
#include <mscorcfg.h>
#include <holder.h>
#include <dbgInterface.h>


// Implementation of the CustomerDebugHelper class
CustomerDebugHelper* CustomerDebugHelper::m_pCdh = NULL;

// Constructor
CustomerDebugHelper::CustomerDebugHelper()
{
    m_pCrst                  = ::new Crst("CustomerDebugHelper", CrstSingleUseLock);
    m_allowDebugBreak = false;
    m_bWin32OuputExclusive = false;

    m_iNumberOfProbes        = CUSTOMERCHECKEDBUILD_NUMBER_OF_PROBES;
    m_iNumberOfEnabledProbes = 0;

    m_aProbeNames           = new LPCWSTR  [m_iNumberOfProbes];
    m_aProbeStatus          = new BOOL     [m_iNumberOfProbes];
    m_aProbeParams          = new ParamsList        [m_iNumberOfProbes];
    m_aProbeParseMethods    = new EnumParseMethods  [m_iNumberOfProbes];

    // Adding a probe requires 3 changes:
    //   (1) Add the probe to EnumProbes (CustomerDebugHelper.h)
    //   (2) Add the probe name to m_aProbeNames[] (CustomerDebugHelper.cpp)
    //   (3) Add the probe to machine.config with activation status in developerSettings

    m_aProbeNames[CustomerCheckedBuildProbe_StackImbalance]     = L"CDP.PInvokeCallConvMismatch";
    m_aProbeNames[CustomerCheckedBuildProbe_CollectedDelegate]  = L"CDP.CollectedDelegate";
    m_aProbeNames[CustomerCheckedBuildProbe_InvalidIUnknown]    = L"CDP.InvalidIUnknown";
    m_aProbeNames[CustomerCheckedBuildProbe_InvalidVariant]     = L"CDP.InvalidVariant";
    m_aProbeNames[CustomerCheckedBuildProbe_Marshaling]         = L"CDP.Marshaling";
    m_aProbeNames[CustomerCheckedBuildProbe_Apartment]          = L"CDP.Apartment";
    m_aProbeNames[CustomerCheckedBuildProbe_NotMarshalable]     = L"CDP.NotMarshalable";
    m_aProbeNames[CustomerCheckedBuildProbe_DisconnectedContext]= L"CDP.DisconnectedContext";
    m_aProbeNames[CustomerCheckedBuildProbe_FailedQI]           = L"CDP.FailedQI";
    m_aProbeNames[CustomerCheckedBuildProbe_BufferOverrun]      = L"CDP.BufferOverrun";
    m_aProbeNames[CustomerCheckedBuildProbe_ObjNotKeptAlive]    = L"CDP.ObjNotKeptAlive";
    m_aProbeNames[CustomerCheckedBuildProbe_FunctionPtr]        = L"CDP.FunctionPtr";

    // Set-up customized parse methods

    for (int i=0; i < m_iNumberOfProbes; i++) {
        m_aProbeParseMethods[i] = NO_PARSING;  // Default to no customization
    }

    // By default, all probes will not have any customized parsing to determine
    // activation.  A probe is either enabled or disabled indepedent of the calling
    // method.
    //
    // To specify a customized parsing method, set the parse method in 
    // m_aProbeParseMethods to one of the appropriate EnumParseMethods.  Then edit 
    // machine.config by setting attribute [probe-name].Params to semicolon 
    // seperated values.

    m_aProbeParseMethods[CustomerCheckedBuildProbe_Marshaling] = METHOD_NAME_PARSE;

    static WCHAR        strParamsExtension[] = {L".Filter"};
    CQuickArray<WCHAR>  strProbeParamsAttribute;
    strProbeParamsAttribute.Alloc(0);

    // It is our policy to only check the Machine.Config file for CDP.AllowDebugProbes
    // EEConfig::GetConfigString only checks the Machine.Config file.
    LPWSTR strProbeMasterSwitch = EEConfig::GetConfigString(L"CDP.AllowDebugProbes");
    if (strProbeMasterSwitch == NULL || wcscmp(strProbeMasterSwitch, L"true") != 0)
    {
        for (int i = 0; i < m_iNumberOfProbes; i++)
        {
            m_aProbeStatus[i] = false;
        }

        delete[] strProbeMasterSwitch;
        return;
    }
    delete[] strProbeMasterSwitch;

    LPWSTR strWin32OutputDebugString = EEConfig::GetConfigString(L"CDP.Win32OutputDebugString");
    if (strWin32OutputDebugString != NULL && wcscmp(strWin32OutputDebugString, L"exclusive") == 0)
    {
        m_bWin32OuputExclusive = true;
        OutputDebugString(L"CDP> CDP.AllowDebugProbes = true\n");
        OutputDebugString(L"CDP> CDP.Win32OutputDebugString = exclusive\n");
    }
    else
    {
        OutputDebugString(L"CDP> CDP.AllowDebugProbes = true\n");    
    }
    delete[] strWin32OutputDebugString;

    LPWSTR strAllowDebugBreak = EEConfig::GetConfigString(L"CDP.AllowDebugBreak");
    if (strAllowDebugBreak != NULL && wcscmp(strAllowDebugBreak, L"true") == 0)
    {
        OutputDebugString(L"CDP> CDP.AllowDebugBreak = true\n");
        m_allowDebugBreak = true;
    }
    delete[] strAllowDebugBreak;

    // Because the master switch is set, go ahead and read the application config file
    m_appConfigFile.Init(100, NULL);
    ReadAppConfigurationFile();
        
    for (int iProbe=0; iProbe < m_iNumberOfProbes; iProbe++) {

        // Get probe activation status from machine.config

        LPWSTR strProbeStatus = GetConfigString((LPWSTR)m_aProbeNames[iProbe]);

        if (strProbeStatus == NULL)
            m_aProbeStatus[iProbe] = false;
        else
        {
            m_aProbeStatus[iProbe] = (wcscmp( strProbeStatus, L"true" ) == 0);

            if (m_aProbeStatus[iProbe])
            {
                LogInfo(L"Probe enabled.", (EnumProbes)iProbe);
                m_iNumberOfEnabledProbes++;
            }
        }

        // Get probe relevant parameters from machine.config

        strProbeParamsAttribute.ReSize( (UINT)wcslen(m_aProbeNames[iProbe]) + lengthof(strParamsExtension) );
        Wszwsprintf( (LPWSTR)strProbeParamsAttribute.Ptr(), L"%s%s", m_aProbeNames[iProbe], strParamsExtension );

        LPWSTR strProbeParams = GetConfigString((LPWSTR)strProbeParamsAttribute.Ptr());
        
        m_aProbeParams[iProbe].Init();        
        if (strProbeParams != NULL)
        {
            // Populate array with parsed tokens

            LPWSTR strToken = wcstok(strProbeParams, L";");

            while (strToken != NULL)
            {
                LPWSTR strParsedToken = new WCHAR[wcslen(strToken) + 1];
                wcscpy(strParsedToken, strToken);

                // Strip parenthesis
                if (wcschr(strParsedToken, '(') != NULL)
                    *wcschr(strParsedToken, '(') = NULL;

                m_aProbeParams[iProbe].InsertHead(new Param(strParsedToken));
                strToken = wcstok(NULL, L";");
            }

            delete [] strToken;
        }

        delete [] strProbeStatus;
        delete [] strProbeParams;
    }
};


// Destructor
CustomerDebugHelper::~CustomerDebugHelper()
{
    for (int iProbe=0; iProbe < m_iNumberOfProbes; iProbe++)
    {        
        while (!m_aProbeParams[iProbe].IsEmpty())
            delete m_aProbeParams[iProbe].RemoveHead();
    }
    
    delete [] m_aProbeNames;
    delete [] m_aProbeStatus;
    delete [] m_aProbeParams;
    delete [] m_aProbeParseMethods;
};


// Return instance of CustomerDebugHelper to caller
CustomerDebugHelper* CustomerDebugHelper::GetCustomerDebugHelper()
{
    if (m_pCdh == NULL)
    {    
        CustomerDebugHelper* pCdh = new CustomerDebugHelper();
        if (InterlockedCompareExchangePointer((void**)&m_pCdh, (void*)pCdh, NULL) != NULL)
            delete pCdh;
    }
    return m_pCdh;
}


// Destroy instance of CustomerDebugHelper
void CustomerDebugHelper::Terminate()
{
    _ASSERTE(m_pCdh != NULL);
    delete m_pCdh;
    m_pCdh = NULL;
}

BOOL CustomerDebugHelper::UseManagedOutputDebugString()
{
    Thread *pThread = GetThread();
    AppDomain *pAppDomain = NULL;
    
    if (pThread)
        pAppDomain = pThread->GetDomain();
 
    BOOL bUnmanagedDebuggerPresent = IsDebuggerPresent();
    BOOL bManagedDebuggerPresent = pAppDomain ? pAppDomain->IsDebuggerAttached() : false;
    BOOL bUnmanagedDebugLoggingEnabled = g_pDebugInterface->IsLoggingEnabled();
    
    return (!m_bWin32OuputExclusive &&
            !bUnmanagedDebuggerPresent &&
            bManagedDebuggerPresent && 
            bUnmanagedDebugLoggingEnabled);
}

// Log information from probe
void CustomerDebugHelper::OutputDebugString(LPCWSTR strMessage)
{  
    if (UseManagedOutputDebugString())     
        ManagedOutputDebugString(strMessage);
    else
        WszOutputDebugString(strMessage);
 }

void CustomerDebugHelper::LogInfo(LPCWSTR strMessage, EnumProbes ProbeID)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    //_ASSERTE(m_aProbeStatus[ProbeID] || !"Attempted to use disabled probe");
    _ASSERTE(strMessage != NULL);

    static WCHAR        strLog[] = {L"CDP> Logged information from %s: %s\n"};
    CQuickArray<WCHAR>  strOutput;

    strOutput.Alloc( lengthof(strLog) + wcslen(m_aProbeNames[ProbeID]) + wcslen(strMessage) );

    Wszwsprintf( (LPWSTR)strOutput.Ptr(), strLog, m_aProbeNames[ProbeID], strMessage );
    OutputDebugString( (LPCWSTR)strOutput.Ptr() );
};


// Report errors from probe
void CustomerDebugHelper::ReportError(LPCWSTR strMessage, EnumProbes ProbeID)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    //_ASSERTE(m_aProbeStatus[ProbeID] || !"Attempted to use disabled probe");
    _ASSERTE(strMessage != NULL);

    static WCHAR        strReport[] = {L"CDP> Reported error from %s: %s\n"};
    CQuickArray<WCHAR>  strOutput;

    strOutput.Alloc( lengthof(strReport) + wcslen(m_aProbeNames[ProbeID]) + wcslen(strMessage) );
    
    Wszwsprintf( (LPWSTR)strOutput.Ptr(), strReport, m_aProbeNames[ProbeID], strMessage );
    OutputDebugString( (LPCWSTR)strOutput.Ptr() );

    if (m_allowDebugBreak == TRUE)
    {
        DebugBreak();
    }
};


// Activation of customer checked build
BOOL CustomerDebugHelper::IsEnabled()
{
    return (m_iNumberOfEnabledProbes != 0);
};


// Activation of specific probe
BOOL CustomerDebugHelper::IsProbeEnabled(EnumProbes ProbeID)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    return m_aProbeStatus[ProbeID];
};


// Customized activation of specific probe

BOOL CustomerDebugHelper::IsProbeEnabled(EnumProbes ProbeID, LPCWSTR strEnabledFor)
{
    return IsProbeEnabled(ProbeID, strEnabledFor, m_aProbeParseMethods[ProbeID]);
}

BOOL CustomerDebugHelper::IsProbeEnabled(EnumProbes ProbeID, LPCWSTR strEnabledFor, EnumParseMethods enCustomParse)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    _ASSERTE((0 <= enCustomParse) && (enCustomParse < NUMBER_OF_PARSE_METHODS));
    _ASSERTE(strEnabledFor != NULL);

    if (m_aProbeStatus[ProbeID])
    {
        if (m_aProbeParams[ProbeID].IsEmpty())
            return false;
        else
        {
            CQuickArray<WCHAR>  strNamespaceClassMethod;
            CQuickArray<WCHAR>  strNamespaceClass;
            CQuickArray<WCHAR>  strNamespace;
            CQuickArray<WCHAR>  strClassMethod;
            CQuickArray<WCHAR>  strClass;
            CQuickArray<WCHAR>  strMethod;
            
            CQuickArray<WCHAR>  strInput;
            CQuickArray<WCHAR>  strTemp;

            Param*              param;
            BOOL                bFound = false;
            UINT                iLengthOfEnabledFor = (UINT)wcslen(strEnabledFor) + 1;

            static WCHAR        strNamespaceClassMethodFormat[] = {L"%s.%s::%s"};
            static WCHAR        strNamespaceClassFormat[] = {L"%s.%s"};
            static WCHAR        strClassMethodFormat[] = {L"%s::%s"};


            switch(enCustomParse)
            {
                case METHOD_NAME_PARSE:

                    strInput.Alloc(iLengthOfEnabledFor);
                    wcscpy(strInput.Ptr(), strEnabledFor);

                    // Strip parenthesis

                    if (wcschr(strInput.Ptr(), '('))
                        *wcschr(strInput.Ptr(), '(') = NULL;

                    // Obtain namespace, class, and method names

                    strNamespaceClassMethod.Alloc(iLengthOfEnabledFor);
                    strNamespaceClass.Alloc(iLengthOfEnabledFor);
                    strNamespace.Alloc(iLengthOfEnabledFor);
                    strClassMethod.Alloc(iLengthOfEnabledFor);
                    strClass.Alloc(iLengthOfEnabledFor);
                    strMethod.Alloc(iLengthOfEnabledFor);

                    strTemp.Alloc(iLengthOfEnabledFor);
                    wcscpy(strTemp.Ptr(), strInput.Ptr());

                    if (wcschr(strInput.Ptr(), ':') &&
                        wcschr(strInput.Ptr(), '.') )
                    {
                        // input format is Namespace.Class::Method
                        wcscpy(strNamespaceClassMethod.Ptr(), strInput.Ptr());
                        wcscpy(strNamespaceClass.Ptr(),  wcstok(strTemp.Ptr(), L":"));
                        wcscpy(strMethod.Ptr(), wcstok(NULL, L":"));

                        ns::SplitPath(strNamespaceClass.Ptr(), strNamespace.Ptr(), iLengthOfEnabledFor, strClass.Ptr(), iLengthOfEnabledFor);
                        Wszwsprintf(strClassMethod.Ptr(), strClassMethodFormat, strClass.Ptr(), strMethod.Ptr());
                    }
                    else if (wcschr(strInput.Ptr(), ':'))
                    {
                        // input format is Class::Method
                        wcscpy(strClass.Ptr(),  wcstok(strTemp.Ptr(), L":"));
                        wcscpy(strMethod.Ptr(), wcstok(NULL, L":"));
                        
                        Wszwsprintf(strClassMethod.Ptr(), strClassMethodFormat, strClass.Ptr(), strMethod.Ptr());
                        
                        *strNamespaceClassMethod.Ptr() = NULL;
                        *strNamespaceClass.Ptr() = NULL;
                        *strNamespace.Ptr() = NULL;
                    }
                    else if (wcschr(strInput.Ptr(), '.'))
                    {
                        // input format is Namespace.Class
                        wcscpy(strNamespaceClass.Ptr(), strInput.Ptr());
                        ns::SplitPath(strNamespaceClass.Ptr(), strNamespace.Ptr(), iLengthOfEnabledFor, strClass.Ptr(), iLengthOfEnabledFor);

                        *strNamespaceClassMethod.Ptr() = NULL;
                        *strClassMethod.Ptr() = NULL;
                        *strMethod.Ptr() = NULL;
                    }
                    else
                    {
                        // input has no separators -- assume Method
                        wcscpy(strMethod.Ptr(), strInput.Ptr());

                        *strNamespaceClassMethod.Ptr() = NULL;
                        *strNamespaceClass.Ptr() = NULL;
                        *strNamespace.Ptr() = NULL;
                        *strClassMethod.Ptr() = NULL;
                        *strClass.Ptr() = NULL;
                    }

                    // Compare namespace, class, and method names to m_aProbeParams

                    // Take lock to prevent concurrency failure if m_aProbeParams is modified
                    m_pCrst->Enter();

                    param = m_aProbeParams[ProbeID].GetHead();
                    while (param != NULL)
                    {
                        if ( _wcsicmp(strNamespaceClassMethod.Ptr(), param->Value()) == 0  || 
                             _wcsicmp(strNamespaceClass.Ptr(), param->Value()) == 0        || 
                             _wcsicmp(strNamespace.Ptr(), param->Value()) == 0             ||
                             _wcsicmp(strClassMethod.Ptr(), param->Value()) == 0           ||
                             _wcsicmp(strClass.Ptr(), param->Value()) == 0                 ||
                             _wcsicmp(strMethod.Ptr(), param->Value()) == 0                ||
                             _wcsicmp(L"everything", param->Value()) == 0                   )
                        {
                             bFound = true;
                             break;
                        }
                        else
                            param = m_aProbeParams[ProbeID].GetNext(param);
                    }
                    m_pCrst->Leave();

                    return bFound;


                case NO_PARSING:
                    return IsProbeEnabled(ProbeID);


                case GENERIC_PARSE:
                default:

                    // Case-insensitive string matching

                    // Take lock to prevent concurrency failure if m_aProbeParams is modified
                    m_pCrst->Enter();

                    param = m_aProbeParams[ProbeID].GetHead();
                    while (param != NULL) 
                    {
                        if (_wcsicmp(strEnabledFor, param->Value()) == 0)
                        {
                            bFound = true;
                            break;
                        }
                        else
                            param = m_aProbeParams[ProbeID].GetNext(param);
                    }
                    m_pCrst->Leave();

                    return bFound;
            }
        }
    }
    else
        return false;
};


// Enable specific probe
BOOL CustomerDebugHelper::EnableProbe(EnumProbes ProbeID)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    if (!InterlockedExchange((LPLONG) &m_aProbeStatus[ProbeID], TRUE))
        InterlockedIncrement((LPLONG) &m_iNumberOfEnabledProbes);
    return true;
};


// Customized enabling for specific probe
// Note that calling a customized enable does not necessarily 
// mean the probe is actually enabled.
BOOL CustomerDebugHelper::EnableProbe(EnumProbes ProbeID, LPCWSTR strEnableFor)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    _ASSERTE(strEnableFor != NULL);

    CQuickArray<WCHAR> strParsedEnable;
    strParsedEnable.Alloc((UINT)wcslen(strEnableFor) + 1);
    wcscpy(strParsedEnable.Ptr(), strEnableFor);

    // Strip parenthesis
    if (wcschr(strParsedEnable.Ptr(), '(') != NULL)
        *wcschr(strParsedEnable.Ptr(), '(') = NULL;

    BOOL bAlreadyExists = false;

    // Take lock to avoid concurrent read/write failures
    m_pCrst->Enter();

    Param* param = m_aProbeParams[ProbeID].GetHead();
    while (param != NULL)
    {
        if (_wcsicmp(strParsedEnable.Ptr(), param->Value()) == 0)
            bAlreadyExists = true;
        param = m_aProbeParams[ProbeID].GetNext(param);
    }
    if (!bAlreadyExists)
    {
        LPWSTR strNewEnable = new WCHAR[wcslen(strParsedEnable.Ptr()) + 1];
        wcscpy(strNewEnable, strParsedEnable.Ptr());
        m_aProbeParams[ProbeID].InsertHead(new Param(strNewEnable));
    }
    m_pCrst->Leave();

    return !bAlreadyExists;
}


// Disable specific probe
BOOL CustomerDebugHelper::DisableProbe(EnumProbes ProbeID)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    if (InterlockedExchange((LPLONG) &m_aProbeStatus[ProbeID], FALSE))
        InterlockedDecrement((LPLONG) &m_iNumberOfEnabledProbes);
    return true;
};


// Customized disabling for specific probe
BOOL CustomerDebugHelper::DisableProbe(EnumProbes ProbeID, LPCWSTR strDisableFor)
{
    _ASSERTE((0 <= ProbeID) && (ProbeID < m_iNumberOfProbes));
    _ASSERTE(strDisableFor != NULL);

    CQuickArray<WCHAR> strParsedDisable;
    strParsedDisable.Alloc((UINT)wcslen(strDisableFor) + 1);
    wcscpy(strParsedDisable.Ptr(), strDisableFor);

    // Strip parenthesis
    if (wcschr(strParsedDisable.Ptr(), '(') != NULL)
        *wcschr(strParsedDisable.Ptr(), '(') = NULL;

    // Take lock to avoid concurrent read/write failures
    m_pCrst->Enter();

    BOOL bRemovedProbe = false;
    Param* param = m_aProbeParams[ProbeID].GetHead();
    while (param != NULL)
    {
        if (_wcsicmp(strParsedDisable.Ptr(), param->Value()) == 0)
        {
            param = m_aProbeParams[ProbeID].FindAndRemove(param);
            delete param;
            bRemovedProbe = true;
            break;
        }
        param = m_aProbeParams[ProbeID].GetNext(param);
    }
    m_pCrst->Leave();

    return bRemovedProbe;
}

LPWSTR CustomerDebugHelper::GetConfigString(LPWSTR name)
{ 
    LPWSTR pResult = NULL;

    if ((pResult = EEConfig::GetConfigString(name)) != NULL)
    {
        return pResult;
    }
    
    LPWSTR pValue = NULL;
    EEStringData sKey((DWORD)wcslen(name) + 1, name);
    HashDatum datum;

    if(m_appConfigFile.GetValue(&sKey, &datum)) {
        pValue = (LPWSTR) datum;
    }
    
    if(pValue != NULL) {
        SIZE_T cValue = wcslen(pValue) + 1;
        pResult = new WCHAR[cValue];
        wcsncpy(pResult, pValue, cValue);
    }
    
    return pResult;
}


// Aggregated from functions in EEConfig. Will search for c:\pathToRunningExe\runningExe.exe.config
HRESULT CustomerDebugHelper::ReadAppConfigurationFile()
{
    HRESULT hr = S_OK;
    WCHAR version[_MAX_PATH];
    
    ComWrap<IXMLParser> pIXMLParser;
    ComWrap<IStream> pFile;
    ComWrap<EEConfigFactory> pFactory;

    // Get EE Version
    DWORD dwVersion = _MAX_PATH;
    IfFailGo(GetCORVersion(version, _MAX_PATH, & dwVersion));

    // Generate name of AppConfig file
    static LPWSTR DOT_CONFIG = L".config\0";
    WCHAR systemDir[_MAX_PATH + NumItems(DOT_CONFIG)];
    if (!WszGetModuleFileName(NULL, systemDir, _MAX_PATH))
    {
        hr = E_FAIL;
        goto ErrExit;
    }
    wcsncat(systemDir, DOT_CONFIG, NumItems(systemDir));

    pFactory = new EEConfigFactory(&m_appConfigFile, version);
    if (pFactory == NULL) {
        hr = E_OUTOFMEMORY; 
        goto ErrExit; 
    }
    pFactory->AddRef(); // EEConfigFactory ref count is 0 after it's created.
    
    IfFailGo(CreateConfigStream(systemDir, &pFile));      
    IfFailGo(GetXMLObject(&pIXMLParser));
    IfFailGo(pIXMLParser->SetInput(pFile)); // filestream's RefCount=2
    IfFailGo(pIXMLParser->SetFactory(pFactory)); // factory's RefCount=2
    IfFailGo(pIXMLParser->Run(-1));
    
ErrExit:  
    if (hr == XML_E_MISSINGROOT)
        hr = S_OK;

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr = S_FALSE;

    return hr;
}

HRESULT CustomerDebugHelper::ManagedOutputDebugString(LPCWSTR pMessage)
{
#ifdef DEBUGGING_SUPPORTED

    if (!pMessage)
        return S_OK;

    const static LPWSTR szCatagory = L"CDP";

    g_pDebugInterface->SendLogMessage (
                        0,                   // Level
                        (WCHAR*)szCatagory,          
                        NumItems(szCatagory),
                        (WCHAR*)pMessage,
                        (int)wcslen(pMessage) + 1
                        );
    return S_OK;
#endif // DEBUGGING_SUPPORTED
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dbginterface.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// COM+99 Debug Interface Header
//

#ifndef _dbgInterface_h_
#define _dbgInterface_h_

#include "common.h"
#include "EEDbgInterface.h"
#include "corjit.h"
#include "EnC.h"
#include "..\debug\inc\DbgIPCEvents.h"
//
// The purpose of this object is to serve as an entry point to the
// debugger, which used to reside in a seperate DLL.
//
class DebugInterface : public ICorDebugInfo
{
public:
    //
    // Functions exported from the debugger to the EE.
    //
    virtual HRESULT Startup(void) = 0;
    virtual void SetEEInterface(EEDebugInterface* i) = 0;
    virtual void StopDebugger(void) = 0;
    virtual BOOL IsStopped(void) = 0;

    virtual void ThreadCreated(Thread* pRuntimeThread) = 0;
    virtual void ThreadStarted(Thread* pRuntimeThread,
                               BOOL fAttaching) = 0;
    virtual void DetachThread(Thread *pRuntimeThread,
							  BOOL fHoldingThreadstoreLock = FALSE) = 0;

    virtual BOOL SuspendComplete(BOOL fHoldingThreadstoreLock) = 0;
    
    virtual void LoadModule(Module* pRuntimeModule,
                            IMAGE_COR20_HEADER* pCORHeader,
                            VOID* baseAddress,
                            LPCWSTR psModuleName,
                            DWORD dwModuleName,
                            Assembly *pAssembly,
                            AppDomain *pAppDomain,
                            BOOL fAttaching) = 0;
    virtual void UnloadModule(Module* pRuntimeModule, AppDomain *pAppDomain) = 0;
    virtual void DestructModule(Module *pModule) = 0;

    virtual BOOL LoadClass(EEClass *pRuntimeClass,
                           mdTypeDef classMetadataToken,
                           Module *classModule, 
                           AppDomain *pAppDomain,
                           BOOL fSendEventToAllAppDomains,
                           BOOL fAttaching) = 0;
    virtual void UnloadClass(mdTypeDef classMetadataToken,
                             Module *classModule,
                             AppDomain *pAppDomain,
                             BOOL fSendEventToAllAppDomains) = 0;

    virtual bool FirstChanceNativeException(EXCEPTION_RECORD *exception,
                                       CONTEXT *context,
                                       DWORD code,
                                       Thread *thread) = 0;
    virtual bool FirstChanceManagedException(bool continuable, CONTEXT *pContext) = 0;
    virtual LONG LastChanceManagedException(
            EXCEPTION_RECORD *pExceptionRecord, 
            CONTEXT *pContext,
            Thread *thread,
            UnhandledExceptionLocation location) = 0;


    virtual void ExceptionFilter(BYTE *pStack, MethodDesc *fd, SIZE_T offset) = 0;
    virtual void ExceptionHandle(BYTE *pStack, MethodDesc *fd, SIZE_T offset) = 0;

    // @TODO: maybe we need some params here
    virtual void ExceptionCLRCatcherFound()                                   = 0;

    virtual void FixupEnCInfo(EnCInfo *info,
    						  UnorderedEnCErrorInfoArray *pEnCError) = 0;

    virtual void SendUserBreakpoint(Thread *thread) = 0;

    virtual void UpdateModuleSyms(Module *pRuntimeModule,
                                  AppDomain *pAppDomain,
                                  BOOL fAttaching) = 0;
    
    // JITBeginning() is called before a method is jit-compiled and either it
    // needs debug info tracked (trackJITinfo==true), or a debugger is attached.
    // Note: perhaps have JITBeginning return a BOOL so the debugger
    // can decide wether or not to let the JIT take place?
    //
    virtual void JITBeginning(MethodDesc* fd, bool trackJITInfo) = 0;
                              
    // JITComplete() is called after a method is jit-compiled and either it
    // needs debug info tracked (trackJITinfo==true), or a debugger is attached.
    virtual void JITComplete(MethodDesc* fd,
                            BYTE* newAddress,
                            SIZE_T sizeOfCode,
                            bool trackJITInfo) = 0;

    // 
    // EnC functions
    virtual HRESULT IncrementVersionNumber(Module *pModule, 
                                           mdMethodDef token) = 0;

    virtual HRESULT UpdateFunction(MethodDesc* fd, 
                                   const UnorderedILMap *ilMap,
                                   UnorderedEnCRemapArray *pEnCRemapInfo,
                                   UnorderedEnCErrorInfoArray *pEnCError) = 0;

    // Used by the codemanager FixContextForEnC() to update
    virtual HRESULT MapILInfoToCurrentNative(MethodDesc *PFD, 
                                             SIZE_T ilOffset, 
                                             UINT mapType, 
                                             SIZE_T which, 
                                             SIZE_T *nativeFnxStart,
                                             SIZE_T *nativeOffset, 
                                             void *DebuggerVersionToken,
                                             BOOL *fAccurate) = 0;

    virtual HRESULT DoEnCDeferedWork(MethodDesc *pMd, 
                                     BOOL fAccurateMapping) = 0;

    virtual HRESULT ActivatePatchSkipForEnc(CONTEXT *pCtx,
                                            MethodDesc *pMD,
                                            BOOL fShortCircuit) = 0;

    virtual	void GetVarInfo(MethodDesc *       fd,         // [IN] method of interest
                            void *DebuggerVersionToken,    // [IN] which edit version
                            SIZE_T *           cVars,      // [OUT] size of 'vars'
                            const NativeVarInfo **vars     // [OUT] map telling where local vars are stored
                            ) = 0;

//    virtual bool InterpretedBreak(Thread *thread, const BYTE *ip) = 0;
    virtual DWORD GetPatchedOpcode(const BYTE *ip) = 0;

    virtual void FunctionStubInitialized(MethodDesc *fd, const BYTE *pStub) = 0;

    virtual void TraceCall(const BYTE *target) = 0;
    virtual void PossibleTraceCall(UMEntryThunk *pUMEntryThunk, Frame *pFrame) = 0;

    virtual bool ThreadsAtUnsafePlaces(void) = 0;

    virtual void PitchCode( MethodDesc *fd, const BYTE *pbAddr ) = 0;

	virtual void MovedCode( MethodDesc *fd, const BYTE *pbOldAddress,
                            const BYTE *pbNewAddress) = 0;

	virtual HRESULT LaunchDebuggerForUser (void) = 0;

	virtual void SendLogMessage (int iLevel, WCHAR *pCategory, int iCategoryLen,
                                 WCHAR *pMessage, int iMessageLen) = 0;

	virtual void SendLogSwitchSetting (int iLevel, int iReason, 
                                       WCHAR *pLogSwitchName, WCHAR *pParentSwitchName) = 0;

	virtual bool IsLoggingEnabled (void) = 0;
	virtual bool GetILOffsetFromNative (MethodDesc *PFD, 
										const BYTE *pbAddr,
										DWORD nativeOffset, 
										DWORD *ilOffset) = 0;

    virtual HRESULT GetILToNativeMapping(MethodDesc *pMD,
                                         ULONG32 cMap,
                                         ULONG32 *pcMap,
                                         COR_DEBUG_IL_TO_NATIVE_MAP map[]) = 0;

	virtual DWORD GetHelperThreadID(void ) = 0;
	virtual HRESULT	AddAppDomainToIPC (AppDomain *pAppDomain) = 0;
	virtual HRESULT RemoveAppDomainFromIPC (AppDomain *pAppDomain) = 0;
	virtual HRESULT UpdateAppDomainEntryInIPC (AppDomain *pAppDomain) = 0;
    virtual void SendCreateAppDomainEvent (AppDomain *pAppDomain,
                                           BOOL fAttaching) = 0;
    virtual void SendExitAppDomainEvent (AppDomain *pAppDomain) = 0;

    virtual void LoadAssembly(AppDomain* pRuntimeAppDomain, 
                              Assembly *pAssembly, 
                              BOOL fIsSystemAssembly,
                              BOOL fAttaching) = 0;
    virtual void UnloadAssembly(AppDomain *pAppDomain, Assembly* pAssembly) = 0;

    virtual HRESULT SetILInstrumentedCodeMap(MethodDesc *fd,
                                             BOOL fStartJit,
                                             ULONG32 cILMapEntries,
                                             COR_IL_MAP rgILMapEntries[]) = 0;

    virtual void EarlyHelperThreadDeath(void) = 0;

    virtual void ShutdownBegun(void) = 0;

    virtual HRESULT GetInprocICorDebug( IUnknown **iu, bool fThisThread ) = 0;
    virtual HRESULT SetInprocActiveForThread(BOOL fIsActive) = 0;
    virtual BOOL    GetInprocActiveForThread() = 0;
    virtual void    InprocOnThreadDestroy(Thread *pThread) = 0;

	virtual HRESULT NameChangeEvent(AppDomain *pAppDomain, Thread *pThread) = 0;
	virtual void IgnoreThreadDetach(void) = 0;

    virtual HRESULT SetCurrentPointerForDebugger( void *ptr,PTR_TYPE ptrType) = 0;
    virtual BOOL SendCtrlCToDebugger(DWORD dwCtrlType) = 0;

    virtual DebuggerModule *TranslateRuntimeModule(Module *pModule) = 0;

    // Allows the debugger to keep an up to date list of special threads
    virtual HRESULT UpdateSpecialThreadList(DWORD cThreadArrayLength, DWORD *rgdwThreadIDArray) = 0;

    // Updates the pointer for the debugger services
    virtual void SetIDbgThreadControl(IDebuggerThreadControl *pIDbgThreadControl) = 0;

    virtual HRESULT InitInProcDebug() = 0;
    virtual HRESULT UninitInProcDebug() = 0;

    virtual SIZE_T GetVersionNumber(MethodDesc *fd) = 0;

    virtual void SetVersionNumberLastRemapped(MethodDesc *fd, 
                                              SIZE_T nVersionRemapped) = 0;
                                              
    virtual void LockJITInfoMutex() = 0;
    
    virtual void UnlockJITInfoMutex() = 0;

    virtual void SetEnCTransitionIllegal(MethodDesc *fd) = 0;

    virtual DWORD GetRCThreadId() = 0;

    virtual HRESULT GetVariablesFromOffset(MethodDesc                 *pMD,
                                           UINT                        varNativeInfoCount, 
                                           ICorJitInfo::NativeVarInfo *varNativeInfo,
                                           SIZE_T                      offsetFrom, 
                                           CONTEXT                    *pCtx,
                                           DWORD                      *rgVal1,
                                           DWORD                      *rgVal2,
                                           BYTE                     ***rgpVCs) = 0;
                               
    virtual void SetVariablesAtOffset(MethodDesc                 *pMD,
                                      UINT                        varNativeInfoCount, 
                                      ICorJitInfo::NativeVarInfo *varNativeInfo,
                                      SIZE_T                      offsetTo, 
                                      CONTEXT                    *pCtx,
                                      DWORD                      *rgVal1,
                                      DWORD                      *rgVal2,
                                      BYTE                      **rgpVCs) = 0;

    virtual BOOL IsThreadContextInvalid(Thread *pThread) = 0;

    virtual AppDomainEnumerationIPCBlock *GetAppDomainEnumIPCBlock() = 0;
};

#endif // _dbgInterface_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dataimage.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _DATAIMAGE_H_
#define _DATAIMAGE_H_

#include "memorypool.h"
#include "rangetree.h"

class Module;
class MethodDesc;

class DataImage
{
  public:

    //
    // IDataStore is used to provide a container to a DiskImage which
    // will hold the resulting image, plus any relocation information.
    //
    // It can also provide support for generating several images for 
    // different modules at the same time.
    //

    enum ReferenceDest
    {
        REFERENCE_IMAGE,            // offset is an RVA into the IL module
        REFERENCE_FUNCTION,         // offset is FunctionPointer as returned
                                    // by GetFunctionPointer below. Offset is presumed
                                    // to be in the Library module.
        REFERENCE_STORE,            // offset is into the DataStore.  Offset is presumed
                                    // to be inthe library module.
    };

    enum Fixup
    {
        FIXUP_VA,
        FIXUP_RVA,
        FIXUP_RELATIVE,
    };

    enum Description
    {
        DESCRIPTION_MODULE,
        DESCRIPTION_METHOD_TABLE,
        DESCRIPTION_CLASS,
        DESCRIPTION_METHOD_DESC,
        DESCRIPTION_FIELD_DESC,
        DESCRIPTION_FIXUPS,
        DESCRIPTION_DEBUG,
        DESCRIPTION_OTHER,

        DESCRIPTION_COUNT
    };

    class IDataStore
    {
    public:
        // Called when total size is known - should allocate memory 
        // & return both pointer & base address in image.
        virtual HRESULT Allocate(ULONG size, 
                                 ULONG *sizesByDescription,
                                 void **baseMemory) = 0;

        // Called when data contains an internal reference.  
        virtual HRESULT AddFixup(ULONG offset,
                                 ReferenceDest dest,
                                 Fixup type) = 0;
    
        // Called when data contains a ppointer to fixup to
        // a token
        virtual HRESULT AddTokenFixup(ULONG offset,
                                      mdToken tokenType,
                                      Module *module) = 0;
    
        // Called when data contains a function address.  The data store
        // can return a fixed compiled code address if it is compiling
        // code for the module. 
        virtual HRESULT GetFunctionAddress(MethodDesc *pMD,
                                           void **pResult) = 0;

        // Called to keep track of attribution of space to tokens
        virtual HRESULT AdjustAttribution(mdToken, LONG size) = 0;

        // Called when an error occurs
        virtual HRESULT Error(mdToken token, HRESULT hr, OBJECTREF *pThrowable) = 0;
    };

// Experiments show that its important to keep the data accessed from the prejit file together. Moreover,
// this data should not be stranded all over the file since the OS prefetches multiple pages. 
// USE_ONE_SECTION is a quick way to change the layout of the EE data structs in the prejitted file.
// In future versions we can clean up this code to do more interesting mapping from section type to 
// file offset.
#define USE_ONE_SECTION 1

    //
    // The DataImage provides several "sections", which can be used
    // to sort data into different sets for locality control
    //
    enum Section
    {
        SECTION_MODULE = 0, // Must be first
#ifdef USE_ONE_SECTION
        SECTION_FIXUPS = 0,
        SECTION_BINDER = 0,
        SECTION_METHOD_DESC = 0,
        SECTION_METHOD_TABLE = 0,
        SECTION_METHOD_INFO = 0,
        SECTION_CLASS = 0,
        SECTION_FIELD_DESC = 0,
        SECTION_FIELD_INFO = 0,
        SECTION_RVA_STATICS = 0,
        SECTION_DEBUG = 0,
        
        SECTION_COUNT = 1
#else
        SECTION_FIXUPS,
        SECTION_BINDER,
        SECTION_METHOD_DESC,
        SECTION_METHOD_TABLE,
        SECTION_METHOD_INFO,
        SECTION_CLASS,
        SECTION_FIELD_DESC,
        SECTION_FIELD_INFO,
        SECTION_RVA_STATICS,
        SECTION_DEBUG,
        
        SECTION_COUNT
#endif // USE_ONE_SECTION
    };

    class InternedStructureTable : private CHashTableAndData<CNewData>
      {
      private:

          DataImage *m_pImage;

          struct InternedStructure
          {
              BYTE          *pData;
              ULONG         cData;
          };

          struct InternedStructureEntry
          {
              HASHENTRY     hash;
              InternedStructure structure;
          };

          BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
            {
                InternedStructure *s1 = (InternedStructure *)pc1;
                InternedStructureEntry *s2 = (InternedStructureEntry *)pc2;

                return !(s1->cData == s2->structure.cData
                         && memcmp(s1->pData, s2->structure.pData, s1->cData) == 0);
            }

          USHORT HASH(InternedStructure *s)
            {
                ULONG hash = HashBytes(s->pData, s->cData);

                return (USHORT) ((hash & 0xFFFF) ^ (hash >> 16));
            }

          BYTE *KEY(InternedStructure *s)
            {
                return (BYTE *) s;
            }

      public:

          InternedStructureTable()
            : CHashTableAndData<CNewData>(111)
          { 
              NewInit(111, sizeof(InternedStructureEntry), USHRT_MAX); 
          }

          void *FindData(void *data, ULONG size)
          {
              InternedStructure s = { (BYTE *) data, size };

              InternedStructureEntry *result = (InternedStructureEntry *) 
                Find(HASH(&s), KEY(&s));
              
              if (result == NULL)
                  return NULL;
              else
                  return result->structure.pData;

              // @nice: would be nice to double check that 
              // (section, description, align) match.
          }

          HRESULT StoreData(void *data, ULONG size)
          {
              _ASSERTE(FindData(data, size) == NULL);

              InternedStructure s = { (BYTE *) data, size };

              InternedStructureEntry *result = (InternedStructureEntry *) Add(HASH(&s));
              if (result == NULL)
                  return NULL;

              result->structure.pData = (BYTE *) data;
              result->structure.cData = size;
                
              return S_OK;
          }
      };

  public:

    DataImage(Module *module, IDataStore *store);
    ~DataImage();

    Module *GetModule() { return m_module; }

    //
    // Data is stored in the image store in three phases. 
    //

    //
    // In the first phase, all objects are assigned locations in the
    // data store.  This is done by calling StoreStructure on all
    // structures which are being stored into the image.
    //
    // This would typically done by methods on the objects themselves,
    // each of which stores itself and any objects it references.  
    // Reference loops must be explicitly tested for using IsStored.
    // (Each structure can be stored only once.)
    //

    HRESULT Pad(ULONG size, Section section, Description description, int align = 4);

    HRESULT StoreStructure(void *data, ULONG size, Section section, Description description, 
                           mdToken attribution = mdTokenNil, int align = 4);
    BOOL IsStored(void *data);
    BOOL IsAnyStored(void *data, ULONG size);

    HRESULT StoreInternedStructure(void *data, ULONG size, Section section, Description description,
                                   mdToken attribution = mdTokenNil, int align = 4);

    void ReattributeStructure(mdToken toToken, ULONG size, mdToken fromToken = mdTokenNil);

    //
    // In the second phase, data is actually copied into the destination
    // DataStore.  
    // 

    HRESULT CopyData();

    //
    // In the third phase fixups are applied to the data. This
    // phase is used to adjust internal pointers to point to the 
    // new locations, and to report relocations to the IDataStore.
    //
    // There are two main types of fixups:
    //   Pointer fixups - for fields containing pointers to 
    //     structures which are also being stored into the DataImage.
    //     These fields are fixed up with the new address which the
    //     structure will live at inside the DataImage's DataStore.
    //   Address fixups - for fields containing pointers to addresses
    //     inside a module's image. These are not fixed up by DataImage,
    //     (except that a change in base address between the current module
    //     and the DataStore's module will be fixed up.)  In some cases,
    //     the DataStore will want to perform additional fixup on these 
    //     addresses.
    //
    // In addition, either of these fixups can reference a module
    // which is external to the Module being stored.  In the former case,
    // the IDataStore must provide a pointer to the DataImage which corresponds
    // to the Module; in the latter, the base address is simply obtained from 
    // the Module itself.
    //
    // Finally, a structure may perform other arbitrary fixups on its fields by
    // calling GetImagePointer and GetImageAddress and manipulating the DataStore's
    // memory directly.
    //

    HRESULT FixupPointerField(void *pointerField, 
                              void *pointerValue = NULL,
                              ReferenceDest dest = REFERENCE_STORE,
                              Fixup type = FIXUP_VA,
                              BOOL endInclusive = FALSE);

    HRESULT FixupPointerFieldToToken(void *tokenField, 
                                     void *pointerValue = NULL,
                                     Module *module = NULL,
                                     mdToken tokenType = mdtTypeDef);

    HRESULT FixupPointerFieldMapped(void *pointerField,
                                    void *mappedValue,
                                    ReferenceDest dest = REFERENCE_STORE,
                                    Fixup type = FIXUP_VA);

    HRESULT ZeroField(void *field, SIZE_T size);
    void *GetImagePointer(void *pointer);
    SIZE_T GetImageAddress(void *pointer);

    HRESULT GetFunctionAddress(MethodDesc *pMethod, void **pResult)
      { return m_dataStore->GetFunctionAddress(pMethod, pResult); }

    HRESULT ZeroPointerField(void *pointerField) 
      { return ZeroField(pointerField, sizeof(void*)); }

    void SetInternedStructureFixedUp(void *data);
    BOOL IsInternedStructureFixedUp(void *data);

    ULONG GetSectionBaseOffset(Section section) { return m_sectionBases[section]; }

    BYTE *GetImageBase() { return m_imageBaseMemory; }

    HRESULT Error(mdToken token, HRESULT hr, OBJECTREF *pThrowable);

  private:
    struct MapEntry
    {
        RangeTree::Node node;

        USHORT          section;
        SIZE_T          offset;
    };

    Module *m_module;
    IDataStore *m_dataStore;

    RangeTree m_rangeTree;
    MemoryPool m_pool;

    InternedStructureTable m_internedTable;

    ULONG m_sectionBases[SECTION_COUNT+1];
    ULONG *m_sectionSizes;
    ULONG m_sizesByDescription[DESCRIPTION_COUNT];

    BYTE *m_imageBaseMemory;

    BYTE *GetMapEntryPointer(MapEntry *entry)
        { return m_imageBaseMemory + m_sectionBases[entry->section] + entry->offset; }

    SIZE_T GetMapEntryAddress(MapEntry *entry)
        { return m_sectionBases[entry->section] + entry->offset; }
};

#define ZERO_FIELD(f) ZeroField(&f, sizeof(f))

#endif // _DATAIMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\debugdebugger.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: DebugDebugger.h
**
** Author: Michael Panitz (mipanitz)
**
** Purpose: Native methods on System.Debug.Debugger
**
** Date:  April 2, 1998
**
===========================================================*/

#pragma once
#include <object.h>

class LogHashTable;


// ! WARNING !
// The following constants mirror the constants 
// declared in the class LoggingLevelEnum in the 
// System.Diagnostic package. Any changes here will also
// need to be made there.
#define     TraceLevel0     0
#define     TraceLevel1     1
#define     TraceLevel2     2
#define     TraceLevel3     3
#define     TraceLevel4     4
#define     StatusLevel0    20
#define     StatusLevel1    21
#define     StatusLevel2    22
#define     StatusLevel3    23
#define     StatusLevel4    24
#define     WarningLevel    40
#define     ErrorLevel      50
#define     PanicLevel      100

// ! WARNING !
// The following constants mirror the constants 
// declared in the class AssertLevelEnum in the 
// System.Diagnostic package. Any changes here will also
// need to be made there.
#define     FailDebug           0
#define     FailIgnore          1
#define     FailTerminate       2
#define     FailContinueFilter  3

#define     MAX_LOG_SWITCH_NAME_LEN     256

class DebugDebugger
{
    struct LogArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strMessage);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strModule);
        DECLARE_ECALL_I4_ARG( INT32, m_Level );
    };

    struct IsLoggingArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strModule);        
        DECLARE_ECALL_I4_ARG(INT32, m_Level);
    };
    
public:
    static void  __stdcall Break( LPVOID /*no args*/);
    static INT32 __stdcall Launch( LPVOID /*no args*/ );
    static INT32 __stdcall IsDebuggerAttached( LPVOID /*no args*/ );
    static void  __stdcall Log(const LogArgs *pArgs);
    static INT32 __stdcall IsLogging(const IsLoggingArgs *pArgs);
} ;




class StackFrameHelper:public Object
{
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    // classlib defintion of the StackFrameHelper class.
public:
    THREADBASEREF TargetThread;
    I4ARRAYREF rgiOffset;
    I4ARRAYREF rgiILOffset;
    PTRARRAYREF rgMethodInfo;
    PTRARRAYREF rgFilename;
    I4ARRAYREF rgiLineNumber;
    I4ARRAYREF rgiColumnNumber;
    int iFrameCount;
    BOOL fNeedFileInfo;

protected:
    StackFrameHelper() {}
    ~StackFrameHelper() {}

public:
    void SetFrameCount (int iCount) { iFrameCount = iCount;}
    int  GetFrameCount (void) { return iFrameCount;}
};

typedef StackFrameHelper* STACKFRAMEHELPERREF;


class DebugStackTrace
{   
public:

    struct GetStackFramesInternalArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_Exception);
        DECLARE_ECALL_I4_ARG(INT32, m_iSkip);
        DECLARE_ECALL_OBJECTREF_ARG(STACKFRAMEHELPERREF, m_StackFrameHelper);
    };

private:
    struct StackTraceElement {
        DWORD dwOffset; // todo ia64 isn't this a pointer?
        DWORD dwILOffset;
        MethodDesc *pFunc;
    };

    struct GetStackFramesData
    {
        // Used for the integer-skip version
        INT32   skip;
        INT32   NumFramesRequested;
        INT32   cElementsAllocated;
        INT32   cElements;
        StackTraceElement* pElements;
        THREADBASEREF   TargetThread;
        AppDomain *pDomain;

        GetStackFramesData() :  skip(0), 
                                NumFramesRequested (0),
                                cElementsAllocated(0), 
                                cElements(0), 
                                pElements(NULL),
                                TargetThread((THREADBASEREF)(size_t)NULL){}
    };


public:
    static void __stdcall GetStackFramesInternal(GetStackFramesInternalArgs *pargs);
private:
    static void GetStackFrames(Frame *pStartFrame, void* pStopStack, GetStackFramesData *pData);
    static void GetStackFramesFromException(OBJECTREF * e, GetStackFramesData *pData);
    static StackWalkAction GetStackFramesCallback(CrawlFrame* pCf, VOID* data);

} ;

class DebuggerAssert
{
private:
    struct AssertFailArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strMessage);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strCondition);
    };

public:
    static INT32 __stdcall ShowDefaultAssertDialog(AssertFailArgs *pArgs);
} ;


// The following code is hacked from object.h and modified to suit 
// LogSwitchBaseObject 
//  
class LogSwitchObject : public Object
{
  protected:
    // README:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class defintion of the LogSwitch object.

    STRINGREF m_strName;
    STRINGREF strDescription;
    OBJECTREF m_ParentSwitch;   
    OBJECTREF m_ChildSwitch;
    INT32 m_iLevel;
    INT32 m_iOldLevel;
    INT32 m_iNumChildren;
    INT32 m_iChildArraySize;

  protected:
    LogSwitchObject() {}
   ~LogSwitchObject() {}
   
  public:
    // check for classes that wrap Ole classes 

    void SetLevel(INT32 iLevel) 
    {
        m_iLevel = iLevel;
    }

    INT32 GetLevel() 
    {
        return m_iLevel;
    }

    OBJECTREF GetParent (void) { return m_ParentSwitch;}

    STRINGREF GetName (void) { return m_strName;}
};

typedef LogSwitchObject* LOGSWITCHREF;


#define MAX_KEY_LENGTH      64
#define MAX_HASH_BUCKETS    20

class HashElement
{
private:
    OBJECTHANDLE    m_pData;
    WCHAR   m_strKey [MAX_KEY_LENGTH];
    HashElement *m_pNext;

public:
    HashElement () 
    {
        m_pData = NULL;
        m_pNext = NULL;
        m_strKey[0] = L'\0';
    }

    ~HashElement()
    {
        if (m_pNext!= NULL)
            delete m_pNext;
        m_pNext=NULL;

    }// ~HashElement

    void SetData (OBJECTHANDLE pData, WCHAR *pKey) 
    {
        m_pData = pData;
        _ASSERTE (wcslen (pKey) < MAX_KEY_LENGTH);
        wcscpy (m_strKey, pKey);
    }

    OBJECTHANDLE GetData (void) { return m_pData;}
    WCHAR *GetKey (void) { return m_strKey;}
    void SetNext (HashElement *pNext) { m_pNext = pNext;}
    HashElement *GetNext (void) { return m_pNext;}
};

class LogHashTable
{
private:
    bool    m_Initialized;
    HashElement *m_Buckets [MAX_HASH_BUCKETS];

public:
    LogHashTable()
    {
        m_Initialized = false;
    }

    ~LogHashTable()
    {
    /*
        for(int i=0; i<MAX_HASH_BUCKETS;i++)
            if (m_Buckets[i])
                delete m_Buckets[i];
*/
    }// ~LogHashTable
#ifdef SHOULD_WE_CLEANUP
    void FreeMemory()
    {
        for(int i=0; i<MAX_HASH_BUCKETS;i++)
            if (m_Buckets[i])
                delete m_Buckets[i];
    }// Terminate
#endif /* SHOULD_WE_CLEANUP */
    void Init (void)
    {
        if (m_Initialized == false)
        {
            for (int i=0; i<MAX_HASH_BUCKETS; i++)
                m_Buckets [i] = NULL;

            m_Initialized = true;
        }
    }

    HRESULT LogHashTable::AddEntryToHashTable (WCHAR *pKey, OBJECTHANDLE pData);
    OBJECTHANDLE LogHashTable::GetEntryFromHashTable (WCHAR *pKey);
    
};
LogHashTable* GetStaticLogHashTable();

class Log
{
private:
    struct AddLogSwitchArg
    {
        DECLARE_ECALL_OBJECTREF_ARG(LOGSWITCHREF, m_LogSwitch);
    };

    struct ModifyLogSwitchArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strParentName);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, m_strLogSwitchName);
        DECLARE_ECALL_I4_ARG( INT32, m_Level );
    };

public:
    static INT32 __stdcall  AddLogSwitch (AddLogSwitchArg *pArgs);
    static void __stdcall   ModifyLogSwitch (ModifyLogSwitchArgs *pArgs);

    // The following method is called when the level of a log switch is modified
    // from the debugger. It is not an ecall.
    static void DebuggerModifyingLogSwitch (int iNewLevel, WCHAR *pLogSwitchName);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\debuggc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// debuggc.cpp
//
// This is the COM+ special garbage collector for internal use
// only.   It is designed to aid in the discovery of GC holes
// within the execution engine itself.
//
#include "common.h"
#include "log.h"
#include <stdlib.h>
#include <objbase.h>
#include "class.h"
#include "object.h"
#include "debuggc.h"
#include "gcdesc.h"
#include "frames.h"
#include "threads.h"
#include "ObjectHandle.h"
#include "EETwain.h"
#include "dataflow.h"
#include "inifile.h"
#include "gcscan.h"
#include "eeconfig.h"


// Comment out the following if you want to effectively disable contexts
#define TEMP_COMPLUS_CONTEXT



#if _DEBUG

#define ObjectToOBJECTREF(obj)     (OBJECTREF((obj),0))
#define OBJECTREFToObject(objref)  (*( (Object**) &(objref) ))
#define ObjectToSTRINGREF(obj)     (STRINGREF((obj),0))

#else   //_DEBUG

#define ObjectToOBJECTREF(obj)    (obj)
#define OBJECTREFToObject(objref) (objref)
#define ObjectToSTRINGREF(obj)    (obj)

#endif  //_DEBUG


// One point to note is how we finesse the handling of the ObjHeader.  This is
// allocated at a negative offset from the object.  The size of an object (and,
// thus, the allocation request) include this amount.  What we do is pre-advance
// m_pAlloc beyond the first ObjHeader during initialization.  From that point
// on, each allocation operation effectively reserves the ObjHeader for the
// next (not the current) request.  The advantage of this complexity is that
// we get the allocation and initialization of the ObjHeader for free.
//
//
// More details on ObjHeader handling:
// 1) On allocation m_pAlloc has already been pre-advanced when we create the
//    space so the first object has space for its ObjHeader.   Future Objects
//    get the space automatically from the allocation of the previous object...
//
// 2) On GC we advance the alloc and scan pointers to make room for the first
//    objects ObjHeader
//
// 3) When copying an object we copy source and destination from ptr - sizeof(ObjHeader)
//    so that we copy the ObjHeader.
//




//
// Hardcoded limit
//
// Currently the largest single object you can allocate is
// approximately HUGE_OBJECT_RESERVE....

#define HUGE_OBJECT_RESERVE (1024*1024)


// Objects in the heap must be aligned on 8 byte boundaries
#define OBJECT_ALIGNMENT        8
#define OBJECT_SIZE_ALIGN(x)    ( ((x)+(OBJECT_ALIGNMENT-1)) & (~(OBJECT_ALIGNMENT-1)) )

#define MEGABYTE            (1024 * 1024)

// A more generic alignment macro
#define ROUNDUP(x, align)       ( ((x)+((align)-1)) & (~((align)-1)) )

#define OS_PAGE_SIZE        4096

//
// Default amount of memory allocated between GC -- override by INI file setting
// (see InitializeGarbageCollector() for details of INI settings available)
//
#define GROWTH              (MEGABYTE * 3)

//
// This controls how much we can allocate between collections
//
UINT g_GCGrowthBetweenCollections = GROWTH;

/********************************************************************
 *
 *           S E M I  S P A C E  C A C H E     M E T H O D S
 *
 ********************************************************************/
inline DWORD SemiSpaceCache::GetMemSize()
{
    return( m_cbSumSpaces );
}


SemiSpaceCache::SemiSpaceCache()
{
    m_cbThreshold = 0;
    m_cbSumSpaces = 0;
}



void SemiSpaceCache::Shutdown()
{
    SemiSpace *victim;

    while (! m_SemiList.IsEmpty())
    {
        victim = m_SemiList.RemoveHead();
        m_cbSumSpaces -= victim->GetHeapMemSize();
        victim->ReleaseMemory();
        delete victim;
    }

    _ASSERTE(m_cbSumSpaces == 0);
}



HRESULT SemiSpaceCache::Initialize( DWORD cbThreshold )
{
    m_cbThreshold = cbThreshold;
    return(S_OK);
}



HRESULT SemiSpaceCache::Add( SemiSpace *pSemiSpace )
{
    _ASSERTE( pSemiSpace );

    m_cbSumSpaces += pSemiSpace->GetHeapMemSize();

    pSemiSpace->DeactivateMemory();

    m_SemiList.InsertTail( pSemiSpace );

    while (m_cbSumSpaces > m_cbThreshold)
    {
        SemiSpace *pVictimSpace;
        _ASSERTE(! m_SemiList.IsEmpty() );

        if (! m_SemiList.IsEmpty())
        {
            pVictimSpace = m_SemiList.RemoveHead();
            if (pVictimSpace)
            {
                m_cbSumSpaces -= pVictimSpace->GetHeapMemSize();
                pVictimSpace->ReleaseMemory();
                delete pVictimSpace;
            }
        }
    }

    return(S_OK);
}



HRESULT SemiSpaceCache::Find(LPBYTE address)
{
    return(E_NOTIMPL);
}





/********************************************************************
 *
 *           S E M I S P A C E    M E T H O D S
 *
 ********************************************************************/

HRESULT SemiSpace::AcquireMemory(DWORD cbSemiSpaceSize)
{
    m_cbCommitedSize = ROUNDUP( cbSemiSpaceSize, OS_PAGE_SIZE ) + g_GCGrowthBetweenCollections;
    m_cbReservedSize = m_cbCommitedSize + HUGE_OBJECT_RESERVE;


    // Reserve memory for our new semi-space
    m_pHeapMem = (LPBYTE) VirtualAlloc( 0, m_cbReservedSize, MEM_RESERVE, PAGE_READWRITE );
    if (! m_pHeapMem)
    {
    	//ARULM//RETAILMSG(1, (L"SemiSpace::AcquireMemory RESERVE failed. GLE=%d\r\n", GetLastError()));
        return E_FAIL;
	}
	
    // Commit the portion of the heap necessary
    if (! VirtualAlloc( m_pHeapMem, m_cbCommitedSize, MEM_COMMIT, PAGE_READWRITE ))
    {
    	//ARULM//RETAILMSG(1, (L"SemiSpace::AcquireMemory COMMIT failed. GLE=%d\r\n", GetLastError()));
        return E_FAIL;  //@TODO - cleanup alloc'ed memory?
    }

    // We zero init the new object space
    // - this is actually unnecessary for the portion we are copying from the old space...
    ZeroMemory( m_pHeapMem, m_cbCommitedSize );


    // Note that the limit is set here will be lowered by
    // GarbageCollect() once it figures out how much stuff
    // remained alive from the previous semi-space
    m_pLimit    = m_pHeapMem + m_cbCommitedSize;

    m_pAlloc    = m_pHeapMem;

    return( S_OK );
}


//
// Grow()
//
// Used to grow the semispace to accomidate an allocation that will take us
// beyond the commited portion of memory in this semispace.   We only do this
// once per semi-space
//

HRESULT SemiSpace::Grow( DWORD cbGrowth )
{
    // Notice here that I depend on Win32 allowing me to commit a region that is already
    // commited which is expressly allowed
    if (! VirtualAlloc( m_pHeapMem, m_cbCommitedSize + cbGrowth, MEM_COMMIT, PAGE_READWRITE ))
    {
        _ASSERTE(0);
        return E_FAIL;
    }

    // We need to zero-init the memory for our allocation sematics
    ZeroMemory( m_pHeapMem + m_cbCommitedSize, cbGrowth );

    return S_OK;
}



//
// DeactivateMemory()
//
// Makes the memory that used to contain objects prior to GC inaccessable
// to catch GC holes

HRESULT SemiSpace::DeactivateMemory()
{
    // Decommit the pages of the semi-space (which included some commited and some
    // non commited).   Access to a reserved, uncommited page results in an access violation
    // which indicates a GC reference which was not promoted
    if (! VirtualFree(m_pHeapMem, m_cbCommitedSize, MEM_DECOMMIT))
    {
        _ASSERTE(0);
        return E_FAIL;
    }

    return S_OK;
}


//
// ReleaseMemory()
//
// Free the reserved pages of a semispace (which take up virtual address space) so the
// system can make use of the pages for other requests.

HRESULT SemiSpace::ReleaseMemory()
{
    // VirtualFree will fail if you tell it how big a chunk to free...Go Figure.
    if (! VirtualFree(m_pHeapMem, 0, MEM_RELEASE))
        return E_FAIL;
    m_pHeapMem = NULL;

    return S_OK;
}


VOID SemiSpace::SaveLiveSizeInfo()
{
    SetBirthSize( m_pAlloc - m_pHeapMem );
    m_pLimit = m_pAlloc + g_GCGrowthBetweenCollections;

    // Whenever we allocate an object, we use a 'size' that includes an ObjHeader
    // at a negative offset from the start of the object.  So we adjust the
    // allocation point of the heap such that it gives us the offset to the
    // Object, even though it is allocating the ObjHeader before it.  Furthermore,
    // we zero the ObjHeader of the next object which means we cannot safely use
    // the last (sizeof(ObjHeader)) bytes in the space.
    ((ObjHeader *) m_pAlloc)->Init();
    m_pAlloc += sizeof(ObjHeader);
}



/********************************************************************
 *
 *           H E A P   M E T H O D S
 *
 ********************************************************************/

// For multi-threaded access to a single heap, ensure we only have one allocator
// at a time.  If a GC occurs, waiters will eventually time out and are guaranteed
// to move into preemptive GC mode.  This means they cannot deadlock the GC.
void DebugGCHeap::EnterAllocLock()
{
retry:
    if (FastInterlockExchange(&m_GCLock, 1) == 1)
    {
        unsigned int i = 0;
        while (m_GCLock == 1)
        {
            if (++i & 7)
                ::Sleep(0);
            else
            {
                // every 8th attempt:
                Thread *pCurThread = GetThread();

                pCurThread->EnablePreemptiveGC();
                ::Sleep(5);
                pCurThread->DisablePreemptiveGC();

                i = 0;
            }
        }
        goto retry;
    }
}

void DebugGCHeap::LeaveAllocLock()
{
    m_GCLock = 0;
}


size_t       DebugGCHeap::GetTotalBytesInUse()
{
    return m_pCurrentSpace->m_pAlloc - m_pCurrentSpace->m_pHeapMem;
}

/*
 * Initialize()
 *
 * This initializes the heap and makes it available for object
 * allocation
 */

HRESULT     DebugGCHeap::Initialize(DWORD cbSizeDeadSpace)
{
    HRESULT     hr = S_OK;


    g_GCGrowthBetweenCollections = ROUNDUP( g_GCGrowthBetweenCollections, OS_PAGE_SIZE );

    m_pCurrentSpace = new SemiSpace();
    if (! m_pCurrentSpace)
    {
        hr = E_FAIL;
        goto done;
    }


    if (FAILED(m_pCurrentSpace->AcquireMemory( 0 )))
    {
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(m_OldSpaceCache.Initialize(cbSizeDeadSpace)))
    {
        hr = E_FAIL;
        goto done;
    }

    m_pCurrentSpace->SaveLiveSizeInfo();

    m_bInGC = FALSE;

    m_WaitForGCEvent = ::WszCreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_WaitForGCEvent == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto done;
    }

  done:
    return( hr );
}


/*
 * Shutdown()
 *
 * Free up any resources that the heap has taken
 */

HRESULT DebugGCHeap::Shutdown()
{
    HRESULT hr = S_OK;

    if (m_pCurrentSpace)
    {
        delete m_pCurrentSpace;
        m_pCurrentSpace = NULL;
    }

    m_OldSpaceCache.Shutdown();

    return( hr );
}



/*
 * Forward()
 *
 * Forward copies an object into the new space and marks
 * the old object as forwarded so that other references
 * to the old object can be updated with the new location
 *
 * NOTE: new objectref (forwarded pointer) is stored in
 * NOTE: first data slot of old object
 */

void
DebugGCHeap::Forward( Object *&o, BYTE* low, BYTE* high, BOOL)
{
    Object *newloc;
    DebugGCHeap     *h = (DebugGCHeap *) g_pGCHeap;


    if (! o)
        return;

    _ASSERTE( h->pAlreadyPromoted->LookupValue( (ULONG) &o,1) == INVALIDENTRY);
    h->pAlreadyPromoted->InsertValue( (ULONG) &o, 1 );
    
    if (o->IsMarked())
    {
        o = o->GetForwardedLocation();
        return;
    }

    newloc = (Object *) h->m_pCurrentSpace->m_pAlloc;
    h->m_pCurrentSpace->m_pAlloc += OBJECT_SIZE_ALIGN(o->GetSize());

    CopyMemory( ((BYTE*)newloc)-sizeof(ObjHeader), ((BYTE*)o) - sizeof(ObjHeader), o->GetSize() );

    o->SetForwardedLocation( newloc );
    o->SetMarked();

    o = newloc;
}



Object* DebugGCHeap::Alloc(DWORD size, BOOL bFinalize, BOOL bContainsPointers)
{
    Object  *p;
    
    // Up size for alignment...
    size = OBJECT_SIZE_ALIGN(size);

    // Grab the allocation lock -- May allow GC to run....
    EnterAllocLock();

    // GCStress Testing
    if (g_pConfig->IsGCStressEnabled())
        GarbageCollectWorker();

    if (size >= HUGE_OBJECT_RESERVE)
    {
        _ASSERTE(! "Attempting to allocate an object whose size is larger than supported");
        p = NULL;
        goto exit;
    }

    // Did we use up all the space in this semi-space? yes, then we GC now
    if (m_pCurrentSpace->m_pAlloc > m_pCurrentSpace->m_pLimit)
    {
        GarbageCollectWorker();

        // Assert that GC was successful in making more room
        if (m_pCurrentSpace->m_pAlloc > m_pCurrentSpace->m_pLimit)
        {
            _ASSERTE(! "Internal GC Error....Unable to make memory available...Alloc > Limit");
            p = NULL;
            goto exit;
        }
    }


    // Do we need to use any of the reserves to handle this allocation?
    if ((m_pCurrentSpace->m_pAlloc + size) > m_pCurrentSpace->m_pLimit)
    {
        if (FAILED(m_pCurrentSpace->Grow((m_pCurrentSpace->m_pAlloc + size) - m_pCurrentSpace->m_pLimit)))
        {
            _ASSERTE(! "Internal GC Error...Unable to grow semispace to fit final object");
            p = NULL;
            goto exit;
        }
    }

    // save allocated object pointer
    p = (Object *) m_pCurrentSpace->m_pAlloc;

    // Advance the allocation pointer
    m_pCurrentSpace->m_pAlloc += size;

exit:
    // Let others allocate...
    LeaveAllocLock();

    return p;
}




/*
 * GarbageCollect()
 *
 * Perform a copying collection of all live objects
 */

HRESULT DebugGCHeap::GarbageCollect(BOOL forceFull, BOOL collectClasses)
{
    HRESULT     hr;
    DWORD       curgcnum = gcnum;
    
    forceFull, collectClasses;

    // By the time we have acquired the lock for the heap, someone else may have
    // performed a collection.  In that case, we need not bother.
    EnterAllocLock();
    hr = (curgcnum == gcnum ? GarbageCollectWorker() : S_OK);
    LeaveAllocLock();

    return hr;
}


/*
 * GarbageCollectWorker()
 *
 * Perform a copying collection of all live objects.  This is an internal service.
 * The requirement is that you must have call this service within an EnterAllocLock
 * and LeaveAllocLock pair.
 */

HRESULT DebugGCHeap::GarbageCollectWorker()
{
    GCCONTEXT   gcctx;
    SemiSpace  *pOldSpace;
    Thread     *pThread = NULL;
    HRESULT      hr;
    LPBYTE       pScanPointer;

    _ASSERTE( m_WaitForGCEvent != INVALID_HANDLE_VALUE);
    _ASSERTE(m_GCLock == 1);

  
    ::ResetEvent(m_WaitForGCEvent);

    _ASSERTE( ! m_bInGC );
    if (m_bInGC)
        return(E_FAIL);

    // Lock the thread store.  This prevents other threads from suspending us and it
    // prevents threads from being added or removed to the store while the collection
    // proceeds.
    ThreadStore::LockThreadStore();
    ThreadStore::TrapReturningThreads(TRUE);
    m_bInGC = TRUE;
    m_pGCThread = GetThread();

    hr = Thread::SysSuspendForGC();
    if (FAILED(hr))
        goto done;

    LOG((LF_GC, INFO3, "Starting GC [%4d]   %8d bytes used   %8d bytes in dead space\n", gcnum, m_pCurrentSpace->GetUsedSpace(), m_OldSpaceCache.GetMemSize() ));

    pOldSpace = m_pCurrentSpace;

    // Create a new semi-space
    m_pCurrentSpace = new SemiSpace();
    if (! m_pCurrentSpace)
    {
        hr = E_FAIL;
        goto done;
    }

    // Allocate memory for the new semispace
    if (FAILED(hr = m_pCurrentSpace->AcquireMemory(pOldSpace->GetUsedSpace())))
    {
        goto done;
    }

    // Chaneys Copying Collector Algorithm
    m_pCurrentSpace->m_pAlloc += sizeof(ObjHeader);
    pScanPointer = m_pCurrentSpace->m_pAlloc;

    // Hash table for already promoted object references
    pAlreadyPromoted = new HashMap();
	_ASSERTE(pAlreadyPromoted != NULL);
    if (!pAlreadyPromoted)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    pAlreadyPromoted->Init( (unsigned) 0, false);

    // Copy Roots
    gcctx.f     = Forward;
    gcctx.low   = (BYTE*) 0x00000000;
    gcctx.high  = (BYTE*) 0xFFFFFFFF;
    
    _ASSERTE(ThreadStore::DbgHoldingThreadStore());

    while ((pThread = ThreadStore::GetThreadList(pThread)) != NULL)
        pThread->StackWalkFrames( GcStackCrawlCallBack, &gcctx, 0);

    // Scan Root Table
    Ref_TraceNormalRoots(0, 0, (LPARAM) 0x00000000, (LPARAM) 0xFFFFFFFF);

    while (pScanPointer < m_pCurrentSpace->m_pAlloc)
    {
        CGCDesc         *map;
        CGCDescSeries   *cur;
        CGCDescSeries   *last;

        Object *o = (Object *) pScanPointer;

        if (o->GetMethodTable()->ContainsPointers())
        {
            map = o->GetSlotMap();
            cur = map->GetHighestSeries();
            last= map->GetLowestSeries();

            while (cur >= last)
            {
                Object **ppslot = (Object **) ((BYTE*)o + cur->GetSeriesOffset());
                Object **ppstop = (Object **) ((BYTE*)ppslot + cur->GetSeriesSize() + o->GetSize());
                while (ppslot < ppstop)
                {
                    Forward( *ppslot, gcctx.low, gcctx.high );
                    ppslot++;
                }
                cur--;
            }
        }

        pScanPointer += OBJECT_SIZE_ALIGN(o->GetSize());
    }

    //
    // Weak Pointer Scanning -
    //

    // Scan the weak pointers that do not persist across finalization
    Ref_CheckReachable(0, 0, (LPARAM) 0x00000000, (LPARAM) 0xFFFFFFFF );

    //@TODO Finalization
    

    // Scan the weak pointers that persist across finalization
    Ref_CheckAlive(    0, 0, (LPARAM) 0x00000000, (LPARAM) 0xFFFFFFFF );

    // Update weak and strong pointers
    Ref_UpdatePointers(0, 0, (LPARAM) 0x00000000, (LPARAM) 0xFFFFFFFF );

    // Delete hash table of promoted object references
    delete pAlreadyPromoted;

    // This allows for the next heap allocated to be smaller by
    // saving the size of the live set from the previous heap
    m_pCurrentSpace->SaveLiveSizeInfo();

    m_OldSpaceCache.Add( pOldSpace );

    LOG((LF_GC, INFO3, "Ending GC [%d]   %d bytes in use\n", gcnum, m_pCurrentSpace->GetUsedSpace() ));
    gcnum++;

  done:
    m_pGCThread = NULL;
    m_bInGC = FALSE;
    ThreadStore::TrapReturningThreads(FALSE);
    ::SetEvent(m_WaitForGCEvent);
    Thread::SysResumeFromGC();
    ThreadStore::UnlockThreadStore();
    return( hr );
}


// Threads that have enabled preemptive GC cannot switch back to cooperative GC mode
// if a GC is in progress.  Instead, they wait here.

#define DETECT_DEADLOCK_TIMEOUT     60000       // a minute of GC

void DebugGCHeap::WaitUntilGCComplete()
{
    if (IsGCInProgress())
    {
#if 0 && defined(_DEBUG)                        // enable timeout detection here
        DWORD   dbgResult;
        while (TRUE)
        {
            dbgResult = ::WaitForSingleObject(m_WaitForGCEvent, DETECT_DEADLOCK_TIMEOUT);
            if (dbgResult == WAIT_OBJECT_0)
                break;

            _ASSERTE(FALSE);
        }
#else
        ::WaitForSingleObject(m_WaitForGCEvent, INFINITE);
#endif
    }
}


//
// Mark Roots
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\debuggc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// 
// Garbage Collector for detecting GC holes in the execution engine
//

#ifndef _DEBUGGC_H_
#define _DEBUGGC_H_


//
// On Multiple GC Heaps and Base GC Heaps
//
// In order to permit dynamic choice of which GC implementation to use
// we have a base GC Heap class which is extended by actual heap
// implementations.   Currently we plan on two heap implementations
// one is for debugging purposes and one is the normal high performance
// generational GC
//
// This flexible implementation is for the specific purpose of being able
// to throw a registry switch and use the Debug GC when trying to track
// down a problem.
//
// In Retail releases this is a perf penalty, since many critical methods
// will be going through an unnecessary V-Table indirection.   So through
// use of #ifdef in retail the HighPerfGCHeap does not actually inherit
// from the BaseGCHeap.   It becomes the base gc heap implementation
// without virtual methods so it is faster.
//
// DEBUGGC enables the dynamically choosable GC and can be turned on
// even in a retail build


class BaseGCHeap
{
  public:
    virtual HRESULT     Initialize( DWORD cbSizeDeadSpace ) = 0;
    virtual HRESULT     Shutdown() = 0;
    virtual HRESULT     GarbageCollect(BOOL forceFull = FALSE, BOOL collectClasses = FALSE) = 0;
    virtual size_t      GetTotalBytesInUse() = 0;
    virtual BOOL        IsGCInProgress() = 0;
    virtual void        WaitUntilGCComplete() = 0;
    virtual Thread     *GetGCThread() = 0;
    virtual Object *Alloc( DWORD size, BOOL bFinalize, BOOL bContainsPointers ) = 0;
};







//
// The DebugGCHeap is a special GC Heap that is designed to
// aid in catching of GC hole bugs.   It is a copying collector
// which uses page protection to catch access to now dead objects
//
// It is implemented as a Cheney Copying Collector using many
// semispaces.   Old spaces are page protected to cause access
// violation on access.   This indicates a missed promotion of
// an object reference


/*
 *              S E M I S P A C E
 *
 * SemiSpace represents a "Semi-Space" in the heap.   Objects are
 * allocated in the "current" semi-space during execution.   At GC
 * all live objects are copied into new semi-space.
 *
 * In a classical copying collector there are only two semi-spaces.
 * In this special debug collector there can be many semi-spaces, only
 * one of which has valid memory pages at a time.
 *
 * The old semi-spaces are kept around to catch GC-Holes.
 *
 * NOTE: The amount of space allocated in a space may be wasteful
 * NOTE: this is because we cannot determine how much stuff is
 * NOTE: going to live from the previous space.   Without doing
 * NOTE: a full scan to measure the size, then another scan
 * NOTE: to copy the objects into the new space.  
 * NOTE: Instead, allocate the amount used by the previous space
 * NOTE: plus the growth amount.   The amount used by the previous
 * NOTE: space is computed by how much was carried into that space
 * NOTE: during the GC that created.
 * NOTE: 
 * NOTE: So - Heaps shrink but only with a delay of at least one GC
 */

class SemiSpace
{
    friend class DebugGCHeap;
    friend class SemiSpaceCache;

  public:
    SLink   m_Node;                 // Linked list linkage

  private:
    LPBYTE  m_pHeapMem;             // Memory Buffer for SemiSpace
    DWORD   m_cbCommitedSize;       // Size of Committed Memory Buffer
    DWORD   m_cbReservedSize;       // Total amount of virtual address spaced used
    LPBYTE  m_pAlloc;               // Allocation Pointer
    LPBYTE  m_pLimit;               // Allocation Limit (GC triggers when hit)
    DWORD   m_cbLiveAtBirth;        // Size caried into this space from previous space

  public:
    SemiSpace()  
    { 
        m_pAlloc = m_pHeapMem = m_pLimit = NULL;
        m_cbCommitedSize = m_cbLiveAtBirth = m_cbReservedSize = 0; 
    };
    
    ~SemiSpace()
    {
        if (m_pHeapMem)
        {
            ReleaseMemory();
        }
    };

    
    HRESULT     Grow( DWORD cbGrowth );
    HRESULT     AcquireMemory( DWORD cbSemiSpaceSize );
    HRESULT     DeactivateMemory();
    HRESULT     ReleaseMemory();

    VOID        SaveLiveSizeInfo();
    VOID        SetBirthSize( DWORD sz )        { m_cbLiveAtBirth = sz; };
    DWORD       GetUsedSpace()                  { return( m_pAlloc - m_pHeapMem ); };
    DWORD       GetHeapMemSize()                { return( m_cbReservedSize ); };
};




/*
 *              S E M I  S P A C E  C A C H E 
 *
 * The SemiSpaceCache represents a cache of old semi-spaces.   The
 * cache is kept limited by the sum of the space used by all the 
 * semi-spaces in the cache.    Eviction of the LRU semi-spaces
 * is performed to keep the total bytes in old semi-spaces below
 * the set threshold.
 *
 * The list allows one to search to see if any semi-space in the list
 * contains a given address.   This will be used to determine if a
 * fault was due to a GC hole.
 *
 */

typedef SList<SemiSpace, offsetof(SemiSpace, m_Node)> SemiSpaceList;

class SemiSpaceCache
{
    friend class DebugGCHeap;

  private:
    SemiSpaceList   m_SemiList;
    DWORD           m_cbThreshold;
    DWORD           m_cbSumSpaces;
    
  public:
    SemiSpaceCache();

    void Shutdown();
    
    DWORD       GetMemSize();
    HRESULT     Initialize( DWORD cbThreshold );
    HRESULT     Add( SemiSpace *space );
    HRESULT     Find( LPBYTE address );
};
    

/*
 *      D E B U G   G C  H E A P
 *
 */
 
class DebugGCHeap : public BaseGCHeap
{
  private:
    SemiSpace     *m_pCurrentSpace;
    SemiSpaceCache m_OldSpaceCache;
    BOOL            m_bInGC;
    DWORD           gcnum;
    HANDLE          m_WaitForGCEvent;
    LONG            m_GCLock;
    Thread         *m_pGCThread;

  private:
    VOID            MarkPhase();
    Object *    Forward(Object *o);

    void            EnterAllocLock();
    void            LeaveAllocLock();

    HRESULT         GarbageCollectWorker();
    HashMap        *pAlreadyPromoted;

  public:
    // Constructor/Destructor Do nothing useful
    DebugGCHeap()
    {
        gcnum = 0;
        m_pCurrentSpace = NULL;
        m_bInGC = FALSE;
        m_WaitForGCEvent = INVALID_HANDLE_VALUE;
        m_GCLock = 0;
        m_pGCThread = NULL;
        // alignment required for reliable atomic operations
        _ASSERTE((((UINT32) &m_GCLock) & 3) == 0);
    }

    ~DebugGCHeap()
    {
        if (m_WaitForGCEvent != INVALID_HANDLE_VALUE)
            CloseHandle(m_WaitForGCEvent);
    }

    // Initialization is necessary before the heap may be used
    // - the initial size is rounded up to the next OS page size
    virtual HRESULT     Initialize(DWORD cbSizeDeadSpace);

    virtual HRESULT     Shutdown();

    virtual HRESULT     GarbageCollect(BOOL forceFull, BOOL collectClasses);

    Object*         Alloc( DWORD size, BOOL bFinalize, BOOL fContainsPointers );

    static  void        Forward(Object *&o, BYTE* low, BYTE* high, 
								BOOL=FALSE);

    size_t GetTotalBytesInUse();

    virtual BOOL        IsGCInProgress()        { return m_bInGC; }
    virtual void        WaitUntilGCComplete();
    virtual Thread     *GetGCThread()           { return m_pGCThread; }
};



#endif _DEBUGGC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\debughelp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

//#ifdef DEBUGGING_SUPPORTED
//#ifndef GOLDEN
/*******************************************************************/
/* The folowing routines are useful to have around so that they can
   be called from the debugger 
*/
/*******************************************************************/
//#include "WinBase.h"
#include "StdLib.h"

void *DumpEnvironmentBlock(void)
{
   LPTSTR lpszVariable; 
   lpszVariable = (LPTSTR)GetEnvironmentStrings();
   char sz[4] = {0,0,0,0};
    
   while (*lpszVariable) 
      fprintf(stderr, "%c", *lpszVariable++); 
      
   fprintf(stderr, "\n"); 

    return GetEnvironmentStrings();
/*
    LPTSTR lpszVariable; 
    LPVOID lpvEnv; 
     
    lpvEnv = GetEnvironmentStrings(); 

    for (lpszVariable = (LPTSTR) lpvEnv; *lpszVariable; lpszVariable++) 
    { 
       while (*lpszVariable) 
          fprintf(stderr, "%c", *lpszVariable++); 
          
       fprintf(stderr, "\n"); 
    } 

    for (lpszVariable = (LPTSTR) lpvEnv; *lpszVariable; lpszVariable++) 
    { 
       while (*lpszVariable) 
          fprintf(stderr, "%C", *lpszVariable++); 
          
       fprintf(stderr, "\n"); 
    } 
*/
}

/*******************************************************************/
bool isMemoryReadable(const void* start, unsigned len) 
{
    void* buff = _alloca(len);
    return(ReadProcessMemory(GetCurrentProcess(), start, buff, len, 0) != 0);
}

/*******************************************************************/
MethodDesc* IP2MD(ULONG_PTR IP) {
    return(IP2MethodDesc((SLOT)IP));
}

/*******************************************************************/
MethodDesc* Entry2MethodDescMD(BYTE* entry) {
    return(Entry2MethodDesc((BYTE*) entry, 0));
}

/*******************************************************************/
/* if addr is a valid method table, return a poitner to it */
MethodTable* AsMethodTable(size_t addr) {
    MethodTable* pMT = (MethodTable*) addr;
    if (!isMemoryReadable(pMT, sizeof(MethodTable)))
        return(0);

    EEClass* cls = pMT->GetClass();
    if (!isMemoryReadable(cls, sizeof(EEClass)))
        return(0);

    if (cls->GetMethodTable() != pMT)
        return(0);

    return(pMT);
}

/*******************************************************************/
/* if addr is a valid method table, return a pointer to it */
MethodDesc* AsMethodDesc(size_t addr) {
    MethodDesc* pMD = (MethodDesc*) addr;

    if (!isMemoryReadable(pMD, sizeof(MethodDesc)))
        return(0);

    MethodDescChunk *chunk = MethodDescChunk::RecoverChunk(pMD);
    if (!isMemoryReadable(chunk, sizeof(MethodDescChunk)))
        return(0);

    MethodTable* pMT = chunk->GetMethodTable();
    if (AsMethodTable((size_t) pMT) == 0)
        return(0);

    return(pMD);
}

/*******************************************************************
/* check to see if 'retAddr' is a valid return address (it points to
   someplace that has a 'call' right before it), If possible it is 
   it returns the address that was called in whereCalled */

bool isRetAddr(size_t retAddr, size_t* whereCalled) 
{
            // don't waste time values clearly out of range
        if (retAddr < (size_t)BOT_MEMORY || retAddr > (size_t)TOP_MEMORY)   
            return false;

        BYTE* spot = (BYTE*) retAddr;
        if (!isMemoryReadable(&spot[-7], 7))
            return(false);

            // Note this is possible to be spoofed, but pretty unlikely
        *whereCalled = 0;
            // call XXXXXXXX
        if (spot[-5] == 0xE8) {         
            *whereCalled = *((int*) (retAddr-4)) + retAddr; 
            return(true);
            }

            // call [XXXXXXXX]
        if (spot[-6] == 0xFF && (spot[-5] == 025))  {
            if (isMemoryReadable(*((size_t**)(retAddr-4)),4)) {
                *whereCalled = **((size_t**) (retAddr-4));
                return(true);
            }
        }

            // call [REG+XX]
        if (spot[-3] == 0xFF && (spot[-2] & ~7) == 0120 && (spot[-2] & 7) != 4) 
            return(true);
        if (spot[-4] == 0xFF && spot[-3] == 0124)       // call [ESP+XX]
            return(true);

            // call [REG+XXXX]
        if (spot[-6] == 0xFF && (spot[-5] & ~7) == 0220 && (spot[-5] & 7) != 4) 
            return(true);

        if (spot[-7] == 0xFF && spot[-6] == 0224)       // call [ESP+XXXX]
            return(true);

            // call [REG]
        if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0020 && (spot[-1] & 7) != 4 && (spot[-1] & 7) != 5)
            return(true);

            // call REG
        if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0320 && (spot[-1] & 7) != 4)
            return(true);

            // There are other cases, but I don't believe they are used.
    return(false);
}


/*******************************************************************/
/* LogCurrentStack, pretty printing IL methods if possible. This
   routine is very robust.  It will never cause an access violation
   and it always find return addresses if they are on the stack 
   (it may find some spurious ones however).  */ 

int LogCurrentStack(BYTE* topOfStack, unsigned len)
{
    size_t* top = (size_t*) topOfStack;
    size_t* end = (size_t*) &topOfStack[len];

    size_t* ptr = (size_t*) (((size_t) top) & ~3);    // make certain dword aligned.
    size_t whereCalled;

    CQuickBytes qb;
    int nLen = MAX_CLASSNAME_LENGTH * 3 + 100;  // this should be enough
    wchar_t *buff = (wchar_t *) qb.Alloc(nLen *sizeof(wchar_t));
    if( buff == NULL)
        goto Exit;
    
    buff[nLen - 1] = L'\0'; // make sure the buffer is NULL-terminated

    while (ptr < end) 
    {
        if (!isMemoryReadable(ptr, sizeof(void*)))          // stop if we hit unmapped pages
            break;
        if (isRetAddr(*ptr, &whereCalled)) 
        {
            swprintf(buff,  L"found retAddr %#08X, %#08X, calling %#08X\n", 
                                                 ptr, *ptr, whereCalled);
            //WszOutputDebugString(buff);
            MethodDesc* ftn = IP2MethodDesc((BYTE*) *ptr);
            if (ftn != 0) {
                wcscpy(buff, L"    ");
                EEClass* cls = ftn->GetClass();
                if (cls != 0) {
                    DefineFullyQualifiedNameForClass();
                    LPCUTF8 clsName = GetFullyQualifiedNameForClass(cls);
                    if (clsName != 0) {
                        if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1,  L"%S::", clsName) <0)
                           goto Exit;
                    }
                }
#ifdef _DEBUG
                if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"%S%S\n", 
                            ftn->GetName(), ftn->m_pszDebugMethodSignature) <0)
                    goto Exit;                  
#else
                if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"%S\n", ftn->GetName()) <0)
                    goto Exit;
#endif
                LogInterop((LPWSTR)buff);
           }                        
        }
        ptr++;
    }
Exit:
    return(0);
}

extern LONG g_RefCount;
/*******************************************************************/
/* CoLogCurrentStack, log the stack from the current ESP.  Stop when we reach a 64K
   boundary */
int STDMETHODCALLTYPE CoLogCurrentStack(WCHAR * pwsz, BOOL fDumpStack) 
{
#ifdef _X86_
    if (g_RefCount > 0)
    {
        BYTE* top;
        __asm mov top, ESP;
    
        if (pwsz != NULL)
        {
            LogInterop(pwsz);
        }
        else
        {
            LogInterop("-----------\n");
        }
        if (fDumpStack)
            // go back at most 64K, it will stop if we go off the
            // top to unmapped memory
            return(LogCurrentStack(top, 0xFFFF));
        else
            return 0;
    }
#else
    _ASSERTE(!"@TODO IA64 - DumpCurrentStack(DebugHelp.cpp)");
#endif // _X86_
    return -1;
}

/*******************************************************************/
//  This function will return NULL if the buffer is not large enough.
/*******************************************************************/

wchar_t* formatMethodTable(MethodTable* pMT, wchar_t* buff, DWORD bufSize) {   
    EEClass* cls = pMT->GetClass();
    DefineFullyQualifiedNameForClass();
    if( bufSize == 0 )
        goto ErrExit;
    
    LPCUTF8 clsName = GetFullyQualifiedNameForClass(cls);
    if (clsName != 0) {
        if(_snwprintf(buff, bufSize - 1, L"%S", clsName) < 0)
            goto ErrExit;
        buff[ bufSize - 1] = L'\0';
    }
    return(buff);
ErrExit:
    return NULL;        
}

/*******************************************************************/
//  This function will return NULL if the buffer is not large enough, otherwise it will
//  return the buffer position for next write.
/*******************************************************************/

wchar_t* formatMethodDesc(MethodDesc* pMD, wchar_t* buff, DWORD bufSize) {
    if( bufSize == 0 )
        goto ErrExit;
    
    buff = formatMethodTable(pMD->GetMethodTable(), buff, bufSize);
    if( buff == NULL)
        goto ErrExit;

    buff[bufSize - 1] = L'\0';    // this will guarantee the buffer is also NULL-terminated
    if( _snwprintf( &buff[lstrlenW(buff)] , bufSize -lstrlenW(buff) - 1, L"::%S", pMD->GetName()) < 0)
        goto ErrExit;       

#ifdef _DEBUG
    if (pMD->m_pszDebugMethodSignature) {
        if( _snwprintf(&buff[lstrlenW(buff)], bufSize -lstrlenW(buff) - 1, L" %S", 
                     pMD->m_pszDebugMethodSignature) < 0)
            goto ErrExit;
    }
#endif;

    if(_snwprintf(&buff[lstrlenW(buff)], bufSize -lstrlenW(buff) - 1, L"(%x)", pMD) < 0)
        goto ErrExit;
    return(buff);
ErrExit:
    return NULL;    
}


/*******************************************************************/
/* dump the stack, pretty printing IL methods if possible. This
   routine is very robust.  It will never cause an access violation
   and it always find return addresses if they are on the stack 
   (it may find some spurious ones, however).  */ 

int dumpStack(BYTE* topOfStack, unsigned len) 
{
    size_t* top = (size_t*) topOfStack;
    size_t* end = (size_t*) &topOfStack[len];

    size_t* ptr = (size_t*) (((size_t) top) & ~3);    // make certain dword aligned.
    size_t whereCalled;
    WszOutputDebugString(L"***************************************************\n");
    while (ptr < end) 
    {
        CQuickBytes qb;
        int nLen = MAX_CLASSNAME_LENGTH * 4 + 400;  // this should be enough
        wchar_t *buff = (wchar_t *) qb.Alloc(nLen * sizeof(wchar_t) );
        if( buff == NULL)
            goto Exit;
    
        // Make sure we'll always be null terminated
        buff[nLen -1]=0;

        wchar_t* buffPtr = buff;
        if (!isMemoryReadable(ptr, sizeof(void*)))          // stop if we hit unmapped pages
            break;
        if (isRetAddr(*ptr, &whereCalled)) 
        {
            if( _snwprintf(buffPtr, buff+ nLen -buffPtr-1 ,L"STK[%08X] = %08X ", ptr, *ptr)  <0)
                goto Exit;
                
            buffPtr += lstrlenW(buffPtr);
            wchar_t* kind = L"RETADDR ";

               // Is this a stub (is the return address a MethodDesc?
            MethodDesc* ftn = AsMethodDesc(*ptr);
            if (ftn != 0) {
                kind = L"     MD PARAM";
                // If another true return address is not directly before it, it is just
                // a methodDesc param.
                size_t prevRetAddr = ptr[1];
                if (isRetAddr(prevRetAddr, &whereCalled) && AsMethodDesc(prevRetAddr) == 0)
                    kind = L"STUBCALL";
                else  {
                    // Is it the magic sequence used by CallDescr?
                    if (isMemoryReadable((void*) (prevRetAddr - sizeof(short)), sizeof(short)) &&
                        ((short*) prevRetAddr)[-1] == 0x5A59)   // Pop ECX POP EDX
                        kind = L"STUBCALL";
                }
            }
            else    // Is it some other code the EE knows about?
                ftn = IP2MethodDesc((BYTE*)(*ptr));

            if( _snwprintf(buffPtr, buff+ nLen -buffPtr-1, L"%s ", kind) < 0)
               goto Exit;
            buffPtr += lstrlenW(buffPtr);

            if (ftn != 0) {
                // buffer is not large enough
                if( formatMethodDesc(ftn, buffPtr, buff+ nLen -buffPtr-1) == NULL)
                    goto Exit;
                buffPtr += lstrlenW(buffPtr);                
            }
            else {
                wcsncpy(buffPtr, L"<UNKNOWN FTN>", buff+ nLen-buffPtr-1);
                buffPtr += lstrlenW(buffPtr);
            }

            if (whereCalled != 0) {
                if( _snwprintf(buffPtr, buff+ nLen -buffPtr-1, L" Caller called Entry %X", whereCalled) <0)
                    goto Exit;  
                buffPtr += lstrlenW(buffPtr);
            }

            wcsncpy(buffPtr, L"\n", buff+nLen -buffPtr-1);
            WszOutputDebugString(buff);
        }
        MethodTable* pMT = AsMethodTable(*ptr);
        if (pMT != 0) {
            if( _snwprintf(buffPtr, buff+ nLen -buffPtr-1, L"STK[%08X] = %08X          MT PARAM ", ptr, *ptr) <0)
                goto Exit;
            buffPtr += lstrlenW(buffPtr);
            if( formatMethodTable(pMT, buffPtr, buff+ nLen -buffPtr-1) == NULL)
                goto Exit;
            buffPtr += lstrlenW(buffPtr);
            
            wcsncpy(buffPtr, L"\n", buff+ nLen -buffPtr-1);
            WszOutputDebugString(buff);
        }
        ptr++;
    }
Exit:
    return(0);
}

/*******************************************************************/
/* dump the stack from the current ESP.  Stop when we reach a 64K
   boundary */
int DumpCurrentStack() 
{
#ifdef _X86_
    BYTE* top;
    __asm mov top, ESP;
    
        // go back at most 64K, it will stop if we go off the
        // top to unmapped memory
    return(dumpStack(top, 0xFFFF));
#else
    _ASSERTE(!"@TODO Alpha - DumpCurrentStack(DebugHelp.cpp)");
    return 0;
#endif // _X86_
}

/*******************************************************************/
WCHAR* StringVal(STRINGREF objref) {
    return(objref->GetBuffer());
}
    
LPCUTF8 NameForMethodTable(UINT_PTR pMT) {
    DefineFullyQualifiedNameForClass();
    LPCUTF8 clsName = GetFullyQualifiedNameForClass(((MethodTable*)pMT)->GetClass());
    // Note we're returning local stack space - this should be OK for using in the debugger though
    return clsName;
}

LPCUTF8 ClassNameForObject(UINT_PTR obj) {
    return(NameForMethodTable((UINT_PTR)(((Object*)obj)->GetMethodTable())));
}
    
LPCUTF8 ClassNameForOBJECTREF(OBJECTREF obj) {
    return(ClassNameForObject((UINT_PTR)(OBJECTREFToObject(obj))));
}

LPCUTF8 NameForMethodDesc(UINT_PTR pMD) {
    return(((MethodDesc*)pMD)->GetName());
}

LPCUTF8 ClassNameForMethodDesc(UINT_PTR pMD) {
    DefineFullyQualifiedNameForClass ();
    if (((MethodDesc *)pMD)->GetClass())
    {
        return GetFullyQualifiedNameForClass(((MethodDesc*)pMD)->GetClass());
    }
    else
        return "GlobalFunctions";
}

PCCOR_SIGNATURE RawSigForMethodDesc(MethodDesc* pMD) {
    return(pMD->GetSig());
}

Thread * CurrentThreadInfo ()
{
    return GetThread ();
}

AppDomain *GetAppDomainForObject(UINT_PTR obj)
{
    return ((Object*)obj)->GetAppDomain();
}

DWORD GetAppDomainIndexForObject(UINT_PTR obj)
{
    return ((Object*)obj)->GetHeader()->GetAppDomainIndex();
}

AppDomain *GetAppDomainForObjectHeader(UINT_PTR hdr)
{
    DWORD indx = ((ObjHeader*)hdr)->GetAppDomainIndex();
    if (! indx)
        return NULL;
    return SystemDomain::GetAppDomainAtIndex(indx);
}

DWORD GetAppDomainIndexForObjectHeader(UINT_PTR hdr)
{
    return ((ObjHeader*)hdr)->GetAppDomainIndex();
}

SyncBlock *GetSyncBlockForObject(UINT_PTR obj)
{
    return ((Object*)obj)->GetHeader()->GetRawSyncBlock();
}

#include "..\ildasm\formatType.cpp"
bool IsNameToQuote(const char *name) { return(false); }
/*******************************************************************/
void PrintTableForClass(UINT_PTR pClass)
{
    DefineFullyQualifiedNameForClass();
    LPCUTF8 name = GetFullyQualifiedNameForClass(((EEClass*)pClass));
    ((EEClass*)pClass)->DebugDumpVtable(name, true);
    ((EEClass*)pClass)->DebugDumpFieldLayout(name, true);
    ((EEClass*)pClass)->DebugDumpGCDesc(name, true);
}

void PrintMethodTable(UINT_PTR pMT)
{
  PrintTableForClass((UINT_PTR) ((MethodTable*)pMT)->GetClass() );
}

void PrintTableForMethodDesc(UINT_PTR pMD)
{
    PrintMethodTable((UINT_PTR) ((MethodDesc *)pMD)->GetClass()->GetMethodTable() );
}

void PrintException(OBJECTREF pObjectRef)
{
    COMPLUS_TRY {
        if(pObjectRef == NULL) 
            return;

        GCPROTECT_BEGIN(pObjectRef);

        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__EXCEPTION__INTERNAL_TO_STRING);        

        INT64 arg[1] = { 
            ObjToInt64(pObjectRef)
        };
        
        STRINGREF str = Int64ToString(pMD->Call(arg));

        if(str->GetBuffer() != NULL) {
            WszOutputDebugString(str->GetBuffer());
        }

        GCPROTECT_END();
    }
    COMPLUS_CATCH {
    } COMPLUS_END_CATCH;
} 

void PrintException(UINT_PTR pObject)
{
    OBJECTREF pObjectRef = NULL;
    GCPROTECT_BEGIN(pObjectRef);
    GCPROTECT_END();
}


/*******************************************************************/
char* FormatSig(MethodDesc* pMD) {

    CQuickBytes out;
    PCCOR_SIGNATURE pSig;
    ULONG cSig;
    pMD->GetSig(&pSig, &cSig);

    if (pSig == NULL)
        return "<null>";

    const char* sigStr = PrettyPrintSig(pSig, cSig, "*", &out, pMD->GetMDImport(), 0);

    char* ret = (char*) pMD->GetModule()->GetClassLoader()->GetHighFrequencyHeap()->AllocMem(strlen(sigStr)+1);
    strcpy(ret, sigStr);
    return(ret);
}

/*******************************************************************/
/* sends a current stack trace to the debug window */

struct PrintCallbackData {
    BOOL toStdout;
    BOOL withAppDomain;
#ifdef _DEBUG
    BOOL toLOG;
#endif
};

StackWalkAction PrintStackTraceCallback(CrawlFrame* pCF, VOID* pData)
{
    MethodDesc* pMD = pCF->GetFunction();
    wchar_t buff[2048];
    const int nLen = NumItems(buff) - 1;    // keep one character for "\n"
    buff[0] = 0;
    buff[nLen-1] = L'\0';                    // make sure the buffer is always NULL-terminated
    
    PrintCallbackData *pCBD = (PrintCallbackData *)pData;

    if (pMD != 0) {
        EEClass* cls = pMD->GetClass();
        LPCUTF8 nameSpace = 0;
        if (pCBD->withAppDomain)
            if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1,  L"{[%3.3x] %s} ", 
                           pCF->GetAppDomain()->GetId(), pCF->GetAppDomain()->GetFriendlyName(FALSE) )<0)
                goto Exit;
        if (cls != 0) {
            DefineFullyQualifiedNameForClass();
            LPCUTF8 clsName = GetFullyQualifiedNameForClass(cls);
            if (clsName != 0)
                if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"%S::", clsName) <0 )
                    goto Exit;
        }
        if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"%S %S  ", 
                                                pMD->GetName(), FormatSig(pMD)) < 0 )
            goto Exit;                                      
        if (pCF->IsFrameless() && pCF->GetJitManager() != 0) {
            METHODTOKEN methTok;
            IJitManager* jitMgr = pCF->GetJitManager();
            PREGDISPLAY regs = pCF->GetRegisterSet();
            
            DWORD offset;
            jitMgr->JitCode2MethodTokenAndOffset(*regs->pPC, &methTok, &offset);
            BYTE* start = jitMgr->JitToken2StartAddress(methTok);

#ifdef _X86_
            if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"JIT ESP:%X MethStart:%X EIP:%X(rel %X)", 
                           regs->Esp, start, *regs->pPC, offset) < 0)
                goto Exit;    
#elif defined(_ALPHA_)
            if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"JIT ESP:%X MethStart:%X EIP:%X(rel %X)", 
                          regs->IntSP, start, *regs->pPC, offset) <0 )
                goto Exit;
#endif
        } else
            if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"EE implemented") < 0)
                goto Exit;
    } else {
        if(_snwprintf(&buff[lstrlenW(buff)], nLen -lstrlenW(buff) - 1, L"EE Frame %x", pCF->GetFrame()) <0)
          goto Exit;            
    }

    wcscat(buff, L"\n");            // we have kept one character for this character
    if (pCBD->toStdout)
        PrintToStdOutW(buff);
#ifdef _DEBUG
    else if (pCBD->toLOG) {
        MAKE_ANSIPTR_FROMWIDE(sbuff, buff);
        LogSpewAlways("    %s\n", sbuff);
    }
#endif
    else
        WszOutputDebugString(buff);
Exit: 
    return SWA_CONTINUE;
}

void PrintStackTrace()
{
    WszOutputDebugString(L"***************************************************\n");
    PrintCallbackData cbd = {0, 0};
    GetThread()->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}

void PrintStackTraceToStdout()
{
    PrintCallbackData cbd = {1, 0};
    GetThread()->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}

#ifdef _DEBUG
void PrintStackTraceToLog()
{
    PrintCallbackData cbd = {0, 0, 1};
    GetThread()->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}
#endif

void PrintStackTraceWithAD()
{
    WszOutputDebugString(L"***************************************************\n");
    PrintCallbackData cbd = {0, 1};
    GetThread()->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}

void PrintStackTraceWithADToStdout()
{
    PrintCallbackData cbd = {1, 1};
    GetThread()->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}

#ifdef _DEBUG
void PrintStackTraceWithADToLog()
{
    PrintCallbackData cbd = {0, 1, 1};
    GetThread()->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}

void PrintStackTraceWithADToLog(Thread *pThread)
{
    PrintCallbackData cbd = {0, 1, 1};
    pThread->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}
#endif


/*******************************************************************/
// Get the system or current domain from the thread. 
BaseDomain* GetSystemDomain()
{
    return SystemDomain::System();
}

AppDomain* GetCurrentDomain()
{
    return SystemDomain::GetCurrentDomain();
}

void PrintDomainName(size_t ob)
{
    AppDomain* dm = (AppDomain*) ob;
    LPCWSTR st = dm->GetFriendlyName(FALSE);
    if(st != NULL)
        WszOutputDebugString(st);
    else
        WszOutputDebugString(L"<Domain with no Name>");
}

/*******************************************************************/
// Dump the SEH chain to stderr
void PrintSEHChain(void)
{
#ifdef _DEBUG
    EXCEPTION_REGISTRATION_RECORD* pEHR = (EXCEPTION_REGISTRATION_RECORD*) GetCurrentSEHRecord();
    
    while (pEHR != NULL && pEHR != (void *)-1)  
    {
        fprintf(stderr, "pEHR:0x%x  Handler:0x%x\n", (size_t)pEHR, (size_t)pEHR->Handler);
        pEHR = pEHR->Next;
    }
#endif    
}

/*******************************************************************/
// Dump some registers to stderr, given a context.  
// Useful for debugger-debugging
void PrintRegs(CONTEXT *pCtx)
{
#ifdef _X86_
    fprintf(stderr, "Edi:0x%x Esi:0x%x Ebx:0x%x Edx:0x%x Ecx:0x%x Eax:0x%x\n", 
        pCtx->Edi, pCtx->Esi, pCtx->Ebx, pCtx->Edx, pCtx->Ecx, pCtx->Eax);

    fprintf(stderr, "Ebp:0x%x Eip:0x%x Esp:0x%x EFlags:0x%x SegFs:0x%x SegCs:0x%x\n\n", 
        pCtx->Ebp, pCtx->Eip, pCtx->Esp, pCtx->EFlags, pCtx->SegFs, pCtx->SegCs);
#else // !_X86_
    _ASSERTE(!"@TODO - Port");
#endif // _X86_
}


/*******************************************************************/
// Get the current com object for the thread. This object is given
// to all COM objects that are not known at run time
MethodTable* GetDefaultComObject()
{
    return SystemDomain::GetDefaultComObject();
}


/*******************************************************************/
const char* GetClassName(void* ptr)
{
    DefineFullyQualifiedNameForClass();
    LPCUTF8 clsName = GetFullyQualifiedNameForClass(((EEClass*)ptr));
    // Note we're returning local stack space - this should be OK for using in the debugger though
    return (const char *) clsName;
}

#if defined(_X86_)       

#include "GCDump.h"

#include "..\GCDump\i386\GCDumpX86.cpp"

#include "..\GCDump\GCDump.cpp"

/*********************************************************************/
void printfToDbgOut(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);

    char buffer[4096];
    _vsnprintf(buffer, 4096, fmt, args);
    buffer[4096-1] = 0;

    OutputDebugStringA( buffer );
}


void DumpGCInfo(MethodDesc* method) {

    if (!method->IsJitted())
        return;

    SLOT methodStart = (SLOT) method->GetAddrofJittedCode();
    if (methodStart == 0)
        return;
    IJitManager* jitMan = ExecutionManager::FindJitMan(methodStart);
    if (jitMan == 0)
           return;
    ICodeManager* codeMan = jitMan->GetCodeManager();
    METHODTOKEN methodTok;
    DWORD methodOffs;
    jitMan->JitCode2MethodTokenAndOffset(methodStart, &methodTok, &methodOffs);
    _ASSERTE(methodOffs == 0);
    BYTE* table = (BYTE*) jitMan->GetGCInfo(methodTok);
    unsigned methodSize = (unsigned)codeMan->GetFunctionSize(table);

    GCDump gcDump;
    gcDump.gcPrintf = printfToDbgOut;
    InfoHdr header;
    printfToDbgOut ("Method info block:\n");
    table += gcDump.DumpInfoHdr(table, &header, &methodSize, 0);
    printfToDbgOut ("\n");
    printfToDbgOut ("Pointer table:\n");
    table += gcDump.DumpGCTable(table, header, methodSize, 0);
}

void DumpGCInfoMD(size_t method) {
    DumpGCInfo((MethodDesc*) method);
}

#endif  // _X86_

#ifdef LOGGING
void LogStackTrace()
{
    PrintCallbackData cbd = {0, 0, 1};
    GetThread()->StackWalkFrames(PrintStackTraceCallback, &cbd, 0, 0);
}
#endif

    // The functions above are ONLY meant to be used in the 'watch' window of a debugger.
    // Thus they are NEVER called by the runtime itself (except for diagnosic purposes etc.   
    // We DO want these funcitons in free (but not golden) builds because that is where they 
    // are needed the most (when you don't have nice debug fields that tell you the names of things).
    // To keep the linker from optimizing these away, the following array provides a
    // reference (and there is a reference to this array in EEShutdown) so that it looks
    // referenced 

void* debug_help_array[] = {
    PrintStackTrace,
    DumpCurrentStack,
    StringVal,
    NameForMethodTable,
    ClassNameForObject,
    ClassNameForOBJECTREF,
    NameForMethodDesc,
    RawSigForMethodDesc,
    ClassNameForMethodDesc,
    CurrentThreadInfo,
    IP2MD,
    Entry2MethodDescMD,
#if defined(_X86_)       // needs to be debug for printf capability
    DumpGCInfoMD
#endif // _DEBUG && _X86_
    };

//#endif // GOLDEN
//#endif // DEBUGGING_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\debugdebugger.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File: DebugDebugger.cpp
**
** Author: Michael Panitz (mipanitz)
**
** Purpose: Native methods on System.Debug.Debugger
**
** Date:  April 2, 1998
**
===========================================================*/

#include "common.h"

#include <object.h>
#include <winnls.h>
#include "ceeload.h"
#include "CorPermP.h"

#include "utilcode.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "field.h"
#include "COMStringCommon.h"
#include "COMString.h"
#include "gc.h"
#include "COMMember.h" 
#include "SigFormat.h"
#include "__product__.ver"
#include "JITInterface.h"
#include "COMSystem.h"
#include "DebugDebugger.h"
#include "DbgInterface.h"
#include "cordebug.h"
#include "corsym.h"

extern HRESULT QuickCOMStartup();

static LogHashTable LogHTable;

LogHashTable* GetStaticLogHashTable()
{
    return &LogHTable;
}// GetStaticLogHashTable

//Note: this code is copied from VM\JIT_UserBreakpoint, so propogate changes
//back to there
void DebugDebugger::Break( LPVOID /*no args*/)
{
#ifdef DEBUGGING_SUPPORTED
    _ASSERTE (g_pDebugInterface != NULL);

    g_pDebugInterface->SendUserBreakpoint(GetThread());
#endif // DEBUGGING_SUPPORTED
}

INT32 DebugDebugger::Launch( LPVOID /*no args*/ )
{
#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerAttached())
    {
        return TRUE;
    }
    else
    {
        _ASSERTE (g_pDebugInterface != NULL);


        if (SUCCEEDED (g_pDebugInterface->LaunchDebuggerForUser ()))
            return TRUE;

        }
#endif // DEBUGGING_SUPPORTED

    return FALSE;
}

INT32 DebugDebugger::IsDebuggerAttached( LPVOID /*no args*/ )
{
#ifdef DEBUGGING_SUPPORTED
    //verbose so that we'll return (INT32)1 or (INT32)0
    if (GetThread()->GetDomain()->IsDebuggerAttached())
        return TRUE;

#endif // DEBUGGING_SUPPORTED

    return FALSE;
}

void DebugDebugger::Log(const LogArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

#ifdef DEBUGGING_SUPPORTED
    IsLoggingArgs IsArgs;

    IsArgs.m_strModule = pArgs->m_strModule;
    IsArgs.m_Level = pArgs->m_Level;

    AppDomain *pAppDomain = GetThread()->GetDomain();

    // Send message for logging only if the 
    // debugger is attached and logging is enabled
    // for the given category
    if (pAppDomain->IsDebuggerAttached() || (IsArgs.m_Level == PanicLevel))
    {
        if ((IsLogging (&IsArgs) == TRUE) || (IsArgs.m_Level == PanicLevel))
        {
            int iCategoryLength = 0;
            int iMessageLength = 0;

            WCHAR   *pstrModuleName=NULL;
            WCHAR   *pstrMessage=NULL;
            WCHAR   wszSwitchName [MAX_LOG_SWITCH_NAME_LEN+1];
            WCHAR   *pwszMessage = NULL;

            wszSwitchName [0] = L'\0';

            if (pArgs->m_strModule != NULL)
            {
                RefInterpretGetStringValuesDangerousForGC (
                                    pArgs->m_strModule,
                                    &pstrModuleName,
                                    &iCategoryLength);

                if (iCategoryLength > MAX_LOG_SWITCH_NAME_LEN)
                {
                    wcsncpy (wszSwitchName, pstrModuleName, MAX_LOG_SWITCH_NAME_LEN);
                    wszSwitchName [MAX_LOG_SWITCH_NAME_LEN] = L'\0';
                    iCategoryLength = MAX_LOG_SWITCH_NAME_LEN;
                }
                else
                    wcscpy (wszSwitchName, pstrModuleName);
            }

            if (pArgs->m_strMessage != NULL)
            {   
                RefInterpretGetStringValuesDangerousForGC (
                                    pArgs->m_strMessage,
                                    &pstrMessage,
                                    &iMessageLength);
            }

            if ((iCategoryLength || iMessageLength) || (IsArgs.m_Level == PanicLevel))
            {
                bool fMemAllocated = false;
                if ((IsArgs.m_Level == PanicLevel) && (iMessageLength == 0))
                {
                    pwszMessage = L"Panic Message received";
                    iMessageLength = (int)wcslen (pwszMessage);
                }
                else
                {
                    pwszMessage = new WCHAR [iMessageLength + 1];
                    if (pwszMessage == NULL)
                        COMPlusThrowOM();

                    wcsncpy (pwszMessage, pstrMessage, iMessageLength);
                    pwszMessage [iMessageLength] = L'\0';
                    fMemAllocated = true;
                }

                g_pDebugInterface->SendLogMessage (
                                    pArgs->m_Level,
                                    wszSwitchName,
                                    iCategoryLength,
                                    pwszMessage,
                                    iMessageLength
                                    );

                if (fMemAllocated)
                    delete [] pwszMessage;
            }
        }
    }
#endif // DEBUGGING_SUPPORTED
}


INT32 DebugDebugger::IsLogging(const IsLoggingArgs *pArgs)
{
#ifdef DEBUGGING_SUPPORTED
    if (GetThread()->GetDomain()->IsDebuggerAttached())
        return (g_pDebugInterface->IsLoggingEnabled());
#endif // DEBUGGING_SUPPORTED
    return FALSE;
}

void __stdcall DebugStackTrace::GetStackFramesInternal(GetStackFramesInternalArgs *pargs)
{    
    HRESULT hr;
    ASSERT(pargs != NULL);
    ASSERT(pargs->m_iSkip >= 0);

    GetStackFramesData data;

    THROWSCOMPLUSEXCEPTION();

    data.pDomain = GetAppDomain();

    data.skip = pargs->m_iSkip;

    data.NumFramesRequested = pargs->m_StackFrameHelper->iFrameCount;

    if (pargs->m_Exception == NULL)
    {
        data.TargetThread = pargs->m_StackFrameHelper->TargetThread;
        GetStackFrames(NULL, (void*)-1, &data);
    }
    else
    {
        GetStackFramesFromException(&pargs->m_Exception, &data);
    }

    if (data.cElements != 0)
    {
        
        if (pargs->m_StackFrameHelper->fNeedFileInfo)
        {
            // Calls to COM up ahead.
            if (FAILED(hr = QuickCOMStartup()))
            {
                COMPlusThrowHR(hr);
            }
        }
        
        COMClass::EnsureReflectionInitialized();

        // Skip any JIT helpers...
        // @todo: where is the jit helper class? (Does it even exist anymore?)
        // MethodTable *pJithelperClass = g_Mscorlib.GetClass(CLASS__JIT_HELPERS);
        MethodTable *pJithelperClass = NULL;

        MethodTable *pMT = g_Mscorlib.GetClass(CLASS__METHOD_BASE);

        // Allocate memory for the MethodInfo objects
        PTRARRAYREF MethodInfoArray = (PTRARRAYREF) AllocateObjectArray(data.cElements,
                                                                        TypeHandle(pMT));

        if (!MethodInfoArray)
            COMPlusThrowOM();
        SetObjectReference( (OBJECTREF *)&(pargs->m_StackFrameHelper->rgMethodInfo), (OBJECTREF)MethodInfoArray,
                            pargs->m_StackFrameHelper->GetAppDomain());

        // Allocate memory for the Offsets 
        OBJECTREF Offsets = AllocatePrimitiveArray(ELEMENT_TYPE_I4, data.cElements);

        if (! Offsets)
            COMPlusThrowOM();
        SetObjectReference( (OBJECTREF *)&(pargs->m_StackFrameHelper->rgiOffset), (OBJECTREF)Offsets,
                            pargs->m_StackFrameHelper->GetAppDomain());

        // Allocate memory for the ILOffsets 
        OBJECTREF ILOffsets = AllocatePrimitiveArray(ELEMENT_TYPE_I4, data.cElements);

        if (! ILOffsets)
            COMPlusThrowOM();
        SetObjectReference( (OBJECTREF *)&(pargs->m_StackFrameHelper->rgiILOffset), (OBJECTREF)ILOffsets,
                            pargs->m_StackFrameHelper->GetAppDomain());

        // if we need Filename, linenumber, etc., then allocate memory for the same
        // Allocate memory for the Filename string objects
        PTRARRAYREF FilenameArray = (PTRARRAYREF) AllocateObjectArray(data.cElements, g_pStringClass);

        if (!FilenameArray)
            COMPlusThrowOM();
        SetObjectReference( (OBJECTREF *)&(pargs->m_StackFrameHelper->rgFilename), (OBJECTREF)FilenameArray,
                            pargs->m_StackFrameHelper->GetAppDomain());

        // Allocate memory for the Offsets 
        OBJECTREF LineNumbers = AllocatePrimitiveArray(ELEMENT_TYPE_I4, data.cElements);

        if (! LineNumbers)
            COMPlusThrowOM();
        SetObjectReference( (OBJECTREF *)&(pargs->m_StackFrameHelper->rgiLineNumber), (OBJECTREF)LineNumbers,
                            pargs->m_StackFrameHelper->GetAppDomain());

        // Allocate memory for the ILOffsets 
        OBJECTREF ColumnNumbers = AllocatePrimitiveArray(ELEMENT_TYPE_I4, data.cElements);

        if (! ColumnNumbers)
            COMPlusThrowOM();
        SetObjectReference( (OBJECTREF *)&(pargs->m_StackFrameHelper->rgiColumnNumber), (OBJECTREF)ColumnNumbers,
                            pargs->m_StackFrameHelper->GetAppDomain());

        int iNumValidFrames = 0;
        for (int i=0; i<data.cElements; i++)
        {
            OBJECTREF o;
            // Skip Jit Helper functions, since they can throw when you have
            // a bug in your code, such as an invalid cast. Also skip if it is 
            // a constructor 
            if (data.pElements[i].pFunc->GetMethodTable() != pJithelperClass)
            {
                if (data.pElements[i].pFunc->IsCtor())
                {
                    EEClass *pEEClass = data.pElements[i].pFunc->GetClass();

                    REFLECTCLASSBASEREF obj = (REFLECTCLASSBASEREF) pEEClass->GetExposedClassObject();
                
                    if (!obj) {
                        _ASSERTE(!"Didn't find Object");
                        FATAL_EE_ERROR();
                    }
                    
                    ReflectClass* pRC = (ReflectClass*) obj->GetData();
                    _ASSERTE(pRC);
                    ReflectMethodList* pRML = pRC->GetConstructors();
                    ReflectMethod* pRM = pRML->FindMethod(data.pElements[i].pFunc);
                    _ASSERTE(pRM);

                    o = (OBJECTREF) (pRM->GetConstructorInfo(
                                                             pRC));
                }
                else if (data.pElements[i].pFunc->IsStaticInitMethod())
                {
                    o = (OBJECTREF) (COMMember::g_pInvokeUtil->GetMethodInfo(
                                                                             data.pElements[i].pFunc));
                }
                else
                {
                    o = (OBJECTREF) (COMMember::g_pInvokeUtil->GetMethodInfo(
                                                                             data.pElements[i].pFunc));
                }

                pargs->m_StackFrameHelper->rgMethodInfo->SetAt(iNumValidFrames, o);

                // native offset
                I4 *pI4 = (I4 *)((I4ARRAYREF)pargs->m_StackFrameHelper->rgiOffset)
                    ->GetDirectPointerToNonObjectElements();
                pI4 [iNumValidFrames] = data.pElements[i].dwOffset; 

                // IL offset
                I4 *pILI4 = (I4 *)((I4ARRAYREF)pargs->m_StackFrameHelper->rgiILOffset)
                    ->GetDirectPointerToNonObjectElements();
                pILI4 [iNumValidFrames] = data.pElements[i].dwILOffset; 

                BOOL fFileInfoSet = FALSE;

                // check if the user wants the filenumber, linenumber info...
                if (pargs->m_StackFrameHelper->fNeedFileInfo)
                {
                    // Use the MethodDesc...
                    MethodDesc *pMethod = data.pElements[i].pFunc;
                    Module *pModule = pMethod->GetModule();

                    ULONG32 sourceLine = 0;
                    ULONG32 sourceColumn = 0;
                    WCHAR wszFileName[MAX_PATH];
                    ULONG32 fileNameLength = 0;

                    // Note: we need to enable preemptive GC when accessing the unmanages symbol store.
                    BEGIN_ENSURE_PREEMPTIVE_GC();

                    ISymUnmanagedReader *pISymUnmanagedReader = pModule->GetISymUnmanagedReader();

                    if (pISymUnmanagedReader != NULL)
                    {
                        ISymUnmanagedMethod *pISymUnmanagedMethod;  
                        hr = pISymUnmanagedReader->GetMethod(pMethod->GetMemberDef(), 
                                                             &pISymUnmanagedMethod);

                        if (SUCCEEDED(hr))
                        {
                            // get all the sequence points and the documents 
                            // associated with those sequence points.
                            // from the doument get the filename using GetURL()
                            ULONG32 SeqPointCount;
                            ULONG32 DummyCount;

                            hr = pISymUnmanagedMethod->GetSequencePointCount(&SeqPointCount);
                            _ASSERTE (SUCCEEDED(hr));

                            if (SUCCEEDED(hr) && SeqPointCount > 0)
                            {
                                // allocate memory for the objects to be fetched
                                ULONG32 *offsets = new ULONG32 [SeqPointCount];
                                ULONG32 *lines = new ULONG32 [SeqPointCount];
                                ULONG32 *columns = new ULONG32 [SeqPointCount];
                                ULONG32 *endlines = new ULONG32 [SeqPointCount];
                                ULONG32 *endcolumns = new ULONG32 [SeqPointCount];
                                ISymUnmanagedDocument **documents = 
                                    (ISymUnmanagedDocument **)new PVOID [SeqPointCount];

                                _ASSERTE (offsets && lines && columns 
                                          && documents && endlines && endcolumns);

                                if ((offsets && lines && columns && documents && endlines && endcolumns))
                                {
                                    hr = pISymUnmanagedMethod->GetSequencePoints (
                                                                                  SeqPointCount,
                                                                                  &DummyCount,
                                                                                  offsets,
                                                                                  (ISymUnmanagedDocument **)documents,
                                                                                  lines,
                                                                                  columns,
                                                                                  endlines,
                                                                                  endcolumns);

                                    _ASSERTE(SUCCEEDED(hr));
                                    _ASSERTE(DummyCount == SeqPointCount);

#ifdef _DEBUG
                                    {
                                        // This is just some debugging code to help ensure that the array
                                        // returned contains valid interface pointers.
                                        for (ULONG32 i = 0; i < SeqPointCount; i++)
                                        {
                                            _ASSERTE(documents[i] != NULL);
                                            _ASSERTE(!IsBadWritePtr((LPVOID)documents[i],
                                                                    sizeof(ISymUnmanagedDocument *)));
                                            documents[i]->AddRef();
                                            documents[i]->Release();
                                        }
                                    }
#endif

                                    if (SUCCEEDED(hr))
                                    {
                                        // This is the IL offset of the current frame
                                        DWORD dwCurILOffset = data.pElements[i].dwILOffset;

                                        // search for the correct IL offset
                                        for (DWORD j=0; j<SeqPointCount; j++)
                                        {
                                            // look for the entry matching the one we're looking for
                                            if (offsets[j] >= dwCurILOffset)
                                            {
                                                // if this offset is > what we're looking for, ajdust the index
                                                if (offsets[j] > dwCurILOffset && j > 0)
                                                    j--;

                                                break;
                                            }
                                        }

                                        // If we didn't find a match, default to the last sequence point
                                        if  (j == SeqPointCount)
                                            j--;

                                        while (lines[j] == 0x00feefee && j > 0)
                                            j--;

#ifdef DEBUGGING_SUPPORTED
                                        DWORD dwDebugBits = pModule->GetDebuggerInfoBits();
                                        if (CORDebuggerTrackJITInfo(dwDebugBits) && lines[j] != 0x00feefee)
                                        {
                                            sourceLine = lines [j];  
                                            sourceColumn = columns [j];  
                                        }
                                        else
#endif // DEBUGGING_SUPPORTED
                                        {
                                            sourceLine = 0;  
                                            sourceColumn = 0;  
                                        }

                                        // Also get the filename from the document...
                                        _ASSERTE (documents [j] != NULL);

                                        hr = documents [j]->GetURL (MAX_PATH, &fileNameLength, wszFileName);
                                        _ASSERTE (SUCCEEDED(hr));


                                        // indicate that the requisite information has been set!
                                        fFileInfoSet = TRUE;
                                    }                                 

                                    // free up all the allocated memory
                                    delete [] lines;
                                    delete [] columns;
                                    delete [] offsets;
                                    for (DWORD j=0; j<SeqPointCount; j++)
                                        documents [j]->Release();
                                    delete [] documents;
                                    delete [] endlines;
                                    delete [] endcolumns;
                                }
                            }

                            //
                            // touching unmanaged object...
                            //
                            pISymUnmanagedMethod->Release();
                        }
                    }

                    END_ENSURE_PREEMPTIVE_GC();
                    
                    if (fFileInfoSet == TRUE)
                    {
                        // Set the line and column numbers
                        I4 *pI4Line = (I4 *)((I4ARRAYREF)pargs->m_StackFrameHelper->rgiLineNumber)
                            ->GetDirectPointerToNonObjectElements();
                        I4 *pI4Column = (I4 *)((I4ARRAYREF)pargs->m_StackFrameHelper->rgiColumnNumber)
                            ->GetDirectPointerToNonObjectElements();

                        pI4Line [iNumValidFrames] = sourceLine;  
                        pI4Column [iNumValidFrames] = sourceColumn;  

                        // Set the file name
                        OBJECTREF o = (OBJECTREF) COMString::NewString(wszFileName);
                        pargs->m_StackFrameHelper->rgFilename->SetAt(iNumValidFrames, o);
                    }
                }


                if (fFileInfoSet == FALSE)
                {
                    I4 *pI4Line = (I4 *)((I4ARRAYREF)pargs->m_StackFrameHelper->rgiLineNumber)
                        ->GetDirectPointerToNonObjectElements();
                    I4 *pI4Column = (I4 *)((I4ARRAYREF)pargs->m_StackFrameHelper->rgiColumnNumber)
                        ->GetDirectPointerToNonObjectElements();
                    pI4Line [iNumValidFrames] = 0;
                    pI4Column [iNumValidFrames] = 0;

                    pargs->m_StackFrameHelper->rgFilename->SetAt(iNumValidFrames, NULL);
                    
                }

                iNumValidFrames++;
            }
        }

        pargs->m_StackFrameHelper->iFrameCount = iNumValidFrames;

        delete [] data.pElements;
    }
    else
        pargs->m_StackFrameHelper->iFrameCount = 0;

}



void DebugStackTrace::GetStackFrames(Frame *pStartFrame, void* pStopStack, GetStackFramesData *pData)
{
    THROWSCOMPLUSEXCEPTION();

    GetStackFramesData localData;
    ASSERT (pData != NULL);
    
    pData->cElements = 0;

    // if the caller specified (< 20) frames are required, then allocate
    // only that many
    if ((pData->NumFramesRequested != 0) && (pData->NumFramesRequested < 20))
       pData->cElementsAllocated = pData->NumFramesRequested;
    else
       pData->cElementsAllocated = 20;

    // Allocate memory for the initial 'n' frames
    pData->pElements = new (throws) StackTraceElement[pData->cElementsAllocated];
    
    bool fThreadStoreLocked = false;
    EE_TRY_FOR_FINALLY 
    {
        if (pData->TargetThread == NULL)
        {
            GetThread()->StackWalkFrames(GetStackFramesCallback, pData, FUNCTIONSONLY, pStartFrame);
        }
        else
        {
            Thread *pThread = pData->TargetThread->GetInternal();
            _ASSERTE (pThread != NULL);
            ThreadStore::LockThreadStore();
            fThreadStoreLocked = true;
            Thread::ThreadState state = pThread->GetSnapshotState();

            if (!((state & Thread::TS_Unstarted) ||
                  (state & Thread::TS_Dead) ||
                  (state & Thread::TS_Detached) ||
                  (state & Thread::TS_SyncSuspended) ||
                  (state & Thread::TS_UserSuspendPending)
                  ))
            {
                COMPlusThrow(kThreadStateException, IDS_EE_THREAD_BAD_STATE);
            }           

            pThread->StackWalkFrames(GetStackFramesCallback, pData, FUNCTIONSONLY, pStartFrame);
        }
    }
    EE_FINALLY
    {
        if (fThreadStoreLocked)
            ThreadStore::UnlockThreadStore();
        
    } EE_END_FINALLY
}

StackWalkAction DebugStackTrace::GetStackFramesCallback(CrawlFrame* pCf, VOID* data)
{
    GetStackFramesData* pData = (GetStackFramesData*)data;

    if (pData->pDomain != pCf->GetAppDomain())
        return SWA_CONTINUE;

    if (pData->skip > 0) {
        pData->skip--;
        return SWA_CONTINUE;
    }

    // @todo: How do we know what kind of frame we have?
    //        Can we always assume FramedMethodFrame?
    //        NOT AT ALL!!!, but we can assume it's a function
    //                       because we asked the stackwalker for it!
    MethodDesc* pFunc = pCf->GetFunction();

    if (pData->cElements >= pData->cElementsAllocated) {

        StackTraceElement* pTemp = new (nothrow) StackTraceElement[2*pData->cElementsAllocated];
        if (!pTemp)
            return SWA_ABORT;
        memcpy(pTemp, pData->pElements, pData->cElementsAllocated* sizeof(StackTraceElement));
        delete [] pData->pElements;
        pData->pElements = pTemp;
        pData->cElementsAllocated *= 2;
    }    

    pData->pElements[pData->cElements].pFunc = pFunc;

    SLOT ip;

    if (pCf->IsFrameless())
    {
        pData->pElements[pData->cElements].dwOffset = pCf->GetRelOffset();
        ip = *(pCf->GetRegisterSet()->pPC);
    }
    else
    {
        ip = (SLOT)((FramedMethodFrame*)(pCf->GetFrame()))->GetIP();

        pData->pElements[pData->cElements].dwOffset = (DWORD)(size_t)ip; // @TODO WIN64 - Pointer Truncation
    }

    // Also get the ILOffset
    DWORD ilOffset = -1;
#ifdef DEBUGGING_SUPPORTED
    g_pDebugInterface->GetILOffsetFromNative(
                            pFunc,
                            (const BYTE *)ip,
                            pData->pElements[pData->cElements].dwOffset, 
                            &ilOffset);
    pData->pElements[pData->cElements].dwILOffset = (DWORD)ilOffset;
#endif // DEBUGGING_SUPPORTED

    ++pData->cElements;

    // check if we already have the number of frames that the user had asked for
    if ((pData->NumFramesRequested != 0) 
        && 
        (pData->NumFramesRequested <= pData->cElements))
        return SWA_ABORT;

    return SWA_CONTINUE;
}


void DebugStackTrace::GetStackFramesFromException(OBJECTREF * e, GetStackFramesData *pData)
{
    THROWSCOMPLUSEXCEPTION();

    GetStackFramesData localData;
    ASSERT (pData != NULL);

    // Reasonable default, will indicate error on failure
    pData->cElements = 0;

    // Get the class for the exception
    EEClass *pExcepClass = (*e)->GetClass();
    if (!IsException(pExcepClass))
        return;

    // Get the _stackTrace field descriptor
    FieldDesc *pStackTraceFD = g_Mscorlib.GetField(FIELD__EXCEPTION__STACK_TRACE);

    // Now get the _stackTrace reference
    I1ARRAYREF pTraceData;
    pTraceData = I1ARRAYREF(pStackTraceFD->GetRefValue(*e));

    // Get the size of the array
    unsigned cbTraceData = 0;
    if (pTraceData != NULL)
        cbTraceData = pTraceData->GetNumComponents();
    else
        cbTraceData = 0;
    _ASSERTE(cbTraceData % sizeof(SystemNative::StackTraceElement) == 0);

    // The number of frame info elements in the stack trace info
    pData->cElements = cbTraceData / sizeof(SystemNative::StackTraceElement);

    // Now we know the size, allocate the information for the data struct
    if (cbTraceData != 0)
    {
        // Allocate the memory to contain the data
        pData->pElements = new (throws) StackTraceElement[pData->cElements];

        // Get a pointer to the actuall array data
        SystemNative::StackTraceElement *arrTraceData =
            (SystemNative::StackTraceElement *)pTraceData->GetDirectPointerToNonObjectElements();
        _ASSERTE(arrTraceData);

        GCPROTECT_BEGININTERIOR(arrTraceData);
        // Fill in the data
        for (unsigned i = 0; i < (unsigned)pData->cElements; i++)
        {
            SystemNative::StackTraceElement *pCur = &arrTraceData[i];

            // Fill out the MethodDesc*
            MethodDesc *pMD = pCur->pFunc;
            _ASSERTE(pMD);
            pData->pElements[i].pFunc = pMD;

            // Calculate the native offset
            // This doesn't work for framed methods, since internal calls won't
            // push frames and the method body is therefore non-contiguous.
            // Currently such methods always return an IP of 0, so they're easy
            // to spot.
            DWORD dwNativeOffset;
            if (pCur->ip)
                dwNativeOffset = (DWORD)(pCur->ip - pMD->GetNativeAddrofCode());
            else
                dwNativeOffset = 0;
            pData->pElements[i].dwOffset = dwNativeOffset;

#ifdef DEBUGGING_SUPPORTED
            // Calculate the IL offset using the debugging services
            bool bRes = g_pDebugInterface->GetILOffsetFromNative(
                pMD, (const BYTE *)pCur->ip, dwNativeOffset, &pData->pElements[i].dwILOffset);
#else // !DEBUGGING_SUPPORTED
            bool bRes = false;
#endif // !DEBUGGING_SUPPORTED

            // If there was no mapping information, then set to an invalid value
            if (!bRes)
                pData->pElements[i].dwILOffset = (DWORD)-1;
        }
        GCPROTECT_END();
    }
    else
        pData->pElements = NULL;

    return;
}

INT32 __stdcall DebuggerAssert::ShowDefaultAssertDialog(AssertFailArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    int result = IDRETRY;

    int iConditionLength = 0;
    int iMessageLength = 0;

    WCHAR   *pstrCondition=NULL;
    WCHAR   *pstrMessage=NULL;

    if (pArgs->m_strCondition != NULL)
    {
        RefInterpretGetStringValuesDangerousForGC (
                            pArgs->m_strCondition,
                            &pstrCondition,
                            &iConditionLength);
    }

    if (pArgs->m_strMessage != NULL)
    {   
        RefInterpretGetStringValuesDangerousForGC (
                            pArgs->m_strMessage,
                            &pstrMessage,
                            &iMessageLength);
    }
                                        
    WCHAR *pStr = new WCHAR [iConditionLength+iMessageLength+256];
    if (pStr == NULL)
        COMPlusThrowOM();

    wcscpy (pStr, L"Expression: ");
    wcscat (pStr, pstrCondition);
    wcscat (pStr, L"\n");
    wcscat (pStr, L"Description: ");
    wcscat (pStr, pstrMessage);
    wcscat (pStr, L"\n\n");
    wcscat (pStr, L"Press RETRY to attach debugger\n");

    // Give a message box to the user about the exception.
    WCHAR titleString[MAX_PATH + 64]; // extra room for title
    WCHAR fileName[MAX_PATH];
    
    if (WszGetModuleFileName(NULL, fileName, MAX_PATH))
        swprintf(titleString,
                 L"%s - Assert Failure",
                 fileName);
    else
        wcscpy(titleString, L"Assert Failure");

    // Toggle the threads's GC mode so that GC can occur
    Thread *pThread = GetThread();
    BOOL    fToggleGC = (pThread && pThread->PreemptiveGCDisabled());

    if (fToggleGC)
        pThread->EnablePreemptiveGC();

    result = WszMessageBoxInternal(NULL, pStr, titleString,
                           MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION);

    if (fToggleGC)
        pThread->DisablePreemptiveGC();

    // map the user's choice to the values recognized by 
    // the System.Diagnostics.Assert package
    if (result == IDRETRY)
        result = FailDebug;
    else if (result == IDIGNORE)
        result = FailIgnore;
    else
        result = FailTerminate;

    delete [] pStr;

    return result;
};


INT32 __stdcall Log::AddLogSwitch (AddLogSwitchArg *pArgs)
{
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    // Create a strong reference handle to the LogSwitch object
    OBJECTHANDLE ObjHandle = pThread->GetDomain()->CreateStrongHandle(NULL);
    StoreObjectInHandle (ObjHandle, ObjectToOBJECTREF(pArgs->m_LogSwitch));
    // Use  ObjectFromHandle(ObjHandle) to get back the object. 

    // From the given args, extract the LogSwitch name
    STRINGREF Name = ((LogSwitchObject *)pArgs->m_LogSwitch)->GetName();

    _ASSERTE (Name!= NULL);
    WCHAR *pstrCategoryName = NULL;
    int iCategoryLength = 0;
    WCHAR wszParentName [MAX_LOG_SWITCH_NAME_LEN+1];
    WCHAR wszSwitchName [MAX_LOG_SWITCH_NAME_LEN+1];
    wszParentName [0] = L'\0';
    wszSwitchName [0] = L'\0';

    // extract the (WCHAR) name from the STRINGREF object
    RefInterpretGetStringValuesDangerousForGC (
                        Name,
                        &pstrCategoryName,
                        &iCategoryLength);

    _ASSERTE (iCategoryLength > 0);
    if (iCategoryLength > MAX_LOG_SWITCH_NAME_LEN)
    {
        wcsncpy (wszSwitchName, pstrCategoryName, MAX_LOG_SWITCH_NAME_LEN);
        wszSwitchName [MAX_LOG_SWITCH_NAME_LEN] = L'\0';
    }
    else
        wcscpy (wszSwitchName, pstrCategoryName);

    // check if an entry with this name already exists in the hash table.
    // Duplicates are not allowed.
    if (LogHTable.GetEntryFromHashTable (pstrCategoryName) != NULL)
    {
        return (TYPE_E_DUPLICATEID);
    }

    HRESULT hresult = LogHTable.AddEntryToHashTable (pstrCategoryName,
                                            ObjHandle);

#ifdef DEBUGGING_SUPPORTED
    if (hresult == S_OK)
    {
        // tell the attached debugger about this switch
        if (GetThread()->GetDomain()->IsDebuggerAttached())
        {
            int iLevel = ((LogSwitchObject *)pArgs->m_LogSwitch)->GetLevel();
            WCHAR *pstrParentName = NULL;
            int iParentNameLength = 0;

            OBJECTREF tempobj = ((LogSwitchObject *)pArgs->m_LogSwitch)->GetParent();
            LogSwitchObject *pParent =
                    (LogSwitchObject *)(OBJECTREFToObject (tempobj));

            if (pParent != NULL)
            {
                // From the given args, extract the ParentLogSwitch's name
                STRINGREF strrefParentName = pParent->GetName();

                // extract the (WCHAR) name from the STRINGREF object
                RefInterpretGetStringValuesDangerousForGC (
                                    strrefParentName,
                                    &pstrParentName,
                                    &iParentNameLength);

                if (iParentNameLength > MAX_LOG_SWITCH_NAME_LEN)
                {
                    wcsncpy (wszParentName, pstrParentName, MAX_LOG_SWITCH_NAME_LEN);
                    wszParentName [MAX_LOG_SWITCH_NAME_LEN] = L'\0';
                }
                else
                    wcscpy (wszParentName, pstrParentName);
            }

            g_pDebugInterface->SendLogSwitchSetting (iLevel,
                                                    SWITCH_CREATE,
                                                    wszSwitchName,
                                                    wszParentName
                                                    );
        }
    }   
#endif // DEBUGGING_SUPPORTED

    return hresult;

}



void Log::ModifyLogSwitch (ModifyLogSwitchArgs *pArgs)
{
    _ASSERTE (pArgs->m_strLogSwitchName != NULL);
    
    WCHAR *pstrLogSwitchName = NULL;
    WCHAR *pstrParentName = NULL;
    int iSwitchNameLength = 0;
    int iParentNameLength = 0;
    WCHAR wszParentName [MAX_LOG_SWITCH_NAME_LEN+1];
    WCHAR wszSwitchName [MAX_LOG_SWITCH_NAME_LEN+1];
    wszParentName [0] = L'\0';
    wszSwitchName [0] = L'\0';

    // extract the (WCHAR) name from the STRINGREF object
    RefInterpretGetStringValuesDangerousForGC (
                        pArgs->m_strLogSwitchName,
                        &pstrLogSwitchName,
                        &iSwitchNameLength);

    if (iSwitchNameLength > MAX_LOG_SWITCH_NAME_LEN)
    {
        wcsncpy (wszSwitchName, pstrLogSwitchName, MAX_LOG_SWITCH_NAME_LEN);
        wszSwitchName [MAX_LOG_SWITCH_NAME_LEN] = L'\0';
    }
    else
        wcscpy (wszSwitchName, pstrLogSwitchName);

    // extract the (WCHAR) name from the STRINGREF object
    RefInterpretGetStringValuesDangerousForGC (
                        pArgs->m_strParentName,
                        &pstrParentName,
                        &iParentNameLength);

    if (iParentNameLength > MAX_LOG_SWITCH_NAME_LEN)
    {
        wcsncpy (wszParentName, pstrParentName, MAX_LOG_SWITCH_NAME_LEN);
        wszParentName [MAX_LOG_SWITCH_NAME_LEN] = L'\0';
    }
    else
        wcscpy (wszParentName, pstrParentName);

#ifdef DEBUGGING_SUPPORTED
    g_pDebugInterface->SendLogSwitchSetting (pArgs->m_Level,
                                            SWITCH_MODIFY,
                                            wszSwitchName,
                                            wszParentName
                                            );
#endif // DEBUGGING_SUPPORTED
}


void Log::DebuggerModifyingLogSwitch (int iNewLevel, WCHAR *pLogSwitchName)
{
    // check if an entry with this name exists in the hash table.
    OBJECTHANDLE ObjHandle = LogHTable.GetEntryFromHashTable (pLogSwitchName);
    if ( ObjHandle != NULL)
    {
        OBJECTREF obj = ObjectFromHandle (ObjHandle);
        LogSwitchObject *pLogSwitch = 
                (LogSwitchObject *)(OBJECTREFToObject (obj));

        pLogSwitch->SetLevel (iNewLevel);
    }
}


// Note: Caller should ensure that it's not adding a duplicate
// entry by calling GetEntryFromHashTable before calling this
// function.
HRESULT LogHashTable::AddEntryToHashTable (WCHAR *pKey, OBJECTHANDLE pData)
{
    HashElement *pElement;

    Init();

    // check that the length is non-zero
    if (pKey == NULL)
        return (E_INVALIDARG);

    int iHashKey = 0;
    int iLength = (int)wcslen (pKey);

    for (int i= 0; i<iLength; i++)
        iHashKey += pKey [i];

    iHashKey = iHashKey % MAX_HASH_BUCKETS;

    // Create a new HashElement
    if ((pElement = new HashElement) == NULL)
    {
        return (E_OUTOFMEMORY);
    }

    pElement->SetData (pData, pKey);

    if (m_Buckets [iHashKey] == NULL)
    {
        m_Buckets [iHashKey] = pElement;
    }
    else
    {
        pElement->SetNext (m_Buckets [iHashKey]);
        m_Buckets [iHashKey] = pElement;
    }

    return S_OK;
}



OBJECTHANDLE LogHashTable::GetEntryFromHashTable (WCHAR *pKey)
{

    if (pKey == NULL)
        return NULL;

    Init();

    int iHashKey = 0;
    int iLength = (int)wcslen (pKey);

    // Calculate the hash value of the given key
    for (int i= 0; i<iLength; i++)
        iHashKey += pKey [i];

    iHashKey = iHashKey % MAX_HASH_BUCKETS;

    HashElement *pElement = m_Buckets [iHashKey];

    // Find and return the data
    while (pElement != NULL)
    {
        if (wcscmp(pElement->GetKey(), pKey) == 0)
            return (pElement->GetData());

        pElement = pElement->GetNext();
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\delegateinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//depot/urt/main/clr/src/VM/DelegateInfo.h#1 - branch change 18945 (text)
/*============================================================
**
** Header: DelegateInfo.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.ThreadPool
**          and its inner classes
**
** Date:  August, 1999
** 
===========================================================*/
#ifndef DELEGATE_INFO
#define DELEGATE_INFO

#include "security.h"
#include "threadpool.h"


struct DelegateInfo;
typedef DelegateInfo* DelegateInfoPtr;

struct DelegateInfo
{
    DWORD           m_appDomainId;
    OBJECTHANDLE    m_delegateHandle;
    OBJECTHANDLE    m_stateHandle;
    OBJECTHANDLE    m_eventHandle;
    OBJECTHANDLE    m_registeredWaitHandle;
    CompressedStack* m_compressedStack;
    DWORD           m_overridesCount;
    AppDomainStack  m_ADStack;
    BOOL            m_hasSecurityInfo;
    



    void SetThreadSecurityInfo( Thread* thread, StackCrawlMark* stackMark )
    {
        CompressedStack* compressedStack = Security::GetDelayedCompressedStack();

        _ASSERTE( compressedStack != NULL && "Unable to generate compressed stack for this thread" );

        // Purposely do not AddRef here since GetDelayedCompressedStack() already returns with a refcount
        // of one.

        m_compressedStack = compressedStack;

        m_hasSecurityInfo = TRUE;
    }

    void Release()
    {
        AppDomain *pAppDomain = SystemDomain::GetAppDomainAtId(m_appDomainId);

        if (pAppDomain != NULL)
        {
            DestroyHandle(m_delegateHandle);
            DestroyHandle(m_stateHandle);
            DestroyHandle(m_eventHandle);
            DestroyHandle(m_registeredWaitHandle);
        }

        if (m_compressedStack != NULL)
            m_compressedStack->Release();
    }
    
    static DelegateInfo  *MakeDelegateInfo(OBJECTREF delegate, 
                                           AppDomain *pAppDomain, 
                                           OBJECTREF state,
                                           OBJECTREF waitEvent=NULL,
                                           OBJECTREF registeredWaitObject=NULL);
};





#endif // DELEGATE_INFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dispparammarshaler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Implementation of dispatch parameter marshalers.
**  
**      //  %%Created by: dmortens
===========================================================*/

#include "common.h"
#include "DispParamMarshaler.h"
#include "OleVariant.h"
#include "DispatchInfo.h"
#include "nstruct.h"

void DispParamMarshaler::MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    OleVariant::MarshalObjectForOleVariant(pSrcVar, pDestObj);
}

void DispParamMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    OleVariant::MarshalOleVariantForObject(pSrcObj, pDestVar);
}

void DispParamMarshaler::MarshalManagedToNativeRef(OBJECTREF *pSrcObj, VARIANT *pRefVar)
{
    OleVariant::MarshalOleRefVariantForObject(pSrcObj, pRefVar);
}

void DispParamMarshaler::CleanUpManaged(OBJECTREF *pObj)
{
}

void DispParamCurrencyMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;

    // Convert the managed decimal to a VARIANT containing a decimal.
    OleVariant::MarshalOleVariantForObject(pSrcObj, pDestVar);
    _ASSERTE(pDestVar->vt == VT_DECIMAL);

    // Coerce the decimal to a currency.
    IfFailThrow(SafeVariantChangeType(pDestVar, pDestVar, 0, VT_CY));
}

void DispParamOleColorMarshaler::MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL bByref = FALSE;
    VARTYPE vt = V_VT(pSrcVar);

    // Handle byref VARIANTS
    if (vt & VT_BYREF)
    {
        vt = vt & ~VT_BYREF;
        bByref = TRUE;
    }

    // Validate the OLE variant type.
    if (vt != VT_I4 && vt != VT_UI4)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);

    // Retrieve the OLECOLOR.
    int OleColor = bByref ? *V_I4REF(pSrcVar) : V_I4(pSrcVar);

    // Convert the OLECOLOR to a System.Drawing.Color.
    SYSTEMCOLOR MngColor;
    ConvertOleColorToSystemColor(OleColor, &MngColor);

    // Box the System.Drawing.Color value class and give back the boxed object.
    TypeHandle hndColorType = 
        GetThread()->GetDomain()->GetMarshalingData()->GetOleColorMarshalingInfo()->GetColorType();
    *pDestObj = hndColorType.GetMethodTable()->Box(&MngColor, TRUE);
}

void DispParamOleColorMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    // Clear the destination VARIANT.
    SafeVariantClear(pDestVar);

    // Convert the System.Drawing.Color to an OLECOLOR.
    V_VT(pDestVar) = VT_I4;
    V_I4(pDestVar) = ConvertSystemColorToOleColor((SYSTEMCOLOR*)(*pSrcObj)->UnBox());
}

void DispParamErrorMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    // Convert the managed decimal to a VARIANT containing a VT_I4 or VT_UI4.
    OleVariant::MarshalOleVariantForObject(pSrcObj, pDestVar);
    _ASSERTE(V_VT(pDestVar) == VT_I4 || V_VT(pDestVar) == VT_UI4);

    // Since VariantChangeType refuses to coerce an I4 or an UI4 to a VT_ERROR, just
    // wack the variant type directly.
    V_VT(pDestVar) = VT_ERROR;
}

void DispParamInterfaceMarshaler::MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL bByref = FALSE;
    VARTYPE vt = V_VT(pSrcVar);

    // Handle byref VARIANTS
    if (vt & VT_BYREF)
    {
        vt = vt & ~VT_BYREF;
        bByref = TRUE;
    }

    // Validate the OLE variant type.
    if (vt != VT_UNKNOWN && vt != VT_DISPATCH)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);

    // Retrieve the IP.
    IUnknown *pUnk = bByref ? *V_UNKNOWNREF(pSrcVar) : V_UNKNOWN(pSrcVar);

    // Convert the IP to an OBJECTREF.
    *pDestObj = GetObjectRefFromComIP(pUnk, m_pClassMT, m_bClassIsHint);
}

void DispParamInterfaceMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    SafeVariantClear(pDestVar);
    V_VT(pDestVar) = m_bDispatch ? VT_DISPATCH : VT_UNKNOWN;
    if (m_pIntfMT != NULL)
    {
        V_UNKNOWN(pDestVar) = GetComIPFromObjectRef(pSrcObj, m_pIntfMT);          
    }
    else
    {
        V_UNKNOWN(pDestVar) = GetComIPFromObjectRef(pSrcObj, m_bDispatch ? ComIpType_Dispatch : ComIpType_Unknown, NULL);
    }
}

void DispParamArrayMarshaler::MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    VARTYPE vt = m_ElementVT;
    MethodTable *pElemMT = m_pElementMT;

    THROWSCOMPLUSEXCEPTION();

    // Validate the OLE variant type.
    if ((V_VT(pSrcVar) & VT_ARRAY) == 0)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);   

    // Retrieve the SAFEARRAY pointer.
    SAFEARRAY *pSafeArray = V_VT(pSrcVar) & VT_BYREF ? *V_ARRAYREF(pSrcVar) : V_ARRAY(pSrcVar);

    if (pSafeArray)
    {
        // Retrieve the variant type if it is not specified for the parameter.
        if (vt == VT_EMPTY)
            vt = V_VT(pSrcVar) & ~VT_ARRAY | VT_BYREF;

        if (!pElemMT && vt == VT_RECORD)
            pElemMT = OleVariant::GetElementTypeForRecordSafeArray(pSafeArray).GetMethodTable();

        // Create an array from the SAFEARRAY.
        *(BASEARRAYREF*)pDestObj = OleVariant::CreateArrayRefForSafeArray(pSafeArray, vt, pElemMT);

        // Convert the contents of the SAFEARRAY.
        OleVariant::MarshalArrayRefForSafeArray(pSafeArray, (BASEARRAYREF*)pDestObj, vt, pElemMT);
    }
    else
    {
        *pDestObj = NULL;
    }
}

void DispParamArrayMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    SAFEARRAY *pSafeArray = NULL;
    VARTYPE vt = m_ElementVT;
    MethodTable *pElemMT = m_pElementMT;

    // Clear the destination VARIANT.
    SafeVariantClear(pDestVar);

    EE_TRY_FOR_FINALLY
    {
        if (*pSrcObj != NULL)
        {
            // Retrieve the VARTYPE if it is not specified for the parameter.
            if (vt == VT_EMPTY)
                vt = OleVariant::GetElementVarTypeForArrayRef(*((BASEARRAYREF*)pSrcObj));

            // Retrieve the element method table if it is not specified for the parameter.
            if (!pElemMT)
                pElemMT = OleVariant::GetArrayElementTypeWrapperAware((BASEARRAYREF*)pSrcObj).GetMethodTable();

            // Allocate the safe array based on the source object and the destination VT.
            pSafeArray = OleVariant::CreateSafeArrayForArrayRef((BASEARRAYREF*)pSrcObj, vt, pElemMT);
            _ASSERTE(pSafeArray);

            // Marshal the contents of the SAFEARRAY.
            OleVariant::MarshalSafeArrayForArrayRef((BASEARRAYREF*)pSrcObj, pSafeArray, vt, pElemMT);
        }

        // Store the resulting SAFEARRAY in the destination VARIANT.
        V_ARRAY(pDestVar) = pSafeArray;
        V_VT(pDestVar) = VT_ARRAY | vt;

        // Set pSafeArray to NULL so we don't destroy it.
        pSafeArray = NULL;
    }
    EE_FINALLY
    {
        if (pSafeArray)
            SafeArrayDestroy(pSafeArray);
    }
    EE_END_FINALLY     
}

void DispParamArrayMarshaler::MarshalManagedToNativeRef(OBJECTREF *pSrcObj, VARIANT *pRefVar)
{
    THROWSCOMPLUSEXCEPTION();

    VARIANT vtmp;
    VARTYPE RefVt = V_VT(pRefVar) & ~VT_BYREF;

    // Clear the contents of the original variant.
    OleVariant::ExtractContentsFromByrefVariant(pRefVar, &vtmp);
    SafeVariantClear(&vtmp);

    // Marshal the array to a temp VARIANT.
    memset(&vtmp, 0, sizeof(VARIANT));
    MarshalManagedToNative(pSrcObj, &vtmp);

    // Verify that the type of the temp VARIANT and the destination byref VARIANT
    // are the same.
    if (V_VT(&vtmp) != RefVt)
    {
        SafeVariantClear(&vtmp);
        COMPlusThrow(kInvalidCastException, IDS_EE_CANNOT_COERCE_BYREF_VARIANT);
    }

    // Copy the converted variant back into the byref variant.
    OleVariant::InsertContentsIntoByrefVariant(&vtmp, pRefVar);
}

void DispParamRecordMarshaler::MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    THROWSCOMPLUSEXCEPTION();

    GUID argGuid;
    GUID paramGuid;
    HRESULT hr = S_OK;
    VARTYPE vt = V_VT(pSrcVar);

    // Handle byref VARIANTS
    if (vt & VT_BYREF)
        vt = vt & ~VT_BYREF;

    // Validate the OLE variant type.
    if (vt != VT_RECORD)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);

    // Make sure an IRecordInfo is specified.
    IRecordInfo *pRecInfo = pSrcVar->pRecInfo;
    if (!pRecInfo)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);

    // Make sure the GUID of the IRecordInfo matches the guid of the 
    // parameter type.
    IfFailThrow(pRecInfo->GetGuid(&argGuid));
    if (argGuid != GUID_NULL)
    {
        m_pRecordMT->GetClass()->GetGuid(&paramGuid, TRUE);
        if (paramGuid != argGuid)
            COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);
    }

    OBJECTREF BoxedValueClass = NULL;
    GCPROTECT_BEGIN(BoxedValueClass)
    {
        LPVOID pvRecord = pSrcVar->pvRecord;
        if (pvRecord)
        {
            // Allocate an instance of the boxed value class and copy the contents
            // of the record into it.
            BoxedValueClass = FastAllocateObject(m_pRecordMT);
            FmtClassUpdateComPlus(&BoxedValueClass, (BYTE*)pvRecord, FALSE);
        }

        *pDestObj = BoxedValueClass;
    }
    GCPROTECT_END();
}

void DispParamRecordMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    // Clear the destination VARIANT.
    SafeVariantClear(pDestVar);

    // Convert the value class to a VT_RECORD.
    OleVariant::ConvertValueClassToVariant(pSrcObj, pDestVar);

    // Set the VT in the VARIANT.
    V_VT(pDestVar) = VT_RECORD;
}

void DispParamCustomMarshaler::MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL bByref = FALSE;
    VARTYPE vt = V_VT(pSrcVar);

    // Handle byref VARIANTS
    if (vt & VT_BYREF)
    {
        vt = vt & ~VT_BYREF;
        bByref = TRUE;
    }

    // Make sure the source VARIANT is of a valid type.
    if (vt != VT_I4 && vt != VT_UI4 && vt != VT_UNKNOWN && vt != VT_DISPATCH)
        COMPlusThrow(kInvalidCastException, IDS_EE_INVALID_VT_FOR_CUSTOM_MARHALER);

    // Retrieve the IUnknown pointer.
    IUnknown *pUnk = bByref ? *V_UNKNOWNREF(pSrcVar) : V_UNKNOWN(pSrcVar);

    // Marshal the contents of the VARIANT using the custom marshaler.
    *pDestObj = m_pCMHelper->InvokeMarshalNativeToManagedMeth(pUnk);
}

void DispParamCustomMarshaler::MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    IUnknown *pUnk = NULL;
    IDispatch *pDisp = NULL;

    // Convert the object using the custom marshaler.
    SafeVariantClear(pDestVar);

    // Invoke the MarshalManagedToNative method.
    pUnk = (IUnknown*)m_pCMHelper->InvokeMarshalManagedToNativeMeth(*pSrcObj);
    if (!pUnk)
    {
        // Put a null IDispath pointer in the VARIANT.
        V_VT(pDestVar) = VT_DISPATCH;
        V_DISPATCH(pDestVar) = NULL;
    }
    else
    {
        // QI the object for IDispatch.
        HRESULT hr = SafeQueryInterface(pUnk, IID_IDispatch, (IUnknown **)&pDisp);
        LogInteropQI(pUnk, IID_IDispatch, hr, "DispParamCustomMarshaler::MarshalManagedToNative");
        if (SUCCEEDED(hr))
        {
            // Release the IUnknown pointer since we will put the IDispatch pointer in 
            // the VARIANT.
            ULONG cbRef = SafeRelease(pUnk);
            LogInteropRelease(pUnk, cbRef, "Release IUnknown");

            // Put the IDispatch pointer into the VARIANT.
            V_VT(pDestVar) = VT_DISPATCH;
            V_DISPATCH(pDestVar) = pDisp;
        }
        else
        {
            // Put the IUnknown pointer into the VARIANT.
            V_VT(pDestVar) = VT_UNKNOWN;
            V_UNKNOWN(pDestVar) = pUnk;
        }
    }
}

void DispParamCustomMarshaler::MarshalManagedToNativeRef(OBJECTREF *pSrcObj, VARIANT *pRefVar)
{
    THROWSCOMPLUSEXCEPTION();

    VARTYPE RefVt = V_VT(pRefVar) & ~VT_BYREF;
    VARIANT vtmp;

    // Clear the contents of the original variant.
    OleVariant::ExtractContentsFromByrefVariant(pRefVar, &vtmp);
    SafeVariantClear(&vtmp);

    // Convert the object using the custom marshaler.
    V_UNKNOWN(&vtmp) = (IUnknown*)m_pCMHelper->InvokeMarshalManagedToNativeMeth(*pSrcObj);
    V_VT(&vtmp) = m_vt;

    // Call VariantChangeType if required.
    if (V_VT(&vtmp) != RefVt)
    {
        HRESULT hr = SafeVariantChangeType(&vtmp, &vtmp, 0, RefVt);
        if (FAILED(hr))
        {
            SafeVariantClear(&vtmp);
            if (hr == DISP_E_TYPEMISMATCH)
                COMPlusThrow(kInvalidCastException, IDS_EE_CANNOT_COERCE_BYREF_VARIANT);
            else
                COMPlusThrowHR(hr);
        }
    }

    // Copy the converted variant back into the byref variant.
    OleVariant::InsertContentsIntoByrefVariant(&vtmp, pRefVar);
}

void DispParamCustomMarshaler::CleanUpManaged(OBJECTREF *pObj)
{
    m_pCMHelper->InvokeCleanUpManagedMeth(*pObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dump-tables.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**
 * File: dump-tables.cpp
 *
 * Rational
 * --------
 * In the beginning...there was Strike.  And Strike was good.  It allowed
 * attaching NTSD to a managed process/dump file to get information about the
 * process, which was useful for debugging.
 *
 * Strike had one problem: in order to operate, it required full PDBs for the
 * entire runtime.  This wasn't usually an issue, as the only people who
 * needed Strike had access to the PDBs.
 *
 * However, PSS wanted a version of strike that they could send to customers.
 * Their customers would often have problems, and the usual ways PSS helped
 * was through "trace files" or dump files.
 *
 * With trace files, PSS sends the customer a DLL and a script, and directs
 * the customer to execute the script (which attaches NTSD, executes some more
 * script, and saves the output).  The output is sent back to PSS for review,
 * and (hopefully) a solution to the customers problem.
 *
 * The problem with this is that debugging in the CLR requires assistance from
 * the managed process, which prevents NTSD from being used as a managed
 * debugger.  Additionally, using a managed debugger (e.g. cordbg) might not
 * be possible because it might not be on their machine, while NTSD will
 * *always* be on their machine.
 *
 * Thus, we needed an NTSD extension DLL that does what Strike does, but
 * without requiring PDBs.  This is Son Of Strike (SOS).
 *
 * Strike required PDBs so that it could duplicate key data structures within
 * its own address space.  For example, if it came across an ArrayClass in the
 * debugged process, it "knows" that it has a member named ``m_dwRank''.  What
 * it *doesn't* know is the correct offset of the member from the beginning of
 * the class, as that could change as members are added/moved.
 *
 * In general, Strike needed PDBs for 2 things: offsets of members within a
 * class, and addresses of global (and class-static) variables.
 *
 * Both of these can be done by using table lookup instead of PDBs.
 * Additionally, this isn't considered to be an IP leak because the table is
 * just a bunch of numbers.  There's no way to correspond the actual number in
 * the table to a class-name member-name without consulting
 * ``inc/dump-types.h'', which shouldn't leave the company.
 *
 * The table itself is stored as a global variable with an unnamed export, so
 * only SOS knows what the correct entry is.
 *
 *
 * Table Layout
 * ------------
 * In the abstract, the table is a two-dimensional jagged array of ULONG_PTRs.
 * The row is a class, while the offset is a member.
 *
 * The reality is more complicated.
 * The global variable is of type ClassDumpTable, which contains an array of
 * pointers to ClassDumpInfo objects (see ``inc/dump-tables.h'').  Each
 * ClassDumpInfo object contains a class size, the number of members, and a
 * pointer to an array of members:
 *
 *    ClassDumpTable
 *      - version
 *      - nentries
 *      + classes
 *        - Class Foo
 *          - classSize
 *          - nmembers
 *          + memberOffset
 *            - member 1
 *            - member 2
 *            - ...
 *        - Class Bar
 *            - ...
 *        - ...
 *
 * Overall, it's far easier to consider it as a two-dimensional jagged array;
 * the array of pointers to classes, etc., is merely an implementation detail
 * to make it easier to use macros to construct the table.
 *
 * To look up an entry, you need two things: the class index, and the member
 * index.  Both of these are generated in ``inc/dump-type-info.h''.
 *
 * With these two items, you use the class index to read the correct
 * ClassDumpInfo member from the ClassDumpTable::classes array, and then use
 * the member index to read the correct ULONG_PTR value from the
 * ClassDumpInfo::memberOffsets array.
 *
 *
 * Table Generation
 * ----------------
 * To generate the table, we provide an implementation of the macros used in
 * ``inc/dump-types.h''.  A typical entry in the file is like:
 *
 *    BEGIN_CLASS_DUMP_INFO(ClassName)
 *      CDI_CLASS_MEMBER_OFFSET(member)
 *      CDI_CLASS_STATIC_ADDRESS(static_member)
 *      CDI_GLOBAL_ADDRESS(global)
 *    END_CLASS_DUMP_INFO(ClassName)
 *
 * This gets expanded into:
 *
 *    struct ClassName_member_offset_info
 *      {
 *      typedef ClassName _class;
 *      static ULONG_PTR members[];
 *      };
 *
 *    ULONG_PTR ClassName_member_offset_info::members[] = 
 *      {
 *      offsetof (_class, member),
 *      &_class::static_member,
 *      &global,
 *      (ULONG_PTR) -1  // for end of table
 *      };
 *
 *    ClassDumpInfo g_ClassName_member_offset_info_info = 
 *      {
 *      sizeof (ClassDumpInfo),
 *      3,
 *      & ClassName_member_offset_info::members;
 *      };
 *
 * This allows us to build a compile-time table of all offsets/addresses
 * required by strike, with the correct member indexes for a given class.
 *
 * To build the class indexes, we need another table.  This second table is
 * also present in ``inc/dump-types.h'', which is like:
 *
 *    BEGIN_CLASS_DUMP_TABLE(ExportName)
 *      CDT_CLASS_ENTRY(ClassName)
 *      // ...other classes...
 *    END_CLASS_DUMP_TABLE(ExportName)
 *
 * This gets expanded into two things: a table for the class indexes, and the
 * actual table named "ExportName".
 *
 * The class indexes are generated as:
 * 
 *    ClassDumpInfo* g_ExportName_classes[] = 
 *      {
 *      & g_ClassName_member_offset_info_info,
 *      // ... other classes...
 *      0
 *      };
 *
 * While the actual table is initialized as:
 *
 *    ClassDumpTable ExportName = 
 *      {
 *      0,  // version
 *      1,  // # entries
 *      & g_ExportName_classes    // actual classes held
 *      };
 *
 * Of course, macro "trickery" is used to determine the number of elements in
 * the array (instead of an explicit number), but this is the high-level
 * overview.
 *
 * Once this is done, ``ExportName'' is our table that can be used instead of
 * PDBs.
 *
 *
 * Warnings
 * --------
 * Alas, life can't be quite this simple.  Since we're constrained to the C
 * pre-processor, there is less flexibility in the system than is required.
 * For example, some members are (not) present based on whether or not
 * preprocessor variables are (un)set.
 *
 * This is taken to an extreme in ``gc_heap'', where some members are static
 * members on Workstation builds, and non-static members on Server builds.
 *
 * Other members are only present in debug builds.
 *
 * To allow the use of these members, their complexity had to be "pushed up"
 * into the name of the macros.  Thus, a member present only on debug builds
 * is introduced with the CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY() macro.
 *
 * There are a number of scenarios like this, and more are likely to come up
 * in the future.
 *
 * This is the principle reason that there are 17+ macros used for the tables,
 * instead of (the preferrable) 8.  (Minimum, I'd expect BEGIN/END macros for
 * each class (2), macros for member offsets/static addresses/global addresses
 * (3), BEGIN/END for the table (2), and for each class in the table (1).)
 *
 * When in doubt, run ``cl /E'' on this file to see what the preprocessor is
 * generating.  It's often the only way to determine what's wrong with a
 * specific table.
 */

#include "common.h"

#include "DbgAlloc.h"
#include "log.h"
#include "ceemain.h"
#include "clsload.hpp"
#include "object.h"
#include "hash.h"
#include "ecall.h"
#include "ceemain.h"
#include "ndirect.h"
#include "syncblk.h"
#include "COMMember.h"
#include "COMString.h"
#include "COMSystem.h"
#include "EEConfig.h"
#include "stublink.h"
#include "handletable.h"
#include "method.hpp"
#include "codeman.h"
#include "gcscan.h"
#include "frames.h"
#include "threads.h"
#include "stackwalk.h"
#include "gc.h"
#include "interoputil.h"
#include "security.h"
#include "nstruct.h"
#include "DbgInterface.h"
#include "EEDbgInterfaceImpl.h"
#include "DebugDebugger.h"
#include "CorDBPriv.h"
#include "remoting.h"
#include "COMDelegate.h"
#include "nexport.h"
#include "icecap.h"
#include "AppDomain.hpp"
#include "CorMap.hpp"
#include "PerfCounters.h"
#include "RWLock.h"
#include "IPCManagerInterface.h"
#include "tpoolwrap.h"
#include "nexport.h"
#include "COMCryptography.h"
#include "InternalDebug.h"
#include "corhost.h"
#include "binder.h"
#include "olevariant.h"

#include "compluswrapper.h"
#include "IPCFuncCall.h"
#include "PerfLog.h"
#include "..\dlls\mscorrc\resource.h"

#include "COMNlsInfo.h"

#include "util.hpp"
#include "ShimLoad.h"

#include "zapmonitor.h"
#include "ComThreadPool.h"

#include "StackProbe.h"
#include "PostError.h"

#include "Timeline.h"

#include "minidumppriv.h"

#ifdef PROFILING_SUPPORTED 
#include "ProfToEEInterfaceImpl.h"
#endif // PROFILING_SUPPORTED

#include "notifyexternals.h"
#include "corsvcpriv.h"

#include "StrongName.h"
#include "COMCodeAccessSecurityEngine.h"

#include "../fjit/IFJitCompiler.h"    // for Fjit_hdrInfo
#include "gcpriv.h"                   // for gc_heap, generation, etc.
#include "HandleTablePriv.h"          // HandleTable, etc.
#include "EJitMgr.h"                  // EconoJitManager
#include "Win32ThreadPool.h"          // ThreadpoolMgr

extern char g_Version[];              // defined in vars.cpp

extern BYTE g_SyncBlockCacheInstance[]; // defined in syncblk.cpp

#ifdef _DEBUG
extern bool g_DbgEnabled;             // defined in ..\Utilcode\DbgAlloc.cpp
#endif

// defined in ``ComThreadPool.cpp''
extern DWORD WINAPI QueueUserWorkItemCallback (PVOID DelegateInfo);

// defined in ``JITinterface.cpp''
extern "C" VMHELPDEF hlpFuncTable[];

/*
 * Some global variables are located within a 
 * BEGIN_CLASS_DUMP_INFO(Global_Variables) declaration.
 * However, there is (of course) no Global_Variables structure.  Thus, we
 * introduce one.
 */
struct Global_Variables {};

/* 
 * The definition of this structure *must* be kept up to date with the
 * definition in ObjectHandle.cpp.
 */
struct HandleTableMap
{
    HHANDLETABLE            *pTable;
    struct HandleTableMap   *pNext;
    DWORD                    dwMaxIndex;
};

/* Declared/defined in ``ObjectHandle.cpp''. */
extern HandleTableMap g_HandleTableMap;

/* 
 * The Performance tracking classes are only present when PERF_TRACKING is
 * defined.
 */
#ifndef PERF_TRACKING
  struct PerfAllocHeader {};
  struct PerfAllocVars {};
  struct PerfUtil {};
#endif   /* def _DEBUG */

#include <clear-class-dump-defs.h>
#include <dump-tables.h>


#define NMEMBERS(x) (sizeof(x)/sizeof(x[0]))

#include <member-offset-info.h>

#define BEGIN_CLASS_DUMP_INFO(klass) \
  /* The struct is used so that we can use the ``_class'' typedef,  \
   * so that CI_CLASS_MEMBER doesn't need the class specified. */ \
  struct MEMBER_OFFSET_INFO(klass) \
    { \
    typedef klass _class; \
    static ULONG_PTR members[]; \
    }; \
  ULONG_PTR MEMBER_OFFSET_INFO(klass)::members[] = \
    {
    
#define BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent) BEGIN_CLASS_DUMP_INFO(klass)
#define BEGIN_ABSTRACT_CLASS_DUMP_INFO(klass) BEGIN_CLASS_DUMP_INFO(klass)
#define BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent) BEGIN_CLASS_DUMP_INFO(klass)

/*
 * Certain members change between Server and Workstation builds.
 * This is currently only in the gc_heap class, but it affects ~4 members.
 *
 * SERVER_GC appears to be the only discernable difference between the
 * workstation and server build commands, so it's used to differentiate
 * between them.
 */
#ifdef SERVER_GC
  #define CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(member) \
    CDI_CLASS_MEMBER_OFFSET(member)

  #define CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL(member) \
    CDI_CLASS_MEMBER_OFFSET(member)
#else
  #define CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(member) \
    CDI_CLASS_STATIC_ADDRESS(member)

  #define CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL(member) \
    CDI_GLOBAL_ADDRESS(member)
#endif

/* ignore the class-injection stuff; we don't need it. */
#define CDI_CLASS_INJECT(m)

#define CDI_CLASS_MEMBER_OFFSET(m) offsetof (_class, m), 

#define CDI_CLASS_MEMBER_OFFSET_BITFIELD(member, size) \
    offsetof (_class, member ## _begin),

#ifdef _DEBUG
  #define CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(m) offsetof (_class, m),
#else
  #define CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(m) ((ULONG_PTR)-1),
#endif

#ifdef PERF_TRACKING
  #define CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(m) offsetof (_class, m),
#else
  #define CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(m) ((ULONG_PTR)-1),
#endif

#if defined (MULTIPLE_HEAPS) && !defined(ISOLATED_HEAPS)
  #define CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY(member) \
    offsetof(_class, member),
#else
  #define CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY(member) ((ULONG_PTR)-1),
#endif

/* static members are globals; we just want their address.  */
#define CDI_CLASS_STATIC_ADDRESS(member) \
    (ULONG_PTR) &_class::member, 

#ifdef PERF_TRACKING
  #define CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY(member) \
    (ULONG_PTR) &_class::member, 
#else
  #define CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY(member) ((ULONG_PTR)-1),
#endif

#if defined (MULTIPLE_HEAPS) && !defined (ISOLATED_HEAPS)
  #define CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY(member) \
    (ULONG_PTR) &_class::member, 
#else
  #define CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY(member) \
    ((ULONG_PTR)-1),
#endif

#define CDI_CLASS_STATIC_ADDRESS(member) \
    (ULONG_PTR) &_class::member, 

#define CDI_GLOBAL_ADDRESS(global) \
    (ULONG_PTR) & global,

#ifdef _DEBUG
  #define CDI_GLOBAL_ADDRESS_DEBUG_ONLY(global) \
    (ULONG_PTR) & global,
#else /* def _DEBUG */
  #define CDI_GLOBAL_ADDRESS_DEBUG_ONLY(global) \
    ((ULONG_PTR)-1),
#endif /* def _DEBUG */

#define END_CLASS_DUMP_INFO(klass) \
    ((ULONG_PTR)-1) \
    }; \
  ClassDumpInfo g_ ## klass ## _info = \
    { \
    sizeof (klass), \
    NMEMBERS(MEMBER_OFFSET_INFO(klass)::members)-1, \
    /* the "-1" is because of the ``-1'' added at end of END_CLASS_INFO(). */ \
    MEMBER_OFFSET_INFO(klass)::members \
    };

#define END_CLASS_DUMP_INFO_DERIVED(klass, parent) END_CLASS_DUMP_INFO(klass)
#define END_ABSTRACT_CLASS_DUMP_INFO(klass) END_CLASS_DUMP_INFO(klass)
#define END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent) END_CLASS_DUMP_INFO(klass)

#define BEGIN_CLASS_DUMP_TABLE(name) \
  ClassDumpInfo* g_ ## name ## _classes[] = \
    {

#define CDT_CLASS_ENTRY(klass) &g_ ## klass ## _info, 

#define END_CLASS_DUMP_TABLE(name) \
    0 \
    }; \
  extern "C" ClassDumpTable name = \
    {\
    0, /* version */ \
    NMEMBERS(g_ ## name ## _classes)-1, \
      /* the "-1" is because of the ``0'' added in END_INTERNAL_DATA (). */ \
    g_ ## name ## _classes\
    };

#include <dump-types.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ecall.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ECALL.H -
//
// Handles our private native calling interface.
//


#ifndef _ECALL_H_
#define _ECALL_H_

#include "fcall.h"
#include "mlcache.h"
#include "corinfo.h"


class StubLinker;
class ECallMethodDesc;
class ArgBasedStubCache;
class MethodDesc;

enum  StubStyle;

struct ECFunc {
	BOOL IsFCall() 						{ return m_isFCall; }
	CorInfoIntrinsics 	IntrinsicID() 	{ return CorInfoIntrinsics(m_intrinsicID); }

    LPCUTF8            m_wszMethodName;
    LPHARDCODEDMETASIG m_wszMethodSig;
    LPVOID             m_pImplementation;
    MethodDesc*        m_pMD;				// for reverse mapping

    unsigned 		   m_intrinsicID : 8;		
    unsigned 		   m_isFCall     : 1;	// Can shrink if needed

	ECFunc*			   m_pNext;				// linked list for hash table
};


struct ECClass
{
    LPCUTF8      m_wszClassName;
    LPCUTF8      m_wszNameSpace;
    ECFunc      *m_pECFunc;
};


class ArrayStubCache : public MLStubCache
{
    virtual MLStubCompilationMode CompileMLStub(const BYTE *pRawMLStub,
                                                StubLinker *psl,
                                                void *callerContext);
    virtual UINT Length(const BYTE *pRawMLStub);
};


//=======================================================================
// Collects code and data pertaining to the ECall interface.
//=======================================================================
class ECall
{
    public:
        //---------------------------------------------------------
        // One-time init
        //---------------------------------------------------------
        static BOOL Init();

        //---------------------------------------------------------
        // One-time cleanup
        //---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
        static VOID Terminate();
#endif /* SHOULD_WE_CLEANUP */

        //---------------------------------------------------------
        // Either creates or retrieves from the cache, a stub to
        // invoke ECall methods. Each call refcounts the returned stub.
        // This routines throws a COM+ exception rather than returning
        // NULL.
        //---------------------------------------------------------
        static Stub* ECall::GetECallMethodStub(StubLinker *psl, ECallMethodDesc *pMD);

        //---------------------------------------------------------
        // Call at strategic times to discard unused stubs.
        //---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
        static VOID  FreeUnusedStubs();
#endif /* SHOULD_WE_CLEANUP */


        //---------------------------------------------------------
        // Stub cache for ECall Method stubs
        //---------------------------------------------------------
        static ArgBasedStubCache *m_pECallStubCache;  


		static CorInfoIntrinsics IntrinsicID(MethodDesc*);

        //---------------------------------------------------------
        // Cache for array stubs
        //---------------------------------------------------------
        static ArrayStubCache *m_pArrayStubCache;


    private:
		friend MethodDesc* MapTargetBackToMethod(const void* pTarg);
        static ECFunc* FindTarget(const void* pTarg);
        static VOID  ECall::EmitECallMethodStub(StubLinker *psl, ECallMethodDesc *pMD, StubStyle style);
        ECall() {};     // prevent "new"'s on this class

};

#endif _ECALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dispparammarshaler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Definition of dispatch parameter marshalers.
**  
**      //  %%Created by: dmortens
===========================================================*/

#ifndef _DISPPARAMMARSHALER_H
#define _DISPPARAMMARSHALER_H

#include "vars.hpp"
#include "mlinfo.h"

class DispParamMarshaler
{
public:
    DispParamMarshaler() {}
    virtual ~DispParamMarshaler() {}

    virtual void MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj);
    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);
    virtual void MarshalManagedToNativeRef(OBJECTREF *pSrcObj, VARIANT *pRefVar);
    virtual void CleanUpManaged(OBJECTREF *pObj);
};

class DispParamCurrencyMarshaler : public DispParamMarshaler
{
public:
    DispParamCurrencyMarshaler() {}
    virtual ~DispParamCurrencyMarshaler() {}

    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);
};

class DispParamOleColorMarshaler : public DispParamMarshaler
{
public:
    DispParamOleColorMarshaler() {}
    virtual ~DispParamOleColorMarshaler() {}

    virtual void MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj);
    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);
};

class DispParamErrorMarshaler : public DispParamMarshaler
{
public:
    DispParamErrorMarshaler() {}
    virtual ~DispParamErrorMarshaler() {}

    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);
};

class DispParamInterfaceMarshaler : public DispParamMarshaler
{
public:
    DispParamInterfaceMarshaler(BOOL bDispatch, MethodTable* pIntfMT, MethodTable *pClassMT, BOOL bClassIsHint) 
    : m_bDispatch(bDispatch)
    , m_pIntfMT(pIntfMT)
    , m_pClassMT(pClassMT)
    , m_bClassIsHint(bClassIsHint)
    {
    }

    virtual ~DispParamInterfaceMarshaler() {}

    virtual void MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj);
    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);

private:

    // if return type is an interface, then the method table
    // of the interface is cached here.
    // we need to cache this and use it when we call GetCOMIPFromObjectRef    
    MethodTable* m_pIntfMT;
    MethodTable* m_pClassMT;
    BOOL m_bDispatch;
    BOOL m_bClassIsHint;
};

class DispParamArrayMarshaler : public DispParamMarshaler
{
public:
    DispParamArrayMarshaler(VARTYPE ElementVT, MethodTable *pElementMT) 
    : m_ElementVT(ElementVT)
    , m_pElementMT(pElementMT)
    {
    }

    virtual ~DispParamArrayMarshaler() {}

    virtual void MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj);
    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);
    virtual void MarshalManagedToNativeRef(OBJECTREF *pSrcObj, VARIANT *pDestVar);

private:
    VARTYPE m_ElementVT;
    MethodTable *m_pElementMT;
};

class DispParamRecordMarshaler : public DispParamMarshaler
{
public:
    DispParamRecordMarshaler(MethodTable *pRecordMT) 
    : m_pRecordMT(pRecordMT)
    {
    }

    virtual ~DispParamRecordMarshaler() {}

    virtual void MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj);
    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);

private:
    MethodTable *m_pRecordMT;
};

class DispParamCustomMarshaler : public DispParamMarshaler
{
public:
    DispParamCustomMarshaler(CustomMarshalerHelper *pCMHelper, VARTYPE vt) 
    : m_pCMHelper(pCMHelper)
    , m_vt(vt)
    {
    }

    virtual ~DispParamCustomMarshaler() {}

    virtual void MarshalNativeToManaged(VARIANT *pSrcVar, OBJECTREF *pDestObj);
    virtual void MarshalManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);
    virtual void MarshalManagedToNativeRef(OBJECTREF *pSrcObj, VARIANT *pRefVar);
    virtual void CleanUpManaged(OBJECTREF *pObj);

private:
    CustomMarshalerHelper *m_pCMHelper;
    VARTYPE m_vt;
};

#endif _DISPPARAMMARSHALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dispatchinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Definition of helpers used to expose IDispatch 
**          and IDispatchEx to COM.
**  
**      //  %%Created by: dmortens
===========================================================*/

#ifndef _DISPATCHINFO_H
#define _DISPATCHINFO_H

#include "vars.hpp"
#include "mlinfo.h"

// Forward declarations.
struct ComMethodTable;
struct SimpleComCallWrapper;
class ComMTMemberInfoMap;
struct ComMTMethodProps;
class DispParamMarshaler;
class ReflectMethod;
class ReflectField;
class MarshalInfo;
class DispatchInfo;

// An enumeration of the types of managed MemberInfo's. This must stay in synch with
// the ones defined in MemberInfo.cool.
enum EnumMemberTypes
{
    Uninitted                           = 0x00,
	Constructor							= 0x01,
	Event								= 0x02,
	Field								= 0x04,
	Method								= 0x08,
	Property							= 0x10
};

enum {NUM_MEMBER_TYPES = 5};

enum CultureAwareStates
{
    Aware,
    NonAware,
    Unknown
};

// This structure represents a dispatch member.
struct DispatchMemberInfo
{
    DispatchMemberInfo(DispatchInfo *pDispInfo, DISPID DispID, LPWSTR strName, REFLECTBASEREF MemberInfoObj);
    ~DispatchMemberInfo();

    // Helper method to ensure the entry is initialized.
    void EnsureInitialized();

    // This method retrieves the ID's of the specified names.
    HRESULT GetIDsOfParameters(WCHAR **astrNames, int NumNames, DISPID *aDispIds, BOOL bCaseSensitive);

	// Accessors.
	PTRARRAYREF GetParameters();

    BOOL IsParamInOnly(int iIndex)
    {        
        return m_pParamInOnly[iIndex];
    }


    // Inline accessors.
    BOOL IsCultureAware()
    {
        _ASSERTE(m_CultureAwareState != Unknown);
        return m_CultureAwareState == Aware;
    }

    EnumMemberTypes GetMemberType() 
    {
        _ASSERTE(m_enumType != Uninitted);
        return m_enumType;
    }

    int GetNumParameters() 
    {
        _ASSERTE(m_iNumParams != -1);
        return m_iNumParams;
    }

    BOOL RequiresManagedObjCleanup() 
    {
        return m_bRequiresManagedCleanup;
    }

    // Parameter marshaling methods.
	void MarshalParamNativeToManaged(int iParam, VARIANT *pSrcVar, OBJECTREF *pDestObj);
	void MarshalParamManagedToNativeRef(int iParam, OBJECTREF *pSrcObj, VARIANT *pRefVar);
    void CleanUpParamManaged(int iParam, OBJECTREF *pObj);
	void MarshalReturnValueManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar);

    // Static helper methods.
    static ComMTMethodProps *GetMemberProps(REFLECTBASEREF MemberInfoObj, ComMTMemberInfoMap *pMemberMap);
    static DISPID GetMemberDispId(REFLECTBASEREF MemberInfoObj, ComMTMemberInfoMap *pMemberMap);
    static LPWSTR GetMemberName(REFLECTBASEREF MemberInfoObj, ComMTMemberInfoMap *pMemberMap);

    DISPID                  m_DispID;
    OBJECTHANDLE            m_hndMemberInfo;
    DispParamMarshaler**    m_apParamMarshaler;
    DispatchMemberInfo*     m_pNext;
    BOOL*                   m_pParamInOnly;
    LPWSTR                  m_strName;
    EnumMemberTypes         m_enumType;
    int                     m_iNumParams;
    CultureAwareStates      m_CultureAwareState;
    BOOL                    m_bRequiresManagedCleanup;
    BOOL                    m_bInitialized;
    DispatchInfo*           m_pDispInfo;

private:
    // Private helpers.
    void Init();
    void DetermineMemberType();
    void DetermineParamCount();
    void DetermineCultureAwareness();
    void SetUpParamMarshalerInfo();
    void SetUpMethodMarshalerInfo(ReflectMethod *pReflectMeth, BOOL bReturnValueOnly);
    void SetUpFieldMarshalerInfo(ReflectField *pReflectField);
    void SetUpDispParamMarshalerForMarshalInfo(int iParam, MarshalInfo *pInfo);
    void SetUpDispParamAttributes(int iParam, MarshalInfo* Info);

    static EEClass  *       s_pMemberTypes[NUM_MEMBER_TYPES];
    static EnumMemberTypes  s_memberTypes[NUM_MEMBER_TYPES];
    static int              s_iNumMemberTypesKnown;
};

// This is the list of expando methods for which we cache the MD's.
enum EnumIReflectMethods
{
    IReflectMethods_GetProperties = 0,
    IReflectMethods_GetFields,
    IReflectMethods_GetMethods,
    IReflectMethods_InvokeMember,
    IReflectMethods_LastMember
};

// This is the list of expando methods for which we cache the MD's.
enum EnumIExpandoMethods
{
    IExpandoMethods_AddField = 0,
    IExpandoMethods_RemoveMember,
    IExpandoMethods_LastMember
};

// This is the list of type methods for which we cache the MD's.
enum EnumTypeMethods
{
    TypeMethods_GetProperties = 0,
    TypeMethods_GetFields,
    TypeMethods_GetMethods,
    TypeMethods_InvokeMember,
    TypeMethods_LastMember
};

// This is the list of FieldInfo methods for which we cache the MD's.
enum EnumFieldInfoMethods
{
    FieldInfoMethods_SetValue = 0,
    FieldInfoMethods_GetValue,
    FieldInfoMethods_LastMember
};

// This is the list of PropertyInfo methods for which we cache the MD's.
enum EnumPropertyInfoMethods
{
    PropertyInfoMethods_SetValue = 0,
    PropertyInfoMethods_GetValue,
    PropertyInfoMethods_GetIndexParameters,
    PropertyInfoMethods_LastMember
};

// This is the list of MethodInfo methods for which we cache the MD's.
enum EnumMethodInfoMethods
{
    MethodInfoMethods_Invoke = 0,
    MethodInfoMethods_GetParameters,
    MethodInfoMethods_LastMember
};

// This is the list of ICustomAttributeProvider methods which we use.
enum EnumCustomAttrProviderMethods
{
    CustomAttrProviderMethods_GetCustomAttributes = 0,
    CustomAttrProviderMethods_LastMember
};

class DispatchInfo
{
public:
    // Constructor and destructor.
    DispatchInfo(ComMethodTable *pComMTOwner);
    virtual ~DispatchInfo();

    // Methods to lookup members.
    DispatchMemberInfo*     FindMember(DISPID DispID);
    DispatchMemberInfo*     FindMember(BSTR strName, BOOL bCaseSensitive);

    // Helper method that invokes the member with the specified DISPID.
    HRESULT                 InvokeMember(SimpleComCallWrapper *pSimpleWrap, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pVarRes, EXCEPINFO *pei, IServiceProvider *pspCaller, unsigned int *puArgErr);

    // Methods to retrieve the cached MD's
    static MethodDesc*      GetTypeMD(EnumTypeMethods Method);
    static MethodDesc*      GetFieldInfoMD(EnumFieldInfoMethods Method, TypeHandle hndFieldInfoType);
    static MethodDesc*      GetPropertyInfoMD(EnumPropertyInfoMethods Method, TypeHandle hndPropInfoType);
    static MethodDesc*      GetMethodInfoMD(EnumMethodInfoMethods Method, TypeHandle hndMethodInfoType);
    static MethodDesc*      GetCustomAttrProviderMD(EnumCustomAttrProviderMethods Method, TypeHandle hndCustomAttrProvider);

    // This method synchronizes the DispatchInfo's members with the ones in managed world.
    // The return value will be set to TRUE if the object was out of synch and members where
    // added and it will be set to FALSE otherwise.
    BOOL                    SynchWithManagedView();

    // Method to enter and leave the interop lock that protects the DispatchInfo.
    void                    EnterLock();
    void                    LeaveLock();

    // This method retrieves the OleAutBinder type.
    static OBJECTREF        GetOleAutBinder();

    // Helper function to retrieve the Missing.Value object.
    static OBJECTREF        GetMissingObject();

    // Returns TRUE if the argument is "Missing"
    static BOOL             VariantIsMissing(VARIANT *pOle);

protected:
    // Parameter marshaling helpers.
	void                    MarshalParamNativeToManaged(DispatchMemberInfo *pMemberInfo, int iParam, VARIANT *pSrcVar, OBJECTREF *pDestObj);
	void                    MarshalParamManagedToNativeRef(DispatchMemberInfo *pMemberInfo, int iParam, OBJECTREF *pSrcObj, OBJECTREF *pBackupStaticArray, VARIANT *pRefVar);
	void                    MarshalReturnValueManagedToNative(DispatchMemberInfo *pMemberInfo, OBJECTREF *pSrcObj, VARIANT *pDestVar);

	// DISPID to named argument convertion helper.
	void					SetUpNamedParamArray(DispatchMemberInfo *pMemberInfo, DISPID *pSrcArgNames, int NumNamedArgs, PTRARRAYREF *pNamedParamArray);

    // Helper method to retrieve the source VARIANT from the VARIANT contained in the disp params.
    VARIANT*                RetrieveSrcVariant(VARIANT *pDispParamsVariant);

    // Helper methods called from SynchWithManagedView() to retrieve the lists of members.
    virtual PTRARRAYREF     RetrievePropList();
    virtual PTRARRAYREF     RetrieveFieldList();
    virtual PTRARRAYREF     RetrieveMethList();

    // Virtual method to retrieve the InvokeMember method desc.
    virtual MethodDesc*     GetInvokeMemberMD();

    // Virtual method to retrieve the reflection object associated with the DispatchInfo.
    virtual OBJECTREF       GetReflectionObject();

    // Virtual method to retrieve the member info map.
    virtual ComMTMemberInfoMap* GetMemberInfoMap();

    // This method generates a DISPID for a new member.
    DISPID                  GenerateDispID();

    // Helper method to create an instance of a DispatchMemberInfo.
    DispatchMemberInfo*     CreateDispatchMemberInfoInstance(DISPID DispID, LPWSTR strMemberName, REFLECTBASEREF MemberInfoObj);

    // Helper function to fill in an EXCEPINFO for an InvocationException.
    static void             GetExcepInfoForInvocationExcep(OBJECTREF objException, EXCEPINFO *pei);

    // This helper method converts the IDispatch::Invoke flags to BindingFlags.
    static int              ConvertInvokeFlagsToBindingFlags(int InvokeFlags);

    // Helper function to determine if a VARIANT is a byref static safe array.
    static BOOL             IsVariantByrefStaticArray(VARIANT *pOle);

    ComMethodTable*         m_pComMTOwner;
    PtrHashMap              m_DispIDToMemberInfoMap;
    DispatchMemberInfo*     m_pFirstMemberInfo;
    Crst                    m_lock;
    int                     m_CurrentDispID;
    BOOL                    m_bAllowMembersNotInComMTMemberMap;
    BOOL                    m_bInvokeUsingInvokeMember;

    static MethodDesc*      m_apTypeMD[TypeMethods_LastMember];
    static MethodDesc*      m_apFieldInfoMD[FieldInfoMethods_LastMember];
    static MethodDesc*      m_apPropertyInfoMD[PropertyInfoMethods_LastMember];
    static MethodDesc*      m_apMethodInfoMD[MethodInfoMethods_LastMember];
    static MethodDesc*      m_apCustomAttrProviderMD[CustomAttrProviderMethods_LastMember];

    static OBJECTHANDLE     m_hndOleAutBinder;
    static OBJECTHANDLE     m_hndMissing;
};

class DispatchExInfo : public DispatchInfo
{
public:
    // Constructor and destructor.
    DispatchExInfo(SimpleComCallWrapper *pSimpleWrapper, ComMethodTable *pIClassXComMT, BOOL bSupportsExpando);
    virtual ~DispatchExInfo();

    // Returns true if this DispatchExInfo supports expando operations.
    BOOL                    SupportsExpando();

    // Methods to lookup members. These methods synch with the managed view if they fail to
    // find the method.
    DispatchMemberInfo*     SynchFindMember(DISPID DispID);
    DispatchMemberInfo*     SynchFindMember(BSTR strName, BOOL bCaseSensitive);

    // Helper method that invokes the member with the specified DISPID. These methods synch 
    // with the managed view if they fail to find the method.
    HRESULT                 SynchInvokeMember(SimpleComCallWrapper *pSimpleWrap, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pVarRes, EXCEPINFO *pei, IServiceProvider *pspCaller, unsigned int *puArgErr);

    // These methods return the first and next non deleted members.
    DispatchMemberInfo*     GetFirstMember();
    DispatchMemberInfo*     GetNextMember(DISPID CurrMemberDispID);

    // Methods to add and delete members.
    DispatchMemberInfo*     AddMember(BSTR strName, BOOL bCaseSensitive);
    void                    DeleteMember(DISPID DispID);

    // Methods to retrieve the cached MD's   
    MethodDesc*             GetIReflectMD(EnumIReflectMethods Method);
    MethodDesc*             GetIExpandoMD(EnumIExpandoMethods Method);

private:
    // Helper methods called from SynchWithManagedView() to retrieve the lists of members.
    virtual PTRARRAYREF     RetrievePropList();
    virtual PTRARRAYREF     RetrieveFieldList();
    virtual PTRARRAYREF     RetrieveMethList();

    // Virtual method to retrieve the InvokeMember method desc.
    virtual MethodDesc*     GetInvokeMemberMD();

    // Virtual method to retrieve the reflection object associated with the DispatchInfo.
    virtual OBJECTREF       GetReflectionObject();

    // Virtual method to retrieve the member info map.
    virtual ComMTMemberInfoMap* GetMemberInfoMap();

    static MethodDesc*      m_apIExpandoMD[IExpandoMethods_LastMember];
    static MethodDesc*      m_apIReflectMD[IReflectMethods_LastMember];   

    SimpleComCallWrapper*   m_pSimpleWrapperOwner;
    BOOL                    m_bSupportsExpando;
};

#endif _DISPATCHINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\dispatchinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Implementation of helpers used to expose IDispatch 
**          and IDispatchEx to COM.
**  
**      //  %%Created by: dmortens
===========================================================*/

#include "common.h"

#include "DispatchInfo.h"
#include "dispex.h"
#include "object.h"
#include "field.h"
#include "method.hpp"
#include "class.h"
#include "ComCallWrapper.h"
#include "orefcache.h"
#include "threads.h"
#include "excep.h"
#include "objecthandle.h"
#include "comutilnative.h"
#include "eeconfig.h"
#include "interoputil.h"
#include "reflectutil.h"
#include "OleVariant.h"
#include "COMMember.h"
#include "ComMTMemberInfoMap.h" 
#include "DispParamMarshaler.h"
#include "Security.h"
#include "COMCodeAccessSecurityEngine.h"

#define EXCEPTION_INNER_PROP                            "InnerException"

// The name of the properties accessed on the managed member infos.
#define MEMBER_INFO_NAME_PROP                           "Name"
#define METHOD_INFO_GETPARAMETERS_METH                  "GetParameters"
#define PROPERTY_INFO_GETINDEXPARAMETERS_METH           "GetIndexParameters"

// The initial size of the DISPID to member map.
#define DISPID_TO_MEMBER_MAP_INITIAL_PRIME_INDEX        4

MethodDesc*   DispatchInfo::m_apTypeMD[] = {NULL};
MethodDesc*   DispatchInfo::m_apFieldInfoMD[] = {NULL, NULL};
MethodDesc*   DispatchInfo::m_apPropertyInfoMD[] = {NULL, NULL};
MethodDesc*   DispatchInfo::m_apMethodInfoMD[] = {NULL};
MethodDesc*   DispatchInfo::m_apCustomAttrProviderMD[] = {NULL};
MethodDesc*   DispatchExInfo::m_apIReflectMD[] = {NULL, NULL, NULL, NULL};
MethodDesc*   DispatchExInfo::m_apIExpandoMD[] = {NULL, NULL};
OBJECTHANDLE  DispatchInfo::m_hndOleAutBinder = NULL;
OBJECTHANDLE  DispatchInfo::m_hndMissing = NULL;

EEClass*      DispatchMemberInfo::s_pMemberTypes[NUM_MEMBER_TYPES] = {NULL};
EnumMemberTypes      DispatchMemberInfo::s_memberTypes[NUM_MEMBER_TYPES] = {Uninitted};
int           DispatchMemberInfo::s_iNumMemberTypesKnown = 0;


// The names of the properties that are accessed on the managed member info's
#define MEMBERINFO_TYPE_PROP            "MemberType"

// The names of the properties that are accessed on managed DispIdAttributes.
#define DISPIDATTRIBUTE_VALUE_PROP      "Value"

// The name of the value field on the missing class.
#define MISSING_VALUE_FIELD             "Value"

// The names of the properties that are accessed on managed ParameterInfo.
#define PARAMETERINFO_NAME_PROP         "Name"

// Helper function to convert between a DISPID and a hashkey.
inline UPTR DispID2HashKey(DISPID DispID)
{
    return DispID + 2;
}

// Typedef for string comparition functions.
typedef int (__cdecl *UnicodeStringCompareFuncPtr)(const wchar_t *, const wchar_t *);

//--------------------------------------------------------------------------------
// The DispatchMemberInfo class implementation.

DispatchMemberInfo::DispatchMemberInfo(DispatchInfo *pDispInfo, DISPID DispID, LPWSTR strName, REFLECTBASEREF MemberInfoObj)
: m_DispID(DispID)
, m_hndMemberInfo(((OBJECTREF)MemberInfoObj)->GetClass()->GetDomain()->CreateShortWeakHandle((OBJECTREF)MemberInfoObj))
, m_apParamMarshaler(NULL)
, m_pParamInOnly(NULL)
, m_strName(strName)
, m_pNext(NULL)
, m_enumType (Uninitted)
, m_iNumParams(-1)
, m_CultureAwareState(Unknown)
, m_bRequiresManagedCleanup(FALSE)
, m_bInitialized(FALSE)
, m_pDispInfo(pDispInfo)
{
}

DispatchMemberInfo::~DispatchMemberInfo()
{
    // Delete the parameter marshalers and then delete the array of parameter 
    // marshalers itself.
    if (m_apParamMarshaler)
    {
        EnumMemberTypes MemberType = GetMemberType();
        int NumParamMarshalers = GetNumParameters() + ((MemberType == Property) ? 2 : 1);
        for (int i = 0; i < NumParamMarshalers; i++)
        {
            if (m_apParamMarshaler[i])
                delete m_apParamMarshaler[i];
        }
        delete []m_apParamMarshaler;
    }

    if (m_pParamInOnly)
        delete [] m_pParamInOnly;

    // Destroy the member info object.
    DestroyShortWeakHandle(m_hndMemberInfo);

    // Delete the name of the member.
    delete []m_strName;
}

void DispatchMemberInfo::EnsureInitialized()
{
    // Initialize the entry if it hasn't been initialized yet. This must be synchronized.
    if (!m_bInitialized)
    {
        m_pDispInfo->EnterLock();
        if (!m_bInitialized)
        {
            Init();       
        }
        m_pDispInfo->LeaveLock();
    }
}

void DispatchMemberInfo::Init()
{
    // Determine the type of the member.
    DetermineMemberType();

    // Determine the parameter count.
    DetermineParamCount();

    // Determine the culture awareness of the member.
    DetermineCultureAwareness();

    // Set up the parameter marshaler info.
    SetUpParamMarshalerInfo();

    // Mark the dispatch member info as having been initialized.
    m_bInitialized = TRUE;
}

HRESULT DispatchMemberInfo::GetIDsOfParameters(WCHAR **astrNames, int NumNames, DISPID *aDispIds, BOOL bCaseSensitive)
{
    THROWSCOMPLUSEXCEPTION();

    int NumNamesMapped = 0;
    PTRARRAYREF ParamArray = NULL;
    int cNames = 0;

    // The member info must have been initialized before this is called.
    _ASSERTE(m_bInitialized);

    // Validate the arguments.
    _ASSERTE(astrNames && aDispIds);

    // Make sure we are in cooperative GC mode.
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Initialize all the ID's to DISPID_UNKNOWN.
    for (cNames = 0; cNames < NumNames; cNames++)
        aDispIds[cNames] = DISPID_UNKNOWN;

    // Retrieve the appropriate string comparation function.
    UnicodeStringCompareFuncPtr StrCompFunc = bCaseSensitive ? wcscmp : _wcsicmp;

    GCPROTECT_BEGIN(ParamArray)
    {
		// Retrieve the member parameters.
        ParamArray = GetParameters();

        // If we managed to retrieve an non empty array of parameters then go through it and
        // map the specified names to ID's.
        if ((ParamArray != NULL) && (ParamArray->GetNumComponents() > 0))
        {
            int NumParams = ParamArray->GetNumComponents();
            int cParams = 0;
            WCHAR **astrParamNames = (WCHAR **)_alloca(sizeof(WCHAR *) * NumParams);
            memset(astrParamNames, 0, sizeof(WCHAR *) * NumParams);

            EE_TRY_FOR_FINALLY
            {
                // Go through and retrieve the names of all the components.
                for (cParams = 0; cParams < NumParams; cParams++)
                {
                    OBJECTREF ParamInfoObj = ParamArray->GetAt(cParams);
                    GCPROTECT_BEGIN(ParamInfoObj)
                    {
                        // Retrieve the MD to use to retrieve the name of the parameter.
                        MethodDesc *pGetParamNameMD = ParamInfoObj->GetClass()->FindPropertyMethod(PARAMETERINFO_NAME_PROP, PropertyGet);
                        _ASSERTE(pGetParamNameMD && "Unable to find getter method for property ParameterInfo::Name");

                        // Retrieve the name of the parameter.
                        INT64 GetNameArgs[] = { 
                            ObjToInt64(ParamInfoObj)
                        };
                        STRINGREF MemberNameObj = (STRINGREF)Int64ToObj(pGetParamNameMD->Call(GetNameArgs));

                        // If we got a valid name back then store that in the array of names.
                        if (MemberNameObj != NULL)
                        {
                            astrParamNames[cParams] = new WCHAR[MemberNameObj->GetStringLength() + 1];
                            if (!astrParamNames[cParams])
                                COMPlusThrowOM();
                            wcscpy(astrParamNames[cParams], MemberNameObj->GetBuffer());
                        }
                    }               
                    GCPROTECT_END();        
                }

                // Now go through the list of specfiied names and map then to ID's.
                for (cNames = 0; cNames < NumNames; cNames++)
                {
                    for (cParams = 0; cParams < NumParams; cParams++)
                    {
                        if (astrParamNames[cParams] && (StrCompFunc(astrNames[cNames], astrParamNames[cParams]) == 0))
                        {
                            aDispIds[cNames] = cParams;
                            NumNamesMapped++;
                            break;
                        }
                    }
                }
            }
            EE_FINALLY
            {
                // Free all the strings we allocated.
                for (cParams = 0; cParams < NumParams; cParams++)
                {
                    if (astrParamNames[cParams])
                        delete astrParamNames[cParams];
                }
            }
            EE_END_FINALLY  
        }
    }
    GCPROTECT_END();

    return (NumNamesMapped == NumNames) ? S_OK : DISP_E_UNKNOWNNAME;
}

PTRARRAYREF DispatchMemberInfo::GetParameters()
{
    PTRARRAYREF ParamArray = NULL;
    MethodDesc *pGetParamsMD = NULL;

    // Retrieve the method to use to retrieve the array of parameters.
    switch (GetMemberType())
    {
        case Method:
        {
            pGetParamsMD = DispatchInfo::GetMethodInfoMD(
                MethodInfoMethods_GetParameters, ObjectFromHandle(m_hndMemberInfo)->GetTypeHandle());
            _ASSERTE(pGetParamsMD && "Unable to find method MemberBase::GetParameters");
            break;
        }

        case Property:
        {
            pGetParamsMD = DispatchInfo::GetPropertyInfoMD(
                PropertyInfoMethods_GetIndexParameters, ObjectFromHandle(m_hndMemberInfo)->GetTypeHandle());
            _ASSERTE(pGetParamsMD && "Unable to find method PropertyInfo::GetIndexParameters");
            break;
        }
    }

    // If the member has parameters then retrieve the array of parameters.
    if (pGetParamsMD != NULL)
    {
        INT64 GetParamsArgs[] = { 
            ObjToInt64(ObjectFromHandle(m_hndMemberInfo))
        };
        ParamArray = (PTRARRAYREF)Int64ToObj(pGetParamsMD->Call(GetParamsArgs));
    }

    return ParamArray;
}

void DispatchMemberInfo::MarshalParamNativeToManaged(int iParam, VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    // The member info must have been initialized before this is called.
    _ASSERT(m_bInitialized);

    if (m_apParamMarshaler && m_apParamMarshaler[iParam + 1])
        m_apParamMarshaler[iParam + 1]->MarshalNativeToManaged(pSrcVar, pDestObj);
    else
        OleVariant::MarshalObjectForOleVariant(pSrcVar, pDestObj);
}

void DispatchMemberInfo::MarshalParamManagedToNativeRef(int iParam, OBJECTREF *pSrcObj, VARIANT *pRefVar)
{
    // The member info must have been initialized before this is called.
    _ASSERT(m_bInitialized);

    if (m_apParamMarshaler && m_apParamMarshaler[iParam + 1])
        m_apParamMarshaler[iParam + 1]->MarshalManagedToNativeRef(pSrcObj, pRefVar);
    else
        OleVariant::MarshalOleRefVariantForObject(pSrcObj, pRefVar);
}

void DispatchMemberInfo::CleanUpParamManaged(int iParam, OBJECTREF *pObj)
{
    // The member info must have been initialized before this is called.
    _ASSERT(m_bInitialized);

    if (m_apParamMarshaler && m_apParamMarshaler[iParam + 1])
        m_apParamMarshaler[iParam + 1]->CleanUpManaged(pObj);
}

void DispatchMemberInfo::MarshalReturnValueManagedToNative(OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    // The member info must have been initialized before this is called.
    _ASSERT(m_bInitialized);

    if (m_apParamMarshaler && m_apParamMarshaler[0])
        m_apParamMarshaler[0]->MarshalManagedToNative(pSrcObj, pDestVar);
    else
        OleVariant::MarshalOleVariantForObject(pSrcObj, pDestVar);
}

ComMTMethodProps * DispatchMemberInfo::GetMemberProps(REFLECTBASEREF MemberInfoObj, ComMTMemberInfoMap *pMemberMap)
{
    DISPID DispId = DISPID_UNKNOWN;
    ComMTMethodProps *pMemberProps = NULL;

    // Validate the arguments.
    _ASSERTE(MemberInfoObj != NULL);

	// If we don't have a member map then we cannot retrieve properties for the member.
	if (!pMemberMap)
		return NULL;

    // Make sure we are in cooperative GC mode.
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Get the member's properties.
    GCPROTECT_BEGIN(MemberInfoObj);
    {
        MethodTable *pMemberInfoClass = MemberInfoObj->GetMethodTable();
        if (pMemberInfoClass == g_pRefUtil->GetClass(RC_Method))
        {
            ReflectMethod* pRM = (ReflectMethod*) MemberInfoObj->GetData();
            MethodDesc* pMeth = pRM->pMethod;           
            pMemberProps = pMemberMap->GetMethodProps(pMeth->GetMemberDef(), pMeth->GetModule());
        }
        else if (pMemberInfoClass == g_pRefUtil->GetClass(RC_Field))
        {
            ReflectField* pRF = (ReflectField*) MemberInfoObj->GetData();
            FieldDesc* pFld = pRF->pField;
            pMemberProps = pMemberMap->GetMethodProps(pFld->GetMemberDef(), pFld->GetModule());
        }
        else if (pMemberInfoClass == g_pRefUtil->GetClass(RC_Prop))
        {
            ReflectProperty* pProp = (ReflectProperty*) MemberInfoObj->GetData();
            pMemberProps = pMemberMap->GetMethodProps(pProp->propTok, pProp->pModule);
        }
    }
    GCPROTECT_END();

	return pMemberProps;
}

DISPID DispatchMemberInfo::GetMemberDispId(REFLECTBASEREF MemberInfoObj, ComMTMemberInfoMap *pMemberMap)
{
    DISPID DispId = DISPID_UNKNOWN;

    // Get the member's properties.
	ComMTMethodProps *pMemberProps = GetMemberProps(MemberInfoObj, pMemberMap);

    // If we managed to get the properties of the member then extract the DISPID.
    if (pMemberProps)
        DispId = pMemberProps->dispid;

    return DispId;
}

LPWSTR DispatchMemberInfo::GetMemberName(REFLECTBASEREF MemberInfoObj, ComMTMemberInfoMap *pMemberMap)
{
    THROWSCOMPLUSEXCEPTION();

    LPWSTR strMemberName = NULL;
    ComMTMethodProps *pMemberProps = NULL;

    // Validate the arguments.
    _ASSERTE(MemberInfoObj != NULL);

    // Make sure we are in cooperative GC mode.
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    GCPROTECT_BEGIN(MemberInfoObj);
    {
        // Get the member's properties.
		pMemberProps = GetMemberProps(MemberInfoObj, pMemberMap);

        // If we managed to get the member's properties then extract the name.
        if (pMemberProps)
        {
            int MemberNameLen = (INT)wcslen(pMemberProps->pName);
            strMemberName = new (throws) WCHAR[MemberNameLen + 1];

            memcpy(strMemberName, pMemberProps->pName, (MemberNameLen + 1) * sizeof(WCHAR));
        }
        else
        {
            // Retrieve the Get method for the Name property.
            MethodDesc *pMD = MemberInfoObj->GetClass()->FindPropertyMethod(MEMBER_INFO_NAME_PROP, PropertyGet);
            _ASSERTE(pMD && "Unable to find getter method for property MemberInfo::Name");

            // Prepare the arguments.
            INT64 Args[] = { 
                ObjToInt64(MemberInfoObj)
            };

            // Retrieve the value of the Name property.
            STRINGREF strObj = (STRINGREF)Int64ToObj(pMD->Call(Args));
            _ASSERTE(strObj != NULL);

            // Copy the name into the buffer we will return.
            int MemberNameLen = strObj->GetStringLength();
            strMemberName = new WCHAR[strObj->GetStringLength() + 1];
            memcpy(strMemberName, strObj->GetBuffer(), MemberNameLen * sizeof(WCHAR));
            strMemberName[MemberNameLen] = 0;
        }
    }
    GCPROTECT_END();

    return strMemberName;
}

void DispatchMemberInfo::DetermineMemberType()
{
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // This should not be called more than once.
    _ASSERTE(m_enumType == Uninitted);

    static BOOL bMemberTypeLoaded = FALSE;
    REFLECTBASEREF MemberInfoObj = (REFLECTBASEREF)ObjectFromHandle(m_hndMemberInfo);

    // Check to see if the member info is of a type we have already seen.
    EEClass *pMemberInfoClass   = MemberInfoObj->GetClass();
    for (int i = 0 ; i < s_iNumMemberTypesKnown ; i++)
    {
        if (pMemberInfoClass == s_pMemberTypes[i])
        {
            m_enumType = s_memberTypes[i];
            return;
        }
    }

    GCPROTECT_BEGIN(MemberInfoObj);
    {
        // Retrieve the method descriptor for the type property accessor.
        MethodDesc *pMD = MemberInfoObj->GetClass()->FindPropertyMethod(MEMBERINFO_TYPE_PROP, PropertyGet);
        _ASSERTE(pMD && "Unable to find getter method for property MemberInfo::Type");

        if (!bMemberTypeLoaded)
        {
            // We need to load the type handle for the return of pMD.
            // Otherwise loading of the handle in MethodDesc::CallDescr triggers GC
            // and trashes what is in Args.
            MetaSig msig(pMD->GetSig(), pMD->GetModule());
            msig.GetReturnTypeNormalized();
            bMemberTypeLoaded = TRUE;
        }

        // Prepare the arguments that will be used to retrieve the value of all the properties.
        INT64 Args[] = { 
            ObjToInt64(MemberInfoObj)
        };

        // Retrieve the actual type of the member info.
        m_enumType = (EnumMemberTypes)pMD->Call(Args);
    }
    GCPROTECT_END();

    if (s_iNumMemberTypesKnown < NUM_MEMBER_TYPES)
    {
        s_pMemberTypes[s_iNumMemberTypesKnown] = MemberInfoObj->GetClass();
        s_memberTypes[s_iNumMemberTypesKnown++] = m_enumType;
    }
}

void DispatchMemberInfo::DetermineParamCount()
{
    MethodDesc *pGetParamsMD = NULL;

    // This should not be called more than once.
    _ASSERTE(m_iNumParams == -1);

    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    REFLECTBASEREF MemberInfoObj = (REFLECTBASEREF)ObjectFromHandle(m_hndMemberInfo);
    GCPROTECT_BEGIN(MemberInfoObj);
    {
        // Retrieve the method to use to retrieve the array of parameters.
        switch (GetMemberType())
        {
            case Method:
            {
                pGetParamsMD = DispatchInfo::GetMethodInfoMD(
                    MethodInfoMethods_GetParameters, ObjectFromHandle(m_hndMemberInfo)->GetTypeHandle());
                _ASSERTE(pGetParamsMD && "Unable to find method MemberBase::GetParameters");
                break;
            }

            case Property:
            {
                pGetParamsMD = DispatchInfo::GetPropertyInfoMD(
                    PropertyInfoMethods_GetIndexParameters, ObjectFromHandle(m_hndMemberInfo)->GetTypeHandle());
                _ASSERTE(pGetParamsMD && "Unable to find method PropertyInfo::GetIndexParameters");
                break;
            }
        }

        // If the member has parameters then get their count.
        if (pGetParamsMD != NULL)
        {
            INT64 GetParamsArgs[] = { 
                ObjToInt64(ObjectFromHandle(m_hndMemberInfo))
            };
            PTRARRAYREF ParamArray = (PTRARRAYREF)Int64ToObj(pGetParamsMD->Call(GetParamsArgs));
            if (ParamArray != NULL)
                m_iNumParams = ParamArray->GetNumComponents();
        }
        else
        {
            m_iNumParams = 0;
        }
    }
    GCPROTECT_END();
}

void DispatchMemberInfo::DetermineCultureAwareness()
{   
    THROWSCOMPLUSEXCEPTION();

    // This should not be called more than once.
    _ASSERTE(m_CultureAwareState == Unknown);

    static EEClass *s_pLcIdConvAttrClass;    

    // Load the LCIDConversionAttribute type.
    if (!s_pLcIdConvAttrClass)
        s_pLcIdConvAttrClass = g_Mscorlib.GetClass(CLASS__LCID_CONVERSION_TYPE)->GetClass();

    // Check to see if the attribute is set.
    REFLECTBASEREF MemberInfoObj = (REFLECTBASEREF)ObjectFromHandle(m_hndMemberInfo);
    GCPROTECT_BEGIN(MemberInfoObj);
    {
        // Retrieve the method to use to determine if the DispIdAttribute custom attribute is set.
        MethodDesc *pGetCustomAttributesMD = 
            DispatchInfo::GetCustomAttrProviderMD(CustomAttrProviderMethods_GetCustomAttributes, MemberInfoObj->GetTypeHandle());

        // Prepare the arguments.
        INT64 GetCustomAttributesArgs[] = { 
            0,
            0,
            ObjToInt64(s_pLcIdConvAttrClass->GetExposedClassObject())
        };

        // Now that we have potentially triggered a GC in the GetExposedClassObject
        // call above, it is safe to set the 'this' using our properly protected
        // MemberInfoObj value.
        GetCustomAttributesArgs[0] = ObjToInt64(MemberInfoObj);

        // Retrieve the custom attributes of type LCIDConversionAttribute.
        PTRARRAYREF CustomAttrArray = NULL;        
        COMPLUS_TRY
        {
            CustomAttrArray = (PTRARRAYREF) Int64ToObj(pGetCustomAttributesMD->Call(GetCustomAttributesArgs));
        }
        COMPLUS_CATCH
        {
        }
        COMPLUS_END_CATCH

        GCPROTECT_BEGIN(CustomAttrArray)
        {
            if ((CustomAttrArray != NULL) && (CustomAttrArray->GetNumComponents() > 0))
                m_CultureAwareState = Aware;
            else
                m_CultureAwareState = NonAware;
        }
        GCPROTECT_END();
    }
    GCPROTECT_END();
}

void DispatchMemberInfo::SetUpParamMarshalerInfo()
{
    REFLECTBASEREF MemberInfoObj = (REFLECTBASEREF)ObjectFromHandle(m_hndMemberInfo);   
    GCPROTECT_BEGIN(MemberInfoObj);
    {
        MethodTable *pMemberInfoMT = MemberInfoObj->GetMethodTable();
        if (pMemberInfoMT == g_pRefUtil->GetClass(RC_Method))
        {
            SetUpMethodMarshalerInfo((ReflectMethod*)MemberInfoObj->GetData(), FALSE);
        }
        else if (pMemberInfoMT == g_pRefUtil->GetClass(RC_Field))
        {
            SetUpFieldMarshalerInfo((ReflectField*)MemberInfoObj->GetData());
        }
        else if (pMemberInfoMT == g_pRefUtil->GetClass(RC_Prop))
        {
            ReflectProperty *pProp = (ReflectProperty*)MemberInfoObj->GetData();
            if (pProp->pSetter)
            {
                SetUpMethodMarshalerInfo(pProp->pSetter, FALSE);
            }
            if (pProp->pGetter)
            {
                // Only set up the marshalling information for the parameters if we haven't done it already 
                // for the setter.
                BOOL bSetUpReturnValueOnly = (pProp->pSetter != NULL);
                SetUpMethodMarshalerInfo(pProp->pGetter, bSetUpReturnValueOnly);
            }
        }
        else
        {
            // @FUTURE: Add support for user defined derived classes for
            //          MethodInfo, PropertyInfo and FieldInfo.
        }
    }
    GCPROTECT_END();
}

void DispatchMemberInfo::SetUpMethodMarshalerInfo(ReflectMethod *pReflectMeth, BOOL bReturnValueOnly)
{
    MethodDesc *pMD = pReflectMeth->pMethod;
    Module *pModule = pMD->GetModule();
    IMDInternalImport *pInternalImport = pModule->GetMDImport();
    CorElementType  mtype;
    MetaSig         msig(pMD->GetSig(), pModule);
    LPCSTR          szName;
    USHORT          usSequence;
    DWORD           dwAttr;
    mdParamDef      returnParamDef = mdParamDefNil;
    mdParamDef      currParamDef = mdParamDefNil;

#ifdef _DEBUG
    LPCUTF8         szDebugName = pMD->m_pszDebugMethodName;
    LPCUTF8         szDebugClassName = pMD->m_pszDebugClassName;
#endif

    int numArgs = msig.NumFixedArgs();
    SigPointer returnSig = msig.GetReturnProps();
    HENUMInternal *phEnumParams = NULL;
    HENUMInternal hEnumParams;


    //
    // Initialize the parameter definition enum.
    //

    HRESULT hr = pInternalImport->EnumInit(mdtParamDef, pMD->GetMemberDef(), &hEnumParams);
    if (SUCCEEDED(hr)) 
        phEnumParams = &hEnumParams;


    //
    // Retrieve the paramdef for the return type and determine which is the next 
    // parameter that has parameter information.
    //

    do 
    {
        if (phEnumParams && pInternalImport->EnumNext(phEnumParams, &currParamDef))
        {
            szName = pInternalImport->GetParamDefProps(currParamDef, &usSequence, &dwAttr);
            if (usSequence == 0)
            {
                // The first parameter, if it has sequence 0, actually describes the return type.
                returnParamDef = currParamDef;
            }
        }
        else
        {
            usSequence = (USHORT)-1;
        }
    }
    while (usSequence == 0);


    // Look up the best fit mapping info via Assembly & Interface level attributes
    BOOL BestFit = TRUE;
    BOOL ThrowOnUnmappableChar = FALSE;
    ReadBestFitCustomAttribute(pMD, &BestFit, &ThrowOnUnmappableChar);


    //
    // Unless the bReturnValueOnly flag is set, set up the marshaling info for the parameters.
    //

    if (!bReturnValueOnly)
    {
        int iParam = 1;
        while (ELEMENT_TYPE_END != (mtype = msig.NextArg()))
        {
            //
            // Get the parameter token if the current parameter has one.
            //

            mdParamDef paramDef = mdParamDefNil;
            if (usSequence == iParam)
            {
                paramDef = currParamDef;

                if (pInternalImport->EnumNext(phEnumParams, &currParamDef))
                {
                    szName = pInternalImport->GetParamDefProps(currParamDef, &usSequence, &dwAttr);

                    // Validate that the param def tokens are in order.
                    _ASSERTE((usSequence > iParam) && "Param def tokens are not in order");
                }
                else
                {
                    usSequence = (USHORT)-1;
                }
            }


            //
            // Set up the marshaling info for the parameter.
            //

            MarshalInfo Info(pModule, msig.GetArgProps(), paramDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 
                    0, 0, TRUE, iParam, BestFit, ThrowOnUnmappableChar
     #ifdef CUSTOMER_CHECKED_BUILD
                     ,pMD
    #endif
    #ifdef _DEBUG
                     ,szDebugName, szDebugClassName, NULL, iParam
    #endif
                );


            //
            // Based on the MarshalInfo, set up a DispParamMarshaler for the parameter.
            //

            SetUpDispParamMarshalerForMarshalInfo(iParam, &Info);

            //
            // Get the in/out/ref attributes.
            //

            SetUpDispParamAttributes(iParam, &Info);

            //
            // Increase the argument index.
            //

            iParam++;
        }

        // Make sure that there are not more param def tokens then there are COM+ arguments.
        _ASSERTE( usSequence == (USHORT)-1 && "There are more parameter information tokens then there are COM+ arguments" );
    }


    //
    // Set up the marshaling info for the return value.
    //

    if (msig.GetReturnType() != ELEMENT_TYPE_VOID)
    {
        MarshalInfo Info(pModule, returnSig, returnParamDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, FALSE, 0,
                        BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                         ,pMD
#endif
#ifdef _DEBUG
                         ,szDebugName, szDebugClassName, NULL, 0
#endif
                        );

        SetUpDispParamMarshalerForMarshalInfo(0, &Info);
    }


    //
    // If the paramdef enum was used, then close it.
    //

    if (phEnumParams)
        pInternalImport->EnumClose(phEnumParams);
}

void DispatchMemberInfo::SetUpFieldMarshalerInfo(ReflectField *pReflectField)
{
    // @TODO(DM): Implement this.
}

void DispatchMemberInfo::SetUpDispParamMarshalerForMarshalInfo(int iParam, MarshalInfo *pInfo)
{
    DispParamMarshaler *pDispParamMarshaler = pInfo->GenerateDispParamMarshaler();
    if (pDispParamMarshaler)
    {
        // If the array of marshalers hasn't been allocated yet, then allocate it.
        if (!m_apParamMarshaler)
        {
            // The array needs to be one more than the number of parameters for
            // normal methods and fields and 2 more properties.
            EnumMemberTypes MemberType = GetMemberType();
            int NumParamMarshalers = GetNumParameters() + ((MemberType == Property) ? 2 : 1);
            m_apParamMarshaler = new DispParamMarshaler*[NumParamMarshalers];
            memset(m_apParamMarshaler, 0, sizeof(DispParamMarshaler*) * NumParamMarshalers);
        }

        // Set the DispParamMarshaler in the array.
        m_apParamMarshaler[iParam] = pDispParamMarshaler;
    }
}


void DispatchMemberInfo::SetUpDispParamAttributes(int iParam, MarshalInfo* Info)
{
    // If the arry of In Only parameter indicators hasn't been allocated yet, then allocate it.
    if (!m_pParamInOnly)
    {
        EnumMemberTypes MemberType = GetMemberType();
        int NumInOnlyFlags = GetNumParameters() + ((MemberType == Property) ? 2 : 1);
        m_pParamInOnly = new BOOL[NumInOnlyFlags];
        memset(m_pParamInOnly, 0, sizeof(BOOL) * NumInOnlyFlags);
    }

    m_pParamInOnly[iParam] = ( Info->IsIn() && !Info->IsOut() );
}


//--------------------------------------------------------------------------------
// The DispatchInfo class implementation.

DispatchInfo::DispatchInfo(ComMethodTable *pComMTOwner)
: m_pComMTOwner(pComMTOwner)
, m_pFirstMemberInfo(NULL)
, m_lock("Interop", CrstInterop, FALSE, FALSE)
, m_CurrentDispID(0x10000)
, m_bInvokeUsingInvokeMember(FALSE)
, m_bAllowMembersNotInComMTMemberMap(FALSE)
{
    // Make sure a simple wrapper was specified.
    _ASSERTE(pComMTOwner);

    // Init the hashtable.
    m_DispIDToMemberInfoMap.Init(DISPID_TO_MEMBER_MAP_INITIAL_PRIME_INDEX, NULL);
}

DispatchInfo::~DispatchInfo()
{
    DispatchMemberInfo* pCurrMember = m_pFirstMemberInfo;
    while (pCurrMember)
    {
        // Retrieve the next member.
        DispatchMemberInfo* pNextMember = pCurrMember->m_pNext;

        // Delete the current member.
        delete pCurrMember;

        // Process the next member.
        pCurrMember = pNextMember;
    }
}

DispatchMemberInfo* DispatchInfo::FindMember(DISPID DispID)
{
    // We need to special case DISPID_UNKNOWN and -2 because the hashtable cannot handle them.
    // This is OK since these are invalid DISPID's.
    if ((DispID == DISPID_UNKNOWN) || (DispID == -2)) 
        return NULL;

    // Lookup in the hashtable to find member with the specified DISPID. Note: this hash is unsynchronized, but Gethash
    // doesn't require synchronization.
    UPTR Data = (UPTR)m_DispIDToMemberInfoMap.Gethash(DispID2HashKey(DispID));
    if (Data != -1)
    {
        // We have found the member, so ensure it is initialized and return it.
        DispatchMemberInfo *pMemberInfo = (DispatchMemberInfo*)Data;
        pMemberInfo->EnsureInitialized();
        return pMemberInfo;
    }
    else
    {
        return NULL;
    }
}

DispatchMemberInfo* DispatchInfo::FindMember(BSTR strName, BOOL bCaseSensitive)
{
    BOOL fFound = FALSE;

    // Make sure we are in cooperative GC mode.
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Retrieve the appropriate string comparation function.
    UnicodeStringCompareFuncPtr StrCompFunc = bCaseSensitive ? wcscmp : _wcsicmp;

    // Go through the list of DispatchMemberInfo's to try and find one with the 
    // specified name.
    DispatchMemberInfo *pCurrMemberInfo = m_pFirstMemberInfo;
    while (pCurrMemberInfo)
    {
        if (ObjectFromHandle(pCurrMemberInfo->m_hndMemberInfo) != NULL)
        {
            // Compare the 2 strings. We can use the normal string compare operations since we
            // do not support embeded NULL's inside member names.
            if (StrCompFunc(pCurrMemberInfo->m_strName, strName) == 0)
            {
                // We have found the member, so ensure it is initialized and return it.
                pCurrMemberInfo->EnsureInitialized();
                return pCurrMemberInfo;
            }
        }

        // Process the next member.
        pCurrMemberInfo = pCurrMemberInfo->m_pNext;
    }

    // No member has been found with the coresponding name.
    return NULL;
}

// Helper method used to create DispatchMemberInfo's. This is only here because
// we can't call new inside a method that has a COMPLUS_TRY statement.
DispatchMemberInfo* DispatchInfo::CreateDispatchMemberInfoInstance(DISPID DispID, LPWSTR strMemberName, REFLECTBASEREF MemberInfoObj)
{
    return new DispatchMemberInfo(this, DispID, strMemberName, MemberInfoObj);
}

struct InvokeObjects
{
    PTRARRAYREF ParamArray;
    PTRARRAYREF CleanUpArray;
    REFLECTBASEREF MemberInfo;
    OBJECTREF OleAutBinder;
    OBJECTREF Target;
    OBJECTREF PropVal;
    OBJECTREF ByrefStaticArrayBackupPropVal;
    OBJECTREF RetVal;
    OBJECTREF TmpObj;
    OBJECTREF MemberName;
    OBJECTREF CultureInfo;
    OBJECTREF OldCultureInfo;
    PTRARRAYREF NamedArgArray;
};

// Helper method that invokes the member with the specified DISPID.
HRESULT DispatchInfo::InvokeMember(SimpleComCallWrapper *pSimpleWrap, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pVarRes, EXCEPINFO *pei, IServiceProvider *pspCaller, unsigned int *puArgErr)
{
    HRESULT hr = S_OK;
    int i = 0;
    int iSrcArg = -1;
    int iDestArg;
    int iBaseErrorArg = 0;
    int NumArgs;
    int NumNamedArgs;
    int NumParams;
    int CleanUpArrayArraySize = -1;
    EnumMemberTypes MemberType;
    InvokeObjects Objs;
    DISPID *pSrcArgNames = NULL;
    VARIANT *pSrcArgs = NULL;
    BOOL bHasMissingArguments = FALSE;
    int BindingFlags = 0;
    Thread *pThread = GetThread();
    AppDomain *pAppDomain = pThread->GetDomain();

    _ASSERTE(pSimpleWrap);


    //
    // Validate the arguments.
    //

    if (!pdp)
        return E_POINTER;
    if (!pdp->rgvarg && (pdp->cArgs > 0))
        return E_INVALIDARG;
    if (!pdp->rgdispidNamedArgs && (pdp->cNamedArgs > 0))
        return E_INVALIDARG;
    if (pdp->cNamedArgs > pdp->cArgs)
        return E_INVALIDARG;
    if ((int)pdp->cArgs < 0 || (int)pdp->cNamedArgs < 0)
        return E_INVALIDARG;


    //
    // Make sure the GC mode has been switched to cooperative.
    //

    _ASSERTE(pThread && pThread->PreemptiveGCDisabled());

    
    //
    // Clear the out arguments before we start.
    //

    if (pVarRes)
        VariantClear(pVarRes);
    if (puArgErr)
        *puArgErr = -1;


    //
    // Convert the default LCID's to actual LCID's.
    //

    if(lcid == LOCALE_SYSTEM_DEFAULT || lcid == 0)
        lcid = GetSystemDefaultLCID();

    if(lcid == LOCALE_USER_DEFAULT)
        lcid = GetUserDefaultLCID();


    //
    // Set the value of the variables we use internally.
    //

    NumArgs = pdp->cArgs;
    NumNamedArgs = pdp->cNamedArgs;
    memset(&Objs, 0, sizeof(InvokeObjects));

    if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
    {
        if (NumArgs < 1)
        {
            return DISP_E_BADPARAMCOUNT;
        }
        else
        {
            NumArgs--;
            pSrcArgs = &pdp->rgvarg[1];
        }

        if (NumNamedArgs < 1)
        {
			if (NumNamedArgs < 0)  
				return DISP_E_BADPARAMCOUNT;
			// Verify if we really want to do this or return E_INVALIDARG instead.
			_ASSERTE(NumNamedArgs == 0);
            _ASSERTE(pSrcArgNames == NULL);
        }
        else
        {
            NumNamedArgs--;
            pSrcArgNames = &pdp->rgdispidNamedArgs[1];
        }
    }
    else
    {
        pSrcArgs = pdp->rgvarg;
        pSrcArgNames = pdp->rgdispidNamedArgs;
    }


    //
    // Do a lookup in the hashtable to find the DispatchMemberInfo for the DISPID.
    //

    DispatchMemberInfo *pDispMemberInfo = FindMember(id);
    if (!pDispMemberInfo || !(*((Object **)pDispMemberInfo->m_hndMemberInfo)))
        pDispMemberInfo = NULL;


    //
    // If the member is not known then make sure that the DispatchInfo we have
    // supports unknown members.
    //
    
    if (m_bInvokeUsingInvokeMember)
    {
        // Since we do not have any information regarding the member then we
        // must assume the number of formal parameters matches the number of args.
        NumParams = NumArgs;
    }
    else
    {
        // If we haven't found the member then fail the invoke call.
        if (!pDispMemberInfo)
            return DISP_E_MEMBERNOTFOUND;

        // DISPATCH_CONSTRUCT only works when calling InvokeMember.
        if (wFlags & DISPATCH_CONSTRUCT)
            return E_INVALIDARG;

        // We have the member so retrieve the number of formal parameters.
        NumParams = pDispMemberInfo->GetNumParameters();

        // Make sure the number of arguments does not exceed the number of parameters.
        if (NumArgs > NumParams)
            return DISP_E_BADPARAMCOUNT;

        // Validate that all the named arguments are known.
        for (iSrcArg = 0; iSrcArg < NumNamedArgs; iSrcArg++)
        {
            // There are some members we do not know about so we will call InvokeMember() 
            // passing in the DISPID's directly so the caller can try to handle them.
            if (pSrcArgNames[iSrcArg] < 0 || pSrcArgNames[iSrcArg] >= NumParams)
                return DISP_E_MEMBERNOTFOUND;
        }
    }


    //
    // The member is present so we need to convert the arguments and then do the
    // actual invocation.
    //

    GCPROTECT_BEGIN(Objs);
    {
        //
        // Allocate information used by the method.
        //

        // Allocate the array of byref objects.
        VARIANT **aByrefArgOleVariant = (VARIANT **)_alloca(sizeof(VARIANT *) * NumArgs);
        DWORD *aByrefArgMngVariantIndex = (DWORD *)_alloca(sizeof(DWORD) * NumArgs);
        int NumByrefArgs = 0;
        BOOL bPropValIsByref = FALSE;
        int* pManagedMethodParamIndexMap = (int*)_alloca(sizeof(int) * NumArgs);

        // Allocate the array of backup byref static array objects.
        OBJECTHANDLE *aByrefStaticArrayBackupObjHandle = (OBJECTHANDLE *)_alloca(sizeof(OBJECTHANDLE *) * NumArgs);
        memset(aByrefStaticArrayBackupObjHandle, 0, NumArgs * sizeof(OBJECTHANDLE));

        // Allocate the array of used flags.
        BYTE *aArgUsedFlags = (BYTE*)_alloca(NumParams * sizeof(BYTE));
        memset(aArgUsedFlags, 0, NumParams * sizeof(BYTE));

        COMPLUS_TRY
        {
            //
            // Retrieve information required for the invoke call.
            //

            Objs.Target = pSimpleWrap->GetObjectRef();
            Objs.OleAutBinder = DispatchInfo::GetOleAutBinder();


            //
            // Allocate the array of arguments
            //

            // Allocate the array that will contain the converted variants in the right order.
            // If the invoke is for a PROPUT or a PROPPUTREF and we are going to call through
            // invoke member then allocate the array one bigger to allow space for the property 
            // value.
            int ArraySize = m_bInvokeUsingInvokeMember && wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF) ? NumParams + 1 : NumParams;
            Objs.ParamArray = (PTRARRAYREF)AllocateObjectArray(ArraySize, g_pObjectClass);


            //
            // Convert the property set argument if the invoke is a PROPERTYPUT OR PROPERTYPUTREF.
            //

            if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
            {
                // Convert the variant.
                iSrcArg = 0;
                VARIANT *pSrcOleVariant = RetrieveSrcVariant(&pdp->rgvarg[iSrcArg]);
                MarshalParamNativeToManaged(pDispMemberInfo, NumArgs, pSrcOleVariant, &Objs.PropVal);

                // Remember if the argument is a variant representing missing.
                bHasMissingArguments |= VariantIsMissing(pSrcOleVariant);

                // Remember if the property value is byref or not.
                bPropValIsByref = V_VT(pSrcOleVariant) & VT_BYREF;

                // If the variant is a byref static array, then remember the property value.
                if (IsVariantByrefStaticArray(pSrcOleVariant))
                    SetObjectReference(&Objs.ByrefStaticArrayBackupPropVal, Objs.PropVal, pAppDomain);

                // Since this invoke is for a property put or put ref we need to add 1 to
                // the iSrcArg to get the argument that is in error.
                iBaseErrorArg = 1;
            }


            //
            // Convert the named arguments.
            //

            if (!m_bInvokeUsingInvokeMember)
            {
                for (iSrcArg = 0; iSrcArg < NumNamedArgs; iSrcArg++)
                {
                    // Determine the destination index.
                    iDestArg = pSrcArgNames[iSrcArg];

                    // Check for duplicate param DISPID's.
                    if (aArgUsedFlags[iDestArg] != 0)
                        COMPlusThrowHR(DISP_E_PARAMNOTFOUND);

                    // Convert the variant.
                    VARIANT *pSrcOleVariant = RetrieveSrcVariant(&pSrcArgs[iSrcArg]);
                    MarshalParamNativeToManaged(pDispMemberInfo, iDestArg, pSrcOleVariant, &Objs.TmpObj);
                    Objs.ParamArray->SetAt(iDestArg, Objs.TmpObj);

                    // Remember if the argument is a variant representing missing.
                    bHasMissingArguments |= VariantIsMissing(pSrcOleVariant);

                    // If the argument is byref then add it to the array of byref arguments.
                    if (V_VT(pSrcOleVariant) & VT_BYREF)
                    {
                        // Remember what arg this really is.
                        pManagedMethodParamIndexMap[NumByrefArgs] = iDestArg;
                        
                        aByrefArgOleVariant[NumByrefArgs] = pSrcOleVariant;
                        aByrefArgMngVariantIndex[NumByrefArgs] = iDestArg;

                        // If the variant is a byref static array, then remember the objectref we
                        // converted the variant to.
                        if (IsVariantByrefStaticArray(pSrcOleVariant))
                            aByrefStaticArrayBackupObjHandle[NumByrefArgs] = pAppDomain->CreateHandle(Objs.TmpObj);

                        NumByrefArgs++;
                    }

                    // Mark the slot the argument is in as occupied.
                    aArgUsedFlags[iDestArg] = 1;
                }
            }
            else
            {
                for (iSrcArg = 0, iDestArg = 0; iSrcArg < NumNamedArgs; iSrcArg++, iDestArg++)
                {
                    // Convert the variant.
                    VARIANT *pSrcOleVariant = RetrieveSrcVariant(&pSrcArgs[iSrcArg]);
                    MarshalParamNativeToManaged(pDispMemberInfo, iDestArg, pSrcOleVariant, &Objs.TmpObj);
                    Objs.ParamArray->SetAt(iDestArg, Objs.TmpObj);

                    // Remember if the argument is a variant representing missing.
                    bHasMissingArguments |= VariantIsMissing(pSrcOleVariant);

                    // If the argument is byref then add it to the array of byref arguments.
                    if (V_VT(pSrcOleVariant) & VT_BYREF)
                    {
                        // Remember what arg this really is.
                        pManagedMethodParamIndexMap[NumByrefArgs] = iDestArg;
                        
                        aByrefArgOleVariant[NumByrefArgs] = pSrcOleVariant;
                        aByrefArgMngVariantIndex[NumByrefArgs] = iDestArg;

                        // If the variant is a byref static array, then remember the objectref we
                        // converted the variant to.
                        if (IsVariantByrefStaticArray(pSrcOleVariant))
                            aByrefStaticArrayBackupObjHandle[NumByrefArgs] = pAppDomain->CreateHandle(Objs.TmpObj);

                        NumByrefArgs++;
                    }

                    // Mark the slot the argument is in as occupied.
                    aArgUsedFlags[iDestArg] = 1;
                }
            }


            //
            // Fill in the positional arguments. These are copied in reverse order and we also
            // need to skip the arguments already filled in by named arguments.
            //

            for (iSrcArg = NumArgs - 1, iDestArg = 0; iSrcArg >= NumNamedArgs; iSrcArg--, iDestArg++)
            {
                // Skip the arguments already filled in by named args.
                for (; aArgUsedFlags[iDestArg] != 0; iDestArg++);
                _ASSERTE(iDestArg < NumParams);

                // Convert the variant.
                VARIANT *pSrcOleVariant = RetrieveSrcVariant(&pSrcArgs[iSrcArg]);
                MarshalParamNativeToManaged(pDispMemberInfo, iDestArg, pSrcOleVariant, &Objs.TmpObj);
                Objs.ParamArray->SetAt(iDestArg, Objs.TmpObj);

                // Remember if the argument is a variant representing missing.
                bHasMissingArguments |= VariantIsMissing(pSrcOleVariant);

                // If the argument is byref then add it to the array of byref arguments.
                if (V_VT(pSrcOleVariant) & VT_BYREF)
                {
                    // Remember what arg this really is.
                    pManagedMethodParamIndexMap[NumByrefArgs] = iDestArg;
                        
                    aByrefArgOleVariant[NumByrefArgs] = pSrcOleVariant;
                    aByrefArgMngVariantIndex[NumByrefArgs] = iDestArg;

                    // If the variant is a byref static array, then remember the objectref we
                    // converted the variant to.
                    if (IsVariantByrefStaticArray(pSrcOleVariant))
                        aByrefStaticArrayBackupObjHandle[NumByrefArgs] = pAppDomain->CreateHandle(Objs.TmpObj);

                    NumByrefArgs++;
                }
            }

            // Set the source arg back to -1 to indicate we are finished converting args.
            iSrcArg = -1;

            
            // 
            // Fill in all the remaining arguments with Missing.Value.
            //

            for (; iDestArg < NumParams; iDestArg++)
            {
                if (aArgUsedFlags[iDestArg] == 0)
                {
                    Objs.ParamArray->SetAt(iDestArg, GetMissingObject());
                    bHasMissingArguments = TRUE;
                }
            }


            //
            // Set up the binding flags to pass to reflection.
            //

            BindingFlags = ConvertInvokeFlagsToBindingFlags(wFlags) | BINDER_OptionalParamBinding;


            //
            // Do the actual invocation on the member info.
            //

            if (!m_bInvokeUsingInvokeMember)
            {
                _ASSERTE(pDispMemberInfo);

                if (pDispMemberInfo->IsCultureAware())
                {
                    // If the method is culture aware, then set the specified culture on the thread.
                    GetCultureInfoForLCID(lcid, &Objs.CultureInfo);
                    Objs.OldCultureInfo = pThread->GetCulture(FALSE);
                    pThread->SetCultureId(lcid, FALSE);
                }

                // If the method has custom marshalers then we will need to call
                // the clean up method on the objects. So we need to make a copy of the
                // ParamArray since it might be changed by reflection if any of the
                // parameters are byref.
                if (pDispMemberInfo->RequiresManagedObjCleanup())
                {
                    // Allocate the clean up array.
                    CleanUpArrayArraySize = wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF) ? NumParams + 1 : NumParams;
                    Objs.CleanUpArray = (PTRARRAYREF)AllocateObjectArray(CleanUpArrayArraySize, g_pObjectClass);

                    // Copy the parameters into the clean up array.
                    for (i = 0; i < ArraySize; i++)
                        Objs.CleanUpArray->SetAt(i, Objs.ParamArray->GetAt(i));

                    // If this invoke is for a PROPUT or PROPPUTREF, then add the property object to
                    // the end of the clean up array.
                    if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
                        Objs.CleanUpArray->SetAt(NumParams, Objs.PropVal);
                }

                // Retrieve the member info object and the type of the member.
                Objs.MemberInfo = (REFLECTBASEREF)ObjectFromHandle(pDispMemberInfo->m_hndMemberInfo);
                MemberType = pDispMemberInfo->GetMemberType();
            
                // Determine whether the member has a link time security check. If so we
                // need to emulate this (since the caller is obviously not jitted in this
                // case). Only methods and properties can have a link time check.
                MethodDesc *pMD = NULL;

                if (MemberType == Method)
                {
                    ReflectMethod *pRM = (ReflectMethod*)Objs.MemberInfo->GetData();
                    pMD = pRM->pMethod;           
                }
                else if (MemberType == Property)
                {
                    ReflectProperty *pRP = (ReflectProperty*)Objs.MemberInfo->GetData();
                    if ((wFlags & DISPATCH_PROPERTYGET) && (pRP->pGetter != NULL))
                    {
                        pMD = pRP->pGetter->pMethod;
                    }
                    else if (pRP->pSetter != NULL)
                    {
                        pMD = pRP->pSetter->pMethod;
                    }
                }

                if (pMD)
                    Security::CheckLinkDemandAgainstAppDomain(pMD);

                switch (MemberType)
                {
                    case Field:
                    {
                        // Make sure this invoke is actually for a property put or get.
                        if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
                        {   
                            // Do some more validation now that we know the type of the invocation.
                            if (NumNamedArgs != 0)
                                COMPlusThrowHR(DISP_E_NONAMEDARGS);
                            if (NumArgs != 0)
                                COMPlusThrowHR(DISP_E_BADPARAMCOUNT);

                            // Retrieve the method descriptor that will be called on.
                            MethodDesc *pMD = GetFieldInfoMD(FieldInfoMethods_GetValue, Objs.MemberInfo->GetTypeHandle());

                            // Prepare the arguments that will be passed to Invoke.
                            int StackSize = sizeof(OBJECTREF) * 2;
                            BYTE *Args = (BYTE*)_alloca(StackSize);
                            BYTE *pDst = Args;

                            *((REFLECTBASEREF*)pDst) = Objs.MemberInfo;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.Target;
                            pDst += sizeof(OBJECTREF);

                            // Validate that the stack size is coherent with the number of arguments pushed.
                            _ASSERTE(pDst - Args == StackSize);

                            // Do the actual method invocation.
                            Objs.RetVal = Int64ToObj(pMD->Call(Args, &MetaSig(pMD->GetSig(),pMD->GetModule())));
                        }
                        else if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
                        {
                            // Do some more validation now that we know the type of the invocation.
                            if (NumArgs != 0)
                                COMPlusThrowHR(DISP_E_BADPARAMCOUNT);
                            if (NumNamedArgs != 0)
                                COMPlusThrowHR(DISP_E_NONAMEDARGS);

                            // Retrieve the method descriptor that will be called on.
                            MethodDesc *pMD = GetFieldInfoMD(FieldInfoMethods_SetValue, Objs.MemberInfo->GetTypeHandle());

                            // Prepare the arguments that will be passed to Invoke.
                            int StackSize = sizeof(OBJECTREF) * 5 + sizeof(int);
                            BYTE *Args = (BYTE*)_alloca(StackSize);
                            BYTE *pDst = Args;

                            *((REFLECTBASEREF*)pDst) = Objs.MemberInfo;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.CultureInfo;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.OleAutBinder;
                            pDst += sizeof(OBJECTREF);

                            *((int*)pDst) = BindingFlags;
                            pDst += sizeof(int);

                            *((OBJECTREF*)pDst) = Objs.PropVal;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.Target;
                            pDst += sizeof(OBJECTREF);

                            // Validate that the stack size is coherent with the number of arguments pushed.
                            _ASSERTE(pDst - Args == StackSize);

                            // Do the actual method invocation.
                            pMD->Call(Args, &MetaSig(pMD->GetSig(),pMD->GetModule()));
                        }
                        else
                        {
                            COMPlusThrowHR(DISP_E_MEMBERNOTFOUND);
                        }

                        break;
                    }

                    case Property:
                    {
                        // Make sure this invoke is actually for a property put or get.
                        if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
                        {
                            // Retrieve the method descriptor that will be called on.
                            MethodDesc *pMD = GetPropertyInfoMD(PropertyInfoMethods_GetValue, Objs.MemberInfo->GetTypeHandle());

                            // Prepare the arguments that will be passed to GetValue().
                            int StackSize = sizeof(OBJECTREF) * 5 + sizeof(int);
                            BYTE *Args = (BYTE*)_alloca(StackSize);
                            BYTE *pDst = Args;

                            *((REFLECTBASEREF*)pDst) = Objs.MemberInfo;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.CultureInfo;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = (OBJECTREF)Objs.ParamArray;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.OleAutBinder;
                            pDst += sizeof(OBJECTREF);

                            *((int*)pDst) = BindingFlags;
                            pDst += sizeof(int);

                            *((OBJECTREF*)pDst) = Objs.Target;
                            pDst += sizeof(OBJECTREF);

                            // Validate that the stack size is coherent with the number of arguments pushed.
                            _ASSERTE(pDst - Args == StackSize);

                            // Do the actual method invocation.
                            Objs.RetVal = Int64ToObj(pMD->Call(Args, &MetaSig(pMD->GetSig(),pMD->GetModule())));
                        }
                        else if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
                        {
                            // Retrieve the method descriptor that will be called on.
                            MethodDesc *pMD = GetPropertyInfoMD(PropertyInfoMethods_SetValue, Objs.MemberInfo->GetTypeHandle());

                            // Prepare the arguments that will be passed to SetValue().
                            int StackSize = sizeof(OBJECTREF) * 6 + sizeof(int);
                            BYTE *Args = (BYTE*)_alloca(StackSize);
                            BYTE *pDst = Args;

                            *((REFLECTBASEREF*)pDst) = Objs.MemberInfo;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.CultureInfo;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = (OBJECTREF)Objs.ParamArray;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.OleAutBinder;
                            pDst += sizeof(OBJECTREF);

                            *((int*)pDst) = BindingFlags;
                            pDst += sizeof(int);

                            *((OBJECTREF*)pDst) = Objs.PropVal;
                            pDst += sizeof(OBJECTREF);

                            *((OBJECTREF*)pDst) = Objs.Target;
                            pDst += sizeof(OBJECTREF);

                            // Validate that the stack size is coherent with the number of arguments pushed.
                            _ASSERTE(pDst - Args == StackSize);

                            // Do the actual method invocation.
                            pMD->Call(Args, &MetaSig(pMD->GetSig(),pMD->GetModule()));
                        }
                        else
                        {
                            COMPlusThrowHR(DISP_E_MEMBERNOTFOUND);
                        }

                        break;
                    }

                    case Method:
                    {
                        // Make sure this invoke is actually for a method. We also allow
                        // prop gets since it is harmless and it allows the user a bit
                        // more freedom.
                        if (!(wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET)))
                            COMPlusThrowHR(DISP_E_MEMBERNOTFOUND);

                        // Retrieve the method descriptor that will be called on.
                        MethodDesc *pMD = GetMethodInfoMD(MethodInfoMethods_Invoke, Objs.MemberInfo->GetTypeHandle());

                        // If we are using RuntimeMethodInfo, we can go directly to COMMember::InvokeMethod
                        // PLEASE NOTE - ANY CHANGE HERE MAY HAVE TO BE PROPAGATED TO RuntimeMethodInfo::Invoke METHOD
                        if (pMD == m_apMethodInfoMD[MethodInfoMethods_Invoke] && bHasMissingArguments == FALSE)
                        {
                            COMMember::_InvokeMethodArgs args;

                            args.refThis = Objs.MemberInfo;
                            args.locale = NULL;
                            args.objs = Objs.ParamArray;
                            args.binder = Objs.OleAutBinder;
                            args.attrs = BindingFlags;
                            args.target = Objs.Target;
                            args.isBinderDefault = FALSE;
                            args.caller = NULL;

                            GCPROTECT_BEGIN(args.refThis);
                            GCPROTECT_BEGIN(args.objs);
                            GCPROTECT_BEGIN(args.binder);
                            GCPROTECT_BEGIN(args.target);

                            Objs.RetVal = ObjectToOBJECTREF((Object *)COMMember::InvokeMethod(&args));

                            GCPROTECT_END();
                            GCPROTECT_END();
                            GCPROTECT_END();
                            GCPROTECT_END();
                            break;
                        }

                        // Prepare the arguments that will be passed to Invoke.
                        int StackSize = sizeof(OBJECTREF) * 5 + sizeof(int);
                        BYTE *Args = (BYTE*)_alloca(StackSize);
                        BYTE *pDst = Args;

                        *((REFLECTBASEREF*)pDst) = Objs.MemberInfo;
                        pDst += sizeof(OBJECTREF);

                        *((OBJECTREF*)pDst) = Objs.CultureInfo;
                        pDst += sizeof(OBJECTREF);

                        *((OBJECTREF*)pDst) = (OBJECTREF)Objs.ParamArray;
                        pDst += sizeof(OBJECTREF);

                        *((OBJECTREF*)pDst) = Objs.OleAutBinder;
                        pDst += sizeof(OBJECTREF);

                        *((int*)pDst) = BindingFlags;
                        pDst += sizeof(int);

                        *((OBJECTREF*)pDst) = Objs.Target;
                        pDst += sizeof(OBJECTREF);

                        // Validate that the stack size is coherent with the number of arguments pushed.
                        _ASSERTE(pDst - Args == StackSize);

                        // Do the actual method invocation.
                        Objs.RetVal = Int64ToObj(pMD->Call(Args, &MetaSig(pMD->GetSig(),pMD->GetModule())));
                        break;
                    }

                    default:
                    {
                        COMPlusThrowHR(E_UNEXPECTED);
                    }
                }
            }
            else
            {
                WCHAR strTmp[64];

                // Convert the LCID into a CultureInfo.
                GetCultureInfoForLCID(lcid, &Objs.CultureInfo);

                // Retrieve the method descriptor that will be called on.
                MethodDesc *pMD = GetInvokeMemberMD();

                // Allocate the string that will contain the name of the member.
                if (!pDispMemberInfo)
                {
                    swprintf(strTmp, DISPID_NAME_FORMAT_STRING, id);
                    Objs.MemberName = (OBJECTREF)COMString::NewString(strTmp);
                }
                else
                {
                    Objs.MemberName = (OBJECTREF)COMString::NewString(pDispMemberInfo->m_strName);
                }

                // If there are named arguments, then set up the array of named arguments
                // to pass to InvokeMember.
                if (NumNamedArgs > 0)
                    SetUpNamedParamArray(pDispMemberInfo, pSrcArgNames, NumNamedArgs, &Objs.NamedArgArray);

                // If this is a PROPUT or a PROPPUTREF then we need to add the value 
                // being set as the last argument in the argument array.
                if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
                    Objs.ParamArray->SetAt(NumParams, Objs.PropVal);

                // Prepare the arguments that will be passed to Invoke.
                int StackSize = sizeof(OBJECTREF) * 8 + sizeof(int);
                BYTE *Args = (BYTE*)_alloca(StackSize);
                BYTE *pDst = Args;

                *((OBJECTREF*)pDst) = GetReflectionObject();
                pDst += sizeof(OBJECTREF);

                *((OBJECTREF*)pDst) = (OBJECTREF)Objs.NamedArgArray;
                pDst += sizeof(OBJECTREF);

                *((OBJECTREF*)pDst) = Objs.CultureInfo;
                pDst += sizeof(OBJECTREF);

                // @TODO(DM): Look into setting the byref modifiers.
                *((OBJECTREF*)pDst) = NULL;
                pDst += sizeof(OBJECTREF);

                *((OBJECTREF*)pDst) = (OBJECTREF)Objs.ParamArray;
                pDst += sizeof(OBJECTREF);

                *((OBJECTREF*)pDst) = Objs.Target;
                pDst += sizeof(OBJECTREF);

                *((OBJECTREF*)pDst) = Objs.OleAutBinder;
                pDst += sizeof(OBJECTREF);

                *((int*)pDst) = BindingFlags;
                pDst += sizeof(int);

                *((OBJECTREF*)pDst) = Objs.MemberName;
                pDst += sizeof(OBJECTREF);

                // Validate that the stack size is coherent with the number of arguments pushed.
                _ASSERTE(pDst - Args == StackSize);

                // Do the actual method invocation.
                Objs.RetVal = Int64ToObj(pMD->Call(Args, &MetaSig(pMD->GetSig(),pMD->GetModule())));
            }


            //
            // Convert the return value and the byref arguments.
            //

            // If the property value is byref then convert it back.
            if (bPropValIsByref)
                MarshalParamManagedToNativeRef(pDispMemberInfo, NumArgs, &Objs.PropVal, &Objs.ByrefStaticArrayBackupPropVal, &pdp->rgvarg[0]);

            // Convert all the ByRef arguments back.
            for (i = 0; i < NumByrefArgs; i++)
            {
                // Get the real parameter index for this arg.
                //  Add one to skip the return arg.
                int iParamIndex = pManagedMethodParamIndexMap[i] + 1;
                
                if (!pDispMemberInfo || m_bInvokeUsingInvokeMember || !pDispMemberInfo->IsParamInOnly(iParamIndex))
                {
                    Objs.TmpObj = Objs.ParamArray->GetAt(aByrefArgMngVariantIndex[i]);
                    MarshalParamManagedToNativeRef(pDispMemberInfo, i, &Objs.TmpObj, (OBJECTREF*)aByrefStaticArrayBackupObjHandle[i], aByrefArgOleVariant[i]);
                }

                if (aByrefStaticArrayBackupObjHandle[i])
                {
                    DestroyHandle(aByrefStaticArrayBackupObjHandle[i]);
                    aByrefStaticArrayBackupObjHandle[i] = NULL;
                }
            }

            // Convert the return COM+ object to an OLE variant.
            if (pVarRes)
                MarshalReturnValueManagedToNative(pDispMemberInfo, &Objs.RetVal, pVarRes);

            // If the member info requires managed object cleanup, then do it now.
            if (pDispMemberInfo && pDispMemberInfo->RequiresManagedObjCleanup())
            {
                // The size of the clean up array must have already been determined.
                _ASSERTE(CleanUpArrayArraySize != -1);

                for (i = 0; i < CleanUpArrayArraySize; i++)
                {
                    // Clean up all the managed parameters that were generated.
                    Objs.TmpObj = Objs.CleanUpArray->GetAt(i);
                    pDispMemberInfo->CleanUpParamManaged(i, &Objs.TmpObj);
                }
            }
        }
        COMPLUS_CATCH 
        {
            // Do HR convertion.
            hr = SetupErrorInfo(GETTHROWABLE());
            if (hr == COR_E_TARGETINVOCATION)
            {
                hr = DISP_E_EXCEPTION;
                if (pei)
                {
                    // Retrieve the exception iformation.
                    GetExcepInfoForInvocationExcep(GETTHROWABLE(), pei);

                    // Clear the IErrorInfo on the current thread since it does contains
                    // information on the TargetInvocationException which conflicts with
                    // the information in the returned EXCEPINFO.
                    IErrorInfo *pErrInfo = NULL;
                    HRESULT hr2 = GetErrorInfo(0, &pErrInfo);
                    _ASSERTE(hr2 == S_OK);
                    pErrInfo->Release();
                }
            }
            else if (hr == COR_E_OVERFLOW)
            {
                hr = DISP_E_OVERFLOW;
                if (iSrcArg != -1)
                {
                    if (puArgErr)
                        *puArgErr = iSrcArg + iBaseErrorArg;
                }
            }
            else if (hr == COR_E_INVALIDOLEVARIANTTYPE)
            {
                hr = DISP_E_BADVARTYPE;
                if (iSrcArg != -1)
                {
                    if (puArgErr)
                        *puArgErr = iSrcArg + iBaseErrorArg;
                }
            }
            else if (hr == COR_E_ARGUMENT)
            {
                hr = E_INVALIDARG;
                if (iSrcArg != -1)
                {
                    if (puArgErr)
                        *puArgErr = iSrcArg + iBaseErrorArg;
                }
            }
            else if (hr == COR_E_SAFEARRAYTYPEMISMATCH)
            {
                hr = DISP_E_TYPEMISMATCH;
                if (iSrcArg != -1)
                {
                    if (puArgErr)
                        *puArgErr = iSrcArg + iBaseErrorArg;
                }
            }

            // Destroy all the handles we allocated for the byref static safe array's.
            for (i = 0; i < NumByrefArgs; i++)
            {
                if (aByrefStaticArrayBackupObjHandle[i])
                    DestroyHandle(aByrefStaticArrayBackupObjHandle[i]);
            }
        }
        COMPLUS_END_CATCH

        // If the culture was changed then restore it to the old culture.
        if (Objs.OldCultureInfo != NULL)
            pThread->SetCulture(Objs.OldCultureInfo, FALSE);
    }
    GCPROTECT_END();

    return hr;
}

void DispatchInfo::EnterLock()
{
    Thread *pThread = GetThread();

    // Make sure we switch to cooperative mode before we take the lock.
    BOOL bToggleGC = pThread->PreemptiveGCDisabled();
    if (bToggleGC)
        pThread->EnablePreemptiveGC();

    // Try to enter the lock.
    m_lock.Enter();

    // Switch back to the original GC mode.
    if (bToggleGC)
        pThread->DisablePreemptiveGC();
}

void DispatchInfo::LeaveLock()
{
    // Simply leave the lock.
    m_lock.Leave();
}

// Parameter marshaling helpers.
void DispatchInfo::MarshalParamNativeToManaged(DispatchMemberInfo *pMemberInfo, int iParam, VARIANT *pSrcVar, OBJECTREF *pDestObj)
{
    if (pMemberInfo && !m_bInvokeUsingInvokeMember)
        pMemberInfo->MarshalParamNativeToManaged(iParam, pSrcVar, pDestObj);
    else
        OleVariant::MarshalObjectForOleVariant(pSrcVar, pDestObj);
}

void DispatchInfo::MarshalParamManagedToNativeRef(DispatchMemberInfo *pMemberInfo, int iParam, OBJECTREF *pSrcObj, OBJECTREF *pBackupStaticArray, VARIANT *pRefVar)
{
    THROWSCOMPLUSEXCEPTION();

    if (pBackupStaticArray && (*pBackupStaticArray != NULL))
    {
        // The contents of a static array can change, but not the array itself. If
        // the array has changed, then throw an exception.
        if (*pSrcObj != *pBackupStaticArray)
			COMPlusThrow(kInvalidOperationException, IDS_INVALID_REDIM);

        // Retrieve the element VARTYPE and method table.
        VARTYPE ElementVt = V_VT(pRefVar) & ~(VT_BYREF | VT_ARRAY);
        MethodTable *pElementMT = (*(BASEARRAYREF *)pSrcObj)->GetElementTypeHandle().GetMethodTable();

        // Convert the contents of the managed array into the original SAFEARRAY.
        OleVariant::MarshalSafeArrayForArrayRef((BASEARRAYREF *)pSrcObj,
                                                *V_ARRAYREF(pRefVar),
                                                ElementVt,
                                                pElementMT);
    }
    else
{
    if (pMemberInfo && !m_bInvokeUsingInvokeMember)
        pMemberInfo->MarshalParamManagedToNativeRef(iParam, pSrcObj, pRefVar);
    else
        OleVariant::MarshalOleRefVariantForObject(pSrcObj, pRefVar);
}
}

void DispatchInfo::MarshalReturnValueManagedToNative(DispatchMemberInfo *pMemberInfo, OBJECTREF *pSrcObj, VARIANT *pDestVar)
{
    if (pMemberInfo && !m_bInvokeUsingInvokeMember)
        pMemberInfo->MarshalReturnValueManagedToNative(pSrcObj, pDestVar);
    else
        OleVariant::MarshalOleVariantForObject(pSrcObj, pDestVar);
}

void DispatchInfo::SetUpNamedParamArray(DispatchMemberInfo *pMemberInfo, DISPID *pSrcArgNames, int NumNamedArgs, PTRARRAYREF *pNamedParamArray)
{
    PTRARRAYREF ParamArray = NULL;
    int NumParams = pMemberInfo ? pMemberInfo->GetNumParameters() : 0;
    int iSrcArg;
    int iDestArg;
    WCHAR strTmp[64];
    BOOL bGotParams = FALSE;
    
    GCPROTECT_BEGIN(ParamArray)
    {
        // Allocate the array of named parameters.
        *pNamedParamArray = (PTRARRAYREF)AllocateObjectArray(NumNamedArgs, g_pObjectClass);
        
        // Convert all the named parameters from DISPID's to string.
        for (iSrcArg = 0, iDestArg = 0; iSrcArg < NumNamedArgs; iSrcArg++, iDestArg++)
        {
            BOOL bParamNameSet = FALSE;
            
            // Check to see if the DISPID is one that we can map to a parameter name.
            if (pMemberInfo && pSrcArgNames[iSrcArg] >= 0 && pSrcArgNames[iSrcArg] < NumNamedArgs)
            {
                // The DISPID is one that we assigned, map it back to its name.
                if (!bGotParams)
                    ParamArray = pMemberInfo->GetParameters();
                
                // If we managed to get the parameters and if the current ID maps
                // to an entry in the array.
                if (ParamArray != NULL && (int)ParamArray->GetNumComponents() > pSrcArgNames[iSrcArg])
                {
                    OBJECTREF ParamInfoObj = ParamArray->GetAt(pSrcArgNames[iSrcArg]);
                    GCPROTECT_BEGIN(ParamInfoObj)
                    {
                        // Retrieve the MD to use to retrieve the name of the parameter.
                        MethodDesc *pGetParamNameMD = ParamInfoObj->GetClass()->FindPropertyMethod(PARAMETERINFO_NAME_PROP, PropertyGet);
                        _ASSERTE(pGetParamNameMD && "Unable to find getter method for property ParameterInfo::Name");
                        
                        // Retrieve the name of the parameter.
                        INT64 GetNameArgs[] = { 
                            ObjToInt64(ParamInfoObj)
                        };
                        STRINGREF MemberNameObj = (STRINGREF)Int64ToObj(pGetParamNameMD->Call(GetNameArgs));
                        
                        // If we got a valid name back then use it as the named parameter.
                        if (MemberNameObj != NULL)
                        {
                            (*pNamedParamArray)->SetAt(iDestArg, (OBJECTREF)MemberNameObj);
                            bParamNameSet = TRUE;
                        }
                    }
                    GCPROTECT_END();
                }
            }
            
            // If we haven't set the param name yet, then set it to [DISP=XXXX].
            if (!bParamNameSet)
            {
                swprintf(strTmp, DISPID_NAME_FORMAT_STRING, pSrcArgNames[iSrcArg]);
                (*pNamedParamArray)->SetAt(iDestArg, (OBJECTREF)COMString::NewString(strTmp));
            }
        }
    }
    GCPROTECT_END();
}

VARIANT *DispatchInfo::RetrieveSrcVariant(VARIANT *pDispParamsVariant)
{
    // For VB6 compatibility reasons, if the VARIANT is a VT_BYREF | VT_VARIANT that 
    // contains another VARIANT wiht VT_BYREF | VT_VARIANT, then we need to extract the 
    // inner VARIANT and use it instead of the outer one.
    if (V_VT(pDispParamsVariant) == (VT_VARIANT | VT_BYREF) && 
        V_VT(V_VARIANTREF(pDispParamsVariant)) == (VT_VARIANT | VT_BYREF))
    {
	    return V_VARIANTREF(pDispParamsVariant);
    }
    else
    {
	    return pDispParamsVariant;
    }
}

MethodDesc* DispatchInfo::GetTypeMD(EnumTypeMethods Method)
{
    // The ids of the methods. This needs to stay in sync with the enum of expando 
    // methods defined in DispatchInfo.h
    static BinderMethodID aMethods[] =
    {
        METHOD__CLASS__GET_PROPERTIES,
        METHOD__CLASS__GET_FIELDS,
        METHOD__CLASS__GET_METHODS,
        METHOD__CLASS__INVOKE_MEMBER
    };

    // If we already have retrieved the specified MD then just return it.
    if (m_apTypeMD[Method])
        return m_apTypeMD[Method];

    // The method desc has not been retrieved yet so find it.
    MethodDesc *pMD = g_Mscorlib.GetMethod(aMethods[Method]);

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

    // Cache the method desc.
    m_apTypeMD[Method] = pMD;

    // Return the specified method desc.
    return m_apTypeMD[Method];
}

MethodDesc* DispatchInfo::GetFieldInfoMD(EnumFieldInfoMethods Method, TypeHandle hndFieldInfoType)
{
    BOOL bUsingRuntimeImpl = FALSE;

    // The IDs of the methods. This needs to stay in sync with the enum of expando 
    // methods defined in DispatchInfo.h
    static BinderMethodID aMethods[] =
    {
        METHOD__FIELD__SET_VALUE,
        METHOD__FIELD__GET_VALUE,
    };

    // If the current class is the standard implementation then return the cached method desc if present.
    if (hndFieldInfoType.GetMethodTable() == g_pRefUtil->GetClass(RC_Field))
    {
        if (m_apFieldInfoMD[Method])
            return m_apFieldInfoMD[Method];

        bUsingRuntimeImpl = TRUE;
    }

    // The method desc has not been retrieved yet so find it.
    MethodDesc *pMD;
    if (bUsingRuntimeImpl)
        pMD = g_Mscorlib.GetMethod(aMethods[Method]);
    else
        pMD = hndFieldInfoType.GetClass()->FindMethod(g_Mscorlib.GetMethodName(aMethods[Method]), 
                                                      g_Mscorlib.GetMethodSig(aMethods[Method]), 
                                                      g_pRefUtil->GetClass(RC_Field));

    _ASSERTE(pMD && "Unable to find specified FieldInfo method");

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

    // If the loaded method desc is for the runtime field info class then cache it.
    if (bUsingRuntimeImpl)
        m_apFieldInfoMD[Method] = pMD;

    // Return the specified method desc.
    return pMD;
}

MethodDesc* DispatchInfo::GetPropertyInfoMD(EnumPropertyInfoMethods Method, TypeHandle hndPropInfoType)
{
    BOOL bUsingRuntimeImpl = FALSE;

    // The IDs of the methods. This needs to stay in sync with the enum of expando 
    // methods defined in DispatchInfo.h
    static BinderMethodID aMethods[] =
    {
        METHOD__PROPERTY__SET_VALUE,
        METHOD__PROPERTY__GET_VALUE,
        METHOD__PROPERTY__GET_INDEX_PARAMETERS,
    };

    // If the current class is the standard implementation then return the cached method desc if present.
    if (hndPropInfoType.GetMethodTable() == g_pRefUtil->GetClass(RC_Prop))
    {
        if (m_apPropertyInfoMD[Method])
            return m_apPropertyInfoMD[Method];

        bUsingRuntimeImpl = TRUE;
    }

    // The method desc has not been retrieved yet so find it.
    MethodDesc *pMD;
    if (bUsingRuntimeImpl)
        pMD = g_Mscorlib.GetMethod(aMethods[Method]);
    else
        pMD = hndPropInfoType.GetClass()->FindMethod(g_Mscorlib.GetMethodName(aMethods[Method]), 
                                                     g_Mscorlib.GetMethodSig(aMethods[Method]), 
                                                     g_pRefUtil->GetClass(RC_Prop));

    _ASSERTE(pMD && "Unable to find specified PropertyInfo method");

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

    // If the loaded method desc is for the standard runtime implementation then cache it.
    if (bUsingRuntimeImpl)
        m_apPropertyInfoMD[Method] = pMD;

    // Return the specified method desc.
    return pMD;
}

MethodDesc* DispatchInfo::GetMethodInfoMD(EnumMethodInfoMethods Method, TypeHandle hndMethodInfoType)
{
    BOOL bUsingRuntimeImpl = FALSE;

    // The IDs of the methods. This needs to stay in sync with the enum of expando 
    // methods defined in DispatchInfo.h
    static BinderMethodID aMethods[] =
    {
        METHOD__METHOD__INVOKE,
        METHOD__METHOD__GET_PARAMETERS,
    };

    // If the current class is the standard implementation then return the cached method desc if present.
    if (hndMethodInfoType.GetMethodTable() == g_pRefUtil->GetClass(RC_Method))
    {
        if (m_apMethodInfoMD[Method])
            return m_apMethodInfoMD[Method];

        bUsingRuntimeImpl = TRUE;
    }

    // The method desc has not been retrieved yet so find it.
    MethodDesc *pMD;
    if (bUsingRuntimeImpl)
        pMD = g_Mscorlib.GetMethod(aMethods[Method]);
    else
        pMD = hndMethodInfoType.GetClass()->FindMethod(g_Mscorlib.GetMethodName(aMethods[Method]),
                                                       g_Mscorlib.GetMethodSig(aMethods[Method]),
                                                       g_pRefUtil->GetClass(RC_Method));
    _ASSERTE(pMD && "Unable to find specified MethodInfo method");

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

    // If the loaded method desc is for the standard runtime implementation then cache it.
    if (bUsingRuntimeImpl)
        m_apMethodInfoMD[Method] = pMD;

    // Return the specified method desc.
    return pMD;
}

MethodDesc* DispatchInfo::GetCustomAttrProviderMD(EnumCustomAttrProviderMethods Method, TypeHandle hndCustomAttrProvider)
{
    THROWSCOMPLUSEXCEPTION();

    // The IDs of the methods. This needs to stay in sync with the enum of 
    // methods defined in DispatchInfo.h
    static BinderMethodID aMethods[] =
    {
        METHOD__ICUSTOM_ATTR_PROVIDER__GET_CUSTOM_ATTRIBUTES,
    };

    // If we already have retrieved the specified MD then just return it.
    if (m_apCustomAttrProviderMD[Method] == NULL)
    {
    // The method desc has not been retrieved yet so find it.
        MethodDesc *pMD = g_Mscorlib.GetMethod(aMethods[Method]);

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

        // Cache the method desc.
        m_apCustomAttrProviderMD[Method] = pMD;
    }

    MethodTable *pMT = hndCustomAttrProvider.AsMethodTable();
    MethodDesc *pMD = pMT->GetMethodDescForInterfaceMethod(m_apCustomAttrProviderMD[Method]);

    // Return the specified method desc.
    return pMD;
}

// This method synchronizes the DispatchInfo's members with the ones in the method tables type.
// The return value will be set to TRUE if the object was out of synch and members where
// added and it will be set to FALSE otherwise.
BOOL DispatchInfo::SynchWithManagedView()
{
    HRESULT hr = S_OK;
    LPWSTR strMemberName = NULL;
    ComMTMemberInfoMap *pMemberMap = NULL;

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return FALSE;

    // Determine if this is the first time we synch.
    BOOL bFirstSynch = (m_pFirstMemberInfo == NULL);

    // This method needs to be synchronized to make sure two threads don't try and 
    // add members at the same time.
    EnterLock();

    // Make sure we switch to cooperative mode before we start.
    BOOL bToggleGC = !pThread->PreemptiveGCDisabled();
    if (bToggleGC)
        pThread->DisablePreemptiveGC();

    // This represents the new member to add and it is also used to determine if members have 
    // been added or not.
    DispatchMemberInfo *pMemberToAdd = NULL;

    // Go through the list of member info's and find the end.
    DispatchMemberInfo **ppNextMember = &m_pFirstMemberInfo;
    while (*ppNextMember)
        ppNextMember = &((*ppNextMember)->m_pNext);

    COMPLUS_TRY
    {
        // Retrieve the member info map.
        pMemberMap = GetMemberInfoMap();

        for (int cPhase = 0; cPhase < 3; cPhase++)
        {
            PTRARRAYREF MemberArrayObj = NULL;
            GCPROTECT_BEGIN(MemberArrayObj);    

            // Retrieve the appropriate array of members for the current phase.
            switch (cPhase)
            {
                case 0: 
                    // Retrieve the array of properties.
                    MemberArrayObj = RetrievePropList();
                    break;

                case 1: 
                    // Retrieve the array of fields.
                    MemberArrayObj = RetrieveFieldList();
                    break;

                case 2: 
                    // Retrieve the array of methods.
                    MemberArrayObj = RetrieveMethList();
                    break;
            }

            // Retrieve the number of components in the member array.
            UINT NumComponents = 0;
            if (MemberArrayObj != NULL)
                NumComponents = MemberArrayObj->GetNumComponents();

            // Go through all the member info's in the array and see if they are already
            // in the DispatchExInfo.
            for (UINT i = 0; i < NumComponents; i++)
            {
                BOOL bMatch = FALSE;

                REFLECTBASEREF CurrMemberInfoObj = (REFLECTBASEREF)MemberArrayObj->GetAt(i);
                GCPROTECT_BEGIN(CurrMemberInfoObj)
                {
                    DispatchMemberInfo *pCurrMemberInfo = m_pFirstMemberInfo;
                    while (pCurrMemberInfo)
                    {
                        // We can simply compare the OBJECTREF's.
                        if (CurrMemberInfoObj == (REFLECTBASEREF)ObjectFromHandle(pCurrMemberInfo->m_hndMemberInfo))
                        {
                            // We have found a match.
                            bMatch = TRUE;
                            break;
                        }

                        // Check the next member.
                        pCurrMemberInfo = pCurrMemberInfo->m_pNext;
                    }

                    // If we have not found a match then we need to add the member info to the 
                    // list of member info's that will be added to the DispatchExInfo.
                    if (!bMatch)
                    {
                        DISPID MemberID = DISPID_UNKNOWN;
						BOOL bAddMember = FALSE;


                        //
                        // Attempt to retrieve the properties of the member.
                        //

						ComMTMethodProps *pMemberProps = DispatchMemberInfo::GetMemberProps(CurrMemberInfoObj, pMemberMap);					


                        //
                        // Determine if we are to add this member or not.
                        //

						if (pMemberProps)
						{
							bAddMember = pMemberProps->bMemberVisible;
						}
						else
						{
							bAddMember = m_bAllowMembersNotInComMTMemberMap;
						}

						if (bAddMember)
						{
							//
							// Retrieve the DISPID of the member.
                            //
                            MemberID = DispatchMemberInfo::GetMemberDispId(CurrMemberInfoObj, pMemberMap);


                            //
                            // If the member does not have an explicit DISPID or if the specified DISPID 
                            // is already in use then we need to generate a dynamic DISPID for the member.
                            //

                            if ((MemberID == DISPID_UNKNOWN) || (FindMember(MemberID) != NULL))
                                MemberID = GenerateDispID();


                            //
                            // Retrieve the name of the member.
                            //

                            strMemberName = DispatchMemberInfo::GetMemberName(CurrMemberInfoObj, pMemberMap);


                            //
                            // Create a DispatchInfoMemberInfo that will represent the member.
                            //

                            pMemberToAdd = CreateDispatchMemberInfoInstance(MemberID, strMemberName, CurrMemberInfoObj);
                            strMemberName = NULL;                 


                            //
                            // Add the member to the end of the list.
                            //

                            *ppNextMember = pMemberToAdd;

                            // Update ppNextMember to be ready for the next new member.
                            ppNextMember = &((*ppNextMember)->m_pNext);

                            // Add the member to the map. Note, the hash is unsynchronized, but we already have our lock
                            // so we're okay.
                            m_DispIDToMemberInfoMap.InsertValue(DispID2HashKey(MemberID), pMemberToAdd);
                        }
                    }
                }
                GCPROTECT_END();
            }

            GCPROTECT_END();        
        }
    }
    COMPLUS_CATCH
    {
        // This should REALLY not happen.
        _ASSERTE(!"An unexpected exception occured while synchronizing the DispatchInfo");
    }
    COMPLUS_END_CATCH

    // Switch back to the original GC mode.
    if (bToggleGC)
        pThread->EnablePreemptiveGC();

    // Leave the lock now that we have finished synchronizing with the IExpando.
    LeaveLock();

    // Clean up all allocated data.
    if (strMemberName)
        delete []strMemberName;
    if (pMemberMap)
        delete pMemberMap;

    // Check to see if any new members were added to the expando object.
    return pMemberToAdd ? TRUE : FALSE;
}

// This method retrieves the OleAutBinder type.
OBJECTREF DispatchInfo::GetOleAutBinder()
{
    THROWSCOMPLUSEXCEPTION();

    // If we have already create the instance of the OleAutBinder then simply return it.
    if (m_hndOleAutBinder)
        return ObjectFromHandle(m_hndOleAutBinder);

    MethodTable *pOleAutBinderClass = g_Mscorlib.GetClass(CLASS__OLE_AUT_BINDER);

    // Allocate an instance of the OleAutBinder class.
    OBJECTREF OleAutBinder = AllocateObject(pOleAutBinderClass);

    // Keep a handle to the OleAutBinder instance.
    m_hndOleAutBinder = CreateGlobalHandle(OleAutBinder);

    return OleAutBinder;
}

OBJECTREF DispatchInfo::GetMissingObject()
{
    if (!m_hndMissing)
    {
        // Get the field
        FieldDesc *pValueFD = g_Mscorlib.GetField(FIELD__MISSING__VALUE);
        // Retrieve the value static field and store it.
        m_hndMissing = GetAppDomain()->CreateHandle(pValueFD->GetStaticOBJECTREF());
    }

    return ObjectFromHandle(m_hndMissing);
}

BOOL DispatchInfo::VariantIsMissing(VARIANT *pOle)
{
    return (V_VT(pOle) == VT_ERROR) && (V_ERROR(pOle) == DISP_E_PARAMNOTFOUND);
}

PTRARRAYREF DispatchInfo::RetrievePropList()
{
    // Retrieve the MethodDesc to use.
    MethodDesc *pMD = GetTypeMD(TypeMethods_GetProperties);

    // Retrieve the exposed class object.
    OBJECTREF TargetObj = GetReflectionObject();

    // Prepare the arguments that will be passed to the method.
    INT64 Args[] = { 
        ObjToInt64(TargetObj),
        (INT64)BINDER_DefaultLookup
    };

    // Retrieve the array of members from the type object.
    return (PTRARRAYREF)Int64ToObj(pMD->Call(Args));
}

PTRARRAYREF DispatchInfo::RetrieveFieldList()
{
    // Retrieve the MethodDesc to use.
    MethodDesc *pMD = GetTypeMD(TypeMethods_GetFields);

    // Retrieve the exposed class object.
    OBJECTREF TargetObj = GetReflectionObject();

    // Prepare the arguments that will be passed to the method.
    INT64 Args[] = { 
        ObjToInt64(TargetObj),
        (INT64)BINDER_DefaultLookup
    };

    // Retrieve the array of members from the type object.
    return (PTRARRAYREF)Int64ToObj(pMD->Call(Args));
}

PTRARRAYREF DispatchInfo::RetrieveMethList()
{
    // Retrieve the MethodDesc to use.
    MethodDesc *pMD = GetTypeMD(TypeMethods_GetMethods);

    // Retrieve the exposed class object.
    OBJECTREF TargetObj = GetReflectionObject();

    // Prepare the arguments that will be passed to the method.
    INT64 Args[] = { 
        ObjToInt64(TargetObj),
        (INT64)BINDER_DefaultLookup
    };

    // Retrieve the array of members from the type object.
    return (PTRARRAYREF)Int64ToObj(pMD->Call(Args));
}

// Virtual method to retrieve the InvokeMember method desc.
MethodDesc* DispatchInfo::GetInvokeMemberMD()
{
    return GetTypeMD(TypeMethods_InvokeMember);
}

// Virtual method to retrieve the object associated with this DispatchInfo that 
// implements IReflect.
OBJECTREF DispatchInfo::GetReflectionObject()
{
    return m_pComMTOwner->m_pMT->GetClass()->GetExposedClassObject();
}

// Virtual method to retrieve the member info map.
ComMTMemberInfoMap *DispatchInfo::GetMemberInfoMap()
{
    THROWSCOMPLUSEXCEPTION();

    // Create the member info map.
    ComMTMemberInfoMap *pMemberInfoMap = new ComMTMemberInfoMap(m_pComMTOwner->m_pMT);
    if (!pMemberInfoMap)
        COMPlusThrowOM();

    // Initialize it.
    pMemberInfoMap->Init();

    return pMemberInfoMap;
}

// Helper function to fill in an EXCEPINFO for an InvocationException.
void DispatchInfo::GetExcepInfoForInvocationExcep(OBJECTREF objException, EXCEPINFO *pei)
{
    MethodDesc *pMD;
    ExceptionData ED;
    OBJECTREF InnerExcep = NULL;

    // Validate the arguments.
    _ASSERTE(objException != NULL);
    _ASSERTE(pei != NULL);
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Initialize the EXCEPINFO.
    memset(pei, 0, sizeof(EXCEPINFO));
    pei->scode = E_FAIL;

    GCPROTECT_BEGIN(InnerExcep)
    GCPROTECT_BEGIN(objException)
    {
        // Retrieve the method desc to access the InnerException property.
        pMD = objException->GetClass()->FindPropertyMethod(EXCEPTION_INNER_PROP, PropertyGet);
        _ASSERTE(pMD && "Unable to find get method for proprety Exception.InnerException");

        // Retrieve the value of the InnerException property.
        INT64 GetInnerExceptionArgs[] = { ObjToInt64(objException) };
        InnerExcep = (OBJECTREF) Int64ToObj(pMD->Call(GetInnerExceptionArgs));

        // If the inner exception object is null then we can't get any info.
        if (InnerExcep != NULL)
        {
            // Retrieve the exception data for the inner exception.
            ExceptionNative::GetExceptionData(InnerExcep, &ED);
            pei->bstrSource = ED.bstrSource;
            pei->bstrDescription = ED.bstrDescription;
            pei->bstrHelpFile = ED.bstrHelpFile;
            pei->dwHelpContext = ED.dwHelpContext;
            pei->scode = ED.hr;
        }
    }
    GCPROTECT_END();
    GCPROTECT_END();
}

int DispatchInfo::ConvertInvokeFlagsToBindingFlags(int InvokeFlags)
{
    int BindingFlags = 0;

    // Check to see if DISPATCH_CONSTRUCT is set.
    if (InvokeFlags & DISPATCH_CONSTRUCT)
        BindingFlags |= BINDER_CreateInstance;

    // Check to see if DISPATCH_METHOD is set.
    if (InvokeFlags & DISPATCH_METHOD)
        BindingFlags |= BINDER_InvokeMethod;

    if (InvokeFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
    {
        // We are dealing with a PROPPUT or PROPPUTREF or both.
        if ((InvokeFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) == (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
        {
            BindingFlags |= BINDER_SetProperty;
        }
        else if (InvokeFlags & DISPATCH_PROPERTYPUT)
        {
            BindingFlags |= BINDER_PutDispProperty;
        }
        else
        {
            BindingFlags |= BINDER_PutRefDispProperty;
        }
    }
    else
    {
        // We are dealing with a PROPGET.
        if (InvokeFlags & DISPATCH_PROPERTYGET)
            BindingFlags |= BINDER_GetProperty;
    }

    return BindingFlags;
}

BOOL DispatchInfo::IsVariantByrefStaticArray(VARIANT *pOle)
{
    if (V_VT(pOle) & VT_BYREF && V_VT(pOle) & VT_ARRAY)
    {
        if ((*V_ARRAYREF(pOle))->fFeatures & FADF_STATIC)
            return TRUE;
    }

    return FALSE;
}

DISPID DispatchInfo::GenerateDispID()
{
    // Find the next unused DISPID. Note, the hash is unsynchronized, but Gethash doesn't require synchronization.
    for (; (UPTR)m_DispIDToMemberInfoMap.Gethash(DispID2HashKey(m_CurrentDispID)) != -1; m_CurrentDispID++);
    return m_CurrentDispID++;
}

//--------------------------------------------------------------------------------
// The DispatchExInfo class implementation.

DispatchExInfo::DispatchExInfo(SimpleComCallWrapper *pSimpleWrapper, ComMethodTable *pIClassXComMT, BOOL bSupportsExpando)
: DispatchInfo(pIClassXComMT)
, m_pSimpleWrapperOwner(pSimpleWrapper)
, m_bSupportsExpando(bSupportsExpando)
{
    // Validate the arguments.
    _ASSERTE(pSimpleWrapper);

    // Set the flags to specify the behavior of the base DispatchInfo class.
    m_bAllowMembersNotInComMTMemberMap = TRUE;
    m_bInvokeUsingInvokeMember = TRUE;

    // Set all the IReflect and IExpando method desc pointers to NULL.
    memset(m_apIExpandoMD, 0, IExpandoMethods_LastMember * sizeof(MethodDesc *));
    memset(m_apIReflectMD, 0, IReflectMethods_LastMember * sizeof(MethodDesc *));
}

DispatchExInfo::~DispatchExInfo()
{
}

BOOL DispatchExInfo::SupportsExpando()
{
    return m_bSupportsExpando;
}

// Methods to lookup members. These methods synch with the managed view if they fail to
// find the method.
DispatchMemberInfo* DispatchExInfo::SynchFindMember(DISPID DispID)
{
    DispatchMemberInfo *pMemberInfo = FindMember(DispID);

    if (!pMemberInfo && SynchWithManagedView())
        pMemberInfo = FindMember(DispID);

    return pMemberInfo;
}

DispatchMemberInfo* DispatchExInfo::SynchFindMember(BSTR strName, BOOL bCaseSensitive)
{
    DispatchMemberInfo *pMemberInfo = FindMember(strName, bCaseSensitive);

    if (!pMemberInfo && SynchWithManagedView())
        pMemberInfo = FindMember(strName, bCaseSensitive);

    return pMemberInfo;
}

// Helper method that invokes the member with the specified DISPID. These methods synch 
// with the managed view if they fail to find the method.
HRESULT DispatchExInfo::SynchInvokeMember(SimpleComCallWrapper *pSimpleWrap, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pVarRes, EXCEPINFO *pei, IServiceProvider *pspCaller, unsigned int *puArgErr)
{
    // Invoke the member.
    HRESULT hr = InvokeMember(pSimpleWrap, id, lcid, wFlags, pdp, pVarRes, pei, pspCaller, puArgErr);

    // If the member was not found then we need to synch and try again if the managed view has changed.
    if ((hr == DISP_E_MEMBERNOTFOUND) && SynchWithManagedView())
        hr = InvokeMember(pSimpleWrap, id, lcid, wFlags, pdp, pVarRes, pei, pspCaller, puArgErr);

    return hr;
}

DispatchMemberInfo* DispatchExInfo::GetFirstMember()
{
    // Make sure we are in cooperative mode.
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Start with the first member.
    DispatchMemberInfo **ppNextMemberInfo = &m_pFirstMemberInfo;

    // If the next member is not set we need to sink up with the expando object 
    // itself to make sure that this member is really the last member and that
    // other members have not been added without us knowing.
    if (!(*ppNextMemberInfo))
    {
        if (SynchWithManagedView())
        {
            // New members have been added to the list and since they must be added
            // to the end the next member of the previous end of the list must
            // have been updated.
            _ASSERTE(*ppNextMemberInfo);
        }
    }

    // Now we need to make sure we skip any members that are deleted.
    while ((*ppNextMemberInfo) && !ObjectFromHandle((*ppNextMemberInfo)->m_hndMemberInfo))
        ppNextMemberInfo = &((*ppNextMemberInfo)->m_pNext);

    return *ppNextMemberInfo;
}

DispatchMemberInfo* DispatchExInfo::GetNextMember(DISPID CurrMemberDispID)
{
    // Make sure we are in cooperative mode.
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Do a lookup in the hashtable to find the DispatchMemberInfo for the DISPID.
    DispatchMemberInfo *pDispMemberInfo = FindMember(CurrMemberDispID);
    if (!pDispMemberInfo)
        return NULL;

    // Start from the next member.
    DispatchMemberInfo **ppNextMemberInfo = &pDispMemberInfo->m_pNext;

    // If the next member is not set we need to sink up with the expando object 
    // itself to make sure that this member is really the last member and that
    // other members have not been added without us knowing.
    if (!(*ppNextMemberInfo))
    {
        if (SynchWithManagedView())
        {
            // New members have been added to the list and since they must be added
            // to the end the next member of the previous end of the list must
            // have been updated.
            _ASSERTE(*ppNextMemberInfo);
        }
    }

    // Now we need to make sure we skip any members that are deleted.
    while ((*ppNextMemberInfo) && !ObjectFromHandle((*ppNextMemberInfo)->m_hndMemberInfo))
        ppNextMemberInfo = &((*ppNextMemberInfo)->m_pNext);

    return *ppNextMemberInfo;
}

DispatchMemberInfo* DispatchExInfo::AddMember(BSTR strName, BOOL bCaseSensitive)
{
    THROWSCOMPLUSEXCEPTION();

    DispatchMemberInfo *pDispMemberInfo = NULL;
    Thread *pThread = GetThread();

    _ASSERTE(pThread->PreemptiveGCDisabled());
    _ASSERTE(m_bSupportsExpando);

    // Attempt to find the member in the DispatchEx information.
    pDispMemberInfo = SynchFindMember(strName, bCaseSensitive);

    // If we haven't found the member, then we need to add it.
    if (!pDispMemberInfo)
    {
        // Take a lock before we check again to see if the member has been added by another thread.
        EnterLock();

        COMPLUS_TRY
        {
            // Now that we are inside the lock, check without synching.
            pDispMemberInfo = FindMember(strName, bCaseSensitive);
            if (!pDispMemberInfo)
            {
                // Retrieve the MethodDesc for AddField()
                MethodDesc *pMD = GetIExpandoMD(IExpandoMethods_AddField);

                // Allocate the string object that will be passed to the AddField method.
                int StringLength = SysStringLen(strName);
                STRINGREF strObj = AllocateString(StringLength+1);
                if (!strObj)
                    COMPlusThrowOM();

                GCPROTECT_BEGIN(strObj);
                memcpyNoGCRefs(strObj->GetBuffer(), strName, StringLength*sizeof(WCHAR));
                strObj->SetStringLength(StringLength);

                // Retrieve the COM+ object that is being exposed to COM.
                OBJECTREF TargetObj = GetReflectionObject();

                // Prepare the arguments that will be passed to AddField.
                INT64 Args[] = { 
                    ObjToInt64(TargetObj), 
                    ObjToInt64(strObj) 
                };

                // Add the field to the target expando.
                REFLECTBASEREF pMemberInfo = (REFLECTBASEREF)Int64ToObj(pMD->Call(Args));

                // Generate the DISPID for this member.
                DISPID DispID = GenerateDispID();

                // Make a copy of the member name.
                int MemberNameLen = SysStringLen(strName);
                LPWSTR strMemberName = new WCHAR[MemberNameLen + 1];
                memcpy(strMemberName, strName, MemberNameLen * sizeof(WCHAR));
                strMemberName[MemberNameLen] = 0;

                // Create a new DispatchMemberInfo that will represent this member.
                pDispMemberInfo = CreateDispatchMemberInfoInstance(DispID, strMemberName, pMemberInfo);

                // Go through the list of member info's and find the end.
                DispatchMemberInfo **ppNextMember = &m_pFirstMemberInfo;
                while (*ppNextMember)
                    ppNextMember = &((*ppNextMember)->m_pNext);

                // Add the new member info to the end of the list.
                *ppNextMember = pDispMemberInfo;

                // Add the member to the hashtable. Note, the hash is unsynchronized, but we already have our lock so
                // we're okay.
                m_DispIDToMemberInfoMap.InsertValue(DispID2HashKey(DispID), pDispMemberInfo);

                GCPROTECT_END();
            }
        }
        COMPLUS_FINALLY
        {
            // Leave the lock now that the member has been added.
            LeaveLock();
        } 
        COMPLUS_END_FINALLY
    }

    return pDispMemberInfo;
}

void DispatchExInfo::DeleteMember(DISPID DispID)
{
    _ASSERTE(GetThread()->PreemptiveGCDisabled());
    _ASSERTE(m_bSupportsExpando);

    // Take a lock before we check that the member has not already been deleted.
    EnterLock();

    // Do a lookup in the hashtable to find the DispatchMemberInfo for the DISPID.
    DispatchMemberInfo *pDispMemberInfo = SynchFindMember(DispID);

    // If the member does not exist, it is static or has been deleted then we have nothing more to do.
    if (pDispMemberInfo && (ObjectFromHandle(pDispMemberInfo->m_hndMemberInfo) != NULL))
    {
        COMPLUS_TRY
        {
            // Retrieve the DeleteMember MethodDesc.
            MethodDesc *pMD = GetIExpandoMD(IExpandoMethods_RemoveMember);

            OBJECTREF TargetObj = GetReflectionObject();
            OBJECTREF MemberInfoObj = ObjectFromHandle(pDispMemberInfo->m_hndMemberInfo);

            // Prepare the arguments that will be passed to RemoveMember.
            INT64 Args[] = { 
                ObjToInt64(TargetObj), 
                ObjToInt64(MemberInfoObj) 
            };

            // Call the DeleteMember method.
            pMD->Call(Args);
        }
        COMPLUS_CATCH
        {
        }
        COMPLUS_END_CATCH

        // Set the handle to point to NULL to indicate the member has been removed.
        StoreObjectInHandle(pDispMemberInfo->m_hndMemberInfo, NULL);
    }

    // Leave the lock now that the member has been removed.
    LeaveLock();
}

MethodDesc* DispatchExInfo::GetIReflectMD(EnumIReflectMethods Method)
{
    THROWSCOMPLUSEXCEPTION();

    // The IDs of the methods. This needs to stay in sync with the enum of 
    // methods defined in DispatchInfo.h
    static BinderMethodID aMethods[] =
    {
        METHOD__IREFLECT__GET_PROPERTIES,
        METHOD__IREFLECT__GET_FIELDS,
        METHOD__IREFLECT__GET_METHODS,
        METHOD__IREFLECT__INVOKE_MEMBER,
    };

    // If we already have retrieved the specified MD then just return it.
    if (m_apIReflectMD[Method] == NULL)
    {
    // The method desc has not been retrieved yet so find it.
        MethodDesc *pMD = g_Mscorlib.GetMethod(aMethods[Method]);

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

    // Cache the method desc.
    m_apIReflectMD[Method] = pMD;
    }

    MethodTable *pMT = m_pSimpleWrapperOwner->m_pClass->GetMethodTable();
    MethodDesc *pMD = pMT->GetMethodDescForInterfaceMethod(m_apIReflectMD[Method]);

    // Return the specified method desc.
    return pMD;
}
MethodDesc* DispatchExInfo::GetIExpandoMD(EnumIExpandoMethods Method)
{
    THROWSCOMPLUSEXCEPTION();

    // The IDs of the methods. This needs to stay in sync with the enum of 
    // methods defined in DispatchInfo.h
    static BinderMethodID aMethods[] =
    {
        METHOD__IEXPANDO__ADD_FIELD,
        METHOD__IEXPANDO__REMOVE_MEMBER,
    };

    // You should not be calling this if expando operations are not supported.
    _ASSERTE(SupportsExpando());

    // If we already have retrieved the specified MD then just return it.
    if (m_apIExpandoMD[Method] == NULL)
    {
    // The method desc has not been retrieved yet so find it.
        MethodDesc *pMD = g_Mscorlib.GetMethod(aMethods[Method]);

    // Ensure that the value types in the signature are loaded.
    MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule());

    // Cache the method desc.
    m_apIExpandoMD[Method] = pMD;
    }

    MethodTable *pMT = m_pSimpleWrapperOwner->m_pClass->GetMethodTable();
    MethodDesc *pMD = pMT->GetMethodDescForInterfaceMethod(m_apIExpandoMD[Method]);

    // Return the specified method desc.
    return pMD;
}

PTRARRAYREF DispatchExInfo::RetrievePropList()
{
    // Retrieve the GetMembers MethodDesc.
    MethodDesc *pMD = GetIReflectMD(IReflectMethods_GetProperties);

    // Retrieve the expando OBJECTREF.
    OBJECTREF TargetObj = GetReflectionObject();

    // Prepare the arguments that will be passed to the method.
    INT64 Args[] = { 
        ObjToInt64(TargetObj),
        (INT64)BINDER_DefaultLookup
    };

    // Retrieve the array of members from the expando object
    return (PTRARRAYREF)Int64ToObj(pMD->Call(Args));
}

PTRARRAYREF DispatchExInfo::RetrieveFieldList()
{
    // Retrieve the GetMembers MethodDesc.
    MethodDesc *pMD = GetIReflectMD(IReflectMethods_GetFields);

    // Retrieve the expando OBJECTREF.
    OBJECTREF TargetObj = GetReflectionObject();

    // Prepare the arguments that will be passed to the method.
    INT64 Args[] = { 
        ObjToInt64(TargetObj),
        (INT64)BINDER_DefaultLookup
    };

    // Retrieve the array of members from the expando object
    return (PTRARRAYREF)Int64ToObj(pMD->Call(Args));
}

PTRARRAYREF DispatchExInfo::RetrieveMethList()
{
    // Retrieve the GetMembers MethodDesc.
    MethodDesc *pMD = GetIReflectMD(IReflectMethods_GetMethods);

    // Retrieve the expando OBJECTREF.
    OBJECTREF TargetObj = GetReflectionObject();

    // Prepare the arguments that will be passed to the method.
    INT64 Args[] = { 
        ObjToInt64(TargetObj),
        (INT64)BINDER_DefaultLookup
    };

    // Retrieve the array of members from the expando object
    return (PTRARRAYREF)Int64ToObj(pMD->Call(Args));
}

// Virtual method to retrieve the InvokeMember method desc.
MethodDesc* DispatchExInfo::GetInvokeMemberMD()
{
    return GetIReflectMD(IReflectMethods_InvokeMember);
}

// Virtual method to retrieve the object associated with this DispatchInfo that 
// implements IReflect.
OBJECTREF DispatchExInfo::GetReflectionObject()
{
    // Runtime type is very special. Because of how it is implemented, calling methods
    // through IDispatch on a runtime type object doesn't work like other IReflect implementors
    // work. To be able to invoke methods on the runtime type, we need to invoke them
    // on the runtime type that represents runtime type. This is why for runtime type,
    // we get the exposed class object and not the actual objectred contained in the
    // wrapper.
    if (m_pComMTOwner->m_pMT == COMClass::GetRuntimeType())
        return m_pComMTOwner->m_pMT->GetClass()->GetExposedClassObject();
    else
        return m_pSimpleWrapperOwner->GetObjectRef();
}

// Virtual method to retrieve the member info map.
ComMTMemberInfoMap *DispatchExInfo::GetMemberInfoMap()
{
    // There is no member info map for IExpando objects.
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ecall.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ECALL.CPP -
//
// Handles our private native calling interface.
//

#include "common.h"
#include "vars.hpp"
#include "object.h"
#include "util.hpp"
#include "stublink.h"
#include "cgensys.h"
#include "ecall.h"
#include "excep.h"
#include "jitinterface.h"
#include "security.h"
#include "ndirect.h"
#include "COMArrayInfo.h"
#include "COMString.h"
#include "COMStringBuffer.h"
#include "COMSecurityRuntime.h"
#include "COMCodeAccessSecurityEngine.h"
#include "COMPlusWrapper.h"
#include "COMObject.h"
#include "COMClass.h"
#include "COMDelegate.h"
#include "CustomAttribute.h"
#include "COMMember.h"
#include "COMDynamic.h"
#include "COMMethodRental.h"
#include "COMNlsInfo.h"
#include "COMModule.h"
#include "COMNDirect.h"
#include "COMOAVariant.h"
#include "COMSystem.h"
#include "COMUtilNative.h"
#include "COMSynchronizable.h"
#include "COMFloatClass.h"
#include "COMX509Certificate.h"
#include "COMCryptography.h"
#include "COMStreams.h"
#include "COMVariant.h"
#include "COMDecimal.h"
#include "COMCurrency.h"
#include "COMDateTime.h"
#include "COMIsolatedStorage.h"
#include "COMSecurityConfig.h"
#include "COMPrincipal.h"
#include "COMHash.h"
#include "array.h"
#include "COMNumber.h"
#include "remoting.h"
#include "DebugDebugger.h"
#include "message.h"
#include "StackBuilderSink.h"
#include "remoting.h"
#include "ExtensibleClassFactory.h"
#include "AssemblyName.hpp"
#include "AssemblyNative.hpp"
#include "RWLock.h"
#include "COMThreadPool.h"
#include "COMWaitHandle.h"
#include "COMEvent.h"
#include "COMMutex.h"
#include "Monitor.h"
#include "NativeOverlapped.h"
#include "COMTypeLibConverter.h"
#include "JitInterface.h"
#include "ProfToEEInterfaceImpl.h"
#include "EEConfig.h"
#include "AppDomainNative.hpp"
#include "handleTablepriv.h"
#include "objecthandle.h"
#include "objecthandlenative.hpp"
#include "registration.h"
#include "coverage.h"
#include "ConfigHelper.h"
#include "COMArrayHelpers.h"

ECFunc* FindImplsForClass(MethodTable* pMT);

FCDECL0(LPVOID, GetPrivateContextsPerfCountersEx);
FCDECL0(LPVOID, GetGlobalContextsPerfCountersEx);

ArrayStubCache *ECall::m_pArrayStubCache = NULL;

// Note: if you mess these up (ie, accidentally use FCFuncElement for an ECall method),
// you'll get an access violation or similar bizarre-seeming error.  This MUST be correct.
#define ECFuncElement(A,B,C) A, B, C, NULL, CORINFO_INTRINSIC_Illegal, 0
#define FCFuncElement(A,B,C) A, B, C, NULL, CORINFO_INTRINSIC_Illegal, 1
#define FCIntrinsic(A,B,C, intrinsicID) A, B, C, NULL, intrinsicID, 1

static
ECFunc  gMarshalByRefFuncs[] =
{
    {ECFuncElement("GetComIUnknown", NULL, (LPVOID)CRemotingServices::GetComIUnknown)},
    {NULL, NULL, NULL}
};

static
ECFunc  gRemotingFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("IsTransparentProxy", &gsig_SM_Obj_RetBool, (LPVOID)CRemotingServices::IsTransparentProxy)},
    {FCFuncElement("GetRealProxy", NULL, (LPVOID)CRemotingServices::GetRealProxy)},
    {FCFuncElement("Unwrap", NULL, (LPVOID)CRemotingServices::Unwrap)},
    {FCFuncElement("AlwaysUnwrap", NULL, (LPVOID)CRemotingServices::AlwaysUnwrap)},
    {FCFuncElement("CheckCast",    NULL, (LPVOID)CRemotingServices::NativeCheckCast)},
    {FCFuncElement("nSetRemoteActivationConfigured", NULL, (LPVOID)CRemotingServices::SetRemotingConfiguredFlag)},
    {FCFuncElement("CORProfilerTrackRemoting", NULL, (LPVOID)ProfilingFCallHelper::FC_TrackRemoting)},
    {FCFuncElement("CORProfilerTrackRemotingCookie", NULL, (LPVOID)ProfilingFCallHelper::FC_TrackRemotingCookie)},
    {FCFuncElement("CORProfilerTrackRemotingAsync", NULL, (LPVOID)ProfilingFCallHelper::FC_TrackRemotingAsync)},
    {FCFuncElement("CORProfilerRemotingClientSendingMessage", NULL, (LPVOID)ProfilingFCallHelper::FC_RemotingClientSendingMessage)},
    {FCFuncElement("CORProfilerRemotingClientReceivingReply", NULL, (LPVOID)ProfilingFCallHelper::FC_RemotingClientReceivingReply)},
    {FCFuncElement("CORProfilerRemotingServerReceivingMessage", NULL, (LPVOID)ProfilingFCallHelper::FC_RemotingServerReceivingMessage)},
    {FCFuncElement("CORProfilerRemotingServerSendingReply", NULL, (LPVOID)ProfilingFCallHelper::FC_RemotingServerSendingReply)},
    {FCFuncElement("CORProfilerRemotingClientInvocationFinished", NULL, (LPVOID)ProfilingFCallHelper::FC_RemotingClientInvocationFinished)},
#ifdef REMOTING_PERF
    {FCFuncElement("LogRemotingStage",    NULL, (LPVOID)CRemotingServices::LogRemotingStage)},
#endif
#endif
    {ECFuncElement("CreateTransparentProxy", NULL, (LPVOID)CRemotingServices::CreateTransparentProxy)},
    {ECFuncElement("AllocateUninitializedObject", NULL, (LPVOID)CRemotingServices::AllocateUninitializedObject)},
    {ECFuncElement("CallDefaultCtor", NULL, (LPVOID)CRemotingServices::CallDefaultCtor)},
    {ECFuncElement("AllocateInitializedObject", NULL, (LPVOID)CRemotingServices::AllocateInitializedObject)},
    {NULL, NULL, NULL}
};

static
ECFunc  gRealProxyFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("SetStubData",        NULL, (LPVOID)CRealProxy::SetStubData)},
    {FCFuncElement("GetStubData",        NULL, (LPVOID)CRealProxy::GetStubData)},
    {FCFuncElement("GetStub",            NULL, (LPVOID)CRealProxy::GetStub)},
    {FCFuncElement("GetDefaultStub",     NULL, (LPVOID)CRealProxy::GetDefaultStub)},
#endif
    {ECFuncElement("SetStubData",        NULL, (LPVOID)CRealProxy::SetStubData)},
    {ECFuncElement("GetStubData",        NULL, (LPVOID)CRealProxy::GetStubData)},
    {ECFuncElement("GetStub",            NULL, (LPVOID)CRealProxy::GetStub)},
    {ECFuncElement("GetDefaultStub",     NULL, (LPVOID)CRealProxy::GetDefaultStub)},
    {ECFuncElement("GetProxiedType",     NULL, (LPVOID)CRealProxy::GetProxiedType)},
    {NULL, NULL, NULL}
};

static
ECFunc gContextFuncs[] =
{
    {ECFuncElement("SetupInternalContext", NULL, (LPVOID)Context::SetupInternalContext)},
    {ECFuncElement("CleanupInternalContext", NULL, (LPVOID)Context::CleanupInternalContext)},
    {ECFuncElement("ExecuteCallBackInEE", NULL, (LPVOID)Context::ExecuteCallBack)},
    {NULL, NULL, NULL, NULL}
};


static
ECFunc gRWLockFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("AcquireReaderLock", NULL, (LPVOID) CRWLock::StaticAcquireReaderLockPublic)},
    {FCFuncElement("AcquireWriterLock", NULL, (LPVOID) CRWLock::StaticAcquireWriterLockPublic)},
    {FCFuncElement("ReleaseReaderLock", NULL, (LPVOID) CRWLock::StaticReleaseReaderLockPublic)},
    {FCFuncElement("ReleaseWriterLock", NULL, (LPVOID) CRWLock::StaticReleaseWriterLockPublic)},
    {FCFuncElement("UpgradeToWriterLock", NULL, (LPVOID) CRWLock::StaticUpgradeToWriterLock)},
    {FCFuncElement("DowngradeFromWriterLock", NULL, (LPVOID) CRWLock::StaticDowngradeFromWriterLock)},
    {FCFuncElement("ReleaseLock", NULL, (LPVOID) CRWLock::StaticReleaseLock)},
    {FCFuncElement("RestoreLock", NULL, (LPVOID) CRWLock::StaticRestoreLock)},
    {FCFuncElement("PrivateGetIsReaderLockHeld", NULL, (LPVOID) CRWLock::StaticIsReaderLockHeld)},
    {FCFuncElement("PrivateGetIsWriterLockHeld", NULL, (LPVOID) CRWLock::StaticIsWriterLockHeld)},
    {FCFuncElement("PrivateGetWriterSeqNum", NULL, (LPVOID) CRWLock::StaticGetWriterSeqNum)},
    {FCFuncElement("AnyWritersSince", NULL, (LPVOID) CRWLock::StaticAnyWritersSince)},
    {FCFuncElement("PrivateInitialize", NULL, (LPVOID) CRWLock::StaticPrivateInitialize)},
#else
    {ECFuncElement("AcquireReaderLock", NULL, (LPVOID) CRWLockThunks::StaticAcquireReaderLock)},
    {ECFuncElement("AcquireWriterLock", NULL, (LPVOID) CRWLockThunks::StaticAcquireWriterLock)},
    {ECFuncElement("ReleaseReaderLock", NULL, (LPVOID) CRWLockThunks::StaticReleaseReaderLock)},
    {ECFuncElement("ReleaseWriterLock", NULL, (LPVOID) CRWLockThunks::StaticReleaseWriterLock)},
    {ECFuncElement("UpgradeToWriterLock", NULL, (LPVOID) CRWLockThunks::StaticUpgradeToWriterLock)},
    {ECFuncElement("DowngradeFromWriterLock", NULL, (LPVOID) CRWLockThunks::StaticDowngradeFromWriterLock)},
    {ECFuncElement("ReleaseLock", NULL, (LPVOID) CRWLockThunks::StaticReleaseLock)},
    {ECFuncElement("RestoreLock", NULL, (LPVOID) CRWLockThunks::StaticRestoreLock)},
    {ECFuncElement("PrivateGetIsReaderLockHeld", NULL, (LPVOID) CRWLockThunks::StaticIsReaderLockHeld)},
    {ECFuncElement("PrivateGetIsWriterLockHeld", NULL, (LPVOID) CRWLockThunks::StaticIsWriterLockHeld)},
    {ECFuncElement("PrivateGetWriterSeqNum", NULL, (LPVOID) CRWLockThunks::StaticGetWriterSeqNum)},
    {ECFuncElement("AnyWritersSince", NULL, (LPVOID) CRWLockThunks::StaticAnyWritersSince)},
    {ECFuncElement("PrivateInitialize", NULL, (LPVOID) CRWLockThunks::StaticPrivateInitialize)},
#endif // FCALLAVAILABLE
    {NULL, NULL, NULL, NULL}
};

static
ECFunc  gMessageFuncs[] =
{
    {FCFuncElement("nGetMetaSigLen",         NULL, (PVOID)   CMessage::GetMetaSigLen)},
#ifdef FCALLAVAILABLE
    {FCFuncElement("InternalGetArgCount",           NULL, (PVOID)   CMessage::GetArgCount)},
    {FCFuncElement("InternalHasVarArgs",            NULL, (PVOID)   CMessage::HasVarArgs)},
    {FCFuncElement("GetVarArgsPtr",         NULL, (PVOID)   CMessage::GetVarArgsPtr)},
#else
    {ECFuncElement("HasVarArgs",            NULL, (PVOID)   CMessage::HasVarArgs)},
    {ECFuncElement("GetVarArgsPtr",         NULL, (PVOID)   CMessage::GetVarArgsPtr)},
#endif
    {ECFuncElement("InternalGetArg",         NULL, (PVOID)  CMessage::GetArg)},
    {ECFuncElement("InternalGetArgs",        NULL, (PVOID)  CMessage::GetArgs)},
    {ECFuncElement("InternalGetMethodBase",  NULL, (PVOID)  CMessage::GetMethodBase)},
    {ECFuncElement("InternalGetMethodName",  NULL, (PVOID)  CMessage::GetMethodName)},
    {ECFuncElement("PropagateOutParameters", NULL, (PVOID)  CMessage::PropagateOutParameters)},
    {ECFuncElement("GetReturnValue",         NULL, (PVOID)  CMessage::GetReturnValue)},
    {ECFuncElement("Init",                   NULL, (PVOID)  CMessage::Init)},
    {ECFuncElement("GetAsyncBeginInfo",      NULL, (PVOID)  CMessage::GetAsyncBeginInfo)},
    {ECFuncElement("GetAsyncResult",         NULL, (PVOID)  CMessage::GetAsyncResult)},
    {ECFuncElement("GetThisPtr",             NULL, (PVOID)  CMessage::GetAsyncObject)},
    {ECFuncElement("OutToUnmanagedDebugger", NULL, (PVOID)  CMessage::DebugOut)},
    {ECFuncElement("DebugOutPtr",            NULL, (PVOID)  CMessage::DebugOutPtr)},
    {FCFuncElement("Break",                  NULL, (PVOID)  CMessage::Break)},
    {ECFuncElement("Dispatch",               NULL, (PVOID)  CMessage::Dispatch)},
    {ECFuncElement("MethodAccessCheck",      NULL, (PVOID)  CMessage::MethodAccessCheck)},
    {NULL, NULL, NULL, NULL}
};

static
ECFunc gConvertFuncs[] = {
    {FCFuncElement("ToBase64String",    NULL, (LPVOID)  BitConverter::ByteArrayToBase64String)},
    {FCFuncElement("FromBase64String",  NULL, (LPVOID)  BitConverter::Base64StringToByteArray)},
        {FCFuncElement("ToBase64CharArray",  NULL, (LPVOID)  BitConverter::ByteArrayToBase64CharArray)},
        {FCFuncElement("FromBase64CharArray",  NULL, (LPVOID)  BitConverter::Base64CharArrayToByteArray)},
        {NULL, NULL, NULL, NULL}
};



static
ECFunc  gChannelServicesFuncs[] =
{
    {FCFuncElement("GetPrivateContextsPerfCounters", NULL, (PVOID) GetPrivateContextsPerfCountersEx)},
    {FCFuncElement("GetGlobalContextsPerfCounters", NULL, (PVOID) GetGlobalContextsPerfCountersEx)},
    {NULL, NULL, NULL, NULL}
};


static
ECFunc  gCloningFuncs[] =
{
    {ECFuncElement("GetEmptyArrayForCloning", NULL, (PVOID) SystemNative::GetEmptyArrayForCloning)},
    {NULL, NULL, NULL, NULL}
};

static
ECFunc  gEnumFuncs[] =
{
    {FCFuncElement("InternalGetUnderlyingType", NULL, (LPVOID) COMMember::InternalGetEnumUnderlyingType)},
    {FCFuncElement("InternalGetValue", NULL, (LPVOID) COMMember::InternalGetEnumValue)},
    {FCFuncElement("InternalGetEnumValues", NULL, (LPVOID) COMMember::InternalGetEnumValues)},
    {FCFuncElement("InternalBoxEnumI4", NULL, (PVOID) COMMember::InternalBoxEnumI4)},
    {FCFuncElement("InternalBoxEnumU4", NULL, (PVOID) COMMember::InternalBoxEnumU4)},
    {FCFuncElement("InternalBoxEnumI8", NULL, (PVOID) COMMember::InternalBoxEnumI8)},
    {FCFuncElement("InternalBoxEnumU8", NULL, (PVOID) COMMember::InternalBoxEnumU8)},
    {NULL, NULL, NULL, NULL}
};

static
ECFunc  gStackBuilderSinkFuncs[] =
{
    {ECFuncElement("PrivateProcessMessage",  NULL, (PVOID)  CStackBuilderSink::PrivateProcessMessage)},
    {NULL, NULL, NULL, NULL}
};

#include "COMVarArgs.h"

static
ECFunc gParseNumbersFuncs[] =
{
  {FCFuncElement("IntToDecimalString", NULL, (LPVOID)ParseNumbers::IntToDecimalString)},
  {FCFuncElement("IntToString", NULL, (LPVOID)ParseNumbers::IntToString)},
  {FCFuncElement("LongToString", NULL,(LPVOID)ParseNumbers::LongToString)},
  {FCFuncElement("StringToInt", NULL, (LPVOID)ParseNumbers::StringToInt)},
  {FCFuncElement("StringToLong", NULL, (LPVOID)ParseNumbers::StringToLong)},
  {FCFuncElement("RadixStringToLong", NULL, (LPVOID)ParseNumbers::RadixStringToLong)},
  {NULL, NULL, NULL}
};

static
ECFunc gTimeZoneFuncs[] =
{
    {FCFuncElement("nativeGetTimeZoneMinuteOffset",    NULL, (LPVOID)COMNlsInfo::nativeGetTimeZoneMinuteOffset)},
    {ECFuncElement("nativeGetStandardName",             NULL, (LPVOID)COMNlsInfo::nativeGetStandardName)},
    {ECFuncElement("nativeGetDaylightName",             NULL, (LPVOID)COMNlsInfo::nativeGetDaylightName)},
    {ECFuncElement("nativeGetDaylightChanges",          NULL, (LPVOID)COMNlsInfo::nativeGetDaylightChanges)},
    {NULL, NULL, NULL}
};

static
ECFunc gGuidFuncs[] =
{
  {ECFuncElement("CompleteGuid", NULL, (LPVOID)GuidNative::CompleteGuid)},
  {NULL, NULL, NULL}
};


static
ECFunc  gObjectFuncs[] =
{
    {FCFuncElement("GetExistingType", NULL, (LPVOID) ObjectNative::GetExistingClass)},
    {FCFuncElement("FastGetExistingType", NULL, (LPVOID) ObjectNative::FastGetClass)},
    {FCFuncElement("GetHashCode", NULL, (LPVOID)ObjectNative::GetHashCode)},
    {FCFuncElement("Equals", NULL, (LPVOID)ObjectNative::Equals)},
    {ECFuncElement("InternalGetType", NULL, (LPVOID)ObjectNative::GetClass)},
    {ECFuncElement("MemberwiseClone", NULL, (LPVOID)ObjectNative::Clone)},
    {NULL, NULL, NULL}
};

static
ECFunc  gStringFuncs[] =
{
    //FastAllocateString is set dynamically and must be kept as the first element in this array.
    //The actual set is done in JitInterfacex86.cpp
#ifdef _X86_
  {FCFuncElement("FastAllocateString",    NULL,                     (LPVOID)NULL)},
#endif // _X86_
  {FCFuncElement("Equals",               &gsig_IM_Obj_RetBool,                         (LPVOID)COMString::EqualsObject)},
  {FCFuncElement("Equals",               &gsig_IM_Str_RetBool,                         (LPVOID)COMString::EqualsString)},
  {FCFuncElement("FillString",            NULL,                     (LPVOID)COMString::FillString)},
  {FCFuncElement("FillStringChecked",     NULL,                     (LPVOID)COMString::FillStringChecked)},
  {FCFuncElement("FillStringEx",          NULL,                     (LPVOID)COMString::FillStringEx)},
  {FCFuncElement("FillSubstring",         NULL,                     (LPVOID)COMString::FillSubstring)},
  {FCFuncElement("FillStringArray",       NULL,                     (LPVOID)COMString::FillStringArray)},
  {FCFuncElement("nativeCompareOrdinal",  NULL,                     (LPVOID)COMString::FCCompareOrdinal)},
  {FCFuncElement("nativeCompareOrdinalWC",NULL,                     (LPVOID)COMString::FCCompareOrdinalWC)},
  {FCFuncElement("GetHashCode",           NULL,                     (LPVOID)COMString::GetHashCode)},
  {FCIntrinsic("InternalLength",          NULL,                     (LPVOID)COMString::Length, CORINFO_INTRINSIC_StringLength)},
  {FCIntrinsic("InternalGetChar",         NULL,                     (LPVOID)COMString::GetCharAt, CORINFO_INTRINSIC_StringGetChar)},
  {FCFuncElement("CopyTo",                NULL,                     (LPVOID)COMString::GetPreallocatedCharArray)},
  {FCFuncElement("CopyToByteArray",       NULL,                     (LPVOID)COMString::InternalCopyToByteArray)},
   {FCFuncElement("InternalCopyTo",        NULL,                     (LPVOID)COMString::GetPreallocatedCharArray)},
  {FCFuncElement("IsFastSort",            NULL,                     (LPVOID)COMString::IsFastSort)},
#ifdef _DEBUG
  {FCFuncElement("ValidModifiableString", NULL,                     (LPVOID)COMString::ValidModifiableString)},
#endif
  {FCFuncElement("nativeCompareOrdinalEx",NULL,                     (LPVOID)COMString::CompareOrdinalEx)},
  {FCFuncElement("IndexOf",               &gsig_IM_Char_Int_Int_RetInt,        (LPVOID)COMString::IndexOfChar)},
  {FCFuncElement("IndexOfAny",               &gsig_IM_ArrChar_Int_Int_RetInt, (LPVOID)COMString::IndexOfCharArray)},
  {FCFuncElement("LastIndexOf",           &gsig_IM_Char_Int_Int_RetInt,        (LPVOID)COMString::LastIndexOfChar)},
  {FCFuncElement("LastIndexOfAny",           &gsig_IM_ArrChar_Int_Int_RetInt,   (LPVOID)COMString::LastIndexOfCharArray)},
  {FCFuncElement("nativeSmallCharToUpper",NULL,                     (LPVOID)COMString::SmallCharToUpper)},

  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_ArrChar_Int_Int_RetVoid,            (LPVOID)COMString::StringInitCharArray)},
  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_ArrChar_RetVoid,                    (LPVOID)COMString::StringInitChars)},
  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_PtrChar_RetVoid,                    (LPVOID)COMString::StringInitWCHARPtr)},
  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_PtrChar_Int_Int_RetVoid,            (LPVOID)COMString::StringInitWCHARPtrPartial)},
  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_PtrSByt_RetVoid,                    (LPVOID)COMString::StringInitCharPtr)},
  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_PtrSByt_Int_Int_RetVoid,            (LPVOID)COMString::StringInitCharPtrPartial)},
  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_Char_Int_RetVoid,                   (LPVOID)COMString::StringInitCharCount)},
  {FCFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_PtrSByt_Int_Int_Encoding_RetVoid,   (LPVOID)COMString::StringInitSBytPtrPartialEx)},
  {ECFuncElement("Join",                  &gsig_SM_Str_ArrStr_Int_Int_RetStr,          (LPVOID)COMString::JoinArray)},
  {ECFuncElement("Substring",             NULL,                     (LPVOID)COMString::Substring)},
  {ECFuncElement("TrimHelper",            NULL,                     (LPVOID)COMString::TrimHelper)},
  {ECFuncElement("Split",                 NULL,                     (LPVOID)COMString::Split)},
  {ECFuncElement("Remove",                NULL,                     (LPVOID)COMString::Remove)},
  {ECFuncElement("Replace",               &gsig_IM_Char_Char_RetStr, (LPVOID)COMString::Replace)},
  {ECFuncElement("Replace",               &gsig_IM_Str_Str_RetStr,  (LPVOID)COMString::ReplaceString)},
  {ECFuncElement("Insert",                NULL,                     (LPVOID)COMString::Insert)},
  {ECFuncElement("PadHelper",             NULL,                     (LPVOID)COMString::PadHelper)},
  {NULL, NULL, NULL}
};

//In order for our code that sets up the fast string allocator to work,
//FastAllocateString must always be the first method in gStringFuncs.
//Code in JitInterfacex86.cpp assigns the value to m_pImplementation after
//that code has been dynamically generated.
LPVOID *FCallFastAllocateStringImpl = &(gStringFuncs[0].m_pImplementation);

ECFunc  gStringBufferFuncs[] =
{
 {FCFuncElement("InternalGetCurrentThread", NULL, COMStringBuffer::GetCurrentThread)},
 {ECFuncElement("InternalSetCapacity",NULL, (LPVOID)COMStringBuffer::SetCapacity)},
 {ECFuncElement("Insert",&gsig_IM_Int_ArrChar_Int_Int_RetStringBuilder, (LPVOID)COMStringBuffer::InsertCharArray)},
 {ECFuncElement("Insert",&gsig_IM_Int_Str_Int_RetStringBuilder, (LPVOID)COMStringBuffer::InsertString)},
 {ECFuncElement("Remove",NULL, (LPVOID)COMStringBuffer::Remove)},
 {ECFuncElement("MakeFromString",NULL, (LPVOID)COMStringBuffer::MakeFromString)},
 {ECFuncElement("Replace", &gsig_IM_Str_Str_Int_Int_RetStringBuilder, (LPVOID)COMStringBuffer::ReplaceString)},
  {NULL, NULL, NULL}
};

static
ECFunc gValueTypeFuncs[] =
{
  {FCFuncElement("GetMethodTablePtrAsInt", NULL, (LPVOID)ValueTypeHelper::GetMethodTablePtr)},
  {FCFuncElement("CanCompareBits", NULL, (LPVOID)ValueTypeHelper::CanCompareBits)},
  {FCFuncElement("FastEqualsCheck", NULL, (LPVOID)ValueTypeHelper::FastEqualsCheck)},
  {NULL, NULL, NULL}
};

static
ECFunc gDiagnosticsDebugger[] =
{
    {ECFuncElement("BreakInternal",       NULL, (LPVOID)DebugDebugger::Break)},
    {ECFuncElement("LaunchInternal",      NULL, (LPVOID)DebugDebugger::Launch )},
    {ECFuncElement("IsDebuggerAttached",  NULL, (LPVOID)DebugDebugger::IsDebuggerAttached )}, /**/
    {ECFuncElement("Log",                 NULL, (LPVOID)DebugDebugger::Log )},
    {ECFuncElement("IsLogging",           NULL, (LPVOID)DebugDebugger::IsLogging )},
    {NULL, NULL,NULL}
};


static
ECFunc gDiagnosticsStackTrace[] =
{
    {ECFuncElement("GetStackFramesInternal",      NULL, (LPVOID)DebugStackTrace::GetStackFramesInternal )},
    {NULL, NULL,NULL}
};


static
ECFunc gDiagnosticsLog[] =
{
    {ECFuncElement("AddLogSwitch", NULL, (LPVOID)Log::AddLogSwitch)},
    {ECFuncElement("ModifyLogSwitch", NULL, (LPVOID)Log::ModifyLogSwitch)},
    {NULL, NULL,NULL}
};


static
ECFunc gDiagnosticsAssert[] =
{
    {ECFuncElement("ShowDefaultAssertDialog", NULL, (LPVOID)DebuggerAssert::ShowDefaultAssertDialog)},
    {NULL, NULL,NULL}
};


static ECFunc gEnvironmentFuncs[] =
{
     {FCFuncElement("nativeGetTickCount", NULL, (LPVOID)SystemNative::GetTickCount)},
     {ECFuncElement("ExitNative",         NULL, (LPVOID)SystemNative::Exit)},
     {ECFuncElement("nativeSetExitCode",  NULL, (LPVOID)SystemNative::SetExitCode)},
     {ECFuncElement("nativeGetExitCode",  NULL, (LPVOID)SystemNative::GetExitCode)},
     {ECFuncElement("nativeGetVersion",   NULL, (LPVOID)SystemNative::GetVersionString)},
     {FCFuncElement("nativeGetWorkingSet",NULL, (LPVOID)SystemNative::GetWorkingSet)},
     {ECFuncElement("nativeGetEnvironmentVariable",  NULL, (LPVOID)SystemNative::GetEnvironmentVariable)}, /**/
     {ECFuncElement("nativeGetEnvironmentCharArray", NULL, (LPVOID)SystemNative::GetEnvironmentCharArray)},
     {ECFuncElement("GetCommandLineArgsNative", NULL, (LPVOID)SystemNative::GetCommandLineArgs)},
     {FCFuncElement("nativeHasShutdownStarted",NULL, (LPVOID)SystemNative::HasShutdownStarted)},
     {NULL, NULL, NULL}
};

static ECFunc gRuntimeEnvironmentFuncs[] =
{
     {ECFuncElement("GetModuleFileName", NULL, (LPVOID)SystemNative::GetModuleFileName)},
     {ECFuncElement("GetDeveloperPath", NULL, (LPVOID)SystemNative::GetDeveloperPath)},
     {ECFuncElement("GetRuntimeDirectoryImpl", NULL, (LPVOID)SystemNative::GetRuntimeDirectory)},
     {ECFuncElement("GetHostBindingFile", NULL, (LPVOID)SystemNative::GetHostBindingFile)},
     {ECFuncElement("FromGlobalAccessCache", NULL, (LPVOID)SystemNative::FromGlobalAccessCache)},
     {NULL, NULL, NULL}
};

static
ECFunc gSerializationFuncs[] =
{
    {ECFuncElement("nativeGetSafeUninitializedObject", NULL, (LPVOID)COMClass::GetSafeUninitializedObject)},
    {ECFuncElement("nativeGetUninitializedObject", NULL, (LPVOID)COMClass::GetUninitializedObject)},
    {ECFuncElement("nativeGetSerializableMembers", NULL, (LPVOID)COMClass::GetSerializableMembers)},
    {FCFuncElement("GetSerializationRegistryValues", NULL, (LPVOID)COMClass::GetSerializationRegistryValues)},
    {NULL, NULL, NULL}
};

static
ECFunc gExceptionFuncs[] =
{
    {ECFuncElement("GetClassName",        NULL, (LPVOID)ExceptionNative::GetClassName)},
    {ECFuncElement("InternalGetMethod",   NULL, (LPVOID)SystemNative::CaptureStackTraceMethod)},
    {NULL, NULL, NULL}
};

static
ECFunc gFileStreamFuncs[] =
{
    {FCFuncElement("RunningOnWinNTNative",    NULL, (LPVOID)COMStreams::RunningOnWinNT)},
    {NULL, NULL, NULL}
};

static
ECFunc gPathFuncs[] =
{
    {ECFuncElement("nGetFullPathHelper",      NULL, (LPVOID)COMStreams::GetFullPathHelper)},
    {FCFuncElement("CanPathCircumventSecurityNative", NULL, (LPVOID)COMStreams::CanPathCircumventSecurity)},
    {NULL, NULL, NULL}
};

static
ECFunc gConsoleFuncs[] =
{
    {FCFuncElement("ConsoleHandleIsValidNative", NULL, (LPVOID) COMStreams::ConsoleHandleIsValid)},
    {FCFuncElement("GetConsoleCPNative", NULL, (LPVOID) COMStreams::ConsoleInputCP)}, /**/
    {FCFuncElement("GetConsoleOutputCPNative", NULL, (LPVOID) COMStreams::ConsoleOutputCP)}, /**/
    {NULL, NULL, NULL}
};


static
ECFunc gCodePageEncodingFuncs[] =
{
    {FCFuncElement("BytesToUnicodeNative",   NULL, (LPVOID)COMStreams::BytesToUnicode )},
    {FCFuncElement("UnicodeToBytesNative",   NULL, (LPVOID)COMStreams::UnicodeToBytes )},
    {ECFuncElement("GetCPMaxCharSizeNative",  NULL, (LPVOID)COMStreams::GetCPMaxCharSize )}, /**/
    {NULL, NULL, NULL}
};

static
ECFunc gMLangCodePageEncodingFuncs[] =
{
    {FCFuncElement("nativeCreateIMultiLanguage", NULL, (LPVOID)COMNlsInfo::nativeCreateIMultiLanguage)},
    {FCFuncElement("nativeReleaseIMultiLanguage", NULL, (LPVOID)COMNlsInfo::nativeReleaseIMultiLanguage)},
    {FCFuncElement("nativeIsValidMLangCodePage", NULL, (LPVOID)COMNlsInfo::nativeIsValidMLangCodePage)},
    {FCFuncElement("nativeBytesToUnicode",    NULL, (LPVOID)COMNlsInfo::nativeBytesToUnicode )},
    {FCFuncElement("nativeUnicodeToBytes",    NULL, (LPVOID)COMNlsInfo::nativeUnicodeToBytes )},
    {NULL, NULL, NULL}
};

static 
ECFunc gGB18030EncodingFuncs[] = {
    {FCFuncElement("nativeLoadGB18030DLL",    NULL, (LPVOID)COMNlsInfo::nativeLoadGB18030DLL)},
    {FCFuncElement("nativeUnloadGB18030DLL",  NULL, (LPVOID)COMNlsInfo::nativeUnloadGB18030DLL)},
    {FCFuncElement("nativeBytesToUnicode",    NULL, (LPVOID)COMNlsInfo::nativeGB18030BytesToUnicode )},
    {FCFuncElement("nativeUnicodeToBytes",    NULL, (LPVOID)COMNlsInfo::nativeGB18030UnicodeToBytes )},
    {NULL, NULL, NULL}
};

static
ECFunc gTypedReferenceFuncs[] =
{
    {ECFuncElement("ToObject",                          NULL,     (LPVOID)COMMember::TypedReferenceToObject)},
    {ECFuncElement("InternalObjectToTypedReference",    NULL,     (LPVOID)COMMember::ObjectToTypedReference)},
    {ECFuncElement("InternalMakeTypedReferences",       NULL,     (LPVOID)COMMember::MakeTypedReference)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMClassFuncs[] =
{
    {FCFuncElement("IsPrimitiveImpl",          NULL, (LPVOID) COMClass::IsPrimitive)},
    {FCFuncElement("GetAttributeFlagsImpl",    NULL, (LPVOID) COMClass::GetAttributeFlags)},
    {FCFuncElement("InternalGetTypeDefTokenHelper",  NULL, (LPVOID) COMClass::GetTypeDefToken)},
    {FCFuncElement("InternalIsContextful",     NULL, (LPVOID) COMClass::IsContextful)},
    {FCFuncElement("InternalIsMarshalByRef",   NULL, (LPVOID) COMClass::IsMarshalByRef)},
    {FCFuncElement("InternalHasProxyAttribute",   NULL, (LPVOID) COMClass::HasProxyAttribute)},
    {FCFuncElement("InternalGetTypeHandleFromObject",  NULL, (LPVOID) COMClass::GetTHFromObject)},
    {FCFuncElement("IsByRefImpl",              NULL, (LPVOID) COMClass::IsByRefImpl)},
    {FCFuncElement("IsPointerImpl",            NULL, (LPVOID) COMClass::IsPointerImpl)},
    {FCFuncElement("GetNestedTypes",           NULL, (LPVOID) COMClass::GetNestedTypes)},
    {FCFuncElement("GetNestedType",            NULL, (LPVOID) COMClass::GetNestedType)},
    {FCFuncElement("IsNestedTypeImpl",         NULL, (LPVOID) COMClass::IsNestedTypeImpl)},
    {FCFuncElement("InternalGetNestedDeclaringType",    NULL, (LPVOID) COMClass::GetNestedDeclaringType)},
    {FCFuncElement("IsCOMObjectImpl",          NULL, (LPVOID) COMClass::IsCOMObject)},
    {FCFuncElement("IsGenericCOMObjectImpl",   NULL, (LPVOID) COMClass::IsGenericCOMObject)},
    {FCFuncElement("InternalGetInterfaceMap",  NULL, (LPVOID) COMClass::GetInterfaceMap)},
    {FCFuncElement("IsSubclassOf",             NULL, (LPVOID) COMClass::IsSubClassOf)},
    {FCFuncElement("CanCastTo",                NULL, (LPVOID) COMClass::CanCastTo)}, /**/

    {ECFuncElement("GetField",                 NULL, (LPVOID) COMClass::GetField)}, /**/
    {ECFuncElement("InternalGetSuperclass",    NULL, (LPVOID) COMClass::GetSuperclass)}, /**/
    {ECFuncElement("InternalGetClassHandle",   NULL, (LPVOID) COMClass::GetClassHandle)},
    {FCFuncElement("GetTypeFromHandleImpl",    NULL, (LPVOID) COMClass::GetClassFromHandle)},
    {ECFuncElement("InternalGetName",          NULL, (LPVOID) COMClass::GetName)}, /**/
    {ECFuncElement("InternalGetProperlyQualifiedName",NULL, (LPVOID) COMClass::GetProperName)},
    {ECFuncElement("InternalGetFullName",      NULL, (LPVOID) COMClass::GetFullName)}, /**/
    {ECFuncElement("InternalGetAssemblyQualifiedName",NULL, (LPVOID) COMClass::GetAssemblyQualifiedName)},
    {ECFuncElement("InternalGetNameSpace",     NULL, (LPVOID) COMClass::GetNameSpace)},
    {ECFuncElement("InternalGetGUID",          NULL, (LPVOID) COMClass::GetGUID)},
    {ECFuncElement("IsArrayImpl",              NULL, (LPVOID) COMClass::IsArray)},
    {ECFuncElement("InvokeDispMethod",         NULL, (LPVOID) COMClass::InvokeDispMethod)},
    {ECFuncElement("GetElementType",           NULL, (LPVOID) COMClass::GetArrayElementType)},
    {ECFuncElement("GetTypeImpl",              NULL, (LPVOID) COMClass::GetClass)}, /**/
    {ECFuncElement("InvalidateCachedNestedType",NULL, (LPVOID) COMClass::InvalidateCachedNestedType)}, /**/
    {ECFuncElement("GetType",                  &gsig_SM_Str_RetType, (LPVOID) COMClass::GetClass1Arg)}, /**/
    {ECFuncElement("GetType",                  &gsig_SM_Str_Bool_RetType, (LPVOID) COMClass::GetClass2Args)}, /**/
    {ECFuncElement("GetType",                  &gsig_SM_Str_Bool_Bool_RetType, (LPVOID) COMClass::GetClass3Args)}, /**/
    {ECFuncElement("GetTypeInternal",          NULL, (LPVOID) COMClass::GetClassInternal)}, /**/
    {ECFuncElement("GetInterfaces",            NULL, (LPVOID) COMClass::GetInterfaces)},
    {ECFuncElement("GetInterface",             NULL, (LPVOID) COMClass::GetInterface)},
    {ECFuncElement("GetConstructorsInternal",  NULL, (LPVOID) COMClass::GetConstructors)},
    {ECFuncElement("GetMethods",               NULL, (LPVOID) COMClass::GetMethods)},
    {ECFuncElement("InternalGetFields",        NULL, (LPVOID) COMClass::GetFields)}, /**/
    {ECFuncElement("GetEvent",                 NULL, (LPVOID) COMClass::GetEvent)},
    {ECFuncElement("GetEvents",                NULL, (LPVOID) COMClass::GetEvents)},
    {ECFuncElement("GetProperties",            NULL, (LPVOID) COMClass::GetProperties)},
    // This one is found in COMMember because it basically a constructor method
    {ECFuncElement("CreateInstanceImpl",       NULL, (LPVOID) COMMember::CreateInstance)}, /**/
    {ECFuncElement("GetMember",                NULL, (LPVOID) COMClass::GetMember)},
    {ECFuncElement("GetMembers",               NULL, (LPVOID) COMClass::GetMembers)},
    {ECFuncElement("InternalGetModule",        NULL, (LPVOID) COMClass::GetModule)},
    {ECFuncElement("InternalGetAssembly",      NULL, (LPVOID) COMClass::GetAssembly)},
    {ECFuncElement("GetTypeFromProgIDImpl",    NULL, (LPVOID) COMClass::GetClassFromProgID)},
    {ECFuncElement("GetTypeFromCLSIDImpl",     NULL, (LPVOID) COMClass::GetClassFromCLSID)},
    {FCFuncElement("nGetMethodFromCache",      NULL, (LPVOID) COMClass::GetMethodFromCache)},
    {FCFuncElement("nAddMethodToCache",        NULL, (LPVOID) COMClass::AddMethodToCache)},
    {ECFuncElement("GetMemberMethod",          NULL, (LPVOID) COMClass::GetMemberMethods)},
    {ECFuncElement("GetMemberCons",            NULL, (LPVOID) COMClass::GetMemberCons)}, /**/
    {ECFuncElement("GetMemberField",           NULL, (LPVOID) COMClass::GetMemberField)},
    {ECFuncElement("GetMemberProperties",      NULL, (LPVOID) COMClass::GetMemberProperties)},
    {ECFuncElement("GetMatchingProperties",    NULL, (LPVOID) COMClass::GetMatchingProperties)},
    {ECFuncElement("SupportsInterface",        NULL, (LPVOID) COMClass::SupportsInterface)},
    {ECFuncElement("InternalGetArrayRank",     NULL, (LPVOID) COMClass::InternalGetArrayRank)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMMethodFuncs[] =
{
    {FCFuncElement("GetMethodHandleImpl",           NULL, (LPVOID) COMMember::GetMethodHandleImpl)},
    {FCFuncElement("GetMethodFromHandleImp",    NULL, (LPVOID) COMMember::GetMethodFromHandleImp)},
    {ECFuncElement("InternalGetName",          NULL, (LPVOID) COMMember::GetMethodName)}, /**/
    {ECFuncElement("InternalGetReturnType",    NULL, (LPVOID) COMMember::GetReturnType)},
    {ECFuncElement("InternalInvoke",           NULL, (LPVOID) COMMember::InvokeMethod)}, /**/
    //{ECFuncElement("InternalDirectInvoke",     NULL, (LPVOID) COMMember::InternalDirectInvoke)},
    {ECFuncElement("InternalToString",         NULL, (LPVOID) COMMember::GetMethodInfoToString)},

    // All of these functions are shared between both constructors and methods....
    {ECFuncElement("InternalDeclaringClass",           NULL, (LPVOID) COMMember::GetDeclaringClass)}, /**/
    {ECFuncElement("InternalReflectedClass",           NULL, (LPVOID) COMMember::GetReflectedClass)}, /**/
    {ECFuncElement("InternalGetAttributeFlags",        NULL, (LPVOID) COMMember::GetAttributeFlags)},
    {ECFuncElement("InternalGetCallingConvention",     NULL, (LPVOID) COMMember::GetCallingConvention)},
    {ECFuncElement("GetMethodImplementationFlags",     NULL, (LPVOID) COMMember::GetMethodImplFlags)},
    {ECFuncElement("InternalGetParameters",    NULL, (LPVOID) COMMember::GetParameterTypes)},
    //{ECFuncElement("GetExceptions",            NULL, (LPVOID) COMMember::GetExceptions)},
    {ECFuncElement("Equals",                   NULL, (LPVOID) COMMember::Equals)},
    {ECFuncElement("GetBaseDefinition",        NULL, (LPVOID) COMMember::GetBaseDefinition)},
    {ECFuncElement("GetParentDefinition",        NULL, (LPVOID) COMMember::GetParentDefinition)},
    {ECFuncElement("InternalGetCurrentMethod", NULL, (LPVOID) COMMember::InternalGetCurrentMethod)},
    {ECFuncElement("IsOverloadedInternal",     NULL, (LPVOID) COMMember::IsOverloaded)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMMethodHandleFuncs[] =
{
    {FCFuncElement("InternalGetFunctionPointer",        NULL, (LPVOID) COMMember::GetFunctionPointer)},
};

static
ECFunc gCOMEventFuncs[] =
{
    {ECFuncElement("InternalGetName",          NULL, (LPVOID) COMMember::GetEventName)}, /**/
    {ECFuncElement("InternalGetAttributeFlags",NULL, (LPVOID) COMMember::GetEventAttributeFlags)},
    {ECFuncElement("InternalDeclaringClass",   NULL, (LPVOID) COMMember::GetEventDeclaringClass)}, /**/
    {ECFuncElement("InternalReflectedClass",   NULL, (LPVOID) COMMember::GetReflectedClass)}, /**/
    {ECFuncElement("Equals",                   NULL, (LPVOID) COMMember::Equals)}, 
    {ECFuncElement("GetAddMethod",             NULL, (LPVOID) COMMember::GetAddMethod)},
    {ECFuncElement("GetRemoveMethod",          NULL, (LPVOID) COMMember::GetRemoveMethod)},
    {ECFuncElement("GetRaiseMethod",          NULL, (LPVOID) COMMember::GetRaiseMethod)},
    {ECFuncElement("InternalToString",         NULL, (LPVOID) COMMember::GetEventInfoToString)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMPropFuncs[] =
{
    {ECFuncElement("InternalGetName",          NULL, (LPVOID) COMMember::GetPropName)}, /**/
    {ECFuncElement("InternalGetType",          NULL, (LPVOID) COMMember::GetPropType)},
    {ECFuncElement("InternalToString",         NULL, (LPVOID) COMMember::GetPropInfoToString)},
    {ECFuncElement("InternalGetAttributeFlags",NULL, (LPVOID) COMMember::GetPropAttributeFlags)},
    {ECFuncElement("InternalDeclaringClass",   NULL, (LPVOID) COMMember::GetPropDeclaringClass)}, /**/
    {ECFuncElement("InternalReflectedClass",   NULL, (LPVOID) COMMember::GetReflectedClass)}, /**/
    {ECFuncElement("Equals",                   NULL, (LPVOID) COMMember::PropertyEquals)},
    {ECFuncElement("GetAccessors",             NULL, (LPVOID) COMMember::GetAccessors)},
    {ECFuncElement("InternalGetter",           NULL, (LPVOID) COMMember::InternalGetter)},
    {ECFuncElement("InternalSetter",           NULL, (LPVOID) COMMember::InternalSetter)},
    {ECFuncElement("InternalCanRead",          NULL, (LPVOID) COMMember::CanRead)},
    {ECFuncElement("InternalCanWrite",         NULL, (LPVOID) COMMember::CanWrite)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMDefaultBinderFuncs[] =
{
    {FCFuncElement("CanConvertPrimitive",        NULL, (LPVOID) COMMember::DBCanConvertPrimitive)},
    {FCFuncElement("CanConvertPrimitiveObjectToType", NULL, (LPVOID) COMMember::DBCanConvertObjectPrimitive)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMConstructorFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("GetMethodHandleImpl",           NULL, (LPVOID) COMMember::GetMethodHandleImpl)},
#endif

    {ECFuncElement("InternalInvoke",               NULL, (LPVOID) COMMember::InvokeCons)}, /**/
    {ECFuncElement("InternalInvokeNoAllocation",   NULL, (LPVOID) COMMember::InvokeMethod)},
    {ECFuncElement("SerializationInvoke",          NULL, (LPVOID) COMMember::SerializationInvoke)},
    // All of these functions are shared between both constructors and methods....
    {ECFuncElement("InternalDeclaringClass",       NULL, (LPVOID) COMMember::GetDeclaringClass)}, /**/
    {ECFuncElement("InternalReflectedClass",       NULL, (LPVOID) COMMember::GetReflectedClass)}, /**/
    {ECFuncElement("InternalToString",             NULL, (LPVOID) COMMember::GetMethodInfoToString)},
    {ECFuncElement("InternalGetAttributeFlags",    NULL, (LPVOID) COMMember::GetAttributeFlags)},
    {ECFuncElement("GetMethodImplementationFlags", NULL, (LPVOID) COMMember::GetMethodImplFlags)},
    {ECFuncElement("GetParameters",            NULL, (LPVOID) COMMember::GetParameterTypes)}, /**/
    {ECFuncElement("InternalGetCallingConvention",     NULL, (LPVOID) COMMember::GetCallingConvention)},
   //{ECFuncElement("GetExceptions",            NULL, (LPVOID) COMMember::GetExceptions)},
    {ECFuncElement("Equals",                   NULL, (LPVOID) COMMember::Equals)},
    {ECFuncElement("InternalGetName",          NULL, (LPVOID) COMMember::GetMethodName)}, /**/
    {ECFuncElement("IsOverloadedInternal",     NULL, (LPVOID) COMMember::IsOverloaded)},
    {ECFuncElement("HasLinktimeDemand",            NULL, (LPVOID) COMMember::HasLinktimeDemand)},
   {NULL, NULL, NULL}
};

static
ECFunc gCOMFieldFuncs[] =
{
    {FCFuncElement("GetFieldHandleImpl",        NULL, (LPVOID) COMMember::GetFieldHandleImpl)},
    {FCFuncElement("GetFieldFromHandleImp",     NULL, (LPVOID) COMMember::GetFieldFromHandleImp)},

    {ECFuncElement("SetValueDirectImpl",       NULL, (LPVOID) COMMember::DirectFieldSet)},
    {ECFuncElement("GetValueDirectImpl",       NULL, (LPVOID) COMMember::DirectFieldGet)},
    {ECFuncElement("InternalGetName",          NULL, (LPVOID) COMMember::GetFieldName)}, /**/
    {ECFuncElement("InternalToString",         NULL, (LPVOID) COMMember::GetFieldInfoToString)},
    {ECFuncElement("InternalDeclaringClass",   NULL, (LPVOID) COMMember::GetFieldDeclaringClass)}, /**/
    {ECFuncElement("InternalReflectedClass",   NULL, (LPVOID) COMMember::GetReflectedClass)}, /**/
    {ECFuncElement("InternalGetSignature",     NULL, (LPVOID) COMMember::GetFieldSignature)},
    {ECFuncElement("InternalGetFieldType",     NULL, (LPVOID) COMMember::GetFieldType)}, /**/
    {ECFuncElement("InternalGetAttributeFlags",NULL, (LPVOID) COMMember::GetAttributeFlags)},
    {ECFuncElement("InternalGetValue",         NULL, (LPVOID) COMMember::FieldGet)}, /**/
    {ECFuncElement("InternalSetValue",         NULL, (LPVOID) COMMember::FieldSet)}, /**/
    {NULL, NULL, NULL}
};

static
ECFunc gCOMModuleFuncs[] =
{
    {ECFuncElement("IsDynamic",              NULL, (LPVOID) COMModule::IsDynamic)},
    {ECFuncElement("InternalGetTypeToken",   NULL, (LPVOID) COMModule::GetClassToken)},
    {ECFuncElement("InternalGetTypeSpecToken", NULL, (LPVOID) COMModule::GetTypeSpecToken)},
    {ECFuncElement("InternalGetTypeSpecTokenWithBytes", NULL, (LPVOID) COMModule::GetTypeSpecTokenWithBytes)},
    {ECFuncElement("InternalGetMemberRef", NULL, (LPVOID) COMModule::GetMemberRefToken)},
    {ECFuncElement("InternalGetMemberRefOfMethodInfo", NULL, (LPVOID) COMModule::GetMemberRefTokenOfMethodInfo)},
    {ECFuncElement("InternalGetMemberRefOfFieldInfo", NULL, (LPVOID) COMModule::GetMemberRefTokenOfFieldInfo)},
    {ECFuncElement("InternalGetMemberRefFromSignature", NULL, (LPVOID) COMModule::GetMemberRefTokenFromSignature)},
    {ECFuncElement("InternalSetFieldRVAContent", NULL, (LPVOID) COMModule::SetFieldRVAContent)},
    {ECFuncElement("InternalLoadInMemoryTypeByName",        NULL, (LPVOID) COMModule::LoadInMemoryTypeByName)},
    {ECFuncElement("nativeGetArrayMethodToken",    NULL, (LPVOID) COMModule::GetArrayMethodToken)},
    {ECFuncElement("pGetCaller",             NULL, (LPVOID) COMModule::GetCaller)},
    {ECFuncElement("GetTypeInternal",        NULL, (LPVOID) COMModule::GetClass)},
    {ECFuncElement("InternalGetName",        NULL, (LPVOID) COMModule::GetName)}, /**/
    {ECFuncElement("GetTypesInternal",       NULL, (LPVOID) COMModule::GetClasses)},
    {ECFuncElement("InternalGetStringConstant",NULL, (LPVOID) COMModule::GetStringConstant)},
    {ECFuncElement("GetSignerCertificate",   NULL, (LPVOID) COMModule::GetSignerCertificate)},
    {ECFuncElement("InternalPreSavePEFile",  NULL, (LPVOID) COMDynamicWrite::PreSavePEFile)},
    {ECFuncElement("InternalSavePEFile",     NULL, (LPVOID) COMDynamicWrite::SavePEFile)},
    {ECFuncElement("InternalAddResource",    NULL, (LPVOID) COMDynamicWrite::AddResource)},
    {ECFuncElement("InternalSetResourceCounts",         NULL, (LPVOID) COMDynamicWrite::SetResourceCounts)},
    {ECFuncElement("InternalSetModuleProps",  NULL, (LPVOID) COMModule::SetModuleProps)},
    {ECFuncElement("InteralGetFullyQualifiedName",  NULL, (LPVOID) COMModule::GetFullyQualifiedName)},
    {ECFuncElement("GetHINSTANCE",           NULL, (LPVOID) COMModule::GetHINST)},
    {ECFuncElement("nGetAssembly",           NULL, (LPVOID) COMModule::GetAssembly)},
    {ECFuncElement("GetMethods",             NULL, (LPVOID) COMModule::GetMethods)},
    {ECFuncElement("InternalGetMethod",      NULL, (LPVOID) COMModule::InternalGetMethod)},
    {FCFuncElement("GetFields",             NULL, (LPVOID) COMModule::GetFields)},
    {FCFuncElement("InternalGetField",       NULL, (LPVOID) COMModule::GetField)},
    {ECFuncElement("InternalDefineNativeResourceFile", NULL, (LPVOID) COMDynamicWrite::DefineNativeResourceFile)},
    {ECFuncElement("InternalDefineNativeResourceBytes", NULL, (LPVOID) COMDynamicWrite::DefineNativeResourceBytes)},
    {ECFuncElement("IsResource",           NULL, (LPVOID) COMModule::IsResource)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMCustomAttributeFuncs[] =
{
    {FCFuncElement("GetMemberToken",            NULL, (LPVOID) COMCustomAttribute::GetMemberToken)},
    {FCFuncElement("GetMemberModule",           NULL, (LPVOID) COMCustomAttribute::GetMemberModule)},
    {FCFuncElement("GetAssemblyToken",          NULL, (LPVOID) COMCustomAttribute::GetAssemblyToken)},
    {FCFuncElement("GetAssemblyModule",         NULL, (LPVOID) COMCustomAttribute::GetAssemblyModule)},
    {FCFuncElement("GetModuleToken",            NULL, (LPVOID) COMCustomAttribute::GetModuleToken)},
    {FCFuncElement("GetModuleModule",           NULL, (LPVOID) COMCustomAttribute::GetModuleModule)},
    {FCFuncElement("GetMethodRetValueToken",    NULL, (LPVOID) COMCustomAttribute::GetMethodRetValueToken)},
    {ECFuncElement("IsCADefined",               NULL, (LPVOID) COMCustomAttribute::IsCADefined)},
    {ECFuncElement("GetCustomAttributeList",    NULL, (LPVOID) COMCustomAttribute::GetCustomAttributeList)},
    {ECFuncElement("CreateCAObject",            NULL, (LPVOID) COMCustomAttribute::CreateCAObject)},
    {ECFuncElement("GetDataForPropertyOrField", NULL, (LPVOID) COMCustomAttribute::GetDataForPropertyOrField)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMClassWriter[] =
{
    {ECFuncElement("InternalDefineClass",     NULL, (LPVOID) COMDynamicWrite::CWCreateClass)},
    {ECFuncElement("InternalSetParentType",   NULL, (LPVOID) COMDynamicWrite::CWSetParentType)},
    {ECFuncElement("InternalAddInterfaceImpl",NULL, (LPVOID) COMDynamicWrite::CWAddInterfaceImpl)},
    {ECFuncElement("InternalDefineMethod",    NULL, (LPVOID) COMDynamicWrite::CWCreateMethod)},
    {ECFuncElement("InternalSetMethodIL",     NULL, (LPVOID) COMDynamicWrite::CWSetMethodIL)},
    {ECFuncElement("TermCreateClass",         NULL, (LPVOID) COMDynamicWrite::CWTermCreateClass)},
    {ECFuncElement("InternalDefineField",     NULL, (LPVOID) COMDynamicWrite::CWCreateField)},
    {ECFuncElement("InternalSetPInvokeData",  NULL, (LPVOID) COMDynamicWrite::InternalSetPInvokeData)},
    {ECFuncElement("InternalDefineProperty",  NULL, (LPVOID) COMDynamicWrite::CWDefineProperty)},
    {ECFuncElement("InternalDefineEvent",     NULL, (LPVOID) COMDynamicWrite::CWDefineEvent)},
    {ECFuncElement("InternalDefineMethodSemantics",     NULL, (LPVOID) COMDynamicWrite::CWDefineMethodSemantics)},
    {ECFuncElement("InternalSetMethodImpl",   NULL, (LPVOID) COMDynamicWrite::CWSetMethodImpl)},
    {ECFuncElement("InternalDefineMethodImpl",   NULL, (LPVOID) COMDynamicWrite::CWDefineMethodImpl)},
    {ECFuncElement("InternalGetTokenFromSig", NULL, (LPVOID) COMDynamicWrite::CWGetTokenFromSig)},
    {ECFuncElement("InternalSetFieldOffset",  NULL, (LPVOID) COMDynamicWrite::CWSetFieldLayoutOffset)},
    {ECFuncElement("InternalSetClassLayout",  NULL, (LPVOID) COMDynamicWrite::CWSetClassLayout)},
    {ECFuncElement("InternalSetParamInfo",    NULL, (LPVOID) COMDynamicWrite::CWSetParamInfo)},
    {ECFuncElement("InternalSetMarshalInfo",    NULL, (LPVOID) COMDynamicWrite::CWSetMarshal)},
    {ECFuncElement("InternalSetConstantValue",    NULL, (LPVOID) COMDynamicWrite::CWSetConstantValue)},
    {ECFuncElement("InternalCreateCustomAttribute",  NULL, (LPVOID) COMDynamicWrite::CWInternalCreateCustomAttribute)},
    {ECFuncElement("InternalAddDeclarativeSecurity",  NULL, (LPVOID) COMDynamicWrite::CWAddDeclarativeSecurity)},
    {NULL, NULL, NULL}
};


static
ECFunc gCOMMethodRental[] =
{
    {ECFuncElement("SwapMethodBodyHelper",     NULL, (LPVOID) COMMethodRental::SwapMethodBody)},
    {NULL, NULL, NULL}
};


static
ECFunc gCOMCodeAccessSecurityEngineFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("IncrementOverridesCount", NULL, (LPVOID)Security::IncrementOverridesCount)},
    {FCFuncElement("DecrementOverridesCount", NULL, (LPVOID)Security::DecrementOverridesCount)},
    {FCFuncElement("GetDomainPermissionListSet", NULL, (LPVOID)ApplicationSecurityDescriptor::GetDomainPermissionListSet)},
    {FCFuncElement("UpdateDomainPermissionListSet", NULL, (LPVOID)ApplicationSecurityDescriptor::UpdateDomainPermissionListSet)},
    {FCFuncElement("UpdateOverridesCount", NULL, (LPVOID)COMCodeAccessSecurityEngine::UpdateOverridesCount)},
    {FCFuncElement("GetResult", NULL, (LPVOID)COMCodeAccessSecurityEngine::GetResult)},
    {FCFuncElement("SetResult", NULL, (LPVOID)COMCodeAccessSecurityEngine::SetResult)},
    {FCFuncElement("ReleaseDelayedCompressedStack", NULL, (LPVOID)COMCodeAccessSecurityEngine::FcallReleaseDelayedCompressedStack)},
#endif
    {ECFuncElement("Check", NULL, (LPVOID)COMCodeAccessSecurityEngine::Check)},
    {ECFuncElement("CheckSet",  NULL, (LPVOID)COMCodeAccessSecurityEngine::CheckSet)},
    {ECFuncElement("CheckNReturnSO", NULL, (LPVOID)COMCodeAccessSecurityEngine::CheckNReturnSO)},
    {ECFuncElement("GetPermissionsP", NULL, (LPVOID)COMCodeAccessSecurityEngine::GetPermissionsP)},
    {ECFuncElement("_GetGrantedPermissionSet", NULL, (LPVOID)COMCodeAccessSecurityEngine::GetGrantedPermissionSet)},
    {ECFuncElement("GetCompressedStackN", NULL, (LPVOID)COMCodeAccessSecurityEngine::EcallGetCompressedStack)}, /**/
    {ECFuncElement("GetDelayedCompressedStack", NULL, (LPVOID)COMCodeAccessSecurityEngine::EcallGetDelayedCompressedStack)}, /**/
    {ECFuncElement("InitSecurityEngine", NULL, (LPVOID)COMCodeAccessSecurityEngine::InitSecurityEngine)},
    {ECFuncElement("GetZoneAndOriginInternal", NULL, (LPVOID)COMCodeAccessSecurityEngine::GetZoneAndOrigin)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMSecurityManagerFuncs[] =
{
    {ECFuncElement("_IsSecurityOn", NULL, (LPVOID)Security::IsSecurityOnNative)},
    {ECFuncElement("GetGlobalFlags", NULL, (LPVOID)Security::GetGlobalSecurity)},
    {ECFuncElement("SetGlobalFlags", NULL, (LPVOID)Security::SetGlobalSecurity)},
    {ECFuncElement("SaveGlobalFlags", NULL, (LPVOID)Security::SaveGlobalSecurity)},
    {ECFuncElement("Log", NULL, (LPVOID)Security::Log)},
    {ECFuncElement("_GetGrantedPermissions", NULL, (LPVOID)Security::GetGrantedPermissions)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMSecurityZone[] =
{
    {ECFuncElement("_CreateFromUrl", NULL, (LPVOID)Security::CreateFromUrl)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMFileIOAccessFuncs[] =
{
    {ECFuncElement("_LocalDrive", NULL, (LPVOID)Security::LocalDrive)},
    {NULL, NULL, NULL}
};

static
ECFunc gCOMStringExpressionSetFuncs[] =
{
    {ECFuncElement("GetLongPathName", NULL, (LPVOID)Security::EcallGetLongPathName)},
    {NULL, NULL, NULL}
};


static
ECFunc gCOMUrlStringFuncs[] =
{
    {ECFuncElement("_GetDeviceName", NULL, (LPVOID)Security::GetDeviceName)},
    {NULL, NULL, NULL}
};



static
ECFunc gCOMSecurityRuntimeFuncs[] =
{
    {ECFuncElement("GetSecurityObjectForFrame", NULL, (LPVOID)COMSecurityRuntime::GetSecurityObjectForFrame)}, /**/
    {ECFuncElement("SetSecurityObjectForFrame", NULL, (LPVOID)COMSecurityRuntime::SetSecurityObjectForFrame)},
    {ECFuncElement("GetDeclaredPermissionsP", &gsig_IM_Obj_Int_RetPMS, (LPVOID)COMSecurityRuntime::GetDeclaredPermissionsP)},
    {ECFuncElement("InitSecurityRuntime", NULL, (LPVOID)COMSecurityRuntime::InitSecurityRuntime)},
    {NULL, NULL, NULL}
};

static
ECFunc gX509CertificateFuncs[] =
{
    {ECFuncElement("SetX509Certificate", NULL, (LPVOID)COMX509Certificate::SetX509Certificate)},
    {ECFuncElement("BuildFromContext", NULL, (LPVOID)COMX509Certificate::BuildFromContext)},
    {ECFuncElement("_GetPublisher", NULL, (LPVOID)COMX509Certificate::GetPublisher)},
    {NULL,
     NULL,
     NULL}
};

static ECFunc gBCLDebugFuncs[] =
{
    {FCFuncElement("GetRegistryValue", NULL, (LPVOID)ManagedLoggingHelper::GetRegistryLoggingValues )},
    {NULL, NULL, NULL}
};

static
ECFunc gCryptographicFuncs[] =
{
    {ECFuncElement("_AcquireCSP", NULL, (LPVOID) COMCryptography::_AcquireCSP)},
    {ECFuncElement("_CryptDeriveKey", NULL, (LPVOID) COMCryptography::_CryptDeriveKey)},
    {ECFuncElement("_CreateCSP", NULL, (LPVOID) COMCryptography::_CreateCSP)},
    {ECFuncElement("_CreateHash", NULL, (LPVOID) COMCryptography::_CreateHash)},
    {ECFuncElement("_DecryptData", NULL, (LPVOID) COMCryptography::_DecryptData)},
    {ECFuncElement("_DecryptKey", NULL, (LPVOID) COMCryptography::_DecryptKey)},
    {ECFuncElement("_DecryptPKWin2KEnh", NULL, (LPVOID) COMCryptography::_DecryptPKWin2KEnh)},
    {ECFuncElement("_DeleteKeyContainer", NULL, (LPVOID) COMCryptography::_DeleteKeyContainer)},
    {ECFuncElement("_DuplicateKey", NULL, (LPVOID) COMCryptography::_DuplicateKey)},
    {ECFuncElement("_EncryptData", NULL, (LPVOID) COMCryptography::_EncryptData)},
    {ECFuncElement("_EncryptKey", NULL, (LPVOID) COMCryptography::_EncryptKey)},
    {ECFuncElement("_EncryptPKWin2KEnh", NULL, (LPVOID) COMCryptography::_EncryptPKWin2KEnh)},
    {ECFuncElement("_EndHash", NULL, (LPVOID) COMCryptography::_EndHash)},
    {ECFuncElement("_ExportKey", NULL, (LPVOID) COMCryptography::_ExportKey)},
    {ECFuncElement("_FreeCSP", NULL, (LPVOID) COMCryptography::_FreeCSP)},
    {ECFuncElement("_FreeHash", NULL, (LPVOID) COMCryptography::_FreeHash)},
    {ECFuncElement("_FreeHKey", NULL, (LPVOID) COMCryptography::_FreeHKey)},
    {ECFuncElement("_GenerateKey", NULL, (LPVOID) COMCryptography::_GenerateKey)},
    {ECFuncElement("_GetBytes", NULL, (LPVOID) COMCryptography::_GetBytes)},
    {ECFuncElement("_GetKeyParameter", NULL, (LPVOID) COMCryptography::_GetKeyParameter)},
    {ECFuncElement("_GetNonZeroBytes", NULL, (LPVOID) COMCryptography::_GetNonZeroBytes)},
    {ECFuncElement("_GetUserKey", NULL, (LPVOID) COMCryptography::_GetUserKey)},
    {ECFuncElement("_HashData", NULL, (LPVOID) COMCryptography::_HashData)},
    {ECFuncElement("_ImportBulkKey", NULL, (LPVOID) COMCryptography::_ImportBulkKey)},
    {ECFuncElement("_ImportKey", NULL, (LPVOID) COMCryptography::_ImportKey)},
    {ECFuncElement("_SearchForAlgorithm", NULL, (LPVOID) COMCryptography::_SearchForAlgorithm)},
    {ECFuncElement("_SetKeyParamDw", NULL, (LPVOID) COMCryptography::_SetKeyParamDw)},
    {ECFuncElement("_SetKeyParamRgb", NULL, (LPVOID) COMCryptography::_SetKeyParamRgb)},
    {ECFuncElement("_SignValue", NULL, (LPVOID) COMCryptography::_SignValue)},
    {ECFuncElement("_VerifySign", NULL, (LPVOID) COMCryptography::_VerifySign)},
    {NULL, NULL, NULL}
};

#ifdef RSA_NATIVE
static
ECFunc gRSANativeFuncs[] =
{
    {ECFuncElement("_ApplyPrivateKey", NULL, (LPVOID) RSANative::_ApplyPrivateKey)},
    {ECFuncElement("_ApplyPublicKey", NULL, (LPVOID) RSANative::_ApplyPublicKey)},
    {ECFuncElement("_GenerateKey", NULL, (LPVOID) RSANative::_GenerateKey)},
};
#endif // RSA_NATIVE

static
ECFunc gAppDomainSetupFuncs[] =
{
    {ECFuncElement("UpdateContextProperty",    NULL, (LPVOID)AppDomainNative::UpdateContextProperty)},
    {NULL, NULL, NULL}
};

static
ECFunc gAppDomainFuncs[] =
{
    
    {ECFuncElement("CreateBasicDomain",    NULL, (LPVOID)AppDomainNative::CreateBasicDomain)},
    {ECFuncElement("SetupDomainSecurity",    NULL, (LPVOID)AppDomainNative::SetupDomainSecurity)},
    {ECFuncElement("GetSecurityDescriptor",    NULL, (LPVOID)AppDomainNative::GetSecurityDescriptor)},
    {ECFuncElement("GetFusionContext",    NULL, (LPVOID)AppDomainNative::GetFusionContext)},
    {ECFuncElement("UpdateLoaderOptimization",    NULL, (LPVOID)AppDomainNative::UpdateLoaderOptimization)},
    {ECFuncElement("nGetFriendlyName",  NULL, (LPVOID)AppDomainNative::GetFriendlyName)},
    {ECFuncElement("GetAssemblies",    NULL, (LPVOID)AppDomainNative::GetAssemblies)},
    {ECFuncElement("nCreateDynamicAssembly", NULL, (LPVOID)AppDomainNative::CreateDynamicAssembly)},
    {ECFuncElement("nExecuteAssembly",       NULL, (LPVOID)AppDomainNative::ExecuteAssembly)},
    {ECFuncElement("nUnload",      NULL, (LPVOID)AppDomainNative::Unload)},
    {ECFuncElement("GetDefaultDomain", NULL, (LPVOID)AppDomainNative::GetDefaultDomain)},
    {ECFuncElement("GetId", NULL, (LPVOID)AppDomainNative::GetId)},
    {ECFuncElement("nForcePolicyResolution", NULL, (LPVOID)AppDomainNative::ForcePolicyResolution)},
    {ECFuncElement("IsStringInterned",  NULL, (LPVOID)AppDomainNative::IsStringInterned)},
    {ECFuncElement("GetOrInternString", NULL, (LPVOID)AppDomainNative::GetOrInternString)},
    {ECFuncElement("GetDynamicDir", NULL, (LPVOID)AppDomainNative::GetDynamicDir)},
    {ECFuncElement("nForceResolve", NULL, (LPVOID)AppDomainNative::ForceResolve)},
    {ECFuncElement("IsTypeUnloading", NULL, (LPVOID)AppDomainNative::IsTypeUnloading)},
    {ECFuncElement("nGetGrantSet", NULL, (LPVOID)AppDomainNative::GetGrantSet)},
    {ECFuncElement("GetIdForUnload", NULL, (LPVOID)AppDomainNative::GetIdForUnload)},
    {ECFuncElement("IsDomainIdValid", NULL, (LPVOID)AppDomainNative::IsDomainIdValid)},
    {ECFuncElement("GetUnloadWorker", NULL, (LPVOID)AppDomainNative::GetUnloadWorker)},
    {ECFuncElement("IsUnloadingForcedFinalize", NULL, (LPVOID)AppDomainNative::IsUnloadingForcedFinalize)},
    {ECFuncElement("IsFinalizingForUnload", NULL, (LPVOID)AppDomainNative::IsFinalizingForUnload)},
    {NULL, NULL, NULL}
};

static
ECFunc gAssemblyFuncs[] =
{
    {ECFuncElement("nLoad",            NULL, (LPVOID)AssemblyNative::Load)}, /**/
    {ECFuncElement("nLoadImage",       NULL, (LPVOID)AssemblyNative::LoadImage)},
    {ECFuncElement("nLoadFile",        NULL, (LPVOID)AssemblyNative::LoadFile)},
    {ECFuncElement("nLoadModule",      NULL, (LPVOID)AssemblyNative::LoadModuleImage)},
    {ECFuncElement("GetType",          &gsig_IM_Str_RetType, (LPVOID) AssemblyNative::GetType1Args)}, /**/
    {ECFuncElement("GetType",          &gsig_IM_Str_Bool_RetType, (LPVOID) AssemblyNative::GetType2Args)}, /**/
    {ECFuncElement("GetType",          &gsig_IM_Str_Bool_Bool_RetType, (LPVOID) AssemblyNative::GetType3Args)}, /**/
    {ECFuncElement("GetTypeInternal",  NULL, (LPVOID) AssemblyNative::GetTypeInternal)}, /**/
    {ECFuncElement("ParseTypeName",    NULL, (LPVOID) AssemblyNative::ParseTypeName)}, /**/
    {ECFuncElement("nGetVersion",      NULL, (LPVOID)AssemblyNative::GetVersion)},
    {ECFuncElement("nGetSimpleName",   NULL, (LPVOID)AssemblyNative::GetSimpleName)},
    {ECFuncElement("nGetPublicKey",    NULL, (LPVOID)AssemblyNative::GetPublicKey)},
    {ECFuncElement("nGetLocale",       NULL, (LPVOID)AssemblyNative::GetLocale)},
    {ECFuncElement("nGetCodeBase",     NULL, (LPVOID)AssemblyNative::GetCodeBase)},
    {ECFuncElement("nGetHashAlgorithm", NULL, (LPVOID)AssemblyNative::GetHashAlgorithm)},
    {ECFuncElement("nGetFlags",        NULL, (LPVOID)AssemblyNative::GetFlags)},
    {ECFuncElement("GetResource",      NULL, (LPVOID)AssemblyNative::GetResource)},
    {ECFuncElement("nGetManifestResourceInfo",     NULL, (LPVOID)AssemblyNative::GetManifestResourceInfo)},
    {ECFuncElement("nGetModules",       NULL, (LPVOID)AssemblyNative::GetModules)},
    {ECFuncElement("GetModule",       NULL, (LPVOID)AssemblyNative::GetModule)},
    {ECFuncElement("GetReferencedAssemblies",       NULL, (LPVOID)AssemblyNative::GetReferencedAssemblies)},
    {ECFuncElement("GetExportedTypes",   NULL, (LPVOID)AssemblyNative::GetExportedTypes)},
    {ECFuncElement("nGetManifestResourceNames", NULL, (LPVOID)AssemblyNative::GetResourceNames)},
    {ECFuncElement("nDefineDynamicModule", NULL, (LPVOID)COMModule::DefineDynamicModule)},
    {ECFuncElement("nPrepareForSavingManifestToDisk", NULL, (LPVOID)AssemblyNative::PrepareSavingManifest)},
    {ECFuncElement("nSaveToFileList", NULL, (LPVOID)AssemblyNative::AddFileList)},
    {ECFuncElement("nSetHashValue", NULL, (LPVOID)AssemblyNative::SetHashValue)},
    {ECFuncElement("nSaveExportedType", NULL, (LPVOID)AssemblyNative::AddExportedType)},
    {ECFuncElement("nAddStandAloneResource", NULL, (LPVOID)AssemblyNative::AddStandAloneResource)},
    {ECFuncElement("nSavePermissionRequests", NULL, (LPVOID)AssemblyNative::SavePermissionRequests)},
    {ECFuncElement("nSaveManifestToDisk", NULL, (LPVOID)AssemblyNative::SaveManifestToDisk)},
    {ECFuncElement("nAddFileToInMemoryFileList", NULL, (LPVOID)AssemblyNative::AddFileToInMemoryFileList)},
    {ECFuncElement("GetFullName", NULL, (LPVOID)AssemblyNative::GetStringizedName)},
    {ECFuncElement("nGetEntryPoint", NULL, (LPVOID)AssemblyNative::GetEntryPoint)},
    {ECFuncElement("nGetExecutingAssembly",      NULL, (LPVOID)AssemblyNative::GetExecutingAssembly)},
    {ECFuncElement("GetEntryAssembly",      NULL, (LPVOID)AssemblyNative::GetEntryAssembly)},
    {ECFuncElement("CreateQualifiedName", NULL, (LPVOID)AssemblyNative::CreateQualifiedName)},
    {ECFuncElement("nForceResolve", NULL, (LPVOID)AssemblyNative::ForceResolve)},
    {ECFuncElement("nGetGrantSet", NULL, (LPVOID)AssemblyNative::GetGrantSet)},
    {ECFuncElement("nGetOnDiskAssemblyModule", NULL, (LPVOID)AssemblyNative::GetOnDiskAssemblyModule)},
    {ECFuncElement("nGetInMemoryAssemblyModule", NULL, (LPVOID)AssemblyNative::GetInMemoryAssemblyModule)},
    {ECFuncElement("nGetEvidence", NULL, (LPVOID)Security::GetEvidence)},
    {ECFuncElement("GetLocation", NULL, (LPVOID)AssemblyNative::GetLocation)},
    {ECFuncElement("nDefineVersionInfoResource", NULL, (LPVOID)AssemblyNative::DefineVersionInfoResource)},
    {ECFuncElement("nGetExportedTypeLibGuid",     NULL, (LPVOID)AssemblyNative::GetExportedTypeLibGuid)},
    {ECFuncElement("nGlobalAssemblyCache", NULL, (LPVOID)AssemblyNative::GlobalAssemblyCache)},
    {ECFuncElement("nGetImageRuntimeVersion", NULL, (LPVOID)AssemblyNative::GetImageRuntimeVersion)},
    {NULL, NULL, NULL}
};

static
ECFunc gAssemblyNameFuncs[] =
{
    {ECFuncElement("nGetFileInformation", NULL, (LPVOID)AssemblyNameNative::GetFileInformation)},
    {ECFuncElement("nToString", NULL, (LPVOID)AssemblyNameNative::ToString)},
    {ECFuncElement("nGetPublicKeyToken", NULL, (LPVOID)AssemblyNameNative::GetPublicKeyToken)},
    {ECFuncElement("EscapeCodeBase", NULL, (LPVOID)AssemblyNameNative::EscapeCodeBase)},
   {NULL, NULL, NULL}
};

static
ECFunc gCharacterFuncs[] =
{
    {ECFuncElement("ToString", NULL, (LPVOID)COMCharacter::ToString)},
    {NULL, NULL, NULL}
};

static
ECFunc gDelegateFuncs[] =
{
    {ECFuncElement("InternalCreate", NULL, (LPVOID) COMDelegate::InternalCreate)}, /**/
    {ECFuncElement("InternalCreateStatic", NULL, (LPVOID) COMDelegate::InternalCreateStatic)},
    {ECFuncElement("InternalAlloc",  NULL, (LPVOID) COMDelegate::InternalAlloc)},
    {ECFuncElement("InternalCreateMethod", NULL, (LPVOID) COMDelegate::InternalCreateMethod)},
    {ECFuncElement("InternalFindMethodInfo", NULL, (LPVOID) COMDelegate::InternalFindMethodInfo)},
    {NULL, NULL, NULL}
};


static
ECFunc gFloatFuncs[] =
{
    {FCFuncElement("IsPositiveInfinity", NULL, (LPVOID)COMFloat::IsPositiveInfinity)},
    {FCFuncElement("IsNegativeInfinity", NULL, (LPVOID)COMFloat::IsNegativeInfinity)},
    {FCFuncElement("IsInfinity", NULL, (LPVOID)COMFloat::IsInfinity)},
    {NULL, NULL, NULL}
};

static
ECFunc gDoubleFuncs[] =
{
    {FCFuncElement("IsPositiveInfinity", NULL, (LPVOID)COMDouble::IsPositiveInfinity)},
    {FCFuncElement("IsNegativeInfinity", NULL, (LPVOID)COMDouble::IsNegativeInfinity)},
    {FCFuncElement("IsInfinity", NULL, (LPVOID)COMDouble::IsInfinity)},
    {NULL, NULL, NULL}
};

static
ECFunc gMathFuncs[] =
{
    {FCIntrinsic("Sin", NULL, (LPVOID)COMDouble::Sin, CORINFO_INTRINSIC_Sin)},
    {FCIntrinsic("Cos", NULL, (LPVOID)COMDouble::Cos, CORINFO_INTRINSIC_Cos)},
    {FCIntrinsic("Sqrt", NULL, (LPVOID)COMDouble::Sqrt, CORINFO_INTRINSIC_Sqrt)},
    {FCIntrinsic("Round", NULL, (LPVOID)COMDouble::Round, CORINFO_INTRINSIC_Round)},
    {FCIntrinsic("Abs", &gsig_SM_Flt_RetFlt, (LPVOID)COMDouble::AbsFlt, CORINFO_INTRINSIC_Abs)},
    {FCIntrinsic("Abs", &gsig_SM_Dbl_RetDbl, (LPVOID)COMDouble::AbsDbl, CORINFO_INTRINSIC_Abs)},
    {FCFuncElement("Exp", NULL, (LPVOID)COMDouble::Exp)},
    {FCFuncElement("Pow", NULL, (LPVOID)COMDouble::Pow)},
    {FCFuncElement("Tan", NULL, (LPVOID)COMDouble::Tan)},
    {FCFuncElement("Floor", NULL, (LPVOID)COMDouble::Floor)},
    {FCFuncElement("Log", NULL, (LPVOID)COMDouble::Log)},
    {FCFuncElement("Sinh", NULL, (LPVOID)COMDouble::Sinh)},
    {FCFuncElement("Cosh", NULL, (LPVOID)COMDouble::Cosh)},
    {FCFuncElement("Tanh", NULL, (LPVOID)COMDouble::Tanh)},
    {FCFuncElement("Acos", NULL, (LPVOID)COMDouble::Acos)},
    {FCFuncElement("Asin", NULL, (LPVOID)COMDouble::Asin)},
    {FCFuncElement("Atan", NULL, (LPVOID)COMDouble::Atan)},
    {FCFuncElement("Atan2", NULL, (LPVOID)COMDouble::Atan2)},
    {FCFuncElement("Log10", NULL, (LPVOID)COMDouble::Log10)},
    {FCFuncElement("Ceiling", NULL, (LPVOID)COMDouble::Ceil)},
    {FCFuncElement("IEEERemainder", NULL, (LPVOID)COMDouble::IEEERemainder)},
    {FCFuncElement("InternalRound", NULL, (LPVOID)COMDouble::RoundDigits)},
    {NULL, NULL, NULL}
};

static
ECFunc gThreadFuncs[] =
{
    {ECFuncElement("StartInternal", NULL, (LPVOID)ThreadNative::Start)}, /**/
    {ECFuncElement("SuspendInternal", NULL, (LPVOID)ThreadNative::Suspend)},
    {ECFuncElement("ResumeInternal", NULL, (LPVOID)ThreadNative::Resume)},
    {ECFuncElement("GetPriorityNative", NULL, (LPVOID)ThreadNative::GetPriority)},
    {ECFuncElement("SetPriorityNative", NULL, (LPVOID)ThreadNative::SetPriority)},
    {ECFuncElement("InterruptInternal", NULL, (LPVOID)ThreadNative::Interrupt)},
    {ECFuncElement("IsAliveNative", NULL, (LPVOID)ThreadNative::IsAlive)},
    {ECFuncElement("Join", &gsig_IM_RetVoid, (LPVOID)ThreadNative::Join)},
    {ECFuncElement("Join", &gsig_IM_Int_RetBool, (LPVOID)ThreadNative::JoinTimeout)},
    {ECFuncElement("Sleep", NULL, (LPVOID)ThreadNative::Sleep)},
    {ECFuncElement("GetCurrentThreadNative", NULL, (LPVOID)ThreadNative::GetCurrentThread)},
    {FCFuncElement("GetFastCurrentThreadNative", NULL, (LPVOID)ThreadNative::FastGetCurrentThread)},
    {ECFuncElement("GetDomainLocalStore", NULL, (LPVOID)ThreadNative::GetDomainLocalStore)}, /**/
    {ECFuncElement("SetDomainLocalStore", NULL, (LPVOID)ThreadNative::SetDomainLocalStore)}, /**/
    {ECFuncElement("InternalFinalize", NULL, (LPVOID)ThreadNative::Finalize)},
    {ECFuncElement("SetStart", NULL, (LPVOID)ThreadNative::SetStart)}, /**/
    {ECFuncElement("SetBackgroundNative", NULL, (LPVOID)ThreadNative::SetBackground)}, /**/
    {ECFuncElement("IsBackgroundNative", NULL, (LPVOID)ThreadNative::IsBackground)},
    {ECFuncElement("GetThreadStateNative", NULL, (LPVOID)ThreadNative::GetThreadState)},
    {ECFuncElement("SetApartmentStateNative", NULL, (LPVOID)ThreadNative::SetApartmentState)}, /**/
    {ECFuncElement("GetApartmentStateNative", NULL, (LPVOID)ThreadNative::GetApartmentState)},
    {ECFuncElement("GetDomainInternal", NULL, (LPVOID)ThreadNative::GetDomain)}, /**/
    {FCFuncElement("GetFastDomainInternal", NULL, (LPVOID)ThreadNative::FastGetDomain)}, /**/
    {ECFuncElement("GetContextInternal", NULL, (LPVOID)ThreadNative::GetContextFromContextID)},
    {ECFuncElement("SetCompressedStackInternal", NULL, (LPVOID)ThreadNative::SetCompressedStack)},
    {ECFuncElement("GetCompressedStackInternal", NULL, (LPVOID)ThreadNative::GetCompressedStack)},
#ifdef FCALLAVAILABLE
    {FCFuncElement("EnterContextInternal", NULL, (LPVOID)ThreadNative::EnterContextFromContextID)},    
    {FCFuncElement("ReturnToContext", NULL, (LPVOID)ThreadNative::ReturnToContextFromContextID)},    
    {FCFuncElement("InformThreadNameChange", NULL, (LPVOID)ThreadNative::InformThreadNameChange)},    
    {FCFuncElement("AbortInternal", NULL, (LPVOID)ThreadNative::Abort)},    
    {FCFuncElement("ResetAbortNative", NULL, (LPVOID)ThreadNative::ResetAbort)},    
    {FCFuncElement("IsRunningInDomain", NULL, (LPVOID)ThreadNative::IsRunningInDomain)},
    {FCFuncElement("IsThreadpoolThreadNative", NULL, (LPVOID)ThreadNative::IsThreadpoolThread)},
    {FCFuncElement("SpinWait", NULL, (LPVOID)ThreadNative::SpinWait)},
#else

#endif
    {FCFuncElement("VolatileRead", &gsig_SM_RefByte_RetByte, (LPVOID)ThreadNative::VolatileReadByte)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefShrt_RetShrt, (LPVOID)ThreadNative::VolatileReadShort)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefInt_RetInt, (LPVOID)ThreadNative::VolatileReadInt)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefLong_RetLong, (LPVOID)ThreadNative::VolatileReadLong)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefSByt_RetSByt, (LPVOID)ThreadNative::VolatileReadByte)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefUShrt_RetUShrt, (LPVOID)ThreadNative::VolatileReadShort)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefUInt_RetUInt, (LPVOID)ThreadNative::VolatileReadInt)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefIntPtr_RetIntPtr, (LPVOID)ThreadNative::VolatileReadPtr)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefUIntPtr_RetUIntPtr, (LPVOID)ThreadNative::VolatileReadPtr)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefULong_RetULong, (LPVOID)ThreadNative::VolatileReadLong)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefFlt_RetFlt, (LPVOID)ThreadNative::VolatileReadFloat)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefDbl_RetDbl, (LPVOID)ThreadNative::VolatileReadDouble)},
    {FCFuncElement("VolatileRead", &gsig_SM_RefObj_RetObj, (LPVOID)ThreadNative::VolatileReadObjPtr)},

    {FCFuncElement("VolatileWrite", &gsig_SM_RefByte_Byte_RetVoid, (LPVOID)ThreadNative::VolatileWriteByte)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefShrt_Shrt_RetVoid, (LPVOID)ThreadNative::VolatileWriteShort)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefInt_Int_RetVoid, (LPVOID)ThreadNative::VolatileWriteInt)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefLong_Long_RetVoid, (LPVOID)ThreadNative::VolatileWriteLong)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefSByt_SByt_RetVoid, (LPVOID)ThreadNative::VolatileWriteByte)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefUShrt_UShrt_RetVoid, (LPVOID)ThreadNative::VolatileWriteShort)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefUInt_UInt_RetVoid, (LPVOID)ThreadNative::VolatileWriteInt)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefIntPtr_IntPtr_RetVoid, (LPVOID)ThreadNative::VolatileWritePtr)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefUIntPtr_UIntPtr_RetVoid, (LPVOID)ThreadNative::VolatileWritePtr)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefULong_ULong_RetVoid, (LPVOID)ThreadNative::VolatileWriteLong)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefFlt_Flt_RetVoid, (LPVOID)ThreadNative::VolatileWriteFloat)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefDbl_Dbl_RetVoid, (LPVOID)ThreadNative::VolatileWriteDouble)},
    {FCFuncElement("VolatileWrite", &gsig_SM_RefObj_Obj_RetVoid, (LPVOID)ThreadNative::VolatileWriteObjPtr)},

    {FCFuncElement("MemoryBarrier", NULL, (LPVOID)ThreadNative::MemoryBarrier)},

    {NULL, NULL, NULL}
};

static
ECFunc gThreadPoolFuncs[] =
{
    {ECFuncElement("RegisterWaitForSingleObjectNative", NULL, (LPVOID)ThreadPoolNative::CorRegisterWaitForSingleObject)},
    {ECFuncElement("QueueUserWorkItem", NULL, (LPVOID)ThreadPoolNative::CorQueueUserWorkItem)},
    {ECFuncElement("BindIOCompletionCallbackNative", NULL, (LPVOID)ThreadPoolNative::CorBindIoCompletionCallback)},
    {FCFuncElement("GetMaxThreadsNative", NULL, (LPVOID)ThreadPoolNative::CorGetMaxThreads)},
    {FCFuncElement("SetMinThreadsNative", NULL, (LPVOID)ThreadPoolNative::CorSetMinThreads)},
    {FCFuncElement("GetMinThreadsNative", NULL, (LPVOID)ThreadPoolNative::CorGetMinThreads)},
    {FCFuncElement("GetAvailableThreadsNative", NULL, (LPVOID)ThreadPoolNative::CorGetAvailableThreads)},
};


static
ECFunc gTimerFuncs[] =
{
    {ECFuncElement("ChangeTimerNative", NULL, (LPVOID)TimerNative::CorChangeTimer)},
    {ECFuncElement("DeleteTimerNative", NULL, (LPVOID)TimerNative::CorDeleteTimer)},
    {ECFuncElement("AddTimerNative", NULL, (LPVOID)TimerNative::CorCreateTimer)},
    {NULL, NULL, NULL}
};

static
ECFunc gRegisteredWaitHandleFuncs[] =
{
    {ECFuncElement("UnregisterWaitNative", NULL, (LPVOID)ThreadPoolNative::CorUnregisterWait)},
    {ECFuncElement("WaitHandleCleanupNative", NULL, (LPVOID)ThreadPoolNative::CorWaitHandleCleanupNative)},
    {NULL, NULL, NULL}
};

static
ECFunc gWaitHandleFuncs[] =
{
    {ECFuncElement("WaitOneNative", NULL, (LPVOID)WaitHandleNative::CorWaitOneNative)}, /**/
    {ECFuncElement("WaitMultiple",   NULL, (LPVOID)WaitHandleNative::CorWaitMultipleNative)},
    {NULL, NULL, NULL}

};

static
ECFunc gManualResetEventFuncs[] =
{
    {ECFuncElement("CreateManualResetEventNative", NULL, (LPVOID)ManualResetEventNative::CorCreateManualResetEvent)}, /**/
    {ECFuncElement("SetManualResetEventNative", NULL, (LPVOID)ManualResetEventNative::CorSetEvent)}, /**/
    {ECFuncElement("ResetManualResetEventNative", NULL, (LPVOID)ManualResetEventNative::CorResetEvent)},
    {NULL, NULL, NULL}

};

static
ECFunc gAutoResetEventFuncs[] =
{
    {ECFuncElement("CreateAutoResetEventNative", NULL, (LPVOID)AutoResetEventNative::CorCreateAutoResetEvent)},
    {ECFuncElement("SetAutoResetEventNative", NULL, (LPVOID)AutoResetEventNative::CorSetEvent)},
    {ECFuncElement("ResetAutoResetEventNative", NULL, (LPVOID)AutoResetEventNative::CorResetEvent)},
    {NULL, NULL, NULL}

};

static
ECFunc gMutexFuncs[] =
{
    {FCFuncElement("CreateMutexNative", NULL, (LPVOID)MutexNative::CorCreateMutex)},
    {FCFuncElement("ReleaseMutexNative", NULL, (LPVOID)MutexNative::CorReleaseMutex)},
};

static
ECFunc gNumberFuncs[] =
{
    {ECFuncElement("FormatDecimal", NULL, (LPVOID)COMNumber::FormatDecimal)},
    {ECFuncElement("FormatDouble", NULL, (LPVOID)COMNumber::FormatDouble)},
    {ECFuncElement("FormatInt32",  NULL, (LPVOID)COMNumber::FormatInt32)},
    {ECFuncElement("FormatUInt32",  NULL, (LPVOID)COMNumber::FormatUInt32)},
    {ECFuncElement("FormatInt64",  NULL, (LPVOID)COMNumber::FormatInt64)},
    {ECFuncElement("FormatUInt64",  NULL, (LPVOID)COMNumber::FormatUInt64)},
    {ECFuncElement("FormatSingle", NULL, (LPVOID)COMNumber::FormatSingle)},
    {ECFuncElement("ParseDecimal", NULL, (LPVOID)COMNumber::ParseDecimal)},
    {ECFuncElement("ParseDouble",  NULL, (LPVOID)COMNumber::ParseDouble)},
    {ECFuncElement("TryParseDouble",  NULL, (LPVOID)COMNumber::TryParseDouble)},
    {ECFuncElement("ParseInt32",   NULL, (LPVOID)COMNumber::ParseInt32)},
    {ECFuncElement("ParseUInt32",   NULL, (LPVOID)COMNumber::ParseUInt32)},
    {ECFuncElement("ParseInt64",   NULL, (LPVOID)COMNumber::ParseInt64)},
    {ECFuncElement("ParseUInt64",   NULL, (LPVOID)COMNumber::ParseUInt64)},
    {ECFuncElement("ParseSingle",  NULL, (LPVOID)COMNumber::ParseSingle)},
    {NULL, NULL, NULL}
};

static
ECFunc gVariantFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("SetFieldsR4",           NULL, (LPVOID)COMVariant::SetFieldsR4)},
    {FCFuncElement("SetFieldsR8",           NULL, (LPVOID)COMVariant::SetFieldsR8)},
    {FCFuncElement("SetFieldsObject",       NULL, (LPVOID)COMVariant::SetFieldsObject)},
    {FCFuncElement("GetR4FromVar",          NULL, (LPVOID)COMVariant::GetR4FromVar)},
    {FCFuncElement("GetR8FromVar",          NULL, (LPVOID)COMVariant::GetR8FromVar)},
#else
    {ECFuncElement("SetFieldsR4",           NULL, (LPVOID)COMVariant::SetFieldsR4)},
    {ECFuncElement("SetFieldsR8",           NULL, (LPVOID)COMVariant::SetFieldsR8)},
    {ECFuncElement("SetFieldsObject",       NULL, (LPVOID)COMVariant::SetFieldsObject)},
    {ECFuncElement("GetR4FromVar",          NULL, (LPVOID)COMVariant::GetR4FromVar)},
    {ECFuncElement("GetR8FromVar",          NULL, (LPVOID)COMVariant::GetR8FromVar)},
#endif
    {ECFuncElement("InitVariant",           NULL, (LPVOID)COMVariant::InitVariant)},
    {ECFuncElement("TypedByRefToVariant", &gsig_SM_Int_RetVar, (LPVOID)COMVariant::RefAnyToVariant)},
    {ECFuncElement("TypedByRefToVariant", &gsig_SM_TypedByRef_RetVar, (LPVOID)COMVariant::TypedByRefToVariantEx)},
    {ECFuncElement("InternalTypedByRefToVariant", NULL, (LPVOID)COMVariant::TypedByRefToVariantEx)},
    {ECFuncElement("VariantToTypedByRef",   NULL, (LPVOID)COMVariant::VariantToRefAny)},
    {ECFuncElement("InternalVariantToTypedByRef",   NULL, (LPVOID)COMVariant::VariantToTypedRefAnyEx)},
    {ECFuncElement("BoxEnum",               NULL, (LPVOID)COMVariant::BoxEnum)},
    {NULL, NULL, NULL}
};

static
ECFunc gOAVariantFuncs[] =
{
    {ECFuncElement("Add",                 NULL, (LPVOID)COMOAVariant::Add)},
    {ECFuncElement("Subtract",            NULL, (LPVOID)COMOAVariant::Subtract)},
    {ECFuncElement("Multiply",            NULL, (LPVOID)COMOAVariant::Multiply)},
    {ECFuncElement("Divide",              NULL, (LPVOID)COMOAVariant::Divide)},
    {ECFuncElement("Mod",                 NULL, (LPVOID)COMOAVariant::Mod)},
    {ECFuncElement("Pow",                 NULL, (LPVOID)COMOAVariant::Pow)},
    {ECFuncElement("And",                 NULL, (LPVOID)COMOAVariant::And)},
    {ECFuncElement("Or",                  NULL, (LPVOID)COMOAVariant::Or)},
    {ECFuncElement("Xor",                 NULL, (LPVOID)COMOAVariant::Xor)},
    {ECFuncElement("Eqv",                 NULL, (LPVOID)COMOAVariant::Eqv)},
    {ECFuncElement("IntDivide",           NULL, (LPVOID)COMOAVariant::IntDivide)},
    {ECFuncElement("Implies",             NULL, (LPVOID)COMOAVariant::Implies)},

    {ECFuncElement("Negate",              NULL, (LPVOID)COMOAVariant::Negate)},
    {ECFuncElement("Not",                 NULL, (LPVOID)COMOAVariant::Not)},
    {ECFuncElement("Abs",                 NULL, (LPVOID)COMOAVariant::Abs)},
    {ECFuncElement("Fix",                 NULL, (LPVOID)COMOAVariant::Fix)},
    {ECFuncElement("Int",                 NULL, (LPVOID)COMOAVariant::Int)},

    {ECFuncElement("InternalCompare",     NULL, (LPVOID)COMOAVariant::Compare)},
    {ECFuncElement("ChangeType",          NULL, (LPVOID)COMOAVariant::ChangeType)},
    {ECFuncElement("ChangeTypeEx",        NULL, (LPVOID)COMOAVariant::ChangeTypeEx)},
    {ECFuncElement("Round",               NULL, (LPVOID)COMOAVariant::Round)},

    {ECFuncElement("Format",              NULL, (LPVOID)COMOAVariant::Format)},
    {ECFuncElement("FormatBoolean",       NULL, (LPVOID)COMOAVariant::FormatBoolean)},
    {ECFuncElement("FormatByte",          NULL, (LPVOID)COMOAVariant::FormatByte)},
    {ECFuncElement("FormatSByte",         NULL, (LPVOID)COMOAVariant::FormatSByte)},
    {ECFuncElement("FormatInt16",         NULL, (LPVOID)COMOAVariant::FormatInt16)},
    {ECFuncElement("FormatInt32",         NULL, (LPVOID)COMOAVariant::FormatInt32)},
    {ECFuncElement("FormatSingle",        NULL, (LPVOID)COMOAVariant::FormatSingle)},
    {ECFuncElement("FormatDouble",        NULL, (LPVOID)COMOAVariant::FormatDouble)},
    {ECFuncElement("FormatCurrency",      &gsig_SM_Currency_Int_Int_RetStr, (LPVOID)COMOAVariant::FormatCurrency)},
    {ECFuncElement("FormatCurrency",      &gsig_SM_Var_Int_Int_Int_Int_Int_RetStr, (LPVOID)COMOAVariant::FormatCurrencySpecial)},
    {ECFuncElement("FormatDateTime",      &gsig_SM_DateTime_Int_Int_RetStr, (LPVOID)COMOAVariant::FormatDateTime)},
    {ECFuncElement("FormatDateTime",      &gsig_SM_Var_Int_Int_RetStr, (LPVOID)COMOAVariant::FormatDateTimeSpecial)},
    {ECFuncElement("FormatDecimal",       NULL, (LPVOID)COMOAVariant::FormatDecimal)},
    {ECFuncElement("FormatNumber",        NULL, (LPVOID)COMOAVariant::FormatNumber)},
    {ECFuncElement("FormatPercent",       NULL, (LPVOID)COMOAVariant::FormatPercent)},

    {ECFuncElement("ParseBoolean",        NULL, (LPVOID)COMOAVariant::ParseBoolean)},
    {ECFuncElement("ParseDateTime",       NULL, (LPVOID)COMOAVariant::ParseDateTime)},
    {NULL, NULL, NULL}
};


static
ECFunc gBitConverterFuncs[] =
{
    {ECFuncElement("GetBytes",           &gsig_SM_Char_RetArrByte, (LPVOID)BitConverter::CharToBytes)}, /**/
    {ECFuncElement("GetBytes",           &gsig_SM_Shrt_RetArrByte, (LPVOID)BitConverter::I2ToBytes)}, /**/
    {ECFuncElement("GetBytes",           &gsig_SM_Int_RetArrByte,  (LPVOID)BitConverter::I4ToBytes)}, /**/
    {ECFuncElement("GetBytes",           &gsig_SM_Long_RetArrByte, (LPVOID)BitConverter::I8ToBytes)}, /**/
    {ECFuncElement("GetUInt16Bytes",     NULL, (LPVOID)BitConverter::U2ToBytes)},
    {ECFuncElement("GetUInt32Bytes",     NULL, (LPVOID)BitConverter::U4ToBytes)},
    {ECFuncElement("GetUInt64Bytes",     NULL, (LPVOID)BitConverter::U8ToBytes)},
    {ECFuncElement("ToChar",             NULL, (LPVOID)BitConverter::BytesToChar)},
    {ECFuncElement("ToInt16",            NULL, (LPVOID)BitConverter::BytesToI2)},
    {ECFuncElement("ToInt32",            NULL, (LPVOID)BitConverter::BytesToI4)},
    {ECFuncElement("ToInt64",            NULL, (LPVOID)BitConverter::BytesToI8)},
    {ECFuncElement("ToUInt16",           NULL, (LPVOID)BitConverter::BytesToU2)},
    {ECFuncElement("ToUInt32",           NULL, (LPVOID)BitConverter::BytesToU4)},
    {ECFuncElement("ToUInt64",           NULL, (LPVOID)BitConverter::BytesToU8)},
    {ECFuncElement("ToSingle",           NULL, (LPVOID)BitConverter::BytesToR4)},
    {ECFuncElement("ToDouble",           NULL, (LPVOID)BitConverter::BytesToR8)},
    {ECFuncElement("ToString",           NULL, (LPVOID)BitConverter::BytesToString)},
    {NULL, NULL, NULL}
};

static
ECFunc gDecimalFuncs[] =
{
    {FCFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_Flt_RetVoid,   (LPVOID)COMDecimal::InitSingle)},
    {FCFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_Dbl_RetVoid,   (LPVOID)COMDecimal::InitDouble)},
    {FCFuncElement("Add",         NULL,               (LPVOID)COMDecimal::Add)},
    {FCFuncElement("Compare",     NULL,               (LPVOID)COMDecimal::Compare)},
    {FCFuncElement("Divide",      NULL,               (LPVOID)COMDecimal::Divide)},
    {FCFuncElement("Floor",       NULL,               (LPVOID)COMDecimal::Floor)},
    {FCFuncElement("GetHashCode", NULL,               (LPVOID)COMDecimal::GetHashCode)},
    {FCFuncElement("Remainder",   NULL,               (LPVOID)COMDecimal::Remainder)},
    {FCFuncElement("Multiply",    NULL,               (LPVOID)COMDecimal::Multiply)},
    {FCFuncElement("Round",       NULL,               (LPVOID)COMDecimal::Round)},
    {FCFuncElement("Subtract",    NULL,               (LPVOID)COMDecimal::Subtract)},
    {FCFuncElement("ToCurrency",  NULL,               (LPVOID)COMDecimal::ToCurrency)},
    {FCFuncElement("ToDouble",    NULL,               (LPVOID)COMDecimal::ToDouble)},
    {FCFuncElement("ToSingle",    NULL,               (LPVOID)COMDecimal::ToSingle)},
    {ECFuncElement("ToString",    NULL,               (LPVOID)COMDecimal::ToString)},
    {FCFuncElement("Truncate",    NULL,               (LPVOID)COMDecimal::Truncate)},
    {NULL, NULL, NULL}
};

static
ECFunc gCurrencyFuncs[] =
{
    {ECFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_Flt_RetVoid,   (LPVOID)COMCurrency::InitSingle)},
    {ECFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_Dbl_RetVoid,   (LPVOID)COMCurrency::InitDouble)},
    {ECFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_Str_RetVoid,   (LPVOID)COMCurrency::InitString)},
    {ECFuncElement("Add",         NULL,               (LPVOID)COMCurrency::Add)},
    {ECFuncElement("Floor",       NULL,               (LPVOID)COMCurrency::Floor)},
    {ECFuncElement("Multiply",    NULL,               (LPVOID)COMCurrency::Multiply)},
    {ECFuncElement("Round",       NULL,               (LPVOID)COMCurrency::Round)},
    {ECFuncElement("Subtract",    NULL,               (LPVOID)COMCurrency::Subtract)},
    {ECFuncElement("ToDecimal",   NULL,               (LPVOID)COMCurrency::ToDecimal)},
    {ECFuncElement("ToDouble",    NULL,               (LPVOID)COMCurrency::ToDouble)},
    {ECFuncElement("ToSingle",    NULL,               (LPVOID)COMCurrency::ToSingle)},
    {ECFuncElement("ToString",    NULL,               (LPVOID)COMCurrency::ToString)},
    {ECFuncElement("Truncate",    NULL,               (LPVOID)COMCurrency::Truncate)},
    {NULL, NULL, NULL}
};

static
ECFunc gDateTimeFuncs[] =
{
    {FCFuncElement("GetSystemFileTime",  NULL,             (LPVOID)COMDateTime::FCGetSystemFileTime)},
    {NULL, NULL, NULL}
};

static
ECFunc gCharacterInfoFuncs[] =
{
    {ECFuncElement("nativeInitTable",               NULL, (LPVOID)COMNlsInfo::nativeInitUnicodeCatTable)}, /**/
    {FCFuncElement("nativeGetCategoryDataTable",        NULL, (LPVOID)COMNlsInfo::nativeGetUnicodeCatTable)},
    {FCFuncElement("nativeGetCategoryLevel2Offset",        NULL, (LPVOID)COMNlsInfo::nativeGetUnicodeCatLevel2Offset)},
    {FCFuncElement("nativeGetNumericDataTable",        NULL, (LPVOID)COMNlsInfo::nativeGetNumericTable)},
    {FCFuncElement("nativeGetNumericLevel2Offset",        NULL, (LPVOID)COMNlsInfo::nativeGetNumericLevel2Offset)},
    {FCFuncElement("nativeGetNumericFloatData",        NULL, (LPVOID)COMNlsInfo::nativeGetNumericFloatData)},
    {NULL, NULL, NULL}
};

static
ECFunc gCompareInfoFuncs[] =
{
    {ECFuncElement("Compare",                 NULL,                            (LPVOID)COMNlsInfo::Compare)},
    {ECFuncElement("CompareRegion",           NULL,                            (LPVOID)COMNlsInfo::CompareRegion)}, /**/
    {ECFuncElement("IndexOfChar",                 NULL,   (LPVOID)COMNlsInfo::IndexOfChar)},
    {FCFuncElement("IndexOfString",           NULL, (LPVOID)COMNlsInfo::IndexOfString)},
    {ECFuncElement("LastIndexOfChar",             NULL,   (LPVOID)COMNlsInfo::LastIndexOfChar)},
    {ECFuncElement("LastIndexOfString",             NULL, (LPVOID)COMNlsInfo::LastIndexOfString)},
    {FCFuncElement("nativeIsPrefix",            NULL, (LPVOID)COMNlsInfo::nativeIsPrefix)},
    {FCFuncElement("nativeIsSuffix",            NULL, (LPVOID)COMNlsInfo::nativeIsSuffix)},
#ifdef _USE_NLS_PLUS_TABLE
    {ECFuncElement("InitializeNativeCompareInfo",  NULL,                      (LPVOID)COMNlsInfo::InitializeNativeCompareInfo)},
#endif //_USE_NLS_PLUS_TABLE
    {NULL, NULL, NULL}
};

static
ECFunc gGlobalizationAssemblyFuncs[] =
{
    {ECFuncElement("nativeCreateGlobalizationAssembly",  NULL,                            (LPVOID)COMNlsInfo::nativeCreateGlobalizationAssembly)},
    {NULL, NULL, NULL}
};

static
ECFunc gEncodingTableFuncs[] =
{
    {FCFuncElement("GetNumEncodingItems",  NULL, (LPVOID)COMNlsInfo::nativeGetNumEncodingItems)},
    {FCFuncElement("GetEncodingData",  NULL, (LPVOID)COMNlsInfo::nativeGetEncodingTableDataPointer)},
    {FCFuncElement("GetCodePageData",  NULL, (LPVOID)COMNlsInfo::nativeGetCodePageTableDataPointer)},
    {NULL, NULL, NULL}
};


static
ECFunc gCalendarFuncs[] =
{
    {ECFuncElement("nativeGetTwoDigitYearMax",   NULL,             (LPVOID)COMNlsInfo::nativeGetTwoDigitYearMax)},
    {NULL, NULL, NULL},
};

static
ECFunc gCultureInfoFuncs[] =
{
    {FCFuncElement("IsSupportedLCID",                   NULL,      (LPVOID)COMNlsInfo::IsSupportedLCID)},
    {FCFuncElement("IsInstalledLCID",                   NULL,      (LPVOID)COMNlsInfo::IsInstalledLCID)},
    {FCFuncElement("nativeGetUserDefaultLCID",          NULL,      (LPVOID)COMNlsInfo::nativeGetUserDefaultLCID)},
    {ECFuncElement("nativeGetUserDefaultUILanguage",    NULL,      (LPVOID)COMNlsInfo::nativeGetUserDefaultUILanguage)}, /**/
    {ECFuncElement("nativeGetSystemDefaultUILanguage",  NULL,      (LPVOID)COMNlsInfo::nativeGetSystemDefaultUILanguage)},
    {FCFuncElement("nativeGetThreadLocale",             NULL,      (LPVOID)COMNlsInfo::nativeGetThreadLocale)},
    {FCFuncElement("nativeSetThreadLocale",             NULL,      (LPVOID)COMNlsInfo::nativeSetThreadLocale)},
    {NULL, NULL, NULL}
};

static
ECFunc gCultureTableFuncs[] =
{
    {ECFuncElement("nativeInitCultureInfoTable",        NULL,      (LPVOID)COMNlsInfo::nativeInitCultureInfoTable)},
    {FCFuncElement("nativeGetHeader",                   NULL,      (LPVOID)COMNlsInfo::nativeGetCultureInfoHeader)},
    {FCFuncElement("nativeGetNameOffsetTable",          NULL,      (LPVOID)COMNlsInfo::nativeGetCultureInfoNameOffsetTable)},
    {FCFuncElement("nativeGetStringPoolStr",            NULL,      (LPVOID)COMNlsInfo::nativeGetCultureInfoStringPoolStr)},
    {FCFuncElement("nativeGetDataItemFromCultureID",    NULL,      (LPVOID)COMNlsInfo::nativeGetCultureDataFromID)},
    {FCFuncElement("GetInt32Value",                     NULL,      (LPVOID)COMNlsInfo::GetCultureInt32Value)},
    {ECFuncElement("GetStringValue",                    NULL,      (LPVOID)COMNlsInfo::GetCultureStringValue)},
    {FCFuncElement("GetDefaultInt32Value",              NULL,      (LPVOID)COMNlsInfo::GetCultureDefaultInt32Value)},
    {ECFuncElement("GetDefaultStringValue",             NULL,      (LPVOID)COMNlsInfo::GetCultureDefaultStringValue)},
    {ECFuncElement("GetMultipleStringValues",           NULL,      (LPVOID)COMNlsInfo::GetCultureMultiStringValues)},
    {NULL, NULL, NULL}
};


static
ECFunc gRegionTableFuncs[] =
{
#ifdef _USE_NLS_PLUS_TABLE
    {ECFuncElement("nativeInitRegionInfoTable",         NULL,      (LPVOID)COMNlsInfo::nativeInitRegionInfoTable)},
    {FCFuncElement("nativeGetHeader",                   NULL,      (LPVOID)COMNlsInfo::nativeGetRegionInfoHeader)},
    {FCFuncElement("nativeGetNameOffsetTable",          NULL,      (LPVOID)COMNlsInfo::nativeGetRegionInfoNameOffsetTable)},
    {FCFuncElement("nativeGetStringPoolStr",            NULL,      (LPVOID)COMNlsInfo::nativeGetRegionInfoStringPoolStr)},
    {FCFuncElement("nativeGetDataItemFromRegionID",     NULL,      (LPVOID)COMNlsInfo::nativeGetRegionDataFromID)},
    {ECFuncElement("GetInt32Value",                     NULL,      (LPVOID)COMNlsInfo::nativeGetRegionInt32Value)},
    {ECFuncElement("GetStringValue",                    NULL,      (LPVOID)COMNlsInfo::nativeGetRegionStringValue)},
    //{ECFuncElement("GetMultipleStringValues",              NULL,      (LPVOID)COMNlsInfo::nativeGetRegionMultiStringValues)},
#endif
    {NULL, NULL, NULL}
};

static
ECFunc gCalendarTableFuncs[] =
{
#ifdef _USE_NLS_PLUS_TABLE
    {ECFuncElement("nativeInitCalendarTable",         NULL,      (LPVOID)COMNlsInfo::nativeInitCalendarTable)},
    {ECFuncElement("GetInt32Value",                     NULL,      (LPVOID)COMNlsInfo::nativeGetCalendarInt32Value)},
    {ECFuncElement("GetStringValue",                    NULL,      (LPVOID)COMNlsInfo::nativeGetCalendarStringValue)},
    {ECFuncElement("GetMultipleStringValues",              NULL,      (LPVOID)COMNlsInfo::nativeGetCalendarMultiStringValues)},
    {ECFuncElement("nativeGetEraName",                NULL,          (LPVOID)COMNlsInfo::nativeGetEraName)},
    //{FCFuncElement("nativeGetHeader",                   NULL,      (LPVOID)COMNlsInfo::nativeGetCalendarHeader)},
    //{FCFuncElement("nativeGetStringPoolStr",            NULL,      (LPVOID)COMNlsInfo::nativeGetCalendarStringPoolStr)},
#endif
    {NULL, NULL, NULL}
};

static
ECFunc gTextInfoFuncs[] =
{
#ifdef _USE_NLS_PLUS_TABLE
    {FCFuncElement("nativeChangeCaseChar",        NULL,             (LPVOID)COMNlsInfo::nativeChangeCaseChar)},
    {ECFuncElement("nativeChangeCaseString",      NULL,             (LPVOID)COMNlsInfo::nativeChangeCaseString)},
    {ECFuncElement("AllocateDefaultCasingTable",  NULL,             (LPVOID)COMNlsInfo::AllocateDefaultCasingTable)},
    {ECFuncElement("InternalAllocateCasingTable", NULL,             (LPVOID)COMNlsInfo::AllocateCasingTable)},
    {FCFuncElement("nativeGetCaseInsHash",        NULL,             (LPVOID)COMNlsInfo::GetCaseInsHash)},
    {FCFuncElement("nativeGetTitleCaseChar",      NULL,             (LPVOID)COMNlsInfo::nativeGetTitleCaseChar)},
#else
    {ECFuncElement("nativeToLowerChar",             NULL,               (LPVOID)COMNlsInfo::ToLowerChar)},
    {ECFuncElement("nativeToLowerString",             NULL,               (LPVOID)COMNlsInfo::ToLowerString)},
    {ECFuncElement("nativeToUpperChar",             NULL,               (LPVOID)COMNlsInfo::ToUpperChar)},
    {ECFuncElement("nativeToUpperString",             NULL,               (LPVOID)COMNlsInfo::ToUpperString)},
#endif // _USE_NLS_PLUS_TABLE
    {NULL, NULL, NULL}
};

static
ECFunc gSortKeyFuncs[] =
{
    {ECFuncElement("Compare",              NULL,  (LPVOID)COMNlsInfo::SortKey_Compare)},
    {ECFuncElement("nativeCreateSortKey",  NULL,  (LPVOID)COMNlsInfo::nativeCreateSortKey)},
    {NULL, NULL, NULL}
};

static
ECFunc gArrayFuncs[] =
{
    {ECFuncElement("Copy",                 NULL,   (LPVOID)SystemNative::ArrayCopy)}, /**/
    {ECFuncElement("Clear",                NULL,   (LPVOID)SystemNative::ArrayClear)},
    {FCFuncElement("GetRankNative",        NULL,   (LPVOID)Array_Rank)},
    {FCFuncElement("GetLowerBound",        NULL,   (LPVOID)Array_LowerBound)},
    {FCFuncElement("GetUpperBound",        NULL,   (LPVOID)Array_UpperBound)},
    {FCIntrinsic  ("GetLength",            &gsig_IM_Int_RetInt, (LPVOID)Array_GetLength,       CORINFO_INTRINSIC_Array_GetDimLength)},
    {FCIntrinsic  ("GetLengthNative",      &gsig_IM_RetInt,     (LPVOID)Array_GetLengthNoRank, CORINFO_INTRINSIC_Array_GetLengthTotal)},
    {FCFuncElement("Initialize",           NULL,   (LPVOID)Array_Initialize)},
    {ECFuncElement("InternalCreate",       NULL,   (LPVOID)COMArrayInfo::CreateInstance)}, /**/
    {ECFuncElement("InternalCreateEx",     NULL,   (LPVOID)COMArrayInfo::CreateInstanceEx)},
    {FCFuncElement("InternalGetValue",     NULL,   (LPVOID)COMArrayInfo::GetValue)}, /**/
    {ECFuncElement("InternalGetValueEx",   NULL,   (LPVOID)COMArrayInfo::GetValueEx)},
    {ECFuncElement("InternalSetValue",     NULL,   (LPVOID)COMArrayInfo::SetValue)},
    {ECFuncElement("InternalSetValueEx",   NULL,   (LPVOID)COMArrayInfo::SetValueEx)}, /**/
    {FCFuncElement("TrySZIndexOf",         NULL,   (LPVOID)ArrayHelper::TrySZIndexOf)},
    {FCFuncElement("TrySZLastIndexOf",     NULL,   (LPVOID)ArrayHelper::TrySZLastIndexOf)},
    {FCFuncElement("TrySZBinarySearch",    NULL,   (LPVOID)ArrayHelper::TrySZBinarySearch)},
    {FCFuncElement("TrySZSort",            NULL,   (LPVOID)ArrayHelper::TrySZSort)},
    {FCFuncElement("TrySZReverse",         NULL,   (LPVOID)ArrayHelper::TrySZReverse)},
    {NULL, NULL, NULL}
};

static
ECFunc gBufferFuncs[] =
{
    {FCFuncElement("BlockCopy",        NULL,   (LPVOID)Buffer::BlockCopy)}, /**/
    {FCFuncElement("InternalBlockCopy",NULL,   (LPVOID)Buffer::InternalBlockCopy)}, /**/
    {ECFuncElement("GetByte",          NULL,   (LPVOID)Buffer::GetByte)}, /**/
    {ECFuncElement("SetByte",          NULL,   (LPVOID)Buffer::SetByte)}, /**/
    {ECFuncElement("ByteLength",       NULL,   (LPVOID)Buffer::ByteLength)}, /**/
    {NULL, NULL, NULL}
};

static
ECFunc gGCInterfaceFuncs[] =
{
    {ECFuncElement("GetGenerationWR",         NULL,   (LPVOID)GCInterface::GetGenerationWR)},
    {ECFuncElement("GetGeneration",           NULL,   (LPVOID)GCInterface::GetGeneration)},
    {FCFuncElement("KeepAlive",               NULL,   (LPVOID)GCInterface::KeepAlive)},
    {ECFuncElement("nativeGetTotalMemory",    NULL,   (LPVOID)GCInterface::GetTotalMemory)}, /**/
    {ECFuncElement("nativeCollectGeneration", NULL,   (LPVOID)GCInterface::CollectGeneration)}, /**/
    {ECFuncElement("nativeGetMaxGeneration",        NULL,   (LPVOID)GCInterface::GetMaxGeneration)},
    {ECFuncElement("WaitForPendingFinalizers",           NULL,   (LPVOID)GCInterface::RunFinalizers)}, /**/
    {ECFuncElement("nativeGetCurrentMethod",  NULL, (LPVOID) GCInterface::InternalGetCurrentMethod)},
    {FCFuncElement("SetCleanupCache",         NULL,   (LPVOID)GCInterface::NativeSetCleanupCache)},
#ifdef FCALLAVAILABLE
    {FCFuncElement("nativeSuppressFinalize",       NULL,   (LPVOID)GCInterface::FCSuppressFinalize)},
    {FCFuncElement("nativeReRegisterForFinalize",    NULL,   (LPVOID)GCInterface::FCReRegisterForFinalize)},
#else
    {ECFuncElement("nativeSuppressFinalize",        NULL,   (LPVOID)GCInterface::SuppressFinalize)},
    {ECFuncElement("nativeReRegisterForFinalize",     NULL,   (LPVOID)GCInterface::ReRegisterForFinalize)},
#endif
    {NULL, NULL, NULL}
};


static
ECFunc gInteropMarshalFuncs[] =
{
    {ECFuncElement("SizeOf",                    &gsig_SM_Type_RetInt,      (LPVOID)SizeOfClass )}, /**/
    {FCFuncElement("SizeOf",                    &gsig_SM_Obj_RetInt,       (LPVOID)FCSizeOfObject )},
    {ECFuncElement("OffsetOfHelper",            NULL,                      (LPVOID)OffsetOfHelper )},
    {FCFuncElement("UnsafeAddrOfPinnedArrayElement", NULL,                 (LPVOID)FCUnsafeAddrOfPinnedArrayElement )},
    {ECFuncElement("GetLastWin32Error",         NULL,                      (LPVOID)GetLastWin32Error )},
    {ECFuncElement("Prelink",                   NULL,                      (LPVOID)NDirect_Prelink_Wrapper )},
    {ECFuncElement("NumParamBytes",             NULL,                      (LPVOID)NDirect_NumParamBytes )},
    {ECFuncElement("CopyBytesToNative",         NULL,                      (LPVOID)CopyToNative )},
    {ECFuncElement("Copy",                      &gsig_SM_ArrChar_Int_Int_Int_RetVoid,    (LPVOID)CopyToNative )},
    {ECFuncElement("Copy",                      &gsig_SM_ArrShrt_Int_Int_Int_RetVoid,   (LPVOID)CopyToNative )},
    {ECFuncElement("Copy",                      &gsig_SM_ArrInt_Int_Int_Int_RetVoid,     (LPVOID)CopyToNative )},
    {ECFuncElement("Copy",                      &gsig_SM_ArrLong_Int_Int_Int_RetVoid,    (LPVOID)CopyToNative )},
    {ECFuncElement("Copy",                      &gsig_SM_ArrFlt_Int_Int_Int_RetVoid,   (LPVOID)CopyToNative )},
    {ECFuncElement("Copy",                      &gsig_SM_ArrDbl_Int_Int_Int_RetVoid,  (LPVOID)CopyToNative )},
    {ECFuncElement("CopyBytesToManaged",        NULL,                      (LPVOID)CopyToManaged )},
    {ECFuncElement("Copy",                      &gsig_SM_Int_ArrChar_Int_Int_RetVoid,   (LPVOID)CopyToManaged )},
    {ECFuncElement("Copy",                      &gsig_SM_Int_ArrShrt_Int_Int_RetVoid,  (LPVOID)CopyToManaged )},
    {ECFuncElement("Copy",                      &gsig_SM_Int_ArrInt_Int_Int_RetVoid,    (LPVOID)CopyToManaged )},
    {ECFuncElement("Copy",                      &gsig_SM_Int_ArrLong_Int_Int_RetVoid,   (LPVOID)CopyToManaged )},
    {ECFuncElement("Copy",                      &gsig_SM_Int_ArrFlt_Int_Int_RetVoid,  (LPVOID)CopyToManaged )},
    {ECFuncElement("Copy",                      &gsig_SM_Int_ArrDbl_Int_Int_RetVoid, (LPVOID)CopyToManaged )},
    {ECFuncElement("GetExceptionPointers",      NULL,           (LPVOID)ExceptionNative::GetExceptionPointers )},
    {ECFuncElement("GetExceptionCode",          NULL,           (LPVOID)ExceptionNative::GetExceptionCode )},
    {ECFuncElement("GetLoadedTypeForGUID",      NULL,                      (LPVOID)Interop::GetLoadedTypeForGUID )},
    {ECFuncElement("GetITypeInfoForType",       NULL,                      (LPVOID)Interop::GetITypeInfoForType )},
    {ECFuncElement("GetIUnknownForObject",      NULL,                      (LPVOID)Interop::GetIUnknownForObject )},
    {ECFuncElement("GetIDispatchForObject",     NULL,                      (LPVOID)Interop::GetIDispatchForObject )},
    {ECFuncElement("GetComInterfaceForObject",  NULL,                      (LPVOID)Interop::GetComInterfaceForObject )},
    {ECFuncElement("GetObjectForIUnknown",      NULL,                      (LPVOID)Interop::GetObjectForIUnknown )},
    {ECFuncElement("GetSystemMaxDBCSCharSize",  NULL,                      (LPVOID)GetSystemMaxDBCSCharSize) }, /**/
    {ECFuncElement("GetTypedObjectForIUnknown", NULL,                      (LPVOID)Interop::GetTypedObjectForIUnknown) },
    {ECFuncElement("IsComObject",               NULL,                      (LPVOID)Interop::IsComObject )},
    {ECFuncElement("nReleaseComObject",         NULL,                      (LPVOID)Interop::ReleaseComObject )},
    {ECFuncElement("InternalCreateWrapperOfType",      NULL,               (LPVOID)Interop::InternalCreateWrapperOfType )},
    {ECFuncElement("QueryInterface",            NULL,                      (LPVOID)Interop::QueryInterface) },
    {ECFuncElement("AddRef",                    NULL,                      (LPVOID)Interop::AddRef )},
    {ECFuncElement("Release",                   NULL,                      (LPVOID)Interop::Release )},
    {ECFuncElement("GetNativeVariantForManagedVariant",NULL,               (LPVOID)Interop::GetNativeVariantForManagedVariant )},
    {ECFuncElement("GetManagedVariantForNativeVariant",NULL,               (LPVOID)Interop::GetManagedVariantForNativeVariant )},
    {ECFuncElement("GetNativeVariantForObject", NULL,                      (LPVOID)Interop::GetNativeVariantForObject )},
    {ECFuncElement("GetObjectForNativeVariant", NULL,                      (LPVOID)Interop::GetObjectForNativeVariant )},
    {ECFuncElement("GetObjectsForNativeVariants", NULL,                    (LPVOID)Interop::GetObjectsForNativeVariants )},
    {ECFuncElement("PtrToStringAnsi",           NULL,                      (LPVOID)PtrToStringAnsi)},
    {ECFuncElement("PtrToStringUni",            NULL,                      (LPVOID)PtrToStringUni)},
    {FCFuncElement("InternalGetThreadFromFiberCookie",NULL,                (LPVOID)Interop::GetThreadFromFiberCookie )},
    {ECFuncElement("IsTypeVisibleFromCom",      NULL,                      (LPVOID)Interop::IsTypeVisibleFromCom )},
    {ECFuncElement("StructureToPtr",            NULL,                      (LPVOID)StructureToPtr)}, /**/
    {ECFuncElement("PtrToStructureHelper",      NULL,                      (LPVOID)PtrToStructureHelper)}, /**/
    {ECFuncElement("DestroyStructure",          NULL,                      (LPVOID)DestroyStructure)},
    {ECFuncElement("GenerateGuidForType",       NULL,                      (LPVOID)Interop::GenerateGuidForType)},
    {ECFuncElement("GetTypeLibGuidForAssembly", NULL,                      (LPVOID)Interop::GetTypeLibGuidForAssembly)},
    {ECFuncElement("GetUnmanagedThunkForManagedMethodPtr", NULL,           (LPVOID)GetUnmanagedThunkForManagedMethodPtr)},
    {ECFuncElement("GetManagedThunkForUnmanagedMethodPtr", NULL,           (LPVOID)GetManagedThunkForUnmanagedMethodPtr)},
    {ECFuncElement("GetStartComSlot",           NULL,                      (LPVOID)Interop::GetStartComSlot)},
    {ECFuncElement("GetEndComSlot",             NULL,                      (LPVOID)Interop::GetEndComSlot)},
    {ECFuncElement("GetMethodInfoForComSlot",   NULL,                      (LPVOID)Interop::GetMethodInfoForComSlot)},
    {ECFuncElement("GetComSlotForMethodInfo",   NULL,                      (LPVOID)Interop::GetComSlotForMethodInfo)},
    {ECFuncElement("ThrowExceptionForHR",       NULL,                      (LPVOID)Interop::ThrowExceptionForHR)},
    {ECFuncElement("GetHRForException",         NULL,                      (LPVOID)Interop::GetHRForException)},
    {ECFuncElement("_WrapIUnknownWithComObject", NULL, (LPVOID)Interop::WrapIUnknownWithComObject)},
    {ECFuncElement("SwitchCCW", NULL, (LPVOID)Interop::SwitchCCW)},
    {ECFuncElement("ChangeWrapperHandleStrength", NULL, (LPVOID)Interop::ChangeWrapperHandleStrength)},    

    {NULL, NULL, NULL}
};


static
ECFunc gArrayWithOffsetFuncs[] =
{
    {ECFuncElement("CalculateCount",          NULL,                      (LPVOID)CalculateCount )},
    {NULL, NULL, NULL}
};


static
ECFunc gExtensibleClassFactoryFuncs[] =
{
    {ECFuncElement("RegisterObjectCreationCallback", NULL,               (LPVOID)RegisterObjectCreationCallback )},
    {NULL, NULL, NULL}
};

static
ECFunc gTypeLibConverterFuncs[] =
{
    {ECFuncElement("nConvertAssemblyToTypeLib",   NULL,                    (LPVOID)COMTypeLibConverter::ConvertAssemblyToTypeLib)},
    {ECFuncElement("nConvertTypeLibToMetadata",   NULL,                    (LPVOID)COMTypeLibConverter::ConvertTypeLibToMetadata)},
    {NULL, NULL, NULL, NULL}
};

static
ECFunc gRegistrationFuncs[] =
{
    {ECFuncElement("RegisterTypeForComClientsNative",    NULL,             (LPVOID)RegisterTypeForComClientsNative)},
};

static
ECFunc gPolicyManagerFuncs[] =
{
    {ECFuncElement("_InitData", NULL, (LPVOID)COMSecurityConfig::EcallInitData)},
    {ECFuncElement("_InitDataEx", NULL, (LPVOID)COMSecurityConfig::EcallInitDataEx)},
    {ECFuncElement("SaveCacheData", NULL, (LPVOID)COMSecurityConfig::EcallSaveCacheData)},
    {ECFuncElement("ResetCacheData", NULL, (LPVOID)COMSecurityConfig::EcallResetCacheData)},
    {ECFuncElement("ClearCacheData", NULL, (LPVOID)COMSecurityConfig::EcallClearCacheData)},
    {ECFuncElement("_SaveDataString", NULL, (LPVOID)COMSecurityConfig::EcallSaveDataString)},
    {ECFuncElement("_SaveDataByte", NULL, (LPVOID)COMSecurityConfig::EcallSaveDataByte)},
    {ECFuncElement("RecoverData", NULL, (LPVOID)COMSecurityConfig::EcallRecoverData)},
    {ECFuncElement("GetData", NULL, (LPVOID)COMSecurityConfig::GetRawData)},
    {ECFuncElement("GenerateFilesAutomatically", NULL, (LPVOID)COMSecurityConfig::EcallGenerateFilesAutomatically)},
    {ECFuncElement("GetQuickCacheEntry", NULL, (LPVOID)COMSecurityConfig::EcallGetQuickCacheEntry)},
    {ECFuncElement("SetQuickCache", NULL, (LPVOID)COMSecurityConfig::EcallSetQuickCache)},
    {ECFuncElement("GetCacheEntry", NULL, (LPVOID)COMSecurityConfig::GetCacheEntry)},
    {ECFuncElement("AddCacheEntry", NULL, (LPVOID)COMSecurityConfig::AddCacheEntry)},
    {ECFuncElement("TurnCacheOff", NULL, (LPVOID)COMSecurityConfig::EcallTurnCacheOff)},
    {ECFuncElement("_GetMachineDirectory", NULL, (LPVOID)COMSecurityConfig::EcallGetMachineDirectory)},
    {ECFuncElement("_GetUserDirectory", NULL, (LPVOID)COMSecurityConfig::EcallGetUserDirectory)},
    {ECFuncElement("WriteToEventLog", NULL, (LPVOID)COMSecurityConfig::EcallWriteToEventLog)},
    {ECFuncElement("_GetStoreLocation", NULL, (LPVOID)COMSecurityConfig::EcallGetStoreLocation)},
    {ECFuncElement("GetCacheSecurityOn", NULL, (LPVOID)COMSecurityConfig::GetCacheSecurityOn)},
    {ECFuncElement("SetCacheSecurityOn", NULL, (LPVOID)COMSecurityConfig::SetCacheSecurityOn)},
    {ECFuncElement("_DebugOut", NULL, (LPVOID)COMSecurityConfig::DebugOut)},
    {NULL, NULL, NULL}
};

static
ECFunc gPrincipalFuncs[] =
{
    {FCFuncElement("_DuplicateHandle", NULL, (LPVOID)COMPrincipal::DuplicateHandle)},
    {FCFuncElement("_CloseHandle", NULL, (LPVOID)COMPrincipal::CloseHandle)},
    {FCFuncElement("_GetAccountType", NULL, (LPVOID)COMPrincipal::GetAccountType)},
    {FCFuncElement("_S4ULogon", NULL, (LPVOID)COMPrincipal::S4ULogon)},
    {ECFuncElement("_ResolveIdentity", NULL, (LPVOID)COMPrincipal::ResolveIdentity)},
    {ECFuncElement("_GetRoles", NULL, (LPVOID)COMPrincipal::GetRoles)},
    {ECFuncElement("_GetCurrentToken", NULL, (LPVOID)COMPrincipal::GetCurrentToken)},
    {ECFuncElement("_SetThreadToken", NULL, (LPVOID)COMPrincipal::SetThreadToken)},
    {ECFuncElement("_ImpersonateLoggedOnUser", NULL, (LPVOID)COMPrincipal::ImpersonateLoggedOnUser)},
    {ECFuncElement("_RevertToSelf", NULL, (LPVOID)COMPrincipal::RevertToSelf)},
    {ECFuncElement("_GetRole", NULL, (LPVOID)COMPrincipal::GetRole)},
    {NULL, NULL, NULL}
};

static
ECFunc gHashFuncs[] =
{
    {ECFuncElement("_GetRawData", NULL, (LPVOID)COMHash::GetRawData)},
    {NULL, NULL, NULL}
};

static
ECFunc gIsolatedStorage[] =
{
    {ECFuncElement("nGetCaller", NULL, (LPVOID)COMIsolatedStorage::GetCaller)},
    {NULL, NULL, NULL}
};

static
ECFunc gIsolatedStorageFile[] =
{
    {ECFuncElement("nGetRootDir", NULL, (LPVOID)COMIsolatedStorageFile::GetRootDir)},
    {ECFuncElement("nReserve", NULL, (LPVOID)COMIsolatedStorageFile::Reserve)},
    {ECFuncElement("nGetUsage", NULL, (LPVOID)COMIsolatedStorageFile::GetUsage)},
    {ECFuncElement("nOpen", NULL, (LPVOID)COMIsolatedStorageFile::Open)},
    {ECFuncElement("nClose", NULL, (LPVOID)COMIsolatedStorageFile::Close)},
    {ECFuncElement("nLock", NULL, (LPVOID)COMIsolatedStorageFile::Lock)},
    {NULL, NULL, NULL}
};

static
ECFunc  gTypeLoadExceptionFuncs[] =
{
    {ECFuncElement("FormatTypeLoadExceptionMessage", NULL, (LPVOID)FormatTypeLoadExceptionMessage)},
    {NULL, NULL, NULL}
};

static
ECFunc  gFileLoadExceptionFuncs[] =
{
    {ECFuncElement("FormatFileLoadExceptionMessage", NULL, (LPVOID)FormatFileLoadExceptionMessage)},
    {NULL, NULL, NULL}
};

static
ECFunc  gSignatureHelperFuncs[] =
{
    {FCFuncElement("GetCorElementTypeFromClass", NULL, (LPVOID)COMModule::GetSigTypeFromClassWrapper)}, /**/
    {NULL, NULL, NULL}
};


static
ECFunc  gMissingMethodExceptionFuncs[] =
{
    {ECFuncElement("FormatSignature", NULL, (LPVOID)MissingMethodException_FormatSignature)},
    {NULL, NULL, NULL}
};

static
ECFunc gInterlockedFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("Increment",              &gsig_SM_RefInt_RetInt,                      (LPVOID)COMInterlocked::Increment32 )},
    {FCFuncElement("Decrement",              &gsig_SM_RefInt_RetInt,                      (LPVOID)COMInterlocked::Decrement32)},
    {FCFuncElement("Increment",              &gsig_SM_RefLong_RetLong,                    (LPVOID)COMInterlocked::Increment64 )},
    {FCFuncElement("Decrement",              &gsig_SM_RefLong_RetLong,                    (LPVOID)COMInterlocked::Decrement64)},
    {FCFuncElement("Exchange",               &gsig_SM_RefInt_Int_RetInt,           (LPVOID)COMInterlocked::Exchange)},
    {FCFuncElement("CompareExchange",        &gsig_SM_RefInt_Int_Int_RetInt,    (LPVOID)COMInterlocked::CompareExchange)},
    {FCFuncElement("Exchange",               &gsig_SM_RefFlt_Flt_RetFlt,         (LPVOID)COMInterlocked::ExchangeFloat)},
    {FCFuncElement("CompareExchange",        &gsig_SM_RefFlt_Flt_Flt_RetFlt,  (LPVOID)COMInterlocked::CompareExchangeFloat)},
    {FCFuncElement("Exchange",               &gsig_SM_RefObj_Obj_RetObj,        (LPVOID)COMInterlocked::ExchangeObject)},
    {FCFuncElement("CompareExchange",        &gsig_SM_RefObj_Obj_Obj_RetObj, (LPVOID)COMInterlocked::CompareExchangeObject)},
#else
    {ECFuncElement("Increment",               NULL,                      (LPVOID)COMInterlocked::Increment )},
    {ECFuncElement("Decrement",               NULL,                      (LPVOID)COMInterlocked::Decrement)},
    {ECFuncElement("Exchange",                &gsig_SM_RefInt_Int_RetInt,           (LPVOID)COMInterlocked::Exchange)},
    {ECFuncElement("CompareExchange",         &gsig_SM_RefInt_Int_Int_RetInt,    (LPVOID)COMInterlocked::CompareExchange)},
    {ECFuncElement("Exchange",                &gsig_SM_RefFlt_Flt_RetFlt,         (LPVOID)COMInterlocked::ExchangeFloat)},
    {ECFuncElement("CompareExchange",         &gsig_SM_RefFlt_Flt_Flt_RetFlt,  (LPVOID)COMInterlocked::CompareExchangeFloat)},
    {ECFuncElement("Exchange",                &gsig_SM_RefObj_Obj_RetObj,        (LPVOID)COMInterlocked::ExchangeObject)},
    {ECFuncElement("CompareExchange",         &gsig_SM_RefObj_Obj_Obj_RetObj, (LPVOID)COMInterlocked::CompareExchangeObject)},
#endif
    {NULL, NULL, NULL}
};

static
ECFunc gVarArgFuncs[] =
{
    //{ECFuncElement(COR_CTOR_METHOD_NAME,    &gsig_IM_Int_RetVoid,                      (LPVOID)COMVarArgs::Init)},
    {ECFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_Int_Int_RetVoid,                  (LPVOID)COMVarArgs::Init2)},
    {ECFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_RuntimeArgumentHandle_RetVoid,    (LPVOID)COMVarArgs::Init)},
    {ECFuncElement(COR_CTOR_METHOD_NAME,      &gsig_IM_RuntimeArgumentHandle_PtrVoid_RetVoid,    (LPVOID)COMVarArgs::Init2)},
    {ECFuncElement("GetRemainingCount",       NULL,                       (LPVOID)COMVarArgs::GetRemainingCount)},
    {ECFuncElement("GetNextArgType",          NULL,                       (LPVOID)COMVarArgs::GetNextArgType)},
    {ECFuncElement("GetNextArg",              NULL,   (LPVOID)COMVarArgs::GetNextArg)},
    {ECFuncElement("InternalGetNextArg",      NULL,   (LPVOID)COMVarArgs::GetNextArg2)},
    {NULL, NULL, NULL}
};


static
ECFunc gMonitorFuncs[] =
{
#ifdef FCALLAVAILABLE
    {FCFuncElement("Enter",                  NULL,                       (LPVOID)JIT_MonEnter )},
    {FCFuncElement("Exit",                   NULL,                       (LPVOID)JIT_MonExit )},
    {FCFuncElement("TryEnterTimeout",        NULL,                       (LPVOID)JIT_MonTryEnter )},
#else
    {ECFuncElement("Enter",                   NULL,                       (LPVOID)MonitorNative::Enter)},
    {ECFuncElement("Exit",                    NULL,                       (LPVOID)MonitorNative::Exit)},
    {ECFuncElement("TryEnterTimeout",         NULL,                       (LPVOID)MonitorNative::TryEnter)},
#endif
    {ECFuncElement("ObjWait",   NULL, (LPVOID)ObjectNative::WaitTimeout)},
    {ECFuncElement("ObjPulse",    NULL,(LPVOID)ObjectNative::Pulse)},
    {ECFuncElement("ObjPulseAll",   NULL, (LPVOID)ObjectNative::PulseAll)},
    {NULL, NULL, NULL}

};

static
ECFunc gOverlappedFuncs[] =
{
    {FCFuncElement("AllocNativeOverlapped",   NULL,                       (LPVOID)AllocNativeOverlapped )},
    {FCFuncElement("FreeNativeOverlapped",   NULL,                       (LPVOID)FreeNativeOverlapped )},
    {NULL, NULL, NULL}
};

static
ECFunc gCompilerFuncs[] =
{
    {FCFuncElement("GetObjectValue", NULL, (LPVOID)ObjectNative::GetObjectValue)},
    {FCFuncElement("InitializeArray",   NULL, (LPVOID)COMArrayInfo::InitializeArray )},
    {FCFuncElement("RunClassConstructor",   NULL, (LPVOID)COMClass::RunClassConstructor )},
    {FCFuncElement("GetHashCode",   NULL, (LPVOID)ObjectNative::GetHashCode )},
    {FCFuncElement("Equals",   NULL, (LPVOID)ObjectNative::Equals )},
    {NULL, NULL, NULL}
};

static
ECFunc gStrongNameKeyPairFuncs[] =
{
    {ECFuncElement("nGetPublicKey",             NULL,                       (LPVOID)Security::GetPublicKey )},
    {NULL, NULL, NULL}
};

static
ECFunc gCoverageFuncs[] =
{
    {ECFuncElement("nativeCoverBlock",             NULL,                       (LPVOID)COMCoverage::nativeCoverBlock )},
    {NULL, NULL, NULL}
};


static
ECFunc gGCHandleFuncs[] =
{
    {FCFuncElement("InternalAlloc", NULL,     (LPVOID)GCHandleInternalAlloc)},
    {FCFuncElement("InternalFree", NULL,     (LPVOID)GCHandleInternalFree)},
    {FCFuncElement("InternalGet", NULL,     (LPVOID)GCHandleInternalGet)},
    {FCFuncElement("InternalSet", NULL,     (LPVOID)GCHandleInternalSet)},
    {FCFuncElement("InternalCompareExchange", NULL,     (LPVOID)GCHandleInternalCompareExchange)},
    {FCFuncElement("InternalAddrOfPinnedObject", NULL, (LPVOID)GCHandleInternalAddrOfPinnedObject)},
    {FCFuncElement("InternalCheckDomain", NULL,     (LPVOID)GCHandleInternalCheckDomain)},
    {NULL, NULL, NULL}
};

static
ECFunc gConfigHelper[] =
{
    {ECFuncElement("GetHelper",            NULL, (LPVOID)ConfigNative::GetHelper)},
    {NULL, NULL, NULL}
};

//
// ECall helpers for the standard managed interfaces.
//

#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
\
static \
ECFunc g##FriendlyName##Funcs[] = \
{

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig) \
    {ECFuncElement(#MethName, MethSig, (LPVOID)FriendlyName::ECallMethName)},

#define MNGSTDITF_END_INTERFACE(FriendlyName) \
{NULL, NULL, NULL} \
};

#include "MngStdItfList.h"

#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE


#define ECClassesElement(A,B,C) A, B, C

// Note these have to remain sorted by name:namespace pair (Assert will wack you if you dont)
static
ECClass gECClasses[] =
{
    {ECClassesElement("AppDomain", "System", gAppDomainFuncs)},
    {ECClassesElement("AppDomainSetup", "System", gAppDomainSetupFuncs)},
    {ECClassesElement("ArgIterator", "System", gVarArgFuncs)},
    {ECClassesElement("Array", "System", gArrayFuncs)},
    {ECClassesElement("ArrayWithOffset", "System.Runtime.InteropServices", gArrayWithOffsetFuncs)},
    {ECClassesElement("Assembly", "System.Reflection", gAssemblyFuncs)},
    {ECClassesElement("AssemblyName", "System.Reflection", gAssemblyNameFuncs)},
    {ECClassesElement("Assert", "System.Diagnostics", gDiagnosticsAssert)},
    // @perf: Remove the AsyncFileStreamProto entry before we ship.
    {ECClassesElement("AsyncFileStreamProto", "System.IO", gFileStreamFuncs)},
    {ECClassesElement("AutoResetEvent", "System.Threading", gAutoResetEventFuncs)},
    {ECClassesElement("BCLDebug", "System", gBCLDebugFuncs)},
    {ECClassesElement("BitConverter", "System", gBitConverterFuncs)},
    {ECClassesElement("Buffer", "System", gBufferFuncs)},
    {ECClassesElement("Calendar", "System.Globalization", gCalendarFuncs)},
    {ECClassesElement("CalendarTable", "System.Globalization", gCalendarTableFuncs)},
    {ECClassesElement("ChannelServices", "System.Runtime.Remoting.Channels", gChannelServicesFuncs)},
    {ECClassesElement("Char", "System", gCharacterFuncs)},
    {ECClassesElement("CharacterInfo", "System.Globalization", gCharacterInfoFuncs)},
    {ECClassesElement("CloningFormatter", "System.Runtime.Serialization", gCloningFuncs)},
    {ECClassesElement("CodeAccessSecurityEngine", "System.Security", gCOMCodeAccessSecurityEngineFuncs)},
    {ECClassesElement("CodePageEncoding", "System.Text", gCodePageEncodingFuncs)},
    {ECClassesElement("CompareInfo", "System.Globalization", gCompareInfoFuncs)},
    {ECClassesElement("Config", "System.Security.Util", gPolicyManagerFuncs)},
    {ECClassesElement("ConfigServer", "System", gConfigHelper)},
    {ECClassesElement("Console", "System", gConsoleFuncs)},
    {ECClassesElement("Context", "System.Runtime.Remoting.Contexts", gContextFuncs)},
    {ECClassesElement("Convert", "System", gConvertFuncs)},
    {ECClassesElement("CryptoAPITransform", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("CultureInfo", "System.Globalization", gCultureInfoFuncs)},
    {ECClassesElement("CultureTable", "System.Globalization", gCultureTableFuncs)},
    {ECClassesElement("Currency", "System", gCurrencyFuncs)},
    {ECClassesElement("CurrentSystemTimeZone", "System", gTimeZoneFuncs)},
    {ECClassesElement("CustomAttribute", "System.Reflection", gCOMCustomAttributeFuncs)},
    {ECClassesElement("DESCryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("DSACryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("DateTime", "System", gDateTimeFuncs)},
    {ECClassesElement("Debugger", "System.Diagnostics", gDiagnosticsDebugger)},
    {ECClassesElement("Decimal", "System", gDecimalFuncs)},
    {ECClassesElement("DefaultBinder", "System", gCOMDefaultBinderFuncs)},
    {ECClassesElement("Delegate", "System", gDelegateFuncs)},
    {ECClassesElement("Double", "System", gDoubleFuncs)},
    {ECClassesElement("EncodingTable", "System.Globalization", gEncodingTableFuncs)},
    {ECClassesElement("Enum", "System", gEnumFuncs)},
    {ECClassesElement("Environment", "System", gEnvironmentFuncs)},
    {ECClassesElement("Exception", "System", gExceptionFuncs)},
    {ECClassesElement("ExtensibleClassFactory", "System.Runtime.InteropServices", gExtensibleClassFactoryFuncs)},
    {ECClassesElement("FileIOAccess", "System.Security.Permissions", gCOMFileIOAccessFuncs)},
    {ECClassesElement("FileLoadException", "System.IO", gFileLoadExceptionFuncs)},
    {ECClassesElement("FileStream", "System.IO", gFileStreamFuncs)},
    {ECClassesElement("FormatterServices", "System.Runtime.Serialization", gSerializationFuncs)},
    {ECClassesElement("FrameSecurityDescriptor", "System.Security", gCOMCodeAccessSecurityEngineFuncs)},
    {ECClassesElement("GB18030Encoding", "System.Text", gGB18030EncodingFuncs)},
    {ECClassesElement("GC", "System", gGCInterfaceFuncs)},
    {ECClassesElement("GCHandle", "System.Runtime.InteropServices", gGCHandleFuncs)},
    {ECClassesElement("GlobalizationAssembly", "System.Globalization", gGlobalizationAssemblyFuncs)},
    {ECClassesElement("Guid", "System", gGuidFuncs)},
    {ECClassesElement("Hash", "System.Security.Policy", gHashFuncs)},
    {ECClassesElement("IEnumerable", "System.Collections", gStdMngIEnumerableFuncs)},
    {ECClassesElement("IEnumerator", "System.Collections", gStdMngIEnumeratorFuncs)},
    {ECClassesElement("IExpando", "System.Runtime.InteropServices.Expando", gStdMngIExpandoFuncs)},
    {ECClassesElement("ILCover", "System.Coverage", gCoverageFuncs)},
    {ECClassesElement("IReflect", "System.Reflection", gStdMngIReflectFuncs)},
    {ECClassesElement("Interlocked", "System.Threading", gInterlockedFuncs)},
    {ECClassesElement("IsolatedStorage", "System.IO.IsolatedStorage", gIsolatedStorage)},
    {ECClassesElement("IsolatedStorageFile", "System.IO.IsolatedStorage", gIsolatedStorageFile)},
    {ECClassesElement("Log", "System.Diagnostics", gDiagnosticsLog)},
    {ECClassesElement("MD5CryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("MLangCodePageEncoding", "System.Text", gMLangCodePageEncodingFuncs)},
    {ECClassesElement("MTSPrincipal", "System.Security.Principal", gPrincipalFuncs)},
    {ECClassesElement("ManualResetEvent", "System.Threading", gManualResetEventFuncs)},
    {ECClassesElement("Marshal", "System.Runtime.InteropServices", gInteropMarshalFuncs)},
    {ECClassesElement("MarshalByRefObject", "System", gMarshalByRefFuncs)},
    {ECClassesElement("Math", "System", gMathFuncs)},

    {ECClassesElement("Message", "System.Runtime.Remoting.Messaging", gMessageFuncs)},
    {ECClassesElement("MethodRental", "System.Reflection.Emit", gCOMMethodRental)},
    {ECClassesElement("MissingFieldException", "System",  gMissingMethodExceptionFuncs)},
    {ECClassesElement("MissingMethodException", "System", gMissingMethodExceptionFuncs)},
    {ECClassesElement("Module", "System.Reflection", gCOMModuleFuncs)},
    {ECClassesElement("Monitor", "System.Threading", gMonitorFuncs)},
    {ECClassesElement("Mutex", "System.Threading", gMutexFuncs)},
    {ECClassesElement("Number", "System", gNumberFuncs)},
        // NOTENOTE yslin: if we need native NLSDataTable, uncomment this line.
//  {ECClassesElement("NLSDataTable", "System.Globalization", gNLSDataTableFuncs)},
    {ECClassesElement("OAVariantLib", "Microsoft.Win32", gOAVariantFuncs)},
    {ECClassesElement("Object", "System", gObjectFuncs)},
    {ECClassesElement("Overlapped", "System.Threading", gOverlappedFuncs)},
    {ECClassesElement("ParseNumbers", "System", gParseNumbersFuncs)},
    {ECClassesElement("PasswordDeriveBytes", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("Path", "System.IO", gPathFuncs)},
    {ECClassesElement("PolicyLevel", "System.Security.Policy", gPolicyManagerFuncs)},
    {ECClassesElement("PolicyManager", "System.Security", gPolicyManagerFuncs)},
    {ECClassesElement("RC2CryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("RNGCryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
#ifdef RSA_NATIVE
    {ECClassesElement("RSANative", "System.Security.Cryptography", gRSANativeFuncs)},
#endif // RSA_NATIVE
    {ECClassesElement("RSACryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("ReaderWriterLock", "System.Threading", gRWLockFuncs)},
    {ECClassesElement("RealProxy", "System.Runtime.Remoting.Proxies", gRealProxyFuncs)},
    {ECClassesElement("RegionTable", "System.Globalization", gRegionTableFuncs)},
    {ECClassesElement("RegisteredWaitHandle", "System.Threading", gRegisteredWaitHandleFuncs)},
    {ECClassesElement("RegistrationServices", "System.Runtime.InteropServices", gRegistrationFuncs)},
    {ECClassesElement("RemotingServices", "System.Runtime.Remoting", gRemotingFuncs)},
    {ECClassesElement("RuntimeConstructorInfo", "System.Reflection", gCOMConstructorFuncs)},
    {ECClassesElement("RuntimeEnvironment", "System.Runtime.InteropServices", gRuntimeEnvironmentFuncs)},
    {ECClassesElement("RuntimeEventInfo", "System.Reflection", gCOMEventFuncs)},
    {ECClassesElement("RuntimeFieldInfo", "System.Reflection", gCOMFieldFuncs)},
    {ECClassesElement("RuntimeHelpers", "System.Runtime.CompilerServices", gCompilerFuncs)},
    {ECClassesElement("RuntimeMethodHandle", "System", gCOMMethodHandleFuncs)},
    {ECClassesElement("RuntimeMethodInfo", "System.Reflection", gCOMMethodFuncs)},
    {ECClassesElement("RuntimePropertyInfo", "System.Reflection", gCOMPropFuncs)},
    {ECClassesElement("RuntimeType", "System", gCOMClassFuncs)},
    {ECClassesElement("SHA1CryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("SecurityManager", "System.Security", gCOMSecurityManagerFuncs)},
    {ECClassesElement("SecurityRuntime", "System.Security", gCOMSecurityRuntimeFuncs)},
    {ECClassesElement("SignatureHelper", "System.Reflection.Emit", gSignatureHelperFuncs)},
    {ECClassesElement("Single", "System", gFloatFuncs)},
    {ECClassesElement("SortKey", "System.Globalization", gSortKeyFuncs)},
    {ECClassesElement("StackBuilderSink", "System.Runtime.Remoting.Messaging", gStackBuilderSinkFuncs)},
    {ECClassesElement("StackTrace", "System.Diagnostics", gDiagnosticsStackTrace)},
    {ECClassesElement("String", "System", gStringFuncs)},
    {ECClassesElement("StringBuilder", "System.Text", gStringBufferFuncs)},
    {ECClassesElement("StringExpressionSet", "System.Security.Util", gCOMStringExpressionSetFuncs)},
    {ECClassesElement("StrongNameKeyPair", "System.Reflection", gStrongNameKeyPairFuncs)},
    {ECClassesElement("TextInfo", "System.Globalization", gTextInfoFuncs)},
    {ECClassesElement("Thread", "System.Threading", gThreadFuncs)},
    {ECClassesElement("ThreadPool", "System.Threading", gThreadPoolFuncs)},
    {ECClassesElement("Timer", "System.Threading", gTimerFuncs)},
    {ECClassesElement("TripleDESCryptoServiceProvider", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("Type", "System", gCOMClassFuncs)},
    {ECClassesElement("TypeBuilder", "System.Reflection.Emit", gCOMClassWriter)},
    {ECClassesElement("TypeLibConverter", "System.Runtime.InteropServices", gTypeLibConverterFuncs)},
    {ECClassesElement("TypeLoadException", "System", gTypeLoadExceptionFuncs)},
    {ECClassesElement("TypedReference", "System", gTypedReferenceFuncs)},
    {ECClassesElement("URLString", "System.Security.Util", gCOMUrlStringFuncs)},
    {ECClassesElement("ValueType", "System", gValueTypeFuncs)},
    {ECClassesElement("Variant", "System", gVariantFuncs)},
    {ECClassesElement("WaitHandle", "System.Threading", gWaitHandleFuncs)},
    {ECClassesElement("WindowsIdentity", "System.Security.Principal", gPrincipalFuncs)},
    {ECClassesElement("WindowsImpersonationContext", "System.Security.Principal", gPrincipalFuncs)},
    {ECClassesElement("WindowsPrincipal", "System.Security.Principal", gPrincipalFuncs)},
    {ECClassesElement("X509Certificate", "System.Security.Cryptography.X509Certificates", gX509CertificateFuncs)},
    {ECClassesElement("Zone", "System.Security.Policy", gCOMSecurityZone)},
    {ECClassesElement("__CSPHandleProtector", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("__HashHandleProtector", "System.Security.Cryptography", gCryptographicFuncs)},
    {ECClassesElement("__KeyHandleProtector", "System.Security.Cryptography", gCryptographicFuncs)},
};

    // To provide a quick check, this is the lowest and highest
    // addresses of any FCALL starting address
static BYTE* gLowestFCall = (BYTE*)-1;
static BYTE* gHighestFCall = 0;

#define FCALL_HASH_SIZE 256
static ECFunc* gFCallMethods[FCALL_HASH_SIZE];
static SpinLock gFCallLock;

inline unsigned FCallHash(const void* pTarg) {
    return (unsigned)((((size_t) pTarg) / 4)  % FCALL_HASH_SIZE);
}

inline ECFunc** getCacheEntry(MethodDesc* pMD) {
#define BYMD_CACHE_SIZE 32
    _ASSERTE(((BYMD_CACHE_SIZE-1) & BYMD_CACHE_SIZE) == 0);     // Must be a power of 2
    static ECFunc* gByMDCache[BYMD_CACHE_SIZE];
    return &gByMDCache[((((size_t) pMD) >> 3) & BYMD_CACHE_SIZE-1)];
}

/*******************************************************************************/
USHORT FindImplsIndexForClass(MethodTable* pMT)
{
    LPCUTF8 pszNamespace = 0;
    LPCUTF8 pszName = pMT->GetClass()->GetFullyQualifiedNameInfo(&pszNamespace);

    // Array classes get null from the above routine, but they have no ecalls.
    if (pszName == NULL)
        return(-1);

    unsigned low  = 0;
    unsigned high = sizeof(gECClasses)/sizeof(ECClass);

#ifdef _DEBUG
    static bool checkedSort = false;
    LPCUTF8 prevClass = "";
    LPCUTF8 prevNameSpace = "";
    if (!checkedSort) {
        checkedSort = true;
        for (unsigned i = 0; i < high; i++)  {
                // Make certain list is sorted!
            int cmp = strcmp(gECClasses[i].m_wszClassName, prevClass);
            if (cmp == 0)
                cmp = strcmp(gECClasses[i].m_wszNameSpace, prevNameSpace);
            _ASSERTE(cmp > 0);      // Hey, you forgot to sort the new class

            prevClass = gECClasses[i].m_wszClassName;
            prevNameSpace = gECClasses[i].m_wszNameSpace;
        }
    }
#endif
    while (high > low) {
        unsigned mid  = (high + low) / 2;
        int cmp = strcmp(pszName, gECClasses[mid].m_wszClassName);
        if (cmp == 0)
            cmp = strcmp(pszNamespace, gECClasses[mid].m_wszNameSpace);

        if (cmp == 0) {
            return(mid);
        }
        if (cmp > 0)
            low = mid+1;
        else
            high = mid;
        }

    return(-1);
}

ECFunc* GetImplsForIndex(USHORT index)
{
    if (index == (USHORT) -1)
        return NULL;
    else
        return gECClasses[index].m_pECFunc;        
}

ECFunc* FindImplsForClass(MethodTable* pMT)
{
    return GetImplsForIndex(FindImplsIndexForClass(pMT));
}


/*******************************************************************************/
/*  Finds the implementation for the given method desc.  */

static ECFunc *GetECForIndex(USHORT index, ECFunc *impls)
{
    if (index == (USHORT) -1)
        return NULL;
    else
        return impls + index;
}

static USHORT FindECIndexForMethod(MethodDesc *pMD, ECFunc *impls)
{
    ECFunc* cur = impls;

    LPCUTF8 szMethodName = pMD->GetName();
    PCCOR_SIGNATURE pMethodSig;
    ULONG       cbMethodSigLen;
    pMD->GetSig(&pMethodSig, &cbMethodSigLen);
    Module* pModule = pMD->GetModule();

    for (;cur->m_wszMethodName != 0; cur++)  {
        if (strcmp(cur->m_wszMethodName, szMethodName) == 0) {
            if (cur->m_wszMethodSig != NULL) {
                PCCOR_SIGNATURE pBinarySig;
                ULONG       pBinarySigLen;
                if (FAILED(cur->m_wszMethodSig->GetBinaryForm(&pBinarySig, &pBinarySigLen)))
                    continue;
                if (!MetaSig::CompareMethodSigs(pMethodSig, cbMethodSigLen, pModule,
                                                pBinarySig, pBinarySigLen, cur->m_wszMethodSig->GetModule()))
                    continue;
            }
            // We have found a match!

            return (USHORT)(cur - impls);
        }
    }
    return (USHORT)-1;
}

static ECFunc* FindECFuncForMethod(MethodDesc* pMD)
{
    // check the cache
    ECFunc**cacheEntry = getCacheEntry(pMD);
    ECFunc* cur = *cacheEntry;
    if (cur != 0 && cur->m_pMD == pMD)
        return(cur);

    cur = FindImplsForClass(pMD->GetMethodTable());
    if (cur == 0)
        return(0);

    cur = GetECForIndex(FindECIndexForMethod(pMD, cur), cur);
    if (cur == 0)
        return(0);

    *cacheEntry = cur;                          // put in the cache
    return cur;
}


/*******************************************************************************/
/* ID is formed of 2 USHORTs - class index in high word, method index in low word.  */

#define NO_IMPLEMENTATION 0xffff // No class will have this many ecall methods

ECFunc *FindECFuncForID(DWORD id)
{
    if (id == NO_IMPLEMENTATION)
        return NULL;

    USHORT ImplsIndex = (USHORT) (id >> 16);
    USHORT ECIndex = (USHORT) (id & 0xffff);

    return GetECForIndex(ECIndex, GetImplsForIndex(ImplsIndex));
}

DWORD GetIDForMethod(MethodDesc *pMD)
{
    USHORT ImplsIndex = FindImplsIndexForClass(pMD->GetMethodTable());
    if (ImplsIndex == (USHORT) -1)
        return NO_IMPLEMENTATION;
    USHORT ECIndex = FindECIndexForMethod(pMD, GetImplsForIndex(ImplsIndex));
    if (ECIndex == (USHORT) -1)
        return NO_IMPLEMENTATION;

    return (ImplsIndex<<16) | ECIndex;
}


/*******************************************************************************/
/* returns 0 if it is an ECALL, otherwise returns the native entry point (FCALL) */

void* FindImplForMethod(MethodDesc* pMD)  {

    DWORD rva = pMD->GetRVA();
    
    ECFunc* ret;
    if (rva == 0)
        ret = FindECFuncForMethod(pMD);
    else
    {
        _ASSERTE(pMD->GetModule()->IsPreload());
        ret = FindECFuncForID(rva);
    }

    if (ret == 0)
        return(0);

    ret->m_pMD = pMD;                               // remember for reverse mapping

    if (ret->IsFCall()) {
        // Add to the reverse mapping table for FCalls.
        pMD->SetFCall(true);
        gFCallLock.GetLock();
        if(gLowestFCall > ret->m_pImplementation)
            gLowestFCall = (BYTE*) ret->m_pImplementation;
        if(gHighestFCall < ret->m_pImplementation)
            gHighestFCall = (BYTE*) ret->m_pImplementation;

        // add to hash table, makeing sure I am not already there
        ECFunc** spot = &gFCallMethods[FCallHash(ret->m_pImplementation)];
        for(;;) {
            if (*spot == 0) {                   // found end of list
                *spot = ret;
                _ASSERTE(ret->m_pNext == 0);
                break;
            }
            if (*spot == ret)                   // already in list
                break;
            spot = &(*spot)->m_pNext;
        }
        gFCallLock.FreeLock();
    }

    pMD->SetAddrofCode((BYTE*) ret->m_pImplementation);
    if (!ret->IsFCall())
        return(0);
    return(ret->m_pImplementation);
}

/************************************************************************
 * NDirect.SizeOf(Object)
 */

#ifdef FCALLAVAILABLE

FCIMPL1(VOID, FCComCtor, LPVOID pV)
{
}
FCIMPLEND

#else

struct _ComCtorObjectArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, or);
};

VOID __stdcall ComCtor(struct _ComCtorObjectArgs *args)
{
}
#endif

ArgBasedStubCache *ECall::m_pECallStubCache = NULL;


/* static */
BOOL ECall::Init()
{
    m_pECallStubCache = new ArgBasedStubCache(ArgBasedStubCache::NUMFIXEDSLOTS << 1);
    if (!m_pECallStubCache) {
        return FALSE;
    }

    m_pArrayStubCache = new ArrayStubCache();
    if (!m_pArrayStubCache) {
        return FALSE;
    }

    //In order for our code that sets up the fast string allocator to work,
    //this FastAllocateString must always be the first method in gStringFuncs.
    //Code in JitInterfacex86.cpp assigns the value to m_pImplementation after
    //that code has been dynamically generated.
#ifdef _X86_
    //
    // @TODO_IA64: when we have a fast string allocator on IA64, we need to
    // reenable this assert
    //
    _ASSERTE(strcmp(gStringFuncs[0].m_wszMethodName ,"FastAllocateString")==0);

    // If allocation logging is on, then calls to FastAllocateString are diverted to this ecall
    // method. This allows us to log the allocation, something that the earlier fcall didnt.
    if (
#ifdef PROFILING_SUPPORTED
        CORProfilerTrackAllocationsEnabled() || 
#endif
        LoggingOn(LF_GCALLOC, LL_INFO10))
    {
        gStringFuncs[0].m_isFCall = 0;
        gStringFuncs[0].m_pImplementation = COMString::SlowAllocateString;
    }
#endif // _X86_

    gFCallLock.Init(LOCK_FCALL);
    return TRUE;
}

/* static */
#ifdef SHOULD_WE_CLEANUP
VOID ECall::Terminate()
{
    delete m_pArrayStubCache;
    delete m_pECallStubCache;
}
#endif /* SHOULD_WE_CLEANUP */


/* static */
ECFunc* ECall::FindTarget(const void* pTarg)
{
    // Could this possibily be an FCall?
    if (pTarg < gLowestFCall || pTarg > gHighestFCall)
        return(NULL);

    ECFunc *pECFunc = gFCallMethods[FCallHash(pTarg)];
    while (pECFunc != 0) {
        if (pECFunc->m_pImplementation == pTarg)
            return pECFunc;
        pECFunc = pECFunc->m_pNext;
    }
    return NULL;
}

MethodDesc* MapTargetBackToMethod(const void* pTarg)
{
    ECFunc *info = ECall::FindTarget(pTarg);
    if (info == 0)
        return(0);
    return(info->m_pMD);
}

/* static */
CorInfoIntrinsics ECall::IntrinsicID(MethodDesc* pMD)
{
    ECFunc* info = FindTarget(pMD->GetAddrofCode());    // fast hash lookup
    if (info == 0)
        info = FindECFuncForMethod(pMD);                // try slow path

    if (info == 0)
        return(CORINFO_INTRINSIC_Illegal);
    return(info->IntrinsicID());
}

/* static */
Stub *ECall::GetECallMethodStub(StubLinker *pstublinker, ECallMethodDesc *pMD)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(!pMD->IsSynchronized());

    // COM imported classes have special constructors
    MethodTable* pMT = pMD->GetMethodTable();

    if (pMT->IsArray())
    {
        Stub *pstub = GenerateArrayOpStub((CPUSTUBLINKER*)pstublinker, (ArrayECallMethodDesc*)pMD);
        _ASSERTE(pstub != 0);   // Should handle all cases now.
        return pstub;
    }

    if (pMT->IsComObjectType())
    {
        // verify the method is a constructor
        _ASSERTE(pMD->IsCtor());

#ifdef FCALLAVAILABLE
        {
            //@perf: Right now, we're still going thru an unnecessary double-call:
            // should backpatch the target function directly into the vtable
            // like a JITted method.

#ifdef _X86_
            ((CPUSTUBLINKER*)pstublinker)->X86EmitAddEsp(4);  // Throw away unwanted methoddesc.
            ((CPUSTUBLINKER*)pstublinker)->X86EmitNearJump(pstublinker->NewExternalCodeLabel(FCComCtor));
#else
            _ASSERTE(!"NYI");
#endif
        }
#else
        {
            pMD->SetECallTarget((LPVOID)ComCtor);
            EmitECallMethodStub(pstublinker, pMD, kScalarStubStyle);
        }
#endif
        return pstublinker->Link(pMD->GetClass()->GetClassLoader()->GetStubHeap());
    }

    if (pMT->IsInterface())
    {
        // If this is one of the managed standard interfaces then insert the check for
        // transparent proxies.
#ifdef _X86_
        CRemotingServices::GenerateCheckForProxy((CPUSTUBLINKER*)pstublinker);
#else
        _ASSERTE(!"NYI");
#endif
    }

    _ASSERTE(pMD->IsECall() && !pMD->MustBeFCall());

    // We need to build the stub for Delegate constructors separately...
    if (pMD->GetClass()->IsAnyDelegateClass()) {

        pMD->SetECallTarget((LPVOID)COMDelegate::DelegateConstruct);
        MethodDesc::RETURNTYPE type = pMD->ReturnsObject();
        StubStyle   style;
        if (type == MethodDesc::RETOBJ)
            style = kObjectStubStyle;
        else if (type == MethodDesc::RETBYREF)
            style = kInteriorPointerStubStyle;
        else
            style = kScalarStubStyle;
        EmitECallMethodStub(pstublinker, pMD, style);
        return pstublinker->Link(pMD->GetClass()->GetClassLoader()->GetStubHeap());
    }

    // As an added security measure, ECall methods only work if
    // they're packed into MSCORLIB.DLL.
    if (!pMD->GetModule()->GetSecurityDescriptor()->IsSystemClasses()) {
        BAD_FORMAT_ASSERT(!"ECall methods must be packaged into a system module, such as MSCOREE.DLL");
        COMPlusThrow(kSecurityException);
    }

    //@perf: Right now, we're creating a new stub for every ecall method.
    //Clearly, we can do a better job of caching but we can no longer cache
    //based only on the argstackcount. Once we decide how to do ecalls properly,
    //we'll revisit this issue.
    //
    // JIT helpers have no GC check on the return path because it is
    // unnecessary and incorrect.  Unnecessary because the JIT knows that
    // some helpers are in ASM or FCALLs so they don't check.  It doesn't
    // know which ones, so it assumes that JIT helpers won't check, in its
    // decision of whether to make a method fully interruptible.  The check
    // is incorrect because of JITutil_MonExit.  If we check for GC there,
    // we could detect and throw a ThreadAbort exception.  The exception
    // handler doesn't know if we have backed out of the synchronization
    // lock yet, so we won't count enter/exit to the synchronized region
    // correctly.
    StubStyle   style;
#if 0
    if (g_Mscorlib.IsClass(pMD->GetMethodTable(), CLASS__JIT_HELPERS))
        style = kNoTripStubStyle;
    else
#endif
    {
        MethodDesc::RETURNTYPE type = pMD->ReturnsObject();
        if (type == MethodDesc::RETOBJ)
            style = kObjectStubStyle;
        else if (type == MethodDesc::RETBYREF)
            style = kInteriorPointerStubStyle;
        else
            style = kScalarStubStyle;
    }

#ifdef _DEBUG
    if (!pMD->IsJitted() && (pMD->GetRVA() == 0)) {
        // ECall is a set of tables to call functions within the EE from the classlibs.
        // First we use the class name & namespace to find an array of function pointers for
        // a class, then use the function name (& sometimes signature) to find the correct
        // function pointer for your method.  Methods in the BCL will be marked as 
        // [MethodImplAttribute(MethodImplOptions.InternalCall)] and extern.
        //
        // You'll see this assert in several situations, almost all being the fault of whomever
        // last touched a particular ecall or fcall method, either here or in the classlibs.
        // However, you must also ensure you don't have stray copies of mscorlib.dll on your machine.
        // 1) You forgot to add your class to gEEClasses, the list of classes w/ ecall & fcall methods.
        // 2) You forgot to add your particular method to the ECFunc array for your class.
        // 3) You misspelled the name of your function and/or classname.
        // 4) The signature of the managed function doesn't match the hardcoded metadata signature
        //    listed in your ECFunc array.  The hardcoded metadata sig is only necessary to disambiguate
        //    overloaded ecall functions - usually you can leave it set to NULL.
        // 5) Your copy of mscorlib.dll & mscoree.dll are out of sync - rebuild both.
        // 6) You've loaded the wrong copy of mscorlib.dll.  In msdev's debug menu,
        //    select the "Modules..." dialog.  Verify the path for mscorlib is right.
        // 7) Someone mucked around with how the signatures in metasig.h are parsed, changing the
        //    interpretation of a part of the signature (this is very rare & extremely unlikely,
        //    but has happened at least once).
        _ASSERTE(!"Could not find an ECALL entry for a function!  Read comment above this assert in vm/ecall.cpp");
    }
#endif

    EmitECallMethodStub(pstublinker, pMD, style);

    return pstublinker->Link(pMD->GetClass()->GetClassLoader()->GetStubHeap());
}


#ifdef _X86_
/* static */
VOID ECall::EmitECallMethodStub(StubLinker *pstublinker, ECallMethodDesc *pMD, StubStyle style)
{
    THROWSCOMPLUSEXCEPTION();

    CPUSTUBLINKER *psl = (CPUSTUBLINKER*)pstublinker;

    psl->EmitMethodStubProlog(ECallMethodFrame::GetMethodFrameVPtr());

    psl->EmitShadowStack(pMD);

    psl->Emit8(0x54); //push esp
    psl->Push(4);

    //  mov eax, [CURFRAME.MethodDesc]
    psl->X86EmitIndexRegLoad(kEAX, kESI, FramedMethodFrame::GetOffsetOfMethod());

#ifdef _DEBUG
    //---------------------------------------------------------------------
    // For DEBUG, call debugger routines to verify them
    //---------------------------------------------------------------------

    psl->X86EmitCall(psl->NewExternalCodeLabel(Frame::CheckExitFrameDebuggerCalls), 4, TRUE); // CE doesn't support __stdcall, so pop args on ret

#else
    //---------------------------------------------------------------------
    // For RETAIL, just call.
    //---------------------------------------------------------------------

    //  call [eax + MethodDesc.eCallTarget]
    psl->X86EmitOffsetModRM(0xff, (X86Reg)2, kEAX, ECallMethodDesc::GetECallTargetOffset());
    psl->EmitReturnLabel();
#endif


#ifdef _DEBUG
    // Have to restore esi because WrapCall trashes it.
    // mov esi, [ebx + Thread.m_pFrame]
    psl->X86EmitIndexRegLoad(kESI, kEBX, Thread::GetOffsetOfCurrentFrame());
#endif

    // Note that the shadow stack is popped inside the epilog.
    psl->EmitMethodStubEpilog(pMD->CbStackPop(), style,
                              pMD->SizeOfVirtualFixedArgStack());
}
#endif // _X86_

/*static*/
#ifdef SHOULD_WE_CLEANUP
VOID ECall::FreeUnusedStubs()
{
    m_pECallStubCache->FreeUnusedStubs();
}
#endif /* SHOULD_WE_CLEANUP */


//==========================================================================
// ECall debugger support
//==========================================================================

void ECallMethodFrame::GetUnmanagedCallSite(void **ip,
                                            void **returnIP,
                                            void **returnSP)
{
    MethodDesc *pMD = GetFunction();

    _ASSERTE(pMD->IsECall());

    ECallMethodDesc *pEMD = (ECallMethodDesc *)pMD;

    //
    // We need to get a pointer to the ECall stub.
    // Unfortunately this is a little more difficult than
    // it might be...
    //

    //
    // Read destination out of prestub
    //

    BYTE *prestub = (BYTE*) pMD->GetPreStubAddr();
    INT32 stubOffset = *((UINT32*)(prestub+1));
    const BYTE *code = prestub + METHOD_CALL_PRESTUB_SIZE + stubOffset;

    //
    // Recover stub from code address
    //

    Stub *stub = Stub::RecoverStub(code);

    //
    // ECall stub may have interceptors - skip them
    //

    while (stub->IsIntercept())
        stub = *((InterceptStub*)stub)->GetInterceptedStub();

    //
    // This should be the ECall stub.
    //

    code = stub->GetEntryPoint();

#if defined(STRESS_HEAP) && defined(_DEBUG)
    // This ASERST checks to see if the current stub is a valid stub.
    // This is done by walking all the known stubs and comapring this stub's addr.
    // This causes fastchecked and debug builds to slow down considerably. bug # 25793
    // forces us to put this in gcstres level 1.
    if (g_pConfig->GetGCStressLevel() != 0)
    {
        _ASSERTE(StubManager::IsStub(code));
    }
#endif

    //
    // Compute the pointers from the call site info in the stub
    // (If the stub has no call site info, it's an fcall stub and
    //  we don't want to step into it.)
    //

    if (stub->HasCallSiteInfo())
    {
        if (returnIP != NULL)
            *returnIP = (void*) (code + stub->GetCallSiteReturnOffset());

        if (returnSP != NULL)
            *returnSP = (((BYTE*)this)+GetOffsetOfNextLink()+sizeof(Frame*)
            - stub->GetCallSiteStackSize()
            - sizeof(void*));

        if (ip != NULL)
            *ip = pEMD->GetECallTarget();
    }
    else
    {
        if (returnIP != NULL)
            *returnIP = NULL;

        if (returnSP != NULL)
            *returnSP = NULL;

        if (ip != NULL)
            *ip = NULL;
    }
}

BOOL ECallMethodFrame::TraceFrame(Thread *thread, BOOL fromPatch,
                                  TraceDestination *trace, REGDISPLAY *regs)
{
    //
    // Get the call site info
    //

    LOG((LF_CORDB,LL_INFO1000, "ECallMethodFrame::TraceFrame\n"));

    void *ip, *returnIP, *returnSP;
    GetUnmanagedCallSite(&ip, &returnIP, &returnSP);

    //
    // We can't trace into an fcall.
    //

    if (ip == NULL)
        return FALSE;

    //
    // If we've already made the call, we can't trace any more.
    //
    // !!! Note that this test isn't exact.
    //

    if (!fromPatch
        && (thread->GetFrame() != this
        || *(void**)returnSP == returnIP))
        return FALSE;

    // @nice: We should key this off of a registry setting so that
    // Runtime devs can step into Runtime code through ecalls.
#if 0
    // Otherwise, return the unmanaged destination.
    LOG((LF_CORDB,LL_INFO1000, "It is indeed unmanaged!\n"));

    trace->type = TRACE_UNMANAGED;
    trace->address = (const BYTE *) ip;

    return TRUE;
#else
    return FALSE;
#endif
}

#ifdef _DEBUG
void FCallAssert(void*& cache, void* target) {

    if (cache == 0 ) {
        MethodDesc* pMD = MapTargetBackToMethod(target);
        if (pMD != 0) {
            _ASSERTE(FindImplForMethod(pMD) && "Use FCFuncElement not ECFuncElement");
            return;
        }
            // Slow but only for debugging.  This is needed because in some places
            // we call FCALLs directly from EE code.

        unsigned num = sizeof(gECClasses)/sizeof(ECClass);
        for (unsigned i=0; i < num; i++) {
            ECFunc* ptr = gECClasses[i].m_pECFunc;
            while (ptr->m_pImplementation != 0) {
                if (ptr->m_pImplementation  == target)
                    _ASSERTE(ptr->IsFCall() && "Use FCFuncElement not ECFuncElement");
                    cache = ptr->m_pImplementation;
                    return;
                ptr++;
                }
            }

        _ASSERTE(!"Could not found FCall implemenation in ECall.cpp");
    }
}

void HCallAssert(void*& cache, void* target) {
    if (cache != 0)
        cache = MapTargetBackToMethod(target);
    _ASSERTE(cache == 0 || "Use FCIMPL for fcalls");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eecallconv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//===================================================================
// EECALLCONV.H
//
//  This file can be included multiple times and is useful when you
//  need to write code that depends on details of the calling convention.
//
//  To learn how many registers are reserved for arguments, use the macro
//  NUM_ARGUMENT_REGISTERS
//
//  To enumerate the registers from the first (param #1 or "this") to last,
//
//      #define DEFINE_ARGUMENT_REGISTER(regname)  <expression using regname>
//      #include "eecallconv.h"
//
//  To enumerate the registers in reverse order
//
//      #define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  <expression using regname>
//      #include "eecallconv.h"
//
//
//===================================================================


#ifdef _ALPHA_

#ifndef NUM_ARGUMENT_REGISTERS
#define NUM_ARGUMENT_REGISTERS 6
#endif // NUM_ARGUMENT_REGISTERS

//--------------------------------------------------------------------
// This defines one register guaranteed not to hold an argument.
//--------------------------------------------------------------------
#ifndef SCRATCH_REGISTER
#define SCRATCH_REGISTER T8
#endif // SCRATCH_REGISTER

// #ifndef SCRATCH_REGISTER_X86REG
// #define SCRATCH_REGISTER_X86REG kEAX
// #endif


#ifndef DEFINE_ARGUMENT_REGISTER
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#ifndef DEFINE_ARGUMENT_REGISTER_NOTHING    // used to pick up NUM_ARGUMENT_REGISTERS above
#error  "You didn't pick any choices. Check your spelling."
#endif // !DEFINE_ARGUMENT_REGISTER_NOTHING
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD
#endif // !DEFINE_ARGUMENT_REGISTER


#pragma message("@TODO: ALPHA Determine register containing this")
//-----------------------------------------------------------------------
// Location of "this" argument.
//-----------------------------------------------------------------------
// #ifndef THIS_REG
// #define THIS_REG        ECX
// #endif

// #ifndef THIS_kREG
// #define THIS_kREG       kECX
// #endif


#define ARGUMENT_REG1   A0
#define ARGUMENT_REG2   A1
#define ARGUMENT_REG3   A2
#define ARGUMENT_REG4   A3
#define ARGUMENT_REG5   A4
#define ARGUMENT_REG6   A5

//-----------------------------------------------------------------------
// List of registers in forward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER
#define DEFINE_ARGUMENT_REGISTER(regname)
#endif // !DEFINE_ARGUMENT_REGISTER

DEFINE_ARGUMENT_REGISTER(  A0  )
DEFINE_ARGUMENT_REGISTER(  A1  )
DEFINE_ARGUMENT_REGISTER(  A2  )
DEFINE_ARGUMENT_REGISTER(  A3  )
DEFINE_ARGUMENT_REGISTER(  A4  )
DEFINE_ARGUMENT_REGISTER(  A5  )

#undef DEFINE_ARGUMENT_REGISTER



//-----------------------------------------------------------------------
// List of registers in backward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD


DEFINE_ARGUMENT_REGISTER_BACKWARD(A5)
DEFINE_ARGUMENT_REGISTER_BACKWARD(A4)
DEFINE_ARGUMENT_REGISTER_BACKWARD(A3)
DEFINE_ARGUMENT_REGISTER_BACKWARD(A2)
DEFINE_ARGUMENT_REGISTER_BACKWARD(A1)
DEFINE_ARGUMENT_REGISTER_BACKWARD(A0)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD



//-----------------------------------------------------------------------
// List of registers in backward order with offsets. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#define DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(regname,ofs)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET


DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(A5,0)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(A4,8)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(A3,16)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(A2,24)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(A1,32)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(A0,40)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET


#endif // _ALPHA_

#ifdef _X86_

#ifndef NUM_ARGUMENT_REGISTERS
#define NUM_ARGUMENT_REGISTERS 2
#endif // !NUM_ARGUMENT_REGISTERS


//--------------------------------------------------------------------
// This defines one register guaranteed not to hold an argument.
//--------------------------------------------------------------------
#ifndef SCRATCH_REGISTER
#define SCRATCH_REGISTER EAX
#endif // !SCRATCH_REGISTER

#ifndef SCRATCH_REGISTER_X86REG
#define SCRATCH_REGISTER_X86REG kEAX
#endif // !SCRATCH_REGISTER_X86REG


#ifndef DEFINE_ARGUMENT_REGISTER
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#ifndef DEFINE_ARGUMENT_REGISTER_NOTHING    // used to pick up NUM_ARGUMENT_REGISTERS above
#error  "You didn't pick any choices. Check your spelling."
#endif // !DEFINE_ARGUMENT_REGISTER_NOTHING
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD
#endif // !DEFINE_ARGUMENT_REGISTER


//-----------------------------------------------------------------------
// Location of "this" argument.
//-----------------------------------------------------------------------
#ifndef THIS_REG
#define THIS_REG        ECX
#endif // !THIS_REG

#ifndef THIS_kREG
#define THIS_kREG       kECX
#endif // !THIS_kREG


#define ARGUMENT_REG1   ECX
#define ARGUMENT_REG2   EDX

//-----------------------------------------------------------------------
// List of registers in forward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER
#define DEFINE_ARGUMENT_REGISTER(regname)
#endif // !DEFINE_ARGUMENT_REGISTER

DEFINE_ARGUMENT_REGISTER(  ECX  )
DEFINE_ARGUMENT_REGISTER(  EDX  )

#undef DEFINE_ARGUMENT_REGISTER



//-----------------------------------------------------------------------
// List of registers in backward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD


DEFINE_ARGUMENT_REGISTER_BACKWARD(EDX)
DEFINE_ARGUMENT_REGISTER_BACKWARD(ECX)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD



//-----------------------------------------------------------------------
// List of registers in backward order with offsets. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#define DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(regname,ofs)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET


DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(EDX,0)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(ECX,4)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET


#endif //_X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eeconfig.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EEConfig.H -
//
// Fetched configuration data from the registry (should we Jit, run GC checks ...)
//
//


#ifndef EECONFIG_H
#define EECONFIG_H

class MethodDesc;
#include "eehash.h"

#ifdef _DEBUG
class TypeNamesList
{
    class TypeName
    {    
        LPUTF8      typeName;     
        TypeName *next;           // Next name

        friend class TypeNamesList;
    };

    TypeName     *pNames;         // List of names

public:
    TypeNamesList(LPWSTR str);
    ~TypeNamesList();

    bool IsInList(LPCUTF8 typeName);
};
#endif

class ConfigList;

class ConfigSource
{
    friend ConfigList;
public:
    ConfigSource()
    {
        m_pNext = this;
        m_pPrev = this;
        m_Table.Init(100,NULL);
    }

    ~ConfigSource()
    {
        EEHashTableIteration iter;
        m_Table.IterateStart(&iter);
        while(m_Table.IterateNext(&iter)) {
            LPWSTR pValue = (LPWSTR) m_Table.IterateGetValue(&iter);
            delete [] pValue;
        }
    }
              

    EEUnicodeStringHashTable* Table()
    {
        return &m_Table;
    }

    void Add(ConfigSource* prev)
    {
        _ASSERTE(prev);
        m_pPrev = prev;
        m_pNext = prev->m_pNext;

        _ASSERTE(m_pNext);
        m_pNext->m_pPrev = this;
        prev->m_pNext = this;
    }

    ConfigSource* Next()
    {
        return m_pNext;
    }

    ConfigSource* Previous()
    {
        return m_pPrev;
    }


private:    
    EEUnicodeStringHashTable m_Table;
    ConfigSource *m_pNext;
    ConfigSource *m_pPrev;
};


class ConfigList
{
public:
    class ConfigIter
    {
    public:
        ConfigIter(ConfigList* pList)
        {
            pEnd = &(pList->m_pElement);
            pCurrent = pEnd;
        }

        EEUnicodeStringHashTable* Next()
        {
            pCurrent = pCurrent->Next();;
            if(pCurrent == pEnd)
                return NULL;
            else
                return pCurrent->Table();
        }

        EEUnicodeStringHashTable* Previous()
        {
            pCurrent = pCurrent->Previous();
            if(pCurrent == pEnd)
                return NULL;
            else
                return pCurrent->Table();
        }

    private:
        ConfigSource* pEnd;
        ConfigSource* pCurrent;
    };

    EEUnicodeStringHashTable* Add()
    {
        ConfigSource* pEntry = new ConfigSource();
        if(pEntry == NULL) return NULL;
        pEntry->Add(&m_pElement);
        return pEntry->Table();
    }
        
    EEUnicodeStringHashTable* Append()
    {
        ConfigSource* pEntry = new ConfigSource();
        if(pEntry == NULL) return NULL;
        pEntry->Add(m_pElement.Previous());
        return pEntry->Table();
    }

    ~ConfigList()
    {
        ConfigSource* pNext = m_pElement.Next();
        while(pNext != &m_pElement) {
            ConfigSource *last = pNext;
            pNext = pNext->m_pNext;
            delete last;
        }
    }

private:
    ConfigSource m_pElement;
};

enum { OPT_BLENDED, 
       OPT_SIZE, 
       OPT_SPEED, 
       OPT_RANDOM, 
       OPT_DEFAULT = OPT_BLENDED };

class EEConfig
{
public:
    typedef enum {
        CONFIG_SYSTEM,
        CONFIG_APPLICATION
    } ConfigSearch;


    void *operator new(size_t size);
    void operator delete(void *pMem);

    EEConfig();
    ~EEConfig();

        // Jit-config

    bool ShouldJitMethod(MethodDesc* fun)           const;
    bool ShouldEJitMethod(MethodDesc* fun)          const { return fEnableEJit; }
    bool IsCodePitchEnabled(void)                   const { return fEnableCodePitch; }
    unsigned int  GetMaxCodeCacheSize()             const { return iMaxCodeCacheSize;}
    unsigned int  GetTargetCodeCacheSize()          const { return iTargetCodeCacheSize;}
    unsigned int  GetMaxPitchOverhead()             const { return iMaxPitchOverhead;}
#ifndef GOLDEN
    unsigned int  GetMaxUnpitchedPerThread()        const { return iMaxUnpitchedPerThread;}
    unsigned int  GetCodePitchTrigger()             const { return (fCodePitchTrigger ? fCodePitchTrigger : INT_MAX);}
#endif
    unsigned int  GenOptimizeType(void)             const { return iJitOptimizeType; }
    bool          GenLooseExceptOrder(void)         const { return fJitLooseExceptOrder; }

#ifdef _DEBUG
    bool GenDebugInfo(void)                         const { return fDebugInfo; }
    bool GenDebuggableCode(void)                    const { return fDebuggable; }
    bool IsJitRequired(void)                        const { return fRequireJit; }
    bool IsStressOn(void)                        const { return fStressOn; }

    inline bool ShouldPrestubHalt(MethodDesc* pMethodInfo) const
    { return IsInMethList(pPrestubHalt, pMethodInfo);}
    inline bool ShouldBreakOnClassLoad(LPCUTF8 className) const 
    { return (pszBreakOnClassLoad != 0 && className != 0 && strcmp(pszBreakOnClassLoad, className) == 0);
    }
    inline bool ShouldBreakOnClassBuild(LPCUTF8 className) const 
    { return (pszBreakOnClassBuild != 0 && className != 0 && strcmp(pszBreakOnClassBuild, className) == 0);
    }
    inline bool ShouldBreakOnMethod(LPCUTF8 methodName) const 
    { return (pszBreakOnMethodName != 0 && methodName != 0 && strcmp(pszBreakOnMethodName, methodName) == 0);
    }
    inline bool ShouldDumpOnClassLoad(LPCUTF8 className) const
    { return (pszDumpOnClassLoad != 0 && className != 0 && strcmp(pszDumpOnClassLoad, className) == 0);
    }
    DWORD   GetSecurityOptThreshold()       const { return m_dwSecurityOptThreshold; }
    static TypeNamesList* ParseTypeList(LPWSTR str);
    static void DestroyTypeList(TypeNamesList* list);

    inline bool ShouldGcCoverageOnMethod(LPCUTF8 methodName) const 
    { return (pszGcCoverageOnMethod == 0 || methodName == 0 || strcmp(pszGcCoverageOnMethod, methodName) == 0);
    }
#endif
        // Because the large object heap is 8 byte aligned, we want to put
        // arrays of doubles there more agressively than normal objects.  
        // This is the threshold for this.  It is the number of doubles,
        // not the number of bytes in the array, this constant
    unsigned int  GetDoubleArrayToLargeObjectHeap() const { return DoubleArrayToLargeObjectHeap; }

    inline BaseDomain::SharePolicy DefaultSharePolicy() const
    {
        return (BaseDomain::SharePolicy) dwSharePolicy;
    }

    inline bool FinalizeAllRegisteredObjects() const
    { return fFinalizeAllRegisteredObjects; }

    inline bool AppDomainUnload() const
    { return fAppDomainUnload; }

#ifdef _DEBUG
    inline bool AppDomainLeaks() const
    { return fAppDomainLeaks; }

    inline bool UseBuiltInLoader() const
    { return fBuiltInLoader; }

#endif

    inline bool DeveloperInstallation() const
    { return m_fDeveloperInstallation; }

#ifdef _DEBUG
    bool IsJitVerificationDisabled(void)    const { return fJitVerificationDisable; } 

    // Verifier
    bool    IsVerifierOff()                 const { return fVerifierOff; }
    
    inline bool fAssertOnBadImageFormat() const
    { return m_fAssertOnBadImageFormat; }

    // Verifier Break routines.
    inline bool IsVerifierBreakOnErrorEnabled() const 
    { return fVerifierBreakOnError; }

    // Skip verifiation routine
    inline bool ShouldVerifierSkip(MethodDesc* pMethodInfo) const
    { return IsInMethList(pVerifierSkip, pMethodInfo); }

    // Verifier break routines
    inline bool ShouldVerifierBreak(MethodDesc* pMethodInfo) const
    { return IsInMethList(pVerifierBreak, pMethodInfo); }

    inline bool IsVerifierBreakOffsetEnabled() const 
    { return fVerifierBreakOffset; }
    inline bool IsVerifierBreakPassEnabled() const 
    { return fVerifierBreakPass; }
    inline int GetVerifierBreakOffset() const 
    { return iVerifierBreakOffset; }
    inline int GetVerifierBreakPass() const 
    { return iVerifierBreakPass; }

    // Printing of detailed error message, default is ON
    inline bool IsVerifierMsgMethodInfoOff() const 
    { return fVerifierMsgMethodInfoOff; }

    inline bool Do_AllowUntrustedCaller_Checks()
    { return fDoAllowUntrustedCallerChecks; }

#endif

    // CPU flags/capabilities

    void  SetCpuFlag(DWORD val) { dwCpuFlag = val;  }
    DWORD GetCpuFlag()          { return dwCpuFlag; }
    
    void  SetCpuCapabilities(DWORD val) { dwCpuCapabilities = val;  }
    DWORD GetCpuCapabilities()          { return dwCpuCapabilities; }

    // GC config
    int     GetHeapVerifyLevel()                  { return iGCHeapVerify;  }
    bool    IsHeapVerifyEnabled()           const { return iGCHeapVerify != 0; }
    void    SetGCStressLevel(int val)             { iGCStress = val;  }
    
    enum  GCStressFlags { 
        GCSTRESS_ALLOC              = 1,    // GC on all allocs and 'easy' places
        GCSTRESS_TRANSITION         = 2,    // GC on transitions to preemtive GC 
        GCSTRESS_INSTR              = 4,    // GC on every allowable JITed instr
        GCSTRESS_UNIQUE             = 8,    // GC only on a unique stack trace
    };
    GCStressFlags GetGCStressLevel()        const { return GCStressFlags(iGCStress); }

    int     GetGCtraceStart()               const { return iGCtraceStart; }
    int     GetGCtraceEnd  ()               const { return iGCtraceEnd;   }
    int     GetGCprnLvl    ()               const { return iGCprnLvl;     }
    int     GetGCgen0size  ()               const { return iGCgen0size;   }
    void    SetGCgen0size  (int iSize)         { iGCgen0size = iSize;  }

    int     GetSegmentSize ()               const { return iGCSegmentSize; }
    void    SetSegmentSize (int iSize)         { iGCSegmentSize = iSize; }
    int     GetGCconcurrent()               const { return iGCconcurrent; }
    void    SetGCconcurrent(int val)           { iGCconcurrent = val; }
    int     GetGCForceCompact()             const { return iGCForceCompact; }

    DWORD GetStressLoadThreadCount() const
    { return m_dwStressLoadThreadCount; }

    // thread stress: number of threads to run
#ifdef STRESS_THREAD
    DWORD GetStressThreadCount ()           const {return dwStressThreadCount;}
#endif
    
#ifdef _DEBUG
    inline DWORD FastGCStressLevel() const
    { return iFastGCStress;}
#endif

    // Interop config
    IUnknown* GetTraceIUnknown()            const { return m_pTraceIUnknown; }
    int     GetTraceWrapper()               const { return m_TraceWrapper;      }
    
    // Loader
    bool    UseZaps()                       const { return fUseZaps; }
    bool    RequireZaps()                   const { return fRequireZaps; }
    bool    VersionZapsByTimestamp()        const { return fVersionZapsByTimestamp; }
    bool    LogMissingZaps()                const { return fLogMissingZaps; }

    LPCWSTR ZapSet()                        const { return pZapSet; }


    // ZapMonitor
    // 0 == no monitor
    // 1 == print summary only
    // 2 == print dirty pages, no stack trace
    // 3 == print dirty pages, w/ stack trace
    // 4 == print all pages
    DWORD   MonitorZapStartup()             const { return dwMonitorZapStartup; }
    DWORD   MonitorZapExecution()           const { return dwMonitorZapExecution; }

    bool    RecordLoadOrder()               const { return fRecordLoadOrder; }
    
    DWORD   ShowMetaDataAccess()            const { return fShowMetaDataAccess; }

    void sync();    // check the registry again and update local state
    
    // Helpers to read configuration
    static LPWSTR GetConfigString(LPWSTR name, BOOL fPrependCOMPLUS = TRUE, 
                                  ConfigSearch direction = CONFIG_SYSTEM); // Note that you own the returned string!
    static DWORD GetConfigDWORD(LPWSTR name, DWORD defValue, 
                                DWORD level=REGUTIL::COR_CONFIG_ALL,
                                BOOL fPrependCOMPLUS = TRUE,
                                ConfigSearch direction = CONFIG_SYSTEM);
    static HRESULT SetConfigDWORD(LPWSTR name, DWORD value, 
                                  DWORD level=REGUTIL::COR_CONFIG_CAN_SET);
    static DWORD GetConfigFlag(LPWSTR name, DWORD bitToSet, bool defValue = FALSE);

    int LogRemotingPerf()                   const { return iLogRemotingPerf; }

#ifdef _DEBUG
    // GC alloc logging
    bool ShouldLogAlloc(char* pClass)       const { return pPerfTypesToLog && pPerfTypesToLog->IsInList(pClass);}
    int AllocSizeThreshold()                const { return iPerfAllocsSizeThreshold; }
    int AllocNumThreshold()                 const { return iPerfNumAllocsThreshold;  }
    
#endif // _DEBUG

    BOOL ContinueAfterFatalError()          const { return fContinueAfterFatalError; }
private: //----------------------------------------------------------------
    bool fInited;                   // have we synced to the registry at least once?

    // Jit-config

    DWORD fEnableJit;
    bool fEnableEJit;
    bool fEnableCodePitch;
    int  fCodePitchTrigger;         
    unsigned int  iMaxCodeCacheSize;        // rigid upper limit on how big the code cache can grow.
    // therefore should be large enough to fit the largest jitted method,  
    // otherwise an outofmemory jit failure will occur.

    unsigned int  iTargetCodeCacheSize;      // this is the expected working set for ejitted code
    unsigned int  iMaxPitchOverhead;         // as percentage of total execution time 
#ifndef GOLDEN
    unsigned int  iMaxUnpitchedPerThread;    // maximum number of methods pitched per thread
#endif
    unsigned iJitOptimizeType; // 0=Blended,1=SmallCode,2=FastCode,              default is 0=Blended
    bool fJitLooseExceptOrder; // Enable/Disable strict exception order.         default is false

#define DEFAULT_CODE_PITCH_TRIGGER INT_MAX
#define MINIMUM_CODE_CACHE_SIZE 0x1000  // 1 page
#define DEFAULT_TARGET_CODE_CACHE_SIZE 0x1000000  // 16 MB
#define DEFAULT_MAX_UNPITCHED_PER_THREAD 0x10   // number of methods that are retained on each thread during a pitch
#define DEFAULT_MAX_PITCH_OVERHEAD 5 
#define PAGE_SIZE 0x1000

    static unsigned RoundToPageSize(unsigned);

    LPUTF8 pszBreakOnClassLoad;         // Halt just before loading this class

#ifdef _DEBUG
    static MethodNamesList* ParseMethList(LPWSTR str);
    static void DestroyMethList(MethodNamesList* list);
    static bool IsInMethList(MethodNamesList* list, MethodDesc* pMD);

    bool fDebugInfo;
    bool fDebuggable;
    bool fRequireJit;                   // Report any jit failures vs. fallback to F-JIT on jit failure
    bool fStressOn;

    MethodNamesList* pPrestubHalt;      // list of methods on which to break when hit prestub

    LPUTF8 pszBreakOnClassBuild;         // Halt just before loading this class
    LPUTF8 pszBreakOnMethodName;         // Halt when doing something with this method in the class defined in ClassBuild
    LPUTF8 pszDumpOnClassLoad;          // Dump the class to the log

    DWORD   m_dwSecurityOptThreshold;    // Threshold of demands after which optimization kicks in

    bool    fAppDomainLeaks;             // Enable appdomain leak detection for object refs

    bool   fBuiltInLoader;              // Use Cormap instead of the OS loader
    bool   m_fAssertOnBadImageFormat;   // If false, don't assert on invalid IL (for testing)
#endif
    unsigned int DoubleArrayToLargeObjectHeap;      // double arrays of more than this number of elems go in large object heap

    DWORD  dwSharePolicy;               // Default policy for loading assemblies into the domain neutral area

    bool   fFinalizeAllRegisteredObjects; // if false, skip finalization of registered objects

    // Only developer machines are allowed to use DEVPATH. This value is set when there is an appropriate entry
    // in the machine configuration file. This should not be sent out in the redist.
    bool   m_fDeveloperInstallation;      // We are on a developers machine
    bool   fAppDomainUnload;            // Enable appdomain unloading





#ifdef _DEBUG
    bool fJitVerificationDisable;       // Turn off jit verification (for testing purposes only)

    // Verifier
    bool fVerifierOff;

    // 
    // Verifier debugging options
    // 
    // "VerBreakOnError" to break on verification error.
    // 
    // To Skip verifiation of a methods, set "VerSkip" to a list of methods.
    // 
    // Set "VerBreak" to a list of methods and verifier will halt when
    // the method is being verified.
    // 
    // To break on an IL offset, set "VerOffset" 
    // To break on Pass0 / Pass1, set "VerPass" 
    // 
    // NOTE : If there are more than one methods in the list and an offset
    // is specified, this offset is applicable to all methods in the list
    // 

    bool fVerifierBreakOnError;  // Break on error
    MethodNamesList*  pVerifierSkip;  // methods Skipping verifier
    MethodNamesList*  pVerifierBreak; // methods to break in the verifier
    int  iVerifierBreakOffset;   // break while parsing this offset
    int  iVerifierBreakPass;     // break in pass0 / pass1
    bool fVerifierBreakOffset;   // Offset is valid if true
    bool fVerifierBreakPass;     // Pass is valid if true
    bool fVerifierMsgMethodInfoOff; // detailed errorMessage Off
    bool fDoAllowUntrustedCallerChecks; // do AllowUntrustedCallerChecks
#endif

    // GC config
    int  iGCHeapVerify;
    int  iGCStress;
    int  iGCtraceStart;
    int  iGCtraceEnd;
#define DEFAULT_GC_PRN_LVL 3
    int  iGCprnLvl;
    int  iGCgen0size;
    int  iGCSegmentSize;
    int  iGCconcurrent;
    int  iGCForceCompact;
    DWORD m_dwStressLoadThreadCount;

#ifdef  STRESS_THREAD
    DWORD dwStressThreadCount;
#endif

#ifdef _DEBUG
    DWORD iFastGCStress;
    LPUTF8 pszGcCoverageOnMethod;
#endif

    // Loader
    bool fUseZaps;
    bool fRequireZaps;
    bool fVersionZapsByTimestamp;
    bool fLogMissingZaps;

    LPCWSTR pZapSet;

    // Zap monitor
    DWORD dwMonitorZapStartup;
    DWORD dwMonitorZapExecution;

    // Metadata tracker
    DWORD fShowMetaDataAccess;
    DWORD dwMetaDataPageNumber;
    LPCWSTR szMetaDataFileName;

    bool fRecordLoadOrder;
         
#define COM_SLOT_MODE_ORIGINAL  0       // Use com slot data in metadata
#define COM_SLOT_MODE_LOG       1       // Ignore com slot, log descrepencies
#define COM_SLOT_MODE_ASSERT    2       // Ignore com slot, assert on descrepencies
    // CPU flags

    DWORD dwCpuFlag;
    DWORD dwCpuCapabilities;
    // interop logging
    IUnknown* m_pTraceIUnknown;
    int       m_TraceWrapper;

    // pump flags
    int     m_fPumpAllUser;

    // Flag to keep track of memory
    int     m_fFreepZapSet;

#ifdef _DEBUG
    // GC Alloc perf flags
    int iPerfNumAllocsThreshold;            // Start logging after this many allocations are made
    int iPerfAllocsSizeThreshold;           // Log allocations of this size or above
    TypeNamesList* pPerfTypesToLog;     // List of types whose allocations are to be logged

#endif // _DEBUG

    //Log Remoting timings
    int iLogRemotingPerf;

    // New configuration
    ConfigList  m_Configuration;

    // Behavior on fatal errors.
    BOOL fContinueAfterFatalError;

public:
    HRESULT AppendConfigurationFile(LPCWSTR pszFileName, LPCWSTR version, bool bOnlySafe = false);
    HRESULT SetupConfiguration();

    HRESULT GetConfiguration(LPCWSTR pKey, ConfigSearch direction, LPWSTR* value);
    LPCWSTR  GetProcessBindingFile();  // All flavors must support this method
    
    DWORD GetConfigDWORDInternal (LPWSTR name, DWORD defValue,    //for getting data in the constructor of EEConfig
                                    DWORD level=REGUTIL::COR_CONFIG_ALL,
                                    BOOL fPrependCOMPLUS = TRUE,
                                    ConfigSearch direction = CONFIG_SYSTEM);
    
};

#ifdef _DEBUG

    // We actually want our asserts for illegal IL, but testers need to test that 
    // we fail gracefully under those conditions.  Thus we have to hide them for those runs. 
#define BAD_FORMAT_ASSERT(str) do { if (g_pConfig->fAssertOnBadImageFormat())  _ASSERTE(str); } while(0)

    // STRESS_ASSERT is meant to be temperary additions to the code base that stop the 
    // runtime quickly when running stress
#define STRESS_ASSERT(cond)   do { if (!(cond) && g_pConfig->IsStressOn())  DebugBreak();    } while(0)

#else

#define BAD_FORMAT_ASSERT(str) 0
#define STRESS_ASSERT(cond)   0

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eedbginterface.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// COM+99 EE to Debugger Interface Header
//

#ifndef _eedbginterface_h_
#define _eedbginterface_h_

#include "common.h"
#include "corpriv.h"
#include "hash.h"
#include "class.h"
#include "excep.h"
#include "threads.h"
#include "field.h"
#include "stackwalk.h"
#include "EnC.h"
#include "EnCEE.h"
#include "CorDebug.h"
#include "..\Debug\Inc\Common.h"

class MethodDesc;
class Frame;
//
// The purpose of this object is to provide EE funcationality back to
// the debugger. This represents the entire set of EE functions used
// by the debugger.
//
// We will make this interface smaller over time to minimize the link
// between the EE and the Debugger.
// -- mikemag Sun Apr 26 16:36:21 1998
//
typedef BOOL (*HashMapEnumCallback)(HashMap* h, void* pData, ULONG value);

typedef enum AttachAppDomainEventsEnum
{
    SEND_ALL_EVENTS,
    ONLY_SEND_APP_DOMAIN_CREATE_EVENTS,
    DONT_SEND_CLASS_EVENTS,
    ONLY_SEND_CLASS_EVENTS
} AttachAppDomainEventsEnum;

class EEDebugInterface
{
public:
    //
    // Functions exported from the EE to the debugger.
    //
    virtual Thread* GetThread(void) = 0;
    virtual void SetEEThreadPtr(VOID* newPtr) = 0;

    virtual StackWalkAction StackWalkFramesEx(Thread* pThread,
                                              PREGDISPLAY pRD,
                                              PSTACKWALKFRAMESCALLBACK pCallback,
                                              VOID* pData,
                                              unsigned int flags) = 0;
    virtual Frame *GetFrame(CrawlFrame*) = 0;

    virtual bool InitRegDisplay(Thread* pThread,
                                const PREGDISPLAY pRD, const PCONTEXT pctx,
                                bool validContext) = 0;

    virtual BOOL IsStringObject(Object* o) = 0;
    virtual WCHAR* StringObjectGetBuffer(StringObject* so) = 0;
    virtual DWORD StringObjectGetStringLength(StringObject* so) = 0;

    virtual CorElementType ArrayGetElementType(ArrayBase* a) = 0;

    virtual void *GetObjectFromHandle(OBJECTHANDLE handle) = 0;
    virtual void *GetHandleFromObject(void *or,
                                      bool fStrongNewRef,
                                      AppDomain *pAppDomain) = 0;
    virtual void DbgDestroyHandle( OBJECTHANDLE oh, bool fStrongNewRef ) = 0;

    virtual OBJECTHANDLE *GetThreadException(Thread *pThread) = 0;  
    virtual bool IsThreadExceptionNull(Thread *pThread) = 0;    
    virtual void ClearThreadException(Thread *pThread) = 0; 

    virtual bool StartSuspendForDebug(AppDomain *pAppDomain, 
                                      BOOL fHoldingThreadStoreLock = FALSE) = 0;
    virtual void ResumeFromDebug(AppDomain *pAppDomain)= 0;
    virtual void MarkThreadForDebugSuspend(Thread* pRuntimeThread) = 0;
    virtual void MarkThreadForDebugStepping(Thread* pRuntimeThread,
                                            bool onOff) = 0;

    virtual void SetThreadFilterContext(Thread *thread, CONTEXT *context) = 0;  
    virtual CONTEXT *GetThreadFilterContext(Thread *thread) = 0;

    virtual DWORD GetThreadDebuggerWord(Thread *thread) = 0;
    virtual void SetThreadDebuggerWord(Thread *thread, DWORD dw) = 0;

    virtual BOOL IsManagedNativeCode(const BYTE *address) = 0;
    virtual MethodDesc *GetNativeCodeMethodDesc(const BYTE *address) = 0;
    virtual BOOL IsInPrologOrEpilog(const BYTE *address,
                                    size_t* prologSize) = 0;
    virtual size_t GetFunctionSize(MethodDesc *pFD) = 0;
    virtual const BYTE* GetFunctionAddress(MethodDesc *pFD) = 0;

    virtual const BYTE* GetPrestubAddress(void) = 0;

    /*
     * Given an EnCInfo struct and an error callback, this will attempt to commit
     * the changes found within pEncInfo, calling pIEnCError with any errors
     * encountered.
     */
    virtual HRESULT EnCCommit(EnCInfo *pEnCInfo, 
                              UnorderedEnCErrorInfoArray *pEnCError,
                              UnorderedEnCRemapArray *pEnCRemapInfo,
                              BOOL checkOnly) = 0;
    virtual HRESULT GetRoDataRVA(Module *pModule, SIZE_T *pRoDataRVA) = 0;
    virtual HRESULT GetRwDataRVA(Module *pModule, SIZE_T *pRwDataRVA) = 0;
    virtual void ResumeInUpdatedFunction(EditAndContinueModule *pModule,
                                         MethodDesc *pFD, SIZE_T resumeIP,
                                         UINT mapping,
                                         SIZE_T which, 
                                         void *DebuggerVersionToken,
                                         CONTEXT *pContext,
                                         BOOL fJitOnly,
                                         BOOL fShortCircuit) = 0;
    
    //
    // New methods to support the new debugger.
    //

    virtual MethodDesc *LookupMethodDescFromToken(Module* pModule,
                                                   mdMemberRef memberRef) = 0;
    virtual EEClass *FindLoadedClass(Module *pModule,
                                     mdTypeDef classToken) = 0;

    // This will lookup a class, and if it's not loaded, will load and run
    // the class init.
    virtual EEClass *LoadClass(Module *pModule, mdTypeDef classToken) = 0;

    virtual HRESULT GetMethodImplProps(Module *pModule, mdToken tk,
                                       DWORD *pRVA, DWORD *pImplFlags) = 0;
    virtual HRESULT GetParentToken(Module *pModule, mdToken tk,
                                   mdToken *pParentToken) = 0;

    virtual HRESULT ResolveSigToken(Module *pModule, mdSignature sigTk, 
                                    PCCOR_SIGNATURE *ppSig) = 0;

    virtual MethodDesc *GetNonvirtualMethod(Module *module, 
                                              mdToken token) = 0;   
    virtual MethodDesc *GetVirtualMethod(Module *module,    
                                         Object *object, mdToken token) = 0;    

    virtual void OnDebuggerTripThread() = 0;    

    virtual bool IsPreemptiveGCDisabled() = 0;  
    virtual void DisablePreemptiveGC() = 0; 
    virtual void EnablePreemptiveGC() = 0;  

    virtual void FieldDescGetSig(FieldDesc *fd,
                                 PCCOR_SIGNATURE *ppSig,
                                 DWORD *pcSig) = 0;
    
    virtual DWORD MethodDescIsStatic(MethodDesc *pFD) = 0;
    
    virtual Module *MethodDescGetModule(MethodDesc *pFD) = 0;

    virtual COR_ILMETHOD* MethodDescGetILHeader(MethodDesc *pFD) = 0;

    virtual ULONG MethodDescGetRVA(MethodDesc *pFD) = 0;

    virtual void MarkDebuggerAttached(void) = 0;

    virtual void MarkDebuggerUnattached(void) = 0;

    virtual HRESULT IterateThreadsForAttach(BOOL *fEventSent,
                                            BOOL fAttaching) = 0;

    virtual bool CrawlFrameIsGcSafe(CrawlFrame *pCF) = 0;

    virtual bool SweepThreadsForDebug(bool forceSync) = 0;

   virtual void GetRuntimeOffsets(SIZE_T *pTLSIndex,
                                  SIZE_T *pEEThreadStateOffset,
                                  SIZE_T *pEEThreadStateNCOffset,
                                  SIZE_T *pEEThreadPGCDisabledOffset,
                                  DWORD  *pEEThreadPGCDisabledValue,
                                  SIZE_T *pEEThreadDebuggerWord2Offset,
                                  SIZE_T *pEEThreadFrameOffset,
                                  SIZE_T *pEEThreadMaxNeededSize,
                                  DWORD  *pEEThreadSteppingStateMask,
                                  DWORD  *pEEMaxFrameValue,
                                  SIZE_T *pEEThreadDebuggerWord1Offset,
                                  SIZE_T *pEEThreadCantStopMask,
                                  SIZE_T *pEEFrameNextOffset,
                                  DWORD  *pEEIsManagedExceptionStateMask) = 0;
    
    virtual bool IsStub(const BYTE *ip) = 0;
    virtual bool TraceStub(const BYTE *ip, TraceDestination *trace) = 0; 
    virtual bool FollowTrace(TraceDestination *trace) = 0;
    virtual bool TraceFrame(Thread *thread, Frame *frame, BOOL fromPatch,
                            TraceDestination *trace, REGDISPLAY *regs) = 0; 
    virtual bool TraceManager(Thread *thread, StubManager *stubManager,
                              TraceDestination *trace, CONTEXT *context,
                              BYTE **pRetAddr) = 0;

    virtual void EnableTraceCall(Thread *thread) = 0;
    virtual void DisableTraceCall(Thread *thread) = 0;

    /* Note that GetNativeAddressOfCode doesn't skip over FJIT jump stubs.
    Unless you know that you really, actually, truly need this method, you
    should probably use GetFunctionAddress, instead*/
    virtual const BYTE* GetNativeAddressOfCode(MethodDesc *pFD) = 0;

    enum {
        EE_STATE_CODE_PITCHING =    0x00000001,
    };
    virtual ULONG GetEEState(void) = 0;

    virtual void DebuggerModifyingLogSwitch (int iNewLevel, 
                                             WCHAR *pLogSwitchName) = 0;

    virtual HRESULT SetIPFromSrcToDst(Thread *pThread,
                          IJitManager* pIJM,
                          METHODTOKEN MethodToken,
                          SLOT addrStart,      
                          DWORD offFrom,        
                          DWORD offTo,          
                          bool fCanSetIPOnly,   
                          PREGDISPLAY pReg,
                          PCONTEXT pCtx,
                          DWORD methodSize,
                          void *firstExceptionHandler,
                          void *pDji) = 0;
                              
    virtual void SetDebugState(Thread *pThread, CorDebugThreadState state) = 0;
    virtual void SetAllDebugState(Thread *et, CorDebugThreadState state) = 0;

    virtual CorDebugUserState GetUserState( Thread *pThread ) = 0;
                                      
    virtual BOOL HasPrejittedCode(MethodDesc *pFD) = 0;

    virtual HRESULT GetPrecompiledBoundaries(MethodDesc *pFD, unsigned int *pcMap,
                                             ICorDebugInfo::OffsetMapping **ppMap) = 0;
    virtual HRESULT GetPrecompiledVars(MethodDesc *pFD, unsigned int *pcVars,
                                       ICorDebugInfo::NativeVarInfo **ppVars) = 0;
                                       
    virtual HRESULT FilterEnCBreakpointsByEH(DebuggerILToNativeMap   *m_sequenceMap,
                                             unsigned int             m_sequenceMapCount,
                                             COR_ILMETHOD_DECODER    *pMethodDecoderOld,
                                             CORDB_ADDRESS            addrOfCode,
                                             METHODTOKEN              methodToken,
                                             DWORD                    methodSize) = 0;
};

#endif // _eedbginterface_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eeconfig.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EEConfig.H -
//
// Fetched configuration data from the registry (should we Jit, run GC checks ...)
//
//
#include "common.h"
#include <xmlparser.h>
#include <mscorcfg.h>
#include "EEConfig.h"
#include "method.hpp"
#include "wsperf.h"
#include "EEConfigFactory.h"
#include "fusionsetup.h"

#define DEFAULT_ZAP_SET L""

/**************************************************************/
// Poor mans narrow
LPUTF8 NarrowWideChar(LPWSTR str) 
{
    if (str != 0) { 
        LPWSTR fromPtr = str;
        LPUTF8 toPtr = (LPUTF8) str;
        LPUTF8 result = toPtr;
        while(*fromPtr != 0)
            *toPtr++ = (char) *fromPtr++;
        *toPtr = 0;
        return result;
    }
    return NULL;
}

/**************************************************************/
// For in-place constructor
BYTE g_EEConfigMemory[sizeof(EEConfig)];

void *EEConfig::operator new(size_t size)
{
    WS_PERF_UPDATE("EEConfig", sizeof(EEConfig), g_EEConfigMemory);    
    return g_EEConfigMemory;
}

void EEConfig::operator delete(void *pMem)
{
}

/**************************************************************/
EEConfig::EEConfig()
{
    _ASSERTE(g_pConfig == 0);       // we only need one instance of this

    fInited = false;
    fEnableJit = 1;
    fEnableEJit = false;
    fEnableCodePitch = false;
    fCodePitchTrigger = DEFAULT_CODE_PITCH_TRIGGER;
    iMaxCodeCacheSize = INT_MAX;
    iMaxPitchOverhead = DEFAULT_MAX_PITCH_OVERHEAD;
    iTargetCodeCacheSize = DEFAULT_TARGET_CODE_CACHE_SIZE;
#ifndef GOLDEN
    iMaxUnpitchedPerThread = DEFAULT_MAX_UNPITCHED_PER_THREAD;
#endif

    iGCStress = 0;
    iGCHeapVerify = 0;          // Heap Verification OFF by default
    iGCtraceStart = INT_MAX; // Set to huge value so GCtrace is off by default
    iGCtraceEnd = INT_MAX;
    iGCprnLvl = DEFAULT_GC_PRN_LVL;
    iGCgen0size = 0;
    iGCSegmentSize = 0;
    iGCconcurrent = 0;
    iGCForceCompact = 0;
    m_fFreepZapSet = false;
    iJitOptimizeType = OPT_DEFAULT;
    fJitLooseExceptOrder = false;
    fFinalizeAllRegisteredObjects = false;
    iLogRemotingPerf = 0;
    
#ifdef _DEBUG
    fDebugInfo = false;
    fDebuggable = false;
    fRequireJit = true;
    fStressOn = false;
    pPrestubHalt = 0;
    pszBreakOnClassLoad = 0;
    pszBreakOnClassBuild = 0;
    pszBreakOnMethodName = 0;
    pszDumpOnClassLoad = 0;
    fJitVerificationDisable= false;
    fVerifierOff           = false;
    fVerifierBreakOnError  = false;
    pVerifierSkip          = NULL;
    pVerifierBreak         = NULL;
    iVerifierBreakOffset   = -1;
    iVerifierBreakPass     = -1;
    fVerifierBreakOffset   = false;
    fVerifierBreakPass     = false;
    fVerifierMsgMethodInfoOff = false;
    fDoAllowUntrustedCallerChecks = true;
    m_dwSecurityOptThreshold = 0;
    iPerfNumAllocsThreshold = 0;
    iPerfAllocsSizeThreshold = 0;
    pPerfTypesToLog = NULL;
    iFastGCStress = 0;
#endif
#ifdef _X86_
    dwCpuFlag  = 0;
    dwCpuCapabilities = 0;
#endif

#ifdef _DEBUG
    fBuiltInLoader = false;
    m_fAssertOnBadImageFormat = true;
#endif
    DoubleArrayToLargeObjectHeap = 1000;

    fUseZaps = true;
    fRequireZaps = false;
    fVersionZapsByTimestamp = true;
    fLogMissingZaps = false;

    m_fDeveloperInstallation = false;
    pZapSet = DEFAULT_ZAP_SET;

    dwSharePolicy = BaseDomain::SHARE_POLICY_UNSPECIFIED;

    dwMonitorZapStartup = 0;
    dwMonitorZapExecution = 0;

    dwMetaDataPageNumber = 0xFFFFFFFF;
    fShowMetaDataAccess = 0;
    szMetaDataFileName = L"";

    fRecordLoadOrder = false;

    fAppDomainUnload = true;

#ifdef BUILDENV_CHECKED
    fAppDomainLeaks = TRUE;
#endif

    // interop logging
    m_pTraceIUnknown = NULL;
    m_TraceWrapper = 0;

    fContinueAfterFatalError = FALSE;

    SetupConfiguration();
}

/**************************************************************/
EEConfig::~EEConfig()
{

#ifdef _DEBUG
    if(g_pConfig) {
        LPWSTR setting = NULL;
        if(SUCCEEDED(g_pConfig->GetConfiguration(L"DumpConfiguration", CONFIG_SYSTEM, & setting)) &&
           setting != NULL) {
            ConfigList::ConfigIter iter(&m_Configuration);
            int count = 0;
            for(EEUnicodeStringHashTable* table = iter.Next();table; table = iter.Next()) {
                EEHashTableIteration tableIter;
                table->IterateStart(&tableIter);
                LOG((LF_ALWAYS, LL_ALWAYS, "\nConfiguration Table %d\n", count++));
                LOG((LF_ALWAYS, LL_ALWAYS, "*********************************\n"));
                while(table->IterateNext(&tableIter)) {
                    EEStringData* key = table->IterateGetKey(&tableIter);
                    LPCWSTR keyString = key->GetStringBuffer();
                    LPCWSTR data = (LPCWSTR) table->IterateGetValue(&tableIter);
                    LOG((LF_ALWAYS, LL_ALWAYS, "%S = %S\n", keyString, data));
                }
                LOG((LF_ALWAYS, LL_ALWAYS, "\n"));
            }
        }
    }
#endif

    if (m_fFreepZapSet)
        delete[] (void*)pZapSet;

#ifdef _DEBUG
    DestroyMethList(pPrestubHalt);
    delete [] pszBreakOnClassLoad;
    delete [] pszBreakOnClassBuild;
    delete [] pszBreakOnMethodName;
    delete [] pszDumpOnClassLoad;
    delete [] pszGcCoverageOnMethod;
#endif
#ifdef _DEBUG
    DestroyMethList(pVerifierSkip);
    DestroyMethList(pVerifierBreak);
    DestroyTypeList(pPerfTypesToLog);
#endif
}

/**************************************************************/

LPWSTR EEConfig::GetConfigString(LPWSTR name, BOOL fPrependCOMPLUS, ConfigSearch direction)
{ 
    LPWSTR pvalue = REGUTIL::GetConfigString(name, fPrependCOMPLUS); 
    if(pvalue == NULL && g_pConfig) {
        LPWSTR pResult;
        if(SUCCEEDED(g_pConfig->GetConfiguration(name, direction, &pResult)) && pResult != NULL) {
            pvalue = new WCHAR[wcslen(pResult) + 1];
            wcscpy(pvalue,pResult);
        }
    }
    return pvalue;
}

DWORD EEConfig::GetConfigDWORD(LPWSTR name, DWORD defValue, DWORD level, BOOL fPrependCOMPLUS, ConfigSearch direction)
{    
    // @TODO: After everyone has moved off registry, key remove the following line in golden
    DWORD result = REGUTIL::GetConfigDWORD(name, defValue, (REGUTIL::CORConfigLevel)level, fPrependCOMPLUS); 
    if(result == defValue && g_pConfig) {
        LPWSTR pvalue;
        if(SUCCEEDED(g_pConfig->GetConfiguration(name, direction, &pvalue))) {
            if(pvalue) {
                MAKE_UTF8PTR_FROMWIDE(pstr, pvalue);
                result = atoi(pstr);
            }
        }
    }
    return result;
}

DWORD EEConfig::GetConfigDWORDInternal(LPWSTR name, DWORD defValue, DWORD level, BOOL fPrependCOMPLUS, ConfigSearch direction)
{    
    // @TODO: After everyone has moved off registry, key remove the following line in golden
    DWORD result = REGUTIL::GetConfigDWORD(name, defValue, (REGUTIL::CORConfigLevel)level, fPrependCOMPLUS); 
    if(result == defValue) {
        LPWSTR pvalue;
        if(SUCCEEDED(GetConfiguration(name, direction, &pvalue))) {
            if(pvalue) {
                MAKE_UTF8PTR_FROMWIDE(pstr, pvalue);
                result = atoi(pstr);
            }
        }
    }
    return result;
}


HRESULT EEConfig::SetConfigDWORD(LPWSTR name, DWORD value, DWORD level)
{ return REGUTIL::SetConfigDWORD(name, value, (REGUTIL::CORConfigLevel)level); }

DWORD EEConfig::GetConfigFlag(LPWSTR name, DWORD bitToSet, bool defValue)
{ return REGUTIL::GetConfigFlag(name, bitToSet, defValue); }

/**************************************************************/

void EEConfig::sync()
{
#ifndef PLATFORM_WIN32
//@TODO - LBS Get this using the registry on WinCE M5
    fEnableJit          = 0;
    fEnableCodePitch    = 1;
    fCodePitchTrigger   = INT_MAX;
    iMaxCodeCacheSize   = INT_MAX;
    iMaxPitchOverhead = DEFAULT_MAX_PITCH_OVERHEAD;
    iTargetCodeCacheSize = MINIMUM_CODE_CACHE_SIZE;
#ifndef GOLDEN
    iMaxUnpitchedPerThread = DEFAULT_MAX_UNPITCHED_PER_THREAD;
#endif
    
    iGCStress           = 0;
    iGCHeapVerify       = 0;
    iGCtraceStart       = INT_MAX;
    iGCtraceEnd         = INT_MAX;
    iGCprnLvl           = DEFAULT_GC_PRN_LVL;
    iGCgen0size         = 0;
    iGCconcurrent       = 0;
    iGCForceCompact     = 0;

    m_dwStressLoadThreadCount = 0;
#ifdef STRESS_THREAD
    dwStressThreadCount = 0;
#endif
    
#ifdef _DEBUG
    iFastGCStress       = 0;
#endif
    
    return;
#else // !PLATFORM_WIN32
    // Note the global variable is not updated directly by the GetRegKey function
    // so we only update it one (to avoid reentrancy windows)



    fEnableJit          = GetConfigDWORD(L"JitEnable", fEnableJit);
    // if JIT is disabled, by default don't use zaps either (since they were made byt he JIT
    fUseZaps = (fEnableJit != 0);

#ifdef _DEBUG
    iMaxCodeCacheSize   = GetConfigDWORD(L"MaxCodeCacheSize",iMaxCodeCacheSize);
    iMaxCodeCacheSize = RoundToPageSize(iMaxCodeCacheSize);
    if (iMaxCodeCacheSize < MINIMUM_CODE_CACHE_SIZE)
        iMaxCodeCacheSize = MINIMUM_CODE_CACHE_SIZE;
    iMaxUnpitchedPerThread = GetConfigDWORD(L"MaxUnpitchedPerThread",iMaxUnpitchedPerThread);
    fEnableCodePitch    = (GetConfigDWORD(L"CodePitchEnable", fEnableCodePitch) != 0);
    iTargetCodeCacheSize   = GetConfigDWORD(L"TargetCodeCacheSize",iTargetCodeCacheSize);
    if (!fEnableCodePitch) {
        iMaxPitchOverhead = 0;
        iTargetCodeCacheSize = 64 * 1024 * 1024;
        if (iMaxCodeCacheSize < iTargetCodeCacheSize) 
            iMaxCodeCacheSize = iTargetCodeCacheSize;
    }
    else
    {
        fCodePitchTrigger    = GetConfigDWORD(L"CodePitchTrigger", fCodePitchTrigger);
    }
    fEnableEJit         = (GetConfigDWORD(L"EJitEnable", fEnableEJit) != 0);

    iTargetCodeCacheSize = min(max(iTargetCodeCacheSize,MINIMUM_CODE_CACHE_SIZE), iMaxCodeCacheSize);
    iMaxPitchOverhead   = GetConfigDWORD(L"MaxPitchOverhead",iMaxPitchOverhead);
#endif

#ifdef STRESS_HEAP
    iGCStress           =  GetConfigDWORD(L"GCStress", iGCStress );
    if (iGCStress)
        g_IGCconcurrent = 0;        // by default GCStress turns off concurrent GC since it make objects move less

    iGCHeapVerify       =  GetConfigDWORD(L"HeapVerify", iGCHeapVerify);
#endif //STRESS_HEAP

#ifdef GC_SIZE
    if (!iGCSegmentSize) iGCSegmentSize =  GetConfigDWORD(L"GCSegmentSize", iGCSegmentSize);
    if (!iGCgen0size) iGCgen0size = GetConfigDWORD(L"GCgen0size"  , iGCgen0size);
#endif //GC_SIZE

#ifdef _DEBUG
    iGCtraceStart       =  GetConfigDWORD(L"GCtraceStart", iGCtraceStart);
    iGCtraceEnd         =  GetConfigDWORD(L"GCtraceEnd"  , iGCtraceEnd);
    iGCprnLvl           =  GetConfigDWORD(L"GCprnLvl"    , iGCprnLvl);
#endif

    iGCconcurrent       =  GetConfigDWORD(L"gcConcurrent"  , g_IGCconcurrent);
    iGCForceCompact     =  GetConfigDWORD(L"gcForceCompact"  , iGCForceCompact);

#ifdef _DEBUG
    iFastGCStress       = GetConfigDWORD(L"FastGCStress", iFastGCStress);
    pszGcCoverageOnMethod = NarrowWideChar(GetConfigString(L"GcCoverage"));
#endif
    
    m_dwStressLoadThreadCount = GetConfigDWORD(L"StressLoadThreadCount", m_dwStressLoadThreadCount);
#ifdef STRESS_THREAD
    dwStressThreadCount =  GetConfigDWORD(L"StressThreadCount", dwStressThreadCount);
#endif
    
    fUseZaps            = !(GetConfigDWORD(L"ZapDisable", !fUseZaps) != 0);

    fRequireZaps        = (GetConfigDWORD(L"ZapRequire", fRequireZaps) != 0);
    fVersionZapsByTimestamp = (GetConfigDWORD(L"ZapsVersionByTimestamp", fVersionZapsByTimestamp) != 0);

    pZapSet             = GetConfigString(L"ZapSet");

#ifdef ZAP_LOG_ENABLE
    fLogMissingZaps     = (GetConfigDWORD(L"ZapLogEnable", fLogMissingZaps) != 0);
#endif

#ifdef ZAP_MONITOR
    dwMonitorZapStartup     = GetConfigDWORD(L"ZapMonitorStartup", dwMonitorZapStartup);
    dwMonitorZapExecution   = GetConfigDWORD(L"ZapMonitorExecution", dwMonitorZapExecution);
#endif 

    dwSharePolicy           = GetConfigDWORD(L"LoaderOptimization", dwSharePolicy);

    fRecordLoadOrder        = GetConfigDWORD(L"ZapRecordLoadOrder", fRecordLoadOrder) != 0;

    DoubleArrayToLargeObjectHeap = GetConfigDWORD(L"DoubleArrayToLargeObjectHeap", DoubleArrayToLargeObjectHeap);

    m_fFreepZapSet = true;
    
    if (pZapSet == NULL)
    {
        m_fFreepZapSet = false;
        pZapSet = L"";
    }
    if (wcslen(pZapSet) > 3)
    {
        _ASSERTE(!"Zap Set String must be less than 3 chars");
        delete[] (void*)pZapSet;
        m_fFreepZapSet = false;
        pZapSet = L"";
    }

    fShowMetaDataAccess     = GetConfigDWORD(L"ShowMetadataAccess", fShowMetaDataAccess);

    iLogRemotingPerf = GetConfigDWORD(L"LogRemotingPerf", 0);

#ifdef BREAK_ON_CLSLOAD
    pszBreakOnClassLoad = NarrowWideChar(GetConfigString(L"BreakOnClassLoad"));
#endif

#ifdef _DEBUG
    iJitOptimizeType      =  GetConfigDWORD(L"JitOptimizeType",     iJitOptimizeType);
    if (iJitOptimizeType > OPT_RANDOM)     iJitOptimizeType = OPT_DEFAULT;
    fJitLooseExceptOrder  = (GetConfigDWORD(L"JitLooseExceptOrder", fJitLooseExceptOrder) != 0);

    fDebugInfo          = (GetConfigDWORD(L"JitDebugInfo",       fDebugInfo)          != 0);
    fDebuggable         = (GetConfigDWORD(L"JitDebuggable",      fDebuggable)         != 0);
    fRequireJit         = (GetConfigDWORD(L"JitRequired",        fRequireJit)         != 0);
    fStressOn           = (GetConfigDWORD(L"StressOn",           fStressOn)           != 0);

    pPrestubHalt = ParseMethList(GetConfigString(L"PrestubHalt"));


    pszBreakOnClassBuild = NarrowWideChar(GetConfigString(L"BreakOnClassBuild"));
    pszBreakOnMethodName = NarrowWideChar(GetConfigString(L"BreakOnMethodName"));
    pszDumpOnClassLoad = NarrowWideChar(GetConfigString(L"DumpOnClassLoad"));
    
    m_dwSecurityOptThreshold = GetConfigDWORD(L"SecurityOptThreshold", m_dwSecurityOptThreshold);

    fBuiltInLoader = (GetConfigDWORD(L"BuiltInLoader", fBuiltInLoader) != 0);

    m_fAssertOnBadImageFormat = (GetConfigDWORD(L"AssertOnBadImageFormat", m_fAssertOnBadImageFormat) != 0);
#endif

#ifndef GOLDEN

    fFinalizeAllRegisteredObjects  = (GetConfigDWORD(L"FinalizeAllRegisteredObjects", fFinalizeAllRegisteredObjects) != 0);
#endif

    if(g_pConfig) {
        LPWSTR result = NULL;
        if(SUCCEEDED(g_pConfig->GetConfiguration(L"developerInstallation", CONFIG_SYSTEM, &result)) && result)
        {
            // @TODO: CTS, add addtional checks to ensure this is an SDK installation
            if(_wcsicmp(result, L"true") == 0)
                m_fDeveloperInstallation = true;
        }
    }

#ifdef AD_NO_UNLOAD
    fAppDomainUnload = (GetConfigDWORD(L"AppDomainNoUnload", 0) == 0);
#endif

#ifdef BUILDENV_CHECKED
        fAppDomainLeaks = GetConfigDWORD(L"AppDomainAgilityChecked", 1) == 1;
#elif defined _DEBUG
        fAppDomainLeaks = GetConfigDWORD(L"AppDomainAgilityFastChecked", 0) == 1;
#endif

#ifdef _DEBUG
    fJitVerificationDisable = (GetConfigDWORD(L"JitVerificationDisable", fJitVerificationDisable)         != 0);

    fVerifierOff    = (GetConfigDWORD(L"VerifierOff", fVerifierOff) != 0);
    fVerifierBreakOnError =  
        (GetConfigDWORD(L"VerBreakOnError", -1) == 1);

    pVerifierSkip        =  ParseMethList(GetConfigString(L"VerSkip"));
    pVerifierBreak       =  ParseMethList(GetConfigString(L"VerBreak"));
    iVerifierBreakOffset =  GetConfigDWORD(L"VerOffset", iVerifierBreakOffset);
    iVerifierBreakPass   =  GetConfigDWORD(L"VerPass",   iVerifierBreakPass);
    if (iVerifierBreakOffset != -1)
        fVerifierBreakOffset = true;
    if (iVerifierBreakPass != -1)
        fVerifierBreakPass = true;

    fVerifierMsgMethodInfoOff =  
        (GetConfigDWORD(L"VerMsgMethodInfoOff", -1) == 1);

    fDoAllowUntrustedCallerChecks =  
        (GetConfigDWORD(L"SupressAllowUntrustedCallerChecks", 0) != 1);

#endif
        fInited = true;

    m_pTraceIUnknown = (IUnknown*)(size_t) GetConfigDWORD(L"TraceIUnknown", (DWORD)(size_t)m_pTraceIUnknown); // @TODO WIN64 - conversion from DWORD to IUnknown* of greater size
    m_TraceWrapper = GetConfigDWORD(L"TraceWrap", m_TraceWrapper);

    // can't have both
    if (m_pTraceIUnknown != 0)
    {
        m_TraceWrapper = 0;
    }
    else
    if (m_TraceWrapper != 0)
    {
        m_pTraceIUnknown = (IUnknown*)-1;
    }

#ifdef _DEBUG

    pPerfTypesToLog = ParseTypeList(GetConfigString(L"PerfTypesToLog"));
    iPerfNumAllocsThreshold = GetConfigDWORD(L"PerfNumAllocsThreshold", 0x3FFFFFFF);
    iPerfAllocsSizeThreshold    = GetConfigDWORD(L"PerfAllocsSizeThreshold", 0x3FFFFFFF);

#endif //_DEBUG

    fContinueAfterFatalError = GetConfigDWORD(L"ContinueAfterFatalError", 0);


#endif // !PLATFORM_WIN32
}

/**************************************************************/
HRESULT EEConfig::SetupConfiguration()
{
    // Get the system configuration file
    WCHAR systemDir[_MAX_PATH+9];
    DWORD dwSize = _MAX_PATH;
    WCHAR configFile[] = MACHINE_CONFIGURATION_FILE;
    WCHAR version[_MAX_PATH];
    DWORD dwVersion = _MAX_PATH;

    HRESULT hr;
    // Get the version location
    hr= GetCORVersion(version, _MAX_PATH, & dwVersion);
    if(FAILED(hr)) return hr;


    // See if the environment has specified an XML file
    LPWSTR file = REGUTIL::GetConfigString(L"CONFIG", TRUE);
    if(file != NULL) {
        hr = AppendConfigurationFile(file, version);
    }

    if (FAILED(hr)&&!(REGUTIL::GetConfigDWORD(L"NoGuiFromShim", FALSE)))
    {
        WCHAR* wszMessage=(WCHAR*)alloca(2*wcslen(file)+100);
        swprintf(wszMessage,L"Error parsing %s\nParser returned error 0x%08X",file,hr);
        WszMessageBoxInternal(NULL,wszMessage,L"Config parser error",MB_OK);
    }

    if (file != NULL)
        delete [] file;

    // Size includes the null terminator
    hr = GetInternalSystemDirectory(systemDir, &dwSize);
    if(SUCCEEDED(hr)) {
        DWORD configSize = sizeof(configFile) / sizeof(WCHAR) - 1;
        if(configSize + dwSize <= _MAX_PATH) {
            wcscat(systemDir, configFile);
            hr = AppendConfigurationFile(systemDir, version);
            if(hr == S_FALSE) {
                hr = GetInternalSystemDirectory(systemDir, &dwSize);
                DWORD configSize = sizeof(configFile) / sizeof(WCHAR) - 1;
                wcscpy((systemDir+dwSize-1), configFile);
                hr = AppendConfigurationFile(systemDir, version);
            }               
            if (FAILED(hr)&&!(REGUTIL::GetConfigDWORD(L"NoGuiFromShim", FALSE)))
            {
                WCHAR* wszMessage=(WCHAR*)alloca(2*wcslen(systemDir)+100);
                swprintf(wszMessage,L"Error parsing %s\nParser returned error 0x%08X",systemDir,hr);
                WszMessageBoxInternal(NULL,wszMessage,L"Config parser error",MB_OK);
            }

        }
    }
        
    hr = S_OK;
    int len = WszGetModuleFileName(NULL, systemDir, _MAX_PATH); // get name of file used to create process
    if (len) {
        wcscat(systemDir, L".config\0");
        #ifdef _DEBUG
        hr = AppendConfigurationFile(systemDir, version, false);
        #else
        hr = AppendConfigurationFile(systemDir, version, true);
        #endif

        if (FAILED(hr)&&!(REGUTIL::GetConfigDWORD(L"NoGuiFromShim", FALSE))&&
            GetConfigDWORDInternal(L"NotifyBadAppCfg",false))
        {
            
            WCHAR* wszMessage=(WCHAR*)alloca(2*wcslen(systemDir)+100);
            swprintf(wszMessage,L"Error parsing %s\nParser returned error 0x%08X",systemDir,hr);
            WszMessageBoxInternal(NULL,wszMessage,L"Config parser error",MB_OK);
        }

        hr=S_OK;
    }

    return hr;
}

HRESULT EEConfig::GetConfiguration(LPCWSTR pKey, ConfigSearch direction, LPWSTR* pValue)
{
    HRESULT hr = S_OK;
    _ASSERTE(pValue);
    _ASSERTE(pKey);

    *pValue = NULL;
    ConfigList::ConfigIter iter(&m_Configuration);
    EEStringData sKey((DWORD)wcslen(pKey)+1,pKey);
    HashDatum datum;

    switch(direction) {
    case CONFIG_SYSTEM: {
        for(EEUnicodeStringHashTable* table = iter.Next();table; table = iter.Next()) {
            if(table->GetValue(&sKey, &datum)) {
                *pValue = (LPWSTR) datum;
                    return S_OK;
            }
        }
    }
    case CONFIG_APPLICATION: {
        for(EEUnicodeStringHashTable* table = iter.Previous();table != NULL; table = iter.Previous()) {
            if(table->GetValue(&sKey, &datum)) {
                *pValue = (LPWSTR) datum;
                return S_OK;
            }
        }
    }
    default:
        return E_FAIL;
    }
}        

LPCWSTR EEConfig::GetProcessBindingFile()
{
    return g_pszHostConfigFile;
}

/**************************************************************/
bool EEConfig::ShouldJitMethod(MethodDesc* pMethodInfo) const
{
    if (!fInited)
        const_cast<EEConfig*>(this)->sync();

      /* If Jit disabled check the Include list to see if we have to jit it conditionally */
    return fEnableJit != 0;
}

/**************************************************************/
unsigned EEConfig::RoundToPageSize(unsigned size)
{
    unsigned adjustedSize = (size + PAGE_SIZE-1)/PAGE_SIZE * PAGE_SIZE;
    if (adjustedSize < size)       // check for overflow
    {
        adjustedSize = (size/PAGE_SIZE)*PAGE_SIZE;
    }
    return adjustedSize;
}


HRESULT EEConfig::AppendConfigurationFile(LPCWSTR pszFileName, LPCWSTR version, bool bOnlySafe)
{
    EEUnicodeStringHashTable* pTable = m_Configuration.Append();
    if(pTable == NULL) return NULL;

    IXMLParser     *pIXMLParser = NULL;
    IStream        *pFile = NULL;
    EEConfigFactory *factory = NULL; 

    HRESULT hr = CreateConfigStream(pszFileName, &pFile);
    if(FAILED(hr)) goto Exit;
        
    hr = GetXMLObject(&pIXMLParser);
    if(FAILED(hr)) goto Exit;

    factory = new EEConfigFactory(pTable, version, bOnlySafe);
    
    if ( ! factory) { 

        hr = E_OUTOFMEMORY; 
        goto Exit; 
    }
    factory->AddRef(); // RefCount = 1 

    
    hr = pIXMLParser->SetInput(pFile); // filestream's RefCount=2
    if ( ! SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->SetFactory(factory); // factory's RefCount=2
    if ( ! SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->Run(-1);
    
Exit:  
    if (hr==XML_E_MISSINGROOT)
        hr=S_OK;

    if (hr==HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr=S_FALSE;

    if (pIXMLParser) { 
        pIXMLParser->Release();
        pIXMLParser= NULL ; 
    }
    if ( factory) {
        factory->Release();
        factory=NULL;
    }
    if ( pFile) {
        pFile->Release();
        pFile=NULL;
    }
    return hr;
}


#ifdef _DEBUG

/**************************************************************/
// Ownership of the string buffer passes to ParseMethList
/* static */
MethodNamesList* EEConfig::ParseMethList(LPWSTR str) {
        // we are now done with the string passed in
    if (str == NULL)
        return NULL;

    MethodNamesList* ret = NULL;
    ret = new MethodNamesList(str);
    delete [] str;
    return ret;
}

/**************************************************************/
/* static */
void EEConfig::DestroyMethList(MethodNamesList* list) {
    if (list == 0)
        return;
    delete list;
}

/**************************************************************/
/* static */
bool EEConfig::IsInMethList(MethodNamesList* list, MethodDesc* pMD) {

    DefineFullyQualifiedNameForClass();
    if (list == 0)
        return(false);

    LPCUTF8 name = pMD->GetName();
    LPCUTF8 className = pMD->GetClass() ? GetFullyQualifiedNameForClass(pMD->GetClass()) : "";
    PCCOR_SIGNATURE sig = pMD->GetSig();

    return list->IsInList(name, className, sig);
}

TypeNamesList *EEConfig::ParseTypeList(LPWSTR str)
{
    if (str == NULL)
        return NULL;

    TypeNamesList *ret = NULL;

    ret = new TypeNamesList(str);
    delete [] str;

    return ret;
}

void EEConfig::DestroyTypeList(TypeNamesList* list) {
    if (list == 0)
        return;
    delete list;
}

TypeNamesList::TypeNamesList(LPWSTR str)
{
    pNames = NULL;

    LPWSTR currentType = str;
    int length = 0;
    bool typeFound = false;

    for (; *str != '\0'; str++)
    {
        switch(*str)
        {
        case ' ':
            {
                if (!typeFound)
                    break;

                TypeName *tn = new TypeName();
                tn->typeName = new char[length + 1];
                MAKE_UTF8PTR_FROMWIDE(temp, currentType);
                memcpy(tn->typeName, temp, length * sizeof(char));
                tn->typeName[length] = '\0';

                tn->next = pNames;
                pNames = tn;

                typeFound = false;
                length = 0;

                break;
            }

        default:
            if (!typeFound)
                currentType = str;

            typeFound = true;
            length++;
            break;
        }
    }

    if (typeFound)
    {
        TypeName *tn = new TypeName();
        tn->typeName = new char[length + 1];
        MAKE_UTF8PTR_FROMWIDE(temp, currentType);
        memcpy(tn->typeName, temp, length * sizeof(char));
        tn->typeName[length] = '\0';

        tn->next = pNames;
        pNames = tn;
    }
}

TypeNamesList::~TypeNamesList()
{

    while (pNames)
    {
        delete [] pNames->typeName;

        TypeName *tmp = pNames;
        pNames = pNames->next;

        delete tmp;
    }
}

bool TypeNamesList::IsInList(LPCUTF8 typeName)
{

    TypeName *tnTemp = pNames;
    while (tnTemp)
    {
        if (strstr(typeName, tnTemp->typeName) != typeName)
            tnTemp = tnTemp->next;
        else
            return true;
    }

    return false;
}

#endif _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eeconfigfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EEConfigFactory.cpp -
//
// Factory used to with the XML parser to read configuration files
//
//
#include "common.h"
#include "EEConfigFactory.h"

#define ISWHITE(ch) ((ch) >= 0x09 && (ch) <= 0x0D || (ch) == 0x20)

EEConfigFactory::EEConfigFactory(EEUnicodeStringHashTable* pTable, LPCWSTR pString, bool bSafeMode) 
{
    m_pTable = pTable;
    m_pVersion = pString;
    m_dwDepth = 0;
    m_fRuntime = FALSE;
    m_fDeveloperSettings = FALSE;
    m_fConcurrentGC = FALSE;
    m_fVersionedRuntime= FALSE;
    m_pLastKey = m_pBuffer;
    m_dwLastKey = 0;
    m_dwSize = CONFIG_KEY_SIZE;
    m_bSafeMode = bSafeMode;
}

EEConfigFactory::~EEConfigFactory() 
{
    DeleteKey();
}

HRESULT STDMETHODCALLTYPE EEConfigFactory::NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt)
{
    if(iEvt == XMLNF_ENDDOCUMENT) {
        // @TODO: add error handling.
    }
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE EEConfigFactory::BeginChildren( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    m_dwDepth++;
    return S_OK;

}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE EEConfigFactory::EndChildren( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmptyNode,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    if ( fEmptyNode ) { 
        if(m_fDeveloperSettings)
            m_fDeveloperSettings = FALSE;        
        
        if(m_fConcurrentGC)
            m_fConcurrentGC = FALSE;
        return S_OK;
    }
    else {
        m_dwDepth--;
        if (m_fRuntime && wcscmp(pNodeInfo->pwcText, L"runtime") == 0) {
            m_fRuntime = FALSE;
            m_fVersionedRuntime = FALSE;
        }
    }
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE EEConfigFactory::CreateNode( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
{
    if(m_dwDepth > 3)
        return S_OK;

    HRESULT hr = S_OK;
    WCHAR  wstr[128]; 
    DWORD  dwSize = 128;
    WCHAR* pString = wstr;
    DWORD  i; 
    BOOL   fRuntimeKey = FALSE;
    BOOL   fVersion = FALSE;

    for( i = 0; i < cNumRecs; i++) { 
        if(apNodeInfo[i]->dwType == XML_ELEMENT ||
           apNodeInfo[i]->dwType == XML_ATTRIBUTE ||
           apNodeInfo[i]->dwType == XML_PCDATA) {

            DWORD lgth = apNodeInfo[i]->ulLen;
            WCHAR *ptr = (WCHAR*) apNodeInfo[i]->pwcText;
            // Trim the value
            for(;*ptr && ISWHITE(*ptr) && lgth>0; ptr++, lgth--);
            while( lgth > 0 && ISWHITE(ptr[lgth-1]))
                   lgth--;

            if ( (lgth+1) > dwSize ) {
                dwSize = lgth+1;
                pString = (WCHAR*) alloca(sizeof(WCHAR) * dwSize);
            }
            
            wcsncpy(pString, ptr, lgth);
            pString[lgth] = L'\0';
            
            switch(apNodeInfo[i]->dwType) {
            case XML_ELEMENT : 
                fRuntimeKey = FALSE;
                ClearKey();
                
                if (m_dwDepth == 1 && wcscmp(pString, L"runtime") == 0) {
                    m_fRuntime = TRUE;
                    fRuntimeKey = TRUE;
                }
    
                if(m_dwDepth == 2 && m_fRuntime) {

                    // gcConcurrent is safe to turn on and off
                    if ( wcscmp(pString, L"gcConcurrent") == 0)
                    {
                        m_fConcurrentGC = TRUE;
                    }
                    else
                    {
                        // Only allow developer settings for non safe modes
                        if (m_bSafeMode == false)
                        {
                            m_fDeveloperSettings = TRUE;
                        }
                    }
                }

                break ;     
                
            case XML_ATTRIBUTE : 
                if(fRuntimeKey && wcscmp(pString, L"version") == 0) {
                    fVersion = TRUE;
                }
                else 
                {
                    if(m_dwDepth == 2 && m_fDeveloperSettings) 
                    {
                        hr = CopyToKey(pString, lgth);
                        if(FAILED(hr)) return hr;
                    }
                    else if (m_dwDepth == 2 && m_fConcurrentGC)
                    {
                        // Hack to remain compatible with RTM specs and not have to change
                        // how the whole factory works
                        if (wcscmp(pString, L"enabled") == 0) 
                        {
                            hr = CopyToKey(L"gcConcurrent", (DWORD) wcslen(L"gcConcurrent"));
                            if(FAILED(hr)) return hr;
                        }
                    }
                }
                break;
            case XML_PCDATA:
                if(fVersion) {
                    // if this is not the right version
                    // then we are not interested 
                    if(_wcsicmp(pString, m_pVersion)) {
                        m_fRuntime = FALSE;
                    }
                    else {
                        // if it is the right version then overwrite
                        // all entries that exist in the hash table
                        m_fVersionedRuntime = TRUE;
                    }
                    fVersion = FALSE;
                }
                else if(fRuntimeKey) {
                    break; // Ignore all other attributes on <runtime>
                }
                else if(m_fConcurrentGC ||
                        m_fDeveloperSettings) {
                    if(m_dwLastKey != 0) {
                        EEStringData sKey(m_dwLastKey, m_pLastKey);
                        HashDatum data;
                        if(m_pTable->GetValue(&sKey, &data)) {
                            if(m_fVersionedRuntime) {
                                WCHAR* pValue = (WCHAR*) data;
                                delete [] pValue;
                                LPWSTR pCopy = new WCHAR[lgth+1];
                                wcscpy(pCopy, pString);
                                m_pTable->ReplaceValue(&sKey, pCopy);
                            }
                        }
                        else { 
                            LPWSTR pCopy = new WCHAR[lgth+1];
                            wcscpy(pCopy, pString);
                            m_pTable->InsertValue(&sKey, pCopy, TRUE);
                        }
                    } 
                }
                    
                break ;     
            default: 
                ;
            } // end of switch
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eedbginterfaceimpl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * COM+99 EE to Debugger Interface Implementation
 *
 */
#ifndef _eedbginterfaceimpl_h_
#define _eedbginterfaceimpl_h_
#pragma once

#ifdef DEBUGGING_SUPPORTED

#include "common.h"
#include "corpriv.h"
#include "hash.h"
#include "class.h"
#include "excep.h"
#include "threads.inl"
#include "field.h"
#include "EETwain.h"
#include "JITInterface.h"
#include "EnC.h"
#include "stubmgr.h"

#include "EEDbgInterface.h"
#include "COMSystem.h"
#include "DebugDebugger.h"

#include "corcompile.h"

#include "AppDomain.hpp"
#include "eeconfig.h"
#include "binder.h"

class EEDbgInterfaceImpl : public EEDebugInterface
{
public:
    //
    // Setup and global data used by this interface.
    //
    static __forceinline void Init(void)
    {
        g_pEEDbgInterfaceImpl = new EEDbgInterfaceImpl();
        _ASSERTE(g_pEEDbgInterfaceImpl);
    }

    //
    // Cleanup any global data used by this interface.
    //
    static void Terminate(void)
    {
        if (g_pEEDbgInterfaceImpl)
        {
            delete g_pEEDbgInterfaceImpl;
            g_pEEDbgInterfaceImpl = NULL;
        }
    }

    Thread* GetThread(void) { return ::GetThread(); }

    void SetEEThreadPtr(VOID* newPtr)
    {
        TlsSetValue(GetThreadTLSIndex(), newPtr);
    }

    StackWalkAction StackWalkFramesEx(Thread* pThread,
                                             PREGDISPLAY pRD,
                                             PSTACKWALKFRAMESCALLBACK pCallback,
                                             VOID* pData,
                                             unsigned int flags)
      { return pThread->StackWalkFramesEx(pRD, pCallback, pData, flags); }

    Frame *GetFrame(CrawlFrame *pCF)
      { return pCF->GetFrame(); }

    bool InitRegDisplay(Thread* pThread, const PREGDISPLAY pRD,
                               const PCONTEXT pctx, bool validContext)
      { return pThread->InitRegDisplay(pRD, pctx, validContext); }

    BOOL IsStringObject(Object* o)
      { return (g_Mscorlib.IsClass(o->GetMethodTable(), CLASS__STRING)); }
    WCHAR* StringObjectGetBuffer(StringObject* so)
      { return so->GetBuffer(); }
    DWORD StringObjectGetStringLength(StringObject* so)
      { return so->GetStringLength(); }

    CorElementType ArrayGetElementType(ArrayBase* a)
    {
        ArrayClass* ac = a->GetArrayClass();
        _ASSERTE(ac != NULL);

        if (a->GetMethodTable() == ac->GetMethodTable())
        {
            CorElementType at = ac->GetElementType();
            return at;
        }
        else
            return ELEMENT_TYPE_VOID;
    }

    void* GetObjectFromHandle(OBJECTHANDLE handle)
    {
        void* v;
        *((OBJECTREF*)&v) = *(OBJECTREF*)handle;
        return v;
    }

    void *GetHandleFromObject(void *or, bool fStrongNewRef, AppDomain *pAppDomain)
    {
        OBJECTHANDLE oh;

        if (fStrongNewRef)
        {
            oh = pAppDomain->CreateStrongHandle( ObjectToOBJECTREF((Object *)or));

            LOG((LF_CORDB, LL_INFO1000, "EEI::GHFO: Given objectref 0x%x,"
                "created strong handle 0x%x!\n", or, oh));
        }
        else
        {
            oh = pAppDomain->CreateLongWeakHandle( ObjectToOBJECTREF((Object *)or));

            LOG((LF_CORDB, LL_INFO1000, "EEI::GHFO: Given objectref 0x%x,"
                "created long weak handle 0x%x!\n", or, oh));
        }
            
        return (void*)oh;
    }

    void DbgDestroyHandle( OBJECTHANDLE oh, bool fStrongNewRef)
    {
        LOG((LF_CORDB, LL_INFO1000, "EEI::GHFO: Destroyed given handle 0x%x,"
            "fStrong: 0x%x!\n", oh, fStrongNewRef));
    
        if (fStrongNewRef)
            DestroyStrongHandle(oh);
        else
            DestroyLongWeakHandle(oh);
    }

    
    OBJECTHANDLE *GetThreadException(Thread *pThread)   
    {   
        return pThread->GetThrowableAsHandle();  
    }   

    bool IsThreadExceptionNull(Thread *pThread) 
    {
        //
        // Pure evil follows. We're assuming that the handle on the
        // thread is a strong handle and we're goona check it for
        // NULL. We're also assuming something about the
        // implementation of the handle here, too.
        //
        OBJECTHANDLE h = *(pThread->GetThrowableAsHandle());
        if (h == NULL)
            return true;

        void *pThrowable = *((void**)h);

        return (pThrowable == NULL);
    }   

    void ClearThreadException(Thread *pThread)  
    {   
        pThread->SetThrowable(NULL);
    }   

    bool StartSuspendForDebug(AppDomain *pAppDomain, 
                              BOOL fHoldingThreadStoreLock) 
    {
        LOG((LF_CORDB,LL_INFO1000, "EEDbgII:SSFD: start suspend on AD:0x%x\n",
            pAppDomain));
            
        bool result = Thread::SysStartSuspendForDebug(pAppDomain);

        return result;  
    }

    bool SweepThreadsForDebug(bool forceSync)
    {
        return Thread::SysSweepThreadsForDebug(forceSync);
    }

    void ResumeFromDebug(AppDomain *pAppDomain) 
    {
        Thread::SysResumeFromDebug(pAppDomain);
    }

    void MarkThreadForDebugSuspend(Thread* pRuntimeThread)
    {
        pRuntimeThread->MarkForDebugSuspend();
    }
    void MarkThreadForDebugStepping(Thread* pRuntimeThread, bool onOff)
    {
        pRuntimeThread->MarkDebuggerIsStepping(onOff);
    }
    
    void SetThreadFilterContext(Thread *thread, CONTEXT *context)   
    {   
        thread->SetFilterContext(context); 
    }   

    CONTEXT *GetThreadFilterContext(Thread *thread) 
    {   
        return thread->GetFilterContext();    
    }

    DWORD GetThreadDebuggerWord(Thread *thread)
    {
        return thread->m_debuggerWord2;
    }

    void SetThreadDebuggerWord(Thread *thread, DWORD dw)
    {
        thread->m_debuggerWord2 = dw;
    }

    BOOL IsManagedNativeCode(const BYTE *address)
      { return ExecutionManager::FindCodeMan((SLOT) address) != NULL; }

    MethodDesc *GetNativeCodeMethodDesc(const BYTE *address)
      { return ExecutionManager::FindJitMan((SLOT) address)->JitCode2MethodDesc((SLOT)address); }

    BOOL IsInPrologOrEpilog(const BYTE *address,
                            size_t* prologSize)
    {
        *prologSize = 0;

        IJitManager* pEEJM 
          = ExecutionManager::FindJitMan((SLOT)address);   

        if (pEEJM != NULL)
        {
            METHODTOKEN methodtoken;
            DWORD relOffset;
            pEEJM->JitCode2MethodTokenAndOffset((SLOT)address, &methodtoken,&relOffset);
            LPVOID methodInfo =
                pEEJM->GetGCInfo(methodtoken);

            ICodeManager* codeMgrInstance = pEEJM->GetCodeManager();
            
            if (codeMgrInstance->IsInPrologOrEpilog(relOffset, methodInfo,
                                                    prologSize))
                return TRUE;
        }

        return FALSE;
    }

    size_t GetFunctionSize(MethodDesc *pFD)
    {
        LPVOID methodStart = (LPVOID) pFD->GetNativeAddrofCode();

        IJitManager* pEEJM 
          = ExecutionManager::FindJitMan((SLOT)methodStart);   

        if (pEEJM != NULL)
        {
            METHODTOKEN methodtoken;
            DWORD relOffset;
            pEEJM->JitCode2MethodTokenAndOffset((SLOT)methodStart, &methodtoken,&relOffset);

            if (pEEJM->SupportsPitching())
            {
                if (!pEEJM->IsMethodInfoValid(methodtoken))
                    return 0;
            }

            LPVOID methodInfo =
                pEEJM->GetGCInfo(methodtoken);

            ICodeManager* codeMgrInstance = pEEJM->GetCodeManager();
            
            return codeMgrInstance->GetFunctionSize(methodInfo);
        }

        return 0;
    }

    const BYTE* GetFunctionAddress(MethodDesc *pFD)
    { 
        const BYTE* adr = pFD->GetNativeAddrofCode(); 
        IJitManager* pEEJM = ExecutionManager::FindJitMan((SLOT)adr);

        if (pEEJM == NULL)
            return NULL;

        if (pEEJM->IsStub(adr))
            return pEEJM->FollowStub(adr);
        else
            return adr;
    }

    const BYTE* GetPrestubAddress(void)
      { return ThePreStub()->GetEntryPoint(); }

    //@todo: delete this entry point
    virtual MethodDesc *GetFunctionFromRVA(Frame *frame,    
                                             unsigned int rva)
    {   
        _ASSERTE(!"Old Style global functions no longer supported!");
        return NULL;
//        return frame->GetFunction()->GetModule()->FindFunction(rva);
    }   

    virtual MethodDesc *GetNonvirtualMethod(Module *module, 
                                              mdToken token)    
    {   
        MethodDesc *fd = NULL;  

        if (token&0xff000000)
        {   
            LPCUTF8         szMember;   
            PCCOR_SIGNATURE pSignature; 
            DWORD           cSignature; 
            HRESULT         hr; 
            mdToken         ptkParent;  

            mdToken type = TypeFromToken(token);    
            IMDInternalImport *pInternalImport = module->GetMDImport();
            EEClass *c = NULL;  

            if (type == mdtMethodDef)   
            {   
                szMember = pInternalImport->GetNameOfMethodDef(token);  
                if (szMember == NULL)   
                    return NULL;    

                pSignature = pInternalImport->GetSigOfMethodDef(token,
                                                             &cSignature);  

                hr = pInternalImport->GetParentToken(token, &ptkParent);   
                if (FAILED(hr)) 
                    return NULL;    

                if (ptkParent != COR_GLOBAL_PARENT_TOKEN)   
                {   
                    NameHandle name(module, ptkParent);
                    c = module->GetClassLoader()->LoadTypeHandle(&name).GetClass();   
                    if (c == NULL)  
                        return NULL;    
                }   
                else    
                {   
                    c = NULL;   
                }   
            }   
            else if (type == mdtMemberRef)  
            {   
                //@TODO - LBS   
                // This needs to resolve memberRefs the same as JITInterface.cpp    

                szMember = pInternalImport->GetNameAndSigOfMemberRef(token,
                                                         &pSignature,   
                                                         &cSignature);  

                ptkParent = pInternalImport->GetParentOfMemberRef(token);    
                
                if (ptkParent != COR_GLOBAL_PARENT_TOKEN)   
                {   
                    NameHandle name(module, ptkParent);
                    c = module->GetClassLoader()->LoadTypeHandle(&name).GetClass();   
                    if (c == NULL)  
                        return NULL;    
                }   
                else    
                {   
                    _ASSERTE(!"Cross Module Global Functions NYI"); 
                    c = NULL;   
                }   
            }   
            else    
                return NULL;    

            if (c == NULL)  
                fd = module->FindFunction(token);   
            else    
            {   
                EEClass *pSearch = NULL;    

                for (pSearch = c;   
                     pSearch != NULL;   
                     pSearch = pSearch->GetParentClass())   
                {   
                    fd = (MethodDesc*) pSearch->FindMethod(szMember,    
                                                           pSignature,    
                                                           cSignature,    
                                                           module,
                                                           mdTokenNil);    
                    if (fd != NULL) 
                        break;  
                }   
            }   

        }   
        else    
            fd = module->FindFunction(token);   

        return fd;  
    }   

    virtual MethodDesc *GetVirtualMethod(Module *module,    
                                         Object *object, mdToken token) 
    {   
        MethodDesc *md; 
        EEClass *c; 
        MethodTable *mt;    

        //
        // @todo: do we want to use the lookup method below for this instead?
        //
        HRESULT hr = EEClass::GetMethodDescFromMemberRef(module,    
                                                         token, &md);   
        if (FAILED(hr)) 
            return NULL;    

        c = md->GetClass(); 

        if (c->IsInterface())   
        {   
            mt = object->GetTrueMethodTable();  

            InterfaceInfo_t *pInfo = mt->FindInterface(c->GetMethodTable());    

            if (pInfo != NULL)  
            {   
                int StartSlot = pInfo->m_wStartSlot;
                md = (MethodDesc *) mt->GetClass()->GetMethodDescForSlot(StartSlot + md->GetSlot());  
                _ASSERTE(!md->IsInterface() || object->GetMethodTable()->IsComObjectType());
            }   
            else if (!mt->IsComObjectType())    
                return NULL;    
        }   

        else if (!md->GetClass()->IsValueClass() 
            && !md->DontVirtualize())   
        {   
            EEClass *objectClass = object->GetTrueMethodTable()->GetClass();    

            md = objectClass->GetMethodDescForSlot(md->GetSlot());  

            _ASSERTE(md != NULL);   
        }   

        return md;  
    }   

    void OnDebuggerTripThread() { ::OnDebuggerTripThread(); }   

    void DisablePreemptiveGC() { ::GetThread()->DisablePreemptiveGC(); }    
    void EnablePreemptiveGC() { ::GetThread()->EnablePreemptiveGC(); }  
    bool IsPreemptiveGCDisabled()   
      { return ::GetThread()->m_fPreemptiveGCDisabled != 0; }   

    void FieldDescGetSig(FieldDesc *fd, PCCOR_SIGNATURE *ppSig, DWORD *pcSig)
    {
        fd->GetSig(ppSig, pcSig);
    }
    
    DWORD MethodDescIsStatic(MethodDesc *pFD)
    {
        return pFD->IsStatic();
    }

    Module *MethodDescGetModule(MethodDesc *pFD)
    {
        return pFD->GetModule();
    }

    COR_ILMETHOD* MethodDescGetILHeader(MethodDesc *pFD)
    {
        if (pFD->IsIL())
            return pFD->GetILHeader();
        else
            return NULL;
    }

    ULONG MethodDescGetRVA(MethodDesc *pFD)
    {
        return pFD->GetRVA();
    }

    MethodDesc *LookupMethodDescFromToken(Module* pModule,
                                              mdToken memberRef)
    {
        // Must have a MemberRef or a MethodDef
        mdToken tkType = TypeFromToken(memberRef);
        _ASSERTE((tkType == mdtMemberRef) || (tkType == mdtMethodDef));

        if (tkType == mdtMemberRef)
            return pModule->LookupMemberRefAsMethod(memberRef);
        else
            return pModule->LookupMethodDef(memberRef);
    }

    EEClass *FindLoadedClass(Module *pModule, mdTypeDef classToken)
    {
        TypeHandle th;

        NameHandle name(pModule, classToken);
        th = pModule->GetClassLoader()->LookupInModule(&name);

        if (!th.IsNull())
            return th.GetClass();
        else
            return NULL;
    }

    EEClass *LoadClass(Module *pModule, mdTypeDef classToken)
    {
        TypeHandle th;

        NameHandle name(pModule, classToken);
        th = pModule->GetClassLoader()->LoadTypeHandle(&name);

        if (!th.IsNull())
            return th.GetClass();
        else
            return NULL;
    }

    HRESULT GetMethodImplProps(Module *pModule, mdToken tk,
                               DWORD *pRVA, DWORD *pImplFlags)
    {
        pModule->GetMDImport()->GetMethodImplProps(tk, pRVA, pImplFlags);
        return S_OK;
    }

    HRESULT GetParentToken(Module *pModule, mdToken tk, mdToken *pParentToken)
    {
        return pModule->GetMDImport()->GetParentToken(tk, pParentToken);
    }
    
    HRESULT ResolveSigToken(Module *pModule, mdSignature sigTk, 
                            PCCOR_SIGNATURE *ppSig)
    {
        DWORD cSig;

        *ppSig = pModule->GetMDImport()->GetSigFromToken(sigTk,
                                                         &cSig);
        return S_OK;
    }

    void MarkDebuggerAttached(void)
    {
        g_CORDebuggerControlFlags |= DBCF_ATTACHED;
    }

    void MarkDebuggerUnattached(void)
    {
        g_CORDebuggerControlFlags &= ~DBCF_ATTACHED;
    }

    HRESULT IterateThreadsForAttach(BOOL *fEventSent, BOOL fAttaching)
    {
        LOG((LF_CORDB, LL_INFO10000, "EEDII:ITFA: Entered function IterateThreadsForAttach()\n"));

        HRESULT hr = E_FAIL;

        Thread *pThread = NULL;

        while ((pThread = ThreadStore::GetThreadList(pThread)) != NULL)
        {
            // Does the thread belong to an app domain to which we are attaching?

            
            Thread::ThreadState ts = pThread->GetSnapshotState();

            // Don't send up events for dead or unstarted
            // threads. There is no race between unstarted threads
            // and missing a thread create event, since we setup a
            // DebuggerThreadStarter right after we remove
            // TS_Unstarted.
            if (!((ts & Thread::ThreadState::TS_Dead) || (ts & Thread::ThreadState::TS_Unstarted)))
            {
                LOG((LF_CORDB, LL_INFO10000, "EEDII:ITFA: g_pDebugInterface->ThreadStarted() for [0x%x] "
                    "Thread dead : %s / Thread unstarted: %s (0x%08x) / AD: %(0x%08x)\n",
                    pThread->GetThreadId(),
                    (ts & Thread::ThreadState::TS_Dead)?"TRUE":"FALSE",
                    (ts & Thread::ThreadState::TS_Unstarted)?"TRUE":"FALSE",
                    ts,
                    pThread->GetDomain()->GetDebuggerAttached()));

                g_pDebugInterface->ThreadStarted(pThread, fAttaching);
                *fEventSent = TRUE;
                hr = S_OK;                    
            }
            else
            {
                LOG((LF_CORDB, LL_INFO10000, "EEDII:ITFA: g_pDebugInterface->ThreadStarted() not called for [0x%x] "
                    "Thread dead : %s / Thread unstarted: %s (0x%08x) / AD: %(0x%08x)\n",
                    pThread->GetThreadId(),
                    (ts & Thread::ThreadState::TS_Dead)?"TRUE":"FALSE",
                    (ts & Thread::ThreadState::TS_Unstarted)?"TRUE":"FALSE",
                    ts,
                    pThread->GetDomain()->GetDebuggerAttached()));
            }
            
        }

        return hr;
    }


/*   
     * Given an EnCInfo struct and an error callback, this will attempt to commit
     * the changes found within pEncInfo, calling pIEnCError with any errors
     * encountered.
     */
    HRESULT EnCCommit(EnCInfo *pEnCInfo, 
                      UnorderedEnCErrorInfoArray *pEnCError,
                      UnorderedEnCRemapArray *pEnCRemapInfo,
                      BOOL checkOnly)
    {
        // CommitAndSendChanges should have already called FixupForEnC, so
        // we won't have to call it again here.
        
#ifdef EnC_SUPPORTED
        // @TODO: CTS, determine which loader we are really suppose to use
        return SystemDomain::Loader()->ApplyEditAndContinue(pEnCInfo, 
                pEnCError, 
                pEnCRemapInfo,
                checkOnly);   
#else // !EnC_SUPPORTED
        return E_NOTIMPL;
#endif // !EnC_SUPPORTED
    }
    
    virtual HRESULT GetRoDataRVA(Module *pModule, SIZE_T *pRoDataRVA)
    {
#ifdef EnC_SUPPORTED
        if (! pModule->IsEditAndContinue())
            return E_FAIL;
        return ((EditAndContinueModule *)pModule)->GetRoDataRVA(pRoDataRVA);
#else // !EnC_SUPPORTED
        return E_FAIL;
#endif // !EnC_SUPPORTED
    }

    virtual HRESULT GetRwDataRVA(Module *pModule, SIZE_T *pRwDataRVA)
    {
#ifdef EnC_SUPPORTED
        if (! pModule->IsEditAndContinue())
            return E_FAIL;
        return ((EditAndContinueModule *)pModule)->GetRwDataRVA(pRwDataRVA);
#else // !EnC_SUPPORTED
        return E_FAIL;
#endif // !EnC_SUPPORTED
    }

    void ResumeInUpdatedFunction(EditAndContinueModule *pModule,
                                 MethodDesc *pFD, SIZE_T resumeIP,
                                 UINT mapping,
                                 SIZE_T which, 
                                 void *DebuggerVersionToken,
                                 CONTEXT *pContext,
                                 BOOL fJitOnly,
                                 BOOL fShortCircuit)
    {
#ifdef EnC_SUPPORTED
        pModule->ResumeInUpdatedFunction(pFD, 
                                         resumeIP, 
                                         mapping, 
                                         which,
                                         DebuggerVersionToken,
                                         pContext,
                                         fJitOnly,
                                         fShortCircuit);
#endif // EnC_SUPPORTED
    }
    
    bool CrawlFrameIsGcSafe(CrawlFrame *pCF)
    {
        return pCF->IsGcSafe();
    }

    bool IsStub(const BYTE *ip)
    {
        return StubManager::IsStub(ip) != FALSE;
    }

    bool TraceStub(const BYTE *ip, TraceDestination *trace)
    {
        return StubManager::TraceStub(ip, trace) != FALSE;
    }

    bool FollowTrace(TraceDestination *trace)
    {
        return StubManager::FollowTrace(trace) != FALSE;
    }

    bool TraceFrame(Thread *thread, Frame *frame, BOOL fromPatch, 
        TraceDestination *trace, REGDISPLAY *regs)
    {
        return frame->TraceFrame(thread, fromPatch, trace, regs) != FALSE;
    }

    bool TraceManager(Thread *thread, StubManager *stubManager,
                      TraceDestination *trace, CONTEXT *context,
                      BYTE **pRetAddr)
    {
        return stubManager->TraceManager(thread, trace,
                                         context, pRetAddr) != FALSE;
    }
    
    void EnableTraceCall(Thread *thread)
    {
        thread->IncrementTraceCallCount();
    }
    
    void DisableTraceCall(Thread *thread)
    {
        thread->DecrementTraceCallCount();
    }

    void GetRuntimeOffsets(SIZE_T *pTLSIndex,
                           SIZE_T *pEEThreadStateOffset,
                           SIZE_T *pEEThreadStateNCOffset,
                           SIZE_T *pEEThreadPGCDisabledOffset,
                           DWORD  *pEEThreadPGCDisabledValue,
                           SIZE_T *pEEThreadDebuggerWord2Offset,
                           SIZE_T *pEEThreadFrameOffset,
                           SIZE_T *pEEThreadMaxNeededSize,
                           DWORD  *pEEThreadSteppingStateMask,
                           DWORD  *pEEMaxFrameValue,
                           SIZE_T *pEEThreadDebuggerWord1Offset,
                           SIZE_T *pEEThreadCantStopOffset,
                           SIZE_T *pEEFrameNextOffset,
                           DWORD  *pEEIsManagedExceptionStateMask)
    {
        *pTLSIndex = GetThreadTLSIndex();
        *pEEThreadStateOffset = Thread::GetOffsetOfState();
        *pEEThreadStateNCOffset = Thread::GetOffsetOfStateNC();
        *pEEThreadPGCDisabledOffset = Thread::GetOffsetOfGCFlag();
        *pEEThreadPGCDisabledValue = 1; // A little obvious, but just in case...
        *pEEThreadDebuggerWord2Offset = Thread::GetOffsetOfDbgWord2();
        *pEEThreadFrameOffset = Thread::GetOffsetOfCurrentFrame();
        *pEEThreadMaxNeededSize = sizeof(Thread);
        *pEEThreadDebuggerWord1Offset = Thread::GetOffsetOfDbgWord1();
        *pEEThreadCantStopOffset = Thread::GetOffsetOfCantStop();
        *pEEThreadSteppingStateMask = Thread::TSNC_DebuggerIsStepping;
        *pEEMaxFrameValue = (DWORD)(size_t)FRAME_TOP; // @TODO should this be size_t for 64bit?
        *pEEFrameNextOffset = Frame::GetOffsetOfNextLink();
        *pEEIsManagedExceptionStateMask = Thread::TSNC_DebuggerIsManagedException;
    }

    /*
    Don't use this until you've read the warning in 
    EEDbgInterface.h
    */
    virtual const BYTE* GetNativeAddressOfCode(MethodDesc *pFD)
    {
        return (BYTE *) pFD->GetNativeAddrofCode();
    }

    //  EE_STATE_CODE_PITCHING
    virtual ULONG GetEEState(void)
    {
        ULONG state = 0;

        _ASSERTE( g_pConfig != NULL );
        if (g_pConfig->IsCodePitchEnabled() )
        {
            state |= (ULONG)EE_STATE_CODE_PITCHING;
        }

        return state;
    }

    void DebuggerModifyingLogSwitch (int iNewLevel, WCHAR *pLogSwitchName)
    {
        Log::DebuggerModifyingLogSwitch (iNewLevel, pLogSwitchName);
    }


    HRESULT SetIPFromSrcToDst(Thread *pThread,
                          IJitManager* pIJM,
                          METHODTOKEN MethodToken,
                          SLOT addrStart,      
                          DWORD offFrom,        
                          DWORD offTo,          
                          bool fCanSetIPOnly,   
                          PREGDISPLAY pReg,
                          PCONTEXT pCtx,
                          DWORD methodSize,
                          void *firstExceptionHandler,
                          void *pDji)
    {
        return ::SetIPFromSrcToDst(pThread,
                          pIJM,
                          MethodToken,
                          addrStart,      
                          offFrom,        
                          offTo,          
                          fCanSetIPOnly,   
                          pReg,
                          pCtx,
                          methodSize,
                          firstExceptionHandler,
                          pDji);
    }

    void SetDebugState(Thread *pThread, CorDebugThreadState state)
    {
        _ASSERTE(state == THREAD_SUSPEND || state == THREAD_RUN);

        LOG((LF_CORDB,LL_INFO10000,"EEDbg:Setting thread 0x%x (ID:0x%x) to 0x%x\n", pThread, pThread->GetThreadId(), state));
        
        if (state == THREAD_SUSPEND)
            pThread->SetThreadStateNC(Thread::TSNC_DebuggerUserSuspend);
        else
            pThread->ResetThreadStateNC(Thread::TSNC_DebuggerUserSuspend);
    }

    void SetAllDebugState(Thread *et, CorDebugThreadState state)
    {
        Thread *pThread = NULL;

        while ((pThread = ThreadStore::GetThreadList(pThread)) != NULL)
        {
            if (pThread != et)
                SetDebugState(pThread, state);
        }
    }

    // This is pretty much copied from VM\COMSynchronizable's
    // INT32 __stdcall ThreadNative::GetThreadState, so propogate changes
    // to both functions
    CorDebugUserState GetUserState( Thread *pThread )
    {
        Thread::ThreadState ts = pThread->GetSnapshotState();
        unsigned ret = 0;
        
        if (ts & Thread::TS_Background)
            ret |= (unsigned)USER_BACKGROUND;

        if (ts & Thread::TS_Unstarted)
            ret |= (unsigned)USER_UNSTARTED;            

        // Don't report a StopRequested if the thread has actually stopped.
        if (ts & Thread::TS_Dead)
            ret |= (unsigned)USER_STOPPED;           
        else if (ts & Thread::TS_StopRequested)
            ret |= (unsigned)USER_STOP_REQUESTED;            
            
        if (ts & Thread::TS_Interruptible)
            ret |= (unsigned)USER_WAIT_SLEEP_JOIN;          

        // Don't report a SuspendRequested if the thread has actually Suspended.
        if ( ((ts & Thread::TS_UserSuspendPending) &&
              (ts & Thread::TS_SyncSuspended)))
        {
            ret |= (unsigned)USER_SUSPENDED;
        }
        else if (ts & Thread::TS_UserSuspendPending)
        {
            ret |= (unsigned)USER_SUSPEND_REQUESTED;
        }

        LOG((LF_CORDB,LL_INFO1000, "EEDbgII::GUS: thread 0x%x (id:0x%x)"
            " userThreadState is 0x%x\n", pThread, pThread->GetThreadId(), ret));

        return (CorDebugUserState)ret;
    }

    BOOL HasPrejittedCode(MethodDesc *pMD)
    {
        return pMD->IsPrejitted();
    }

    CORCOMPILE_DEBUG_ENTRY *GetMethodDebugEntry(MethodDesc *pFD)
    {
        _ASSERTE(HasPrejittedCode(pFD));

        Module *pModule = pFD->GetModule();
        _ASSERTE(pModule->IsPEFile());

        IMAGE_COR20_HEADER *pHeader = pModule->GetZapCORHeader();
        CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
          (pModule->GetZapBase() 
           + pHeader->ManagedNativeHeader.VirtualAddress);

        int rid = RidFromToken(pFD->GetMemberDef());

        CORCOMPILE_DEBUG_ENTRY *entry = (CORCOMPILE_DEBUG_ENTRY *)
          (pZapHeader->DebugMap.VirtualAddress + pModule->GetZapBase());
        
        if ((rid-1)*sizeof(CORCOMPILE_DEBUG_ENTRY) >= pZapHeader->DebugMap.Size)
            return NULL;

        entry += rid-1;

        return entry;
    }

    HRESULT GetPrecompiledBoundaries(MethodDesc *pFD, unsigned int *pcMap,
                                     ICorDebugInfo::OffsetMapping **ppMap)
    {
        Module *pModule = pFD->GetModule();
        if (!pModule->IsPEFile())
            return E_FAIL;

        CORCOMPILE_DEBUG_ENTRY *entry = GetMethodDebugEntry(pFD);
        
        if (entry == NULL || entry->boundaries.VirtualAddress == 0)
            return E_FAIL;

        *pcMap = entry->boundaries.Size/sizeof(ICorDebugInfo::OffsetMapping);
        *ppMap = (ICorDebugInfo::OffsetMapping*) 
          (entry->boundaries.VirtualAddress + pModule->GetZapBase());

        return S_OK;
    }

    HRESULT GetPrecompiledVars(MethodDesc *pFD, unsigned int *pcVars,
                               ICorDebugInfo::NativeVarInfo **ppVars)
    {
        Module *pModule = pFD->GetModule();
        if (!pModule->IsPEFile())
            return E_FAIL;

        CORCOMPILE_DEBUG_ENTRY *entry = GetMethodDebugEntry(pFD);

        if (entry == NULL || entry->vars.VirtualAddress == 0)
            return E_FAIL;

        *pcVars = entry->vars.Size/sizeof(ICorDebugInfo::NativeVarInfo);
        *ppVars = (ICorDebugInfo::NativeVarInfo*) 
          (entry->vars.VirtualAddress + pModule->GetZapBase());

        return S_OK;
    }

    HRESULT FilterEnCBreakpointsByEH(DebuggerILToNativeMap   *m_sequenceMap,
                                     unsigned int             m_sequenceMapCount,
                                     COR_ILMETHOD_DECODER    *pMethodDecoderOld,
                                     CORDB_ADDRESS            addrOfCode,
                                     METHODTOKEN              methodToken,
                                     DWORD                    methodSize)
    {
        return S_OK;
//
//      At this point, we'd want to go in, and detect if an EnC will change
//      a method so that the EH structure had changed illegally. The way 
//      I was planning on doing this was to create an EHRangeTree for the old &
//      new versions, then make sure that the structure hadn't changed, then
//      make sure that the location within the EH tree of an old IL offset, when
//      mapped through the old to new IL map, ends up in the corresponding location
//      in the new tree.  All the sequence points that satisfy these constraints are
//      marked "ok", everything else is marked "bad", and we don't set EnC BPs
//      at the "bad" ones.  We'll also have to change DispatchPatchOrSingleStep
//      so we don't short-circuit when we're not supposed to.
//      This prevent us from allowing an EnC that changes the EH layout (the next
//      time the user invokes the function things'll go fine).
//
//        return ::FilterEnCBreakpointsByEH(m_sequenceMap,
//                                          m_sequenceMapCount,
//                                          pMethodDecoderOld,
//                                          pAddrOfCode,
//                                          methodToken,
//                                          methodSize);
    }
};

#endif // DEBUGGING_SUPPORTED

#endif // _eedbginterfaceimpl_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eeconfigfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EEConfigFactory.h -
//
// Parses XML files and adding runtime entries to the EEConfig list
//
//

#ifndef EECONFIGFACTORY_H
#define EECONFIGFACTORY_H

#include <xmlparser.h>
#include <objbase.h>
#include "unknwn.h"
#include "_reference.h"
#include "_unknown.h"
#include "eehash.h"

#define CONFIG_KEY_SIZE 128

class EEConfigFactory : public _unknown<IXMLNodeFactory, &IID_IXMLNodeFactory>
{

public:
    EEConfigFactory(EEUnicodeStringHashTable* pTable, LPCWSTR, bool bSafeMode = false);
    ~EEConfigFactory();
    HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);

    HRESULT STDMETHODCALLTYPE BeginChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

    HRESULT STDMETHODCALLTYPE EndChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ BOOL fEmptyNode,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE Error( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ HRESULT hrErrorCode,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
    {
      /* 
         UNUSED(pSource);
         UNUSED(hrErrorCode);
         UNUSED(cNumRecs);
         UNUSED(apNodeInfo);
      */
        return hrErrorCode;
    }
    
    HRESULT STDMETHODCALLTYPE CreateNode( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ PVOID pNodeParent,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

private:

    HRESULT GrowKey(DWORD dwSize)
    {
        if(dwSize > m_dwSize) {
            DeleteKey();
            m_pLastKey = new WCHAR[dwSize];
            if(m_pLastKey == NULL) return E_OUTOFMEMORY;
            m_dwSize = dwSize;
        }
        return S_OK;
    }

    void ClearKey()
    {
        m_dwLastKey = 0;
    }

    void DeleteKey()
    {
        if(m_pLastKey != NULL && m_pLastKey != m_pBuffer)
            delete [] m_pLastKey;
        m_dwSize = 0;
        m_dwLastKey = 0;
    }

    HRESULT CopyToKey(LPWSTR pString, DWORD dwString)
    {
        dwString++; // add in the null
        HRESULT hr = GrowKey(dwString);
        if(FAILED(hr)) return hr;
        wcsncpy(m_pLastKey, pString, dwString);
        m_dwLastKey = dwString;
        return S_OK;
    }
        
    HRESULT CopyVersion(LPCWSTR version, DWORD dwVersion);

    EEUnicodeStringHashTable* m_pTable;
    BOOL    m_fRuntime;
    BOOL    m_fVersionedRuntime;
    BOOL    m_fDeveloperSettings;
    BOOL    m_fConcurrentGC;

    LPCWSTR m_pVersion;
    LPWSTR  m_pLastKey;
    DWORD   m_dwLastKey;

    WCHAR   m_pBuffer[CONFIG_KEY_SIZE];
    DWORD   m_dwSize;

    DWORD   m_dwDepth;

    bool    m_bSafeMode; // If true, will ignore any settings that may compromise security
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eehash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// File: eehash.cpp
//
#include "common.h"
#include "excep.h"
#include "eehash.h"
#include "wsperf.h"
#include "ExpandSig.h"
#include "permset.h"
#include "comstring.h"
#include "StringLiteralMap.h"
#include "clsload.hpp"
#include "COMNlsInfo.h"

// ============================================================================
// UTF8 string hash table helper.
// ============================================================================
EEHashEntry_t * EEUtf8HashTableHelper::AllocateEntry(LPCUTF8 pKey, BOOL bDeepCopy, void *pHeap)
{
    EEHashEntry_t *pEntry;

    if (bDeepCopy)
    {
        DWORD StringLen = (DWORD)strlen(pKey);
        pEntry = (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY + sizeof(LPUTF8) + StringLen + 1];
        if (!pEntry)
            return NULL;

        memcpy(pEntry->Key + sizeof(LPUTF8), pKey, StringLen + 1); 
        *((LPUTF8*)pEntry->Key) = (LPUTF8)(pEntry->Key + sizeof(LPUTF8));
    }
    else
    {
        pEntry = (EEHashEntry_t *) new (nothrow)BYTE[SIZEOF_EEHASH_ENTRY + sizeof(LPUTF8)];
        if (pEntry)
            *((LPCUTF8*)pEntry->Key) = pKey;
    }

    return pEntry;
}


void EEUtf8HashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, void *pHeap)
{
    delete [] pEntry;
}


BOOL EEUtf8HashTableHelper::CompareKeys(EEHashEntry_t *pEntry, LPCUTF8 pKey)
{
    LPCUTF8 pEntryKey = *((LPCUTF8*)pEntry->Key);
    return (strcmp(pEntryKey, pKey) == 0) ? TRUE : FALSE;
}


DWORD EEUtf8HashTableHelper::Hash(LPCUTF8 pKey)
{
    DWORD dwHash = 0;

    while (*pKey != 0)
    {
        dwHash = (dwHash << 5) + (dwHash >> 5) + (*pKey);
        *pKey++;
    }

    return dwHash;
}


LPCUTF8 EEUtf8HashTableHelper::GetKey(EEHashEntry_t *pEntry)
{
    return *((LPCUTF8*)pEntry->Key);
}


// ============================================================================
// Unicode string hash table helper.
// ============================================================================
EEHashEntry_t * EEUnicodeHashTableHelper::AllocateEntry(EEStringData *pKey, BOOL bDeepCopy, void *pHeap)
{
    EEHashEntry_t *pEntry;

    if (bDeepCopy)
    {
        pEntry = (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY + sizeof(EEStringData) + ((pKey->GetCharCount() + 1) * sizeof(WCHAR))];
        if (pEntry) {
            EEStringData *pEntryKey = (EEStringData *)(&pEntry->Key);
            pEntryKey->SetIsOnlyLowChars (pKey->GetIsOnlyLowChars());
            pEntryKey->SetCharCount (pKey->GetCharCount());
            pEntryKey->SetStringBuffer ((LPWSTR) ((LPBYTE)pEntry->Key + sizeof(EEStringData)));
            memcpy((LPWSTR)pEntryKey->GetStringBuffer(), pKey->GetStringBuffer(), pKey->GetCharCount() * sizeof(WCHAR)); 
        }
    }
    else
    {
        pEntry = (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY + sizeof(EEStringData)];
        if (pEntry) {
            EEStringData *pEntryKey = (EEStringData *) pEntry->Key;
            pEntryKey->SetIsOnlyLowChars (pKey->GetIsOnlyLowChars());
            pEntryKey->SetCharCount (pKey->GetCharCount());
            pEntryKey->SetStringBuffer (pKey->GetStringBuffer());
        }
    }

    return pEntry;
}


void EEUnicodeHashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, void *pHeap)
{
    delete [] pEntry;
}


BOOL EEUnicodeHashTableHelper::CompareKeys(EEHashEntry_t *pEntry, EEStringData *pKey)
{
    EEStringData *pEntryKey = (EEStringData*) pEntry->Key;

    // Same buffer, same string.
    if (pEntryKey->GetStringBuffer() == pKey->GetStringBuffer())
        return TRUE;

    // Length not the same, never a match.
    if (pEntryKey->GetCharCount() != pKey->GetCharCount())
        return FALSE;

    // Compare the entire thing.
    // We'll deliberately ignore the bOnlyLowChars field since this derived from the characters
    return !memcmp(pEntryKey->GetStringBuffer(), pKey->GetStringBuffer(), pEntryKey->GetCharCount() * sizeof(WCHAR));
}


DWORD EEUnicodeHashTableHelper::Hash(EEStringData *pKey)
{
    return (HashBytes((const BYTE *) pKey->GetStringBuffer(), pKey->GetCharCount()*sizeof(WCHAR)));
}


EEStringData *EEUnicodeHashTableHelper::GetKey(EEHashEntry_t *pEntry)
{
    return (EEStringData*)pEntry->Key;
}

void EEUnicodeHashTableHelper::ReplaceKey(EEHashEntry_t *pEntry, EEStringData *pNewKey)
{
    ((EEStringData*)pEntry->Key)->SetStringBuffer (pNewKey->GetStringBuffer());
    ((EEStringData*)pEntry->Key)->SetCharCount (pNewKey->GetCharCount());
    ((EEStringData*)pEntry->Key)->SetIsOnlyLowChars (pNewKey->GetIsOnlyLowChars());
}

// ============================================================================
// Unicode stringliteral hash table helper.
// ============================================================================
EEHashEntry_t * EEUnicodeStringLiteralHashTableHelper::AllocateEntry(EEStringData *pKey, BOOL bDeepCopy, void *pHeap)
{
    // We assert here because we expect that the heap is not null for EEUnicodeStringLiteralHash table. 
    // If someone finds more uses of this kind of hashtable then remove this asserte. 
    // Also note that in case of heap being null we go ahead and use new /delete which is EXPENSIVE
    // But for production code this might be ok if the memory is fragmented then thers a better chance 
    // of getting smaller allocations than full pages.
    _ASSERTE (pHeap);

    if (pHeap)
        return (EEHashEntry_t *) ((MemoryPool*)pHeap)->AllocateElement ();
    else
        return (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY];
}


void EEUnicodeStringLiteralHashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, void *pHeap)
{
    // We assert here because we expect that the heap is not null for EEUnicodeStringLiteralHash table. 
    // If someone finds more uses of this kind of hashtable then remove this asserte. 
    // Also note that in case of heap being null we go ahead and use new /delete which is EXPENSIVE
    // But for production code this might be ok if the memory is fragmented then thers a better chance 
    // of getting smaller allocations than full pages.
    _ASSERTE (pHeap);

    if (pHeap)
        ((MemoryPool*)pHeap)->FreeElement(pEntry);
    else
        delete [] pEntry;
}


BOOL EEUnicodeStringLiteralHashTableHelper::CompareKeys(EEHashEntry_t *pEntry, EEStringData *pKey)
{
    BOOL bMatch = TRUE;
    WCHAR *thisChars;
    int thisLength;

    BEGIN_ENSURE_COOPERATIVE_GC();
    
    StringLiteralEntry *pHashData = (StringLiteralEntry *)pEntry->Data;
    STRINGREF *pStrObj = (STRINGREF*)(pHashData->GetStringObject());
    
    RefInterpretGetStringValuesDangerousForGC((STRINGREF)*pStrObj, &thisChars, &thisLength);

    // Length not the same, never a match.
    if ((unsigned int)thisLength != pKey->GetCharCount())
        bMatch = FALSE;

    // Compare the entire thing.
    // We'll deliberately ignore the bOnlyLowChars field since this derived from the characters
    bMatch = !memcmp(thisChars, pKey->GetStringBuffer(), thisLength * sizeof(WCHAR));

    END_ENSURE_COOPERATIVE_GC();

    return bMatch;
}


DWORD EEUnicodeStringLiteralHashTableHelper::Hash(EEStringData *pKey)
{
    return (HashBytes((const BYTE *) pKey->GetStringBuffer(), pKey->GetCharCount()));
}

// ============================================================================
// Function type descriptor hash table helper.
// ============================================================================
EEHashEntry_t * EEFuncTypeDescHashTableHelper::AllocateEntry(ExpandSig* pKey, BOOL bDeepCopy, void *pHeap)
{
    EEHashEntry_t *pEntry;

    pEntry = (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY + sizeof(ExpandSig*)];
    if (pEntry) {

        if (bDeepCopy) {
            _ASSERTE(FALSE);
            return NULL;
        }
        else
            *((ExpandSig**)pEntry->Key) = pKey;
    }

    return pEntry;
}


void EEFuncTypeDescHashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, void *pHeap)
{
    delete *((ExpandSig**)pEntry->Key);
    delete [] pEntry;
}


BOOL EEFuncTypeDescHashTableHelper::CompareKeys(EEHashEntry_t *pEntry, ExpandSig* pKey)
{
    ExpandSig* pEntryKey = *((ExpandSig**)pEntry->Key);
    return pEntryKey->IsEquivalent(pKey);
}


DWORD EEFuncTypeDescHashTableHelper::Hash(ExpandSig* pKey)
{
    return pKey->Hash();
}


ExpandSig* EEFuncTypeDescHashTableHelper::GetKey(EEHashEntry_t *pEntry)
{
    return *((ExpandSig**)pEntry->Key);
}


// ============================================================================
// Permission set hash table helper.
// ============================================================================

EEHashEntry_t * EEPsetHashTableHelper::AllocateEntry(PsetCacheEntry *pKey, BOOL bDeepCopy, void *pHeap)
{
    _ASSERTE(!bDeepCopy);
    return (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY];
}

void EEPsetHashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, void *pHeap)
{
    delete [] pEntry;
}

BOOL EEPsetHashTableHelper::CompareKeys(EEHashEntry_t *pEntry, PsetCacheEntry *pKey)
{
    return pKey->IsEquiv(&SecurityHelper::s_rCachedPsets[(DWORD)(size_t)pEntry->Data]);
}

DWORD EEPsetHashTableHelper::Hash(PsetCacheEntry *pKey)
{
    return pKey->Hash();
}

PsetCacheEntry * EEPsetHashTableHelper::GetKey(EEHashEntry_t *pEntry)
{
    return &SecurityHelper::s_rCachedPsets[(size_t)pEntry->Data];
}


// Generic GUID hash table helper.

EEHashEntry_t *EEGUIDHashTableHelper::AllocateEntry(GUID *pKey, BOOL bDeepCopy, void *pHeap)
{
    EEHashEntry_t *pEntry;

    if (bDeepCopy)
    {
        pEntry = (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY + sizeof(GUID*) + sizeof(GUID)];
        if (pEntry) {
            memcpy(pEntry->Key + sizeof(GUID*), pKey, sizeof(GUID)); 
            *((GUID**)pEntry->Key) = (GUID*)(pEntry->Key + sizeof(GUID*));
        }
    }
    else
    {
        pEntry = (EEHashEntry_t *) new BYTE[SIZEOF_EEHASH_ENTRY + sizeof(GUID*)];
        if (pEntry)
            *((GUID**)pEntry->Key) = pKey;
    }

    return pEntry;
}

void EEGUIDHashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, void *pHeap)
{
    delete [] pEntry;
}

BOOL EEGUIDHashTableHelper::CompareKeys(EEHashEntry_t *pEntry, GUID *pKey)
{
    GUID *pEntryKey = *(GUID**)pEntry->Key;
    return *pEntryKey == *pKey;
}

DWORD EEGUIDHashTableHelper::Hash(GUID *pKey)
{
    DWORD dwHash = 0;
    BYTE *pGuidData = (BYTE*)pKey;

    for (int i = 0; i < sizeof(GUID); i++)
    {
        dwHash = (dwHash << 5) + (dwHash >> 5) + (*pGuidData);
        *pGuidData++;
    }

    return dwHash;
}

GUID *EEGUIDHashTableHelper::GetKey(EEHashEntry_t *pEntry)
{
    return *((GUID**)pEntry->Key);
}


// ============================================================================
// ComComponentInfo hash table helper.
// ============================================================================

EEHashEntry_t *EEClassFactoryInfoHashTableHelper::AllocateEntry(ClassFactoryInfo *pKey, BOOL bDeepCopy, void *pHeap)
{
    EEHashEntry_t *pEntry;
    DWORD StringLen = 0;

    _ASSERTE(bDeepCopy && "Non deep copy is not supported by the EEComCompInfoHashTableHelper");

    if (pKey->m_strServerName)
        StringLen = (DWORD)wcslen(pKey->m_strServerName) + 1;
    pEntry = (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY + sizeof(ClassFactoryInfo) + StringLen * sizeof(WCHAR)];
    if (pEntry) {
        memcpy(pEntry->Key + sizeof(ClassFactoryInfo), pKey->m_strServerName, StringLen * sizeof(WCHAR)); 
        ((ClassFactoryInfo*)pEntry->Key)->m_strServerName = pKey->m_strServerName ? (WCHAR*)(pEntry->Key + sizeof(ClassFactoryInfo)) : NULL;
        ((ClassFactoryInfo*)pEntry->Key)->m_clsid = pKey->m_clsid;
    }

    return pEntry;
}

void EEClassFactoryInfoHashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, void *pHeap)
{
    delete [] pEntry;
}

BOOL EEClassFactoryInfoHashTableHelper::CompareKeys(EEHashEntry_t *pEntry, ClassFactoryInfo *pKey)
{
    // First check the GUIDs.
    if (((ClassFactoryInfo*)pEntry->Key)->m_clsid != pKey->m_clsid)
        return FALSE;

    // Next do a trivial comparition on the server name pointer values.
    if (((ClassFactoryInfo*)pEntry->Key)->m_strServerName == pKey->m_strServerName)
        return TRUE;

    // If the pointers are not equal then if one is NULL then the server names are different.
    if (!((ClassFactoryInfo*)pEntry->Key) || !pKey->m_strServerName)
        return FALSE;

    // Finally do a string comparition of the server names.
    return wcscmp(((ClassFactoryInfo*)pEntry->Key)->m_strServerName, pKey->m_strServerName) == 0;
}

DWORD EEClassFactoryInfoHashTableHelper::Hash(ClassFactoryInfo *pKey)
{
    DWORD dwHash = 0;
    BYTE *pGuidData = (BYTE*)&pKey->m_clsid;

    for (int i = 0; i < sizeof(GUID); i++)
    {
        dwHash = (dwHash << 5) + (dwHash >> 5) + (*pGuidData);
        *pGuidData++;
    }

    if (pKey->m_strServerName)
    {
        WCHAR *pSrvNameData = pKey->m_strServerName;

        while (*pSrvNameData != 0)
        {
            dwHash = (dwHash << 5) + (dwHash >> 5) + (*pSrvNameData);
            *pSrvNameData++;
        }
    }

    return dwHash;
}

ClassFactoryInfo *EEClassFactoryInfoHashTableHelper::GetKey(EEHashEntry_t *pEntry)
{
    return (ClassFactoryInfo*)pEntry->Key;
}


// ============================================================================
// Class hash table methods
// ============================================================================
void *EEClassHashTable::operator new(size_t size, LoaderHeap *pHeap, DWORD dwNumBuckets, ClassLoader *pLoader, BOOL bCaseInsensitive)
{
    BYTE *              pMem;
    EEClassHashTable *  pThis;

    WS_PERF_SET_HEAP(LOW_FREQ_HEAP);    
    pMem = (BYTE *) pHeap->AllocMem(size + dwNumBuckets*sizeof(EEClassHashEntry_t*));
    if (pMem == NULL)
        return NULL;
    // Don't need to memset() since this was VirtualAlloc()'d memory
    WS_PERF_UPDATE_DETAIL("EEClassHashTable new", size + dwNumBuckets*sizeof(EEClassHashEntry_t*), pMem);
    pThis = (EEClassHashTable *) pMem;

#ifdef _DEBUG
    pThis->m_dwDebugMemory = (DWORD)(size + dwNumBuckets*sizeof(EEClassHashEntry_t*));
#endif

    pThis->m_dwNumBuckets = dwNumBuckets;
    pThis->m_dwNumEntries = 0;
    pThis->m_pBuckets = (EEClassHashEntry_t**) (pMem + size);
    pThis->m_pHeap    = pHeap;
    pThis->m_pLoader  = pLoader;
    pThis->m_bCaseInsensitive = bCaseInsensitive;

    return pThis;
}


// Do nothing - heap allocated memory
void EEClassHashTable::operator delete(void *p)
{
}


// Do nothing - heap allocated memory
EEClassHashTable::~EEClassHashTable()
{
}

// Empty Constructor
EEClassHashTable::EEClassHashTable()
{
}


EEClassHashEntry_t *EEClassHashTable::AllocNewEntry()
{
    _ASSERTE (m_pLoader);
    EEClassHashEntry_t *pTmp;
    DWORD dwSizeofEntry;
    WS_PERF_SET_HEAP(LOW_FREQ_HEAP);    

    dwSizeofEntry = sizeof(EEClassHashEntry_t);
    pTmp = (EEClassHashEntry_t *) m_pHeap->AllocMem(dwSizeofEntry);
    
    WS_PERF_UPDATE_DETAIL("EEClassHashTable:AllocNewEntry:sizeofEEClassHashEntry", dwSizeofEntry, pTmp);
    WS_PERF_UPDATE_COUNTER (EECLASSHASH_TABLE, LOW_FREQ_HEAP, 1);
    WS_PERF_UPDATE_COUNTER (EECLASSHASH_TABLE_BYTES, LOW_FREQ_HEAP, dwSizeofEntry);

    return pTmp;
}

//
// This function gets called whenever the class hash table seems way too small.
// Its task is to allocate a new bucket table that is a lot bigger, and transfer
// all the entries to it.
// 
BOOL EEClassHashTable::GrowHashTable()
{    

    _ASSERTE (m_pLoader);
    // Make the new bucket table 4 times bigger
    DWORD dwNewNumBuckets = m_dwNumBuckets * 4;
    EEClassHashEntry_t **pNewBuckets = (EEClassHashEntry_t **)m_pHeap->AllocMem(dwNewNumBuckets*sizeof(pNewBuckets[0]));

    if (!pNewBuckets)
        return FALSE;
    
    // Don't need to memset() since this was VirtualAlloc()'d memory
    // memset(pNewBuckets, 0, dwNewNumBuckets*sizeof(pNewBuckets[0]));

    // Run through the old table and transfer all the entries

    // Be sure not to mess with the integrity of the old table while
    // we are doing this, as there can be concurrent readers!  Note that
    // it is OK if the concurrent reader misses out on a match, though -
    // they will have to acquire the lock on a miss & try again.

    for (DWORD i = 0; i < m_dwNumBuckets; i++)
    {
        EEClassHashEntry_t * pEntry = m_pBuckets[i];

        // Try to lock out readers from scanning this bucket.  This is
        // obviously a race which may fail. However, note that it's OK
        // if somebody is already in the list - it's OK if we mess
        // with the bucket groups, as long as we don't destroy
        // anything.  The lookup function will still do appropriate
        // comparison even if it wanders aimlessly amongst entries
        // while we are rearranging things.  If a lookup finds a match
        // under those circumstances, great.  If not, they will have
        // to acquire the lock & try again anyway.

        m_pBuckets[i] = NULL;

        while (pEntry != NULL)
        {
            DWORD dwNewBucket = (DWORD)(pEntry->dwHashValue % dwNewNumBuckets);
            EEClassHashEntry_t * pNextEntry  = pEntry->pNext;

            // Insert at head of bucket if non-nested, at end if nested
            if (pEntry->pEncloser && pNewBuckets[dwNewBucket]) {
                EEClassHashEntry_t *pCurrent = pNewBuckets[dwNewBucket];
                while (pCurrent->pNext)
                    pCurrent = pCurrent->pNext;
                
                pCurrent->pNext  = pEntry;
                pEntry->pNext = NULL;
            }
            else {
                pEntry->pNext = pNewBuckets[dwNewBucket];
                pNewBuckets[dwNewBucket] = pEntry;
            }

            pEntry = pNextEntry;
        }
    }

    // Finally, store the new number of buckets and the new bucket table
    m_dwNumBuckets = dwNewNumBuckets;
    m_pBuckets = pNewBuckets;

    return TRUE;
}

void EEClassHashTable::ConstructKeyFromData(EEClassHashEntry_t *pEntry, // IN  : Entry to compare
                                                     LPUTF8 *Key, // OUT : Key is stored here if *pCompareKey is false
                                                     CQuickBytes& cqb) // IN/OUT : Key may be allocated from here
{
    // cqb - If m_bCaseInsensitive is true for the hash table, the bytes in Key will be allocated
    // from cqb. This is to prevent wasting bytes in the Loader Heap. Thusly, it is important to note that
    // in this case, the lifetime of Key is bounded by the lifetime of cqb, which will free the memory
    // it allocated on destruction.
    
    _ASSERTE (m_pLoader);
    LPSTR        pszName = NULL;
    LPSTR        pszNameSpace = NULL;
    IMDInternalImport *pInternalImport = NULL;
    
    HashDatum Data = NULL;
    if (!m_bCaseInsensitive)
        Data = pEntry->Data;
    else
        Data = ((EEClassHashEntry_t*)(pEntry->Data))->Data;

    // Lower bit is a discriminator.  If the lower bit is NOT SET, it means we have
    // a EEClass* Otherwise, we have a mdtTypedef/mdtExportedType.
    if ((((size_t) Data) & 1) == 0)
    {
        TypeHandle pType = TypeHandle(Data);
        _ASSERTE (pType.AsMethodTable());
        EEClass *pCl = pType.AsMethodTable()->GetClass();
        _ASSERTE(pCl);
        pCl->GetMDImport()->GetNameOfTypeDef(pCl->Getcl(), (LPCSTR *)&pszName, (LPCSTR *)&pszNameSpace);
        
    }
    else
    {
        // We have a mdtoken
        _ASSERTE (m_pLoader);

        // call the light weight verson first
        mdToken mdtUncompressed = m_pLoader->UncompressModuleAndClassDef(Data);
        if (TypeFromToken(mdtUncompressed) == mdtExportedType)
        {
            m_pLoader->GetAssembly()->GetManifestImport()->GetExportedTypeProps(mdtUncompressed, 
                                                                                (LPCSTR *)&pszNameSpace,
                                                                                (LPCSTR *)&pszName, 
                                                                                NULL,   //mdImpl
                                                                                NULL,   // type def
                                                                                NULL);  // flags
        }
        else
        {
            _ASSERTE(TypeFromToken(mdtUncompressed) == mdtTypeDef);

            HRESULT     hr = S_OK;
            Module *    pUncompressedModule;
            mdTypeDef   UncompressedCl;
            mdExportedType mdCT;
            OBJECTREF* pThrowable = NULL;
            hr = m_pLoader->UncompressModuleAndClassDef(Data, 0,
                                                        &pUncompressedModule, &UncompressedCl,
                                                        &mdCT, pThrowable);
    
            if(SUCCEEDED(hr)) 
            {
                _ASSERTE ((mdCT == NULL) && "Uncompressed token of unexpected type");
                _ASSERTE (pUncompressedModule && "Uncompressed token of unexpected type");
                pInternalImport = pUncompressedModule->GetMDImport();
                _ASSERTE(pInternalImport && "Uncompressed token has no MD import");
                pInternalImport->GetNameOfTypeDef(UncompressedCl, (LPCSTR *)&pszName, (LPCSTR *)&pszNameSpace);
            }
        }
    }
    if (!m_bCaseInsensitive)
    {
        Key[0] = pszNameSpace;
        Key[1] = pszName;
        _ASSERTE (strcmp(pEntry->DebugKey[1], Key[1]) == 0);
        _ASSERTE (strcmp(pEntry->DebugKey[0], Key[0]) == 0);
    }
    else
    {
        int iNSLength = (int)(strlen(pszNameSpace) + 1);
        int iNameLength = (int)(strlen(pszName) + 1);
        LPUTF8 pszOutNameSpace = (LPUTF8) cqb.Alloc(iNSLength + iNameLength);
        LPUTF8 pszOutName = (LPUTF8) pszOutNameSpace + iNSLength;
        if ((InternalCasingHelper::InvariantToLower(pszOutNameSpace, iNSLength, pszNameSpace) < 0) ||
            (InternalCasingHelper::InvariantToLower(pszOutName, iNameLength, pszName) < 0)) 
        {
            _ASSERTE(!"Unable to convert to lower-case");
        }
        else
        {
            Key[0] = pszOutNameSpace;
            Key[1] = pszOutName;
            _ASSERTE (strcmp(pEntry->DebugKey[1], Key[1]) == 0);
            _ASSERTE (strcmp(pEntry->DebugKey[0], Key[0]) == 0);
        }        
    }

}

EEClassHashEntry_t *EEClassHashTable::InsertValue(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum Data, EEClassHashEntry_t *pEncloser)
{
    _ASSERTE(pszNamespace != NULL);
    _ASSERTE(pszClassName != NULL);
    _ASSERTE(m_dwNumBuckets != 0);
    _ASSERTE (m_pLoader);

    DWORD           dwHash = Hash(pszNamespace, pszClassName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;

    return InsertValueHelper (pszNamespace, pszClassName, Data, pEncloser, dwHash, dwBucket);
}

EEClassHashEntry_t *EEClassHashTable::InsertValueHelper(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum Data, EEClassHashEntry_t *pEncloser, DWORD dwHash, DWORD dwBucket)
{
    EEClassHashEntry_t * pNewEntry;

    pNewEntry = AllocNewEntry();

    if (!pNewEntry)
        return NULL;
        
	// Fill the data structure before we put it in the list
    pNewEntry->pEncloser = pEncloser;
    pNewEntry->Data         = Data;
    pNewEntry->dwHashValue  = dwHash;

#ifdef _DEBUG
    LPCUTF8         Key[2] = { pszNamespace, pszClassName };
    memcpy(pNewEntry->DebugKey, Key, sizeof(LPCUTF8)*2);
#endif

    // Insert at head of bucket if non-nested, at end if nested
    if (pEncloser && m_pBuckets[dwBucket]) {
        EEClassHashEntry_t *pCurrent = m_pBuckets[dwBucket];
        while (pCurrent->pNext)
            pCurrent = pCurrent->pNext;

        pNewEntry->pNext = NULL;
        pCurrent->pNext  = pNewEntry;
    }
    else {
        pNewEntry->pNext     = m_pBuckets[dwBucket];
        m_pBuckets[dwBucket] = pNewEntry;
    }
    
#ifdef _DEBUG
    // now verify that we can indeed get the namespace, name from this data
    LPUTF8         ConstructedKey[2];
    CQuickBytes     cqbKeyMemory;
    ConstructedKey[0] = ConstructedKey[1] = NULL;

    ConstructKeyFromData (pNewEntry, ConstructedKey, cqbKeyMemory);

    _ASSERTE (strcmp(pNewEntry->DebugKey[1], ConstructedKey[1]) == 0);
    _ASSERTE (strcmp(pNewEntry->DebugKey[0], ConstructedKey[0]) == 0);
    cqbKeyMemory.Destroy();
    ConstructedKey[0] = ConstructedKey[1] = NULL;    
#endif

    m_dwNumEntries++;
    if  (m_dwNumEntries > m_dwNumBuckets*2)
        GrowHashTable();

    return pNewEntry;
}

EEClassHashEntry_t *EEClassHashTable::InsertValueIfNotFound(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum *pData, EEClassHashEntry_t *pEncloser, BOOL IsNested, BOOL *pbFound)
{
    _ASSERTE (m_pLoader);
    _ASSERTE(pszNamespace != NULL);
    _ASSERTE(pszClassName != NULL);
    _ASSERTE(m_dwNumBuckets != 0);
    _ASSERTE (m_pLoader);

    DWORD           dwHash = Hash(pszNamespace, pszClassName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;

    EEClassHashEntry_t * pNewEntry = FindItemHelper (pszNamespace, pszClassName, IsNested, dwHash, dwBucket);
    if (pNewEntry)
    {
        *pData = pNewEntry->Data;
        *pbFound = TRUE;
        return pNewEntry;
    }
    

    // Reached here implies that we didn't find the entry and need to insert it 
    *pbFound = FALSE;

    return InsertValueHelper (pszNamespace, pszClassName, *pData, pEncloser, dwHash, dwBucket);
}


EEClassHashEntry_t *EEClassHashTable::FindItem(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, BOOL IsNested)
{
    _ASSERTE (m_pLoader);
    _ASSERTE(pszNamespace != NULL);
    _ASSERTE(pszClassName != NULL);
    _ASSERTE(m_dwNumBuckets != 0);

    DWORD           dwHash = Hash(pszNamespace, pszClassName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;

    return FindItemHelper (pszNamespace, pszClassName, IsNested, dwHash, dwBucket);
}

EEClassHashEntry_t *EEClassHashTable::FindItemHelper(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, BOOL IsNested, DWORD dwHash, DWORD dwBucket)
{
    EEClassHashEntry_t * pSearch;

    for (pSearch = m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash)
        {
            LPCUTF8         Key[2] = { pszNamespace, pszClassName };
            if (CompareKeys(pSearch, Key)) 
            {
                // If (IsNested), then we're looking for a nested class
                // If (pSearch->pEncloser), we've found a nested class
                if (IsNested) {
                    if (pSearch->pEncloser)
                        return pSearch;
                }
                else {
                    if (pSearch->pEncloser)
                        return NULL; // searched past non-nested classes
                    else                    
                        return pSearch;
                }
            }
        }
    }

    return NULL;
}


EEClassHashEntry_t *EEClassHashTable::FindNextNestedClass(NameHandle* pName, HashDatum *pData, EEClassHashEntry_t *pBucket)
{
    _ASSERTE (m_pLoader);
    _ASSERTE(pName);
    if(pName->GetNameSpace())
    {
        return FindNextNestedClass(pName->GetNameSpace(), pName->GetName(), pData, pBucket);
    }
    else {
        return FindNextNestedClass(pName->GetName(), pData, pBucket);
    }
}


EEClassHashEntry_t *EEClassHashTable::FindNextNestedClass(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum *pData, EEClassHashEntry_t *pBucket)
{
    _ASSERTE (m_pLoader);
    DWORD           dwHash = Hash(pszNamespace, pszClassName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    EEClassHashEntry_t * pSearch = pBucket->pNext;

    for (; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash)
        {
            LPCUTF8         Key[2] = { pszNamespace, pszClassName };
            if (CompareKeys(pSearch, Key)) 
            {
                *pData = pSearch->Data;
                return pSearch;
            }
        }
    }

    return NULL;
}


EEClassHashEntry_t *EEClassHashTable::FindNextNestedClass(LPCUTF8 pszFullyQualifiedName, HashDatum *pData, EEClassHashEntry_t *pBucket)
{
    _ASSERTE (m_pLoader);
    EEQuickBytes qb;
    LPSTR szNamespace = (LPSTR) qb.Alloc(MAX_NAMESPACE_LENGTH * sizeof(CHAR));
    LPCUTF8 p;

    if ((p = ns::FindSep(pszFullyQualifiedName)) != NULL)
    {
        SIZE_T d = p - pszFullyQualifiedName;
        if(d >= MAX_NAMESPACE_LENGTH)
            return NULL;
        memcpy(szNamespace, pszFullyQualifiedName, d);
        szNamespace[ d ] = '\0';
        p++;
    }
    else
    {
        szNamespace[0] = '\0';
        p = pszFullyQualifiedName;
    }

    return FindNextNestedClass(szNamespace, p, pData, pBucket);
}


EEClassHashEntry_t * EEClassHashTable::GetValue(LPCUTF8 pszFullyQualifiedName, HashDatum *pData, BOOL IsNested)
{
    _ASSERTE (m_pLoader);
    EEQuickBytes qb;
    LPSTR szNamespace = (LPSTR) qb.Alloc(MAX_NAMESPACE_LENGTH * sizeof(CHAR));
    LPCUTF8 p;

    p = ns::FindSep(pszFullyQualifiedName);
    if (p != NULL)
    {
        SIZE_T d = p - pszFullyQualifiedName;
        if(d >= MAX_NAMESPACE_LENGTH)
            return NULL;
        memcpy(szNamespace, pszFullyQualifiedName, d);
        szNamespace[ d ] = '\0';
        p++;
    }
    else
    {
        szNamespace[0] = '\0';
        p = pszFullyQualifiedName;
    }

    return GetValue(szNamespace, p, pData, IsNested);
}


EEClassHashEntry_t * EEClassHashTable::GetValue(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum *pData, BOOL IsNested)
{
    _ASSERTE (m_pLoader);
    EEClassHashEntry_t *pItem = FindItem(pszNamespace, pszClassName, IsNested);

    if (pItem)
        *pData = pItem->Data;

    return pItem;
}


EEClassHashEntry_t * EEClassHashTable::GetValue(NameHandle* pName, HashDatum *pData, BOOL IsNested)
{
    _ASSERTE(pName);
    _ASSERTE (m_pLoader);
    if(pName->GetNameSpace() == NULL) {
        return GetValue(pName->GetName(), pData, IsNested);
    }
    else {
        return GetValue(pName->GetNameSpace(), pName->GetName(), pData, IsNested);
    }
}

// Returns TRUE if two keys are the same string
BOOL EEClassHashTable::CompareKeys(EEClassHashEntry_t *pEntry, LPCUTF8 *pKey2)
{
    _ASSERTE (m_pLoader);
    _ASSERTE (pEntry);
    _ASSERTE (pKey2);

    LPUTF8 pKey1 [2] = {NULL, NULL};
    CQuickBytes cqbKey1Memory;
    ConstructKeyFromData(pEntry, pKey1, cqbKey1Memory);

    // Try pointer comparison first
    BOOL bReturn = ( 
            ((pKey1[0] == pKey2[0]) && (pKey1[1] == pKey2[1])) ||
            ((strcmp (pKey1[0], pKey2[0]) == 0) && (strcmp (pKey1[1], pKey2[1]) == 0))
           );

#ifdef _DEBUG
    // Just to be explicit
    cqbKey1Memory.Destroy();
    pKey1[0] = pKey1[1] = NULL;
#endif

    return bReturn;
}


DWORD EEClassHashTable::Hash(LPCUTF8 pszNamespace, LPCUTF8 pszClassName)
{
    DWORD dwHash = 5381;
    DWORD dwChar;

    while ((dwChar = *pszNamespace++) != 0)
        dwHash = ((dwHash << 5) + dwHash) ^ dwChar;

    while ((dwChar = *pszClassName++) != 0)
        dwHash = ((dwHash << 5) + dwHash) ^ dwChar;

    return  dwHash;
}


/*===========================MakeCaseInsensitiveTable===========================
**Action: Creates a case-insensitive lookup table for class names.  We create a 
**        full path (namespace & class name) in lowercase and then use that as the
**        key in our table.  The hash datum is a pointer to the EEClassHashEntry in this
**        table.
**
!!        You MUST have already acquired the appropriate lock before calling this.!!
**
**Returns:The newly allocated and completed hashtable.
==============================================================================*/
EEClassHashTable *EEClassHashTable::MakeCaseInsensitiveTable(ClassLoader *pLoader) {
    EEClassHashEntry_t *pTempEntry;
    LPUTF8         pszLowerClsName;
    LPUTF8         pszLowerNameSpace;
    unsigned int   iRow;

    _ASSERTE (m_pLoader);
    _ASSERTE (pLoader == m_pLoader);

    //Allocate the table and verify that we actually got one.
    //Initialize this table with the same number of buckets
    //that we had initially.
    EEClassHashTable * pCaseInsTable = new (pLoader->GetAssembly()->GetLowFrequencyHeap(), m_dwNumBuckets, pLoader, TRUE /* bCaseInsensitive */) EEClassHashTable();
    if (!pCaseInsTable)
        goto ErrorExit;

    //Walk all of the buckets and insert them into our new case insensitive table
    for (iRow=0; iRow<m_dwNumBuckets; iRow++) {
        pTempEntry = m_pBuckets[iRow];

        while (pTempEntry) {
            //Build the cannonical name (convert it to lowercase).
            //Key[0] is the namespace, Key[1] is class name.
            LPUTF8 key[2];
            CQuickBytes cqbKeyMemory;
            ConstructKeyFromData(pTempEntry, key, cqbKeyMemory);
                
            if (!pLoader->CreateCanonicallyCasedKey(key[0], key[1], &pszLowerNameSpace, &pszLowerClsName))
                goto ErrorExit;

#ifdef _DEBUG
            // Just to be explicit that the life of key is bound by cqbKeyMemory
            cqbKeyMemory.Destroy();
            key[0] = key[1] = NULL;
#endif
            
            //Add the newly created name to our hash table.  The hash datum is a pointer
            //to the entry associated with that name in this hashtable.
            pCaseInsTable->InsertValue(pszLowerNameSpace, pszLowerClsName, (HashDatum)pTempEntry, pTempEntry->pEncloser);
            
            //Get the next entry.
            pTempEntry = pTempEntry->pNext;
        }
    }

    return pCaseInsTable;
 ErrorExit:
    //Deleting the table is going to leave the strings around, but they're 
    //in a heap that will get cleaned up when we exit, so that's not tragic.
    if (pCaseInsTable) {
        delete pCaseInsTable;
    }
    return NULL;
}


// ============================================================================
// Scope/Class hash table methods
// ============================================================================
void *EEScopeClassHashTable::operator new(size_t size, LoaderHeap *pHeap, DWORD dwNumBuckets)
{
    BYTE *                  pMem;
    EEScopeClassHashTable * pThis;

    WS_PERF_SET_HEAP(LOW_FREQ_HEAP);    
    pMem = (BYTE *) pHeap->AllocMem(size + dwNumBuckets*sizeof(EEHashEntry_t*));
    if (pMem == NULL)
        return NULL;
    WS_PERF_UPDATE_DETAIL("EEScopeClassHashTable new", size + dwNumBuckets*sizeof(EEHashEntry_t*), pMem);

    pThis = (EEScopeClassHashTable *) pMem;

#ifdef _DEBUG
    pThis->m_dwDebugMemory = (DWORD)(size + dwNumBuckets*sizeof(EEHashEntry_t*));
#endif

    pThis->m_dwNumBuckets = dwNumBuckets;
    pThis->m_pBuckets = (EEHashEntry_t**) (pMem + size);

    // Don't need to memset() since this was VirtualAlloc()'d memory
    // memset(pThis->m_pBuckets, 0, dwNumBuckets*sizeof(EEHashEntry_t*));

    return pThis;
}


// Do nothing - heap allocated memory
void EEScopeClassHashTable::operator delete(void *p)
{
}


// Do nothing - heap allocated memory
EEScopeClassHashTable::~EEScopeClassHashTable()
{
}


// Empty constructor
EEScopeClassHashTable::EEScopeClassHashTable()
{
}

EEHashEntry_t *EEScopeClassHashTable::AllocNewEntry()
{
#ifdef _DEBUG
    m_dwDebugMemory += (SIZEOF_EEHASH_ENTRY + sizeof(mdScope) + sizeof(mdTypeDef));
#endif

    return (EEHashEntry_t *) new (nothrow) BYTE[SIZEOF_EEHASH_ENTRY + sizeof(mdScope) + sizeof(mdTypeDef)];
}


//
// Does not handle duplicates!
//
BOOL EEScopeClassHashTable::InsertValue(mdScope sc, mdTypeDef cl, HashDatum Data)
{
    _ASSERTE(m_dwNumBuckets != 0);

    DWORD           dwHash = Hash(sc, cl);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    EEHashEntry_t * pNewEntry;
    size_t          Key[2] = { (size_t)sc, (size_t)cl };

    pNewEntry = AllocNewEntry();
    if (pNewEntry == NULL)
        return FALSE;

    // Insert at head of bucket
    pNewEntry->pNext        = m_pBuckets[dwBucket];
    pNewEntry->Data         = Data;
    pNewEntry->dwHashValue  = dwHash;
    memcpy(pNewEntry->Key, Key, sizeof(mdScope) + sizeof(mdTypeDef));

    m_pBuckets[dwBucket] = pNewEntry;

    return TRUE;
}


BOOL EEScopeClassHashTable::DeleteValue(mdScope sc, mdTypeDef cl)
{
    _ASSERTE(m_dwNumBuckets != 0);

    DWORD           dwHash = Hash(sc, cl);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    EEHashEntry_t * pSearch;
    EEHashEntry_t **ppPrev = &m_pBuckets[dwBucket];
    size_t          Key[2] = { (size_t)sc, (size_t)cl };

    for (pSearch = m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash && CompareKeys((size_t*) pSearch->Key, (size_t*)Key))
        {
            *ppPrev = pSearch->pNext;
            delete(pSearch);
            return TRUE;
        }

        ppPrev = &pSearch->pNext;
    }

    return FALSE;
}


EEHashEntry_t *EEScopeClassHashTable::FindItem(mdScope sc, mdTypeDef cl)
{
    _ASSERTE(m_dwNumBuckets != 0);

    DWORD           dwHash = Hash(sc, cl);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    EEHashEntry_t * pSearch;
    size_t          Key[2] = { (size_t)sc, (size_t)cl };

    for (pSearch = m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash && CompareKeys((size_t*) pSearch->Key, (size_t*)Key))
            return pSearch;
    }

    return NULL;
}


BOOL EEScopeClassHashTable::GetValue(mdScope sc, mdTypeDef cl, HashDatum *pData)
{
    EEHashEntry_t *pItem = FindItem(sc, cl);

    if (pItem != NULL)
    {
        *pData = pItem->Data;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL EEScopeClassHashTable::ReplaceValue(mdScope sc, mdTypeDef cl, HashDatum Data)
{
    EEHashEntry_t *pItem = FindItem(sc, cl);

    if (pItem != NULL)
    {
        pItem->Data = Data;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


// Returns TRUE if two keys are the same string
BOOL EEScopeClassHashTable::CompareKeys(size_t *pKey1, size_t *pKey2)
{
    return !memcmp(pKey1, pKey2, sizeof(mdTypeDef) + sizeof(mdScope));
}


DWORD EEScopeClassHashTable::Hash(mdScope sc, mdTypeDef cl)
{
    return (DWORD)((size_t)sc ^ (size_t)cl); // @TODO WIN64 - Pointer Truncation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eehash.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//emp
// File: eehash.h
//
// Provides hash table functionality needed in the EE - intended to be replaced later with better
// algorithms, but which have the same interface.
//
// Two requirements are:
//
// 1. Any number of threads can be reading the hash table while another thread is writing, without error.
// 2. Only one thread can write at a time.
// 3. When calling ReplaceValue(), a reader will get the old value, or the new value, but not something
//    in between.
// 4. DeleteValue() is an unsafe operation - no other threads can be in the hash table when this happens.
//
#ifndef _EE_HASH_H
#define _EE_HASH_H

#include "exceptmacros.h"
#include "SyncClean.hpp"

#include <member-offset-info.h>

class ClassLoader;
class NameHandle;
class ExpandSig;
class FunctionTypeDesc;
struct PsetCacheEntry;

// The "blob" you get to store in the hash table

typedef void* HashDatum;

// The heap that you want the allocation to be done in

typedef void* AllocationHeap;


// One of these is present for each element in the table.
// Update the SIZEOF_EEHASH_ENTRY macro below if you change this
// struct

typedef struct EEHashEntry
{
    struct EEHashEntry *pNext;
    DWORD               dwHashValue;
    HashDatum           Data;
    BYTE                Key[1]; // The key is stored inline
} EEHashEntry_t;

// The key[1] is a place holder for the key. sizeof(EEHashEntry) 
// return 16 bytes since it packs the struct with 3 bytes. 
#define SIZEOF_EEHASH_ENTRY (sizeof(EEHashEntry) - 4)


// Struct to hold a client's iteration state
struct EEHashTableIteration;


// Generic hash table.

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
class EEHashTable
{
    friend struct MEMBER_OFFSET_INFO(EEHashTableOfEEClass);
public:
    EEHashTable();
    ~EEHashTable();

    BOOL            Init(DWORD dwNumBuckets, LockOwner *pLock, AllocationHeap pHeap = 0,BOOL CheckThreadSafety = TRUE);

    BOOL            InsertValue(KeyType pKey, HashDatum Data, BOOL bDeepCopyKey = bDefaultCopyIsDeep);
    BOOL            InsertKeyAsValue(KeyType pKey, BOOL bDeepCopyKey = bDefaultCopyIsDeep); 
    BOOL            DeleteValue(KeyType pKey);
    BOOL            ReplaceValue(KeyType pKey, HashDatum Data);
    BOOL            ReplaceKey(KeyType pOldKey, KeyType pNewKey);
    void            ClearHashTable();
    void            EmptyHashTable();
	BOOL            IsEmpty();

    // Reader functions. Please place any functions that can be called from the 
    // reader threads here.
    BOOL            GetValue(KeyType pKey, HashDatum *pData);
    BOOL            GetValue(KeyType pKey, HashDatum *pData, DWORD hashValue);
    DWORD			GetHash(KeyType Key);
    
    

    // Walk through all the entries in the hash table, in meaningless order, without any
    // synchronization.
    //
    //           IterateStart()
    //           while (IterateNext())
    //              IterateGetKey();
    //
    void            IterateStart(EEHashTableIteration *pIter);
    BOOL            IterateNext(EEHashTableIteration *pIter);
    KeyType         IterateGetKey(EEHashTableIteration *pIter);
    HashDatum       IterateGetValue(EEHashTableIteration *pIter);

private:
    BOOL            GrowHashTable();
    EEHashEntry_t * FindItem(KeyType pKey);
    EEHashEntry_t * FindItem(KeyType pKey, DWORD hashValue);

    // Double buffer to fix the race condition of growhashtable (the update
    // of m_pBuckets and m_dwNumBuckets has to be atomic, so we double buffer
    // the structure and access it through a pointer, which can be updated
    // atomically. The union is in order to not change the SOS macros.
    
    struct BucketTable
    {
        EEHashEntry_t ** m_pBuckets;    // Pointer to first entry for each bucket  
        DWORD            m_dwNumBuckets;
    } m_BucketTable[2];

    // In a function we MUST only read this value ONCE, as the writer thread can change
    // the value asynchronously. We make this member volatile the compiler won't do copy propagation 
    // optimizations that can make this read happen more than once. Note that we  only need 
    // this property for the readers. As they are the ones that can have
    // this variable changed (note also that if the variable was enregistered we wouldn't
    // have any problem)
    // BE VERY CAREFUL WITH WHAT YOU DO WITH THIS VARIABLE AS USING IT BADLY CAN CAUSE 
    // RACING CONDITIONS
    BucketTable* volatile   m_pVolatileBucketTable;
    
    DWORD                   m_dwNumEntries;
	AllocationHeap          m_Heap;
    volatile LONG 	      m_bGrowing;     
#ifdef _DEBUG
    LPVOID          m_lockData;
    FnLockOwner     m_pfnLockOwner;
    DWORD           m_writerThreadId;
	BOOL			m_CheckThreadSafety;
#endif

#ifdef _DEBUG
    // A thread must own a lock for a hash if it is a writer.
    BOOL OwnLock()
    {
		if (m_CheckThreadSafety == FALSE)
			return TRUE;

        if (m_pfnLockOwner == NULL) {
            return m_writerThreadId == GetCurrentThreadId();
        }
        else {
            BOOL ret = m_pfnLockOwner(m_lockData);
            if (!ret) {
                if (g_pGCHeap->IsGCInProgress() && 
                    (dbgOnly_IsSpecialEEThread() || GetThread() == g_pGCHeap->GetGCThread())) {
                    ret = TRUE;
                }
            }
            return ret;
        }
    }
#endif
};


template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::EEHashTable()
{
    m_BucketTable[0].m_pBuckets     = NULL;
    m_BucketTable[0].m_dwNumBuckets = 0;
    m_BucketTable[1].m_pBuckets     = NULL;
    m_BucketTable[1].m_dwNumBuckets = 0;
    
    m_pVolatileBucketTable = &m_BucketTable[0];

    m_dwNumEntries = 0;
    m_bGrowing = 0;
}


template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::~EEHashTable()
{
    if (m_pVolatileBucketTable->m_pBuckets != NULL)
    {
        DWORD i;

        for (i = 0; i < m_pVolatileBucketTable->m_dwNumBuckets; i++)
        {
            EEHashEntry_t *pEntry, *pNext;

            for (pEntry = m_pVolatileBucketTable->m_pBuckets[i]; pEntry != NULL; pEntry = pNext)
            {
                pNext = pEntry->pNext;
                Helper::DeleteEntry(pEntry, m_Heap);
            }
        }

        delete[] (m_pVolatileBucketTable->m_pBuckets-1);
    }
   
}


template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
void EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::ClearHashTable()
{
    //_ASSERTE (OwnLock());
    
    AUTO_COOPERATIVE_GC();

    if (m_pVolatileBucketTable->m_pBuckets != NULL)
    {
        DWORD i;

        for (i = 0; i < m_pVolatileBucketTable->m_dwNumBuckets; i++)
        {
            EEHashEntry_t *pEntry, *pNext;

            for (pEntry = m_pVolatileBucketTable->m_pBuckets[i]; pEntry != NULL; pEntry = pNext)
            {
                pNext = pEntry->pNext;
                Helper::DeleteEntry(pEntry, m_Heap);
            }
        }

        delete[] (m_pVolatileBucketTable->m_pBuckets-1);
        m_pVolatileBucketTable->m_pBuckets = NULL;
    }
   
    m_pVolatileBucketTable->m_dwNumBuckets = 0;
    m_dwNumEntries = 0;
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
void EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::EmptyHashTable()
{
    _ASSERTE (OwnLock());
    
    AUTO_COOPERATIVE_GC();
    
    if (m_pVolatileBucketTable->m_pBuckets != NULL)
    {
        DWORD i;

        for (i = 0; i < m_pVolatileBucketTable->m_dwNumBuckets; i++)
        {
            EEHashEntry_t *pEntry, *pNext;

            for (pEntry = m_pVolatileBucketTable->m_pBuckets[i]; pEntry != NULL; pEntry = pNext)
            {
                pNext = pEntry->pNext;
                Helper::DeleteEntry(pEntry, m_Heap);
            }

            m_pVolatileBucketTable->m_pBuckets[i] = NULL;
        }
    }

    m_dwNumEntries = 0;
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::Init(DWORD dwNumBuckets, LockOwner *pLock, AllocationHeap pHeap=0, BOOL CheckThreadSafety = TRUE)
{
    m_pVolatileBucketTable->m_pBuckets = new EEHashEntry_t*[dwNumBuckets+1];
    if (m_pVolatileBucketTable->m_pBuckets == NULL)
        return FALSE;
    
    memset(m_pVolatileBucketTable->m_pBuckets, 0, (dwNumBuckets+1)*sizeof(EEHashEntry_t*));
    // The first slot links to the next list.
    m_pVolatileBucketTable->m_pBuckets ++;

    m_pVolatileBucketTable->m_dwNumBuckets = dwNumBuckets;

	m_Heap = pHeap;

#ifdef _DEBUG
    if (pLock == NULL) {
        m_lockData = NULL;
        m_pfnLockOwner = NULL;
    }
    else {
        m_lockData = pLock->lock;
        m_pfnLockOwner = pLock->lockOwnerFunc;
    }

    if (m_pfnLockOwner == NULL) {
        m_writerThreadId = GetCurrentThreadId();
    }
	m_CheckThreadSafety = CheckThreadSafety;
#endif
    
    return TRUE;
}


// Does not handle duplicates!

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::InsertValue(KeyType pKey, HashDatum Data, BOOL bDeepCopyKey)
{
    _ASSERTE (OwnLock());
    
    AUTO_COOPERATIVE_GC();

    _ASSERTE(pKey != NULL);
    _ASSERTE(m_pVolatileBucketTable->m_dwNumBuckets != 0);

	BOOL  fSuccess = FALSE;
    DWORD dwHash = Helper::Hash(pKey);
    DWORD dwBucket = dwHash % m_pVolatileBucketTable->m_dwNumBuckets;
    EEHashEntry_t * pNewEntry;

    pNewEntry = Helper::AllocateEntry(pKey, bDeepCopyKey, m_Heap);
    if (pNewEntry != NULL)
    {     

	    // Fill in the information for the new entry.
	    pNewEntry->pNext        = m_pVolatileBucketTable->m_pBuckets[dwBucket];
	    pNewEntry->Data         = Data;
	    pNewEntry->dwHashValue  = dwHash;

	    // Insert at head of bucket
	    m_pVolatileBucketTable->m_pBuckets[dwBucket]    = pNewEntry;

	    m_dwNumEntries++;
	    fSuccess = TRUE;
	    if  (m_dwNumEntries > m_pVolatileBucketTable->m_dwNumBuckets*2)
	    {
	        fSuccess = GrowHashTable();
	    }
	}
	
    return fSuccess;
}


// Similar to the above, except that the HashDatum is a pointer to key.
template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::InsertKeyAsValue(KeyType pKey, BOOL bDeepCopyKey)
{
    _ASSERTE (OwnLock());
    
    AUTO_COOPERATIVE_GC();

    _ASSERTE(pKey != NULL);
    _ASSERTE(m_pVolatileBucketTable->m_dwNumBuckets != 0);

	BOOL 			fSuccess = FALSE;
    DWORD           dwHash = Helper::Hash(pKey);
    DWORD           dwBucket = dwHash % m_pVolatileBucketTable->m_dwNumBuckets;
    EEHashEntry_t * pNewEntry;

    pNewEntry = Helper::AllocateEntry(pKey, bDeepCopyKey, m_Heap);
    if (pNewEntry != NULL)
    {     
	    // Fill in the information for the new entry.
	    pNewEntry->pNext        = m_pVolatileBucketTable->m_pBuckets[dwBucket];
	    pNewEntry->dwHashValue  = dwHash;
	    pNewEntry->Data         = *((LPUTF8 *)pNewEntry->Key);

	    // Insert at head of bucket
	    m_pVolatileBucketTable->m_pBuckets[dwBucket]    = pNewEntry;

	    m_dwNumEntries++;
	    fSuccess = TRUE;
	    
	    if  (m_dwNumEntries > m_pVolatileBucketTable->m_dwNumBuckets*2)
	    {
	        fSuccess = GrowHashTable();
	    }
	 }
	
    return fSuccess;
}


template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::DeleteValue(KeyType pKey)
{
    _ASSERTE (OwnLock());
    
    Thread *pThread = GetThread();
    MAYBE_AUTO_COOPERATIVE_GC(pThread ? !(pThread->m_StateNC & Thread::TSNC_UnsafeSkipEnterCooperative) : FALSE);

    _ASSERTE(pKey != NULL);
    _ASSERTE(m_pVolatileBucketTable->m_dwNumBuckets != 0);

    DWORD           dwHash = Helper::Hash(pKey);
    DWORD           dwBucket = dwHash % m_pVolatileBucketTable->m_dwNumBuckets;
    EEHashEntry_t * pSearch;
    EEHashEntry_t **ppPrev = &m_pVolatileBucketTable->m_pBuckets[dwBucket];

    for (pSearch = m_pVolatileBucketTable->m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash && Helper::CompareKeys(pSearch, pKey))
        {
            *ppPrev = pSearch->pNext;
            Helper::DeleteEntry(pSearch, m_Heap);

            // Do we ever want to shrink?
            m_dwNumEntries--;

            return TRUE;
        }

        ppPrev = &pSearch->pNext;
    }

    return FALSE;
}


template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::ReplaceValue(KeyType pKey, HashDatum Data)
{
    _ASSERTE (OwnLock());
    
    EEHashEntry_t *pItem = FindItem(pKey);

    if (pItem != NULL)
    {
        // Required to be atomic
        pItem->Data = Data;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::ReplaceKey(KeyType pOldKey, KeyType pNewKey)
{
    _ASSERTE (OwnLock());
    
    EEHashEntry_t *pItem = FindItem(pOldKey);

    if (pItem != NULL)
    {
        Helper::ReplaceKey (pItem, pNewKey);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
DWORD EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::GetHash(KeyType pKey)
{
	return Helper::Hash(pKey);
}


template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::GetValue(KeyType pKey, HashDatum *pData)
{
    EEHashEntry_t *pItem = FindItem(pKey);

    if (pItem != NULL)
    {
        *pData = pItem->Data;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::GetValue(KeyType pKey, HashDatum *pData, DWORD hashValue)
{
    EEHashEntry_t *pItem = FindItem(pKey, hashValue);

    if (pItem != NULL)
    {
        *pData = pItem->Data;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
EEHashEntry_t *EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::FindItem(KeyType pKey)
{
    _ASSERTE(pKey != NULL);  
	return FindItem(pKey, Helper::Hash(pKey));
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
EEHashEntry_t *EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::FindItem(KeyType pKey, DWORD dwHash)
{
    AUTO_COOPERATIVE_GC();

    // Atomic transaction. In any other point of this method or ANY of the callees of this function you can read
    // from m_pVolatileBucketTable!!!!!!! A racing condition would occur.
    DWORD dwOldNumBuckets;    
    do 
    {    	
        BucketTable* pBucketTable=m_pVolatileBucketTable;
        dwOldNumBuckets = pBucketTable->m_dwNumBuckets;
        
        _ASSERTE(pKey != NULL);
        _ASSERTE(pBucketTable->m_dwNumBuckets != 0);

        DWORD           dwBucket = dwHash % pBucketTable->m_dwNumBuckets;
        EEHashEntry_t * pSearch;

        for (pSearch = pBucketTable->m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->pNext)
        {
            if (pSearch->dwHashValue == dwHash && Helper::CompareKeys(pSearch, pKey))
                return pSearch;
        }

        // There is a race in EEHash Table: when we grow the hash table, we will nuke out 
        // the old bucket table. Readers might be looking up in the old table, they can 
        // fail to find an existing entry. The workaround is to retry the search process 
        // if we are called grow table during the search process.     
    } 
    while ( m_bGrowing || dwOldNumBuckets != m_pVolatileBucketTable->m_dwNumBuckets);

    return NULL;
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::IsEmpty()
{
    return m_dwNumEntries == 0;
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::GrowHashTable()
{
    _ASSERTE(!g_fEEStarted || GetThread()->PreemptiveGCDisabled());
    
    // Make the new bucket table 4 times bigger
    DWORD dwNewNumBuckets = m_pVolatileBucketTable->m_dwNumBuckets * 4;

    // On resizes, we still have an array of old pointers we need to worry about.
    // We can't free these old pointers, for we may hit a race condition where we're
    // resizing and reading from the array at the same time. We need to keep track of these
    // old arrays of pointers, so we're going to use the last item in the array to "link"
    // to previous arrays, so that they may be freed at the end.
    
    EEHashEntry_t **pNewBuckets = new EEHashEntry_t*[dwNewNumBuckets+1];

    if (pNewBuckets == NULL)
    {
        return FALSE;
    }
    
    memset(pNewBuckets, 0, (dwNewNumBuckets+1)*sizeof(EEHashEntry_t*));
    // The first slot is linked to next list.
    pNewBuckets ++;

    // Run through the old table and transfer all the entries

    // Be sure not to mess with the integrity of the old table while
    // we are doing this, as there can be concurrent readers!  Note that
    // it is OK if the concurrent reader misses out on a match, though -
    // they will have to acquire the lock on a miss & try again.

    FastInterlockExchange( (LONG *) &m_bGrowing, 1);
    for (DWORD i = 0; i < m_pVolatileBucketTable->m_dwNumBuckets; i++)
    {
        EEHashEntry_t * pEntry = m_pVolatileBucketTable->m_pBuckets[i];

        // Try to lock out readers from scanning this bucket.  This is
        // obviously a race which may fail. However, note that it's OK
        // if somebody is already in the list - it's OK if we mess
        // with the bucket groups, as long as we don't destroy
        // anything.  The lookup function will still do appropriate
        // comparison even if it wanders aimlessly amongst entries
        // while we are rearranging things.  If a lookup finds a match
        // under those circumstances, great.  If not, they will have
        // to acquire the lock & try again anyway.

        m_pVolatileBucketTable->m_pBuckets[i] = NULL;

        while (pEntry != NULL)
        {
            DWORD           dwNewBucket = pEntry->dwHashValue % dwNewNumBuckets;
            EEHashEntry_t * pNextEntry   = pEntry->pNext;

            pEntry->pNext = pNewBuckets[dwNewBucket];
            pNewBuckets[dwNewBucket] = pEntry;
            pEntry = pNextEntry;
        }
    }


    // Finally, store the new number of buckets and the new bucket table
    BucketTable* pNewBucketTable = (m_pVolatileBucketTable == &m_BucketTable[0]) ?
                    &m_BucketTable[1]:
                    &m_BucketTable[0];

    pNewBucketTable->m_pBuckets = pNewBuckets;
    pNewBucketTable->m_dwNumBuckets = dwNewNumBuckets;

    // Add old table to the to free list. Note that the SyncClean thing will only 
    // delete the buckets at a safe point
    SyncClean::AddEEHashTable (m_pVolatileBucketTable->m_pBuckets);
    
    // Swap the double buffer, this is an atomic operation (the assignment)
    m_pVolatileBucketTable = pNewBucketTable;

    FastInterlockExchange( (LONG *) &m_bGrowing, 0);                                                    
    return TRUE;

}


// Walk through all the entries in the hash table, in meaningless order, without any
// synchronization.
//
//           IterateStart()
//           while (IterateNext())
//              GetKey();
//
template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
void EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::
            IterateStart(EEHashTableIteration *pIter)
{
    _ASSERTE (OwnLock());
    pIter->m_dwBucket = -1;
    pIter->m_pEntry = NULL;

#ifdef _DEBUG
    pIter->m_pTable = this;
#endif
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
BOOL EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::
            IterateNext(EEHashTableIteration *pIter)
{
    _ASSERTE (OwnLock());

    Thread *pThread = GetThread();
    MAYBE_AUTO_COOPERATIVE_GC(pThread ? !(pThread->m_StateNC & Thread::TSNC_UnsafeSkipEnterCooperative) : FALSE);
    
    _ASSERTE(pIter->m_pTable == (void *) this);

    // If we haven't started iterating yet, or if we are at the end of a particular
    // chain, advance to the next chain.
    while (pIter->m_pEntry == NULL || pIter->m_pEntry->pNext == NULL)
    {
        if (++pIter->m_dwBucket >= m_pVolatileBucketTable->m_dwNumBuckets)
        {
            // advanced beyond the end of the table.
            _ASSERTE(pIter->m_dwBucket == m_pVolatileBucketTable->m_dwNumBuckets);   // client keeps asking?
            return FALSE;
        }
        pIter->m_pEntry = m_pVolatileBucketTable->m_pBuckets[pIter->m_dwBucket];

        // If this bucket has no chain, keep advancing.  Otherwise we are done
        if (pIter->m_pEntry)
            return TRUE;
    }

    // We are within a chain.  Advance to the next entry
    pIter->m_pEntry = pIter->m_pEntry->pNext;

    _ASSERTE(pIter->m_pEntry);
    return TRUE;
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
KeyType EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::
            IterateGetKey(EEHashTableIteration *pIter)
{
    _ASSERTE(pIter->m_pTable == (void *) this);
    _ASSERTE(pIter->m_dwBucket < m_pVolatileBucketTable->m_dwNumBuckets && pIter->m_pEntry);
    return Helper::GetKey(pIter->m_pEntry);
}

template <class KeyType, class Helper, BOOL bDefaultCopyIsDeep>
HashDatum EEHashTable<KeyType, Helper, bDefaultCopyIsDeep>::
            IterateGetValue(EEHashTableIteration *pIter)
{
    _ASSERTE(pIter->m_pTable == (void *) this);
    _ASSERTE(pIter->m_dwBucket < m_pVolatileBucketTable->m_dwNumBuckets && pIter->m_pEntry);
    return pIter->m_pEntry->Data;
}

class EEIntHashTableHelper
{
public:
    static EEHashEntry_t *AllocateEntry(int iKey, BOOL bDeepCopy, AllocationHeap pHeap = 0)
    {
        _ASSERTE(!bDeepCopy && "Deep copy is not supported by the EEPtrHashTableHelper");

        EEHashEntry_t *pEntry = (EEHashEntry_t *) new BYTE[SIZEOF_EEHASH_ENTRY + sizeof(int)];
        if (!pEntry)
            return NULL;
        *((int*) pEntry->Key) = iKey;

        return pEntry;
    }

    static void DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap pHeap = 0)
    {
        // Delete the entry.
        delete pEntry;
    }

    static BOOL CompareKeys(EEHashEntry_t *pEntry, int iKey)
    {
        return *((int*)pEntry->Key) == iKey;
    }

    static DWORD Hash(int iKey)
    {
        return (DWORD)iKey;
    }

    static int GetKey(EEHashEntry_t *pEntry)
    {
        return *((int*) pEntry->Key);
    }
};
typedef EEHashTable<int, EEIntHashTableHelper, FALSE> EEIntHashTable;


// UTF8 string hash table. The UTF8 strings are NULL terminated.

class EEUtf8HashTableHelper
{
public:
    static EEHashEntry_t * AllocateEntry(LPCUTF8 pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void            DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL            CompareKeys(EEHashEntry_t *pEntry, LPCUTF8 pKey);
    static DWORD           Hash(LPCUTF8 pKey);
    static LPCUTF8         GetKey(EEHashEntry_t *pEntry);
};

typedef EEHashTable<LPCUTF8, EEUtf8HashTableHelper, TRUE> EEUtf8StringHashTable;


// Unicode String hash table - the keys are UNICODE strings which may
// contain embedded nulls.  An EEStringData struct is used for the key
// which contains the length of the item.  Note that this string is
// not necessarily null terminated and should never be treated as such.
const DWORD ONLY_LOW_CHARS_MASK = 0x80000000;

class EEStringData
{
private:
    LPCWSTR         szString;           // The string data.
    DWORD           cch;                // Characters in the string.
#ifdef _DEBUG
    BOOL            bDebugOnlyLowChars;      // Does the string contain only characters less than 0x80?
    DWORD           dwDebugCch;
#endif // _DEBUG

public:
    // explicilty initialize cch to 0 because SetCharCount uses cch
    EEStringData() : cch(0)
    { 
        SetStringBuffer(NULL);
        SetCharCount(0);
        SetIsOnlyLowChars(FALSE);
    };
    EEStringData(DWORD cchString, LPCWSTR str) : cch(0)
    { 
        SetStringBuffer(str);
        SetCharCount(cchString);
        SetIsOnlyLowChars(FALSE);
    };
    EEStringData(DWORD cchString, LPCWSTR str, BOOL onlyLow) : cch(0)
    { 
        SetStringBuffer(str);
        SetCharCount(cchString);
        SetIsOnlyLowChars(onlyLow);
    };
    inline ULONG GetCharCount() const
    { 
        _ASSERTE ((cch & ~ONLY_LOW_CHARS_MASK) == dwDebugCch);
        return (cch & ~ONLY_LOW_CHARS_MASK); 
    }
    inline void SetCharCount(ULONG _cch)
    {
#ifdef _DEBUG
        dwDebugCch = _cch;
#endif // _DEBUG
        cch = ((DWORD)_cch) | (cch & ONLY_LOW_CHARS_MASK);
    }
    inline LPCWSTR GetStringBuffer() const
    { 
        return (szString); 
    }
    inline void SetStringBuffer(LPCWSTR _szString)
    {
        szString = _szString;
    }
    inline BOOL GetIsOnlyLowChars() const 
    { 
        _ASSERTE(bDebugOnlyLowChars == ((cch & ONLY_LOW_CHARS_MASK) ? TRUE : FALSE));
        return ((cch & ONLY_LOW_CHARS_MASK) ? TRUE : FALSE); 
    }
    inline void SetIsOnlyLowChars(BOOL bIsOnlyLowChars)
    {
#ifdef _DEBUG
        bDebugOnlyLowChars = bIsOnlyLowChars;
#endif // _DEBUG
        bIsOnlyLowChars ? (cch |= ONLY_LOW_CHARS_MASK) : (cch &= ~ONLY_LOW_CHARS_MASK);        
    }
};

class EEUnicodeHashTableHelper
{
public:
    static EEHashEntry_t * AllocateEntry(EEStringData *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void            DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL            CompareKeys(EEHashEntry_t *pEntry, EEStringData *pKey);
    static DWORD           Hash(EEStringData *pKey);
    static EEStringData *  GetKey(EEHashEntry_t *pEntry);
    static void            ReplaceKey(EEHashEntry_t *pEntry, EEStringData *pNewKey);
};

typedef EEHashTable<EEStringData *, EEUnicodeHashTableHelper, TRUE> EEUnicodeStringHashTable;


class EEUnicodeStringLiteralHashTableHelper
{
public:
    static EEHashEntry_t * AllocateEntry(EEStringData *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void            DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL            CompareKeys(EEHashEntry_t *pEntry, EEStringData *pKey);
    static DWORD           Hash(EEStringData *pKey);
    static void            ReplaceKey(EEHashEntry_t *pEntry, EEStringData *pNewKey);
};

typedef EEHashTable<EEStringData *, EEUnicodeStringLiteralHashTableHelper, TRUE> EEUnicodeStringLiteralHashTable;

// Function type descriptor hash table.

class EEFuncTypeDescHashTableHelper
{
public:
    static EEHashEntry_t * AllocateEntry(ExpandSig *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void            DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL            CompareKeys(EEHashEntry_t *pEntry, ExpandSig *pKey);
    static DWORD           Hash(ExpandSig *pKey);
    static ExpandSig *     GetKey(EEHashEntry_t *pEntry);
};

typedef EEHashTable<ExpandSig *, EEFuncTypeDescHashTableHelper, FALSE> EEFuncTypeDescHashTable;


// Permission set hash table.

class EEPsetHashTableHelper
{
public:
    static EEHashEntry_t * AllocateEntry(PsetCacheEntry *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void            DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL            CompareKeys(EEHashEntry_t *pEntry, PsetCacheEntry *pKey);
    static DWORD           Hash(PsetCacheEntry *pKey);
    static PsetCacheEntry *GetKey(EEHashEntry_t *pEntry);
};

typedef EEHashTable<PsetCacheEntry *, EEPsetHashTableHelper, FALSE> EEPsetHashTable;


// Generic pointer hash table helper.

template <class KeyPointerType, BOOL bDeleteData>
class EEPtrHashTableHelper
{
public:
    static EEHashEntry_t *AllocateEntry(KeyPointerType pKey, BOOL bDeepCopy, AllocationHeap Heap)
    {
        _ASSERTE(!bDeepCopy && "Deep copy is not supported by the EEPtrHashTableHelper");
        _ASSERTE(sizeof(KeyPointerType) == sizeof(void *) && "KeyPointerType must be a pointer type");

        EEHashEntry_t *pEntry = (EEHashEntry_t *) new BYTE[SIZEOF_EEHASH_ENTRY + sizeof(KeyPointerType)];
        if (!pEntry)
            return NULL;
        *((KeyPointerType*)pEntry->Key) = pKey;

        return pEntry;
    }

    static void DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap)
    {
        // If the template bDeleteData flag is set then delete the data.
        // This check will be compiled away.
        if (bDeleteData)
            delete pEntry->Data;

        // Delete the entry.
        delete pEntry;
    }

    static BOOL CompareKeys(EEHashEntry_t *pEntry, KeyPointerType pKey)
    {
        KeyPointerType pEntryKey = *((KeyPointerType*)pEntry->Key);
        return pEntryKey == pKey;
    }

    static DWORD Hash(KeyPointerType pKey)
    {
        return (DWORD)(size_t)pKey; // @TODO WIN64 - Pointer Truncation
    }

    static KeyPointerType GetKey(EEHashEntry_t *pEntry)
    {
        return *((KeyPointerType*)pEntry->Key);
    }
};

typedef EEHashTable<void *, EEPtrHashTableHelper<void *, FALSE>, FALSE> EEPtrHashTable;

// Generic GUID hash table helper.

class EEGUIDHashTableHelper
{
public:
    static EEHashEntry_t *AllocateEntry(GUID *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL CompareKeys(EEHashEntry_t *pEntry, GUID *pKey);
    static DWORD Hash(GUID *pKey);
    static GUID *GetKey(EEHashEntry_t *pEntry);
};

typedef EEHashTable<GUID *, EEGUIDHashTableHelper, TRUE> EEGUIDHashTable;


// ComComponentInfo hashtable.

struct ClassFactoryInfo
{
    GUID     m_clsid;
    WCHAR   *m_strServerName;
};

class EEClassFactoryInfoHashTableHelper
{
public:
    static EEHashEntry_t *AllocateEntry(ClassFactoryInfo *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL CompareKeys(EEHashEntry_t *pEntry, ClassFactoryInfo *pKey);
    static DWORD Hash(ClassFactoryInfo *pKey);
    static ClassFactoryInfo *GetKey(EEHashEntry_t *pEntry);
};

typedef EEHashTable<ClassFactoryInfo *, EEClassFactoryInfoHashTableHelper, TRUE> EEClassFactoryInfoHashTable;


// One of these is present for each element in the table

typedef struct EEClassHashEntry
{
    struct EEClassHashEntry *pNext;
    struct EEClassHashEntry *pEncloser; // stores nested class
    DWORD               dwHashValue;
    HashDatum           Data;
#ifdef _DEBUG
    LPCUTF8             DebugKey[2];
#endif // _DEBUG
} EEClassHashEntry_t;

// Class name/namespace hashtable.

class EEClassHashTable 
{
    friend class ClassLoader;

protected:
    EEClassHashEntry_t **m_pBuckets;    // Pointer to first entry for each bucket
    DWORD           m_dwNumBuckets;
    DWORD           m_dwNumEntries;
    ClassLoader    *m_pLoader;
    BOOL            m_bCaseInsensitive;  // Default is true FALSE unless we call MakeCaseInsensitiveTable

public:
    LoaderHeap *    m_pHeap;

#ifdef _DEBUG
    DWORD           m_dwDebugMemory;
#endif

public:
    EEClassHashTable();
    ~EEClassHashTable();
    void *             operator new(size_t size, LoaderHeap *pHeap, DWORD dwNumBuckets, ClassLoader *pLoader, BOOL bCaseInsensitive);
    void               operator delete(void *p);
    
    //NOTICE: look at InsertValue() in ClassLoader, that may be the function you want to use. Use this only
    //        when you are sure you want to insert the value in 'this' table. This function does not deal
    //        with case (as often the class loader has to)
    EEClassHashEntry_t *InsertValue(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum Data, EEClassHashEntry_t *pEncloser);
    EEClassHashEntry_t *InsertValueIfNotFound(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum *pData, EEClassHashEntry_t *pEncloser, BOOL IsNested, BOOL *pbFound);
    EEClassHashEntry_t *GetValue(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum *pData, BOOL IsNested);
    EEClassHashEntry_t *GetValue(LPCUTF8 pszFullyQualifiedName, HashDatum *pData, BOOL IsNested);
    EEClassHashEntry_t *GetValue(NameHandle* pName, HashDatum *pData, BOOL IsNested);
    EEClassHashEntry_t *AllocNewEntry();
    EEClassHashTable   *MakeCaseInsensitiveTable(ClassLoader *pLoader);
    EEClassHashEntry_t *FindNextNestedClass(NameHandle* pName, HashDatum *pData, EEClassHashEntry_t *pBucket);
    EEClassHashEntry_t *FindNextNestedClass(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum *pData, EEClassHashEntry_t *pBucket);
    EEClassHashEntry_t *FindNextNestedClass(LPCUTF8 pszFullyQualifiedName, HashDatum *pData, EEClassHashEntry_t *pBucket);
    void                UpdateValue(EEClassHashEntry_t *pBucket, HashDatum *pData) 
    {
        pBucket->Data = *pData;
    }

    BOOL     CompareKeys(EEClassHashEntry_t *pEntry, LPCUTF8 *pKey2);
    static DWORD    Hash(LPCUTF8 pszNamespace, LPCUTF8 pszClassName);

private:
    EEClassHashEntry_t * FindItem(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, BOOL IsNested);
    EEClassHashEntry_t * FindItemHelper(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, BOOL IsNested, DWORD dwHash, DWORD dwBucket);
    BOOL                 GrowHashTable();
    void                 ConstructKeyFromData(EEClassHashEntry_t *pEntry, LPUTF8 *Key, CQuickBytes& cqb); 
    EEClassHashEntry_t  *InsertValueHelper(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum Data, EEClassHashEntry_t *pEncloser, DWORD dwHash, DWORD dwBucket);
};


// SC/CL hash table - the key is a scope and a CL token
// This is no longer a derived class

class EEScopeClassHashTable 
{
protected:
    EEHashEntry_t **m_pBuckets;    // Pointer to first entry for each bucket
    DWORD           m_dwNumBuckets;

public:

#ifdef _DEBUG
    DWORD           m_dwDebugMemory;
#endif

    void *          operator new(size_t size, LoaderHeap *pHeap, DWORD dwNumBuckets);
    void            operator delete(void *p);
    EEScopeClassHashTable();
    ~EEScopeClassHashTable();

    BOOL            InsertValue(mdScope scKey, mdTypeDef clKey, HashDatum Data);
    BOOL            DeleteValue(mdScope scKey, mdTypeDef clKey);
    BOOL            ReplaceValue(mdScope scKey, mdTypeDef clKey, HashDatum Data);
    BOOL            GetValue(mdScope scKey, mdTypeDef clKey, HashDatum *pData);
    EEHashEntry_t * AllocNewEntry();

    static BOOL     CompareKeys(size_t *pKey1, size_t *pKey2);
    static DWORD    Hash(mdScope scKey, mdTypeDef clKey);

private:
    EEHashEntry_t * FindItem(mdScope sc, mdTypeDef cl);
};


// Struct to hold a client's iteration state
struct EEHashTableIteration
{
    DWORD              m_dwBucket;
    EEHashEntry_t     *m_pEntry;

#ifdef _DEBUG
    void              *m_pTable;
#endif
};

#endif /* _EE_HASH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\encee.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: EnC.CPP
// 

// Handles EditAndContinue support in the EE
// ===========================================================================

#include "common.h"
#include "enc.h"
#include "utilcode.h"
#include "wsperf.h"
#include "DbgInterface.h"
#include "NDirect.h"
#include "EEConfig.h"
#include "Excep.h"

#ifdef EnC_SUPPORTED

// forward declaration
HRESULT MDApplyEditAndContinue(         // S_OK or error.
    IMDInternalImport **ppIMD,          // [in, out] The metadata to be updated.
    IMDInternalImportENC *pDeltaMD);    // [in] The delta metadata.

HRESULT GetInternalWithRWFormat(
    LPVOID      pData, 
    ULONG       cbData, 
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnk);              // [out] Return interface on success.


const BYTE* EditAndContinueModule::m_pGlobalScratchSpaceStart = 0;
const BYTE* EditAndContinueModule::m_pGlobalScratchSpaceNext = 0;
const BYTE *EditAndContinueModule::m_pGlobalScratchSpaceLast = 0;

// @todo Fix this - tweak LoaderHeap so that we can allocate additional
// blocks at addresses greater than the ILBase for a module.
// We're not going to reallocate this for Beta 1, so make it big.
const int IL_CODE_BLOB_SIZE  = (1024*1024*16); // 16MB

// Helper routines.
//
// Binary search for matching element.
//
// *pfExact will be TRUE if the element actually exists;
//      otherwise it will be FALSE & the return value is where
//      to insert the value into the array
long FindTokenIndex(TOKENARRAY *tokens,
                   mdToken token,
                   BOOL *pfExact)
{
    _ASSERTE(pfExact != NULL);
    *pfExact = FALSE;

    if (tokens->Count() == 0)
    {
        LOG((LF_CORDB, LL_INFO1000, "FTI: no elts->0 return\n"));
        return 0;
    }
    
    long iMin = 0;
    long iMax = tokens->Count();

    _ASSERTE( iMin < iMax );

    while (iMin + 1 < iMax)
    {
        _ASSERTE(iMin>=0);
        long iMid = iMin + ((iMax - iMin)>>1);
        
        _ASSERTE(iMid>=0);

        mdToken *midTok = tokens->Get(iMid);
        if (token == *midTok)
        {
            LOG((LF_CORDB, LL_INFO1000, "FTI: found 0x%x at index 0x%x\n",
                token, iMid));
            *pfExact = TRUE;
            return iMid;
        }
        else if (token < *midTok)
            iMax = iMid;
        else
            iMin = iMid;
    }

    if (token == *tokens->Get(iMin))
    {
        LOG((LF_CORDB, LL_INFO1000, "FTI: found 0x%x at index 0x%x\n",
            token, iMin));
        *pfExact = TRUE;
    }
    else if (token > *tokens->Get(iMin))
    {
        // Bump it up one if the elt should go into
        // the next slot.
        iMin++;
    }

    LOG((LF_CORDB, LL_INFO1000, "FTI: Couldn't find 0x%x, "
        "should place at0x%x\n", token, iMin));
    return iMin;
}

HRESULT AddToken(TOKENARRAY *tokens,
                 mdToken token)
{
    LOG((LF_CORDB, LL_INFO1000, "AddToken: adding 0x%x to 0x%x\n", token, tokens));

    BOOL fPresent;
    long iTok = FindTokenIndex(tokens, token, &fPresent);

    if(fPresent == TRUE)
    {
        LOG((LF_CORDB, LL_INFO1000, "AT: 0x%x is already present!\n", token));
        return S_OK; // ignore duplicates
    }
    
    mdToken *pElt = tokens->Insert(iTok);
    if (pElt == NULL)
    {
        LOG((LF_CORDB, LL_INFO1000, "AT: out of memory!\n", token));
        return E_OUTOFMEMORY;
    }
    
    *pElt = token;
    return S_OK;
}

HRESULT EditAndContinueModule::ClassInit()
{
    return FindFreeSpaceWithinRange(m_pGlobalScratchSpaceStart, 
        m_pGlobalScratchSpaceNext,
        m_pGlobalScratchSpaceLast);
}

void EditAndContinueModule::ClassTerm()
{
    if (m_pGlobalScratchSpaceStart)
       VirtualFree((LPVOID)m_pGlobalScratchSpaceStart, 0, MEM_RELEASE);
}

const BYTE *EditAndContinueModule::GetNextScratchSpace()
{
    if (m_pGlobalScratchSpaceStart == 0)
    {
        HRESULT hr = ClassInit();

        if (FAILED(hr))
            return (NULL);
    }

    if (m_pGlobalScratchSpaceNext + SCRATCH_SPACE_SIZE <= m_pGlobalScratchSpaceLast &&
        m_pGlobalScratchSpaceNext > GetILBase()) 
    {
        const BYTE *pScratchSpace = m_pGlobalScratchSpaceNext;
        m_pGlobalScratchSpaceNext = m_pGlobalScratchSpaceNext + SCRATCH_SPACE_SIZE;
        return pScratchSpace;
    }
    
    // return next available scratch space
    // if less than module then 0
    return NULL;
}

HRESULT EditAndContinueModule::GetDataRVA(LoaderHeap *&pScratchSpace, SIZE_T *pDataRVA)
{
    _ASSERTE(pDataRVA);   // caller should verify parm

    *pDataRVA = NULL;

    if (!pScratchSpace) 
    {
        const BYTE *reservedSpace = GetNextScratchSpace();
        if (! reservedSpace)
            return E_OUTOFMEMORY;
            
        pScratchSpace = new LoaderHeap(SCRATCH_SPACE_SIZE, 0);
        if (! pScratchSpace)
            return E_OUTOFMEMORY;
            
        BOOL result = pScratchSpace->AllocateOntoReservedMem(reservedSpace, 
                                                             SCRATCH_SPACE_SIZE);
        if (! result)
        {
            delete pScratchSpace;
            return E_OUTOFMEMORY;
        }
        
        // save the reserved space address so can change protection mode later
        if (pScratchSpace == m_pRoScratchSpace)
            m_pRoScratchSpaceStart = (BYTE*)reservedSpace;
    }
    _ASSERTE(pScratchSpace);
    
    // Guaranteed that this will be in range, and when actually copy into the scratch
    // space will determine if have enough space.
    // Note that this calculation depends on the space being allocated _AFTER_
    // the modules in memory - SIZE_Ts are positive integers, so the
    // RVA must be positive from the base of the module's IL.
    *pDataRVA = pScratchSpace->GetNextAllocAddress() - GetILBase();
    return S_OK;
}

// Right now, we've only got a finite amount of space.  In B2, we'll 
// modify the LoaderHeap so that it can resize if it needs to.
HRESULT EditAndContinueModule::EnsureRVAableHeapExists(void)
{
    if (m_pILCodeSpace == NULL)
    {
        LOG((LF_CORDB, LL_INFO10000, "EACM::ERVAHE: m_pILCodeSpace is NULL,"
            " so we're going to try & get a new one\n"));

        // Last arg, GetILBase(), is the minimum address we're willing to 
        // accept, in order to get an RVA out of the resulting memory
        // (RVA == size_t, a positive offset from start of module)
        m_pILCodeSpace = new LoaderHeap(IL_CODE_BLOB_SIZE,  // dwReserveBlockSize
                                        0,  // dwCommitBlockSize
                                        NULL, // pPrivatePerfCounter_LoaderBytes
                                        NULL, // pGlobalPerfCounter_LoaderBytes
                                        0, // pRangeList
                                        (const BYTE *)GetILBase()); // pMinAddr
        if (!m_pILCodeSpace)
            return E_OUTOFMEMORY;
    }
    
    LOG((LF_CORDB, LL_INFO10000, "EACM::ERVAHE: m_pILCodeSpace is 0x%x\n",
        m_pILCodeSpace));
    return S_OK;
}

HRESULT EditAndContinueModule::GetRVAableMemory(SIZE_T cbMem,
                                                void **ppMem)
{
    LOG((LF_CORDB, LL_INFO10000, "EACM::GRVAM heap:0x%x cb:0x%x ppMem:0x%x\n",
        m_pILCodeSpace, cbMem, ppMem));
        
    _ASSERTE(ppMem);

    HRESULT hr = S_OK;

    (*ppMem) = NULL;

    _ASSERTE(m_pILCodeSpace != NULL || 
             !"Should have called EnsureRVAableHeapExists, first!");

    (*ppMem) = m_pILCodeSpace->AllocMem(cbMem, FALSE);
    if (!(*ppMem))
        return E_OUTOFMEMORY;

    return hr;
}

void EditAndContinueModule::ToggleRoProtection(DWORD dwProtection)
{
    DWORD dwOldProtect;
    BYTE *tmp = m_pRoScratchSpace->GetNextAllocAddress();
    BOOL success = VirtualProtect(m_pRoScratchSpaceStart, tmp-m_pRoScratchSpaceStart, dwProtection, &dwOldProtect);
    _ASSERTE(success);
}
    

HRESULT EditAndContinueModule::CopyToScratchSpace(LoaderHeap *&pScratchSpace, const BYTE *pData, DWORD dataSize)
{
    // if this is ro, then change page to readwrite to copy in and back to readonly when done
    if (pScratchSpace == m_pRoScratchSpace)
        ToggleRoProtection(PAGE_READWRITE);

#ifdef _DEBUG
    BYTE *tmp = pScratchSpace->GetNextAllocAddress();
#endif

    WS_PERF_SET_HEAP(SCRATCH_HEAP);    
    BYTE *pScratchBuf = (BYTE *)(pScratchSpace->AllocMem(dataSize, FALSE));
    WS_PERF_UPDATE_DETAIL("ScratchSpace", dataSize, pScratchBuf);
    if (! pScratchBuf)
        return E_OUTOFMEMORY;
    _ASSERTE(pScratchBuf == tmp);

    memcpy(pScratchBuf, pData, dataSize);

    if (pScratchSpace == m_pRoScratchSpace)
        ToggleRoProtection(PAGE_READONLY);

    return S_OK;
}

EditAndContinueModule::EditAndContinueModule()
{
    LOG((LF_ENC,LL_EVERYTHING,"EACM::ctor 0x%x\n", this));
    m_pDeltaPEList = NULL;  
    m_pRoScratchSpace = NULL;
    m_pRwScratchSpace = NULL;
    m_pILCodeSpace = NULL;
    m_pSections = NULL;

    m_pRangeList = new RangeList();
}

void EditAndContinueModule::Destruct()
{
    LOG((LF_ENC,LL_EVERYTHING,"EACM::Destruct 0x%x\n", this));

    // @todo delete delta pe list: who owns the storage?    
    if (m_pRoScratchSpace)
        delete m_pRoScratchSpace;
        
    if (m_pRwScratchSpace)
        delete m_pRwScratchSpace;

    if (m_pILCodeSpace)
        delete m_pILCodeSpace;

    if (m_pRangeList)
        delete m_pRangeList;

    if (m_pSections)
        delete m_pSections;

    // Call the superclass's Destruct method...
    Module::Destruct();
}

HRESULT EditAndContinueModule::GetRoDataRVA(SIZE_T *pRoDataRVA)
{
    return GetDataRVA(m_pRoScratchSpace, pRoDataRVA);
}

HRESULT EditAndContinueModule::GetRwDataRVA(SIZE_T *pRwDataRVA)
{
    return GetDataRVA(m_pRwScratchSpace, pRwDataRVA);
}

// If this method returns a failing HR, then there must be an entry in
// pEnCError PER error.  Since the return value isn't necc. going to be returned
// to the user (it may be overwritten first), E_FAIL (or E_OUTOFMEMORY) are
// basically the only valid return code (and S_OK, of course).
// It's worth noting that a lot of the error codes that are written into the
// descriptions are borrowed from elsewhere, and so the text associated
// with the HRESULT might not make a lot of sense.  Use the name, instead.
HRESULT EditAndContinueModule::ApplyEditAndContinue(
                                    const EnCEntry *pEnCEntry,
                                    const BYTE *pbDeltaPE,
                                    CBinarySearchILMap *pILM,
                                    UnorderedEnCErrorInfoArray *pEnCError,
                                    UnorderedEnCRemapArray *pEnCRemapInfo,
                                    BOOL fCheckOnly)
{
    // We'll accumulate the HR that we actually return in hrReturn
    // we want to accumulate errors so that we can tell the user that
    // N edits aren't valid, rather than simply saying that the first
    // edit was saw isn't valid.
    HRESULT hrReturn = S_OK;    
    // We'll use hrTemp to store the result of an individual call, etc
    HRESULT hrTemp = S_OK;
    unsigned int totalILCodeSize = 0;
    unsigned int methodILCodeSize = 0;
    IMDInternalImportENC *pIMDInternalImportENC = NULL;
    IMDInternalImportENC *pDeltaMD = NULL;
    BOOL fHaveLoaderLock = FALSE;
    TOKENARRAY methodsBrandNew;
    
#ifdef _DEBUG
    // We'll use this to verify that the invariant "After calling a subroutine from AEAC,
    // the return value x is either !FAILED(x), or the count of elements in pEnCError has
    // increased by at least one"
    USHORT sizeOfErrors = 0;
#endif // _DEBUG

    LOG((LF_CORDB, LL_INFO10000, "EACM::AEAC: fCheckOnly:0x%x\n", fCheckOnly));

    //
    // @todo: Try to remove this failure case
    //
    // Fail any EnC on a module for which we are using a zap file.  While in general this should
    // work, we currently need to fail because prejit doesn't ever generate code with the EnC flag.
    // Eventually, we hope to make it so there is no difference between debugging code and EnC code,
    // so this should be able to go away.
    //
    // Note that even though this prevents a broken case, it's potentially kind of annoying since 
    // a debugger has no control over when we load zaps.  Right now we only do it for our libs 
    // though so it shouldn't be an issue.
    // 

    if (GetZapBase() != 0)
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            CORDBG_E_ENC_ZAPPED_WITHOUT_ENC,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_FAIL;
    }

    IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*) ((size_t)((IMAGE_DOS_HEADER*) pbDeltaPE)->e_lfanew + (size_t)pbDeltaPE);   

    ULONG dwCorHeaderRVA = pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress;
    ULONG dwCorHeaderSize  = pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].Size;

    _ASSERTE(dwCorHeaderRVA && dwCorHeaderSize);
    if (dwCorHeaderRVA == 0 || dwCorHeaderSize == 0)    
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            COR_E_BADIMAGEFORMAT,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_FAIL;
    }
    
    // the Delta PE is in on-disk format, so do a little work to find the sections - can't just add RVA 

    // Get the start of the section headers 
    PIMAGE_SECTION_HEADER pSection =    
        (PIMAGE_SECTION_HEADER)((BYTE *)(&pNT->OptionalHeader) + sizeof(IMAGE_OPTIONAL_HEADER));    

    m_dNumSections = pNT->FileHeader.NumberOfSections;  
    if (! m_dNumSections)   
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            COR_E_BADIMAGEFORMAT,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_FAIL;
    }
    
    // First free any previous map from a previous step.
    if (m_pSections)
        delete m_pSections;
    m_pSections = new OnDiskSectionInfo[m_dNumSections];    
    if (! m_pSections)  
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            E_OUTOFMEMORY,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_OUTOFMEMORY;
    }

    IMAGE_COR20_HEADER *pDeltaCorHeader = NULL;  
    for (int i=0; i < m_dNumSections; i++, pSection++) 
    {
        m_pSections[i].startRVA = pSection->VirtualAddress; 
        m_pSections[i].endRVA = pSection->VirtualAddress + pSection->SizeOfRawData; 
        m_pSections[i].data = pbDeltaPE + pSection->PointerToRawData;   
        
        // check if COR header within this section
        if (pSection->VirtualAddress <= dwCorHeaderRVA &&
                pSection->VirtualAddress + pSection->SizeOfRawData >= dwCorHeaderRVA + dwCorHeaderSize)
        {                
            pDeltaCorHeader = (IMAGE_COR20_HEADER *)(pbDeltaPE + pSection->PointerToRawData + (dwCorHeaderRVA - pSection->VirtualAddress));    
        }
        else if (! strncmp((char*)pSection->Name, ".data", sizeof(".data"))) 
        {
            LOG((LF_ENC, LL_INFO100, "EnCModule::ApplyEditAndContinue copied %d bytes from .data section\n", pSection->Misc.VirtualSize));
            hrTemp = CopyToScratchSpace(m_pRwScratchSpace, pbDeltaPE + pSection->PointerToRawData, pSection->Misc.VirtualSize);
            if (FAILED(hrTemp))
            {
                EnCErrorInfo *pError = pEnCError->Append();

                TESTANDRETURNMEMORY(pError);
                ADD_ENC_ERROR_ENTRY(pError, 
                            hrTemp,
                            NULL, //we'll fill these in later
                            mdTokenNil);

            
                return E_FAIL;
            }
        }
        else if (! strncmp((char*)pSection->Name, ".rdata", sizeof(".rdata"))) 
        {
            hrTemp = CopyToScratchSpace(m_pRoScratchSpace, pbDeltaPE + pSection->PointerToRawData, pSection->Misc.VirtualSize);
            LOG((LF_ENC, LL_INFO100, "EnCModule::ApplyEditAndContinue copied 0x%x bytes from .rdata section\n", pSection->Misc.VirtualSize));
            if (FAILED(hrTemp))
            {
                EnCErrorInfo *pError = pEnCError->Append();

                TESTANDRETURNMEMORY(pError);
                ADD_ENC_ERROR_ENTRY(pError, 
                            hrTemp,
                            NULL, //we'll fill these in later
                            mdTokenNil);
            
                return E_FAIL;
            }
        }
    }   

    _ASSERTE(pDeltaCorHeader);
    if (!pDeltaCorHeader)    
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            COR_E_BADIMAGEFORMAT,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_FAIL;
    }

    LPVOID pmetadata;   
    hrTemp = ResolveOnDiskRVA((DWORD) pDeltaCorHeader->MetaData.VirtualAddress, &pmetadata);
    if (FAILED(hrTemp)) 
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            COR_E_BADIMAGEFORMAT, // ResolveOnDiskRVA will return E_FAIL
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_FAIL;
    }

    HENUMInternal enumENC;
    HENUMInternal enumDelta;

    IMDInternalImport *pMDImport = GetMDImport();
    mdToken token;

    /// *******************   NOTE ****************************//
    /// From here on, you must goto exit rather than return'ing directly!!!!
    /// Note also that where possible, we'd like to check as many changes
    /// as possible all at once, rather than going to the exit at the first sign of trouble.
    
    // Open the delta metadata.
    hrTemp = GetInternalWithRWFormat(pmetadata, pDeltaCorHeader->MetaData.Size, 0, IID_IMDInternalImportENC, (void**)&pDeltaMD);
    if (FAILED(hrTemp))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        if(pError==NULL)
        {        
            hrReturn = E_OUTOFMEMORY;
            goto exit;
        }
        
        ADD_ENC_ERROR_ENTRY(pError, 
                            hrTemp,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        hrReturn = E_FAIL;
        goto exit;
    }
    
#ifdef _DEBUG
     sizeOfErrors = pEnCError->Count();
#endif //_DEBUG

    hrTemp = ConfirmEnCToType(pMDImport, pDeltaMD, COR_GLOBAL_PARENT_TOKEN, pEnCError);

    _ASSERTE(!FAILED(hrTemp) || hrTemp == E_OUTOFMEMORY ||
             pEnCError->Count() > sizeOfErrors ||
             !"EnC subroutine failed, but we didn't add an entry explaining why!");

    if (FAILED(hrTemp))
    {
        // Don't add entries to pEncError - ConfirmEncToType should have done that
        // for us.
        hrReturn = E_FAIL;
        goto exit;
    }

    // Verify that the ENC changes are acceptable.
    hrTemp = pDeltaMD->EnumDeltaTokensInit(&enumDelta);
    if (FAILED(hrTemp))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        if(pError == NULL)
        {
            hrReturn = E_OUTOFMEMORY;
            goto exit;
        }
        
        ADD_ENC_ERROR_ENTRY(pError, 
                            hrTemp,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        hrReturn = E_FAIL;
        goto exit;
    }
        
    // Examine the changed tokens.
    while (pDeltaMD->EnumNext(&enumDelta, &token)) 
    {
        switch (TypeFromToken(token)) 
        {
        case mdtTypeDef:
#ifdef _DEBUG
            LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC check:type\n"));
             sizeOfErrors = pEnCError->Count();
#endif //_DEBUG

            hrTemp = ConfirmEnCToType(pMDImport, pDeltaMD, token, pEnCError);

            _ASSERTE(!FAILED(hrTemp) || hrTemp == E_OUTOFMEMORY ||
                     pEnCError->Count() > sizeOfErrors ||
                     !"EnC subroutine failed, but we didn't add an entry explaining why!");
                 
            if (FAILED(hrTemp)) 
            {
                LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ApplyEditAndContinue Apply to type failed\n"));
                hrReturn = E_FAIL;
            }
            
            break;
            
        case mdtMethodDef:
            UnorderedILMap UILM;
            UILM.mdMethod = token; // set up the key
            
#ifdef _DEBUG
            LOG((LF_CORDB, LL_INFO100000, "EACM::AEAC: Finding token 0x%x\n", token));
             sizeOfErrors = pEnCError->Count();
#endif //_DEBUG

            _ASSERTE(pDeltaMD->IsValidToken(token));
            if (!pMDImport->IsValidToken(token))
            {   
                // If we can't add the method, then things will look weird, but
                // life will otherwise be ok, yes?
                if (FAILED(hrTemp = AddToken(&methodsBrandNew,
                                             token)))
                {                                  
                    EnCErrorInfo *pError = pEnCError->Append();

                    if (pError == NULL)
                    {
                        hrReturn = E_OUTOFMEMORY;
                        goto exit;
                    }
                    
                    ADD_ENC_ERROR_ENTRY(pError, 
                                        hrTemp, 
                                        NULL, //we'll fill these in later
                                        token);

                    hrReturn = E_FAIL;
                }
            }

            if (!FAILED(hrReturn))
            {
                hrTemp = ApplyMethodDelta(token,
                                          TRUE,
                                          pILM->Find(&UILM), 
                                          pEnCError, 
                                          pDeltaMD, 
                                          pMDImport,
                                          &methodILCodeSize,
                                          pEnCRemapInfo,
                                          FALSE);

                _ASSERTE(!FAILED(hrTemp) || hrTemp == E_OUTOFMEMORY ||
                         pEnCError->Count() > sizeOfErrors ||
                         !"EnC subroutine failed, but we didn't add an entry explaining why!");
                         
                totalILCodeSize += methodILCodeSize;
                                          
                if (FAILED(hrTemp)) 
                {
                    LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ApplyEditAndContinue ApplyMethodDelta failed\n"));
                    hrReturn = E_FAIL;
                }
            }
            
            LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC post AMD\n"));
            
            break;
            
        case mdtFieldDef:
#ifdef _DEBUG
            LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC check:field\n"));
             sizeOfErrors = pEnCError->Count();
#endif //_DEBUG

            hrTemp = ApplyFieldDelta(token, TRUE, pDeltaMD, pEnCError);

            _ASSERTE(!FAILED(hrTemp) || hrTemp == E_OUTOFMEMORY ||
                     pEnCError->Count() > sizeOfErrors ||
                     !"EnC subroutine failed, but we didn't add an entry explaining why!");
            if (FAILED(hrTemp)) 
            {
                LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ApplyEditAndContinue ApplyFieldDelta failed\n"));
                hrReturn = E_FAIL;                    
            }
            
            break;
        }
    }

    // With true Delta PEs, the user code, in theory, just add something
    // to the metadata, which would obviate the need to get memory here.
    if (totalILCodeSize > 0)
    {
        hrTemp = EnsureRVAableHeapExists();
        if (FAILED(hrTemp))
        {
            LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC couldn't get RVA-able heap!\n"));
            
            EnCErrorInfo *pError = pEnCError->Append();

            if (pError == NULL)
            {
                hrReturn = E_OUTOFMEMORY;
                goto exit;
            }
            
            ADD_ENC_ERROR_ENTRY(pError, 
                            E_OUTOFMEMORY, 
                            NULL, //we'll fill these in later
                            mdTokenNil);

            hrReturn = E_FAIL;
            goto exit;
        }

        _ASSERTE(m_pILCodeSpace != NULL);
        if (!m_pILCodeSpace->CanAllocMem(totalILCodeSize, TRUE))
        {
            LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC Insufficient space for IL"
                " code: m_ILCodeSpace:0x%x\n", m_pILCodeSpace));

            EnCErrorInfo *pError = pEnCError->Append();

            if (pError == NULL)
            {
                hrReturn = E_OUTOFMEMORY;
                goto exit;
            }

            ADD_ENC_ERROR_ENTRY(pError, 
                            E_OUTOFMEMORY, 
                            NULL, //we'll fill these in later
                            mdTokenNil);

            hrReturn = E_FAIL;
            goto exit;
        }
    }
    
    if (fCheckOnly)
    {
        LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC about to leave - just checking!\n"));

        goto exit;
    }
    _ASSERTE(!fCheckOnly);

    // From this point onwards, if something fails, we should go 
    // straight to the exit label, since CanCommitChanges would have returned
    // in the above "if"

    LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC about to apply MD\n"));

    // If made it here, changes look OK.  Apply them.
    hrTemp = MDApplyEditAndContinue(&pMDImport, pDeltaMD);
    if (FAILED(hrTemp))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        if(pError == NULL)
        {
            hrReturn = E_OUTOFMEMORY;
            goto exit;
        }
        
        ADD_ENC_ERROR_ENTRY(pError, 
                            hrTemp,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        hrReturn = E_FAIL;
        goto exit;
    }

    LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC post apply MD\n"));

    ReleaseMDInterfaces(TRUE);
    SetMDImport(pMDImport);

    if (pEnCEntry->symSize > 0)
    {
        // Snagg the symbol store for this module.
        ISymUnmanagedReader *pReader = GetISymUnmanagedReader();

        if (pReader)
        {
            // Make a stream out of the symbol bytes.
            IStream *pStream = NULL;

            hrTemp = CInMemoryStream::CreateStreamOnMemoryNoHacks(
                                               (void*)(pbDeltaPE +
                                                      pEnCEntry->peSize),
                                               pEnCEntry->symSize,
                                               &pStream);

            // Update the reader.
            if (SUCCEEDED(hrTemp) && pStream)
            {
                hrTemp = pReader->UpdateSymbolStore(NULL, pStream);
                pStream->Release();
            }

            // The CreateStreamOnMemory and the UpdateSymbolStore
            // should have worked...
            if (FAILED(hrTemp))
            {
                EnCErrorInfo *pError = pEnCError->Append();

                if(pError == NULL)
                {
                    hrReturn = E_OUTOFMEMORY;
                    goto exit;
                }
                
                ADD_ENC_ERROR_ENTRY(pError, 
                                    hrTemp,
                                    NULL, //we'll fill these in later
                                    mdTokenNil);

                hrReturn = E_FAIL;
                goto exit;
            }
        }
    }

    LOG((LF_CORDB, LL_EVERYTHING, "EACM::AEAC post symbol update\n"));
    
    hrTemp = GetMDImport()->QueryInterface(IID_IMDInternalImportENC, (void **)&pIMDInternalImportENC);
    if (FAILED(hrTemp))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        if(pError == NULL)
        {
            hrReturn = E_OUTOFMEMORY;
            goto exit;
        }
        
        ADD_ENC_ERROR_ENTRY(pError, 
                            hrTemp,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        hrReturn = E_FAIL;
        goto exit;
    }

    hrTemp = pIMDInternalImportENC->EnumDeltaTokensInit(&enumENC);
    if (FAILED(hrTemp))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        if(pError == NULL)
        {
            hrReturn = E_OUTOFMEMORY;
            goto exit;
        }
        
        ADD_ENC_ERROR_ENTRY(pError, 
                            hrTemp,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        hrReturn = E_FAIL;
        goto exit;
    }

    GetClassLoader()->LockAvailableClasses();
    fHaveLoaderLock = TRUE;

    // Examine the changed tokens.
    // If something goes wrong here, we're screwed.  We should have detected the
    // impending failure above, but for some reason didn't.  Bail immediately
    while (pIMDInternalImportENC->EnumNext(&enumENC, &token)) 
    {
        switch (TypeFromToken(token)) 
        {
            case mdtTypeDef:
#ifdef _DEBUG
                {
                    LPCUTF8 szClassName;
                    LPCUTF8 szNamespace;
                    GetMDImport()->GetNameOfTypeDef(token, &szClassName, &szNamespace);    
                    LOG((LF_ENC, LL_INFO100, "Applying EnC to class %s\n", szClassName));
                }
#endif
                hrTemp = GetClassLoader()->AddAvailableClassHaveLock(this,
                                                                 GetClassLoaderIndex(),
                                                                 token);
                // If we're re-adding a class (ie, we don't have a true DeltaPE), then
                // don't worry about it.
                if (CORDBG_E_ENC_RE_ADD_CLASS == hrTemp)
                    hrTemp = S_OK;

                if (FAILED(hrTemp))
                {
                    EnCErrorInfo *pError = pEnCError->Append();

                    if(pError == NULL)
                    {
                        hrReturn = E_OUTOFMEMORY;
                        goto exit;
                    }
                    
                    ADD_ENC_ERROR_ENTRY(pError, 
                                        hrTemp,
                                        NULL, //we'll fill these in later
                                        token);

                    hrReturn = E_FAIL;
                    goto exit;
                }
                break;
                
            case mdtMethodDef:
            
                UnorderedILMap UILM;
                UILM.mdMethod = token; // set up the key
                
#ifdef _DEBUG
                LOG((LF_CORDB, LL_INFO100000, "EACM::AEAC: Finding token 0x%x\n", token));
                 sizeOfErrors = pEnCError->Count();
#endif //_DEBUG

                BOOL fMethodBrandNew;
                FindTokenIndex(&methodsBrandNew,
                               token,
                               &fMethodBrandNew);
                               
                hrTemp = ApplyMethodDelta(token,
                                          FALSE,
                                          pILM->Find(&UILM), 
                                          pEnCError, 
                                          GetMDImport(), 
                                          NULL,
                                          &methodILCodeSize,
                                          pEnCRemapInfo,
                                          fMethodBrandNew); 
                _ASSERTE(!FAILED(hrTemp) || hrTemp == E_OUTOFMEMORY ||
                     pEnCError->Count() > sizeOfErrors ||
                     !"EnC subroutine failed, but we didn't add an entry explaining why!");
                     
                if (FAILED(hrTemp)) 
                {
                    LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ApplyEditAndContinue ApplyMethodDelta failed\n"));
                    hrReturn = E_FAIL;
                    goto exit;
                }
                break;
                
            case mdtFieldDef:
#ifdef _DEBUG
                {
                    LPCUTF8 szMemberName;
                    szMemberName = GetMDImport()->GetNameOfFieldDef(token);    
                    LPCUTF8 szClassName;
                    LPCUTF8 szNamespace;
                    mdToken parent;
                    hrTemp = GetMDImport()->GetParentToken(token, &parent);
                    if (FAILED(hrTemp)) 
                    {
                        LOG((LF_ENC, LL_INFO100, "**Error** EncModule::ApplyEditAndContinue GetParentToken %8.8x failed\n", token));
                        // Don't assign a value to hrReturn b/c we don't
                        // want the debug build to behave differently from
                        // the free/retail build.
                    }
                    else
                    {
                        GetMDImport()->GetNameOfTypeDef(parent, &szClassName, &szNamespace);    
                        LOG((LF_ENC, LL_INFO100, "EnC adding field %s:%s()\n", szClassName, szMemberName));
                    }
                }

                sizeOfErrors = pEnCError->Count();
#endif //_DEBUG
                hrTemp = ApplyFieldDelta(token, FALSE, pDeltaMD, pEnCError);
                
                _ASSERTE(!FAILED(hrTemp) || hrTemp == E_OUTOFMEMORY ||
                     pEnCError->Count() > sizeOfErrors ||
                     !"EnC subroutine failed, but we didn't add an entry explaining why!");
                if (FAILED(hrTemp)) 
                {
                    LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ApplyEditAndContinue ApplyFieldDelta failed\n"));
                    hrReturn = E_FAIL;
                    goto exit;
                }
                break;
            default:
                // ignore anything we don't care about for now
                break;
        }
    }
    // Done with the enumerator, and with the ENC interface pointer.
exit:
    if (fHaveLoaderLock)
        GetClassLoader()->UnlockAvailableClasses();

    if (pIMDInternalImportENC) {
            pIMDInternalImportENC->EnumClose(&enumENC);
        pIMDInternalImportENC->Release();
    }
    if (pDeltaMD)
    {
        pDeltaMD->EnumClose(&enumDelta);
        pDeltaMD->Release();
    }
    return hrReturn;
}

HRESULT EditAndContinueModule::CompareMetaSigs(MetaSig *pSigA, 
                          MetaSig *pSigB,
                          UnorderedEnCErrorInfoArray *pEnCError,
                          BOOL fRecordError,
                          mdToken token)
{
    CorElementType cetOld;
    CorElementType cetNew;

    // Loop over the elements until we either find a mismatch, or
    // reach the end.
    do
    {
        cetOld = pSigA->NextArg();
        cetNew = pSigB->NextArg();
    } while(cetOld == cetNew &&
            cetOld != ELEMENT_TYPE_END &&
            cetNew != ELEMENT_TYPE_END);

    // If they're not the same, but we simply ran off the end of the old one,
    // that's fine (the new one simply added stuff).
    // Otherwise a local variable has changed type, which isn't kosher.
    if (cetOld != cetNew &&
        cetOld != ELEMENT_TYPE_END)
    {
        if (fRecordError)
        {
            EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError);
            ADD_ENC_ERROR_ENTRY(pError, 
                        CORDBG_E_ENC_METHOD_SIG_CHANGED, 
                        NULL, //we'll fill these in later
                        token);
        }                    
        return CORDBG_E_ENC_METHOD_SIG_CHANGED;
    }

    return S_OK;
}

HRESULT CollectInterfaces(IMDInternalImport *pImportOld,
                          IMDInternalImport *pImportNew,
                          mdToken token,
                          TOKENARRAY *pInterfacesOld,
                          TOKENARRAY *pInterfacesNew,
                          UnorderedEnCErrorInfoArray *pEnCError)
{                          
    HENUMInternal MDEnumOld;
    ULONG cInterfacesOld;
    HENUMInternal MDEnumNew;
    ULONG cInterfacesNew;
    mdInterfaceImpl iImpl;
    mdToken iFace;
    HRESULT hr = S_OK;

    LOG((LF_CORDB, LL_INFO1000, "CI: tok;0x%x\n", token));
    
    // Initialize the old enumerator
    hr = pImportOld->EnumInit(mdtInterfaceImpl, token, &MDEnumOld);
    if (FAILED(hr))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError)
        ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            token);

        hr = E_FAIL;
        goto LExit;
    }

    // Initialize the new enumerator
    hr = pImportNew->EnumInit(mdtInterfaceImpl, token, &MDEnumNew);
    if (FAILED(hr))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError)
        ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            token);

        hr = E_FAIL;
        goto LExit;
    }
   
    // The the set of supported interfaces isn't allowed to either grow
    // or shrink - it must stay exactly the same
    cInterfacesOld = pImportOld->EnumGetCount(&MDEnumOld);
    cInterfacesNew = pImportNew->EnumGetCount(&MDEnumNew);

    LOG((LF_CORDB, LL_INFO1000, "CI: tok;0x%x num old:0x%x num new: 0x%x\n",
        token, cInterfacesOld, cInterfacesNew));
    
    if (cInterfacesOld != cInterfacesNew)
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError)
        ADD_ENC_ERROR_ENTRY(pError, 
                            CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE,
                            NULL, //we'll fill these in later
                            token);

        hr = E_FAIL;
        goto LExit;
    }

    for (ULONG i = 0; i < cInterfacesOld; i++)
    {
        // For each version, get the next suported interface
        if (!pImportOld->EnumNext(&MDEnumOld, &iImpl))
        {
           EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError)
            ADD_ENC_ERROR_ENTRY(pError, 
                            META_E_FIELD_NOT_FOUND, // kinda of a wussy error code,
                                // but kinda makes sense.
                            NULL, //we'll fill these in later
                            mdTokenNil);
            hr = E_FAIL;
            goto LExit;
        }

        iFace = pImportOld->GetTypeOfInterfaceImpl(iImpl);

        // Add to sorted list
        hr = AddToken(pInterfacesOld, iFace);
        if (FAILED(hr))
        {
            LOG((LF_CORDB, LL_INFO1000, "CI:Failed to add 0x%x - returning!\n", iFace));
            EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError)
            ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            mdTokenNil);
            hr = E_FAIL;
            goto LExit;
        }

        // For each version, get the next suported interface
        if (!pImportNew->EnumNext(&MDEnumNew, &iImpl))
        {
           EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError)
            ADD_ENC_ERROR_ENTRY(pError, 
                            META_E_FIELD_NOT_FOUND, // kinda of a wussy error code,
                                // but kinda makes sense.
                            NULL, //we'll fill these in later
                            mdTokenNil);
            hr = E_FAIL;
            goto LExit;
        }

        iFace = pImportNew->GetTypeOfInterfaceImpl(iImpl);

        // Add to sorted list
        hr = AddToken(pInterfacesNew, iFace);
        if (FAILED(hr))
        {
            LOG((LF_CORDB, LL_INFO1000, "CI:Failed to add 0x%x - returning!\n", iFace));
            EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError)
            ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            mdTokenNil);
            hr = E_FAIL;
            goto LExit;
        }
    }

LExit:
    return hr;
}

HRESULT CompareInterfaceCollections(mdToken token,  // Type whose ifaces are being compared
                                    TOKENARRAY *pInterfacesOld,
                                    TOKENARRAY *pInterfacesNew,
                                    UnorderedEnCErrorInfoArray *pEnCError)
{
    LOG((LF_CORDB, LL_INFO1000, "CIC: tok:0x%x ifaces:0x%x\n", token, 
        pInterfacesOld->Count()));
        
    // If the number of interfaces changed, then we should have
    // detected it in CollectInterfaces, and not proceeded to here.
    _ASSERTE(pInterfacesOld->Count() == pInterfacesNew->Count());


    for (int i = 0; i < pInterfacesOld->Count(); i++)
    {
#ifdef _DEBUG
        // The arrays should be sorted, smallest first, no duplicates.
        if (i > 0)
        {
            _ASSERTE(pInterfacesOld->Get(i-1) < pInterfacesOld->Get(i));
            _ASSERTE(pInterfacesNew->Get(i-1) < pInterfacesNew->Get(i));
        }
#endif //_DEBUG
        LOG((LF_CORDB, LL_INFO1000, "CIC: iface 0x%x, old:0x%x new:0x%x",
            i, *pInterfacesOld->Get(i), *pInterfacesNew->Get(i)));
            
        if (*pInterfacesOld->Get(i) != *pInterfacesNew->Get(i))
        {
           EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError)
            ADD_ENC_ERROR_ENTRY(pError, 
                            CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE,
                            NULL, //we'll fill these in later
                            token);
            return CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE;
        }
    }

    return S_OK;
}


// Make sure that none of the fields have changed in an illegal manner!
HRESULT EditAndContinueModule::ConfirmEnCToType(IMDInternalImport *pImportOld,
                                                IMDInternalImport *pImportNew,
                                                mdToken token,
                                                UnorderedEnCErrorInfoArray *pEnCError)
{
    HRESULT hr = S_OK;
    HENUMInternal MDEnumOld;
    HENUMInternal MDEnumNew;
    ULONG cOld;
    ULONG cNew;
    mdToken tokOld;
    mdToken tokNew;
#ifdef _DEBUG
    USHORT sizeOfErrors;
#endif //_DEBUG    
    
    // Firstly, if it's a new token, then changes are additions, and
    // therefore valid
    if (!pImportOld->IsValidToken(token))
        return S_OK;

    // If a superclass is different between the old & new versions, then 
    // the inheritance chain changed, which is illegal.
    mdToken parent = token;
    mdToken parentOld = token;
    while (parent != mdTokenNil && 
           parent != mdTypeDefNil && 
           parent != mdTypeRefNil &&
           parent == parentOld)
    {
        pImportNew->GetTypeDefProps(parent, 0, &parent); 
        pImportOld->GetTypeDefProps(parentOld, 0, &parentOld);
    }
    
    // Regardless of if there was a diff in the chain, or if one chain ended 
    // first, the inheritance chain doesn't match.
    if (parentOld != parent)
    {
        EnCErrorInfo *pError = pEnCError->Append();
        if (!pError)
        {
            return E_OUTOFMEMORY;
        }
        ADD_ENC_ERROR_ENTRY(pError, 
                            CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS,
                            NULL, //we'll fill these in later
                            token);

        return E_FAIL;
    }

    // Next, make sure that the fields haven't changed.

    // For category, we want to make sure that the changes are legal:
    //  *   Fields: Can add, but existing shouldn't change
    //  *   Interfaces: Shouldn't change at all.
    //

    // Make sure that none of the existing fields on this type have
    // changed.
    hr = pImportOld->EnumInit(mdtFieldDef, token, &MDEnumOld);
    if (FAILED(hr))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError)
        ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            token);

        return hr;
    }

    hr = pImportNew->EnumInit(mdtFieldDef, token, &MDEnumNew);
    if (FAILED(hr))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError)
        ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            token);

        return hr;
    }
    
    cOld = pImportOld->EnumGetCount(&MDEnumOld);
    cNew = pImportNew->EnumGetCount(&MDEnumNew);

    if (cNew < cOld)
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                    CORDBG_E_ENC_METHOD_SIG_CHANGED, 
                    NULL, //we'll fill these in later
                    token);

        return E_FAIL;
    }
    
    for (ULONG i = 0; i < cOld; i++)
    {
        if (!pImportOld->EnumNext(&MDEnumOld, &tokOld))
        {
           EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError)
            ADD_ENC_ERROR_ENTRY(pError, 
                            META_E_FIELD_NOT_FOUND, // kinda of a wussy error code,
                                // but kinda makes sense.
                            NULL, //we'll fill these in later
                            mdTokenNil);
           return META_E_FIELD_NOT_FOUND;
        }

        if (!pImportNew->EnumNext(&MDEnumNew, &tokNew))
        {
           EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError)
            ADD_ENC_ERROR_ENTRY(pError, 
                            META_E_FIELD_NOT_FOUND, // kinda of a wussy error code,
                                // but kinda makes sense.
                            NULL, //we'll fill these in later
                            mdTokenNil);
           return META_E_FIELD_NOT_FOUND;
        }

        if (tokOld != tokNew)
        {
            ULONG cbSigOld;
            PCCOR_SIGNATURE sigOld;
            ULONG cbSigNew;
            PCCOR_SIGNATURE sigNew;
            
            sigOld = pImportOld ->GetSigOfFieldDef(tokOld, &cbSigOld);
            sigNew = pImportOld ->GetSigOfFieldDef(tokOld, &cbSigNew);

            MetaSig msOld(sigOld, this, FALSE, MetaSig::sigField);
            MetaSig msNew(sigNew, this, FALSE, MetaSig::sigField);

#ifdef _DEBUG
            sizeOfErrors = pEnCError->Count();
#endif //_DEBUG
            hr = CompareMetaSigs(&msOld, &msNew, pEnCError, TRUE, token);
            
            _ASSERTE(!FAILED(hr) ||
                     pEnCError->Count() > sizeOfErrors ||
                     !"EnC subroutine failed, but we didn't add an entry explaining why!");
        }
    }

    // Make sure that the set of interfaces that this class implements
    // doesn't change.

    TOKENARRAY oldInterfaces;
    TOKENARRAY newInterfaces;

#ifdef _DEBUG
    sizeOfErrors = pEnCError->Count();
#endif //_DEBUG
    hr = CollectInterfaces(pImportOld,
                           pImportNew, 
                           token, 
                           &oldInterfaces, 
                           &newInterfaces,
                           pEnCError);
    _ASSERTE(!FAILED(hr) || hr == E_OUTOFMEMORY ||
             pEnCError->Count() > sizeOfErrors ||
             !"EnC subroutine failed, but we didn't add an entry explaining why!");
    if(FAILED(hr))
        return hr;

#ifdef _DEBUG
    sizeOfErrors = pEnCError->Count();
#endif //_DEBUG
    hr = CompareInterfaceCollections(token, &oldInterfaces, &newInterfaces, pEnCError);
    _ASSERTE(!FAILED(hr) || hr == E_OUTOFMEMORY ||
             pEnCError->Count() > sizeOfErrors ||
             !"EnC subroutine failed, but we didn't add an entry explaining why!");
    return hr;
}

HRESULT EditAndContinueModule::ApplyFieldDelta(mdFieldDef token,
                                               BOOL fCheckOnly,
                                               IMDInternalImportENC *pDeltaMD,
                                               UnorderedEnCErrorInfoArray *pEnCError)
{
    HRESULT hr = S_OK;
    DWORD dwMemberAttrs = pDeltaMD->GetFieldDefProps(token);
    IMDInternalImport *pOldMD = GetMDImport();

    // use module to resolve to method
    FieldDesc *pField = LookupFieldDef(token);
    if (pField) 
    {
        // It had better be already described in metadata.
        _ASSERTE(pOldMD->IsValidToken(token));
        // 
        // If we got true delta PEs, then we'd fail here, since finding a 
        // FieldDesc indicates that the Field is already described in a previous version.
        // For now check that attributes are identical.
        DWORD cbSig;
        PCCOR_SIGNATURE pFieldSig = pDeltaMD->GetSigOfFieldDef(token, &cbSig);

        // For certain types, we'll end up processing whatever's in metadata further.
        // Rather than duplicating code here that'll just get out of sync with someplace
        // else, we'll do a more robust check against what's in metadata.  
        // See AS/URT RAID 65274, 56093 for an example.
        DWORD dwMemberAttrsOld = pOldMD->GetFieldDefProps(token);
        DWORD cbSigOld;
        PCCOR_SIGNATURE pFieldSigOld = pOldMD->GetSigOfFieldDef(token, &cbSigOld);

        // They should both be fields.
        _ASSERTE(*pFieldSig == *pFieldSigOld &&
                 *pFieldSig == IMAGE_CEE_CS_CALLCONV_FIELD);

        // Move up to point to the (first) ELEMENT_TYPE
        pFieldSig++;
        pFieldSigOld++;

        if ((dwMemberAttrsOld & fdFieldAccessMask) != (dwMemberAttrs & fdFieldAccessMask) ||
            (IsFdStatic(dwMemberAttrsOld) != 0) != (IsFdStatic(dwMemberAttrs) != 0))
        {
            LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** EnCModule::ApplyFieldDelta replaced"
                "field definition for %8.8x doesn't match original Old:attr:0x%x"
                "  new attr:0x%x\n", token, dwMemberAttrsOld, dwMemberAttrs));

            EnCErrorInfo *pError = pEnCError->Append();

            ADD_ENC_ERROR_ENTRY(pError, 
                        CORDBG_E_ENC_CANT_CHANGE_FIELD, 
                        NULL, //we'll fill these in later
                        token);

            return E_FAIL;
        }

        CorElementType fieldType;
        CorElementType fieldTypeOld;
        BOOL fDone = FALSE;

        // There may be multiple ELEMENT_TYPEs embedded in the field sig - compare them all
        while(!fDone)
        {
            fieldType = (CorElementType) *pFieldSig++;
            fieldTypeOld = (CorElementType) *pFieldSigOld++;

            if (fieldTypeOld != fieldType)
            {
                LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** EnCModule::ApplyFieldDelta replaced "
                    "field definition for %8.8x doesn't match original Old:attr:0x%x type:0x%x"
                    "  new attr:0x%x type:0x%x\n", token, dwMemberAttrsOld, fieldTypeOld,
                    dwMemberAttrs, fieldType));

                EnCErrorInfo *pError = pEnCError->Append();

                ADD_ENC_ERROR_ENTRY(pError, 
                            CORDBG_E_ENC_CANT_CHANGE_FIELD, 
                            NULL, //we'll fill these in later
                            token);

                return E_FAIL;
            }

            // Convert specialized classes to ELEMENT_TYPE_CLASS
            // Make sure that any data following the type hasn't changed, either
            switch (fieldType) 
            {
                // These are followed by ELEMENT_TYPE - it shouldn't change!
                case ELEMENT_TYPE_STRING:
                case ELEMENT_TYPE_ARRAY:
                case ELEMENT_TYPE_OBJECT:
                case ELEMENT_TYPE_PTR:
                case ELEMENT_TYPE_BYREF:
                {
                    // We'll loop around & compare the next ELEMENT_TYPE, just like
                    // the current one.
                    break;
                }
                
                // These are followed by a Rid- it shouldn't change!
                case ELEMENT_TYPE_VALUETYPE:
                case ELEMENT_TYPE_CLASS:
                case ELEMENT_TYPE_CMOD_REQD:
                case ELEMENT_TYPE_CMOD_OPT:
                {
                    mdToken fieldRidNextNew = (mdToken) *pFieldSig;
                    mdToken fieldRidNextOld = (mdToken) *pFieldSigOld;
                    
                    if (fieldRidNextNew != fieldRidNextOld) 
                    {
                        LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** EnCModule::ApplyFieldDelta "
                            "replaced field definition for %8.8x doesn't match original b/c "
                            "following RID has changed\n", token));

                        EnCErrorInfo *pError = pEnCError->Append();

                        ADD_ENC_ERROR_ENTRY(pError, 
                                    CORDBG_E_ENC_CANT_CHANGE_FIELD, 
                                    NULL, //we'll fill these in later
                                    token);

                        return E_FAIL;
                    }

                    // This isn't followed by anything else
                    fDone = TRUE;
                    break;
                }
                default:
                {
                    // This isn't followed by anything else
                    fDone = TRUE;
                    break;
                }
            }
        }
        
        LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Warning** EnCModule::ApplyFieldDelta ignoring delta to existing field %8.8x\n", token));
        return S_OK;
    }

    // We'll get some info (out of the NEW store) that we'll need to look stuff up.
    // Need to find the class
    mdTypeDef   typeDefDelta;
    hr = pDeltaMD->GetParentToken(token, &typeDefDelta);
    if (FAILED(hr)) 
    {
        LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** Couldn't get token of"
            "parent of field 0x%x from Delta MeDa hr:0x%x\n", token, hr));
        return hr;   
    }

    // Also need to get the name
    LPCUTF8 szClassNameDelta;
    LPCUTF8 szNamespaceDelta;
    // GetNameOfTypeDef returns void
    pDeltaMD->GetNameOfTypeDef(typeDefDelta, &szClassNameDelta, &szNamespaceDelta);

    // If the type already exists in the old MetaData, then we want to make
    // sure that it hasn't changed at all.
    if (GetMDImport()->IsValidToken(token))
    {
        // This what AFD used to do to get the parent token - it should
        // be the same as what we're doing now. 
        mdTypeDef   typeDef;
        hr = GetMDImport()->GetParentToken(token, &typeDef); 
        if (FAILED(hr)) 
        {
            LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** Couldn't get token of"
                "parent of field 0x%x from old MeDa hr:0x%x\n", token, hr));
            return hr;   
        }

        // Make sure parent class hasn't changed
        if (typeDef != typeDefDelta)
        {
            // Tried to change the parent type during an EnC - what the heck?
            LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** Token of"
                "parent of field 0x%x doesn't match between old & new MeDas"
                "old:0x%x new:0x%x\n", token, typeDef, typeDefDelta));

            EnCErrorInfo *pError = pEnCError->Append();

            ADD_ENC_ERROR_ENTRY(pError, 
                        CORDBG_E_ENC_CANT_CHANGE_FIELD, 
                        NULL, //we'll fill these in later
                        token);

            return E_FAIL;
        }

        // Make sure name hasn't changed        
        LPCUTF8 szClassName;
        LPCUTF8 szNamespace;
        // GetNameOfTypeDef returns void
        GetMDImport()->GetNameOfTypeDef(typeDef, &szClassName, &szNamespace);
        
        MAKE_WIDEPTR_FROMUTF8(wszClassName, szClassName);
        MAKE_WIDEPTR_FROMUTF8(wszClassNameDelta, szClassNameDelta);
        if( 0 != wcscmp(wszClassName, wszClassNameDelta) )
        {
            // Tried to change the name of the class during EnC.
            LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** Tried to change the name"
                " of the parent class of field 0x%x old:%s new:%s\n", token,
                szClassName, szClassNameDelta));

            EnCErrorInfo *pError = pEnCError->Append();

            ADD_ENC_ERROR_ENTRY(pError, 
                        CORDBG_E_ENC_CANT_CHANGE_FIELD, 
                        NULL, //we'll fill these in later
                        token);

            return E_FAIL;
        }
            
        MAKE_WIDEPTR_FROMUTF8(wszNamespace, szNamespace);
        MAKE_WIDEPTR_FROMUTF8(wszNamespaceDelta, szNamespaceDelta);
        if( 0 != wcscmp(wszNamespace, wszNamespaceDelta) )
        {
            // Tried to change the namespace of the class during EnC.
            LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** Tried to change the namespace"
                " of the parent class of field 0x%x old:%s new:%s\n", token,
                szNamespace, szNamespaceDelta));

            EnCErrorInfo *pError = pEnCError->Append();

            ADD_ENC_ERROR_ENTRY(pError, 
                        CORDBG_E_ENC_CANT_CHANGE_FIELD, 
                        NULL, //we'll fill these in later
                        token);

            return E_FAIL;
        }
    }

    // At this point, the EnC should be valid & correct, with one possible exception
    // (see below)
    
    MethodTable *pMT = LookupTypeDef(typeDefDelta).AsMethodTable();
    if (! pMT) 
    {
        LOG((LF_ENC, LL_INFO100, "EACM::AFD: Class for token %8.8x not yet loaded\n", typeDefDelta));
        // class not loaded yet so don't need to update
        return S_OK;    
    }
    
    // We can't load new classes here, since we don't have a Thread object
    // to but used for things like COMPLUS_THROW()s, so if we can't find it,
    // we'll ignore the new field.

    NameHandle name(this, typeDefDelta);
    name.SetName(szNamespaceDelta, szClassNameDelta);
    name.SetTokenNotToLoad(typeDefDelta);

    EEClass *pClass = GetClassLoader()->FindTypeHandle(&name, NULL).GetClass();

    // If class is not found, then it hasn't been loaded yet, and when it is loaded,
    // it will include the changes, so we're fine.
    // @todo Get JenH to verify that this is the same as !pMT case, above
    if (!pClass) 
    {
        LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Warning** Can't find class for token %8.8x\n", typeDefDelta));
        return S_OK;
    }

    // The only possible exception is that if we've loaded a ValueClass,
    // we won't be able to add fields to it - all the fields
    // of a VC must be contiguous, so if there's already one up on
    // the stack somewhere (or embedded in an instantiated object,etc)
    // then we're hosed.
    if (pClass->HasLayout())
    {
        LOG((LF_ENC, LL_INFO100, "EACM::AFD:**Error** Tried to add a field"
            " to a value class token:0x%x\n", token));
            
        EnCErrorInfo *pError = pEnCError->Append();

        ADD_ENC_ERROR_ENTRY(pError, 
                        CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUECLASS, 
                        NULL, //we'll fill these in later
                        token);
                        
        return E_FAIL;
    }

    // If we're just checking to see if the EnC can finish, we don't want
    // to actually add the field.
    if (fCheckOnly)
        return S_OK;

    // Everything is ok, and we need to add the field, so go do it.
    return pClass->AddField(token);
}

// returns the address coresponding to a given RVA when the file is in on-disk format
HRESULT EditAndContinueModule::ApplyMethodDelta(mdMethodDef token, 
                                                BOOL fCheckOnly,
                                                const UnorderedILMap *ilMap,
                                                UnorderedEnCErrorInfoArray *pEnCError,
                                                IMDInternalImport *pImport,
                                                IMDInternalImport *pImportOld,
                                                unsigned int *pILMethodSize,
                                                UnorderedEnCRemapArray *pEnCRemapInfo,
                                                BOOL fMethodBrandNew)
{
    HRESULT hr = S_OK;
#ifdef _DEBUG
    USHORT sizeOfErrors;
#endif //_DEBUG

    // We dont use fMethodBrandNew if we're just checking -
    // assert that here.
    _ASSERTE( (fCheckOnly && !fMethodBrandNew) ||
              !fCheckOnly);

    LOG((LF_CORDB,LL_INFO10000, "EACM:AMD: For method 0x%x, given il map 0x%x\n", token, ilMap));

    _ASSERTE(!fCheckOnly || pImportOld != NULL);
    _ASSERTE(pILMethodSize != NULL);
    
    mdTypeDef   parentTypeDef;
    hr = pImport->GetParentToken(token, &parentTypeDef); 
    if (FAILED(hr)) 
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            token);

        return E_FAIL;
    }
    
#ifdef _DEBUG
    {
        LPCUTF8 szMemberName;
        szMemberName = pImport->GetNameOfMethodDef(token);    
        LPCUTF8 szClassName;
        LPCUTF8 szNamespace;
        pImport->GetNameOfTypeDef(parentTypeDef, &szClassName, &szNamespace);    
        LOG((LF_ENC, LL_INFO100, "EACM:AMD: Applying EnC to %s:%s()\n", szClassName, szMemberName));
    }
#endif

    // get the code for the method  
    ULONG dwMethodRVA;  
    DWORD dwMethodFlags;
    pImport->GetMethodImplProps(token, &dwMethodRVA, &dwMethodFlags);  

    COR_ILMETHOD *pNewCodeInDeltaPE = NULL, *pNewCode = NULL;

#ifdef _DEBUG 
    {
        DWORD dwParentAttrs;
        DWORD dwMemberAttrs = pImport->GetMethodDefProps(token);
        pImport->GetTypeDefProps(parentTypeDef, &dwParentAttrs, 0); 
        
        RVA_OR_SHOULD_BE_ZERO(dwMethodRVA, dwParentAttrs, dwMemberAttrs, dwMethodFlags, pImport, token);
    }
#endif

    // use module to resolve to method
    MethodDesc *pMethod = LookupMethodDef(token);

    if (dwMethodRVA != 0) 
    {
        hr = ResolveOnDiskRVA(dwMethodRVA, (LPVOID*)&pNewCodeInDeltaPE); 
        if (FAILED(hr)) 
        {
            EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError);
            ADD_ENC_ERROR_ENTRY(pError, 
                                COR_E_MISSINGMETHOD, // ResolveOnDiskRVA will return E_FAIL
                                NULL, //we'll fill these in later
                                mdTokenNil);

            return E_FAIL;
        }

        // make a copy of the code as the memory it came in with the delta PE will go away.
        COR_ILMETHOD_DECODER decoderNewIL(pNewCodeInDeltaPE);   
        int totMethodSize = decoderNewIL.GetOnDiskSize(pNewCodeInDeltaPE);
        (*pILMethodSize) = (unsigned int)totMethodSize;

        if (fCheckOnly)
        {
            EHRangeTree *ehrtOnDisk = NULL;
            EHRangeTree *ehrtInRuntime = NULL;
        
            // Assume success.
            hr = S_OK;
        
            if (pMethod == NULL)
                return S_OK; //hasn't been JITted yet
        
            // This all builds up to JITCanCommitChanges, which at this point
            // just makes sure that the EH nesting levels haven't changed.
            ehrtOnDisk = new EHRangeTree(&decoderNewIL);
            if (!ehrtOnDisk)
            {
                hr = E_OUTOFMEMORY;
                goto CheckOnlyReturn;
            }
        
            DWORD dwSize;
            METHODTOKEN methodtoken;
            DWORD relOffset;
            void *methodInfoPtr = NULL;
            BYTE* pbAddr = (BYTE *)pMethod->GetNativeAddrofCode(); 
            IJitManager* pIJM = ExecutionManager::FindJitMan((SLOT)pbAddr);
            
            if (pIJM == NULL)
                goto CheckOnlyReturn;
        
            if (pIJM->IsStub(pbAddr))
                pbAddr = (BYTE *)pIJM->FollowStub(pbAddr);
        
            pIJM->JitCode2MethodTokenAndOffset((SLOT)pbAddr, &methodtoken,&relOffset);
        
            if (pIJM->SupportsPitching())
            {
                if (!pIJM->IsMethodInfoValid(methodtoken))
                {
                    EnCErrorInfo *pError = pEnCError->Append();
                    if (!pError)
                    {
                        hr = E_OUTOFMEMORY;
                        goto CheckOnlyReturn;
                    }
                    ADD_ENC_ERROR_ENTRY(pError, 
                                        CORDBG_E_ENC_BAD_METHOD_INFO,
                                        NULL, //we'll fill these in later
                                        mdTokenNil);
        
                    hr = E_FAIL;
                    goto CheckOnlyReturn;
                }
            }
        
            LPVOID methodInfo = pIJM->GetGCInfo(methodtoken);
            ICodeManager* codeMgrInstance = pIJM->GetCodeManager();
            dwSize = (DWORD) codeMgrInstance->GetFunctionSize(methodInfo);
        
            ehrtInRuntime = new EHRangeTree(pIJM,
                                                         methodtoken,
                                                         dwSize);
            if (!ehrtInRuntime)
            {
                hr = E_OUTOFMEMORY;
                goto CheckOnlyReturn;
            }
            
            LOG((LF_CORDB, LL_EVERYTHING, "EACM::AMD About to get GC info!\n"));
            
            methodInfoPtr = pIJM->GetGCInfo(methodtoken);
        
            LOG((LF_CORDB, LL_EVERYTHING, "EACM::AMD JITCCC?\n"));
            
            if(FAILED(hr = codeMgrInstance->JITCanCommitChanges(methodInfoPtr,
                                                  ehrtInRuntime->MaxDepth(),
                                                  ehrtOnDisk->MaxDepth())))
            {
                EnCErrorInfo *pError = pEnCError->Append();
                if (!pError)
                {
                    hr = E_OUTOFMEMORY;
                    goto CheckOnlyReturn;
                }
                ADD_ENC_ERROR_ENTRY(pError, 
                                CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE, 
                                NULL, //we'll fill these in later
                                token);
                                
                hr = E_FAIL;
                goto CheckOnlyReturn;
            }

            
            // Make sure the local signature (local variables' types) haven't changed.
            if ((pMethod->IsIL() && pImportOld != NULL))
            {
                // To change the local signature of a method that we're currently in is
                // erroneous - horribly bad things will happen.  We can EXTEND the signature
                // by tacking extra vars onto the space at the end, but we're not allowed to
                // change the existing ones, UNLESS the method isn't on the call stack anywhere.
                // Why?  Because there's no existing frames that have the old variable layout
                // so we don't have to worry about moving stuff around.  How do we know this is
                // true?  We don't - it's up to the user (eg, CorDbg) to make sure this is true.
                // In a DEBUG build, we'll note if this version of the code has been JITted,
                // and if it has, if the local variables have changed, and if so, we'll note
                // that we shouldn't move from this version to the new version.  In 
                // a checked build we'll assert

                // If the method hasn't been JITted yet, then we don't have to
                // worry about making a bad transition from it.
                COR_ILMETHOD_DECODER decoderOldIL(pMethod->GetILHeader());
        
                // I don't see why COR_ILMETHOD_DECODER doesn't simply set this field to 
                // be mdSignatureNil in the absence of a local signature, but since it sets
                // LocalVarSigTok to zero, we have to set it to what we expect - mdSignatureNil.
                mdSignature mdOldLocalSig = (decoderOldIL.LocalVarSigTok)?(decoderOldIL.LocalVarSigTok):
                                    (mdSignatureNil);
                mdSignature mdNewLocalSig = (decoderNewIL.LocalVarSigTok)?(decoderNewIL.LocalVarSigTok):
                                    (mdSignatureNil);
        
                if (mdOldLocalSig != mdSignatureNil)
                {
                    PCCOR_SIGNATURE sigOld;
                    ULONG cbSigOld;
                    PCCOR_SIGNATURE sigNew;
                    ULONG cbSigNew;
        
                    // If there was a local signature in the old version, then there must be 
                    // a local sig in the new version (not allowed to delete all variables from
                    // a method).
                    if (mdNewLocalSig == mdSignatureNil)
                    {
                        g_pDebugInterface->LockJITInfoMutex();
                        g_pDebugInterface->SetEnCTransitionIllegal(pMethod);
                        g_pDebugInterface->UnlockJITInfoMutex();
                        goto CheckOnlyReturn;
                    }
                         
                    sigOld = pImportOld->GetSigFromToken(mdOldLocalSig, &cbSigOld);
                    if (sigOld == NULL)
                    {   
                        g_pDebugInterface->LockJITInfoMutex();
                        g_pDebugInterface->SetEnCTransitionIllegal(pMethod);
                        g_pDebugInterface->UnlockJITInfoMutex();
                        goto CheckOnlyReturn;
                    }
                    
                    sigNew = pImport->GetSigFromToken(mdNewLocalSig, &cbSigNew);
                    if (sigNew == NULL)
                    {   
                        g_pDebugInterface->LockJITInfoMutex();
                        g_pDebugInterface->SetEnCTransitionIllegal(pMethod);
                        g_pDebugInterface->UnlockJITInfoMutex();
                        goto CheckOnlyReturn;
                    }
        
                    if (mdOldLocalSig != mdNewLocalSig)
                    {
                        MetaSig msOld(sigOld, this, FALSE, MetaSig::sigLocalVars);
                        MetaSig msNew(sigNew, this, FALSE, MetaSig::sigLocalVars);
        #ifdef _DEBUG
                        sizeOfErrors = pEnCError->Count();
        #endif //_DEBUG
                        hr = CompareMetaSigs(&msOld, &msNew, pEnCError, FALSE, token);
        
                        _ASSERTE(pEnCError->Count() == sizeOfErrors ||
                                 !"EnC subroutine failed, and we added an entry explaining why even though we don't want to!!");
                        if (FAILED(hr))
                        {
                            g_pDebugInterface->LockJITInfoMutex();
                            g_pDebugInterface->SetEnCTransitionIllegal(pMethod);
                            g_pDebugInterface->UnlockJITInfoMutex();
                            hr = S_OK; // We don't want to fail the EnC
                            goto CheckOnlyReturn;
                        }
                    }
                }
            }
            
        // Properly clean up all work we've done in this branch.
CheckOnlyReturn:
            if (ehrtOnDisk)
                delete ehrtOnDisk;
            if (ehrtInRuntime)
                delete ehrtInRuntime;
            return hr;
        }

        hr = GetRVAableMemory(totMethodSize,
                              (void **)&pNewCode);
        // This should never fail b/c the user should have called "CanCommitChanges",
        // and if we couldn't get the memory, then we should have found out then.
        _ASSERTE(!FAILED(hr));
        if (FAILED(hr))
            return hr;
            
        memcpy(pNewCode, pNewCodeInDeltaPE, totMethodSize);

        hr = GetEmitter()->SetMethodProps(token, -1, (ULONG)((BYTE*)pNewCode-GetILBase()), dwMethodFlags);
        if (FAILED(hr)) 
        {
            EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError);
            ADD_ENC_ERROR_ENTRY(pError, 
                                hr,
                                NULL, //we'll fill these in later
                                mdTokenNil);

            return E_FAIL;
        }
    }
    else if (fCheckOnly)    // couldn't find it on disk - what now?
    {
        return S_OK;
    }

    // If the method is brand new in this version, we want the version
    // number to be 1.  See RAID 74459
    if (!fMethodBrandNew)
    {
        LOG((LF_CORDB, LL_INFO1000, "EACM:AMD: Method 0x%x existed in prev."
            "version - bumping up ver #\n", token));

        // Bump up the version number whether or not we have a methodDesc,
        // RAID 71972
        g_pDebugInterface->IncrementVersionNumber(this, 
                                                  token);
    }
#ifdef _DEBUG
    else
    {
        LOG((LF_CORDB, LL_INFO1000, "EACM:AMD: method 0x%x is brand new - NOT"
            " incrementing version number\n", token));
    }
#endif

    if (pMethod) 
    {

        // If method is both old and abstract, we're done.
        if (!dwMethodRVA) 
            return S_OK;

        // notify debugger - need to pass it instr mappings
#ifdef _DEBUG
        sizeOfErrors = pEnCError->Count();
#endif //_DEBUG

        // @todo Do we want to lock down the whole UpdateFunction to make
        // it atomic?
        hr = g_pDebugInterface->UpdateFunction(pMethod, ilMap, pEnCRemapInfo, pEnCError);
        
        _ASSERTE(!FAILED(hr) || hr == E_OUTOFMEMORY ||
                 pEnCError->Count() > sizeOfErrors ||
                 !"EnC subroutine failed, but we didn't add an entry explaining why!");
        if (FAILED(hr)) 
            return hr;

        if (!IJitManager::UpdateFunction(pMethod, pNewCode)) 
        {
            LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ApplyMethodDelta UpdateFunction failed\n"));
            EnCErrorInfo *pError = pEnCError->Append();

            TESTANDRETURNMEMORY(pError);
            ADD_ENC_ERROR_ENTRY(pError, 
                                CORDBG_E_ENC_JIT_CANT_UPDATE,
                                NULL, //we'll fill these in later
                                mdTokenNil);

            return E_FAIL;
        }
        return S_OK;
    }

    // this is a new method. Now what?
    // call class to add the method
    MethodTable *pMT = LookupTypeDef(parentTypeDef).AsMethodTable();   
    if (!pMT) 
    {
        if (dwMethodRVA) 
        {
            // class not loaded yet so don't update, but need to update RVA relative to m_base so can be found later
            hr = GetEmitter()->SetMethodProps(token,-1, (ULONG)((BYTE*)pNewCode-GetILBase()), dwMethodFlags);
            if (FAILED(hr)) 
            {
                EnCErrorInfo *pError = pEnCError->Append();

                TESTANDRETURNMEMORY(pError);
                ADD_ENC_ERROR_ENTRY(pError, 
                                    hr,
                                    NULL, //we'll fill these in later
                                    token);

                return E_FAIL;
            }
        }
        return S_OK;    
    }

    // now need to find the class
    NameHandle name(this, parentTypeDef);
    EEClass *pClass = GetClassLoader()->LoadTypeHandle(&name).GetClass();

    // class must be found
    if (!pClass) 
    {
        LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ApplyMethodDelta can't find class for token %8.8x\n", parentTypeDef));
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            CORDBG_E_ENC_MISSING_CLASS,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_FAIL;
    }

    hr = pClass->AddMethod(token, pNewCode);
    if (FAILED(hr))
    {
        EnCErrorInfo *pError = pEnCError->Append();

        TESTANDRETURNMEMORY(pError);
        ADD_ENC_ERROR_ENTRY(pError, 
                            hr,
                            NULL, //we'll fill these in later
                            mdTokenNil);

        return E_FAIL;
    }

    return hr;
}

// returns the address coresponding to a given RVA when the file is in on-disk format
HRESULT EditAndContinueModule::ResolveOnDiskRVA(DWORD rva, LPVOID *addr)
{
    _ASSERTE(addr); 
    
    for (int i=0; i < m_dNumSections; i++)
    {
        if (rva >= m_pSections[i].startRVA && rva <= m_pSections[i].endRVA)
        {
            *addr = (LPVOID)(m_pSections[i].data + (rva - m_pSections[i].startRVA));    
            return S_OK;    
        }   
    }   
    
    return E_FAIL;  
}

HRESULT EditAndContinueModule::ResumeInUpdatedFunction(MethodDesc *pFD, 
                    SIZE_T newILOffset, 
                    UINT mapping, 
                    SIZE_T which,
                    void *DebuggerVersionToken,
                    CONTEXT *pOrigContext,
                    BOOL fJitOnly,
                    BOOL fShortCircuit)
{   
    LOG((LF_ENC, LL_INFO100, "EnCModule::ResumeInUpdatedFunction for %s at "
        "IL offset 0x%x, mapping 0x%x, which:0x%x SS:0x%x\n", 
        pFD->m_pszDebugMethodName, newILOffset, mapping, which, fShortCircuit));

    BOOL fAccurate = FALSE;
    
    Thread *pCurThread = GetThread();
    _ASSERTE(pCurThread);

    BOOL disabled = pCurThread->PreemptiveGCDisabled();
    if (!disabled)
        pCurThread->DisablePreemptiveGC();

#ifdef _DEBUG
    BOOL shouldBreak = g_pConfig->GetConfigDWORD(
                                          L"EncResumeInUpdatedFunction",
                                          0);
    if (shouldBreak > 0) {
        _ASSERTE(!"EncResumeInUpdatedFunction");
    }
#endif

    // If we don't set this here, inside of the JITting, the JITComplete callback
    // into the debugger will send up the EnC remap event, which is too early.
    // We want to wait until we've made it look like we're in the new version
    // of the code, for things like native re-stepping.
    g_pDebugInterface->LockJITInfoMutex();
    
    SIZE_T nVersionCur = g_pDebugInterface->GetVersionNumber(pFD);
    g_pDebugInterface->SetVersionNumberLastRemapped(pFD, nVersionCur);
    
    g_pDebugInterface->UnlockJITInfoMutex();
    
    // Setup a frame so that has context for the exception
    // so that gc can crawl the stack and do the right thing.  
    assert(pOrigContext);
    ResumableFrame resFrame(pOrigContext);
    resFrame.Push(pCurThread);

    CONTEXT *pCtxTemp = NULL;
    // RAID 55210 : we need to zero out the filter context so a multi-threaded
    // GC doesn't result in somebody else tracing this thread & concluding
    // that we're in JITted code.
    // We need to remove the filter context so that if we're in preemptive GC
    // mode, we'll either have the filter context, or the ResumableFrame,
    // but not both, set.
    // Since we're in cooperative mode here, we can swap the two non-atomically
    // here.
    pCtxTemp = pCurThread->GetFilterContext();
    pCurThread->SetFilterContext(NULL); 
    
    // get the code address (may jit the fcn if not already jitted)
    const BYTE *jittedCode = NULL;
    COMPLUS_TRY {
        jittedCode = (const BYTE *) pFD->DoPrestub(NULL);
        LOG((LF_ENC, LL_INFO100, "EnCModule::ResumeInUpdatedFunction JIT successful\n"));
        //jittedCode = UpdateableMethodStubManager::g_pManager->GetStubTargetAddr(jittedCode);
        
        TraceDestination trace;
        BOOL fWorked;
        do 
        {
            fWorked = StubManager::TraceStub(jittedCode, &trace );
            jittedCode = trace.address;
            _ASSERTE( fWorked );
        } while( trace.type == TRACE_STUB );

        _ASSERTE( trace.type == TRACE_MANAGED );
        jittedCode = trace.address;

    } COMPLUS_CATCH {
        LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ResumeInUpdatedFunction JIT failed\n"));
#ifdef _DEBUG
        DefaultCatchHandler();
#endif
    } COMPLUS_END_CATCH

    resFrame.Pop(pCurThread);

    // Restore this here - see 55210 comment above
    pCurThread->SetFilterContext(pCtxTemp); 
    
    if (!jittedCode || fJitOnly) 
    {
        if (!disabled)
            pCurThread->EnablePreemptiveGC();
            
        return (!jittedCode?E_FAIL:S_OK);
    }

    // This will create a new frame and copy old vars to it
    // need pointer to old & new code, old & new info

    METHODTOKEN     oldMethodToken,     newMethodToken;
    DWORD           oldNativeOffset,    newNativeOffset,    dummyOffset;
    LPVOID          oldInfoPtr,         newInfoPtr;
    DWORD           oldFrameSize,       newFrameSize;

    SLOT oldNativeIP = (SLOT) GetIP(pOrigContext);
    IJitManager* pEEJM = ExecutionManager::FindJitMan(oldNativeIP); 
    _ASSERTE(pEEJM);
    ICodeManager * pEECM = pEEJM->GetCodeManager();
    _ASSERTE(pEECM);

    pEEJM->JitCode2MethodTokenAndOffset(oldNativeIP, &oldMethodToken, &oldNativeOffset);
    pEEJM->JitCode2MethodTokenAndOffset((SLOT)jittedCode,  &newMethodToken, &dummyOffset);

    _ASSERTE(dummyOffset == 0);
    LOG((LF_CORDB, LL_INFO10000, "EACM::RIUF: About to map IL forwards!\n"));
    g_pDebugInterface->MapILInfoToCurrentNative(pFD, 
                                                newILOffset, 
                                                mapping, 
                                                which, 
                                                (SIZE_T *)jittedCode, 
                                                (SIZE_T *)&newNativeOffset, 
                                                (void *)DebuggerVersionToken,
                                                &fAccurate);

    // Get the var info which the codemanager will use for updating 
    // enregistered variables correctly, or variables whose lifetimes differ
    // at the update point

    const ICorDebugInfo::NativeVarInfo *    oldVarInfo,    * newVarInfo;
    SIZE_T                                  oldVarInfoCount, newVarInfoCount;

    g_pDebugInterface->GetVarInfo(pFD, DebuggerVersionToken, &oldVarInfoCount, &oldVarInfo);

    g_pDebugInterface->GetVarInfo(pFD, NULL, &newVarInfoCount, &newVarInfo);

    // Get the GC info 
    oldInfoPtr = pEEJM->GetGCInfo(oldMethodToken);
    newInfoPtr = pEEJM->GetGCInfo(newMethodToken);

    // Now ask the codemanager to fix the context.

    oldFrameSize = pEECM->GetFrameSize(oldInfoPtr);
    newFrameSize = pEECM->GetFrameSize(newInfoPtr);

    // As FixContextForEnC() munges directly on the stack, it
    // might screw up the caller stack (including itself). So use alloca to make sure
    // that there is sufficient space on stack so that don't overwrite anything we
    // care about and we alloca any variable we need to have around after the call to make
    // sure that they are lower on the stack

    struct LowStackVars {
        CONTEXT context;
        const BYTE* newNativeIP;
        LPVOID oldFP;
    } *pLowStackVars;
    
    // frame size may go down (due to temp vars or register allocation changes) so make sure always min of 0
    pLowStackVars = (LowStackVars*)alloca(sizeof(LowStackVars) + max(0, (newFrameSize - oldFrameSize)));

    // The originial context is sitting just above the old JITed method.
    // Make a copy of the context so that when FixContextForEnC() munges
    // the stack, we have a copy to work with

    pLowStackVars->context = *pOrigContext;

    pLowStackVars->newNativeIP = jittedCode + newNativeOffset;
#ifdef _X86_
    pLowStackVars->oldFP = (LPVOID)(size_t)pOrigContext->Esp; // get the frame pointer
#else
    _ASSERTE(!"GetFP() is NYI for non-x86");
#endif

    LOG((LF_ENC, LL_INFO100, "EnCModule::ResumeInUpdatedFunction FixContextForEnC oldNativeOffset: 0x%x, newNativeOffset: 0x%x\n", oldNativeOffset, newNativeOffset));
    if (ICodeManager::EnC_OK !=
        pEECM->FixContextForEnC(
                    (void *)pFD,
                    &pLowStackVars->context, 
                    oldInfoPtr, 
                    oldNativeOffset, 
                    oldVarInfo, oldVarInfoCount,
                    newInfoPtr, 
                    newNativeOffset,
                    newVarInfo, newVarInfoCount)) {
        LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::ResumeInUpdatedFunction for FixContextForEnC failed\n"));
        return E_FAIL;
    }

    // Set the new IP
    LOG((LF_ENC, LL_INFO100, "EnCModule::ResumeInUpdatedFunction: Resume at EIP=0x%x\n",
        (LPVOID)pLowStackVars->newNativeIP));

    pCurThread->SetFilterContext(&pLowStackVars->context);

    SetIP(&pLowStackVars->context, (LPVOID)pLowStackVars->newNativeIP);

    g_pDebugInterface->DoEnCDeferedWork(pFD, fAccurate);

    // If this fails, user will hit an extra bp, but will be otherwise fine.
    HRESULT hrIgnore = g_pDebugInterface->ActivatePatchSkipForEnc(
                                                &pLowStackVars->context,
                                                pFD,
                                                fShortCircuit);

    // Now jump into the new version of the method
    // @todo Remove these lines & return normally
    pCurThread->SetFilterContext( NULL );
    
    ResumeAtJit(&pLowStackVars->context, pLowStackVars->oldFP);

    // At this point we shouldn't have failed, so this is genuinely erroneous.
    LOG((LF_ENC, LL_ERROR, "**Error** EnCModule::ResumeInUpdatedFunction returned from ResumeAtJit"));
    _ASSERTE(!"Should not return from ResumeAtJit()");
    
    return E_FAIL;
}

const BYTE *EditAndContinueModule::ResolveVirtualFunction(OBJECTREF orThis, MethodDesc *pMD)
{
    EEClass *pClass = orThis->GetClass();
    _ASSERTE(pClass);
    MethodDesc *pTargetMD = FindVirtualFunction(pClass, pMD->GetMemberDef());
    _ASSERTE(pTargetMD);
    return pTargetMD->GetUnsafeAddrofCode();    // don't want any virtual override applied
}

MethodDesc *EditAndContinueModule::FindVirtualFunction(EEClass *pClass, mdToken token)
{
    PCCOR_SIGNATURE pMemberSig = NULL;
    DWORD cMemberSig;
    mdMethodDef methodToken = mdMethodDefNil;

    LPCUTF8 szMethodName = GetMDImport()->GetNameOfMethodDef(token);
    pMemberSig = GetMDImport()->GetSigOfMethodDef(token, &cMemberSig);
    
    EEClass *pCurClass = pClass;
    while (pCurClass) {
        pCurClass->GetMDImport()->FindMethodDef(
                pCurClass->GetCl(), 
                szMethodName, 
                pMemberSig, 
                cMemberSig, 
                &methodToken);
        if (methodToken != mdMethodDefNil)
            break;
        pCurClass = pCurClass->GetParentClass();
    }

    if (methodToken == mdMethodDefNil) {
#ifdef _DEBUG
        LOG((LF_ENC, LL_INFO100, "**Error** EnCModule::FindVirtualFunction failed for %s::%s\n", 
            (pClass!=NULL)?(pClass->m_szDebugClassName):("<Global Namespace>"), szMethodName));
#endif
        return NULL;
    }

    MethodDesc *pTargetMD = pCurClass->GetModule()->LookupMethodDef(methodToken);
    return pTargetMD;
}

// NOTE that this is very simiilar to 
const BYTE *EditAndContinueModule::ResolveField(OBJECTREF thisPointer, 
                                                EnCFieldDesc *pFD,
                                                BOOL fAllocateNew)
{
    // If we're not allocating any new objects, then we won't
    // throw any exceptions.
    // THIS MUST BE TRUE!!  We call this from the DebuggerRCThread,
    // and we'll be hosed big time if we throw something.
//      if (fAllocateNew) {
//          THROWSCOMPLUSEXCEPTION();
//      }
        
#ifdef _DEBUG
    if(REGUTIL::GetConfigDWORD(L"EACM::RF",0))
        _ASSERTE( !"Stop in EditAndContinueModule::ResolveField?");
#endif //_DEBUG

    // If it's static, we stash in the EnCFieldDesc
    if (pFD->IsStatic())
    {
        EnCAddedStaticField *pAddedStatic = pFD->GetStaticFieldData(fAllocateNew);
        if (!pAddedStatic)
        {
            _ASSERTE(!fAllocateNew); // GetStaticFieldData woulda' thrown
            return NULL;
        }
        
        return pAddedStatic->GetFieldData();
    }

    // not static so get out of the syncblock
    SyncBlock* pBlock;
    if (fAllocateNew)
        pBlock = thisPointer->GetSyncBlockSpecial();
    else
        pBlock = thisPointer->GetRawSyncBlock();
        
    if (pBlock == NULL)
    {
        if (fAllocateNew) {
            THROWSCOMPLUSEXCEPTION();
            COMPlusThrowOM();
        }
        else
            return NULL;
    }

    // Not a big deal if we allocate this early.
    EnCSyncBlockInfo *pEnCInfo = pBlock->GetEnCInfo();
    if (!pEnCInfo) 
    {
        pEnCInfo = new EnCSyncBlockInfo;
        if (! pEnCInfo) 
        {
            if (fAllocateNew) {
                THROWSCOMPLUSEXCEPTION();
                COMPlusThrowOM();
            }
            else
                return NULL;
        }
        
        pBlock->SetEnCInfo(pEnCInfo);
    }
    
    return pEnCInfo->ResolveField(pFD, fAllocateNew);
}

EnCEEClassData *EditAndContinueModule::GetEnCEEClassData(EEClass *pClass, BOOL getOnly)
{
    EnCEEClassData** ppData = m_ClassList.Table();
    EnCEEClassData** ppLast = ppData + m_ClassList.Count();
    
    while (ppData < ppLast)
    {
        if ((*ppData)->GetClass() == pClass)
            return *ppData;
        ++ppData;
    }
    if (getOnly)
        return NULL;

    EnCEEClassData *pNewData = (EnCEEClassData*)pClass->GetClassLoader()->GetLowFrequencyHeap()->AllocMem(sizeof(EnCEEClassData));
    pNewData->Init(pClass);
    ppData = m_ClassList.Append();
    if (!ppData)
        return NULL;
    *ppData = pNewData;
    return pNewData;
}

void EnCFieldDesc::Init(BOOL fIsStatic)
{ 
    m_dwFieldSize = -1; 
    m_pByValueClass = NULL;
    m_pStaticFieldData = NULL;
    m_bNeedsFixup = TRUE;
    if (fIsStatic) 
        m_isStatic = TRUE;
    SetEnCNew();
}


EnCAddedField *EnCAddedField::Allocate(EnCFieldDesc *pFD)
{
    THROWSCOMPLUSEXCEPTION();

    EnCAddedField *pEntry = (EnCAddedField *)new (throws) BYTE[sizeof(EnCAddedField) + sizeof(OBJECTHANDLE) - 1];
    pEntry->m_pFieldDesc = pFD;

    _ASSERTE(!pFD->GetEnclosingClass()->IsShared());
    AppDomain *pDomain = (AppDomain*) pFD->GetEnclosingClass()->GetDomain();

    // we use handles for non-static fields so can delete when the object goes away and they
    // will be collected. We create a helper object to and store this helper object in the handle. 
    // The helper then contains an oref to the real object that we are adding. 
    // The reason for doing this is that we cannot hand out the handle address for
    // the OBJECTREF address so need to hand out something else that is hooked up to the handle
    // to keep the added object alive as long as the containing instance is alive.

    OBJECTHANDLE *pHandle = (OBJECTHANDLE *)&pEntry->m_FieldData;
    *pHandle = pDomain->CreateHandle(NULL);

    MethodTable *pHelperMT = g_Mscorlib.GetClass(CLASS__ENC_HELPER);

    StoreFirstObjectInHandle(*pHandle, AllocateObject(pHelperMT));

    if (pFD->GetFieldType() != ELEMENT_TYPE_CLASS) {
        OBJECTREF obj = NULL;
        if (pFD->IsByValue()) {
            // Create a boxed version of the value class. This allows the standard GC algorithm 
            // to take care of internal pointers into the value class.
            obj = AllocateObject(pFD->GetByValueClass()->GetMethodTable());
        } else {
            // create the storage as a single element array in the GC heap so can be tracked and if have
            // any pointers to the member won't be lost if the containing object is collected
            obj = AllocatePrimitiveArray(ELEMENT_TYPE_I1, GetSizeForCorElementType(pFD->GetFieldType()));
        }
        // store the boxed version into the helper object
        FieldDesc *pHelperField = g_Mscorlib.GetField(FIELD__ENC_HELPER__OBJECT_REFERENCE);
        OBJECTREF *pOR = (OBJECTREF *)pHelperField->GetAddress(ObjectFromHandle(*pHandle)->GetAddress());
        SetObjectReference( pOR, obj, pDomain );
    }

    return pEntry;
}

const BYTE *EnCSyncBlockInfo::ResolveField(EnCFieldDesc *pFD, BOOL fAllocateNew)
{
    EnCAddedField *pEntry = m_pList;
    
    while (pEntry && pEntry->m_pFieldDesc != pFD)
        pEntry = pEntry->m_pNext;
        
    if (!pEntry && fAllocateNew) 
    {
        pEntry = EnCAddedField::Allocate(pFD);
        // put at front of list so in order of recently accessed
        pEntry->m_pNext = m_pList;
        m_pList = pEntry;
    }

    if (!pEntry)
    {
        _ASSERTE(!fAllocateNew); // If pEntry was NULL & fAllocateNew, then
                                 // we should have thrown an OM exception in Allocate
                                 // before getting here.
        return NULL;                                
    }

    OBJECTHANDLE pHandle = *(OBJECTHANDLE*)&pEntry->m_FieldData;
    OBJECTREF pHelper = ObjectFromHandle(pHandle);
    _ASSERTE(pHelper != NULL);

    FieldDesc *pHelperField;
    if (fAllocateNew)
    {
        pHelperField = g_Mscorlib.GetField(FIELD__ENC_HELPER__OBJECT_REFERENCE);
    }
    else
    {
        // We _HAVE_ to call this one b/c (a) we can't throw exceptions on the
        // debugger RC (nonmanaged thread), and (b) we _DON'T_ want to run 
        // class init code, either.
        pHelperField = g_Mscorlib.RawGetField(FIELD__ENC_HELPER__OBJECT_REFERENCE);
        if (pHelperField == NULL)
            return NULL;
    }

    OBJECTREF *pOR = (OBJECTREF *)pHelperField->GetAddress(pHelper->GetAddress());

    if (pFD->IsByValue())
        return (const BYTE *)((*pOR)->UnBox());
    else if (pFD->GetFieldType() == ELEMENT_TYPE_CLASS)
        return (BYTE *)pOR;
    else
        return (const BYTE*)((*(I1ARRAYREF*)pOR)->GetDirectPointerToNonObjectElements());
}

void EnCSyncBlockInfo::Cleanup()
{
    EnCAddedField *pEntry = m_pList;
    while (pEntry) {
        EnCAddedField *next = pEntry->m_pNext;
        if (pEntry->m_pFieldDesc->IsByValue() || pEntry->m_pFieldDesc->GetFieldType() == ELEMENT_TYPE_CLASS) {
            DestroyHandle(*(OBJECTHANDLE*)&pEntry->m_FieldData);
        }
        delete [] ((BYTE*)pEntry);
        pEntry = next;
    }
    delete this;
}

EnCAddedStaticField *EnCAddedStaticField::Allocate(EnCFieldDesc *pFD)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(!pFD->GetEnclosingClass()->IsShared());
    AppDomain *pDomain = (AppDomain*) pFD->GetEnclosingClass()->GetDomain();

    size_t size;
    if (pFD->IsByValue() || pFD->GetFieldType() == ELEMENT_TYPE_CLASS) {
        size = sizeof(EnCAddedStaticField) + sizeof(OBJECTREF*) - 1;
    } else {
        size = sizeof(EnCAddedStaticField) + GetSizeForCorElementType(pFD->GetFieldType()) - 1;
    }

    // allocate space for field
    EnCAddedStaticField *pEntry = (EnCAddedStaticField *)pDomain->GetHighFrequencyHeap()->AllocMem(size);
    if (!pEntry)
        COMPlusThrowOM();
    pEntry->m_pFieldDesc = pFD;
    
    if (pFD->IsByValue()) {
        // create a boxed version of the value class.  This allows the standard GC
        // algorithm to take care of internal pointers in the value class.
        OBJECTREF **pOR = (OBJECTREF**)&pEntry->m_FieldData;
        pDomain->AllocateStaticFieldObjRefPtrs(1, pOR);
        OBJECTREF obj = AllocateObject(pFD->GetByValueClass()->GetMethodTable());
        SetObjectReference( *pOR, obj, pDomain );

    } else if (pFD->GetFieldType() == ELEMENT_TYPE_CLASS) {

        // we use static object refs for static fields as these fields won't go away 
        // unless class is unloaded, and they can easily be found by GC
        OBJECTREF **pOR = (OBJECTREF**)&pEntry->m_FieldData;
        pDomain->AllocateStaticFieldObjRefPtrs(1, pOR);
    }

    return pEntry;
}

// GetFieldData returns the ADDRESS of the object.  
const BYTE *EnCAddedStaticField::GetFieldData()
{
    if (m_pFieldDesc->IsByValue() || m_pFieldDesc->GetFieldType() == ELEMENT_TYPE_CLASS) {
        // It's indirect via m_FieldData.
        return *(const BYTE**)&m_FieldData;
    } else {
        // An elementry type. It's stored directly in m_FieldData.
        return (const BYTE*)&m_FieldData;
    }
}

EnCAddedStaticField* EnCFieldDesc::GetStaticFieldData(BOOL fAllocateNew)
{
    if (!m_pStaticFieldData && fAllocateNew)
        m_pStaticFieldData = EnCAddedStaticField::Allocate(this);
        
    return m_pStaticFieldData;
}

void EnCEEClassData::AddField(EnCAddedFieldElement *pAddedField)
{
    EnCFieldDesc *pFD = &pAddedField->m_fieldDesc;
    EnCAddedFieldElement **pList;
    if (pFD->IsStatic())
    {
        ++m_dwNumAddedStaticFields;
        pList = &m_pAddedStaticFields;
    } 
    else
    {
        ++m_dwNumAddedInstanceFields;
        pList = &m_pAddedInstanceFields;
    }

    if (*pList == NULL) {
        *pList = pAddedField;
        return;
    }
    EnCAddedFieldElement *pCur = *pList;
    while (pCur->m_next != NULL)
        pCur = pCur->m_next;
    pCur->m_next = pAddedField;
}

#endif // EnC_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\encee.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: EnC.H
// 

// CEELOAD.H defines the class use to represent the PE file
// ===========================================================================
#ifndef EnC_H 
#define EnC_H

#include "ceeload.h"
#include "field.h"
#include "class.h"

struct EnCEntry;
class FieldDesc;
struct EnCAddedField;
struct EnCAddedStaticField;

#define SCRATCH_SPACE_SIZE 16*1024                          // 16K
#define SCRATCH_SPACE_THRESHHOLD SCRATCH_SPACE_SIZE - 100   // how close to end do we allow?
#define ENC_EXTRA_SLOT_COUNT 2                              // In Enc mode, allocate an extra
                                                            // 2 slots at the end of each
                                                            // VTable for AddMethod to use,
                                                            // later. Should be kept small.

class EnCFieldDesc : public FieldDesc 
{
#ifdef EnC_SUPPORTED
    BOOL m_bNeedsFixup;
    DWORD m_dwFieldSize;
    EEClass *m_pByValueClass;
    EnCAddedStaticField *m_pStaticFieldData;  

  public:
    void Init(BOOL fIsStatic);

    BOOL NeedsFixup() {
        return m_bNeedsFixup;
    }

    HRESULT Fixup(mdFieldDef token) {
        HRESULT hr = GetEnclosingClass()->FixupFieldDescForEnC(this, token);
        if (SUCCEEDED(hr))
            m_bNeedsFixup = FALSE;
        return hr;
    }

    EEClass *GetByValueClass() {
        _ASSERTE(m_pByValueClass);
        return m_pByValueClass;
    }
    
    void SetByValueClass(EEClass *pByValueClass) {
        m_pByValueClass = pByValueClass;
    }

    EnCAddedStaticField *GetStaticFieldData(BOOL fAllocateNew);

    void SetMemberDef(mdMethodDef mb)
    {
        // m_mb from FieldDesc
        m_mb = mb;
    }
#endif // EnC_SUPPORTED
};

#ifdef EnC_SUPPORTED

struct EnCAddedFieldElement {
    EnCAddedFieldElement *m_next;
    EnCFieldDesc m_fieldDesc;
    void Init(BOOL fIsStatic) {
        m_next = NULL;
        m_fieldDesc.Init(fIsStatic);
    }
};

class EnCEEClassData
{
    friend class EEClass;
    friend FieldDescIterator;

    EEClass              *m_pClass;
    LoaderHeap           *m_pHeapNearVTable;
    int                   m_dwNumAddedInstanceFields;
    int                   m_dwNumAddedStaticFields;
    EnCAddedFieldElement *m_pAddedInstanceFields;
    EnCAddedFieldElement *m_pAddedStaticFields;
    
  public:
    void Init(EEClass *pClass) 
    {
        m_pClass = pClass;
        m_dwNumAddedInstanceFields = m_dwNumAddedStaticFields = 0;
        m_pAddedInstanceFields = m_pAddedStaticFields = 0;
        m_pHeapNearVTable = NULL;
    }
    
    void AddField(EnCAddedFieldElement *pAddedField);
    
    EEClass *GetClass() 
    {
        return m_pClass;
    }
};


#include "BinarySearchILMaps.h"
class EditAndContinueModule : public Module 
{
    struct DeltaPENode {    
        IMAGE_COR20_HEADER *m_pDeltaPE; 
        DeltaPENode *m_next;    
    } *m_pDeltaPEList;  

    struct OnDiskSectionInfo {  
        DWORD startRVA; 
        DWORD endRVA;   
        const BYTE *data;   
    } *m_pSections; 
    
    int m_dNumSections; 

    HRESULT ResolveOnDiskRVA(DWORD rva, LPVOID *addr);  

    static const BYTE* m_pGlobalScratchSpaceStart;
    static const BYTE* m_pGlobalScratchSpaceNext;
    static const BYTE* m_pGlobalScratchSpaceLast;
    
    LoaderHeap *m_pILCodeSpace;

    LoaderHeap *m_pRoScratchSpace;      // RO scratch space for this module
    BYTE *m_pRoScratchSpaceStart;       // start of RO scratch space
    LoaderHeap *m_pRwScratchSpace;      // RW scratch space for this module

    const BYTE *GetNextScratchSpace();   
    
    HRESULT GetDataRVA(LoaderHeap *&pScratchSpace, SIZE_T *pDataRVA);

    // Gets memory that's guaranteed to be >= GetILBase(), so that
    // you can compute (*ppMem) - GetILBase() and have the result be >= 0
    HRESULT GetRVAableMemory(SIZE_T cbMem,
                             void **ppMem);
    // Helper routine - factors between two spots                             
    HRESULT EnsureRVAableHeapExists(void);

    HRESULT CopyToScratchSpace(LoaderHeap *&pScratchSpace, const BYTE *data, DWORD dataSize);
    
    void ToggleRoProtection(DWORD dwProtection);

    CUnorderedArray<EnCEEClassData*, 5> m_ClassList;

public:
    RangeList *m_pRangeList;

    EditAndContinueModule();
    
    virtual void Destruct(); // ~EACM won't be called
    
    HRESULT ApplyEditAndContinue(const EnCEntry *pEnCEntry,
                                 const BYTE *pbDeltaPE,
                                 CBinarySearchILMap *pILM,
                                 UnorderedEnCErrorInfoArray *pEnCError,
                                 UnorderedEnCRemapArray *pEnCRemapInfo,
                                 BOOL fCheckOnly);   
                                 
    HRESULT ApplyMethodDelta(mdMethodDef token, 
                             BOOL fCheckOnly,
                             const UnorderedILMap *ilMap,
                             UnorderedEnCErrorInfoArray *pEnCError,
                             IMDInternalImport *pImport,
                             IMDInternalImport *pImportOld,
                             unsigned int *pILMethodSize,
                             UnorderedEnCRemapArray *pEnCRemapInfo,
                             BOOL fMethodBrandNew);

    HRESULT CompareMetaSigs(MetaSig *pSigA, 
                            MetaSig *pSigB,
                            UnorderedEnCErrorInfoArray *pEnCError,
                            BOOL fRecordError, //FALSE if we shouldn't add entries to pEnCError
                            mdToken token);

    HRESULT ConfirmEnCToType(IMDInternalImport *pImportOld,
                             IMDInternalImport *pImportNew,
                             mdToken token,
                             UnorderedEnCErrorInfoArray *pEnCError);

    HRESULT ApplyFieldDelta(mdFieldDef token,
                            BOOL fCheckOnly,
                            IMDInternalImportENC *pDeltaMD,
                            UnorderedEnCErrorInfoArray *pEnCError);
    
    HRESULT GetRoDataRVA(SIZE_T *pRoDataRVA);   
    
    HRESULT GetRwDataRVA(SIZE_T *pRwDataRVA);   
    
    HRESULT ResumeInUpdatedFunction(MethodDesc *pFD, 
                                    SIZE_T newILOffset,
                                    UINT mapping, SIZE_T which,
                                    void *DebuggerVersionToken,
                                    CONTEXT *pContext,
                                    BOOL fJitOnly,
                                    BOOL fShortCircuit);
    static HRESULT ClassInit();
    
    static void ClassTerm();
    
    const BYTE *ResolveVirtualFunction(OBJECTREF thisPointer, MethodDesc *pMD);
    
    MethodDesc *FindVirtualFunction(EEClass *pClass, mdToken token);
    
    const BYTE *ResolveField(OBJECTREF thisPointer, 
                             EnCFieldDesc *pFD,
                             BOOL fAllocateNew);

    EnCEEClassData *GetEnCEEClassData(EEClass *pClass, BOOL getOnly=FALSE);
};

struct EnCAddedField {
    EnCAddedField *m_pNext;
    EnCFieldDesc *m_pFieldDesc;
    BYTE m_FieldData;
    static EnCAddedField *Allocate(EnCFieldDesc *pFD);
};

struct EnCAddedStaticField {
    EnCFieldDesc *m_pFieldDesc;
    BYTE m_FieldData;
    const BYTE *GetFieldData();
    static EnCAddedStaticField *Allocate(EnCFieldDesc *pFD);
};

class EnCSyncBlockInfo {
    EnCAddedField *m_pList;
    
  public:
    EnCSyncBlockInfo() : m_pList(NULL) {}
    
    const BYTE* ResolveField(EnCFieldDesc *pFieldDesc,
                             BOOL fAllocateNew);
    void Cleanup();
};

#else // !EnC_SUPPORTED

class EditAndContinueModule : public Module {};
class EnCSyncBlockInfo;

#endif // !EnC_SUPPORTED



#endif // #ifndef EnC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\eetwain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "EETwain.h"
#include "DbgInterface.h"

#define RETURN_ADDR_OFFS        1       // in DWORDS
#define CALLEE_SAVED_REG_MAXSZ  (4*sizeof(int)) // EBX,ESI,EDI,EBP

#include "GCInfo.h"
#include "Endian.h"

/*****************************************************************************/
/*
 *   This entire file depends upon GC2_ENCODING being set to 1
 *
 *****************************************************************************/

//#include "target.h"
//#include "error.h"

#ifdef  _DEBUG
// For dumping of verbose info.
extern  bool  trFixContext          = false;
extern  bool  trFixContextForEnC    = true;  // What updates were done
extern  bool  trEnumGCRefs          = false;
extern  bool  trGetInstance         = false;
extern  bool  dspPtr                = false; // prints the live ptrs as reported
#endif


#if CHECK_APP_DOMAIN_LEAKS
#define CHECK_APP_DOMAIN    GC_CALL_CHECK_APP_DOMAIN
#else
#define CHECK_APP_DOMAIN    0
#endif

typedef unsigned  ptrArgTP;
#define MAX_PTRARG_OFS  (sizeof(ptrArgTP)*8)


inline size_t decodeUnsigned(BYTE *src, unsigned* val)
{
    size_t   size  = 1;
    BYTE     byte  = *src++;
    unsigned value = byte & 0x7f;
    while (byte & 0x80) {
        size++;
        byte    = *src++;
        value <<= 7;
        value  += byte & 0x7f;
    }
    *val = value;
    return size;
}

inline size_t decodeUDelta(BYTE *src, unsigned* value, unsigned lastValue)
{
    unsigned delta;
    size_t size = decodeUnsigned(src, &delta);
    *value = lastValue + delta;
    return size;
}

inline size_t decodeSigned(BYTE *src, int* val)
{
    size_t   size  = 1;
    BYTE     byte  = *src++;
    bool     cont  = (byte & 0x80) ? true : false;
    bool     neg   = (byte & 0x40) ? true : false;
    unsigned value = (byte & 0x3f);
    while (cont) {
        size++;
        byte = *src++;
        if ((byte & 0x80) == 0)
            cont = false;
        value <<= 7;
        value  += (byte & 0x7f);
    }
    // negation of unsigned performed via two's complement + 1
    *val = (neg) ? ((~value)+1) : value;
    return size;
}

/*****************************************************************************
 *
 *  Decodes the methodInfoPtr and returns the decoded information
 *  in the hdrInfo struct.  The EIP parameter is the PC location
 *  within the active method.
 */
static size_t   crackMethodInfoHdr(LPVOID      methodInfoPtr,
                                   unsigned    curOffset,
                                   hdrInfo   * infoPtr)
{
    BYTE * table = (BYTE *) methodInfoPtr;
#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xFEEF);
#endif

    table += decodeUnsigned(table, &infoPtr->methodSize);

    assert(curOffset >= 0);
    assert(curOffset <= infoPtr->methodSize);

    /* Decode the InfoHdr */

    InfoHdr header;
    memset(&header, 0, sizeof(InfoHdr));

    BYTE headerEncoding = *table++;

    decodeHeaderFirst(headerEncoding, &header);

    BYTE encoding = headerEncoding;

    while (encoding & 0x80)
    {
        encoding = *table++;
        decodeHeaderNext(encoding, &header);
    }

    {
        unsigned count = 0xffff;
        if (header.untrackedCnt == count)
        {
            table += decodeUnsigned(table, &count);
            header.untrackedCnt = count;
        }
    }

    {
        unsigned count = 0xffff;
        if (header.varPtrTableSize == count)
        {
            table += decodeUnsigned(table, &count);
            header.varPtrTableSize = count;
        }
    }

    /* Some sanity checks on header */

    assert( header.prologSize + 
           (size_t)(header.epilogCount*header.epilogSize) <= infoPtr->methodSize);
    assert( header.epilogCount == 1 || !header.epilogAtEnd);

    assert( header.untrackedCnt <= header.argCount+header.frameSize);

    assert(!header.ebpFrame || !header.doubleAlign  );
    assert( header.ebpFrame || !header.security     );
    assert( header.ebpFrame || !header.handlers     );
    assert( header.ebpFrame || !header.localloc     );
    assert( header.ebpFrame || !header.editNcontinue);  // @TODO : Esp frames NYI for EnC

    /* Initialize the infoPtr struct */

    infoPtr->argSize         = header.argCount * 4;
    infoPtr->ebpFrame        = header.ebpFrame;
    infoPtr->interruptible   = header.interruptible;

    infoPtr->prologSize      = header.prologSize;
    infoPtr->epilogSize      = header.epilogSize;
    infoPtr->epilogCnt       = header.epilogCount;
    infoPtr->epilogEnd       = header.epilogAtEnd;

    infoPtr->untrackedCnt    = header.untrackedCnt;
    infoPtr->varPtrTableSize = header.varPtrTableSize;

    infoPtr->doubleAlign     = header.doubleAlign;
    infoPtr->securityCheck   = header.security;
    infoPtr->handlers        = header.handlers;
    infoPtr->localloc        = header.localloc;
    infoPtr->editNcontinue   = header.editNcontinue;
    infoPtr->varargs         = header.varargs;

    /* Are we within the prolog of the method? */

    if  (curOffset < infoPtr->prologSize)
    {
        infoPtr->prologOffs = curOffset;
    }
    else
    {
        infoPtr->prologOffs = -1;
    }

    /* Assume we're not in the epilog of the method */

    infoPtr->epilogOffs = -1;

    /* Are we within an epilog of the method? */

    if  (infoPtr->epilogCnt)
    {
        unsigned epilogStart;

        if  (infoPtr->epilogCnt > 1 || !infoPtr->epilogEnd)
        {
#if VERIFY_GC_TABLES
            assert(*castto(table, unsigned short *)++ == 0xFACE);
#endif
            epilogStart = 0;
            for (unsigned i = 0; i < infoPtr->epilogCnt; i++)
            {
                table += decodeUDelta(table, &epilogStart, epilogStart);
                if  (curOffset > epilogStart &&
                     curOffset < epilogStart + infoPtr->epilogSize)
                {
                    infoPtr->epilogOffs = curOffset - epilogStart;
                }
            }
        }
        else
        {
            epilogStart = infoPtr->methodSize - infoPtr->epilogSize;

            if  (curOffset > epilogStart &&
                 curOffset < epilogStart + infoPtr->epilogSize)
            {
                infoPtr->epilogOffs = curOffset - epilogStart;
            }
        }
    }

    size_t frameSize = header.frameSize;

    /* Set the rawStackSize to the number of bytes that it bumps ESP */

    infoPtr->rawStkSize = (UINT)(frameSize * sizeof(size_t));

    /* Calculate the callee saves regMask and adjust stackSize to */
    /* include the callee saves register spills                   */

    unsigned savedRegs = RM_NONE;

    if  (header.ediSaved)
    {
        frameSize++;
        savedRegs |= RM_EDI;
    }
    if  (header.esiSaved)
    {
        frameSize++;
        savedRegs |= RM_ESI;
    }
    if  (header.ebxSaved)
    {
        frameSize++;
        savedRegs |= RM_EBX;
    }
    if  (header.ebpSaved)
    {
        frameSize++;
        savedRegs |= RM_EBP;
    }

    infoPtr->savedRegMask = (RegMask)savedRegs;

    infoPtr->stackSize  =  (UINT)(frameSize * sizeof(size_t));

    return  table - ((BYTE *) methodInfoPtr);
}

/*****************************************************************************/

const LCL_FIN_MARK = 0xFC; // FC = "Finally Call"

// We do a "pop eax; jmp eax" to return from a fault or finally handler
const END_FIN_POP_STACK = sizeof(void*);

/*****************************************************************************
 *  Returns the start of the hidden slots for the shadowSP for functions
 *  with exception handlers. There is one slot per nesting level starting
 *  near Ebp and is zero-terminated after the active slots.
 */

inline
size_t *     GetFirstBaseSPslotPtr(size_t ebp, hdrInfo * info)
{
    size_t  distFromEBP = info->securityCheck
        + info->localloc
        + 1 // Slot for end-of-last-executed-filter
        + 1; // to get to the *start* of the next slot

    return (size_t *)(ebp -  distFromEBP * sizeof(void*));
}

/*****************************************************************************
 *    returns the base ESP corresponding to the target nesting level.
 */
inline
size_t GetBaseSPForHandler(size_t ebp, hdrInfo * info)
{
        // we are not taking into account double alignment.  We are
        // safe because the jit currently bails on double alignment if there
        // are handles or localalloc
    _ASSERTE(!info->doubleAlign);
    if (info->localloc)
    {
        // If the function uses localloc we will fetch the ESP from the localloc
        // slot.
        size_t* pLocalloc=
            (size_t *)
            (ebp-
              (info->securityCheck
             + 1)
             * sizeof(void*));
                    
        return (*pLocalloc);
    }
    else
    {
        // Default, go back all the method's local stack size
        return (ebp - info->stackSize + sizeof(int));
    }       
}

/*****************************************************************************
 *
 *  For functions with handlers, checks if it is currently in a handler.
 *  Either of unwindESP or unwindLevel will specify the target nesting level.
 *  If unwindLevel is specified, info about the funclet at that nesting level
 *    will be returned. (Use if you are interested in a specific nesting level.)
 *  If unwindESP is specified, info for nesting level invoked before the stack
 *   reached unwindESP will be returned. (Use if you have a specific ESP value
 *   during stack walking.)
 *
 *  *pBaseSP is set to the base SP (base of the stack on entry to
 *    the current funclet) corresponding to the target nesting level.
 *  *pNestLevel is set to the nesting level of the target nesting level (useful
 *    if unwindESP!=IGNORE_VAL
 *  *hasInnerFilter will be set to true (only when unwindESP!=IGNORE_VAL) if a filter
 *    is currently active, but the target nesting level is an outer nesting level.
 */

enum FrameType 
{    
    FR_NORMAL,              // Normal method frame - no exceptions currently active
    FR_FILTER,              // Frame-let of a filter
    FR_HANDLER,             // Frame-let of a callable catch/fault/finally

    FR_COUNT
};

enum { IGNORE_VAL = -1 };

FrameType   GetHandlerFrameInfo(hdrInfo   * info,
                                size_t      frameEBP, 
                                size_t      unwindESP, 
                                DWORD       unwindLevel,
                                size_t    * pBaseSP = NULL,         /* OUT */
                                DWORD     * pNestLevel = NULL,      /* OUT */
                                bool      * pHasInnerFilter = NULL, /* OUT */
                                bool      * pHadInnerFilter = NULL) /* OUT */
{
    assert(info->ebpFrame && info->handlers);
    // One and only one of them should be IGNORE_VAL
    assert((unwindESP == IGNORE_VAL) != (unwindLevel == IGNORE_VAL));
    assert(pHasInnerFilter == NULL || unwindESP != IGNORE_VAL);

    size_t * pFirstBaseSPslot = GetFirstBaseSPslotPtr(frameEBP, info);
    size_t  baseSP           = GetBaseSPForHandler(frameEBP , info);
    bool    nonLocalHandlers = false; // Are the funclets invoked by EE (instead of managed code itself)
    bool    hasInnerFilter   = false;
    bool    hadInnerFilter   = false;

    /* Get the last non-zero slot >= unwindESP, or lvl<unwindLevel.
       Also do some sanity checks */

    for(size_t * pSlot = pFirstBaseSPslot, lvl = 0;
        *pSlot && lvl < unwindLevel;
        pSlot--, lvl++)
    {
        assert(!(baseSP & ICodeManager::SHADOW_SP_IN_FILTER)); // Filters cant have inner funclets

        size_t curSlotVal = *pSlot;

        // The shadowSPs have to be less unless the stack has been unwound.
        assert(baseSP >  curSlotVal ||
               baseSP == curSlotVal && pSlot == pFirstBaseSPslot);

        if (curSlotVal == LCL_FIN_MARK)
        {   
            // Locally called finally
            baseSP -= sizeof(void*);    
        }
        else
        {
            // Is this a funclet we unwound before (can only happen with filters) ?

            if (unwindESP != IGNORE_VAL && unwindESP > END_FIN_POP_STACK + (curSlotVal & ~ICodeManager::SHADOW_SP_BITS))
            {
                // Filter cant have nested handlers
                assert((pSlot[0] & ICodeManager::SHADOW_SP_IN_FILTER) && (pSlot[-1] == 0)); 
                assert(!(baseSP & ICodeManager::SHADOW_SP_IN_FILTER));

                if (pSlot[0] & ICodeManager::SHADOW_SP_FILTER_DONE)
                    hadInnerFilter = true;
                else
                    hasInnerFilter = true;
                break;
            }

            nonLocalHandlers = true;
            baseSP = curSlotVal;
        }
    }

    if (unwindESP != IGNORE_VAL)
    {
        assert(baseSP >= unwindESP || 
               baseSP == unwindESP - sizeof(void*));  // About to locally call a finally

        if (baseSP < unwindESP)                       // About to locally call a finally
            baseSP = unwindESP;
    }
    else
    {
        assert(lvl == unwindLevel); // unwindLevel must be currently active on stack
    }

    if (pBaseSP)
        *pBaseSP = baseSP & ~ICodeManager::SHADOW_SP_BITS;

    if (pNestLevel)
    {
        *pNestLevel = (DWORD)lvl;
    }
    
    if (pHasInnerFilter)
        *pHasInnerFilter = hasInnerFilter;

    if (pHadInnerFilter)
        *pHadInnerFilter = hadInnerFilter;

    if (baseSP & ICodeManager::SHADOW_SP_IN_FILTER)
    {
        assert(!hasInnerFilter); // nested filters not allowed
        return FR_FILTER;
    }
    else if (nonLocalHandlers)
    {
        return FR_HANDLER;
    }
    else
    {
        return FR_NORMAL;
    }
}

/*****************************************************************************
 *
 *  First chance for the runtime support to suppress conversion
 *  from a win32 fault to a COM+ exception. Instead it could
 *  fixup the faulting context and request the continuation
 *  of execution
 */
bool EECodeManager::FilterException ( PCONTEXT  pContext,
                                      unsigned  win32Fault,
                                      LPVOID    methodInfoPtr,
                                      LPVOID    methodStart)
{
#ifdef _X86_
    /* Why is this a signed char * ???? -- briansul */
    signed char * code     = (signed char*)(size_t)pContext->Eip;
    int           divisor  = 0;
    unsigned      instrLen = 2;

#if 0
#ifdef _DEBUG
    printf("FLT: %X code@%08X:  ", win32Fault, pContext->Eip);
    printf("code: %02X %02X %02X %02X ",
           (code[0] & 0xff), (code[1] & 0xff),
           (code[2] & 0xff), (code[3] & 0xff));
    DebugBreak();
#endif // _DEBUG
#endif // 0

    /* For now we just try to filter out 0x80000000 / -1 */
    /* NT and Memphis are reporting STATUS_INTEGER_OVERFLOW, whereas */
    /* Win95, OSR1, OSR2 are reporting STATUS_DIVIDED_BY_ZERO */

    if  (win32Fault != STATUS_INTEGER_OVERFLOW       &&
         win32Fault != STATUS_INTEGER_DIVIDE_BY_ZERO)
        return false;

    if (((*code++) & 0xff)  != 0xF7)
        return false;

    switch ((*code++) & 0xff)
    {
        /* idiv [EBP+d8]   F7 7D 'd8' */
    case 0x7D :
        divisor = *( (int *) (size_t)((*code) + pContext->Ebp));
        instrLen = 3;
        break;

        /* idiv [EBP+d32] F7 BD 'd32' */
    case 0xBD:
        divisor = *((int*)(size_t)(*((int*)code) + pContext->Ebp));

        instrLen = 6;
        break;

        /* idiv [ESP]     F7 3C 24 */
    case 0x3C:
        if (((*code++)&0xff) != 0x24)
            break;

        divisor = *( (int *)(size_t) pContext->Esp);
        instrLen = 3;
        break;

        /* idiv [ESP+d8]  F7 7C 24 'd8' */
    case 0x7C:
        if (((*code++)&0xff) != 0x24)
            break;
        divisor = *( (int *) (size_t)((*code) + pContext->Esp));
        instrLen = 4;
        break;

        /* idiv [ESP+d32]  F7 BC 24 'd32' */
    case 0xBC:
        if (((*code++)&0xff) != 0x24)
            break;
        divisor = *((int*)(size_t)(*((int*)code) + pContext->Esp));

        instrLen = 7;
        break;

        /* idiv reg        F7 F8..FF */
    case 0xF8:
        divisor = (unsigned) pContext->Eax;
        break;

    case 0xF9:
        divisor = (unsigned) pContext->Ecx;
        break;

    case 0xFA:
        divisor = (unsigned) pContext->Edx;
        break;

    case 0xFB:
        divisor = (unsigned) pContext->Ebx;
        break;

#ifdef _DEBUG
    case 0xFC: //div esp will not be issued
        assert(!"'div esp' is a silly instruction");
#endif // _DEBUG

    case 0xFD:
        divisor = (unsigned) pContext->Ebp;
        break;

    case 0xFE:
        divisor = (unsigned) pContext->Esi;
        break;

    case 0xFF:
        divisor = (unsigned) pContext->Edi;
        break;

    default:
        break;
    }

#if 0
    printf("  div: %X   len: %d\n", divisor, instrLen);
#endif // 0

    if (divisor != -1)
        return false;

    /* It's the special case, fix context (reset EDX, set EIP to next instruction) */

    pContext->Edx = 0;
    pContext->Eip += instrLen;

    return true;
#else // !_X86_
    _ASSERTE(!"@TODO - NYI: FilterException(EETwain.cpp)");
    return false;
#endif // _X86_
}

/*****************************************************************************
 *
 *  Setup context to enter an exception handler (a 'catch' block).
 *  This is the last chance for the runtime support to do fixups in
 *  the context before execution continues inside a filter, catch handler,
 *  or finally.
 */
void EECodeManager::FixContext( ContextType     ctxType,
                                EHContext      *ctx,
                                LPVOID          methodInfoPtr,
                                LPVOID          methodStart,
                                DWORD           nestingLevel,
                                OBJECTREF       thrownObject,
                                CodeManState   *pState,
                                size_t       ** ppShadowSP,
                                size_t       ** ppEndRegion)
{
    assert((ctxType == FINALLY_CONTEXT) == (thrownObject == NULL));

#ifdef _X86_

    assert(sizeof(CodeManStateBuf) <= sizeof(pState->stateBuf));
    CodeManStateBuf * stateBuf = (CodeManStateBuf*)pState->stateBuf;

    /* Extract the necessary information from the info block header */

    stateBuf->hdrInfoSize = (DWORD)crackMethodInfoHdr(methodInfoPtr,
                                       ctx->Eip - (unsigned)(size_t)methodStart,
                                       &stateBuf->hdrInfoBody);
    pState->dwIsSet = 1;

#ifdef  _DEBUG
    if (trFixContext) {
        printf("FixContext [%s][%s] for %s.%s: ",
               stateBuf->hdrInfoBody.ebpFrame?"ebp":"   ",
               stateBuf->hdrInfoBody.interruptible?"int":"   ",
               "UnknownClass","UnknownMethod");
        fflush(stdout);
    }
#endif

    /* make sure that we have an ebp stack frame */

    assert(stateBuf->hdrInfoBody.ebpFrame);
    assert(stateBuf->hdrInfoBody.handlers); // @TODO : This will alway be set. Remove it

    size_t      baseSP;
    FrameType   frameType = GetHandlerFrameInfo(
                                &stateBuf->hdrInfoBody, ctx->Ebp,
                                ctxType == FILTER_CONTEXT ? ctx->Esp : IGNORE_VAL,
                                ctxType == FILTER_CONTEXT ? IGNORE_VAL : nestingLevel,
                                &baseSP,
                                &nestingLevel);

    assert((size_t)ctx->Ebp >= baseSP && baseSP >= (size_t)ctx->Esp);

    ctx->Esp = (DWORD)baseSP;

    // EE will write Esp to **pShadowSP before jumping to handler

    size_t * pBaseSPslots = GetFirstBaseSPslotPtr(ctx->Ebp, &stateBuf->hdrInfoBody);
    *ppShadowSP = &pBaseSPslots[-(int) nestingLevel   ];
                   pBaseSPslots[-(int)(nestingLevel+1)] = 0; // Zero out the next slot

    // EE will write the end offset of the filter
    if (ctxType == FILTER_CONTEXT)
        *ppEndRegion = pBaseSPslots + 1;

    /*  This is just a simple assigment of throwObject to ctx->Eax,
        just pretend the cast goo isn't there.
     */

    *((OBJECTREF*)&(ctx->Eax)) = thrownObject;

#else // !_X86_
    _ASSERTE(!"@TODO Alpha - EECodeManager::FixContext (EETwain.cpp)");
#endif // _X86_
}

/*****************************************************************************/

bool        VarIsInReg(ICorDebugInfo::VarLoc varLoc)
{
    switch(varLoc.vlType)
    {
    case ICorDebugInfo::VLT_REG:
    case ICorDebugInfo::VLT_REG_REG:
    case ICorDebugInfo::VLT_REG_STK:
        return true;

    default:
        return false;
    }
}

/*****************************************************************************
 *  Last chance for the runtime support to do fixups in the context
 *  before execution continues inside an EnC updated function.
 *  It also adjusts ESP and munges on the stack. So the caller has to make
 *  sure that that stack region isnt needed (by doing a localloc)
 *  Also, if this returns EnC_FAIL, we should not have munged the 
 *  context ie. transcated commit
 *  The plan of attack is: 
 *  1) Error checking up front.  If we get through here, everything 
 *      else should work
 *  2) Get all the info about current variables, registers, etc
 *  3) zero out the stack frame - this'll initialize _all_ variables
 *  4) Put the variables from step 3 into their new locations.
 *
 *  Note that while we use the ShuffleVariablesGet/Set methods, they don't
 *  have any info/logic that's internal to the runtime: another codemanger
 *  could easily duplicate what they do, which is why we're calling into them.
 */

DWORD GetConfigDWORD(LPWSTR name, DWORD defValue);

ICodeManager::EnC_RESULT   EECodeManager::FixContextForEnC(
                                       void           *pMethodDescToken,
                                       PCONTEXT        pCtx,
                                       LPVOID          oldMethodInfoPtr,
                                       SIZE_T          oldMethodOffset,
                  const ICorDebugInfo::NativeVarInfo * oldMethodVars,
                                       SIZE_T          oldMethodVarsCount,
                                       LPVOID          newMethodInfoPtr,
                                       SIZE_T          newMethodOffset,
                  const ICorDebugInfo::NativeVarInfo * newMethodVars,
                                       SIZE_T          newMethodVarsCount)
{
    EnC_RESULT hr = EnC_OK;

     // Grab a copy of the context before the EnC update. 
    CONTEXT oldCtx = *pCtx;

#ifdef _X86_
    LOG((LF_CORDB, LL_INFO100, "EECM::FixContextForEnC\n"));

    /* Extract the necessary information from the info block header */

    hdrInfo  oldInfo, newInfo;

    crackMethodInfoHdr(oldMethodInfoPtr,
                       (unsigned)oldMethodOffset,
                       &oldInfo);

    crackMethodInfoHdr(newMethodInfoPtr,
                       (unsigned)newMethodOffset,
                       &newInfo);

    //1) Error checking up front.  If we get through here, everything 
    //     else should work

    if (!oldInfo.editNcontinue || !newInfo.editNcontinue) {
        LOG((LF_CORDB, LL_INFO100, "**Error** EECM::FixContextForEnC EnC_INFOLESS_METHOD\n"));
        return EnC_INFOLESS_METHOD;
    }

    if (!oldInfo.ebpFrame || !newInfo.ebpFrame) {
        LOG((LF_CORDB, LL_INFO100, "**Error** EECM::FixContextForEnC Esp frames NYI\n"));
        return EnC_FAIL; // Esp frames NYI
    }

    if (pCtx->Esp != pCtx->Ebp - oldInfo.stackSize + sizeof(DWORD)) {
        LOG((LF_CORDB, LL_INFO100, "**Error** EECM::FixContextForEnC stack should be empty\n"));
        return EnC_FAIL; // stack should be empty - @TODO : Barring localloc
    }

    if (oldInfo.handlers)
    {
        bool      hasInnerFilter;
        size_t    baseSP;
        FrameType frameType = GetHandlerFrameInfo(&oldInfo, pCtx->Ebp,
                                                  pCtx->Esp, IGNORE_VAL,
                                                  &baseSP, NULL, &hasInnerFilter);
        assert(!hasInnerFilter); // FixContextForEnC() is called for bottommost funclet

        // If the method is in a fuclet, and if the framesize grows, we are in trouble.

        if (frameType != FR_NORMAL)
        {
           /* @TODO : What if the new method offset is in a fuclet, 
              and the old is not, or the nesting level changed, etc */

            if (oldInfo.stackSize != newInfo.stackSize) {
                LOG((LF_CORDB, LL_INFO100, "**Error** EECM::FixContextForEnC stack size mismatch\n"));
                return EnC_IN_FUNCLET;
            }
        }
    }

    /* Check if we have grown out of space for locals, in the face of localloc */

    assert(!oldInfo.localloc && !newInfo.localloc); // @TODO

    /* Cant change handler nesting level in EnC. As a necessary but INsufficient
       condition, check that it is zero for both or non-zero for both.
       @TODO: Do we need to support this scenario? */

    if (oldInfo.handlers != newInfo.handlers)
    {
        LOG((LF_CORDB, LL_INFO100, "**Error** EECM::FixContextForEnC nesting level mismatch\n"));
        return EnC_NESTED_HANLDERS;
    }

    LOG((LF_CORDB, LL_INFO100, "EECM::FixContextForEnC: Checks out\n"));

    // 2) Get all the info about current variables, registers, etc

    // We'll need to sort the native var info by variable number, since the
    // order of them isn't necc. the same.  We'll use the number as the key.
 
    // 2 is for enregistered args
    unsigned oldNumVarsGuess = 2 + (oldInfo.argSize + oldInfo.rawStkSize)/sizeof(int); 
    ICorDebugInfo::NativeVarInfo *  pOldVar;

    ICorDebugInfo::NativeVarInfo *newMethodVarsSorted = NULL;
    DWORD *rgVal1 = NULL;
    DWORD *rgVal2 = NULL;

    // sorted by varNumber
    ICorDebugInfo::NativeVarInfo *oldMethodVarsSorted = 
        new  ICorDebugInfo::NativeVarInfo[oldNumVarsGuess];
    if (!oldMethodVarsSorted)
    {
        hr = EnC_FAIL;
        goto ErrExit;
    }

    SIZE_T local;

    memset((void *)oldMethodVarsSorted, 0, oldNumVarsGuess*sizeof(ICorDebugInfo::NativeVarInfo));
    
    for (local = 0; local < oldNumVarsGuess;local++)
         oldMethodVarsSorted[local].loc.vlType = ICorDebugInfo::VarLocType::VLT_INVALID;
         
    unsigned oldNumVars = 0;
    BYTE **rgVCs = NULL;

    //pOldVar isn't const, thus the typecast.
    for (pOldVar = (ICorDebugInfo::NativeVarInfo *)oldMethodVars, local = 0; 
         local < oldMethodVarsCount; 
         local++, pOldVar++)
    {
        assert(pOldVar->varNumber < oldNumVarsGuess);
        if (oldNumVars <= pOldVar->varNumber)
            oldNumVars = pOldVar->varNumber + 1;

        if (pOldVar->startOffset <= oldMethodOffset && 
            pOldVar->endOffset   >  oldMethodOffset)
        {
            memmove((void *)&(oldMethodVarsSorted[pOldVar->varNumber]), 
                    pOldVar, 
                    sizeof(ICorDebugInfo::NativeVarInfo));
        }
    }

    // Next sort the new var info by varNumber.  We want to do this here, since
    // we're allocating memory (which may fail) - do this before going to step 2
    ICorDebugInfo::NativeVarInfo * pNewVar;
    // 2 is for enregistered args
    unsigned newNumVarsGuess = 2 + (newInfo.argSize + newInfo.rawStkSize)/sizeof(int); 
    // sorted by varNumber    
    newMethodVarsSorted = new ICorDebugInfo::NativeVarInfo[newNumVarsGuess];
    if (!newMethodVarsSorted)
    {
        hr = EnC_FAIL;
        goto ErrExit;
    }
    
    memset(newMethodVarsSorted, 0, newNumVarsGuess*sizeof(ICorDebugInfo::NativeVarInfo));
    for (local = 0; local < newNumVarsGuess;local++)
         newMethodVarsSorted[local].loc.vlType = ICorDebugInfo::VarLocType::VLT_INVALID;

    unsigned newNumVars = 0;

    // Stupid const has to be casted away.
    for (pNewVar = (ICorDebugInfo::NativeVarInfo *)newMethodVars, local = 0; 
         local < newMethodVarsCount; 
         local++, pNewVar++)
    {
        assert(pNewVar->varNumber < newNumVarsGuess);
        if (newNumVars <= pNewVar->varNumber)
            newNumVars = pNewVar->varNumber + 1;

        if (pNewVar->startOffset <= newMethodOffset && 
            pNewVar->endOffset   >  newMethodOffset)
        {
            memmove(&(newMethodVarsSorted[pNewVar->varNumber]),
                    pNewVar,
                    sizeof(ICorDebugInfo::NativeVarInfo));
        }
    }

    _ASSERTE(newNumVars >= oldNumVars ||
             !"Not allowed to reduce the number of locals between versions!");

    LOG((LF_CORDB, LL_INFO100, "EECM::FixContextForEnC: gathered info!\n"));

    rgVal1 = new DWORD[newNumVars];
    if (rgVal1 == NULL)
    {
        hr = EnC_FAIL;
        goto ErrExit;
    }

    rgVal2 = new DWORD[newNumVars];
    if (rgVal2 == NULL)
    {
        hr = EnC_FAIL;
        goto ErrExit;
    }

    // Next we'll zero them out, so any variables that aren't in scope
    // in the old method, but are in scope in the new, will have the 
    // default, zero, value.
    memset(rgVal1, 0, sizeof(DWORD)*newNumVars);
    memset(rgVal2, 0, sizeof(DWORD)*newNumVars);

    if(FAILED(g_pDebugInterface->GetVariablesFromOffset((MethodDesc*)pMethodDescToken,
                           oldNumVars, 
                           oldMethodVarsSorted,
                           oldMethodOffset, 
                           &oldCtx,
                           rgVal1,
                           rgVal2,
                           &rgVCs)))
    {
        hr = EnC_FAIL;
        goto ErrExit;
    }


    LOG((LF_CORDB, LL_INFO100, "EECM::FixContextForEnC: got mem!\n"));
    
    /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
     *  IMPORTANT : Once we start munging on the context, we cannot return
     *  EnC_FAIL, as this should be a transacted commit,
     *
     *  2) Get all the info about current variables, registers, etc.
     *
     **=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/

    // Zero out all  the registers as some may hold new variables.
    pCtx->Eax = pCtx->Ecx = pCtx->Edx = pCtx->Ebx = 
    pCtx->Esi = pCtx->Edi = 0;

    /*-------------------------------------------------------------------------
     * Update the caller's registers. These may be spilled as callee-saved
     * registers, or may just be sitting unmodified
     */

    // Get the values of the old caller registers

    unsigned oldCallerEdi, oldCallerEsi, oldCallerEbx;

    DWORD * pOldSavedRegs = (DWORD *)(size_t)(pCtx->Ebp - oldInfo.rawStkSize);
    pOldSavedRegs--; // get to the first one

    #define GET_OLD_CALLER_REG(reg, mask)       \
        if (oldInfo.savedRegMask & mask)        \
            oldCaller##reg = *pOldSavedRegs--;  \
        else                                    \
            oldCaller##reg = oldCtx.##reg;

    GET_OLD_CALLER_REG(Edi, RM_EDI);
    GET_OLD_CALLER_REG(Esi, RM_ESI);
    GET_OLD_CALLER_REG(Ebx, RM_EBX);
    
    LOG((LF_CORDB, LL_INFO100, "EECM::FixContextForEnC: got vars!\n"));

    // 3) zero out the stack frame - this'll initialize _all_ variables

    /*-------------------------------------------------------------------------
     * Adjust the stack height 
     */

    pCtx->Esp -= (newInfo.stackSize - oldInfo.stackSize);

    // Zero-init the new locals, if any

    if (oldInfo.rawStkSize < newInfo.rawStkSize)
    {
        DWORD newCalleeSaved = newInfo.stackSize - newInfo.rawStkSize;
        newCalleeSaved -= sizeof(DWORD); // excluding EBP
        memset((void*)(size_t)(pCtx->Esp + newCalleeSaved), 0, newInfo.rawStkSize - oldInfo.rawStkSize);
    }

    // 4) Put the variables from step 3 into their new locations.

    // Now update the new caller registers

    DWORD * pNewSavedRegs = (DWORD *)(size_t)(pCtx->Ebp - newInfo.rawStkSize);
    pNewSavedRegs--; // get to the first one

    #define SET_NEW_CALLER_REG(reg, mask)       \
        if (newInfo.savedRegMask & mask)        \
            *pNewSavedRegs-- = oldCaller##reg;  \
        else                                    \
            pCtx->##reg = oldCaller##reg;

    SET_NEW_CALLER_REG(Edi, RM_EDI);
    SET_NEW_CALLER_REG(Esi, RM_ESI);
    SET_NEW_CALLER_REG(Ebx, RM_EBX);

    LOG((LF_CORDB, LL_INFO100, "EECM::FixContextForEnC: set vars!\n"));

    // We want to move the old variables into their new places,
    // and simultaneously zero out new variables.
    g_pDebugInterface->SetVariablesAtOffset((MethodDesc*)pMethodDescToken,
                         newNumVars,
                         newMethodVarsSorted,
                         newMethodOffset, 
                         pCtx, // place them into the new context
                         rgVal1,
                         rgVal2,
                         rgVCs);
                         
    /*-----------------------------------------------------------------------*/

#else // !_X86_
    _ASSERTE(!"@TODO Alpha - EECodeManager::FixContextForEnC (EETwain.cpp)");
#endif // _X86_
    hr = EnC_OK;

ErrExit:
    if (oldMethodVarsSorted)
        delete oldMethodVarsSorted;
    if (newMethodVarsSorted)
        delete newMethodVarsSorted;
    if (rgVal1 != NULL)
        delete rgVal1;
    if (rgVal2 != NULL)
        delete rgVal2;

    LOG((LF_CORDB, LL_INFO100, "EECM::FixContextForEnC: exiting!\n"));
        
    return hr;
}

/*****************************************************************************
 *
 *  Is the function currently at a "GC safe point" ?
 */
bool EECodeManager::IsGcSafe( PREGDISPLAY     pContext,
                              LPVOID          methodInfoPtr,
                              ICodeInfo      *pCodeInfo,
                              unsigned        flags)
{
    hdrInfo         info;
    BYTE    *       table;

    // Address where the method has been interrupted
    DWORD    *       breakPC = (DWORD *) *(pContext->pPC);

    LPVOID methodStart = pCodeInfo->getStartAddress();

    /* Extract the necessary information from the info block header */

    table = (BYTE *)crackMethodInfoHdr(methodInfoPtr,
                                       (DWORD)(size_t)breakPC - (size_t)methodStart,
                                       &info);

    /* HACK: prevent interruption within prolog/epilog */

    if  (info.prologOffs != -1 || info.epilogOffs != -1)
        return false;

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBEEF);
#endif

    if  (!info.interruptible)
        return false;


#if GC_WRITE_BARRIER_CALL

    if  (JITGcBarrierCall)
    {
        assert(JITGcBarrierCall != -1);

        /* Check if we are about to call the write-barrier helper */

        /* If we are too close to the end of the method, it can't be the call */

#define CALLIMDLEN      5

        unsigned    off = (unsigned) breakPC - (unsigned) methodStart;

        if  (off + CALLIMDLEN >= info.methodSize)
            return true;

        // The code at "breakPC". May point into actual code or to _breakCodeCopy
        BYTE    *       breakCode;
        // If the code has been modified, we get the orig bytes into this buf
        BYTE            _breakCodeCopy[CALLIMDLEN];

        if (flags & IGSF_CODE_MODIFIED)
        {
            // During debugging, the code may be modified and
            // we need to get the original as we look at the instructions

            assert(vmSdk3_0);

            JITgetOriginalMethodBytes(methodStart, off, CALLIMDLEN, _breakCodeCopy);
            breakCode = _breakCodeCopy;
        }
        else
        {
            breakCode = (BYTE *)breakPC;
        }

        /* If it's not a call instruction, method is interruptible */

        if  (*breakCode != 0xE8)
            return true;

        /* Get the call target, it's relative to the call instruction */

        unsigned callTarget =   (* (unsigned *) &breakCode[1])
                              - ((unsigned)breakPC)
                              + CALLIMDLEN;

        /* Is target outside the range of write barrier helpers ?*/

        if  (callTarget < jitGcEntryMin && callTarget > jitGcEntryMax)
            return true;

        /* Now try to match the target with one of the write barrier helpers */

        for (int i=0; i < jitGcEntryLen; i++)
            if  (callTarget == jitGcEntries[i])
                return false;

    }
#endif
    return true;
}


/*****************************************************************************/

static
BYTE *   skipToArgReg(const hdrInfo& info, BYTE * table)
{
    unsigned count;

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBEEF);
#endif

    /* Skip over the untracked frame variable table */

    count = info.untrackedCnt;
    while (count-- > 0) {
        int  stkOffs;
        table += decodeSigned(table, &stkOffs);
    }

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xCAFE);
#endif

    /* Skip over the frame variable lifetime table */

    count = info.varPtrTableSize;
    unsigned curOffs = 0;
    while (count-- > 0) {
        unsigned varOfs;
        unsigned begOfs;
        unsigned endOfs;
        table += decodeUnsigned(table, &varOfs);
        table += decodeUDelta(table, &begOfs, curOffs);
        table += decodeUDelta(table, &endOfs, begOfs);
        assert(!info.ebpFrame || (varOfs!=0));
        curOffs = begOfs;
    }

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *) == 0xBABE);
#endif

    return table;
}

/*****************************************************************************/

#define regNumToMask(regNum) RegMask(1<<regNum)

/*****************************************************************************
 Helper for scanArgRegTable() and scanArgRegTableI() for regMasks
 */

void *      getCalleeSavedReg(PREGDISPLAY pContext, regNum reg)
{
#ifndef _X86_
    assert(!"NYI");
    return NULL;
#else
    switch (reg)
    {
        case REGI_EBP: return pContext->pEbp;
        case REGI_EBX: return pContext->pEbx;
        case REGI_ESI: return pContext->pEsi;
        case REGI_EDI: return pContext->pEdi;

        default: _ASSERTE(!"bad info.thisPtrResult"); return NULL;
    }
#endif
}

inline
RegMask     convertCalleeSavedRegsMask(unsigned inMask) // EBP,EBX,ESI,EDI
{
    assert((inMask & 0x0F) == inMask);

    unsigned outMask = RM_NONE;
    if (inMask & 0x1) outMask |= RM_EDI;
    if (inMask & 0x2) outMask |= RM_ESI;
    if (inMask & 0x4) outMask |= RM_EBX;
    if (inMask & 0x8) outMask |= RM_EBP;

    return (RegMask) outMask;
}

inline
RegMask     convertAllRegsMask(unsigned inMask) // EAX,ECX,EDX,EBX, EBP,ESI,EDI
{
    assert((inMask & 0xEF) == inMask);

    unsigned outMask = RM_NONE;
    if (inMask & 0x01) outMask |= RM_EAX;
    if (inMask & 0x02) outMask |= RM_ECX;
    if (inMask & 0x04) outMask |= RM_EDX;
    if (inMask & 0x08) outMask |= RM_EBX;
    if (inMask & 0x20) outMask |= RM_EBP;
    if (inMask & 0x40) outMask |= RM_ESI;
    if (inMask & 0x80) outMask |= RM_EDI;

    return (RegMask)outMask;
}

/*****************************************************************************
 * scan the register argument table for the not fully interruptible case.
   this function is called to find all live objects (pushed arguments)
   and to get the stack base for EBP-less methods.

   NOTE: If info->argTabResult is NULL, info->argHnumResult indicates 
         how many bits in argMask are valid
         If info->argTabResult is non-NULL, then the argMask field does 
         not fit in 32-bits and the value in argMask meaningless. 
         Instead argHnum specifies the number of (variable-lenght) elements
         in the array, and argTabBytes specifies the total byte size of the
         array. [ Note this is an extremely rare case ]
 */

static
unsigned scanArgRegTable(BYTE       * table,
                         unsigned     curOffs,
                         hdrInfo    * info)
{
    regNum thisPtrReg       = REGI_NA;
    unsigned  regMask       = 0;    // EBP,EBX,ESI,EDI
    unsigned  argMask       = 0;
    unsigned  argHnum       = 0;
    BYTE    * argTab        = 0;
    unsigned  argTabBytes   = 0;
    unsigned  stackDepth    = 0;
                            
    unsigned  iregMask      = 0;    // EBP,EBX,ESI,EDI
    unsigned  iargMask      = 0;
    unsigned  iptrMask      = 0;

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBABE);
#endif

    unsigned scanOffs = 0;

    assert(scanOffs <= info->methodSize);

    if (info->ebpFrame) {
  /*
      Encoding table for methods with an EBP frame and
                         that are not fully interruptible

      The encoding used is as follows:

      this pointer encodings:

         01000000          this pointer in EBX
         00100000          this pointer in ESI
         00010000          this pointer in EDI

      tiny encoding:

         0bsdDDDD
                           requires code delta     < 16 (4-bits)
                           requires pushed argmask == 0

           where    DDDD   is code delta
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer

      small encoding:

         1DDDDDDD bsdAAAAA

                           requires code delta     < 120 (7-bits)
                           requires pushed argmask <  64 (5-bits)

           where DDDDDDD   is code delta
                   AAAAA   is the pushed args mask
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer

      medium encoding

         0xFD aaaaaaaa AAAAdddd bseDDDDD

                           requires code delta     <    0x1000000000  (9-bits)
                           requires pushed argmask < 0x1000000000000 (12-bits)

           where    DDDDD  is the upper 5-bits of the code delta
                     dddd  is the low   4-bits of the code delta
                     AAAA  is the upper 4-bits of the pushed arg mask
                 aaaaaaaa  is the low   8-bits of the pushed arg mask
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        e  indicates that register EDI is a live pointer

      medium encoding with interior pointers

         0xF9 DDDDDDDD bsdAAAAAA iiiIIIII

                           requires code delta     < (8-bits)
                           requires pushed argmask < (5-bits)

           where  DDDDDDD  is the code delta
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                    AAAAA  is the pushed arg mask
                      iii  indicates that EBX,EDI,ESI are interior pointers
                    IIIII  indicates that bits is the arg mask are interior
                           pointers

      large encoding

         0xFE [0BSD0bsd][32-bit code delta][32-bit argMask]

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                        B  indicates that register EBX is an interior pointer
                        S  indicates that register ESI is an interior pointer
                        D  indicates that register EDI is an interior pointer
                           requires pushed  argmask < 32-bits

      large encoding  with interior pointers

         0xFA [0BSD0bsd][32-bit code delta][32-bit argMask][32-bit interior pointer mask]  
                               

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                        B  indicates that register EBX is an interior pointer
                        S  indicates that register ESI is an interior pointer
                        D  indicates that register EDI is an interior pointer
                           requires pushed  argmask < 32-bits
                           requires pushed iArgmask < 32-bits

      huge encoding        This is the only encoding that supports
                           a pushed argmask which is greater than
                           32-bits.

         0xFB [0BSD0bsd][32-bit code delta]
              [32-bit table count][32-bit table size]
              [pushed ptr offsets table...]

                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer
                       B   indicates that register EBX is an interior pointer
                       S   indicates that register ESI is an interior pointer
                       D   indicates that register EDI is an interior pointer
                       the list count is the number of entries in the list
                       the list size gives the byte-lenght of the list
                       the offsets in the list are variable-length
  */
        while (scanOffs < curOffs)
        {
            iregMask =
            iargMask = 0;
            argTab = NULL;

            /* Get the next byte and check for a 'special' entry */

            unsigned encType = *table++;

            switch (encType)
            {
                unsigned    val, nxt;

            default:

                /* A tiny or small call entry */
                val = encType;
                if ((val & 0x80) == 0x00) {
                    if (val & 0x0F) {
                        /* A tiny call entry */
                        scanOffs += (val & 0x0F);
                        regMask   = (val & 0x70) >> 4;
                        argMask   = 0;
                        argHnum   = 0;
                    }
                    else {
                        /* This pointer liveness encoding */
                        regMask   = (val & 0x70) >> 4;
                        if (regMask == 0x1)
                            thisPtrReg = REGI_EDI;
                        else if (regMask == 0x2)
                            thisPtrReg = REGI_ESI;
                        else if (regMask == 0x4)
                            thisPtrReg = REGI_EBX;
                        else
                           _ASSERTE(!"illegal encoding for 'this' pointer liveness");
                    }
                }
                else {
                    /* A small call entry */
                    scanOffs += (val & 0x7F);
                    val       = *table++;
                    regMask   = val >> 5;
                    argMask   = val & 0x1F;
                    argHnum   = 5;
                }
                break;

            case 0xFD:  // medium encoding

                argMask   = *table++;
                val       = *table++;
                argMask  |= (val & 0xF0) << 4;
                argHnum   = 12;
                nxt       = *table++;
                scanOffs += (val & 0x0F) + ((nxt & 0x1F) << 4);
                regMask   = nxt >> 5;                   // EBX,ESI,EDI

                break;

            case 0xF9:  // medium encoding with interior pointers

                scanOffs   += *table++;
                val         = *table++;
                argMask     = val & 0x1F;
                argHnum     = 5;
                regMask     = val >> 5;
                val         = *table++;
                iargMask    = val & 0x1F;
                iregMask    = val >> 5;

                break;

            case 0xFE:  // large encoding
            case 0xFA:  // large encoding with interior pointers

                val         = *table++;
                regMask     = val & 0x7;
                iregMask    = val >> 4;
                scanOffs   += readDWordSmallEndian(table);  table += sizeof(DWORD);
                argMask     = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argHnum     = 31;
                if (encType == 0xFA) // read iargMask
                {
                    iargMask = readDWordSmallEndian(table); table += sizeof(DWORD);
                }
                break;

            case 0xFB:  // huge encoding

                val         = *table++;
                regMask     = val & 0x7;
                iregMask    = val >> 4;
                scanOffs   += readDWordSmallEndian(table); table += sizeof(DWORD);
                argHnum     = readDWordSmallEndian(table); table += sizeof(DWORD);
                argTabBytes = readDWordSmallEndian(table); table += sizeof(DWORD);
                argTab      = table;                       table += argTabBytes;

                argMask     = 0xdeadbeef;
                break;

            case 0xFF:
                scanOffs = curOffs + 1;
                break;

            } // end case

            // iregMask & iargMask are subsets of regMask & argMask respectively

            assert((iregMask & regMask) == iregMask);
            assert((iargMask & argMask) == iargMask);

        } // end while

    }
    else {

/*
 *    Encoding table for methods without an EBP frame and are not fully interruptible
 *
 *               The encoding used is as follows:
 *
 *  push     000DDDDD                     ESP push one item with 5-bit delta
 *  push     00100000 [pushCount]         ESP push multiple items
 *  reserved 0011xxxx
 *  skip     01000000 [Delta]             Skip Delta, arbitrary sized delta
 *  skip     0100DDDD                     Skip small Delta, for call (DDDD != 0)
 *  pop      01CCDDDD                     ESP pop  CC items with 4-bit delta (CC != 00)
 *  call     1PPPPPPP                     Call Pattern, P=[0..79]
 *  call     1101pbsd DDCCCMMM            Call RegMask=pbsd,ArgCnt=CCC,
 *                                        ArgMask=MMM Delta=commonDelta[DD]
 *  call     1110pbsd [ArgCnt] [ArgMask]  Call ArgCnt,RegMask=pbsd,ArgMask
 *  call     11111000 [PBSDpbsd][32-bit delta][32-bit ArgCnt]
 *                    [32-bit PndCnt][32-bit PndSize][PndOffs...]
 *  iptr     11110000 [IPtrMask]          Arbitrary Interior Pointer Mask
 *  thisptr  111101RR                     This pointer is in Register RR
 *                                        00=EDI,01=ESI,10=EBX,11=EBP
 *  reserved 111100xx                     xx  != 00
 *  reserved 111110xx                     xx  != 00
 *  reserved 11111xxx                     xxx != 000 && xxx != 111(EOT)
 *
 *   The value 11111111 [0xFF] indicates the end of the table.
 *
 *  An offset (at which stack-walking is performed) without an explicit encoding
 *  is assumed to be a trivial call-site (no GC registers, stack empty before and 
 *  after) to avoid having to encode all trivial calls.
 *
 * Note on the encoding used for interior pointers
 *
 *   The iptr encoding must immediately preceed a call encoding.  It is used to
 *   transform a normal GC pointer addresses into an interior pointers for GC purposes.
 *   The mask supplied to the iptr encoding is read from the least signicant bit
 *   to the most signicant bit. (i.e the lowest bit is read first)
 *
 *   p   indicates that register EBP is a live pointer
 *   b   indicates that register EBX is a live pointer
 *   s   indicates that register ESI is a live pointer
 *   d   indicates that register EDI is a live pointer
 *   P   indicates that register EBP is an interior pointer
 *   B   indicates that register EBX is an interior pointer
 *   S   indicates that register ESI is an interior pointer
 *   D   indicates that register EDI is an interior pointer
 *
 *   As an example the following sequence indicates that EDI.ESI and the 2nd pushed pointer
 *   in ArgMask are really interior pointers.  The pointer in ESI in a normal pointer:
 *
 *   iptr 11110000 00010011           => read Interior Ptr, Interior Ptr, Normal Ptr, Normal Ptr, Interior Ptr
 *   call 11010011 DDCCC011 RRRR=1011 => read EDI is a GC-pointer, ESI is a GC-pointer. EBP is a GC-pointer
 *                           MMM=0011 => read two GC-pointers arguments on the stack (nested call)
 *
 *   Since the call instruction mentions 5 GC-pointers we list them in the required order:
 *   EDI, ESI, EBP, 1st-pushed pointer, 2nd-pushed pointer
 *
 *   And we apply the Interior Pointer mask mmmm=10011 to the above five ordered GC-pointers
 *   we learn that EDI and ESI are interior GC-pointers and that the second push arg is an
 *   interior GC-pointer.
 */

        while (scanOffs <= curOffs)
        {
            unsigned callArgCnt;
            unsigned skip;
            unsigned newRegMask, inewRegMask;
            unsigned newArgMask, inewArgMask;
            unsigned oldScanOffs = scanOffs;

            if (iptrMask)
            {
                // We found this iptrMask in the previous iteration.
                // This iteration must be for a call. Set these variables
                // so that they are available at the end of the loop

                inewRegMask = iptrMask & 0x0F; // EBP,EBX,ESI,EDI
                inewArgMask = iptrMask >> 4;

                iptrMask    = 0;
            }
            else
            {
                // Zero out any stale values.

                inewRegMask =
                inewArgMask = 0;
            }

            /* Get the next byte and decode it */

            unsigned val = *table++;

            /* Check pushes, pops, and skips */

            if  (!(val & 0x80)) {

                //  iptrMask can immediately precede only calls

                assert(!inewRegMask & !inewArgMask);

                if (!(val & 0x40)) {

                    unsigned pushCount;

                    if (!(val & 0x20))
                    {
                        //
                        // push    000DDDDD                 ESP push one item, 5-bit delta
                        //
                        pushCount   = 1;
                        scanOffs   += val & 0x1f;
                    }
                    else
                    {
                        //
                        // push    00100000 [pushCount]     ESP push multiple items
                        //
                        assert(val == 0x20);
                        table    += decodeUnsigned(table, &pushCount);
                    }

                    if (scanOffs > curOffs)
                    {
                        scanOffs = oldScanOffs;
                        goto FINISHED;
                    }

                    stackDepth +=  pushCount;
                }
                else if ((val & 0x3f) != 0) {
                    //
                    //  pop     01CCDDDD         pop CC items, 4-bit delta
                    //
                    scanOffs   +=  val & 0x0f;
                    if (scanOffs > curOffs)
                    {
                        scanOffs = oldScanOffs;
                        goto FINISHED;
                    }
                    stackDepth -= (val & 0x30) >> 4;

                } else if (scanOffs < curOffs) {
                    //
                    // skip    01000000 [Delta]  Skip arbitrary sized delta
                    //
                    table    += decodeUnsigned(table, &skip);
                    scanOffs += skip;
                }
                else // don't process a skip if we are already at curOffs
                    goto FINISHED;

                /* reset regs and args state since we advance past last call site */

                 regMask    =
                iregMask    = 0;
                 argMask    =
                iargMask    = 0;
                argHnum     = 0;

            }
            else /* It must be a call, thisptr, or iptr */
            {
                switch ((val & 0x70) >> 4) {
                default:    // case 0-4, 1000xxxx through 1100xxxx
                    //
                    // call    1PPPPPPP          Call Pattern, P=[0..79]
                    //
                    decodeCallPattern((val & 0x7f), &callArgCnt,
                                      &newRegMask, &newArgMask, &skip);
                    // If we've already reached curOffs and the skip amount
                    // is non-zero then we are done
                    if ((scanOffs == curOffs) && (skip > 0))
                        goto FINISHED;
                    // otherwise process this call pattern
                    scanOffs   += skip;
                    if (scanOffs > curOffs)
                        goto FINISHED;
                     regMask    = newRegMask;
                     argMask    = newArgMask;   argTab = NULL;
                    iregMask    = inewRegMask;
                    iargMask    = inewArgMask;
                    stackDepth -= callArgCnt;
                    argHnum     = 2;             // argMask is known to be <= 3
                    break;

                  case 5:
                    //
                    // call    1101RRRR DDCCCMMM  Call RegMask=RRRR,ArgCnt=CCC,
                    //                        ArgMask=MMM Delta=commonDelta[DD]
                    //
                    newRegMask  = val & 0xf;    // EBP,EBX,ESI,EDI
                    val         = *table++;     // read next byte
                    skip        = callCommonDelta[val>>6];
                    // If we've already reached curOffs and the skip amount
                    // is non-zero then we are done
                    if ((scanOffs == curOffs) && (skip > 0))
                        goto FINISHED;
                    // otherwise process this call encoding
                    scanOffs   += skip;
                    if (scanOffs > curOffs)
                        goto FINISHED;
                     regMask    = newRegMask;
                    iregMask    = inewRegMask;
                    callArgCnt  = (val >> 3) & 0x7;
                    stackDepth -= callArgCnt;
                     argMask    = (val & 0x7);  argTab = NULL;
                    iargMask    = inewArgMask;
                    argHnum     = 3;
                    break;

                  case 6:
                    //
                    // call    1110RRRR [ArgCnt] [ArgMask]
                    //                          Call ArgCnt,RegMask=RRR,ArgMask
                    //
                     regMask    = val & 0xf;    // EBP,EBX,ESI,EDI
                    iregMask    = inewRegMask;
                    table      += decodeUnsigned(table, &callArgCnt);
                    stackDepth -= callArgCnt;
                    table      += decodeUnsigned(table, &argMask);  argTab = NULL;
                    iargMask    = inewArgMask;
                    argHnum     = 31;
                    break;

                  case 7:
                    switch (val & 0x0C) 
                    {
                      case 0x00:
                        //
                        //  iptr 11110000 [IPtrMask] Arbitrary Interior Pointer Mask
                        //
                        table      += decodeUnsigned(table, &iptrMask);
                        break;

                      case 0x04:
                        {
                          static const regNum calleeSavedRegs[] = 
                                    { REGI_EDI, REGI_ESI, REGI_EBX, REGI_EBP };
                          thisPtrReg = calleeSavedRegs[val&0x3];
                        }
                        break;

                      case 0x08:
                        val         = *table++;
                        skip        = readDWordSmallEndian(table); table += sizeof(DWORD);
                        scanOffs   += skip;
                        if (scanOffs > curOffs)
                            goto FINISHED;
                        regMask     = val & 0xF;
                        iregMask    = val >> 4;
                        callArgCnt  = readDWordSmallEndian(table); table += sizeof(DWORD);
                        stackDepth -= callArgCnt;
                        argHnum     = readDWordSmallEndian(table); table += sizeof(DWORD);
                        argTabBytes = readDWordSmallEndian(table); table += sizeof(DWORD);
                        argTab      = table;
                        table      += argTabBytes;
                        break;

                      case 0x0C:
                        assert(val==0xff);
                        goto FINISHED;

                      default:
                        assert(!"reserved GC encoding");
                        break;
                    }
                    break;

                } // end switch

            } // end else (!(val & 0x80))

            // iregMask & iargMask are subsets of regMask & argMask respectively

            assert((iregMask & regMask) == iregMask);
            assert((iargMask & argMask) == iargMask);

        } // end while

    } // end else ebp-less frame

FINISHED:

    // iregMask & iargMask are subsets of regMask & argMask respectively

    assert((iregMask & regMask) == iregMask);
    assert((iargMask & argMask) == iargMask);

    info->thisPtrResult  = thisPtrReg;

    if (scanOffs != curOffs)
    {
        /* must have been a boring call */
        info->regMaskResult  = RM_NONE;
        info->argMaskResult  = 0;
        info->iregMaskResult = RM_NONE;
        info->iargMaskResult = 0;
        info->argHnumResult  = 0;
        info->argTabResult   = NULL;
        info->argTabBytes    = 0;
    }
    else
    {
        info->regMaskResult     = convertCalleeSavedRegsMask(regMask);
        info->argMaskResult     = argMask;
        info->argHnumResult     = argHnum;
        info->iregMaskResult    = convertCalleeSavedRegsMask(iregMask);
        info->iargMaskResult    = iargMask;
        info->argTabResult      = argTab;
        info->argTabBytes       = argTabBytes;
        if ((stackDepth != 0) || (argMask != 0))
        {
            argMask = argMask;
        }
    }
    return (stackDepth * sizeof(unsigned));
}


/*****************************************************************************
 * scan the register argument table for the fully interruptible case.
   this function is called to find all live objects (pushed arguments)
   and to get the stack base for fully interruptible methods.
   Returns size of things pushed on the stack for ESP frames
 */

static
unsigned scanArgRegTableI(BYTE      *  table,
                          unsigned     curOffs,
                          hdrInfo   *  info)
{
    regNum thisPtrReg = REGI_NA;
    unsigned  ptrRegs    = 0;
    unsigned iptrRegs    = 0;
    unsigned  ptrOffs    = 0;
    unsigned  argCnt     = 0;

    ptrArgTP  ptrArgs    = 0;
    ptrArgTP iptrArgs    = 0;
    ptrArgTP  argHigh    = 0;

    bool      isThis     = false;
    bool      iptr       = false;

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBABE);
#endif

  /*
      Encoding table for methods that are fully interruptible

      The encoding used is as follows:

          ptr reg dead        00RRRDDD    [RRR != 100]
          ptr reg live        01RRRDDD    [RRR != 100]

      non-ptr arg push        10110DDD                    [SSS == 110]
          ptr arg push        10SSSDDD                    [SSS != 110] && [SSS != 111]
          ptr arg pop         11CCCDDD    [CCC != 000] && [CCC != 110] && [CCC != 111]
      little delta skip       11000DDD    [CCC == 000]
      bigger delta skip       11110BBB                    [CCC == 110]

      The values used in the encodings are as follows:

        DDD                 code offset delta from previous entry (0-7)
        BBB                 bigger delta 000=8,001=16,010=24,...,111=64
        RRR                 register number (EAX=000,ECX=001,EDX=010,EBX=011,
                              EBP=101,ESI=110,EDI=111), ESP=100 is reserved
        SSS                 argument offset from base of stack. This is 
                              redundant for frameless methods as we can
                              infer it from the previous pushes+pops. However,
                              for EBP-methods, we only report GC pushes, and
                              so we need SSS
        CCC                 argument count being popped (includes only ptrs for EBP methods)

      The following are the 'large' versions:

        large delta skip        10111000 [0xB8] , encodeUnsigned(delta)

        large     ptr arg push  11111000 [0xF8] , encodeUnsigned(pushCount)
        large non-ptr arg push  11111001 [0xF9] , encodeUnsigned(pushCount)
        large     ptr arg pop   11111100 [0xFC] , encodeUnsigned(popCount)
        large         arg dead  11111101 [0xFD] , encodeUnsigned(popCount) for caller-pop args.
                                                    Any GC args go dead after the call, 
                                                    but are still sitting on the stack

        this pointer prefix     10111100 [0xBC]   the next encoding is a ptr live
                                                    or a ptr arg push
                                                    and contains the this pointer

        interior or by-ref      10111111 [0xBF]   the next encoding is a ptr live
             pointer prefix                         or a ptr arg push
                                                    and contains an interior
                                                    or by-ref pointer


        The value 11111111 [0xFF] indicates the end of the table.
  */

    /* Have we reached the instruction we're looking for? */

    while (ptrOffs <= curOffs)
    {
        unsigned    val;

        int         isPop;
        unsigned    argOfs;

        unsigned    regMask;

        // iptrRegs & iptrArgs are subsets of ptrRegs & ptrArgs respectively

        assert((iptrRegs & ptrRegs) == iptrRegs);
        assert((iptrArgs & ptrArgs) == iptrArgs);

        /* Now find the next 'life' transition */

        val = *table++;

        if  (!(val & 0x80))
        {
            /* A small 'regPtr' encoding */

            regNum       reg;

            ptrOffs += (val     ) & 0x7;
            if (ptrOffs > curOffs) {
                iptr = isThis = false;
                goto REPORT_REFS;
            }

            reg     = (regNum)((val >> 3) & 0x7);
            regMask = 1 << reg;         // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI

#if 0
            printf("regMask = %04X -> %04X\n", ptrRegs,
                       (val & 0x40) ? (ptrRegs |  regMask)
                                    : (ptrRegs & ~regMask));
#endif

            /* The register is becoming live/dead here */

            if  (val & 0x40)
            {
                /* Becomes Live */
                assert((ptrRegs  &  regMask) == 0);

                ptrRegs |=  regMask;

                if  (isThis)
                {
                    thisPtrReg = reg;
                }
                if  (iptr)
                {
                    iptrRegs |= regMask;
                }
            }
            else
            {
                /* Becomes Dead */
                assert((ptrRegs  &  regMask) != 0);

                ptrRegs &= ~regMask;

                if  (reg == thisPtrReg)
                {
                    thisPtrReg = REGI_NA;
                }
                if  (iptrRegs & regMask)
                {
                    iptrRegs &= ~regMask;
                }
            }
            iptr = isThis = false;
            continue;
        }

        /* This is probably an argument push/pop */

        argOfs = (val & 0x38) >> 3;

        /* 6 [110] and 7 [111] are reserved for other encodings */
        if  (argOfs < 6)
        {
            ptrArgTP    argMask;

            /* A small argument encoding */

            ptrOffs += (val & 0x07);
            if (ptrOffs > curOffs) {
                iptr = isThis = false;
                goto REPORT_REFS;
            }
            isPop    = (val & 0x40);

        ARG:

            if  (isPop)
            {
                if (argOfs == 0)
                    continue;           // little skip encoding

                /* We remove (pop) the top 'argOfs' entries */

                assert(argOfs || argOfs <= argCnt);

                /* adjust # of arguments */

                argCnt -= argOfs;
                assert(argCnt < MAX_PTRARG_OFS);

//              printf("[%04X] popping %u args: mask = %04X\n", ptrOffs, argOfs, (int)ptrArgs);

                do
                {
                    assert(argHigh);

                    /* Do we have an argument bit that's on? */

                    if  (ptrArgs & argHigh)
                    {
                        /* Turn off the bit */

                        ptrArgs &= ~argHigh;
                       iptrArgs &= ~argHigh;

                        /* We've removed one more argument bit */

                        argOfs--;
                    }
                    else if (info->ebpFrame)
                        argCnt--;
                    else /* !ebpFrame && not a ref */
                        argOfs--;

                    /* Continue with the next lower bit */

                    argHigh >>= 1;
                }
                while (argOfs);

                assert (info->ebpFrame != 0         ||
                        argHigh == 0                ||
                        (argHigh == (ptrArgTP)(1 << (argCnt-1))));

                if (info->ebpFrame)
                {
                    while (!(argHigh&ptrArgs) && (argHigh != 0))
                        argHigh >>= 1;
                }

            }
            else
            {
                /* Add a new ptr arg entry at stack offset 'argOfs' */

                if  (argOfs >= MAX_PTRARG_OFS)
                {
                    assert(!"UNDONE: args pushed 'too deep'");
                }
                else
                {
                    /* For ESP-frames, all pushes are reported, and so 
                       argOffs has to be consistent with argCnt */

                    assert(info->ebpFrame || argCnt == argOfs);

                    /* store arg count */

                    argCnt  = argOfs + 1;
                    assert((argCnt < MAX_PTRARG_OFS));

                    /* Compute the appropriate argument offset bit */

                    argMask = (ptrArgTP)1 << argOfs;

//                  printf("push arg at offset %02u --> mask = %04X\n", argOfs, (int)argMask);

                    /* We should never push twice at the same offset */

                    assert(( ptrArgs & argMask) == 0);
                    assert((iptrArgs & argMask) == 0);

                    /* We should never push within the current highest offset */

                    assert(argHigh < argMask);

                    /* This is now the highest bit we've set */

                    argHigh = argMask;

                    /* Set the appropriate bit in the argument mask */

                    ptrArgs |= argMask;

                    if (iptr)
                        iptrArgs |= argMask;
                }

                iptr = isThis = false;
            }
            continue;
        }
        else if (argOfs == 6)
        {
            if (val & 0x40) {
                /* Bigger delta  000=8,001=16,010=24,...,111=64 */
                ptrOffs += (((val & 0x07) + 1) << 3);
            }
            else {
                /* non-ptr arg push */
                assert(!(info->ebpFrame));
                ptrOffs += (val & 0x07);
                if (ptrOffs > curOffs) {
                    iptr = isThis = false;
                    goto REPORT_REFS;
                }
                argHigh = (ptrArgTP)1 << argCnt;
                argCnt++;
                assert(argCnt < MAX_PTRARG_OFS);
            }
            continue;
        }

        /* argOfs was 7 [111] which is reserved for the larger encodings */

        assert(argOfs==7);

        switch (val)
        {
        case 0xFF:
            iptr = isThis = false;
            goto REPORT_REFS;   // the method might loop !!!

        case 0xB8:
            table   += decodeUnsigned(table, &val);
            ptrOffs += val;
            continue;

        case 0xBC:
            isThis = true;
            break;

        case 0xBF:
            iptr = true;
            break;

        case 0xF8:
        case 0xFC:
            isPop    = val & 0x04;
            table   += decodeUnsigned(table, &argOfs);
            goto ARG;

        case 0xFD:
            table   += decodeUnsigned(table, &argOfs);
            assert(argOfs && argOfs <= argCnt);

            // Kill the top "argOfs" pointers.

            ptrArgTP    argMask;
            for(argMask = (ptrArgTP)1 << argCnt; argOfs; argMask >>= 1)
            {
                assert(argMask && ptrArgs); // there should be remaining pointers

                if (ptrArgs & argMask)
                {
                    ptrArgs  &= ~argMask;
                    iptrArgs &= ~argMask;
                    argOfs--;
                }
            }

            // For ebp-frames, need to find the next higest pointer for argHigh

            if (info->ebpFrame)
            {
                for(argHigh = 0; argMask; argMask >>= 1) 
                {
                    if (ptrArgs & argMask) {
                        argHigh = argMask;
                        break;
                    }
                }
            }
            break;

        case 0xF9:
            table   += decodeUnsigned(table, &argOfs);
            argCnt  += argOfs;
            break;

        default:
#ifdef _DEBUG
            printf("Unexpected special code %04X\n", val);
#endif
            assert(!"");
        }
    }

    /* Report all live pointer registers */
REPORT_REFS:

    assert((iptrRegs & ptrRegs) == iptrRegs); // iptrRegs is a subset of ptrRegs
    assert((iptrArgs & ptrArgs) == iptrArgs); // iptrArgs is a subset of ptrArgs

    /* Save the current live register, argument set, and argCnt */
    info->thisPtrResult  = thisPtrReg;
    info->regMaskResult  = convertAllRegsMask(ptrRegs);
    info->argMaskResult  = ptrArgs;
    info->argHnumResult  = 0;
    info->iregMaskResult = convertAllRegsMask(iptrRegs);
    info->iargMaskResult = iptrArgs;

    if (info->ebpFrame)
        return 0;
    else
        return (argCnt * sizeof(unsigned));
}


/*****************************************************************************/

inline
void    TRASH_CALLEE_UNSAVED_REGS(PREGDISPLAY pContext)
{
#ifdef _X86_
#ifdef _DEBUG
    /* This is not completely correct as we lose the current value, but
       it shouldnt really be useful to anyone. */
    static DWORD s_badData = 0xDEADBEEF;
    pContext->pEax = pContext->pEcx = pContext->pEdx = &s_badData;
#endif //_DEBUG
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - TRASH_CALLEE_UNSAVED_REGS (EETwian.cpp)");
#endif // _X86_
}

/*****************************************************************************
 *  Sizes of certain i386 instructions which are used in the prolog/epilog
 */

// Can we use sign-extended byte to encode the imm value, or do we need a dword
#define CAN_COMPRESS(val)       (((int)(val) > -(int)0x100) && \
                                 ((int)(val) <  (int) 0x80))


#define SZ_RET(argSize)         ((argSize)?3:1)
#define SZ_ADD_REG(val)         ( 2 +  (CAN_COMPRESS(val) ? 1 : 4))
#define SZ_AND_REG(val)         SZ_ADD_REG(val)
#define SZ_POP_REG              1
#define SZ_LEA(offset)          SZ_ADD_REG(offset)
#define SZ_MOV_REG_REG          2


    // skips past a Arith REG, IMM.
inline unsigned SKIP_ARITH_REG(int val, BYTE* base, unsigned offset)
{
    unsigned delta = 0;
    if (val != 0)
    {
#ifdef _DEBUG
        // confirm that arith instruction is at the correct place
        if (base[offset] != 0xCC && base[offset] != 0xF4)   // debuger or GCcover might put an int3 or a halt
        {   // debugger might put 
            _ASSERTE((base[offset] & 0xFD) == 0x81 && (base[offset+1] & 0xC0) == 0xC0);
            // only use DWORD form if needed
            _ASSERTE(((base[offset] & 2) != 0) == CAN_COMPRESS(val));
        }
#endif
        delta = 2 + (CAN_COMPRESS(val) ? 1 : 4);
    }
    return(offset + delta);
}

inline unsigned SKIP_PUSH_REG(BYTE* base, unsigned offset)
{
        // Confirm it is a push instruction
        // debugger might put an int3, gccover might put a halt instruction
    _ASSERTE((base[offset] & 0xF8) == 0x50 || base[offset] == 0xCC || base[offset] == 0xF4); 
    return(offset + 1);
}

inline unsigned SKIP_POP_REG(BYTE* base, unsigned offset)
{
        // Confirm it is a pop instruction
    _ASSERTE((base[offset] & 0xF8) == 0x58 || base[offset] == 0xCC);
    return(offset + 1);
}

inline unsigned SKIP_MOV_REG_REG(BYTE* base, unsigned offset)
{
        // Confirm it is a move instruction
    _ASSERTE(((base[offset] & 0xFD) == 0x89 && (base[offset+1] & 0xC0) == 0xC0) || base[offset] == 0xCC || base[offset] == 0xF4);
    return(offset + 2);
}

unsigned SKIP_ALLOC_FRAME(int size, BYTE* base, unsigned offset)
{
    if (size == 4) {
        // We do "push eax" instead of "sub esp,4"
        return (SKIP_PUSH_REG(base, offset));
    }

    if (size >= 0x1000) {
        if (size < 0x3000) {
            // add 7 bytes for one or two TEST EAX, [ESP+0x1000]
            offset += (size / 0x1000) * 7;
        }
        else {
			// 		xor eax, eax				2
			// loop:
			// 		test [esp + eax], eax		3
			// 		sub eax, 0x1000				5
			// 		cmp EAX, -size				5
			// 		jge loop					2
            offset += 17;
        }
    } 
		// sub ESP, size
    return (SKIP_ARITH_REG(size, base, offset));
}

/*****************************************************************************
 *
 *  Unwind the current stack frame, i.e. update the virtual register
 *  set in pContext. This will be similar to the state after the function
 *  returns back to caller (IP points to after the call, Frame and Stack
 *  pointer has been reset, callee-saved registers restored 
 *  (if UpdateAllRegs), callee-UNsaved registers are trashed)
 *  Returns success of operation.
 */

/* <EMAIL>
 * *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***
 * 
 * If you change the instructions emitted for the prolog of a method, you may
 * break some external profiler vendors that have dependencies on the current
 * prolog sequences.  Make sure to discuss any such changes with Jim Miller,
 * who will notify the external vendors as appropriate.
 *
 * *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***
 * </EMAIL> */

bool EECodeManager::UnwindStackFrame(PREGDISPLAY     pContext,
                                     LPVOID          methodInfoPtr,
                                     ICodeInfo      *pCodeInfo,
                                     unsigned        flags,
                                     CodeManState   *pState)
{
#ifdef _X86_
    // Address where the method has been interrupted
    size_t           breakPC = (size_t) *(pContext->pPC);

    /* Extract the necessary information from the info block header */
    BYTE* methodStart = (BYTE*) pCodeInfo->getStartAddress();
    DWORD  curOffs = (DWORD)((size_t)breakPC - (size_t)methodStart);

    BYTE    *       table   = (BYTE *) methodInfoPtr;

    assert(sizeof(CodeManStateBuf) <= sizeof(pState->stateBuf));
    CodeManStateBuf * stateBuf = (CodeManStateBuf*)pState->stateBuf;

    if (pState->dwIsSet == 0)
    {
        /* Extract the necessary information from the info block header */

        stateBuf->hdrInfoSize = (DWORD)crackMethodInfoHdr(methodInfoPtr,
                                                   curOffs,
                                                   &stateBuf->hdrInfoBody);
    }

    table += stateBuf->hdrInfoSize;

    // Register values at "curOffs"

    const unsigned curESP =  pContext->Esp;
    const unsigned curEBP = *pContext->pEbp;

    /*-------------------------------------------------------------------------
     *  First, handle the epilog
     */

    if  (stateBuf->hdrInfoBody.epilogOffs != -1)
    {
        // assert(flags & ActiveStackFrame); // @TODO : Wont work for thread death
        assert(stateBuf->hdrInfoBody.epilogOffs > 0);
        BYTE* epilogBase = &methodStart[curOffs-stateBuf->hdrInfoBody.epilogOffs];

        RegMask regsMask = stateBuf->hdrInfoBody.savedRegMask; // currently remaining regs

        // Used for UpdateAllRegs. Points to the topmost of the 
        // remaining callee-saved regs

        DWORD *     pSavedRegs = NULL; 

        if  (stateBuf->hdrInfoBody.ebpFrame || stateBuf->hdrInfoBody.doubleAlign)
        {
            assert(stateBuf->hdrInfoBody.argSize < 0x10000); // "ret" only has a 2 byte operand
            
           /* See how many instructions we have executed in the 
              epilog to determine which callee-saved registers
              have already been popped */
            int offset = 0;
            
            // stacksize includes all things pushed by this routine (including EBP
            // for EBP based frames.  Thus we need to subrack off the size of EBP
            // to get the EBP relative offset.
            pSavedRegs = (DWORD *)(size_t)(curEBP - (stateBuf->hdrInfoBody.stackSize - sizeof(void*)));
            
            if (stateBuf->hdrInfoBody.doubleAlign && (curEBP & 0x04))
                pSavedRegs--;
            
            // At this point pSavedRegs points at the last callee saved register that
            // was pushed by the prolog.  
            
            // We reset ESP before popping regs
            if ((stateBuf->hdrInfoBody.localloc) &&
                (stateBuf->hdrInfoBody.savedRegMask & (RM_EBX|RM_ESI|RM_EDI))) 
            {
                // The -sizeof void* is because EBP is pushed (and thus
                // is part of stackSize), but we want the displacement from
                // where EBP points (which does not include the pushed EBP)
                offset += SZ_LEA(stateBuf->hdrInfoBody.stackSize - sizeof(void*));
                if (stateBuf->hdrInfoBody.doubleAlign) offset += SZ_AND_REG(-8);
            }
            
            /* Increment "offset" in steps to see which callee-saved
            registers have already been popped */
            
#define determineReg(mask)                                          \
            if ((offset < stateBuf->hdrInfoBody.epilogOffs) &&      \
                (stateBuf->hdrInfoBody.savedRegMask & mask))        \
                {                                                   \
                regsMask = (RegMask)(regsMask & ~mask);             \
                pSavedRegs++;                                       \
                offset = SKIP_POP_REG(epilogBase, offset);          \
                }
            
            determineReg(RM_EBX);        // EBX
            determineReg(RM_ESI);        // ESI
            determineReg(RM_EDI);        // EDI
#undef determineReg

            if (stateBuf->hdrInfoBody.rawStkSize != 0 
                || stateBuf->hdrInfoBody.localloc
                || stateBuf->hdrInfoBody.doubleAlign)
                offset += SZ_MOV_REG_REG;                           // mov ESP, EBP

            if (offset < stateBuf->hdrInfoBody.epilogOffs)          // have we executed the pop EBP
            {
                    // We are after the pop, thus EBP is already the unwound value, however
                    // and ESP points at the return address.  
                _ASSERTE((regsMask & RM_ALL) == RM_EBP);     // no register besides EBP need to be restored.
                pContext->pPC = (SLOT *)(DWORD_PTR)curESP;

                // since we don't need offset from here on out don't bother updating.  
                INDEBUG(offset = SKIP_POP_REG(epilogBase, offset));          // POP EBP
            }
            else
            {
                    // This means EBP is still valid, find the previous EBP and return address
                    // based on this
                pContext->pEbp = (DWORD *)(DWORD_PTR)curEBP;    // restore EBP
                pContext->pPC = (SLOT*)(pContext->pEbp+1);
            }

            /* now pop return address and arguments base of return address
            location. Note varargs is caller-popped. */
            pContext->Esp = (DWORD)(size_t) pContext->pPC + sizeof(void*) +
                (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);
        }
        else // (stateBuf->hdrInfoBody.ebpFrame || stateBuf->hdrInfoBody.doubleAlign)
        {
            int offset = 0;

            /* at this point we know we don't have to restore EBP
               because this is always the first instruction of the epilog
               (if EBP was saved at all).
               First we have to find out where we are in the epilog, i.e.
               how much of the local stacksize has been already popped.
             */

            assert(stateBuf->hdrInfoBody.epilogOffs > 0);

            /* Remaining callee-saved regs are at curESP. Need to update 
               regsMask as well to exclude registers which have already 
               been popped. */

            pSavedRegs = (DWORD *)(DWORD_PTR)curESP;

            /* Increment "offset" in steps to see which callee-saved
               registers have already been popped */

#define determineReg(mask)                                              \
            if  (offset < stateBuf->hdrInfoBody.epilogOffs && (regsMask & mask)) \
            {                                                           \
                stateBuf->hdrInfoBody.stackSize  -= sizeof(unsigned);   \
                offset++;                                               \
                regsMask = (RegMask)(regsMask & ~mask);                 \
            }

            determineReg(RM_EBP);       // EBP
            determineReg(RM_EBX);       // EBX
            determineReg(RM_ESI);       // ESI
            determineReg(RM_EDI);       // EDI
#undef determineReg

            /* If we are not past popping the local frame
               we have to adjust pContext->Esp.
             */

            if  (offset >= stateBuf->hdrInfoBody.epilogOffs)
            {
                /* We have not executed the ADD ESP, FrameSize, so manually adjust stack pointer */
                pContext->Esp += stateBuf->hdrInfoBody.stackSize;
            }
#ifdef _DEBUG
            else
            {
                   /* we may use POP ecx for doing ADD ESP, 4, or we may not (in the case of JMP epilogs) */
             if ((epilogBase[offset] & 0xF8) == 0x58)    // Pop ECX
                 _ASSERTE(stateBuf->hdrInfoBody.stackSize == 4);
             else                
                 SKIP_ARITH_REG(stateBuf->hdrInfoBody.stackSize, epilogBase, offset);
            }
#endif
            /* Finally we can set pPC */
            pContext->pPC = (SLOT*)(size_t)pContext->Esp;

            /* Now adjust stack pointer, pop return address and arguments. 
              Note varargs is caller-popped. */

            pContext->Esp += sizeof(void *) + (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);
        }

        if (flags & UpdateAllRegs)
        {
            /* If we are not done popping all the callee-saved regs, 
               regsMask should indicate the remaining regs and
               pSavedRegs should indicate where the first of the
               remaining regs are sitting. */

#define restoreReg(reg,mask)                                \
            if  (regsMask & mask)                           \
            {                                               \
                pContext->p##reg  = (DWORD *) pSavedRegs++; \
            }

            // For EBP frames, ebp is not near the other callee-saved
            // registers, and is already updated above
            if (!stateBuf->hdrInfoBody.ebpFrame && !stateBuf->hdrInfoBody.doubleAlign)
                restoreReg(Ebp, RM_EBP);

            restoreReg(Ebx, RM_EBX);
            restoreReg(Esi, RM_ESI);
            restoreReg(Edi, RM_EDI);
#undef  restoreReg

            TRASH_CALLEE_UNSAVED_REGS(pContext);
        }

		_ASSERTE(isLegalManagedCodeCaller(*pContext->pPC));
        return true;
    }

    /*-------------------------------------------------------------------------
     *  Now handle ESP frames
     */

    if (!stateBuf->hdrInfoBody.ebpFrame && !stateBuf->hdrInfoBody.doubleAlign)
    {
        unsigned ESP = curESP;

        if (stateBuf->hdrInfoBody.prologOffs == -1)
        {
            if  (stateBuf->hdrInfoBody.interruptible)
            {
                ESP += scanArgRegTableI(skipToArgReg(stateBuf->hdrInfoBody, table),
                                        curOffs,
                                        &stateBuf->hdrInfoBody);
            }
            else
            {
                ESP += scanArgRegTable (skipToArgReg(stateBuf->hdrInfoBody, table),
                                        curOffs,
                                        &stateBuf->hdrInfoBody);
            }
        }

        /* Unwind ESP and restore EBP (if necessary) */

        if (stateBuf->hdrInfoBody.prologOffs != 0)
        {

            if  (stateBuf->hdrInfoBody.prologOffs == -1)
            {
                /* we are past the prolog, ESP has been set above */

#define restoreReg(reg, mask)                                   \
                if  (stateBuf->hdrInfoBody.savedRegMask & mask) \
                {                                               \
                    pContext->p##reg  = (DWORD *)(size_t) ESP;  \
                    ESP              += sizeof(unsigned);       \
                    stateBuf->hdrInfoBody.stackSize -= sizeof(unsigned); \
                }

                restoreReg(Ebp, RM_EBP);
                restoreReg(Ebx, RM_EBX);
                restoreReg(Esi, RM_ESI);
                restoreReg(Edi, RM_EDI);

#undef restoreReg
                /* pop local stack frame */

                ESP += stateBuf->hdrInfoBody.stackSize;

            }
            else
            {
                /* we are in the middle of the prolog */

                unsigned  codeOffset = 0;
                unsigned stackOffset = 0;
                unsigned    regsMask = 0;
#ifdef _DEBUG
                    // if the first instructions are 'nop, int3' 
                    // we will assume that is from a jithalt operation
                    // ad skip past it
                if (methodStart[0] == 0x90 && methodStart[1] == 0xCC)
                    codeOffset += 2;
#endif

                if  (stateBuf->hdrInfoBody.rawStkSize)
                {
                    /* (possible stack tickle code) 
                       sub esp,size */
                    codeOffset = SKIP_ALLOC_FRAME(stateBuf->hdrInfoBody.rawStkSize, methodStart, codeOffset);

                    /* only the last instruction in the sequence above updates ESP
                       thus if we are less than it, we have not updated ESP */
                    if (curOffs >= codeOffset)
                        stackOffset += stateBuf->hdrInfoBody.rawStkSize;
                }

                // Now find out how many callee-saved regs have already been pushed

#define isRegSaved(mask)    ((codeOffset < curOffs) &&                      \
                             (stateBuf->hdrInfoBody.savedRegMask & (mask)))
                                
#define doRegIsSaved(mask)  do { codeOffset = SKIP_PUSH_REG(methodStart, codeOffset);   \
                                 stackOffset += sizeof(void*);                          \
                                 regsMask    |= mask; } while(0)

#define determineReg(mask)  do { if (isRegSaved(mask)) doRegIsSaved(mask); } while(0)

                determineReg(RM_EDI);               // EDI
                determineReg(RM_ESI);               // ESI
                determineReg(RM_EBX);               // EBX
                determineReg(RM_EBP);               // EBP

#undef isRegSaved
#undef doRegIsSaved
#undef determineReg
                
#ifdef PROFILING_SUPPORTED
                // If profiler is active, we have following code after
                // callee saved registers:
                //     push MethodDesc      (or push [MethodDescPtr])
                //     call EnterNaked      (or call [EnterNakedPtr])
                // We need to adjust stack offset if breakPC is at the call instruction.
                if (CORProfilerPresent() && !CORProfilerInprocEnabled() && codeOffset <= unsigned(stateBuf->hdrInfoBody.prologOffs))
                {
                    // This is a bit of a hack, as we don't update codeOffset, however we don't need it 
                    // from here on out.  We only need to make certain we are not certain the ESP is
                    // adjusted correct (which only happens between the push and the call
                    if (methodStart[curOffs] == 0xe8)                           // call addr
                    {
                        _ASSERTE(methodStart[codeOffset] == 0x68 &&             // push XXXX
                                 codeOffset + 5 == curOffs);
                        ESP += sizeof(DWORD);                        
                    }
                    else if (methodStart[curOffs] == 0xFF && methodStart[curOffs+1] == 0x15)  // call [addr]
                    {
                        _ASSERTE(methodStart[codeOffset]   == 0xFF &&  
                                 methodStart[codeOffset+1] == 0x35 &&             // push [XXXX]
                                 codeOffset + 6 == curOffs);
                        ESP += sizeof(DWORD);
                    }
                }
				INDEBUG(codeOffset = 0xCCCCCCCC);		// Poison the value, we don't set it properly in the profiling case

#endif // PROFILING_SUPPORTED

                    // Always restore EBP 
                DWORD* savedRegPtr = (DWORD*) (size_t) ESP;
                if (regsMask & RM_EBP)
                    pContext->pEbp = savedRegPtr++;

                if (flags & UpdateAllRegs)
                {
                    if (regsMask & RM_EBX)
                        pContext->pEbx = savedRegPtr++;
                    if (regsMask & RM_ESI)
                        pContext->pEsi = savedRegPtr++;
                    if (regsMask & RM_EDI)
                        pContext->pEdi = savedRegPtr++;
                    
                    TRASH_CALLEE_UNSAVED_REGS(pContext);
                }
#if 0
    // NOTE:
    // THIS IS ONLY TRUE IF PROLOGSIZE DOES NOT INCLUDE REG-VAR INITIALIZATION !!!!
    //
                /* there is (potentially) only one additional
                   instruction in the prolog, (push ebp)
                   but if we would have been passed that instruction,
                   stateBuf->hdrInfoBody.prologOffs would be -1!
                */
                assert(codeOffset == stateBuf->hdrInfoBody.prologOffs);
#endif
                assert(stackOffset <= stateBuf->hdrInfoBody.stackSize);

                ESP += stackOffset;
            }
        }

        /* we can now set the (address of the) return address */

        pContext->pPC = (SLOT *)(size_t)ESP;

        /* Now adjust stack pointer, pop return address and arguments.
           Note varargs is caller-popped. */

        pContext->Esp = ESP + sizeof(void*) + (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);

		_ASSERTE(isLegalManagedCodeCaller(*pContext->pPC));
        return true;
    }

    /*-------------------------------------------------------------------------
     *  Now we know that have an EBP frame
     */

    _ASSERTE(stateBuf->hdrInfoBody.ebpFrame || stateBuf->hdrInfoBody.doubleAlign);

    /* Check for the case where ebp has not been updated yet */

    if  (stateBuf->hdrInfoBody.prologOffs == 0 || stateBuf->hdrInfoBody.prologOffs == 1)
    {
        /* If we're past the "push ebp", adjust ESP to pop EBP off */

        if  (stateBuf->hdrInfoBody.prologOffs == 1)
            pContext->Esp += sizeof(void *);

        /* Stack pointer points to return address */

        pContext->pPC = (SLOT *)(size_t)pContext->Esp;

        /* Now adjust stack pointer, pop return address and arguments.
           Note varargs is caller-popped. */

        pContext->Esp += sizeof(void *) + (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);

        /* EBP and callee-saved registers still have the correct value */

        _ASSERTE(isLegalManagedCodeCaller(*pContext->pPC));
        return true;
    }
    else    /* */
    {
        if (stateBuf->hdrInfoBody.handlers && stateBuf->hdrInfoBody.prologOffs == -1)
        {
            size_t  baseSP;

            FrameType frameType = GetHandlerFrameInfo(&stateBuf->hdrInfoBody, curEBP,
                                                      curESP, IGNORE_VAL,
                                                      &baseSP);

            /* If we are in a filter, we only need to unwind the funclet stack. 
               For catches/finallies, the normal handling will 
               cause the frame to be unwound all the way up to ebp skipping
               other frames above it. This is OK, as those frames will be 
               dead. Also, the EE will detect that this has happened and it
               will handle any EE frames correctly.
             */

            if (frameType == FR_FILTER)
            {
                pContext->pPC = (SLOT*)(size_t)baseSP;

                pContext->Esp = (DWORD)(baseSP + sizeof(void*));

             // pContext->pEbp = same as before;
                
#ifdef _DEBUG
                /* The filter has to be called by the VM. So we dont need to
                   update callee-saved registers.
                 */

                if (flags & UpdateAllRegs)
                {
                    static DWORD s_badData = 0xDEADBEEF;
                    
                    pContext->pEax = pContext->pEbx = pContext->pEcx = 
                    pContext->pEdx = pContext->pEsi = pContext->pEdi = &s_badData;
                }
#endif
				_ASSERTE(isLegalManagedCodeCaller(*pContext->pPC));
                return true;
            }
        }

        if (flags & UpdateAllRegs)
        {
            // Get to the first callee-saved register
            DWORD * pSavedRegs = (DWORD*)(size_t)(curEBP - stateBuf->hdrInfoBody.rawStkSize - sizeof(DWORD));

            // Start after the "push ebp, mov ebp, esp"

            DWORD offset = 0;

#ifdef _DEBUG
            // If the first instructions are 'nop, int3', we will assume
            // that is from a JitHalt instruction and skip past it
            if (methodStart[0] == 0x90 && methodStart[1] == 0xCC)
                offset += 2;
#endif
            offset = SKIP_MOV_REG_REG(methodStart, 
                                SKIP_PUSH_REG(methodStart, offset));

            /* make sure that we align ESP just like the method's prolog did */
            if  (stateBuf->hdrInfoBody.doubleAlign)
            {
                offset = SKIP_ARITH_REG(-8, methodStart, offset); // "and esp,-8"
                if (curEBP & 0x04)
                {
                    pSavedRegs--;
#ifdef _DEBUG
                    if (dspPtr) printf("EnumRef: dblalign ebp: %08X\n", curEBP);
#endif
                }
            }

            // sub esp, FRAME_SIZE
            offset = SKIP_ALLOC_FRAME(stateBuf->hdrInfoBody.rawStkSize, methodStart, offset);

            /* Increment "offset" in steps to see which callee-saved
               registers have been pushed already */

#define restoreReg(reg,mask)                                            \
                                                                        \
            /* Check offset in case we are still in the prolog */       \
                                                                        \
            if ((offset < curOffs) && (stateBuf->hdrInfoBody.savedRegMask & mask))       \
            {                                                           \
                pContext->p##reg = pSavedRegs--;                        \
                offset = SKIP_PUSH_REG(methodStart, offset) ; /* "push reg" */ \
            }

            restoreReg(Edi,RM_EDI);
            restoreReg(Esi,RM_ESI);
            restoreReg(Ebx,RM_EBX);

#undef restoreReg

            TRASH_CALLEE_UNSAVED_REGS(pContext);
        }

        /* The caller's ESP will be equal to EBP + retAddrSize + argSize.
           Note varargs is caller-popped. */

        pContext->Esp = (DWORD)(curEBP + 
                                (RETURN_ADDR_OFFS+1)*sizeof(void *) +
                                (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize));

        /* The caller's saved EIP is right after our EBP */

        pContext->pPC = (SLOT *)(DWORD_PTR)&(((size_t *)(DWORD_PTR)curEBP)[RETURN_ADDR_OFFS]);

        /* The caller's saved EBP is pointed to by our EBP */

        pContext->pEbp = (DWORD *)(DWORD_PTR)curEBP;
    }

	_ASSERTE(isLegalManagedCodeCaller(*pContext->pPC));
    return true;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - EECodeManager::UnwindStackFrame (EETwain.cpp)");
    return false;
#endif // _X86_
}

INDEBUG(void* forceStack1;)


/*****************************************************************************
 *
 *  Enumerate all live object references in that function using
 *  the virtual register set.
 *  Returns success of operation.
 */
bool EECodeManager::EnumGcRefs( PREGDISPLAY     pContext,
                                LPVOID          methodInfoPtr,
                                ICodeInfo      *pCodeInfo,
                                unsigned        curOffs,
                                unsigned        flags,
                                GCEnumCallback  pCallBack,      //@TODO: exact type?
                                LPVOID          hCallBack)
{
    INDEBUG(forceStack1 = &curOffs;)            // So I can see this in fastchecked.
#ifdef _X86_
    unsigned  EBP     = *pContext->pEbp;
    unsigned  ESP     =  pContext->Esp;

    unsigned  ptrOffs;

    unsigned  count;

    hdrInfo   info;
    BYTE    * table   = (BYTE *) methodInfoPtr;
    //unsigned  curOffs = *pContext->pPC - (int)methodStart;

    /* Extract the necessary information from the info block header */

    table += crackMethodInfoHdr(methodInfoPtr,
                                curOffs,
                                &info);

    assert( curOffs <= info.methodSize);

#ifdef  _DEBUG
//    if ((methodInfoPtr == (void*)0x37760d0) && (curOffs == 0x264))
//        __asm int 3;

    if (trEnumGCRefs) {
        static unsigned lastESP = 0;
        unsigned        diffESP = ESP - lastESP;
        if (diffESP > 0xFFFF) {
            printf("------------------------------------------------------\n");
        }
        lastESP = ESP;
        printf("EnumGCRefs [%s][%s] at %s.%s + 0x%03X:\n",
               info.ebpFrame?"ebp":"   ",
               info.interruptible?"int":"   ",
               "UnknownClass","UnknownMethod", curOffs);
        fflush(stdout);
    }
#endif

    /* Are we in the prolog or epilog of the method? */

    if  (info.prologOffs != -1 || info.epilogOffs != -1)
    {

		
#if !DUMP_PTR_REFS
		// Under normal circumstances the system will not suspend a thread
		// if it is in the prolog or epilog of the function.   However ThreadAbort
		// exception or stack overflows can cause EH to happen in a prolog. 
		// Once in the handler, a GC can happen, so we can get to this code path.
		// However since we are tearing down this frame, we don't need to report
		// anything and we can simply return. 

		assert(flags & ExecutionAborted);
#endif
        return true;
    }

#ifdef _DEBUG
#define CHK_AND_REPORT_REG(doIt, iptr, regName)                         \
        if  (doIt)                                                      \
        {                                                               \
            if (dspPtr)                                                 \
                printf("    Live pointer register %s: ", #regName);     \
                pCallBack(hCallBack,                                    \
                          (OBJECTREF*)(pContext->p##regName),           \
                          (iptr ? GC_CALL_INTERIOR : 0)                 \
                          | CHECK_APP_DOMAIN );                         \
        }
#else // !_DEBUG
#define CHK_AND_REPORT_REG(doIt, iptr, regName)                         \
        if  (doIt)                                                      \
                pCallBack(hCallBack,                                    \
                          (OBJECTREF*)(pContext->p##regName),           \
                          (iptr ? GC_CALL_INTERIOR : 0)                 \
                          | CHECK_APP_DOMAIN );                         \

#endif // _DEBUG

    /* What kind of a frame is this ? */

    FrameType   frameType = FR_NORMAL;
    size_t      baseSP = 0;

    if (info.handlers)
    {
        assert(info.ebpFrame);

        bool    hasInnerFilter, hadInnerFilter;
        frameType = GetHandlerFrameInfo(&info, EBP,
                                        ESP, IGNORE_VAL,
                                        &baseSP, NULL,
                                        &hasInnerFilter, &hadInnerFilter);

        /* If this is the parent frame of a filter which is currently 
           executing, then the filter would have enumerated the frame using
           the filter PC.
         */

        if (hasInnerFilter)
            return true;

        /* If are in a try and we had a filter execute, we may have reported
           GC refs from the filter (and not using the try's offset). So
           we had better use the filter's end offset, as the try is
           effectively dead and its GC ref's would be stale */

        if (hadInnerFilter)
        {
            size_t * pFirstBaseSPslot = GetFirstBaseSPslotPtr(EBP, &info);
            curOffs = (unsigned)pFirstBaseSPslot[1] - 1;
            assert(curOffs < info.methodSize);

            /* Extract the necessary information from the info block header */

            table = (BYTE *) methodInfoPtr;

            table += crackMethodInfoHdr(methodInfoPtr,
                                        curOffs,
                                        &info);
        }
    }

    bool        willContinueExecution = !(flags & ExecutionAborted);
    unsigned    pushedSize = 0;

    /* if we have been interrupted we don't have to report registers/arguments
    /* because we are about to lose this context anyway. 
     * Alas, if we are in a ebp-less method we have to parse the table
     * in order to adjust ESP.
     *
     */

    if  (info.interruptible)
    {
        pushedSize = scanArgRegTableI(skipToArgReg(info, table), curOffs, &info);

        RegMask   regs  = info.regMaskResult;
        RegMask  iregs  = info.iregMaskResult;
        ptrArgTP  args  = info.argMaskResult;
        ptrArgTP iargs  = info.iargMaskResult;

        assert((args == 0 || pushedSize != 0) || info.ebpFrame);
        assert((args & iargs) == iargs);

            /* now report registers and arguments if we are not interrupted */

        if  (willContinueExecution)
        {

            /* Propagate unsafed registers only in "current" method */
            /* If this is not the active method, then the callee wil
             * trash these registers, and so we wont need to report them */

            if (flags & ActiveStackFrame)
            {
                CHK_AND_REPORT_REG(regs & RM_EAX, iregs & RM_EAX, Eax);
                CHK_AND_REPORT_REG(regs & RM_ECX, iregs & RM_ECX, Ecx);
                CHK_AND_REPORT_REG(regs & RM_EDX, iregs & RM_EDX, Edx);
            }

            CHK_AND_REPORT_REG(regs & RM_EBX, iregs & RM_EBX, Ebx);
            CHK_AND_REPORT_REG(regs & RM_EBP, iregs & RM_EBP, Ebp);
            CHK_AND_REPORT_REG(regs & RM_ESI, iregs & RM_ESI, Esi);
            CHK_AND_REPORT_REG(regs & RM_EDI, iregs & RM_EDI, Edi);
            assert(!(regs & RM_ESP));

            /* Report any pending pointer arguments */

            DWORD * pPendingArgFirst;		// points **AT** first parameter 
            if (!info.ebpFrame)
            {
					// -sizeof(void*) because we want to point *AT* first parameter
                pPendingArgFirst = (DWORD *)(size_t)(ESP + pushedSize - sizeof(void*));
            }
            else
            {
                assert(willContinueExecution);

                if (info.handlers)
                {
						// -sizeof(void*) because we want to point *AT* first parameter
                    pPendingArgFirst = (DWORD *)(size_t)(baseSP - sizeof(void*));
                }
                else if (info.localloc)
                {
                    baseSP = *(DWORD *)(size_t)(EBP - (1 + info.securityCheck) * sizeof(void*));
						// -sizeof(void*) because we want to point *AT* first parameter
                    pPendingArgFirst = (DWORD *)(size_t) (baseSP - sizeof(void*));
                }
                else
                {
						// Note that 'info.stackSize includes the size for pushing EBP, but EBP is pushed
						// BEFORE EBP is set from ESP, thus (EBP - info.stackSize) actually points past 
						// the frame by one DWORD, and thus points *AT* the first parameter (Yuck)  -vancem
                    pPendingArgFirst = (DWORD *)(size_t)(EBP - info.stackSize);
                }
            }

            if  (args)
            {
                unsigned   i;
                ptrArgTP   b;

                for (i = 0, b = 1; args && (i < MAX_PTRARG_OFS); i += 1, b <<= 1)
                {
                    if  (args & b)
                    {
                        unsigned    argAddr = (unsigned)(size_t)(pPendingArgFirst - i);
                        bool        iptr    = false;

                        args -= b;

                        if (iargs  & b)
                        {
                            iargs -= b;
                            iptr   = true;
                        }

#ifdef _DEBUG
                        if (dspPtr)
                        {
                            printf("    Pushed ptr arg  [E");
                            if  (info.ebpFrame)
                                printf("BP-%02XH]: ", EBP - argAddr);
                            else
                                printf("SP+%02XH]: ", argAddr - ESP);
                        }
#endif
                        assert(true == GC_CALL_INTERIOR);
                        pCallBack(hCallBack, (OBJECTREF *)(size_t)argAddr, 
                                  (int)iptr | CHECK_APP_DOMAIN);
                    }
                }
            }
        }
        else
        {
            // Is "this" enregistered. If so, report it as we might need to
            // release the monitor for synchronized methods. However, do not
            // report if an interior ptr. 
            // Else, it is on the stack and will be reported below.

            if (((MethodDesc*)pCodeInfo->getMethodDesc_HACK())->IsSynchronized() &&
                info.thisPtrResult != REGI_NA)
            {
                if ((regNumToMask(info.thisPtrResult) & info.iregMaskResult) == 0)
                {
                    void * thisReg = getCalleeSavedReg(pContext, info.thisPtrResult);
                    pCallBack(hCallBack, (OBJECTREF *)thisReg,
                              CHECK_APP_DOMAIN);
                }
            }
        }
    }
    else /* not interruptible */
    {
        pushedSize = scanArgRegTable(skipToArgReg(info, table), curOffs, &info);

        RegMask    regMask = info.regMaskResult;
        RegMask   iregMask = info.iregMaskResult;
        unsigned   argMask = info.argMaskResult;
        unsigned  iargMask = info.iargMaskResult;
        unsigned   argHnum = info.argHnumResult;
        BYTE *     argTab  = info.argTabResult;

            /* now report registers and arguments if we are not interrupted */

        if  (willContinueExecution)
        {

            /* Report all live pointer registers */

            CHK_AND_REPORT_REG(regMask & RM_EDI, iregMask & RM_EDI, Edi);
            CHK_AND_REPORT_REG(regMask & RM_ESI, iregMask & RM_ESI, Esi);
            CHK_AND_REPORT_REG(regMask & RM_EBX, iregMask & RM_EBX, Ebx);
            CHK_AND_REPORT_REG(regMask & RM_EBP, iregMask & RM_EBP, Ebp);

            /* Esp cant be reported */
            assert(!(regMask & RM_ESP));
            /* No callee-trashed registers */
            assert(!(regMask & RM_CALLEE_TRASHED));
            /* EBP can't be reported unless we have an EBP-less frame */
            assert(!(regMask & RM_EBP) || !(info.ebpFrame));

            /* Report any pending pointer arguments */

            if (argTab != 0)
            {
                unsigned    lowBits, stkOffs, argAddr, val;

                // argMask does not fit in 32-bits
                // thus arguments are reported via a table
                // Both of these are very rare cases

                do 
                {
                    argTab += decodeUnsigned(argTab, &val);

                    lowBits = val &  OFFSET_MASK;
                    stkOffs = val & ~OFFSET_MASK;
                    assert((lowBits == 0) || (lowBits == byref_OFFSET_FLAG));

                    argAddr = ESP + stkOffs;
#ifdef _DEBUG
                    if (dspPtr)
                        printf("    Pushed %sptr arg at [ESP+%02XH]",
                               lowBits ? "iptr " : "", stkOffs);
#endif
                    assert(byref_OFFSET_FLAG == GC_CALL_INTERIOR);
                    pCallBack(hCallBack, (OBJECTREF *)(size_t)argAddr, 
                              lowBits | CHECK_APP_DOMAIN);
                }
                while(--argHnum);

                assert(info.argTabResult + info.argTabBytes == argTab);
            }
            else
            {
                unsigned    argAddr = ESP;

                while (argMask)
                {
                    _ASSERTE(argHnum-- > 0);

                    if  (argMask & 1)
                    {
                        bool     iptr    = false;

                        if (iargMask & 1)
                            iptr = true;
#ifdef _DEBUG
                        if (dspPtr)
                            printf("    Pushed ptr arg at [ESP+%02XH]",
                                   argAddr - ESP);
#endif
                        assert(true == GC_CALL_INTERIOR);
                        pCallBack(hCallBack, (OBJECTREF *)(size_t)argAddr, 
                                  (int)iptr | CHECK_APP_DOMAIN);
                    }

                    argMask >>= 1;
                    iargMask >>= 1;
                    argAddr  += 4;
                }

            }

        }
        else
        {
            // Is "this" enregistered. If so, report it as we will need to
            // release the monitor. Else, it is on the stack and will be 
            // reported below.

            if (((MethodDesc*)pCodeInfo->getMethodDesc_HACK())->IsSynchronized() &&
                info.thisPtrResult != REGI_NA)
            {
                if ((regNumToMask(info.thisPtrResult) & info.iregMaskResult) == 0)
                {
                    void * thisReg = getCalleeSavedReg(pContext, info.thisPtrResult);
                    pCallBack(hCallBack, (OBJECTREF *)thisReg, 
                              CHECK_APP_DOMAIN);
                }
            }
        }

    } //info.interruptible

    /* compute the argument base (reference point) */

    unsigned    argBase;

    if (info.ebpFrame)
        argBase = EBP;
    else
        argBase = ESP + pushedSize;

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBEEF);
#endif

    unsigned ptrAddr;
    unsigned lowBits;


    /* Process the untracked frame variable table */

    count = info.untrackedCnt;
    while (count-- > 0)
    {
        int  stkOffs;
        table += decodeSigned(table, &stkOffs);

        assert(0 == ~OFFSET_MASK % sizeof(void*));

        lowBits  =   OFFSET_MASK & stkOffs;
        stkOffs &=  ~OFFSET_MASK;

        ptrAddr = argBase + stkOffs;
        if (info.doubleAlign && stkOffs >= int(info.stackSize - sizeof(void*))) {
            // We encode the arguments as if they were ESP based variables even though they aren't
            // IF this frame would have ben an ESP based frame,   This fake frame is one DWORD
            // smaller than the real frame because it did not push EBP but the real frame did.
            // Thus to get the correct EBP relative offset we have to ajust by info.stackSize-sizeof(void*)
            ptrAddr = EBP + (stkOffs-(info.stackSize - sizeof(void*)));
        }

#ifdef  _DEBUG
        if (dspPtr)
        {
            printf("    Untracked %s%s local at [E",
                        (lowBits & pinned_OFFSET_FLAG) ? "pinned " : "",
                        (lowBits & byref_OFFSET_FLAG)  ? "byref"   : "");

            int   dspOffs = ptrAddr;
            char  frameType;

            if (info.ebpFrame) {
                dspOffs   -= EBP;
                frameType  = 'B';
            }
            else {
                dspOffs   -= ESP;
                frameType  = 'S';
            }

            if (dspOffs < 0)
                printf("%cP-%02XH]: ", frameType, -dspOffs);
            else
                printf("%cP+%02XH]: ", frameType, +dspOffs);
        }
#endif

        assert((pinned_OFFSET_FLAG == GC_CALL_PINNED) &&
               (byref_OFFSET_FLAG  == GC_CALL_INTERIOR));
        pCallBack(hCallBack, (OBJECTREF*)(size_t)ptrAddr, lowBits | CHECK_APP_DOMAIN);
    }

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xCAFE);
#endif

    /* Process the frame variable lifetime table */
    count = info.varPtrTableSize;

    /* If we are not in the active method, we are currently pointing
     * to the return address; at the return address stack variables
     * can become dead if the call the last instruction of a try block
     * and the return address is the jump around the catch block. Therefore
     * we simply assume an offset inside of call instruction. 
     */

    unsigned newCurOffs;

    if (willContinueExecution)
    {
        newCurOffs = (flags & ActiveStackFrame) ?  curOffs    // after "call"
                                                :  curOffs-1; // inside "call"
    }
    else
    {
        /* However if ExecutionAborted, then this must be one of the 
         * ExceptionFrames. Handle accordingly
         */
        assert(!(flags & AbortingCall) || !(flags & ActiveStackFrame));

        newCurOffs = (flags & AbortingCall) ? curOffs-1 // inside "call"
                                            : curOffs;  // at faulting instr, or start of "try"
    }

    ptrOffs    = 0;
    while (count-- > 0)
    {
        int       stkOffs;
        unsigned  begOffs;
        unsigned  endOffs;

        table   += decodeUnsigned(table, (unsigned *) &stkOffs);
        table   += decodeUDelta  (table, &begOffs, ptrOffs);
        table   += decodeUDelta  (table, &endOffs, begOffs);
        ptrOffs  = begOffs;

        assert(0 == ~OFFSET_MASK % sizeof(void*));

        lowBits  =   OFFSET_MASK & stkOffs;
        stkOffs &=  ~OFFSET_MASK;

        if (info.ebpFrame) {
            stkOffs = -stkOffs;
            assert(stkOffs < 0);
        }
        else {
            assert(stkOffs >= 0);
        }

        ptrAddr = argBase + stkOffs;

        /* Is this variable live right now? */

        if ((newCurOffs >= begOffs) && (newCurOffs <  endOffs))
        {
#ifdef  _DEBUG
            if (dspPtr) {
                printf("    Frame %s%s local at [E",
                            (lowBits & byref_OFFSET_FLAG) ? "byref "   : "",
                            (lowBits & this_OFFSET_FLAG)  ? "this-ptr" : "");

                int  dspOffs = ptrAddr;
                char frameType;

                if (info.ebpFrame) {
                    dspOffs   -= EBP;
                    frameType  = 'B';
                }
                else {
                    dspOffs   -= ESP;
                    frameType  = 'S';
                }

                if (dspOffs < 0)
                    printf("%cP-%02XH]: ", frameType, -dspOffs);
                else
                    printf("%cP+%02XH]: ", frameType, +dspOffs);
            }
#endif
            assert(byref_OFFSET_FLAG == GC_CALL_INTERIOR);
            pCallBack(hCallBack, (OBJECTREF*)(size_t)ptrAddr, 
                      (lowBits & byref_OFFSET_FLAG) | CHECK_APP_DOMAIN);
        }
    }

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBABE);
#endif

    if  (info.securityCheck)
    {
        assert(info.ebpFrame);
        /* Report the "security object" */
        pCallBack(hCallBack, (OBJECTREF *)(size_t)(argBase - sizeof(void *)), 
                  CHECK_APP_DOMAIN);
    }


    /* Are we a vargs function, if so we have to report all args 
       except 'this' (note that the GC tables created by the jit
       do not contain ANY arguments except 'this' (even if they
       were statically declared */

    if (info.varargs) {
        BYTE* argsStart; 
       
        if (info.ebpFrame || info.doubleAlign)
            argsStart = ((BYTE*)(size_t)EBP) + 2* sizeof(void*);                 // pushed EBP and retAddr
        else
            argsStart = ((BYTE*)(size_t)argBase) + info.stackSize + sizeof(void*);   // ESP + locals + retAddr
 
            // Note that I really want to say hCallBack is a GCCONTEXT, but this is pretty close
        extern void GcEnumObject(LPVOID pData, OBJECTREF *pObj, DWORD flags);
        _ASSERTE((void*) GcEnumObject == pCallBack);
        GCCONTEXT   *pCtx = (GCCONTEXT *) hCallBack;

        // For varargs, look up the signature using the varArgSig token passed on the stack
        VASigCookie* varArgSig = *((VASigCookie**) argsStart);
        MetaSig msig(varArgSig->mdVASig, varArgSig->pModule);

        promoteArgs(argsStart, &msig, pCtx, 0, 0);     
    }

    return true;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - EECodeManager::EnumGcRefs (EETwain.cpp)");
    return false;
#endif // _X86_
}

/*****************************************************************************
 *
 *  Return the address of the local security object reference
 *  (if available).
 */
OBJECTREF* EECodeManager::GetAddrOfSecurityObject( PREGDISPLAY     pContext,
                                                   LPVOID          methodInfoPtr,
                                                   unsigned        relOffset,
                                                   CodeManState   *pState)
{
    assert(sizeof(CodeManStateBuf) <= sizeof(pState->stateBuf));
    CodeManStateBuf * stateBuf = (CodeManStateBuf*)pState->stateBuf;

    /* Extract the necessary information from the info block header */

    stateBuf->hdrInfoSize = (DWORD)crackMethodInfoHdr(methodInfoPtr, // @TODO LBS - truncation
                                                      relOffset,
                                                      &stateBuf->hdrInfoBody);

    pState->dwIsSet = 1;
#ifdef _X86_
    if  (stateBuf->hdrInfoBody.securityCheck)
    {
        assert (stateBuf->hdrInfoBody.ebpFrame);
        assert (stateBuf->hdrInfoBody.prologOffs == -1 &&
                stateBuf->hdrInfoBody.epilogOffs == -1);

        return (OBJECTREF *)(size_t)(((DWORD)*pContext->pEbp) - sizeof(void*));
    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - EECodeManager::GetAddrOfSecurityObject (EETwain.cpp)");
#endif // _X86_

    return NULL;
}

/*****************************************************************************
 *
 *  Returns "this" pointer if it is a non-static method
 *  AND the object is still alive.
 *  Returns NULL in all other cases.
 */
OBJECTREF EECodeManager::GetInstance( PREGDISPLAY    pContext,
                                      LPVOID         methodInfoPtr,
                                      ICodeInfo      *pCodeInfo,
                                      unsigned       relOffset)
{
    // Jit Compilers will not track "this" correctly for non-synchronized methods
    if (!((MethodDesc*)pCodeInfo->getMethodDesc_HACK())->IsSynchronized())
        return NULL;

#ifdef _X86_
    BYTE     *  table   = (BYTE *) methodInfoPtr;
    hdrInfo     info;
    unsigned    stackDepth;
    size_t      argBase;
    unsigned    count;

    /* Extract the necessary information from the info block header */

    table += crackMethodInfoHdr(methodInfoPtr,
                                relOffset,
                                &info);

    /* ToDo: Handle the case in which we are in the prolog or (very unlikely) the epilog */

    _ASSERTE(info.prologOffs == -1 && info.epilogOffs == -1);

    if  (info.interruptible)
    {
        stackDepth = scanArgRegTableI(skipToArgReg(info, table), (unsigned)relOffset, &info);
    }
    else
    {
        stackDepth = scanArgRegTable (skipToArgReg(info, table), (unsigned)relOffset, &info);
    }

    if (info.ebpFrame)
    {
        assert(stackDepth == 0);
        argBase = *pContext->pEbp;
    }
    else
    {
        argBase =  pContext->Esp + stackDepth;
    }

    if (info.thisPtrResult != REGI_NA)
    {
        return ObjectToOBJECTREF(*(Object **)getCalleeSavedReg(pContext, info.thisPtrResult));
    }

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBEEF);
#endif

    /* Parse the untracked frame variable table */

    /* The 'this' pointer can never be located in the untracked table */
    /* as we only allow pinned and byrefs in the untracked table      */

    count = info.untrackedCnt;
    while (count-- > 0)
    {
        int  stkOffs;
        table += decodeSigned(table, &stkOffs);
    }

    /* Look for the 'this' pointer in the frame variable lifetime table     */

    count = info.varPtrTableSize;
    unsigned tmpOffs = 0;
    while (count-- > 0)
    {
        unsigned varOfs;
        unsigned begOfs;
        unsigned endOfs;
        table += decodeUnsigned(table, &varOfs);
        table += decodeUDelta(table, &begOfs, tmpOffs);
        table += decodeUDelta(table, &endOfs, begOfs);
        assert(varOfs);
        /* Is this variable live right now? */
        if (((unsigned)relOffset >= begOfs) && ((unsigned)relOffset < endOfs))
        {
            /* Does it contain the 'this' pointer */
            if (varOfs & this_OFFSET_FLAG)
            {
                unsigned ofs = varOfs & ~OFFSET_MASK;

                /* Tracked locals for EBP frames are always at negative offsets */

                if (info.ebpFrame)
                    argBase -= ofs;
                else
                    argBase += ofs;

                return (OBJECTREF)(size_t)(*(DWORD *)argBase);
            }
        }
        tmpOffs = begOfs;
    }

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *) == 0xBABE);
#endif

#else // !_X86_
    _ASSERTE(!"@TODO Alpha - EECodeManager::GetInstance (EETwain.cpp)");
#endif // _X86_
    return NULL;
}

/*****************************************************************************
 *
 *  Returns true if the given IP is in the given method's prolog or epilog.
 */
bool EECodeManager::IsInPrologOrEpilog(DWORD        relPCoffset,
                                       LPVOID       methodInfoPtr,
                                       size_t*      prologSize)
{
    hdrInfo info;

    BYTE* table = (BYTE*) crackMethodInfoHdr(methodInfoPtr,
                                             relPCoffset,
                                             &info);

    *prologSize = info.prologSize;

    if ((info.prologOffs != -1) || (info.epilogOffs != -1))
        return true;
    else
        return false;
}

/*****************************************************************************
 *
 *  Returns the size of a given function.
 */
size_t EECodeManager::GetFunctionSize(LPVOID  methodInfoPtr)
{
    hdrInfo info;

    BYTE* table = (BYTE*) crackMethodInfoHdr(methodInfoPtr,
                                             0,
                                             &info);

    return info.methodSize;
}

/*****************************************************************************
 *
 *  Returns the size of the frame of the given function.
 */
unsigned int EECodeManager::GetFrameSize(LPVOID  methodInfoPtr)
{
    hdrInfo info;

    BYTE* table = (BYTE*) crackMethodInfoHdr(methodInfoPtr,
                                             0,
                                             &info);

    // currently only used by E&C callers need to know about doubleAlign 
    // in all likelyhood
    _ASSERTE(!info.doubleAlign);
    return info.stackSize;
}

/*****************************************************************************/

const BYTE* EECodeManager::GetFinallyReturnAddr(PREGDISPLAY pReg)
{
#ifdef _X86_
    return *(const BYTE**)(size_t)(pReg->Esp);
#else
    _ASSERTE( !"EEJitManager::GetFinallyReturnAddr NYI!");
    return NULL;
#endif    
}

BOOL EECodeManager::IsInFilter(void *methodInfoPtr,
                              unsigned offset,    
                              PCONTEXT pCtx,
                              DWORD curNestLevel)
{
#ifdef _X86_

    /* Extract the necessary information from the info block header */

    hdrInfo     info;

    crackMethodInfoHdr(methodInfoPtr,
                       offset,
                       &info);

    /* make sure that we have an ebp stack frame */

    assert(info.ebpFrame);
    assert(info.handlers); // @TODO : This will alway be set. Remove it

    size_t      baseSP;
    DWORD       nestingLevel;

    FrameType   frameType = GetHandlerFrameInfo(&info, pCtx->Ebp,
                                                pCtx->Esp, IGNORE_VAL,
                                                &baseSP, &nestingLevel);
//    assert(nestingLevel == curNestLevel);

    return frameType == FR_FILTER;

#else
    _ASSERTE( !"EEJitManager::IsInFilter NYI!");
    return FALSE;
#endif    
}


BOOL EECodeManager::LeaveFinally(void *methodInfoPtr,
                                unsigned offset,    
                                PCONTEXT pCtx,
                                DWORD curNestLevel)
{
#ifdef _X86_

    hdrInfo info;
    
    crackMethodInfoHdr(methodInfoPtr,
                       offset,
                       &info);

#ifdef _DEBUG
    size_t      baseSP;
    DWORD       nestingLevel;
    bool        hasInnerFilter;
    FrameType   frameType = GetHandlerFrameInfo(&info, pCtx->Ebp, 
                                                pCtx->Esp, IGNORE_VAL,
                                                &baseSP, &nestingLevel, &hasInnerFilter);
//    assert(frameType == FR_HANDLER);
//    assert(pCtx->Esp == baseSP);
    assert(nestingLevel == curNestLevel);
#endif

    size_t * pBaseSPslots = GetFirstBaseSPslotPtr(pCtx->Ebp, &info);
    size_t * pPrevSlot    = pBaseSPslots + curNestLevel - 1;

    /* Currently, LeaveFinally() is not used if the finally is invoked in the
       second pass for unwinding. So we expect the finally to be called locally */
    assert(*pPrevSlot == LCL_FIN_MARK);

    *pPrevSlot = 0; // Zero out the previous shadow ESP
    
    pCtx->Esp += sizeof(size_t); // Pop the return value off the stack
    return TRUE;
#else
    _ASSERTE( !"EEJitManager::LeaveFinally NYI!");
    return FALSE;
#endif    
}

void EECodeManager::LeaveCatch(void *methodInfoPtr,
                                unsigned offset,    
                                PCONTEXT pCtx)
{
#ifdef _X86_

#ifdef _DEBUG
    size_t      baseSP;
    DWORD       nestingLevel;
    bool        hasInnerFilter;
    hdrInfo     info;
    size_t      size = crackMethodInfoHdr(methodInfoPtr, offset, &info);
        
    FrameType   frameType = GetHandlerFrameInfo(&info, pCtx->Ebp, 
                                                pCtx->Esp, IGNORE_VAL,
                                                &baseSP, &nestingLevel, &hasInnerFilter);
//    assert(frameType == FR_HANDLER);
//    assert(pCtx->Esp == baseSP);
#endif

    return;

#else // !_X86_
    _ASSERTE(!"@todo - port");
    return;
#endif // _X86_
}

HRESULT EECodeManager::JITCanCommitChanges(LPVOID methodInfoPtr,
                                     DWORD oldMaxEHLevel,
                                     DWORD newMaxEHLevel)
{
    // This will be more fleshed out as we add things here. :)
    if (oldMaxEHLevel != newMaxEHLevel)
    {
        return CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ejitmgr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name: EjitMgr.cpp

Abstract: EconojitManager Implementation

Date        Author      Comments
----        ------      --------
2/15/99     sanjaybh     Created     

--*/


#include "common.h"
#include "excep.h"
#include "stubmgr.h"
#include "gms.h"        
#include "frames.h"
#include "EjitMgr.h"
#include "JitInterface.h"
#include "DbgInterface.h"
#include "Fjit_EETwain.h"
#include "EEConfig.h"
#define USE_EH_DECODER
#include "EHEncoder.cpp"
#undef USE_EH_DECODER
#include "jitperf.h"
#include "wsperf.h"
#include "PerfCounters.h"
#include "PerfLog.h"

#if !defined(GOLDEN)
#define SUPPORT_CODE_PITCH_TRIGGER
#define SUPPORT_MAX_UNPITCHED_PER_THREAD
#endif

unsigned  EconoJitManager::m_cMethodsJitted;        // number of methods jitted since last pitch
unsigned  EconoJitManager::m_cCalleeRejits;         // number of callees jitted since last pitch
unsigned  EconoJitManager::m_cCallerRejits;         // number of callers jitted since last pitch
EconoJitManager::JittedMethodInfo**   EconoJitManager::m_PreserveCandidates;   // methods that are possible candidates for pitching
unsigned  EconoJitManager::m_MaxUnpitchedPerThread = DEFAULT_MAX_PRESERVES_PER_THREAD;   // maximum number of methods in each thread that will be pitched
unsigned  EconoJitManager::m_PreserveCandidates_size=0;  // current size of m_PreserveCandidates array

EconoJitManager::JittedMethodInfo** EconoJitManager::m_PreserveEhGcInfoList;
unsigned EconoJitManager::m_cPreserveEhGcInfoList=0;
unsigned EconoJitManager::m_PreserveEhGcInfoList_size=DEFAULT_PRESERVED_EHGCINFO_SIZE;

EconoJitManager::JittedMethodInfoHdr* EconoJitManager::m_JittedMethodInfoHdr;
EconoJitManager::JittedMethodInfo*   EconoJitManager::m_JMIT_free;
EconoJitManager::Link*   EconoJitManager::m_JMIT_freelist;
EconoJitManager::PCToMDMap*          EconoJitManager::m_PcToMdMap;         
unsigned  EconoJitManager::m_PcToMdMap_len = 0;
unsigned  EconoJitManager::m_PcToMdMap_size = INITIAL_PC2MD_MAP_SIZE;
EconoJitManager::PC2MDBlock*  EconoJitManager::m_RecycledPC2MDMaps = NULL;
EconoJitManager::LargeEhGcInfoList* EconoJitManager::m_LargeEhGcInfo = NULL;

HINSTANCE           EconoJitManager::m_JITCompiler;
BYTE*     EconoJitManager::m_CodeHeap;
BYTE*     EconoJitManager::m_CodeHeapFree;
unsigned  EconoJitManager::m_CodeHeapCommittedSize;
unsigned  EconoJitManager::m_CodeHeapReservedSize;
unsigned  EconoJitManager::m_CodeHeapReserveIncrement;
unsigned  EconoJitManager::m_CodeHeapTargetSize;
EconoJitManager::EHGCBlockHdr*       EconoJitManager::m_EHGCHeap;
unsigned char*      EconoJitManager::m_EHGC_alloc_end;      // ptr to next free byte in current block
unsigned char*      EconoJitManager::m_EHGC_block_end;      // ptr to end of current block
Crst*               EconoJitManager::m_pHeapCritSec;
BYTE                EconoJitManager::m_HeapCritSecInstance[sizeof(Crst)];
Crst*               EconoJitManager::m_pRejitCritSec;
BYTE                EconoJitManager::m_RejitCritSecInstance[sizeof(Crst)];
Crst*               EconoJitManager::m_pThunkCritSec;
BYTE                EconoJitManager::m_ThunkCritSecInstance[sizeof(Crst)];
EconoJitManager::ThunkBlock*         EconoJitManager::m_ThunkBlocks;
EconoJitManager::PitchedCodeThunk*   EconoJitManager::m_FreeThunkList;
unsigned            EconoJitManager::m_cThunksInCurrentBlock;        // total number of thunks in current block
BOOL                EconoJitManager::m_PitchOccurred = false;
EjitStubManager*    EconoJitManager::m_stubManager = NULL;

EconoJitManager::TICKS               EconoJitManager::m_EjitStartTime;
EconoJitManager::TICKS               EconoJitManager::m_CumulativePitchOverhead=0;
EconoJitManager::TICKS               EconoJitManager::m_AveragePitchOverhead=MINIMUM_PITCH_OVERHEAD;
unsigned            EconoJitManager::m_cPitchCycles=0;      
#ifdef _DEBUG
DWORD               EconoJitManager::m_RejitLock_Holder = 0;
DWORD               EconoJitManager::m_AllocLock_Holder = 0; 
#endif

//#define DEBUG_LOG(str,size)  printf("\n%s - %x B",str,size)

unsigned EconoJitManager::minimum(unsigned x, unsigned y)
{
    return (x < y) ? x : y;
}
        
inline unsigned     EconoJitManager::InitialCodeHeapSize()
{
    return minimum(g_pConfig->GetMaxCodeCacheSize(),
               max(m_CodeHeapTargetSize, 
                   DEFAULT_CODE_HEAP_RESERVED_SIZE));
}

EconoJitManager::EconoJitManager()
{
    m_EjitStartTime = GET_TIMESTAMP();
    m_JittedMethodInfoHdr = NULL;
    m_PcToMdMap = new PCToMDMap[m_PcToMdMap_size];
    _ASSERTE(m_PcToMdMap);

    m_cThunksInCurrentBlock = 0;
    m_ThunkBlocks = NULL;
    m_FreeThunkList = NULL;
    m_JMIT_free = NULL;
    m_JMIT_freelist = NULL;
    InitializeCodeHeap();
    growJittedMethodInfoTable();
    m_EHGCHeap = NULL;
    m_EHGC_alloc_end = 0;
    m_EHGC_block_end = 0;
    m_pHeapCritSec = new  (&m_HeapCritSecInstance) Crst("EJitHeapCrst",CrstSingleUseLock);
    m_pRejitCritSec = new  (&m_RejitCritSecInstance) Crst("EJitRejitCrst",CrstClassInit, TRUE, FALSE);
    m_pThunkCritSec = new  (&m_ThunkCritSecInstance) Crst("EJitThunkCrst",CrstClassInit);
    m_next = NULL;
#ifdef SUPPORT_MAX_UNPITCHED_PER_THREAD
    m_MaxUnpitchedPerThread = g_pConfig->GetMaxUnpitchedPerThread();
#endif
    if ((m_PreserveCandidates = new pJittedMethodInfo[m_MaxUnpitchedPerThread]) != NULL)
    {
        m_PreserveCandidates_size = m_MaxUnpitchedPerThread;
        memset(m_PreserveCandidates,0,m_MaxUnpitchedPerThread*sizeof(void*));
    }

    // initialize buffer for collecting list of methodinfo's whose GC info is preserved during code pitch
    m_PreserveEhGcInfoList = new (throws) pJittedMethodInfo[DEFAULT_PRESERVED_EHGCINFO_SIZE];
    if (m_PreserveEhGcInfoList == NULL)
    {
        m_PreserveEhGcInfoList_size = 0;
    }

    m_stubManager = new (throws) EjitStubManager();
    StubManager::AddStubManager(m_stubManager);

}


EconoJitManager::~EconoJitManager()
{ 
    if (m_PcToMdMap)
        delete [] m_PcToMdMap;
    delete m_pHeapCritSec;
    delete m_pRejitCritSec;
    delete m_pThunkCritSec;
    if (m_PreserveCandidates)
        delete [] m_PreserveCandidates;
    delete m_stubManager;
    while (m_LargeEhGcInfo)
    {
        LargeEhGcInfoList* temp = m_LargeEhGcInfo;
        m_LargeEhGcInfo = m_LargeEhGcInfo->next;
        delete temp;
    }
#ifdef ENABLE_PERF_LOG
    double TickFrequency = (double) TICK_FREQUENCY();
    double totalExecTime = (double) (GET_TIMESTAMP() - m_EjitStartTime);
    
    PERFLOG((L"Total pitch overhead", ((double) m_CumulativePitchOverhead)/TickFrequency, SECONDS));
    PERFLOG((L"Total pitch cycles", m_cPitchCycles, CYCLES));
    PERFLOG((L"Avg. Pitch Overhead", ((double) m_AveragePitchOverhead)/TickFrequency, SECONDS));
    PERFLOG((L"Total Execution Time", totalExecTime/TickFrequency, SECONDS));

    PERFLOG((L"Total Code Heap Reserved",  m_CodeHeapReservedSize/1024, KBYTES));
    PERFLOG((L"Total Code Heap Committed", m_CodeHeapCommittedSize/1024, KBYTES));
    PERFLOG((L"Total EhGc Heap", m_EHGCHeap->blockSize/1024, KBYTES));
    
    JittedMethodInfoHdr* pJMIT = m_JittedMethodInfoHdr;
    unsigned jmitHeapSize = 0;
    while (pJMIT) {
        jmitHeapSize += JMIT_BLOCK_SIZE;
        pJMIT = pJMIT->next;
    }

    PERFLOG((L"Total JMIT Heap", jmitHeapSize/1024, KBYTES));

    unsigned thunkHeapSize = 0;
    ThunkBlock* thunkBlock = m_ThunkBlocks;
    while (thunkBlock) {
        thunkHeapSize += THUNK_BLOCK_SIZE;
        thunkBlock = thunkBlock->next;
    }
    
    PERFLOG((L"Total Thunk Heap", thunkHeapSize/1024, KBYTES));
    unsigned freePc2MDHeapSize = 0;
    
    PERFLOG((L"Total Pc2MD map", m_PcToMdMap_size/1024, KBYTES));
    PERFLOG((L"Total EJIT working set", (m_CodeHeapCommittedSize+m_EHGCHeap->blockSize+jmitHeapSize+thunkHeapSize+m_PcToMdMap_size)/1024, KBYTES));
#endif

	delete[] m_PreserveEhGcInfoList;

	ResetPc2MdMap();
}

void EconoJitManager::InitializeCodeHeap()
{    
    m_CodeHeapTargetSize = g_pConfig->GetTargetCodeCacheSize();
    _ASSERTE(m_CodeHeapTargetSize <= (unsigned) g_pConfig->GetMaxCodeCacheSize());
    unsigned initialCodeHeapSize =InitialCodeHeapSize();

    m_CodeHeap = (BYTE*) VirtualAlloc(NULL,
                                      initialCodeHeapSize,
                                      MEM_RESERVE,
                                      PAGE_EXECUTE_READWRITE);
    if (m_CodeHeap)
    {
        //DEBUG_LOG("ALLOC(InitialCodeHeap",initialCodeHeapSize);
        ExecutionManager::AddRange((LPVOID)m_CodeHeap, (LPVOID)((size_t)m_CodeHeap + initialCodeHeapSize),this, NULL);
        m_CodeHeapReservedSize = initialCodeHeapSize;
    }
    else
    {
        m_CodeHeapReservedSize =  0;
    }
    m_CodeHeapReserveIncrement = initialCodeHeapSize;
    _ASSERTE(m_CodeHeapReserveIncrement != 0);
    m_CodeHeapFree = m_CodeHeap;
    m_CodeHeapCommittedSize = 0;
}

__inline MethodDesc* EconoJitManager::JitCode2MethodDesc(SLOT currentPC, IJitManager::ScanFlag scanFlag)
{
    return JitCode2MethodDescStatic(currentPC);
}

MethodDesc* EconoJitManager::JitCode2MethodDescStatic(SLOT currentPC)
{
    // First see if currentPC is the stub address
    JittedMethodInfoHdr* pJMIT = m_JittedMethodInfoHdr;
    while (pJMIT) {
        if ((currentPC >= (SLOT)pJMIT) && 
            (currentPC < ((SLOT)pJMIT + JMIT_BLOCK_SIZE)))
        {// found it
            _ASSERTE(offsetof(JittedMethodInfo,JmpInstruction) == 0);
            return JitMethodInfo2MethodDesc((JittedMethodInfo*) currentPC);
        }
        pJMIT = pJMIT->next;
    }

    _ASSERTE(m_PcToMdMap_len);

    signed low, mid, high;
    low = 0;
    high = (m_PcToMdMap_len/ sizeof(PCToMDMap)) - 1;
    while (low < high) {
        // loop invariant
        _ASSERTE((size_t)m_PcToMdMap[high].pCodeEnd >= (size_t)currentPC );

        mid = (low+high)/2;
        if ( (size_t)m_PcToMdMap[mid].pCodeEnd < (size_t)currentPC ) {
            low = mid+1;
        }
        else {
            high = mid;
        }
    }
    _ASSERTE((size_t)m_PcToMdMap[low].pCodeEnd >= (size_t)currentPC);

    return m_PcToMdMap[low].pMD;
}

EconoJitManager::JittedMethodInfo*  EconoJitManager::JitCode2MethodInfo(SLOT currentPC)
{
    MethodDesc* pMD = JitCode2MethodDescStatic((SLOT) currentPC);

#ifdef EnC_SUPPORTED
    if (CORDebuggerAttached())
    {
        Module* module = pMD->GetModule();
        _ASSERTE(module);
        if (module->IsEditAndContinue())
        {
            JittedMethodInfo* jmi = JitCode2MethodTokenInEnCMode(currentPC);
            if (jmi) return jmi;
        }
    }
#endif // EnC_SUPPORTED

    const BYTE* stubAddr = pMD->GetNativeAddrofCode();
#ifdef _DEBUG
    // sanity check the stub address
    JittedMethodInfoHdr* pJMIT = m_JittedMethodInfoHdr;
    BOOL found = false;
    while (pJMIT) {
        if (((size_t)stubAddr >= (size_t)pJMIT) && 
            ((size_t)stubAddr < ((size_t)pJMIT) + JMIT_BLOCK_SIZE))
        {
            found = true;
            break;
        }
        pJMIT = pJMIT->next;
    }
    _ASSERTE(found);
#endif
    _ASSERTE(offsetof(JittedMethodInfo,JmpInstruction) == 0);
    return (JittedMethodInfo*) stubAddr;
    
}



void  EconoJitManager::JitCode2MethodTokenAndOffsetStatic(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset)
{

    ThunkBlock*  pThunkBlock = m_ThunkBlocks;
    while (pThunkBlock) 
    {
        _ASSERTE(pThunkBlock);
        if ((SLOT) pThunkBlock < currentPC && currentPC < ((SLOT)pThunkBlock+THUNK_BLOCK_SIZE))
        {
            // This is a thunk
            PitchedCodeThunk* pThunk = (PitchedCodeThunk*) ((size_t)currentPC & THUNK_BEGIN_MASK);
            *pMethodToken = (METHODTOKEN)pThunk->u.pMethodInfo;
            *pPCOffset = pThunk->relReturnAddress;
            return;
        }
        pThunkBlock=pThunkBlock->next;
    }  

    JittedMethodInfo* jittedMethodInfo = JitCode2MethodInfo(currentPC);
    _ASSERTE(jittedMethodInfo);
    *pMethodToken = (METHODTOKEN) jittedMethodInfo;
    if (IsInStub(currentPC, FALSE))
    {
        *pPCOffset = 0;
        return;
    }

    _ASSERTE(!(jittedMethodInfo->flags.JittedMethodPitched));   // error to call if method has been pitched

    CodeHeader* pCodeHeader = jittedMethodInfo->u1.pCodeHeader;
    _ASSERTE(pCodeHeader && (((size_t)pCodeHeader & 1) == 0));

    SLOT startAddress = (SLOT) (pCodeHeader+1);
    _ASSERTE(currentPC >= startAddress);
    *pPCOffset = (DWORD)(currentPC - startAddress);
}

void  EconoJitManager::JitCode2MethodTokenAndOffset(SLOT currentPC, METHODTOKEN* pMethodToken,DWORD* pPCOffset, ScanFlag scanFlag)
{
        JitCode2MethodTokenAndOffsetStatic(currentPC,pMethodToken,pPCOffset);
}

EconoJitManager::JittedMethodInfo*  EconoJitManager::JitCode2MethodTokenInEnCMode(SLOT currentPC)
{
    _ASSERTE(!m_PitchOccurred); // cannot support EnC and code pitching together
    JittedMethodInfoHdr* pJMIT = m_JittedMethodInfoHdr;
    unsigned max_jmi_index = (unsigned)((((size_t)m_JMIT_free - (size_t)(m_JittedMethodInfoHdr+1))/sizeof(JittedMethodInfo))-1);
    _ASSERTE(pJMIT);
    do {
        JittedMethodInfo* jmi = (JittedMethodInfo*) (pJMIT+1);
        _ASSERTE(!jmi[0].flags.JittedMethodPitched && !jmi[max_jmi_index].flags.JittedMethodPitched);

        if ((currentPC > (SLOT)jmi[0].u1.pCodeHeader) && 
            (currentPC < (SLOT)jmi[max_jmi_index].u2.pCodeEnd))
        {// found the block, now do a binary search

            signed low=0, high=max_jmi_index, mid;
            while (low < high) {
                // loop invariant
                _ASSERTE((size_t)jmi[low].u1.pCodeHeader < (size_t)currentPC );

                mid = (low+high)/2;
                if ( (size_t)jmi[mid].u2.pCodeEnd < (size_t)currentPC ) {
                    low = mid+1;
                }
                else {
                    high = mid;
                }
            }
            _ASSERTE(low == high);
            return &(jmi[low]); 
        }
        
        pJMIT = pJMIT->next;
        #define MAX_JMI_PER_BLOCK  (JMIT_BLOCK_SIZE - sizeof(JittedMethodInfoHdr))/sizeof(JittedMethodInfo)
        max_jmi_index = MAX_JMI_PER_BLOCK-1;
    } while (pJMIT);
    return NULL;
}

unsigned char* EconoJitManager::JitToken2StartAddress(METHODTOKEN MethodToken, ScanFlag scanFlag)
{
    return JitToken2StartAddressStatic(MethodToken);
}

unsigned char* EconoJitManager::JitToken2StartAddressStatic(METHODTOKEN MethodToken)
{
    JittedMethodInfo* jittedMethodInfo = (JittedMethodInfo*) MethodToken;  
    _ASSERTE(!(jittedMethodInfo->flags.JittedMethodPitched));   // error to call if method has been pitched

    CodeHeader* pCodeHeader = jittedMethodInfo->u1.pCodeHeader;
    _ASSERTE(pCodeHeader && ( ((size_t)pCodeHeader & 1) == 0));

    return (BYTE*) (pCodeHeader+1);
}

const BYTE* EconoJitManager::FollowStub(const BYTE* address)
{
#ifdef _X86_
    _ASSERTE(address[0] == CALL_OPCODE || address[0] == JMP_OPCODE || address[0] == BREAK_OPCODE);
    return (address+1 + (*(DWORD*) (address+1))+sizeof(void*)) ;
#else
    _ASSERTE(!"@TODO Alpha - EconoJitManager::FollowStub (EjitMgr.cpp)");
    return NULL;
#endif
}

BOOL EconoJitManager::IsInStub(const BYTE* address, BOOL fSearchThunks)
{
    JittedMethodInfoHdr* pJMIT = m_JittedMethodInfoHdr;
    while (pJMIT)
    {
        if ( ((BYTE*)pJMIT < address) && (address < ((BYTE*)pJMIT + JMIT_BLOCK_SIZE)) )
        {
            return true;       // the only way to be caught here is through an asynchronous exception
        }
        pJMIT = pJMIT->next;
    }

    if (fSearchThunks == TRUE )
    {
        ThunkBlock *ptb = m_ThunkBlocks;
        while( ptb!= NULL)
        {
            if(address>=(const BYTE*)ptb  && 
                address < ( ((const BYTE*)ptb)+THUNK_BLOCK_SIZE))
            {
                return true;
            }
            ptb = ptb->next;
        }
    }
    
    return false;
}

//
// Returns TRUE if the address is in a method that has been pitched.
//
BOOL EconoJitManager::IsCodePitched(const BYTE* address)
{
    METHODTOKEN methodToken;
    DWORD pcOffset;
    
    JitCode2MethodTokenAndOffsetStatic((SLOT)address,
                                       &methodToken,
                                       &pcOffset);

    _ASSERTE(methodToken != NULL);

    JittedMethodInfo *jmi = (JittedMethodInfo*)methodToken;

    return jmi->flags.JittedMethodPitched;
}


__inline MethodDesc* EconoJitManager::JitTokenToMethodDesc(METHODTOKEN MethodToken, ScanFlag scanFlag)
{
    return JitMethodInfo2MethodDesc((JittedMethodInfo*) MethodToken);
}

unsigned EconoJitManager::InitializeEHEnumeration(METHODTOKEN MethodToken, EH_CLAUSE_ENUMERATOR* pEnumState)
{
    JittedMethodInfo* jittedMethodInfo = (JittedMethodInfo*) MethodToken;
    if (jittedMethodInfo->flags.EHInfoExists == 0)      // if no eh with this method return 0
        return 0;
    _ASSERTE(jittedMethodInfo->flags.EHandGCInfoPitched == 0); // @TODO: Remove after EH pitching is implemented
    
    BYTE* EhInfo = jittedMethodInfo->u2.pEhGcInfo;
    if ((size_t)EhInfo & 1)
        EhInfo = (BYTE*) ((size_t)EhInfo & ~1);       // lose the mark bit
    else // code has not been pitched, and it is guaranteed to not be pitched while we are here
    {
        CodeHeader* pCodeHeader = jittedMethodInfo->u1.pCodeHeader;
        _ASSERTE(pCodeHeader && (( (size_t)pCodeHeader & 1) == 0));
        EH_OR_GC_INFO* EhGcInfo = (EH_OR_GC_INFO*) (pCodeHeader-1);
        EhInfo =  (BYTE*) (EhGcInfo->EH);
    }
    unsigned retval;
    // 2 bytes are used to encode length of EHinfo
    *pEnumState = 2 + EHEncoder::decode(EhInfo+2,&retval);     // read number of bytes used by encoded eh info
    _ASSERTE(retval);

    return retval;
    
}

EE_ILEXCEPTION_CLAUSE*  EconoJitManager::GetNextEHClause(METHODTOKEN MethodToken,
                                       EH_CLAUSE_ENUMERATOR* pEnumState, 
                                       EE_ILEXCEPTION_CLAUSE* pEHclause) 
{

    JittedMethodInfo* jittedMethodInfo = (JittedMethodInfo*) MethodToken;
    _ASSERTE(jittedMethodInfo->flags.EHInfoExists != 0);

    BYTE* EhInfo = jittedMethodInfo->u2.pEhGcInfo;
    if ((size_t)EhInfo & 1)
    {
        EhInfo = (BYTE*) ((size_t)EhInfo & ~1);       // lose the mark bit
    }
    else    // code has not been pitched, and it is guaranteed to not be pitched while we are here
    {
        CodeHeader* pCodeHeader = jittedMethodInfo->u1.pCodeHeader;
        _ASSERTE(pCodeHeader && (( (size_t)pCodeHeader & 1) == 0));
        EH_OR_GC_INFO* EhGcInfo = (EH_OR_GC_INFO*) (pCodeHeader-1);
        EhInfo = (BYTE*) (EhGcInfo->EH);
    }
    _ASSERTE(EhInfo);
    unsigned cBytes;
    cBytes = EHEncoder::decode(EhInfo+(*pEnumState),(CORINFO_EH_CLAUSE *) pEHclause);
    (*pEnumState) += cBytes;
    return pEHclause;

}

void  EconoJitManager::ResolveEHClause(METHODTOKEN MethodToken,
                                       EH_CLAUSE_ENUMERATOR* pEnumState, 
                                       EE_ILEXCEPTION_CLAUSE* pEHclause)
{
    // Resolve to class if defined in an *already loaded* scope. Don't cache in ejit for now
    JittedMethodInfo* jittedMethodInfo = (JittedMethodInfo*) MethodToken;
    Module *pModule = JitMethodInfo2MethodDesc(jittedMethodInfo)->GetModule();
    
    m_pHeapCritSec->Enter();
    if (! HasCachedEEClass(pEHclause))
    {
        NameHandle name(pModule, (mdToken)(size_t)pEHclause->pEEClass); // @TODO WIN64 - Pointer Truncation
        name.SetTokenNotToLoad(tdAllTypes);
        TypeHandle typeHnd = pModule->GetClassLoader()->LoadTypeHandle(&name);
        if (!typeHnd.IsNull())
        {
            pEHclause->pEEClass = typeHnd.GetClass();
            SetHasCachedEEClass(pEHclause);
        }
    }
    m_pHeapCritSec->Leave();
}

void* EconoJitManager::GetGCInfo(METHODTOKEN methodToken)
{
    JittedMethodInfo* jittedMethodInfo = (JittedMethodInfo*) methodToken;
    _ASSERTE(jittedMethodInfo->flags.GCInfoExists != 0);        // for now, we always emit GC info
    // Unfortunately I cant assert the following because there is one case where a thread might be
    // stopped in the ejit stub and the method may have been pitched.
    //_ASSERTE(!jittedMethodInfo->flags.EHandGCInfoPitched);

    // The following is still safe, because GC cannot be asking for this information since it
    // first needs to stop us in a safe place. So presumably HandledJitCase is asking for this info
    // to pass to the code manager. The fjit code manager always returns false (even if the debugger is
    // attached it will return false, since the stub is not a sequence point).
    if (jittedMethodInfo->flags.EHandGCInfoPitched)
        return 0;

    BYTE* pEhGcInfo = jittedMethodInfo->u2.pEhGcInfo;
    if ((size_t)pEhGcInfo & 1)
        pEhGcInfo = (BYTE*) ((size_t)pEhGcInfo & ~1);       // lose the mark bit
    else    // code has not been pitched, and it is guaranteed to not be pitched while we are here
    {
        CodeHeader* pCodeHeader = jittedMethodInfo->u1.pCodeHeader;
        _ASSERTE(pCodeHeader && (((size_t)pCodeHeader & 1) == 0));
        pEhGcInfo = *(BYTE**) (pCodeHeader-1);
    }
    _ASSERTE(pEhGcInfo);

    if (jittedMethodInfo->flags.EHInfoExists)
    {
        short cEHbytes = *(short*) pEhGcInfo;
        return (GC_INFO*) (pEhGcInfo + cEHbytes);
    }
    else
        return (GC_INFO*) pEhGcInfo;

}

BOOL  EconoJitManager::LoadJIT(LPCWSTR wzJITdll)
{
    return IJitManager::LoadJIT(wzJITdll);
}

void EconoJitManager::RemoveJitData (METHODTOKEN token)
{
    _ASSERTE(!"NYI");

}

// Class is being unloaded, so remove any info for this method
void EconoJitManager::Unload(MethodDesc *pFD)
{
    JittedMethodInfo* jmi = (JittedMethodInfo*)  pFD->GetAddrofCode();
    if (!jmi->flags.JittedMethodPitched)
        PitchAllJittedMethods(m_CodeHeapCommittedSize,m_CodeHeapCommittedSize,TRUE,TRUE);
    // link the freed jmi to the freelist
    jmi->flags.JittedMethodPitched = 0;
    jmi->flags.MarkedForPitching = 0;
    jmi->flags.EHInfoExists = 0;
    jmi->flags.GCInfoExists = 0;
    jmi->flags.EHandGCInfoPitched = 0;
    jmi->flags.Unused = 0;

#ifdef _DEBUG
    jmi->EhGcInfo_len = 0;
    jmi->u1.pCodeHeader = NULL;
#endif
    jmi->u1.pMethodDescriptor = NULL;

    // the freelist is protected by the m_pHeapCritSec
    m_pHeapCritSec->Enter();
    ((Link*)jmi)->next = m_JMIT_freelist;
    m_JMIT_freelist = (Link*) jmi;
    m_pHeapCritSec->Leave();
}

void RejitThunk();

void  EconoJitManager::ResumeAtJitEH(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack)
{
#ifdef _X86_

    METHODTOKEN token = pCf->GetMethodToken();
    BYTE* startAddress;
    if (IsMethodPitched(token))
    {
        PREGDISPLAY pRD = pCf->GetRegisterSet();
        m_pThunkCritSec->Enter();
        PitchedCodeThunk* thunk = GetNewThunk();
        thunk->Busy = true;
        thunk->LinkedInFreeList = false;
        thunk->retTypeProtect = MethodDesc::RETNONOBJ;
        thunk->CallInstruction[0] = CALL_OPCODE;
        void** callSite = (void**) &(thunk->CallInstruction[1]);
        *callSite = (void*) ((size_t)RejitThunk - (size_t)(callSite+1));
        thunk->relReturnAddress = (unsigned) EHClausePtr->HandlerStartPC;
        thunk->u.pMethodInfo = (JittedMethodInfo*) token;

        MachState ms((void**) pRD->pEdi, (void**) pRD->pEsi, (void**) pRD->pEbx, (void**) pRD->pEbp, 
                            (void*)(size_t)pRD->Esp, (void**) &thunk);
        m_pThunkCritSec->Leave();

        HelperMethodFrame HelperFrame(&ms, 0);
        OBJECTREF pExceptionObj = pThread->GetThrowable();
        GCPROTECT_BEGIN(pExceptionObj);
        startAddress =  RejitMethod((JittedMethodInfo*) token,0);
        _ASSERT(*(&pExceptionObj) == pThread->GetThrowable());
        GCPROTECT_END();
        HelperFrame.Pop();
    }
    else 
    {
        startAddress = JitToken2StartAddress(token);
    }
    ::ResumeAtJitEH(pCf,startAddress,EHClausePtr,nestingLevel,pThread, unwindStack);
#else // _X86_
    _ASSERTE(!"@TODO Alpha - EconoJitManager::ResumeAtJitEH (EjitMgr)");
#endif // _X86_
}

int  EconoJitManager::CallJitEHFilter(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj)
{
    METHODTOKEN token = pCf->GetMethodTo