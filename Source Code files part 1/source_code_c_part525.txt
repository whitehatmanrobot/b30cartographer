 // as well as the pending service state transition timer.
    //
    LOCK m_ServiceStateTransitionLock;


    // service state
    SERVICE_STATUS_HANDLE m_ServiceStatusHandle;
    SERVICE_STATUS m_ServiceStatus;


    // pending service state transition timer
    HANDLE m_PendingServiceStatusTimerHandle;


    // shared timer queue
    HANDLE m_SharedTimerQueueHandle;


    // time to exit work loop?
    BOOL m_ExitWorkLoop;


    // main worker thread ID
    DWORD m_MainWorkerThreadId;


    // for errors which occur on secondary threads
    HRESULT m_SecondaryThreadError;


    // tuck away the path to our DLL
    STRU m_CurrentDirectory;

    // Token Cache so we don't over duplicate token creation
    TOKEN_CACHE m_TokenCache;

    // the LocalSystem token we can use for starting worker processes
    TOKEN_CACHE_ENTRY * m_pLocalSystemTokenCacheEntry;

    // the LocalService token we can use for starting worker processes
    TOKEN_CACHE_ENTRY * m_pLocalServiceTokenCacheEntry;

    // the NetworkService token we can use for starting worker processes
    TOKEN_CACHE_ENTRY * m_pNetworkServiceTokenCacheEntry;

    // are we running in backward compatible mode?
    ENABLED_ENUM m_BackwardCompatibilityEnabled;

    // are we using centralized logging or site logging?
    ENABLED_ENUM m_CentralizedLoggingEnabled;

    // handle to the first instance of the named pipe
    HANDLE m_IPMPipe;

    //
    // Remembers when the service started (in seconds)
    //
    DWORD m_ServiceStartTime;

    //
    // Dispenser for getting things like the local system sid.
    CSecurityDispenser m_SecurityDispenser;

    //
    // HRESULT to report back if no other error is being reported on shutdown.
    HRESULT m_hrToReportToSCM;

    //
    // Flag that let's us know we are currently in the stopping code for the 
    // service and we should not try to attempt a new stop.
    //
    BOOL m_StoppingInProgress;

    DWORD m_ConfigWorkerThreadId;

    // 
    // Used to write logging errors for configuration.
    //
    WMS_ERROR_LOGGER  m_WMSLogger;

    // helper class for logging errors;
    WAS_ERROR_LOGGER m_ErrLogger;

    //
    // System Active Processor Mask
    DWORD_PTR m_SystemActiveProcessorMask;

    // 
    // Need flag to show that we have initialized
    // the static worker process code, otherwise
    // we don't want to clean it up or it will 
    // assert.
    BOOL  m_WPStaticInitialized;

    //
    // Need flag to show that we have initialized
    // the service lock, otherwise we av when we try
    // to use it during shutdown due to a startup error.
    BOOL  m_ServiceStateTransitionLockInitialized;

    //
    // Track number of started sites so we can 
    // tell on pro if we should start the next site.
    //
    DWORD m_NumSitesStarted;

    //
    // Remembers if we are running on PRO or not
    //
    BOOL m_fOnPro;

    //
    // Desktop to startup worker processes under.
    //
    STRU m_strWPDesktop;

    // Worker process desktop arguments
    //
    //
    HWINSTA m_hWPWinStation;
    HDESK   m_hWPDesktop;

};  // class WEB_ADMIN_SERVICE



#endif  // _WEB_ADMIN_SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\web_admin_service.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    web_admin_service.cxx

Abstract:

    The IIS web admin service class implementation.  

    Threading: The following public methods may be called on any thread:
        ~WEB_ADMIN_SERVICE()
        Reference()
        Dereference()
        GetWorkQueue()
        GetMainWorkerThreadId()
        GetServiceState()
        FatalErrorOnSecondaryThread()
        InterrogateService()
        InitiateStopService()
        InitiatePauseService()
        InitiateContinueService()
        UpdatePendingServiceStatus()
    All other public methods may be called only on the main worker thread.
    The ServiceControlHandler() and UpdatePendingServiceStatusCallback() 
    functions are called on secondary threads. 


Author:

    Seth Pollack (sethp)        23-Jul-1998

Revision History:

--*/



#include "precomp.h"



//
// local prototypes
//

// service control callback
VOID
ServiceControlHandler(
    IN DWORD OpCode
    );


// service status pending timer callback
VOID
UpdatePendingServiceStatusCallback(
    IN PVOID Ignored1,
    IN BOOLEAN Ignored2
    );


ULONG
CountOfBitsSet(
    IN DWORD_PTR Value
    );

/***************************************************************************++

Routine Description:

    Constructor for the WEB_ADMIN_SERVICE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WEB_ADMIN_SERVICE::WEB_ADMIN_SERVICE(
    )
    :
    m_WorkQueue(),
    m_UlAndWorkerManager(),
    m_ConfigAndControlManager(),
    m_EventLog( WEB_ADMIN_SERVICE_EVENT_SOURCE_NAME ),
    m_ServiceStateTransitionLock(),
    m_hrToReportToSCM ( S_OK ),
    m_SystemActiveProcessorMask ( 0 ),
    m_WPStaticInitialized ( FALSE ),
    m_ServiceStateTransitionLockInitialized ( FALSE ),
    m_NumSitesStarted( 0 ),
    m_fOnPro( FALSE ),
    m_hWPWinStation ( NULL ),
    m_hWPDesktop ( NULL )
{

    m_StoppingInProgress = FALSE;
   
    m_ConfigWorkerThreadId = 0;

    //
    // BUGBUG The event log constructor can fail. Lame. Best approach is 
    // to fix the EVENT_LOG class. On retail builds, we silently ignore;
    // the EVENT_LOG class does verify whether it has initialized correctly
    // when you try to log an event.
    //

    DBG_ASSERT( m_EventLog.Success() );


    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_ServiceStatusHandle = NULL_SERVICE_STATUS_HANDLE;


    //
    // Initialize the service status structure.
    //
    
    m_ServiceStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    m_ServiceStatus.dwCurrentState            = SERVICE_STOPPED;
    m_ServiceStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;
    m_ServiceStatus.dwWin32ExitCode           = NO_ERROR;
    m_ServiceStatus.dwServiceSpecificExitCode = NO_ERROR;
    m_ServiceStatus.dwCheckPoint              = 0;
    m_ServiceStatus.dwWaitHint                = 0;


    m_PendingServiceStatusTimerHandle = NULL;

    m_SharedTimerQueueHandle = NULL;


    m_ExitWorkLoop = FALSE;


    // the initializing main service thread will become our main worker thread
    m_MainWorkerThreadId = GetCurrentThreadId();


    m_SecondaryThreadError = S_OK;

    m_pLocalSystemTokenCacheEntry = NULL;

    m_pLocalServiceTokenCacheEntry = NULL;

    m_pNetworkServiceTokenCacheEntry = NULL;
        
    m_IPMPipe = NULL;
    
    m_BackwardCompatibilityEnabled = ENABLED_INVALID;

    m_CentralizedLoggingEnabled = ENABLED_INVALID;

    m_ServiceStartTime = 0;

    m_Signature = WEB_ADMIN_SERVICE_SIGNATURE;

}   // WEB_ADMIN_SERVICE::WEB_ADMIN_SERVICE



/***************************************************************************++

Routine Description:

    Destructor for the WEB_ADMIN_SERVICE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WEB_ADMIN_SERVICE::~WEB_ADMIN_SERVICE(
    )
{

    DBG_ASSERT( m_Signature == WEB_ADMIN_SERVICE_SIGNATURE );

    m_Signature = WEB_ADMIN_SERVICE_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    //
    // Note that m_ServiceStatusHandle doesn't have to be closed.
    //


    DBG_ASSERT( m_PendingServiceStatusTimerHandle == NULL );


    m_ServiceStateTransitionLock.Terminate();

    if (m_IPMPipe != NULL)
    {
        DBG_REQUIRE( CloseHandle( m_IPMPipe ) );
        m_IPMPipe = NULL;
    }

}   // WEB_ADMIN_SERVICE::~WEB_ADMIN_SERVICE



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // WEB_ADMIN_SERVICE::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in WEB_ADMIN_SERVICE, deleting, ptr: %p\n",
                this
                ));
        }


        //
        // Say goodbye.
        //

        delete this;
        
    }
    

    return;
    
}   // WEB_ADMIN_SERVICE::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in WEB_ADMIN_SERVICE: %p with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case StartWebAdminServiceWorkItem:
        hr = StartServiceWorkItem();
        break;

    case StopWebAdminServiceWorkItem:
        StopServiceWorkItem();
        break;

    case PauseWebAdminServiceWorkItem:
        hr = PauseServiceWorkItem();
        break;

    case ContinueWebAdminServiceWorkItem:
        hr = ContinueServiceWorkItem();
        break;

    case RecoverFromInetinfoCrashWebAdminServiceWorkItem:
        hr = RecoverFromInetinfoCrash();
        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
            
    }

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing work item on WEB_ADMIN_SERVICE failed\n"
            ));

    }

    return hr;
    
}   // WEB_ADMIN_SERVICE::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Execute the web admin service.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::ExecuteService(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = StartWorkQueue();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not start work queue\n"
            ));

        // If we fail here, then we don't want to go through
        // the cleanup below.  We are not going to get the server
        // up and running.
        return;
    }


    //
    // Enter the main work loop.
    //
    
    hr = MainWorkerThread();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Main work loop function returned an error\n"
            ));

        goto exit;
    }


exit:

    //
    // Need to flag that we are stopping the w3svc so we
    // don't attempt to stop it again.  This is because we may
    // not have told the w3svc that we intend on stopping, if we
    // are stopping due to an error.
    //
    m_StoppingInProgress = TRUE;

    //
    // Do final service cleanup.
    //

    TerminateServiceAndReportFinalStatus( hr );


    return;
    
}   // WEB_ADMIN_SERVICE::ExecuteService



/***************************************************************************++

Routine Description:

    Report a failure which occurred on a secondary thread, i.e. some thread 
    besides the main worker thread. The main worker thread will deal with 
    this error later.

    Note that this routine may be called from any thread. It should not be 
    called by the main work thread however; errors on the main worker thread
    are dealt with in the main work loop.

Arguments:

    SecondaryThreadError - The error which occurred on the secondary thread.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::FatalErrorOnSecondaryThread(
    IN HRESULT SecondaryThreadError
    )
{

    // verify we are NOT on the main worker thread
    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );

    //
    // Note that we only capture the most recent error, not the first one
    // that occurred.
    //
    // Also, no explicit synchronization is necessary on this thread-shared 
    // variable because this is an aligned 32-bit write.
    //

    m_SecondaryThreadError = SecondaryThreadError;

    return;

}   // WEB_ADMIN_SERVICE::FatalErrorOnSecondaryThread



/***************************************************************************++

Routine Description:

    Handle a request for a status update from the service controller. Done
    directly on a secondary thread. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InterrogateService(
    )
{

    HRESULT hr = S_OK;


    m_ServiceStateTransitionLock.Lock();


    //
    // Note: this command is accepted while the service is in any state.
    //


    hr = ReportServiceStatus();
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't report the service status\n"
            ));

    }


    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::InterrogateService

/***************************************************************************++

Routine Description:

    If we are in backward compatible mode this will either tell the service
    that we failed to start and gracefully get us out of any situation we
    are in, or it will register that we have started successfully.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::InetinfoRegistered(
    )
{
    HRESULT hr;
    DBG_ASSERT(m_BackwardCompatibilityEnabled == ENABLED_TRUE);

    // 
    // Only notify the service control manager that 
    // the service has finished starting, if the
    // service is is still sitting in the pending state.
    // 
    // If inetinfo recycles this code will get called
    // but since we have not told the service to stop
    // while inetinfo is recycling we don't want to tell
    // it that it has started again.
    //
    
    // ISSUE-2000/07/21-emilyk:  Use Service Pending?
    //          Maybe we want to change the service to 
    //          paused and back again when inetinfo recycles.

    if (m_ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        hr = FinishStartService();
        if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Couldn't finish the start service\n"
                ));

        }
    }


}   // WEB_ADMIN_SERVICE::InetinfoRegistered

/***************************************************************************++

Routine Description:

    Begin stopping the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitiateStopService(
    )
{
    
    return RequestStopService ( TRUE );

}   // WEB_ADMIN_SERVICE::InitiateStopService

/***************************************************************************++

Routine Description:

    Begin stopping the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    EnableStateCheck - lets us know if we want to only allow this call when
                       the service is not in a pending state.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::RequestStopService(
    BOOL EnableStateCheck
    )
{

    HRESULT hr = S_OK;

    //
    // If we are all ready stopping then we don't need to 
    // initiate another stop.
    //
    if ( m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ||
         m_StoppingInProgress ) 
    {
        return S_OK;
    }

    hr = BeginStateTransition( SERVICE_STOP_PENDING, EnableStateCheck );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't transition to service stop pending\n"
            ));

        goto exit;
    }

    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            StopWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue stop service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::RequestStopService

/***************************************************************************++

Routine Description:

    Begin pausing the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitiatePauseService(
    )
{

    HRESULT hr = S_OK;


    hr = BeginStateTransition( SERVICE_PAUSE_PENDING, TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't transition to service pause pending\n"
            ));

        goto exit;
    }


    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            PauseWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue pause service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitiatePauseService



/***************************************************************************++

Routine Description:

    Begin continuing the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitiateContinueService(
    )
{

    HRESULT hr = S_OK;


    hr = BeginStateTransition( SERVICE_CONTINUE_PENDING, TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't transition to service continue pending\n"
            ));

        goto exit;
    }


    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            ContinueWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue continue service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitiateContinueService



/***************************************************************************++

Routine Description:

    Keep the service controller happy by continuing to update it regularly
    on the status of any pending service state transition.

    There are several possible cases. If we are still in a pending state
    (whether it is the original pending state, or even a different pending 
    state which can arise because a new operation was started), we go ahead
    and update the service controller. However, it is also possible that the
    state transition just finished, but that this call was already underway. 
    In this case, we do nothing here.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::UpdatePendingServiceStatus(
    )
{

    HRESULT hr = S_OK;


    m_ServiceStateTransitionLock.Lock();


    // see if we are still in a pending service state

    if ( IsServiceStateChangePending() )
    {

        m_ServiceStatus.dwCheckPoint++;


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Updating the service state checkpoint to: %lu\n",
                m_ServiceStatus.dwCheckPoint
                ));
        }

        hr = ReportServiceStatus();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not report service status\n"
                ));

        }

    }
    else
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Ignoring pending service status timer, not in pending state. State: %lu\n",
                m_ServiceStatus.dwCurrentState
                ));
        }

    }


    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::UpdatePendingServiceStatus

/***************************************************************************++

Routine Description:

    Queues a work item to recover from the inetinfo crash.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::QueueRecoveryFromInetinfoCrash(
    )
{

    HRESULT hr = S_OK;

    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            RecoverFromInetinfoCrashWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue the recovery from the inetinfo crash \n"
            ));

    }


    return hr;

}   // WEB_ADMIN_SERVICE::RequestStopService


/***************************************************************************++

Routine Description:

    Used by the UL&WM to notify that it has finished it's shutdown work. 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::UlAndWorkerManagerShutdownDone(
    )
{
    FinishStopService();

}   // WEB_ADMIN_SERVICE::UlAndWorkerManagerShutdownDone



/***************************************************************************++

Routine Description:

    Initializes the work queue, and then posts the work item to start the 
    service.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::StartWorkQueue(
    )
{

    HRESULT hr = S_OK;


    // 
    // Just initialize the work queue here. Postpone all other initialization
    // until we're in StartServiceWorkItem().
    //
    
    hr = m_WorkQueue.Initialize();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't initialize work queue\n"
            ));

        goto exit;
    }


    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            StartWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue start service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::StartWorkQueue



/***************************************************************************++

Routine Description:

    The work loop for the main worker thread.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::MainWorkerThread(
    )
{

    HRESULT hr = S_OK;


    //
    // CODEWORK Consider changing error handling strategy to not exit in
    // the case of an error that bubbles up here, to the top of the loop. 
    //


    while ( ! m_ExitWorkLoop )
    {

        hr = m_WorkQueue.ProcessWorkItem();
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Processing work item failed\n"
                ));

            //
            // If there was an unhandled error while processing the work item,
            // bail out of the work loop.
            //

            m_ExitWorkLoop = TRUE;

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Exiting main work loop due to error on main worker thread\n"
                ));
        }
        else
        {

            //
            // See how the other threads are doing.
            //
            // If there has been an unhandled error on a secondary thread
            // (i.e. other threads besides the main worker thread) since the 
            // last trip through the work loop, get the error and bail out of 
            // the work loop.
            //
            // This means that a secondary thread error may not be processed
            // for some time after it happens, because something else has to
            // wake up the main worker thread off of its completion port to
            // send it back through this loop. This seems preferable however
            // to making the main worker thread wake up periodically to check,
            // which would prevent it from getting paged out.
            //
            // Note that no explicit synchronization is used in accessing this 
            // thread-shared variable, because it is an aligned 32-bit read.
            //

            if ( FAILED( m_SecondaryThreadError ) )
            {
            
                hr = m_SecondaryThreadError;
                
                m_ExitWorkLoop = TRUE;

                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Exiting main work loop due to error on secondary thread\n"
                    ));

            }
            
        }
        
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Main worker thread has exited it's work loop\n"
            ));
    }

    return hr;

}   // WEB_ADMIN_SERVICE::MainWorkerThread



/***************************************************************************++

Routine Description:

    Begin starting the web admin service. Register the service control 
    handler, set the service state to pending, and then kick off the real 
    work.
    
Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::StartServiceWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = InitializeInternalComponents();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing internal components failed\n"
            ));

        goto exit;
    }

    hr = BeginStateTransition( SERVICE_START_PENDING, TRUE );
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't transition to service start pending\n"
            ));

        goto exit;
    }

    hr = SetOnPro();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't figure out what version of the OS is running\n"
            ));

        goto exit;
    }

    SetBackwardCompatibility();

    //
    // Start up the other components of the service.
    //

    hr = InitializeOtherComponents();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't initialize subcomponents\n"
            ));

        goto exit;
    }

    if (m_BackwardCompatibilityEnabled == ENABLED_FALSE)
    {
        //
        // Only finish starting the service if we are not
        // in backward compatibility mode.  If we are then 
        // we need to wait to finish until the worker process
        // answers back.
        //

        hr = FinishStartService();
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Finishing start service state transition failed\n"
                ));

            goto exit;
        }
    }
    else
    {
        //
        // Demand start the worker process before marking the
        // service as started.  If there is a problem with the 
        // worker process coming up, then the service will be shutdown.
        //

        hr = m_UlAndWorkerManager.StartInetinfoWorkerProcess();
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to start the worker process in inetinfo\n"
                ));

            goto exit;
        }
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::StartServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the started state.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishStartService(
    )
{

    HRESULT hr = S_OK;

    hr = FinishStateTransition( SERVICE_RUNNING, SERVICE_START_PENDING );
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't finish transition into the running state\n"
            ));

    }

    m_ServiceStartTime = GetCurrentTimeInSeconds();

    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishStartService



/***************************************************************************++

Routine Description:

    Stop the web admin service. 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::StopServiceWorkItem(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // If we are all ready stopping don't go
    // through these stopping steps.  We can't use
    // the state of the service here because 
    // it is not deterministic of whether we have
    // all ready gone to far in the stopping 
    // stages to start stopping again.
    //

    if ( m_StoppingInProgress )
    {
        return;
    }

    m_StoppingInProgress = TRUE;

    Shutdown();


    //
    // Note that FinishStopService() will be called by the method
    // UlAndWorkerManagerShutdownDone() once the UL&WM's shutdown work 
    // is complete.
    //

}   // WEB_ADMIN_SERVICE::StopServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the stopped state.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::FinishStopService(
    )
{

    //
    // Since we are done with regular service spindown, its time to exit
    // the main work loop, so that we can do our final cleanup. 
    //

    m_ExitWorkLoop = TRUE;
    
}   // WEB_ADMIN_SERVICE::FinishStopService



/***************************************************************************++

Routine Description:

    Begin pausing the web admin service. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::PauseServiceWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    m_UlAndWorkerManager.ControlAllSites( MD_SERVER_COMMAND_PAUSE );

    hr = FinishPauseService();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finishing pause service state transition failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::PauseServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the paused state.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishPauseService(
    )
{

    HRESULT hr = S_OK;


    hr = FinishStateTransition( SERVICE_PAUSED, SERVICE_PAUSE_PENDING );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't finish transition into the paused state\n"
            ));

    }


    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishPauseService



/***************************************************************************++

Routine Description:

    Begin continuing the web admin service. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::ContinueServiceWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    m_UlAndWorkerManager.ControlAllSites( MD_SERVER_COMMAND_CONTINUE );

    hr = FinishContinueService();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finishing continue service state transition failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::ContinueServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the running state via continue.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishContinueService(
    )
{

    HRESULT hr = S_OK;


    hr = FinishStateTransition( SERVICE_RUNNING, SERVICE_CONTINUE_PENDING );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't finish transition into the running state\n"
            ));

    }


    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishContinueService



/***************************************************************************++

Routine Description:

    Set the new service (pending) state, and start the timer to keep the 
    service controller happy while the state transition is pending.

Arguments:

    NewState - The pending state into which to transition.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::BeginStateTransition(
    IN DWORD NewState,
    IN BOOL  EnableStateCheck
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    // default the wait hint to the wait hint for everything
    // except the start up wait hint.
    DWORD dwWaitHint = WEB_ADMIN_SERVICE_STATE_CHANGE_WAIT_HINT;

    //
    // If we are starting then we are in a special case
    // we are not going to use the timers to keep us alive
    // we are just going to set a really large wait hint.
    //
    if ( NewState == SERVICE_START_PENDING )
    {
        //
        // Since we only start the service once for life of the svchost, 
        // we will only read from the registry once.
        //
        dwWaitHint = ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_STARTUP_WAIT_HINT, 0 );
        if ( dwWaitHint == 0 )
        {
            dwWaitHint = WEB_ADMIN_SERVICE_STARTUP_WAIT_HINT;
        }

    }
        
    m_ServiceStateTransitionLock.Lock();

    if ( IsServiceStateChangePending() && EnableStateCheck )
    {
        hr = HRESULT_FROM_WIN32( ERROR_SERVICE_CANNOT_ACCEPT_CTRL );
        goto exit;
    }

    // while we are in pending states we will not accept any 
    // other controls.  We will change to accept controls once
    // we have finished changing the state.
    m_ServiceStatus.dwControlsAccepted        = 0;


    hr = UpdateServiceStatus(
                NewState,
                NO_ERROR,
                NO_ERROR,
                1,
                dwWaitHint
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't set service status\n"
            ));

            goto exit;
    }
    
    if ( m_PendingServiceStatusTimerHandle != NULL ||
         NewState == SERVICE_START_PENDING )
    {
        //
        // If we all ready have a timer or if we are doing a start
        // we don't need to start a new timer.  The only place where
        // we may end up using the old timer is if we start shutting down 
        // due to a WP error in BC mode and are currently all ready in 
        // the middle of a continue or pause operation.
        //

        // Issue-EmilyK-3/13/2001  Service state changing investigation
        //      :  Have not actually checked how well this works if we do
        //         get a shutdown while in middle of a continue or pause.
        //         Then again, continue and pause still need attention in 
        //         general.
        
        goto exit;
    }

    // start the service status pending update timer

    DBG_ASSERT( m_SharedTimerQueueHandle != NULL );

    //
    // we have had one av from here, so I am be cautious.  I have also fixed
    // the reason we hit here with a null handle.
    // if we skip this we just won't update our stopping wait hints. better than
    // av'ing...
    //
    if ( m_SharedTimerQueueHandle )
    {
        Status = RtlCreateTimer(
                        m_SharedTimerQueueHandle,   // timer queue
                        &m_PendingServiceStatusTimerHandle,         
                                                    // returned timer handle
                        &UpdatePendingServiceStatusCallback,
                                                    // callback function
                        this,                       // context
                        WEB_ADMIN_SERVICE_STATE_CHANGE_TIMER_PERIOD,
                                                    // initial firing time
                        WEB_ADMIN_SERVICE_STATE_CHANGE_TIMER_PERIOD,
                                                    // subsequent firing period
                        WT_EXECUTEINWAITTHREAD      // execute callback directly
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not create timer\n"
                ));

            goto exit;
        }
    }


exit:

    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::BeginStateTransition



/***************************************************************************++

Routine Description:

    Complete the service state change from one of the pending states into
    the matching completed state. Note that it is possible that another, 
    different service state change operation has happened in the meantime.
    In this case, we detect that another operation has happened, and bail
    out without doing anything. In the standard case however, we shut down 
    the timer which was keeping the service controller happy during the 
    pending state, and set the new service state.

Arguments:

    NewState - The new service state to change to, if the service state is 
    still as expected.

    ExpectedPreviousState - What the service state must currently be in order
    to make the change.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishStateTransition(
    IN DWORD NewState,
    IN DWORD ExpectedPreviousState
    )
{

    HRESULT hr = S_OK;


    m_ServiceStateTransitionLock.Lock();


    // 
    // See if we're still in the expected pending state, or if some other
    // state transition has occurred in the meantime.
    //
    
    if ( m_ServiceStatus.dwCurrentState != ExpectedPreviousState )
    {
    
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Not changing service state to: %lu, because current state is: %lu, was expected to be: %lu\n",
                NewState,
                m_ServiceStatus.dwCurrentState,
                ExpectedPreviousState
                ));
        }

        goto exit;
    }


    hr = CancelPendingServiceStatusTimer( FALSE );
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not cancel timer\n"
            ));

        goto exit;
    }

    //
    // Once we are finishing the state transition we will 
    // once again accept controls for the service.
    //
    m_ServiceStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;


    hr = UpdateServiceStatus(
                NewState,
                NO_ERROR,
                NO_ERROR,
                0,
                0
                );

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not update service status\n"
            ));

        goto exit;
    }


exit:

    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishStateTransition



/***************************************************************************++

Routine Description:

    Determine whether the service is in a pending state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if the service is in a pending state, FALSE otherwise.

--***************************************************************************/

BOOL
WEB_ADMIN_SERVICE::IsServiceStateChangePending(
    )
    const
{

    if ( m_ServiceStatus.dwCurrentState == SERVICE_START_PENDING   ||
         m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING    ||
         m_ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING   ||
         m_ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}   // WEB_ADMIN_SERVICE::IsServiceStateChangePending



/***************************************************************************++

Routine Description:

    Update the local copy of the service status structure, and report it 
    to the service controller.

Arguments:

    State - The service state.

    Win32ExitCode - Service error exit code. NO_ERROR when not used.

    ServiceSpecificExitCode - A service specific error exit code. If this 
    field is used, the Win32ExitCode parameter above must be set to the
    value ERROR_SERVICE_SPECIFIC_ERROR. This parameter should be set to
    NO_ERROR when not used.

    CheckPoint - Check point for lengthy state transitions. Should be
    incremented periodically during pending operations, and zero otherwise.

    WaitHint - Wait hint in milliseconds for lengthy state transitions.
    Should be zero otherwise.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::UpdateServiceStatus(
    IN DWORD State,
    IN DWORD Win32ExitCode,
    IN DWORD ServiceSpecificExitCode,
    IN DWORD CheckPoint,
    IN DWORD WaitHint
    )
{

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Setting service state to: %lu; state was: %lu\n",
            State,
            m_ServiceStatus.dwCurrentState
            ));
    }

    m_ServiceStatus.dwCurrentState = State;
    m_ServiceStatus.dwWin32ExitCode = Win32ExitCode;
    m_ServiceStatus.dwServiceSpecificExitCode = ServiceSpecificExitCode;
    m_ServiceStatus.dwCheckPoint = CheckPoint;
    m_ServiceStatus.dwWaitHint = WaitHint;

    return ReportServiceStatus();

} // WEB_ADMIN_SERVICE::UpdateServiceStatus()



/***************************************************************************++

Routine Description:

    Wraps the call to the SetServiceStatus() function, passing in the local 
    copy of the service status structure.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::ReportServiceStatus(
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;


    // ensure the service status handle has been initialized
    if ( m_ServiceStatusHandle == NULL_SERVICE_STATUS_HANDLE )
    {
        DBGPRINTF(( 
            DBG_CONTEXT,
            "Can't report service status because m_ServiceStatusHandle is null\n"
            ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE );

        goto exit;
    }


    //
    // Note: If we are setting the state to SERVICE_STOPPED, and we are
    // currently the only active service in this process, then at any
    // point after this call svchost.exe may call TerminateProcess(), thus
    // preventing our service from finishing its cleanup. As they say, 
    // that's just the way it is...
    //
    // GeorgeRe, 2000/08/10: This assertion appears to be ill-founded.
    // svchost.exe calls ExitProcess, not TerminateProcess. This provides
    // a more graceful shutdown path.
    //

    if ( m_ServiceStatus.dwCurrentState == SERVICE_STOPPED )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Setting SERVICE_STOPPED state, process may now exit at will\n"
                ));
        }
    }


    Success = SetServiceStatus(
                    m_ServiceStatusHandle, 
                    &m_ServiceStatus
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting service state failed\n"
            ));

        goto exit;
    }


exit:

    return hr;
    
}   // WEB_ADMIN_SERVICE::ReportServiceStatus()


/***************************************************************************++

Routine Description:

    Initialize internal components of this instance. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitializeInternalComponents(
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // Determine if we should break here early in startup for debugging
    // purposes. 
    //

#if DBG

    if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_STARTUP_W, 0 ) )
    {
        DBG_ASSERT ( FALSE );
    }

#endif // DBG

    //
    // Check if the override is on, and if it is not, turn off the debug 
    // spew for the WMS Object.
    //
    if ( !ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_ALLOW_WMS_SPEW, 0 ) )
    {
        // turn off the WMS spew
        IF_DEBUG ( WEB_ADMIN_SERVICE_WMS )
        {
            g_dwDebugFlags = g_dwDebugFlags & ( 0xFFFFFFFF - DEBUG_WEB_ADMIN_SERVICE_WMS );
        }

        // turn off the timer and queue spew
        IF_DEBUG ( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            g_dwDebugFlags = g_dwDebugFlags & ( 0xFFFFFFFF - DEBUG_WEB_ADMIN_SERVICE_TIMER_QUEUE );
        }

    }



    //
    // Bump up the priority of the main worker thread slightly. We want to
    // make sure it is responsive to the degree possible (even in the face
    // of runaway worker processes, etc.).
    //

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    Success = SetThreadPriority(
                    GetCurrentThread(),             // handle to the thread
                    THREAD_PRIORITY_ABOVE_NORMAL    // thread priority level
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting thread priority failed\n"
            ));

        goto exit;
    }


    //
    // Initialize the service state lock.
    //

    hr = m_ServiceStateTransitionLock.Initialize();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Lock initialization failed\n"
            ));

        goto exit;
    }

    m_ServiceStateTransitionLockInitialized = TRUE;
   

    //
    // Register the service control handler.
    //

    m_ServiceStatusHandle = RegisterServiceCtrlHandler(
                                WEB_ADMIN_SERVICE_NAME_W,   // service name
                                ServiceControlHandler       // handler function
                                );

    if ( m_ServiceStatusHandle == NULL_SERVICE_STATUS_HANDLE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't register service control handler\n"
            ));

        goto exit;
    }

    g_RegisterServiceCalled = TRUE;


    //
    // Create the timer queue.
    //

    Status = RtlCreateTimerQueue( &m_SharedTimerQueueHandle );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not create timer queue\n"
            ));

        goto exit;
    }


    //
    // Determine and cache the path to where our service DLL lives.
    //

    hr = DetermineCurrentDirectory();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Determining current directory failed\n"
            ));

        goto exit;
    }


    //
    // Create and cache the various tokens with which we can create worker 
    // processes.
    //

    hr = CreateCachedWorkerProcessTokens();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating cached worker process tokens failed\n"
            ));

        goto exit;
    }
       
    //
    // IISUtil initialization 
    //

    Success = InitializeIISUtil();
    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not initialize iisutil\n"
            ));

        goto exit;
    }

    hr = WORKER_PROCESS::StaticInitialize();

    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not initialize WORKER_PROCESS\n"
            ));

        goto exit;
    }

    m_WPStaticInitialized = TRUE;

exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitializeInternalComponents

/***************************************************************************++

Routine Description:

    Called only once, this routine will remember if we are 
    running on Windows XP Professional.

Arguments:

    None.

Return Value:

    HRESULT 

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::SetOnPro(
    )
{

    OSVERSIONINFOEX  VersionInfo;

    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx( (LPOSVERSIONINFOW) (&VersionInfo) ) )
    {
        if ( VersionInfo.wProductType == VER_NT_WORKSTATION )
        {
            m_fOnPro = TRUE;
        }
        else
        {
            m_fOnPro = FALSE;
        }
    }
    else
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;

}   // WEB_ADMIN_SERVICE::SetOnPro

/***************************************************************************++

Routine Description:

    Called only once, this routine will remember if we are in backward
    compatibility mode or not.

Arguments:

    None.

Return Value:

    VOID 

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::SetBackwardCompatibility(
    )
{

    //
    //  Since this function is called only once, we should
    //  assert that no one else has enabled our flag yet.
    //

    DBG_ASSERT(m_BackwardCompatibilityEnabled == ENABLED_INVALID);

    if ( IsSSLReportingBackwardCompatibilityMode() )
    {
        m_BackwardCompatibilityEnabled = ENABLED_TRUE;
    }
    else
    {
        m_BackwardCompatibilityEnabled = ENABLED_FALSE;
    }

}   // WEB_ADMIN_SERVICE::SetBackwardCompatibility

/***************************************************************************++

Routine Description:

    Called only once, this routine will remember if we are doing only
    centralized logging, or site logging

Arguments:

    BOOL CentralizedLoggingEnabled  -  is centralized logging enabled.

Return Value:

    VOID

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::SetGlobalBinaryLogging(
    BOOL CentralizedLoggingEnabled
    )
{

    //
    //  Since this function is called only once, we should
    //  assert that no one else has enabled our flag yet.
    //

    DBG_ASSERT(m_CentralizedLoggingEnabled == ENABLED_INVALID);

    if ( CentralizedLoggingEnabled )
    {
        m_CentralizedLoggingEnabled = ENABLED_TRUE;
    }
    else
    {
        m_CentralizedLoggingEnabled = ENABLED_FALSE;
    }

}   // WEB_ADMIN_SERVICE::SetGlobalBinaryLogging

/***************************************************************************++

Routine Description:

    Determine and cache the path to where this service DLL resides. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::DetermineCurrentDirectory(
    )
{

    HRESULT hr = S_OK;
    HMODULE ModuleHandle = NULL;
    WCHAR ModulePath[ MAX_PATH ];
    DWORD Length = 0;
    LPWSTR pEnd = NULL;


    //
    // Determine the directory where our service DLL lives. 
    // Do this by finding the fully qualified path to our DLL, then
    // trimming. 
    //

    ModuleHandle = GetModuleHandle( WEB_ADMIN_SERVICE_DLL_NAME_W );
    if ( ModuleHandle == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't get module handle\n"
            ));

        goto exit;
    }

    Length = GetModuleFileNameW(
                ModuleHandle,
                ModulePath,
                sizeof( ModulePath ) / sizeof( ModulePath[0] )
                );

    // Null terminate it just to make sure it is null terminated.
    ModulePath[MAX_PATH-1] = L'\0';

    if ( Length == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Getting module file name failed\n"
            ));

        goto exit;
    }


    //
    // Truncate it just past the final separator.
    //

    pEnd = wcsrchr( ModulePath, L'\\' );
    if ( pEnd == NULL )
    {
        DBG_ASSERT( pEnd != NULL );

        // We expect to find the last separator.  If
        // we don't something is really wrong.
        hr = E_UNEXPECTED;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed finding the final separator.\n"
            ));

        goto exit;

    }

    // if we found a slash, then there is atleast a null
    // following it, so we will not worry about writing beyond
    // the end of the string.
    pEnd[1] = L'\0';

    //
    // Build a STRU object representing it.
    //

    hr = m_CurrentDirectory.Append( ModulePath );
    if (FAILED(hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }

    DBG_ASSERT( m_CurrentDirectory.QueryCCH() > 0 );
    DBG_ASSERT( m_CurrentDirectory.QueryStr()[ m_CurrentDirectory.QueryCCH() - 1 ] == L'\\' );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Current directory: %S\n",
            m_CurrentDirectory.QueryStr()
            ));
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::DetermineCurrentDirectory



/***************************************************************************++

Routine Description:

    Create and cache the two tokens under which we might create worker 
    processes: the LocalSystem token, and a reduced privilege token. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::CreateCachedWorkerProcessTokens(
    )
{

    HRESULT hr      = S_OK;
    DWORD   dwErr   = ERROR_SUCCESS;
    DWORD   dwLogonError;

    hr = m_TokenCache.Initialize();
    if (FAILED(hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the TokenCache\n"
            ));

        goto exit;
    }

    //
    // First, get and cache the LocalSystem token. For this, we simply
    // use our own process token (i.e. LocalSystem).
    //

    DBG_ASSERT( m_pLocalSystemTokenCacheEntry == NULL );

    hr = m_TokenCache.GetCachedToken(
                    L"LocalSystem",             // user name
                    L"NT AUTHORITY",            // domain
                    L"",                        // password
                    (DWORD) IIS_LOGON_METHOD_LOCAL_SYSTEM, // we want a local system token
                    FALSE,                      // do not use subauth
                    FALSE,                      // not UPN logon
                    NULL,                       // do not register remote IP addr
                    &m_pLocalSystemTokenCacheEntry,        // returned token handle
                    &dwLogonError               // LogonError storage
                    );            

    DBG_ASSERT(NULL != m_pLocalSystemTokenCacheEntry || 
              (NULL == m_pLocalSystemTokenCacheEntry && 0 != dwLogonError));

    if ( FAILED(hr) || 
         ( NULL == m_pLocalSystemTokenCacheEntry &&
           FAILED( hr = HRESULT_FROM_WIN32( dwLogonError ) ) )
       )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to get the LocalSystem Token\n"
            ));

        goto exit;
    }

    dwErr = m_SecurityDispenser.AdjustTokenForAdministrators( 
                                       m_pLocalSystemTokenCacheEntry->QueryPrimaryToken() );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not adjust the local system token to allow administrator rights\n"
            ));

        goto exit;
    }

    //
    // Save tokens for the LocalService user
    //
    DBG_ASSERT( m_pLocalServiceTokenCacheEntry == NULL );
    
    hr = m_TokenCache.GetCachedToken(
                    L"LocalService",            // user name
                    L"NT AUTHORITY",            // domain
                    L"",                        // password
                    LOGON32_LOGON_SERVICE,      // type of logon
                    FALSE,                      // do not use subauth
                    FALSE,                      // not UPN logon
                    NULL,                       // do not register remote IP addr
                    &m_pLocalServiceTokenCacheEntry,        // returned token handle
                    &dwLogonError              // LogonError storage
                    );
    DBG_ASSERT(NULL != m_pLocalServiceTokenCacheEntry || 
              (NULL == m_pLocalServiceTokenCacheEntry && 0 != dwLogonError));
    if ( FAILED(hr) || 
         ( NULL == m_pLocalServiceTokenCacheEntry &&
           FAILED( hr = HRESULT_FROM_WIN32( dwLogonError ) ) )
       )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to get the LocalService token.\n"
            ));

        goto exit;
    }

    dwErr = m_SecurityDispenser.AdjustTokenForAdministrators( 
                                       m_pLocalServiceTokenCacheEntry->QueryPrimaryToken() );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not adjust the local service token to allow administrator rights\n"
            ));

        goto exit;
    }

    // 
    // Save tokens for the Network_Service user.
    //

    DBG_ASSERT( m_pNetworkServiceTokenCacheEntry == NULL );
    
    hr = m_TokenCache.GetCachedToken(
                    L"NetworkService",          // user name
                    L"NT AUTHORITY",            // domain
                    L"",                        // password
                    LOGON32_LOGON_SERVICE,      // type of logon
                    FALSE,                      // do not use subauth
                    FALSE,                      // not UPN logon
                    NULL,                       // do not register remote IP addr
                    &m_pNetworkServiceTokenCacheEntry,        // returned token handle
                    &dwLogonError              // LogonError Storage
                    );
    DBG_ASSERT(NULL != m_pNetworkServiceTokenCacheEntry || 
              (NULL == m_pNetworkServiceTokenCacheEntry && 0 != dwLogonError));
    if ( FAILED(hr) || 
         ( NULL == m_pNetworkServiceTokenCacheEntry &&
           FAILED( hr = HRESULT_FROM_WIN32( dwLogonError ) ) )
       )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to get the NetworkService token.\n"
            ));

        goto exit;
    }

    dwErr = m_SecurityDispenser.AdjustTokenForAdministrators( 
                                       m_pNetworkServiceTokenCacheEntry->QueryPrimaryToken() );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not adjust the network service token to allow administrator rights\n"
            ));

        goto exit;
    }

exit:

    return hr;

}   // WEB_ADMIN_SERVICE::CreateCachedWorkerProcessTokens

/***************************************************************************++

Routine Description:

    Initialize sub-components of the web admin service.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WEB_ADMIN_SERVICE::InitializeOtherComponents(
    )
{

    HRESULT hr = S_OK;

    //
    // Before we spin up the other objects, let's decide if
    // we are going to be using a shared desktop for the worker processes.
    //
    hr = SetupSharedWPDesktop();
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed setting up the shared desktop\n"
            ));

        goto exit;
    }


    //
    // Set up structures to manage UL and the worker processes.
    //

    hr = m_UlAndWorkerManager.Initialize( );
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing UL & Worker manager failed\n"
            ));

        goto exit;
    }


    //
    // Read the initial configuration.
    //

    hr = m_ConfigAndControlManager.Initialize();
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing configuration manager failed\n"
            ));

        goto exit;
    }

    //
    // If we have not set the key in the registry ( or it is zero ) then 
    // we can go ahead and tell the logger that we have finished with initalization
    // and it should only log events that happen on valid WAS objects.  Newly created
    // objects that fail validation for some reason will be ignored.
    //
    if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_ALWAYS_LOG_EVENTS_W, 0 ) == 0 )
    {
        m_WMSLogger.MarkAsDoneWithStartup();
    }

    if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_PERF_COUNT_DISABLED_W, 0 ) == 0 )
    {
        m_UlAndWorkerManager.ActivatePerfCounters();
    }

    m_UlAndWorkerManager.ActivateASPCounters();

#if DBG
    //
    // Dump the configured state we read from the config store.
    //

    m_UlAndWorkerManager.DebugDump();
#endif  // DBG
    

    //
    // Now start UL.
    //

    hr = m_UlAndWorkerManager.ActivateUl();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Activating UL failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitializeOtherComponents

/***************************************************************************++

Routine Description:

    Check if we will be using a shared desktop and if we will then
    go ahead and generate one.  We will pick the name randomly.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WEB_ADMIN_SERVICE::SetupSharedWPDesktop(
    )
{

    // We don't need a desktop in BC mode.
    if ( m_BackwardCompatibilityEnabled )
    {
        return S_OK;
    }

    //
    // Check the registry to find out if the value is set and zero or not set, if it is
    // then we are not being asked to create the desktop.
    //
    if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_USE_SHARED_WP_DESKTOP_W, 0 ) == 0 )
    {
        return S_OK;
    }

    //
    // Check if the W3SVC ( this process ) is running interactive, if it is we are not going 
    // to create a new desktop for sharing.  The W3WP's will run interactive as well.
    //
    if ( W3SVCRunningInteractive() )
    {
        return S_OK;
    }

    //
    // If we got here we need to generate a new desktop and then save the name off in the
    // m_WPDesktop variable.
    //
    return GenerateWPDesktop();


}   // WEB_ADMIN_SERVICE::SetupSharedWPDesktop

/***************************************************************************++

Routine Description:

    Creates a desktop to be used by the IIS_WPG group.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WEB_ADMIN_SERVICE::GenerateWPDesktop(
    )
{

    HRESULT     hr = S_OK;
    DWORD       dwErr = ERROR_SUCCESS;

    PSID psidLocalSystem = NULL;
    PSID psidLocalService = NULL;
    PSID psidNetworkService = NULL;
    PSID psidIisWPG = NULL;

    PACL pACL = NULL;

    EXPLICIT_ACCESS ea[4];   // Setup four explicit access objects

    SECURITY_DESCRIPTOR sd = {0};
    SECURITY_ATTRIBUTES sa = {0};

    HWINSTA             hWinStaPrev = NULL;
    HDESK               hDesktopPrev = NULL;

    DBG_ASSERT ( m_hWPWinStation == NULL &&
                 m_hWPDesktop == NULL );
    //
    // Get the SIDs for the security descriptor for the
    // winstation and desktop we are creating.
    //
    dwErr = m_SecurityDispenser.GetSID( WinLocalSystemSid, 
                                        &psidLocalSystem );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not get the local system sid\n"
            ));

        goto exit;
    }

    dwErr = m_SecurityDispenser.GetSID( WinLocalServiceSid, 
                                        &psidLocalService );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not get the local service sid\n"
            ));

        goto exit;
    }

    dwErr = m_SecurityDispenser.GetSID( WinNetworkServiceSid, 
                                        &psidNetworkService );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not get the network service sid\n"
            ));

        goto exit;
    }

    dwErr = m_SecurityDispenser.GetIisWpgSID( &psidIisWPG );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not get the IIS WPG sid\n"
            ));

        goto exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    SecureZeroMemory(ea, sizeof(ea));

    // Note:  GENERIC_ALL means different things for the 
    //        winsta and the desktop.  Taken from MSDN  
    // For the Desktop it means:
    //          DESKTOP_CREATEMENU
    //          DESKTOP_CREATEWINDOW
    //          DESKTOP_ENUMERATE
    //          DESKTOP_HOOKCONTROL
    //          DESKTOP_JOURNALPLAYBACK
    //          DESKTOP_JOURNALRECORD
    //          DESKTOP_READOBJECTS
    //          DESKTOP_SWITCHDESKTOP
    //          DESKTOP_WRITEOBJECTS
    //          STANDARD_RIGHTS_REQUIRED
    // For the Winsta it means ( non-interactive ):
    //          STANDARD_RIGHTS_REQUIRED
    //          WINSTA_ACCESSCLIPBOARD
    //          WINSTA_ACCESSGLOBALATOMS
    //          WINSTA_CREATEDESKTOP
    //          WINSTA_ENUMDESKTOPS
    //          WINSTA_ENUMERATE
    //          WINSTA_EXITWINDOWS
    //          WINSTA_READATTRIBUTES
    //
    SetExplicitAccessSettings(  &(ea[0]),
                                GENERIC_ALL,
                                SET_ACCESS,
                                psidLocalSystem );

    SetExplicitAccessSettings(  &(ea[1]),
                                GENERIC_ALL,
                                SET_ACCESS,
                                psidLocalService );

    SetExplicitAccessSettings(  &(ea[2]),
                                GENERIC_ALL,
                                SET_ACCESS,
                                psidNetworkService );

    SetExplicitAccessSettings(  &(ea[3]),
                                GENERIC_ALL,
                                SET_ACCESS,
                                psidIisWPG );

    //
    // Create a new ACL that contains the new ACEs.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS), ea, NULL, &pACL);
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    }

    if (!SetSecurityDescriptorDacl(&sd,
            TRUE,     // fDaclPresent flag
            pACL,
            FALSE))   // not a default DACL
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    // We have built the SA for the new winstation,
    // now we need to save the old desktop and winstation.

    hDesktopPrev = GetThreadDesktop( GetCurrentThreadId() );
    if ( hDesktopPrev == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't get the thread desktop \n"
            ));
        goto exit;
    }

    // Save our old window station so we can restore it later
    hWinStaPrev = GetProcessWindowStation();
    if ( hWinStaPrev == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't get the process windows station \n"
            ));
        goto exit;
    }

    // We generate the name so we can avoid conflicts.
    dwErr = GenerateNameWithGUID( L"WP_WINSTA-", &m_strWPDesktop );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't generate a name \n"
            ));
        goto exit;
    }

    // Create the window station
    // Note:  There is no way to tell if we are getting an existing winsta or desktop
    //        so we just live with what we get.  Since we are generating the winsta name
    //        it should be harder for an attack to have previously created it.
    m_hWPWinStation = CreateWindowStation( 
                            m_strWPDesktop.QueryStr(),  // name of winstation
                            0,                     // must be null
                            WINSTA_CREATEDESKTOP,  // need to be able to create a desktop
                            &sa );                 // security descriptor

    if ( m_hWPWinStation == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't create the window station \n"
            ));

        goto exit;
    }

    // At this point we should have our window
    DBG_ASSERT ( m_hWPWinStation != NULL );
        
    // Set this as IIS's window station
    if ( !SetProcessWindowStation( m_hWPWinStation ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't change to the window station \n"
            ));
        goto exit;
    }

    // Create a desktop for WP's to use
    // Note:  There is no way to tell if we are getting an existing winsta or desktop
    //        so we just live with what we get.  Since we are generating the winsta name
    //        it should be harder for an attack to have previously created it.
    m_hWPDesktop = CreateDesktop( 
                                L"Default",  // name of desktop
                                NULL,   // must be null
                                NULL,   // must be null
                                0,      // Flags, don't ask to allow others to hook in
                                DESKTOP_CREATEWINDOW,
                                &sa );  // security descriptor
    if ( m_hWPDesktop == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't create the desktop \n"
            ));
        goto exit;
    }

    //
    // Add the desktop name to the winstation 
    // so we know the names to specify later
    // when we create the worker processes.
    //
    hr = m_strWPDesktop.Append(L"\\Default");
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't append the desktop to the string \n"
            ));
        goto exit;
    }

exit:

    if (pACL)
    {
        LocalFree(pACL);
        pACL = NULL;
    }

    // Make sure we get back to the 
    // desktop that we expect to be at.
    if ( hWinStaPrev != NULL )
    {
        SetProcessWindowStation( hWinStaPrev );
        CloseWindowStation( hWinStaPrev );
        hWinStaPrev = NULL;
    }

    if ( hDesktopPrev != NULL )
    {
        SetThreadDesktop( hDesktopPrev );
        CloseDesktop( hDesktopPrev );
        hDesktopPrev = NULL;
    }

    // If there was a problem, make sure
    // we aren't holding on to anything.
    if ( FAILED ( hr ) )
    {
        if ( m_hWPDesktop != NULL )
        {
            CloseDesktop( m_hWPDesktop );
            m_hWPDesktop = NULL;
        }

        if ( m_hWPWinStation != NULL )
        {
            CloseWindowStation( m_hWPWinStation );
            m_hWPWinStation = NULL;
        }

        // Make sure we don't have the
        // string still set.
        m_strWPDesktop.Reset(); 
    }

    return hr;
}  // WEB_ADMIN_SERVICE::GenerateWPDesktop



/***************************************************************************++

Routine Description:

    Check if we will be using a shared desktop and if we will then
    go ahead and generate one.  We will pick the name randomly.

Arguments:

    None.

Return Value:

    BOOL - If we fail we assume we are not running interactive.

Note:

    You could also do this function by querying the W3SVC however, there is 
    a small window where after the process is launched but before the check
    the service could be reconfigured and we would get the reconfigured setting
    not the one we are actually running as.

    According to NTUSER this path is reasonable to tell if you are currently
    running interactive, so we stayed with it.

--***************************************************************************/
BOOL
WEB_ADMIN_SERVICE::W3SVCRunningInteractive(
    )
{

    HRESULT hr = S_OK;
    HWINSTA hWinStation = NULL;
    DWORD  cbNeeded = 0;
    USEROBJECTFLAGS objflags;
    BOOL  RunningAsInteractive = FALSE;

    //
    // Get the winstation to look at.  I suspect
    // we don't need to close this handle just like
    // we don't have to close the handle we get for the
    // desktop.
    //
    hWinStation = GetProcessWindowStation();
    if ( hWinStation == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't get the process windows station \n"
            ));

        RunningAsInteractive = FALSE;
        goto exit;
    }

    if ( GetUserObjectInformation( hWinStation, 
                                   UOI_FLAGS, 
                                   &objflags, 
                                   sizeof(objflags), 
                                   &cbNeeded ) == 0 )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't get the flags for the windows station \n"
            ));

        RunningAsInteractive = FALSE;
        goto exit;

    }

    RunningAsInteractive = (( objflags.dwFlags & WSF_VISIBLE ) == WSF_VISIBLE  );

exit:

    if ( hWinStation )
    {
        CloseWindowStation( hWinStation );
        hWinStation = NULL;
    }

    return RunningAsInteractive;


}   // WEB_ADMIN_SERVICE::W3SVCRunningInteractive

/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of the service.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::Shutdown(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initiating web admin service (gentle) shutdown\n"
            ));
    }


    //
    // Turn off config change and control operation processing.
    //

    m_ConfigAndControlManager.StopChangeProcessing();

    m_UlAndWorkerManager.Shutdown();    

}   // WEB_ADMIN_SERVICE::Shutdown

/***************************************************************************++

Routine Description:

    Tell inetinfo to launch a worker process.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::LaunchInetinfo(
    )
{

    HRESULT hr = S_OK;
    HANDLE  hInetinfoLaunchEvent = NULL;
    BUFFER  bufEventName;
    DWORD   cbNeeded = bufEventName.QuerySize();

    // This should all be there because we have all ready gotten the iisadmin interface.
    // So inetinfo should of setup all the event stuff by now.
    hr = ReadStringParameterValueFromAnyService( REGISTRY_KEY_IISADMIN_W,
                                                 REGISTRY_VALUE_IISADMIN_W3CORE_LAUNCH_EVENT_W,
                                                 (LPWSTR) bufEventName.QueryPtr(),
                                                 &cbNeeded );

    if ( hr == HRESULT_FROM_WIN32( ERROR_MORE_DATA ))
    {
        if ( !bufEventName.Resize(cbNeeded) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = ReadStringParameterValueFromAnyService( REGISTRY_KEY_IISADMIN_W,
                                                         REGISTRY_VALUE_IISADMIN_W3CORE_LAUNCH_EVENT_W,
                                                         (LPWSTR) bufEventName.QueryPtr(),
                                                         &cbNeeded );
        }
    }

    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not get the startup event\n"
            ));

        return hr;
    }

    hInetinfoLaunchEvent = OpenEvent(  EVENT_MODIFY_STATE,
                                       FALSE,
                                       (LPWSTR) bufEventName.QueryPtr());
    if ( hInetinfoLaunchEvent )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Launching Inetinfo CTC = %d \n",
                GetTickCount()
                ));
        }

        if (!SetEvent(hInetinfoLaunchEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not set the Start W3WP event\n"
                ));
        }

        CloseHandle( hInetinfoLaunchEvent );
    }
    else
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Tried to open event to launch a worker process in inetinfo but could not get handle.\n"
            ));

        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}   // WEB_ADMIN_SERVICE::LaunchInetinfo

/***************************************************************************++

Routine Description:

    Routine runs on main thread and handles doing all the operations
    that need to ocurr once inetinfo has come back up after it has crashed.

Arguments:

    None.

Return Value:

    HRESULT -- If this is a failed result the service will shutdown.

--***************************************************************************/
HRESULT 
WEB_ADMIN_SERVICE::RecoverFromInetinfoCrash(
    )
{ 
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // If we are all ready stopping then we do not want to 
    // recover from the inetinfo crash.  One example of 
    // this path that is bad is if we fail to start due to 
    // an inetinfo crash.  When we are emptying out the queue
    // items before completeing the stop we will come across
    // a recover from inetinfo crash item.  However we don't
    // really want to rewrite states or try and recycle worker
    // processes that we have all ready told to shutdown.
    //
    if ( m_StoppingInProgress == FALSE )
    {

        // Need to do the following.
        // 1) Have the config manager create a new admin base object to use.
        // 2) Have the ULAndWorkerManager handle recycling and reporting of state.
        // 3) request the config manager rehookup ( do this after 1 because the state will
        //    be expected to be what we are resetting them to ).

        // Step 1, re-establish the admin base object ( note, that at this point we 
        //         will not hook up for notificaiton, we just need the pointer back so 
        //         we can write the state of objects to the metabase.

        hr = m_ConfigAndControlManager.
             GetConfigManager()->
             ReestablishAdminBaseObject();
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to create a new Admin Base Object after inetinfo crash \n"
                ));

            goto exit;
        }

        // Step 2, have the Worker Manager Recycle all the worker processes
        //         and have it re-record all site and app pool data.
        hr = m_UlAndWorkerManager.RecoverFromInetinfoCrash();
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed having the ULAndWorkerManager recover from inetinfo crash\n"
                ));

            goto exit;
        }

        // Step 3, have the catalog rehookup for notifications.
        m_ConfigAndControlManager.
             GetConfigManager()->
             RehookChangeProcessing();
    }

exit:

    return hr;
} // WEB_ADMIN_SERVICE::RecoverFromInetinfoCrash


/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    PSID - The Local System SID

--***************************************************************************/

PSID
WEB_ADMIN_SERVICE::GetLocalSystemSid(
    )
{   
    DWORD dwErr = ERROR_SUCCESS;
    PSID pSid = NULL;

    dwErr = m_SecurityDispenser.GetSID( WinLocalSystemSid
                                        ,&pSid);
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Fatal service error, shutting down\n"
            ));

        return NULL;
    }

    return pSid;
}


/***************************************************************************++

Routine Description:

    Do final service cleanup, and then tell the service controller that the 
    service has stopped as well as providing it with the service's error 
    exit value.

Arguments:

    ServiceExitCode - The exit code for the service.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::TerminateServiceAndReportFinalStatus(
    IN HRESULT ServiceExitCode
    )
{

    DWORD Win32Error = NO_ERROR;
    DWORD ServiceSpecificError = NO_ERROR;
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // If we got here on a success code, make sure no other code left
    // us an hresult that we should be processing.
    //

    if ( SUCCEEDED ( ServiceExitCode ) )
    {
        ServiceExitCode = m_hrToReportToSCM;
    }

    if ( FAILED( ServiceExitCode ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            ServiceExitCode,
            "Fatal service error, shutting down\n"
            ));

        if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_FAILURE_CAUSING_SHUTDOWN_W, 0 ) )
        {
            DBG_ASSERT ( FAILED( ServiceExitCode ) == FALSE );
        }

        //
        // Log an event: WAS shutting down due to error.
        //

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_ERROR_SHUTDOWN,               // message id
                0,                                      // count of strings
                NULL,                                   // array of strings
                ServiceExitCode                         // error code
                );


        if ( HRESULT_FACILITY( ServiceExitCode ) == FACILITY_WIN32 )
        {
            Win32Error = WIN32_FROM_HRESULT( ServiceExitCode );
        }
        else
        {
            Win32Error = ERROR_SERVICE_SPECIFIC_ERROR;
            ServiceSpecificError = ServiceExitCode;
        }
    }
    else
    {
        //
        // If we are still monitoring inetinfo and
        // inetinfo is in a crashed state, then we will
        // assume that we are shutting down due to the crash.
        //
        if ( m_ConfigAndControlManager.
                 GetConfigManager()->
                 QueryMonitoringInetinfo() &&
             m_ConfigAndControlManager.
                 GetConfigManager()->
                 QueryInetinfoInCrashedState() )
        {
            HRESULT hrTemp = HRESULT_FROM_WIN32( ERROR_SERVICE_DEPENDENCY_FAIL );

            UNREFERENCED_PARAMETER( hrTemp );
            DPERROR(( 
                DBG_CONTEXT,
                hrTemp,
                "Inetinfo crashed, shutting down service\n"
                ));


            if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_FAILURE_CAUSING_SHUTDOWN_W, 0 ) )
            {
                DBG_ASSERT ( !m_ConfigAndControlManager.
                             GetConfigManager()->
                             QueryInetinfoInCrashedState() );
            }

            //
            // Log an event: WAS shutting down due to error.
            //

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_INETINFO_CRASH_SHUTDOWN,      // message id
                    0,                                      // count of strings
                    NULL,                                   // array of strings
                    0                                       // error code
                    );


            Win32Error = ERROR_SERVICE_DEPENDENCY_FAIL;

        }

    }


    //
    // Clean up everything that's left of the service.
    //
    
    Terminate();

    //
    //
    // Report the SERVICE_STOPPED status to the service controller.
    //

    //
    // Note that unfortunately the NT5 SCM service failure actions (such as
    // automatically restarting the service) work only if the service process
    // terminates without setting the service status to SERVICE_STOPPED, and
    // not if it exits cleanly with an error exit code, as we may do here.
    // They are going to consider adding this post-NT5.
    //

    if ( m_ServiceStateTransitionLockInitialized )
    {
        m_ServiceStateTransitionLock.Lock();
    

        hr = UpdateServiceStatus(
                    SERVICE_STOPPED,
                    Win32Error,
                    ServiceSpecificError,
                    0,
                    0
                    );
        if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "couldn't update service status\n"
                ));

        }

        m_ServiceStateTransitionLock.Unlock();
    }


    return;

}   // WEB_ADMIN_SERVICE::TerminateServiceAndReportFinalStatus



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::Terminate(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );    

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initiating web admin service termination\n"
            ));
    }

    //
    // Stop config change and control operation processing, as those could 
    // generate new WORK_ITEMs.
    //
    
    m_ConfigAndControlManager.StopChangeProcessing();

    //
    // Terminate the UL and worker manager.
    //

    m_UlAndWorkerManager.Terminate();


    //
    // Terminate the config and control manager.
    //
    
    m_ConfigAndControlManager.Terminate();

    //
    // Terminate the low memory detector, to flush out any WORK_ITEMs it has.
    //

    //
    // Shut down the work queue. This must be done after all things which can 
    // generate new work items are shut down, as this operation will free any 
    // remaining work items. This includes for example work items that were 
    // pending on real async i/o; in such cases the i/o must be canceled first, 
    // in order to complete the i/o and release the work item, so that we can 
    // then clean it up here.
    //
    // Once this has completed, we are also guaranteed that no more work items
    // can be created. 
    //
    
    m_WorkQueue.Terminate();

    // cleanup any desktops we created and are holding on to.
    if ( m_hWPDesktop != NULL )
    {
        CloseDesktop( m_hWPDesktop );
        m_hWPDesktop = NULL;
    }

    if ( m_hWPWinStation != NULL )
    {
        CloseWindowStation( m_hWPWinStation );
        m_hWPWinStation = NULL;
    }

    // Make sure we don't have the
    // string still set.
    m_strWPDesktop.Reset();

    //
    // Cancel the pending service status timer, if present. We can do this
    // even after cleaning up the work queue, because it does not use 
    // work items. We have it block for any callbacks to finish, so that
    // the callbacks can't complete later, once this instance goes away!
    //

    hr = CancelPendingServiceStatusTimer( TRUE );
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not cancel pending service status timer\n"
            ));

    }
    

    //
    // Close the timer queue (if present).
    //

    DeleteTimerQueue();

    if ( m_WPStaticInitialized )
    {
        WORKER_PROCESS::StaticTerminate();
    }

    if ( m_pLocalSystemTokenCacheEntry != NULL )
    {
        m_pLocalSystemTokenCacheEntry->DereferenceCacheEntry();
        m_pLocalSystemTokenCacheEntry = NULL;
    }

    if ( m_pLocalServiceTokenCacheEntry != NULL )
    {
        m_pLocalServiceTokenCacheEntry->DereferenceCacheEntry();
        m_pLocalServiceTokenCacheEntry = NULL;
    }

    if ( m_pNetworkServiceTokenCacheEntry != NULL )
    {
        m_pNetworkServiceTokenCacheEntry->DereferenceCacheEntry();
        m_pNetworkServiceTokenCacheEntry = NULL;
    }

    m_TokenCache.Clear();
    //
    // CAUTION: this is a static call - it Terminates all token caches in the process
    //
    m_TokenCache.Terminate();

    //
    // At this point we are done using IISUtil
    //
    
    TerminateIISUtil();
    
    return;

}   // WEB_ADMIN_SERVICE::Terminate



/***************************************************************************++

Routine Description:

    Cancel the pending service status timer.

Arguments:

    BlockOnCallbacks - Whether the cancel call should block waiting for
    callbacks to complete, or return immediately. If this method is called
    with the m_ServiceStateTransitionLock held, then DO NOT block on
    callbacks, as you can deadlock. (Instead, the callback to update the
    service pending status is designed to be harmless if called after the
    state transition completes.) 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::CancelPendingServiceStatusTimer(
    IN BOOL BlockOnCallbacks
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    if ( m_SharedTimerQueueHandle != NULL && 
         m_PendingServiceStatusTimerHandle != NULL )
    {

        Status = RtlDeleteTimer(
                        m_SharedTimerQueueHandle,   // the owning timer queue
                        m_PendingServiceStatusTimerHandle,          
                                                    // timer to cancel
                         ( BlockOnCallbacks ? ( ( HANDLE ) -1 ) : NULL )
                                                    // block on callbacks or not
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not cancel timer\n"
                ));

            goto exit;
        }

        m_PendingServiceStatusTimerHandle = NULL;

    }
    

exit:

    return hr;
    
}   // WEB_ADMIN_SERVICE::CancelPendingServiceStatusTimer



/***************************************************************************++

Routine Description:

    Delete the timer queue.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::DeleteTimerQueue(
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;


    if ( m_SharedTimerQueueHandle != NULL )
    {
        Status = RtlDeleteTimerQueueEx( 
                        m_SharedTimerQueueHandle,   // timer queue to delete
                        ( HANDLE ) -1               // block until callbacks finish
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not delete timer queue\n"
                ));

            goto exit;
        }

        m_SharedTimerQueueHandle = NULL;

    }
    

exit:

    return hr;
    
}   // WEB_ADMIN_SERVICE::DeleteTimerQueue


/***************************************************************************++

Routine Description:

    Returns the active process mask for the system.

Arguments:

    None.

Return Value:

    DWORD

--***************************************************************************/
DWORD_PTR
WEB_ADMIN_SERVICE::GetSystemActiveProcessMask(
    )
{
    // if the processor mask is not set, set it now.
    if ( m_SystemActiveProcessorMask == 0 )
    {
        SYSTEM_INFO SystemInfo;

        GetSystemInfo( &SystemInfo );
        DBG_ASSERT( CountOfBitsSet( SystemInfo.dwActiveProcessorMask ) == SystemInfo.dwNumberOfProcessors );

        m_SystemActiveProcessorMask = SystemInfo.dwActiveProcessorMask;
    }

    return m_SystemActiveProcessorMask;
}

/***************************************************************************++

Routine Description:

    Read a DWORD value from the parameters key for this service.

Arguments:

    RegistryValueName - The value to read.

    DefaultValue - The default value to return if the registry value is 
    not present or cannot be read.

Return Value:

    DWORD - The parameter value.

--***************************************************************************/

DWORD
ReadDwordParameterValueFromRegistry(
    IN LPCWSTR RegistryValueName,
    IN DWORD DefaultValue
    )
{
    return ReadDwordParameterValueFromAnyService(
                    REGISTRY_KEY_W3SVC_PARAMETERS_W,
                    RegistryValueName,
                    DefaultValue );
}





/***************************************************************************++

Routine Description:

    The service control handler function called by the service controller,
    on its thread. Posts a work item to the main worker thread to actually
    handle the request.

Arguments:

    OpCode - The requested operation, from the SERVICE_CONTROL_* constants.

Return Value:

    None

--***************************************************************************/

VOID
ServiceControlHandler(
    IN DWORD OpCode
    )
{

    HRESULT hr = S_OK;


    switch( OpCode ) 
    {

    case SERVICE_CONTROL_INTERROGATE:

        hr = GetWebAdminService()->InterrogateService();
        break;

    //
    // CODEWORK Review if we need to support SERVICE_CONTROL_SHUTDOWN.
    // We only need this if we have persistent state to write out on
    // shutdown. If not, remove this to speed up overall NT shutdown.
    // Note that even if we don't internally have persistent state to 
    // write out, we might still want to attempt clean shutdown, so 
    // that application code running in worker processes get a chance
    // to write out their persistent state.
    //
    
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        hr = GetWebAdminService()->InitiateStopService();

        //
        // We assert here, because the SCM doesn't accept
        // that we could ever fail when a Stop command is sent in.
        //
        DBG_ASSERT ( SUCCEEDED ( hr ) );


        break;

    case SERVICE_CONTROL_PAUSE:

        hr = GetWebAdminService()->InitiatePauseService();
        break;

    case SERVICE_CONTROL_CONTINUE:

        hr = GetWebAdminService()->InitiateContinueService();
        break;

    default:
    
        DBGPRINTF(( 
            DBG_CONTEXT,
            "Service control ignored, OpCode: %lu\n",
            OpCode 
            ));
            
        break;
        
    }

    //
    // It's possible to have rejected the service control call
    // but not want the service to actually shutdown.
    //
    if ( FAILED( hr ) && 
         hr != HRESULT_FROM_WIN32( ERROR_SERVICE_CANNOT_ACCEPT_CTRL ))
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Service control operation failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );
    }


    return;
    
}   // ServiceControlHandler



/***************************************************************************++

Routine Description:

    The callback function invoked by the pending service status timer, on
    an RTL thread. It updates the pending service status, and reports the
    new status to the SCM. This work is done directly on this thread, so 
    that the service will not time out during very long single work item
    operations, such as service initialization. 

Arguments:

    Ignored1 - Ignored.

    Ignored2 - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
UpdatePendingServiceStatusCallback(
    IN PVOID Ignored1,
    IN BOOLEAN Ignored2
    )
{

    HRESULT hr = S_OK;


    UNREFERENCED_PARAMETER( Ignored1 );
    UNREFERENCED_PARAMETER( Ignored2 );


    hr = GetWebAdminService()->UpdatePendingServiceStatus();
    if ( FAILED( hr ) )
    {   
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Updating pending service status failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );
    }


    return;

}   // UpdatePendingServiceStatusCallback

/***************************************************************************++

Routine Description:

    Return the count of bits set to 1 in the input parameter. 

Arguments:

    Value - The target value on which to count set bits. 

Return Value:

    ULONG - The number of bits that were set. 

--***************************************************************************/

ULONG
CountOfBitsSet(
    IN DWORD_PTR Value
    )
{
    ULONG Count = 0;

    //
    // Note: designed to work independent of the size in bits of the value.
    //

    while ( Value )
    {   
        if ( Value & 1 )
        {
            Count++;
        }

        Value >>= 1;
        
    }

    return Count;

}   // CountOfBitsSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\was_change_item.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    was_change_item.cxx

Abstract:

    The IIS web admin service configuration change class implementation. 
    This class is used to queue config changes to the main worker thread.

    Threading: Created on the CONFIG Thread and processed on the main thread.

Author:

    Emily Kruglick (emilyk)        28-May-2001

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the WAS_CHANGE_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WAS_CHANGE_ITEM::WAS_CHANGE_ITEM(
    )
{


    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_Signature = WAS_CHANGE_ITEM_SIGNATURE;

}   // WAS_CHANGE_ITEM::WAS_CHANGE_ITEM



/***************************************************************************++

Routine Description:

    Destructor for the WAS_CHANGE_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WAS_CHANGE_ITEM::~WAS_CHANGE_ITEM(
    )
{


    DBG_ASSERT( m_Signature == WAS_CHANGE_ITEM_SIGNATURE );

    m_Signature = WAS_CHANGE_ITEM_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


}   // WAS_CHANGE_ITEM::~WAS_CHANGE_ITEM



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WAS_CHANGE_ITEM::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // WAS_CHANGE_ITEM::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WAS_CHANGE_ITEM::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in WAS_CHANGE_ITEM instance, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // WAS_CHANGE_ITEM::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WAS_CHANGE_ITEM::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in WAS_CHANGE_ITEM (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case ProcessChangeConfigChangeWorkItem:

        GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
                ProcessConfigChange( this );

        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on WAS_CHANGE_ITEM failed\n"
            ));

    }


    return hr;

}   // WAS_CHANGE_ITEM::ExecuteWorkItem


/***************************************************************************++

Routine Description:

    Copy changes which WAS is interested in into a table which is marshalled
    to the main WAS thread

Arguments:

    pSiteTable - Site table
    pApplicationTable - Application table
    pAppPoolTable - AppPool table

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WAS_CHANGE_ITEM::CopyChanges(
    IN GLOBAL_DATA_STORE *                 pGlobalStore,
    IN SITE_DATA_OBJECT_TABLE *            pSiteTable,
    IN APPLICATION_DATA_OBJECT_TABLE *     pApplicationTable,
    IN APP_POOL_DATA_OBJECT_TABLE *        pAppPoolTable
    )
{
    HRESULT                 hr = S_OK;
    
    if ( pGlobalStore == NULL ||
         pSiteTable == NULL ||
         pApplicationTable == NULL ||
         pAppPoolTable == NULL )
    {
        DBG_ASSERT( pGlobalStore != NULL &&
                    pSiteTable != NULL &&
                    pApplicationTable != NULL &&
                    pAppPoolTable != NULL );

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = pGlobalStore->CopyInteresting( &m_GlobalStore );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pSiteTable->CopyInteresting( &m_SiteTable );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pApplicationTable->CopyInteresting( &m_AppTable );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pAppPoolTable->CopyInteresting( &m_AppPoolTable );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return hr;
}

/***************************************************************************++

Routine Description:

    Process changes for this work item

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/

VOID
WAS_CHANGE_ITEM::ProcessChanges(
    )
{

    // we never create new global objects
    m_AppPoolTable.CreateWASObjects();
    m_SiteTable.CreateWASObjects();
    m_AppTable.CreateWASObjects();
    m_GlobalStore.UpdateWASObjects();
    m_AppPoolTable.UpdateWASObjects();
    m_SiteTable.UpdateWASObjects();
    m_AppTable.UpdateWASObjects();

    // notice the different order here
    // we need to clear out the apps 
    // before doing anything else.
    
    // we never delete global objects
    m_AppTable.DeleteWASObjects();
    m_SiteTable.DeleteWASObjects();
    m_AppPoolTable.DeleteWASObjects();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\wmserror.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    configerror.cxx

Abstract:

    Event logging of config errors

Author:

    Bilal Alam (balam)               6-Jun-2001

Revision History:

--*/

#include "precomp.h"

VOID
WMS_ERROR_LOGGER::LogRangeAppPool(
    LPCWSTR             pszAppPoolId,
    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid
)
/*++

Routine Description:
    
    Logs range errors dealing with app pool properties.

Arguments:

    LPCWSTR             pszAppPoolId,
    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid

Return Value:

    VOID

--*/
{
    LogRange( L"Application Pool", 
              pszAppPoolId,
              pszPropertyName,
              dwValue,
              dwLowValue,
              dwHighValue,
              dwDefaultValue,
              fWasValid );
    
}

VOID
WMS_ERROR_LOGGER::LogRangeSite(
    DWORD               dwSiteId,
    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid
)
/*++

Routine Description:
    
    Logs range errors dealing with site properties.

Arguments:

    DWORD               dwSiteId,
    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid

Return Value:

    VOID

--*/
{
    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

    _ultow( dwSiteId, achSiteId, 10 );

    LogRange( L"Virtual Site", 
              achSiteId,
              pszPropertyName,
              dwValue,
              dwLowValue,
              dwHighValue,
              dwDefaultValue,
              fWasValid );
    
}

VOID
WMS_ERROR_LOGGER::LogRangeGlobal(
    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid
)
/*++

Routine Description:
    
    Logs range errors dealing with global properties.

Arguments:

    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid

Return Value:

    VOID

--*/
{

    WCHAR               achValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achLowValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achHighValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achDefaultValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

    const WCHAR *       rgStrings[ 5 ];
    
    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }

    _ultow( dwValue, achValue, 10 );
    _ultow( dwLowValue, achLowValue, 10 );
    _ultow( dwHighValue, achHighValue, 10 );
    _ultow( dwDefaultValue, achDefaultValue, 10 );
    
    rgStrings[ 0 ] = pszPropertyName;
    rgStrings[ 1 ] = achValue;
    rgStrings[ 2 ] = achLowValue;
    rgStrings[ 3 ] = achHighValue;
    rgStrings[ 4 ] = achDefaultValue;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_GLOBAL_RANGE_ERROR,    
                   sizeof ( rgStrings ) / sizeof ( const WCHAR * ),
                  rgStrings,
                  S_OK );
    
}

VOID
WMS_ERROR_LOGGER::LogRange(
    LPCWSTR             pszObjectType,
    LPCWSTR             pszObjectName,
    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid
)
/*++

Routine Description:
    
    Logs range errors.

Arguments:

    LPCWSTR             pszObjectType,
    LPCWSTR             pszObjectName,
    LPCWSTR             pszPropertyName,
    DWORD               dwValue,
    DWORD               dwLowValue,
    DWORD               dwHighValue,
    DWORD               dwDefaultValue,
    BOOL                fWasValid

Return Value:

    VOID

--*/
{
    WCHAR               achValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achLowValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achHighValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achDefaultValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 7 ];
    
    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }

    _ultow( dwValue, achValue, 10 );
    _ultow( dwLowValue, achLowValue, 10 );
    _ultow( dwHighValue, achHighValue, 10 );
    _ultow( dwDefaultValue, achDefaultValue, 10 );
    
    rgStrings[ 0 ] = pszObjectType;
    rgStrings[ 1 ] = pszObjectName;
    rgStrings[ 2 ] = pszPropertyName;
    rgStrings[ 3 ] = achValue;
    rgStrings[ 4 ] = achLowValue;
    rgStrings[ 5 ] = achHighValue;
    rgStrings[ 6 ] = achDefaultValue;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_RANGE_ERROR,    
                  7,
                  rgStrings,
                  S_OK );
    
}

VOID
WMS_ERROR_LOGGER::LogAppPoolCommand(
    LPCWSTR             pszAppPoolId,
    DWORD               dwValue,
    BOOL                fWasValid
)
/*++

Routine Description:
    
    Logs app pool command errors

Arguments:

    LPCWSTR             pszAppPoolId,
    DWORD               dwValue,
    BOOL                fWasValid

Return Value:

    VOID
--*/

{

    WCHAR               achValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 2 ];
    
    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }

    _ultow( dwValue, achValue, 10 );
    
    rgStrings[ 0 ] = pszAppPoolId;
    rgStrings[ 1 ] = achValue;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_APP_POOL_COMMAND_ERROR,    
                  2,
                  rgStrings,
                  S_OK );

}

VOID
WMS_ERROR_LOGGER::LogServerCommand(
    DWORD               dwSiteId,
    DWORD               dwValue,
    BOOL                fWasValid
)
/*++

Routine Description:
    
    Logs server command errors

Arguments:

    DWORD               dwSiteId,
    DWORD               dwValue,
    BOOL                fWasValid

Return Value:

    VOID
--*/
{

    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 2 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    _ultow( dwValue,  achValue,  10 );
    
    rgStrings[ 0 ] = achSiteId;
    rgStrings[ 1 ] = achValue;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_SERVER_COMMAND_ERROR,    
                  2,
                  rgStrings,
                  S_OK );

}


VOID
WMS_ERROR_LOGGER::LogSiteBinding(
    DWORD             dwSiteId,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs site binding errors

Arguments:

    DWORD             dwSiteId,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{

    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 1 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    
    rgStrings[ 0 ] = achSiteId;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_SITE_BINDING_ERROR,    
                  1,
                  rgStrings,
                  S_OK );

}

VOID
WMS_ERROR_LOGGER::LogSiteAppPoolId(
    DWORD             dwSiteId,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs site app pool id errors

Arguments:

    DWORD             dwSiteId,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{

    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 1 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    
    rgStrings[ 0 ] = achSiteId;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_SITE_APP_POOL_ID_ERROR,    
                  1,
                  rgStrings,
                  S_OK );

}

VOID
WMS_ERROR_LOGGER::LogApplicationInvalidDueToMissingAppPoolId(
    DWORD             dwSiteId,
    LPCWSTR           pszApplicationUrl,
    LPCWSTR           pszAppPoolId,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs applications going invalid if they don't have app pool ids

Arguments:

    DWORD             dwSiteId,
    LPCWSTR           pszApplicationUrl,
    LPCWSTR           pszAppPoolId,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{
    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 3 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    
    rgStrings[ 0 ] = achSiteId;
    rgStrings[ 1 ] = pszApplicationUrl;
    rgStrings[ 2 ] = pszAppPoolId;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_APPLICATION_APP_POOL_ID_INVALID_ERROR,    
                  3,
                  rgStrings,
                  S_OK );

}

VOID
WMS_ERROR_LOGGER::LogApplicationInvalidDueToMissingSite(
    DWORD             dwSiteId,
    LPCWSTR           pszApplicationUrl,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs applications going invalid if they don't have sites

Arguments:

    DWORD             dwSiteId,
    LPCWSTR           pszApplicationUrl,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{
    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 2 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    
    rgStrings[ 0 ] = achSiteId;
    rgStrings[ 1 ] = pszApplicationUrl;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_APPLICATION_SITE_INVALID_ERROR,    
                  2,
                  rgStrings,
                  S_OK );

}

VOID
WMS_ERROR_LOGGER::LogApplicationAppPoolIdEmpty(
    DWORD             dwSiteId,
    LPCWSTR           pszApplicationUrl,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs application going invalid if they don't have app pool ids

Arguments:

    DWORD             dwSiteId,
    LPCWSTR           pszApplicationUrl,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{
    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 2 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    
    rgStrings[ 0 ] = achSiteId;
    rgStrings[ 1 ] = pszApplicationUrl;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_APPLICATION_APP_POOL_ID_EMPTY_ERROR,    
                  2,
                  rgStrings,
                  S_OK );

}

VOID
WMS_ERROR_LOGGER::LogIdleTimeoutGreaterThanRestartPeriod(
    LPCWSTR           pszAppPoolId,
    DWORD             dwIdleTimeout,
    DWORD             dwRestartTime,
    DWORD             dwIdleTimeoutDefault,
    DWORD             dwRestartTimeDefault,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs idle timeout being greater than the restart period

Arguments:

    LPCWSTR           pszAppPoolId,
    DWORD             dwIdleTimeout,
    DWORD             dwRestartTime,
    DWORD             dwIdleTimeoutDefault,
    DWORD             dwRestartTimeDefault,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{

    WCHAR               achIdleTimeout[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achIdleTimeoutDefault[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achRestartTime[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achRestartTimeDefault[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 5 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwIdleTimeout, achIdleTimeout, 10 );
    _ultow( dwIdleTimeoutDefault, achIdleTimeoutDefault, 10 );
    _ultow( dwRestartTime, achRestartTime, 10 );
    _ultow( dwRestartTimeDefault, achRestartTimeDefault, 10 );
    
    rgStrings[ 0 ] = pszAppPoolId;
    rgStrings[ 1 ] = achIdleTimeout;
    rgStrings[ 2 ] = achRestartTime;
    rgStrings[ 3 ] = achIdleTimeoutDefault;
    rgStrings[ 4 ] = achRestartTimeDefault;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_IDLE_GREATER_RESTART_ERROR,    
                  5,
                  rgStrings,
                  S_OK );

}


VOID
WMS_ERROR_LOGGER::LogAppPoolIdTooLong(
    LPCWSTR           pszAppPoolId,
    DWORD             dwLength,
    DWORD             dwMaxLength,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs error if the app pool id is too long

Arguments:

    LPCWSTR           pszAppPoolId,
    DWORD             dwLength,
    DWORD             dwMaxLength,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{
    WCHAR               achLength[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR               achMaxLength[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 3 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwLength, achLength, 10 );
    _ultow( dwMaxLength, achMaxLength, 10 );
    
    rgStrings[ 0 ] = pszAppPoolId;
    rgStrings[ 1 ] = achLength;
    rgStrings[ 2 ] = achMaxLength;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_APP_POOL_ID_TOO_LONG_ERROR,    
                  sizeof ( rgStrings ) / sizeof ( const WCHAR * ),
                  rgStrings,
                  S_OK );
}

VOID
WMS_ERROR_LOGGER::LogAppPoolIdNull(
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs error if the app pool id is null

Arguments:

    BOOL              fWasValid

Return Value:

    VOID
--*/
{

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_APP_POOL_ID_NULL_ERROR,    
                  0,
                  NULL,
                  S_OK );
}


VOID
WMS_ERROR_LOGGER::LogSiteInvalidDueToMissingAppPoolId( 
    DWORD             dwSiteId,
    LPCWSTR           pszAppPoolId,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs sites going invalid because their app pool id is not valid.
    Note that if the root app exists this check is not performed.

Arguments:

    DWORD             dwSiteId,
    LPCWSTR           pszAppPoolId,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{
    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 2 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    
    rgStrings[ 0 ] = achSiteId;
    rgStrings[ 1 ] = pszAppPoolId;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_SITE_APPPOOL_INVALID_ERROR,    
                  sizeof ( rgStrings ) / sizeof ( const WCHAR * ),
                  rgStrings,
                  S_OK );

}

VOID
WMS_ERROR_LOGGER::LogSiteInvalidDueToMissingAppPoolIdOnRootApp( 
    DWORD             dwSiteId,
    LPCWSTR           pszAppPoolId,
    BOOL              fWasValid
)
/*++

Routine Description:
    
    Logs sites going invalid because their app pool id is not valid.
    Note that if the root app exists this check is not performed.

Arguments:

    DWORD             dwSiteId,
    LPCWSTR           pszAppPoolId,
    BOOL              fWasValid

Return Value:

    VOID
--*/
{
    WCHAR               achSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    const WCHAR *       rgStrings[ 2 ];

    if ( ShouldLog( fWasValid ) == FALSE )
    {
        return;
    }
    
    _ultow( dwSiteId, achSiteId, 10 );
    
    rgStrings[ 0 ] = achSiteId;
    rgStrings[ 1 ] = pszAppPoolId;

    GetWebAdminService()->GetEventLog()->
        LogEvent( WAS_EVENT_WMS_SITE_ROOT_APPPOOL_INVALID_ERROR,    
                  sizeof ( rgStrings ) / sizeof ( const WCHAR * ),
                  rgStrings,
                  S_OK );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_dispatch.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_dispatch.h

Abstract:

    The IIS web admin service header for the work item dispatch interface. 
    Classes which perform work queued via a WORK_ITEM must implement this 
    interface. 

    Threading: In derived classes, Reference() and Dereference() must be
    implemented thread-safe, as they may be called by any thread. 
    ExecuteWorkItem() will only be called on the main worker thread.

Author:

    Seth Pollack (sethp)        13-Nov-1998

Revision History:

--*/


#ifndef _WORK_DISPATCH_H_
#define _WORK_DISPATCH_H_



//
// forward references
//

class WORK_ITEM;



//
// prototypes
//

class WORK_DISPATCH
{

public:

    virtual
    VOID
    Reference(
        ) = 0;

    virtual
    VOID
    Dereference(
        ) = 0;

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        ) = 0;

    virtual
    BOOL 
    IsMBChangeItem(
        )
    {
        return FALSE;
    }

};  // class WORK_DISPATCH



#endif  // _WORK_DISPATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\worker_process.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    worker_process.cxx

Abstract:

    This class encapsulates the management of a single worker process.

    Threading: For the class itself, Reference(), Dereference(), and the
    destructor may be called on any thread; all other work is done on the
    main worker thread.
    The various timer and wait callbacks are called on secondary threads.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"

//
// WORKER_PROCESS static declarations
//
LIST_ENTRY WORKER_PROCESS::s_WorkerProcessListHead;

//
// local prototypes
//
HRESULT
ExpandCommandLinePiece( 
    LPWSTR OriginalPiece,
    UNICODE_STRING* pFormattedPiece,
    LPVOID pEnvironment
    );

BOOL 
CharactersExist(
    LPCWSTR str
    );

VOID
StartupTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
ShutdownTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
SendPingTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
PingResponseTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
ProcessHandleSignaledCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );


/***************************************************************************++

Routine Description:

    Constructor for the WORKER_PROCESS class.

Arguments:

    pAppPool - The app pool which owns this worker process.

    pAppPoolConfig - A pointer to the app pool configuration data at time of startup.

    StartReason - The reason this worker process is being started.

    pWorkerProcessToReplace - If this worker process is being created to
    replace an existing worker process, this parameter identifies that
    predecessor process. May be NULL.

Return Value:

    None.

--***************************************************************************/

WORKER_PROCESS::WORKER_PROCESS(
    IN APP_POOL * pAppPool,
    IN APP_POOL_CONFIG_STORE * pAppPoolConfig,
    IN WORKER_PROCESS_START_REASON StartReason,
    IN WORKER_PROCESS * pWorkerProcessToReplace,
    IN DWORD  MaxProcessesToLaunch,
    IN DWORD  NumWPOnWayToMaxProcesses
    )
{


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPool != NULL );
    DBG_ASSERT( pAppPoolConfig != NULL );


    m_AppPoolListEntry.Flink = NULL;
    m_AppPoolListEntry.Blink = NULL;

    InsertTailList(&s_WorkerProcessListHead, &m_WorkerProcessListEntry);

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_RegistrationId = 0;

    m_TerminalIllReason = NotIllTerminalIllnessReason;

    m_State = UninitializedWorkerProcessState;

    // Remember if backward compatibility is enabled.
    m_BackwardCompatibilityEnabled = GetWebAdminService()->IsBackwardCompatibilityEnabled();

    // reference the parent app pool, since we'll hold its pointer
    m_pAppPool = pAppPool;
    m_pAppPool->Reference();

    // hold on to the configuration data that we need to use to make all decisions.
    m_pAppPoolConfig = pAppPoolConfig;
    m_pAppPoolConfig->Reference();

    m_ProcessId = INVALID_PROCESS_ID;
    m_RegisteredProcessId = INVALID_PROCESS_ID;

    m_BeingReplaced = FALSE;

    m_NotifiedAppPoolThatStartupAttemptDone = FALSE;

    m_StartReason = StartReason;

    m_StartupTimerHandle = NULL;
    m_StartupBeganTickCount = 0;

    m_ShutdownTimerHandle = NULL;
    m_ShutdownBeganTickCount = 0;

    m_SendPingTimerHandle = NULL;

    m_PingResponseTimerHandle = NULL;
    m_PingBeganTickCount = 0;

    m_AwaitingPingReply = FALSE;

    // ======
    // Not changed in backward compatibility mode
    m_ProcessHandle = NULL;      

    m_ProcessWaitHandle = NULL;   

    m_ProcessAlive = FALSE;
    // End of not used section
    // ========

    m_pWorkerProcessToReplace = pWorkerProcessToReplace;

    m_pMessagingHandler = NULL;

    // checks have been done in the app pool to make sure 
    // that this value is atleast 1, but just make sure.
    DBG_ASSERT ( MaxProcessesToLaunch > 0 );

    m_PercentValueForStaggering = ( FLOAT ) NumWPOnWayToMaxProcesses / ( FLOAT ) MaxProcessesToLaunch;

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {

        DBGPRINTF(( DBG_CONTEXT,
                    "Num = %d, Max = %d, Stagger = %f \n",
                    NumWPOnWayToMaxProcesses,
                    MaxProcessesToLaunch,
                    m_PercentValueForStaggering ));
    }

    DBG_ASSERT ( m_PercentValueForStaggering != 0.0 );
   
    //
    // If there is a worker process to replace, our start reason
    // better be ReplaceWorkerProcessStartReason, and vice versa.
    //

    DBG_ASSERT( ( m_pWorkerProcessToReplace != NULL ) == ( m_StartReason == ReplaceWorkerProcessStartReason ) );


    //
    // If we are replacing another worker process, then reference it
    // to keep it around until our startup attempt is done.
    //

    if ( m_pWorkerProcessToReplace != NULL )
    {
        m_pWorkerProcessToReplace->Reference();
    }

    m_PerfCounterState = IdleWorkerProcessPerfCounterState;

    // defaults to shutting down immediately when a shutdown is requested.
    m_ShutdownType = TRUE;

    // saftey valve that can prevent extra loggings from happening.
    m_TerminallyIllShutdownRegardless = FALSE;

    // accounting for ignoring errors due to debuggers.
    m_IgnoredStartupTimelimitDueToDebugger = FALSE;
    m_IgnoredShutdownTimelimitDueToDebugger = FALSE;
    m_IgnoredPingDueToDebugger = FALSE;

    m_HandleSignalled = FALSE;

    m_Signature = WORKER_PROCESS_SIGNATURE;
}   // WORKER_PROCESS::WORKER_PROCESS



/***************************************************************************++

Routine Description:

    Destructor for the WORKER_PROCESS class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORKER_PROCESS::~WORKER_PROCESS(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( m_Signature == WORKER_PROCESS_SIGNATURE );

    m_Signature = WORKER_PROCESS_SIGNATURE_FREED;

    DBG_ASSERT( m_AppPoolListEntry.Flink == NULL );
    DBG_ASSERT( m_AppPoolListEntry.Blink == NULL );

    DBG_ASSERT( m_RefCount == 0 );

    DBG_ASSERT( m_State == DeletePendingWorkerProcessState );

    DBG_ASSERT( m_ProcessWaitHandle == NULL );

    DBG_ASSERT( ! m_ProcessAlive );

    DBG_ASSERT( m_NotifiedAppPoolThatStartupAttemptDone );

    DBG_ASSERT( m_StartupTimerHandle == NULL );

    DBG_ASSERT( m_ShutdownTimerHandle == NULL );

    DBG_ASSERT( m_SendPingTimerHandle == NULL );

    DBG_ASSERT( m_PingResponseTimerHandle == NULL );

    DBG_ASSERT( m_pWorkerProcessToReplace == NULL );

    DBG_ASSERT( m_pMessagingHandler == NULL );

    //
    // Dereference the parent app pool.
    //

    DBG_ASSERT( m_pAppPool != NULL );

    m_pAppPool->Dereference();
    m_pAppPool = NULL;


    DBG_ASSERT( m_pAppPoolConfig != NULL );
    m_pAppPoolConfig->Dereference();
    m_pAppPoolConfig = NULL;

    //
    // We don't close the process handle until here in the destructor,
    // because that prevents the process id from getting reused while this
    // instance is still around. Having more than one WORKER_PROCESS instance
    // with the same process id could lead to weird behavior.
    //

    if ( m_ProcessHandle != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_ProcessHandle ) );
        m_ProcessHandle = NULL;
    }

    //
    // Clean up any issues with perf counters.
    //
    if ( m_PerfCounterState == WaitingWorkerProcessPerfCounterState )
    {
        //
        // If we are waiting on counters from this object and it is being
        // released then the least we can do is tell the perf manager not to
        // wait any more.
        //

        PERF_MANAGER* pManager = GetWebAdminService()->
           GetUlAndWorkerManager()->
           GetPerfManager();

        //
        // If we don't have a perf manager than no one is waiting on
        // these counters, so we can go ahead and forget about sending
        // back anything.
        //
        if ( pManager )
        {
            //
            // By sending a zero length message, the perf manager
            // will just decrement the number of counters, if it 
            // is waiting on counters.
            //
            DBG_REQUIRE ( pManager->RecordCounters(0, NULL) == TRUE );
        }

        m_PerfCounterState = IdleWorkerProcessPerfCounterState;

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process counter after cleanup is %d\n",
                m_PerfCounterState
                ));
        }

    }

    RemoveEntryList(&m_WorkerProcessListEntry);
    m_WorkerProcessListEntry.Flink = NULL;
    m_WorkerProcessListEntry.Blink = NULL;


}   // WORKER_PROCESS::~WORKER_PROCESS



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // WORKER_PROCESS::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in WORKER_PROCESS instance, deleting (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        delete this;


    }


    return;

}   // WORKER_PROCESS::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in WORKER_PROCESS (ptr: %p; pid: %lu; realpid: %lu) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case ProcessHandleSignaledWorkerProcessWorkItem:
        hr = ProcessHandleSignaledWorkItem();
        break;

    case StartupTimerExpiredWorkerProcessWorkItem:
        hr = StartupTimerExpiredWorkItem();
        break;

    case ShutdownTimerExpiredWorkerProcessWorkItem:
        hr = ShutdownTimerExpiredWorkItem();
        break;

    case SendPingWorkerProcessWorkItem:
        hr = SendPingWorkItem();
        break;

    case PingResponseTimerExpiredWorkerProcessWorkItem:
        hr = PingResponseTimerExpiredWorkItem();
        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on WORKER_PROCESS failed\n"
            ));

        DealWithInternalWorkerProcessFailure( hr );

        hr = S_OK;

    }

    return hr;

}   // WORKER_PROCESS::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize this instance by creating it's actual process, and setting up
    other required machinery.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::Initialize(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( CheckSignature() );

    //
    // Initialize the messaging handler.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initializing message handler\n"
            ));
    }

    //
    // Note:  We disable the app pool when a worker process is attempted to be created
    //        with a bad identity.  While we have earlier loged an error when the identity
    //        was discovered to be invalid, we do not want to disable it at that time.  
    //        This is because a user might have a running app pool and be in the process
    //        of changing the identity and have only changed the Id or the Password and the
    //        next change will complete the change.  If we honored the check when the property
    //        was just set, we may take worker processes down even if users don't want property
    //        changes honored automatically and they haven't completely completed their change.
    //        It is also much harder and more buggy to support honoring the shutdown of the pool
    //        when the property is set than instead of when it is used.  The added complexity is 
    //        not worth the benifit.  

    DBG_ASSERT ( m_pAppPoolConfig );

    if ( m_pAppPoolConfig->GetWorkerProcessToken() == NULL )
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);

        DPERROR((
            DBG_CONTEXT,
            hr,
            "No configured identity to run worker process under.\n"
            ));

        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = m_pAppPool->GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_PROCESS_CREATION_NO_ID,        // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                0                                       // error code
                );

        m_TerminallyIllShutdownRegardless = TRUE;

        goto exit;

    }

    
    DBG_ASSERT(NULL == m_pMessagingHandler);

    m_pMessagingHandler = new MESSAGING_HANDLER;
    if (NULL == m_pMessagingHandler)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to allocate message handler, exiting\n"
            ));
        goto exit;
    }
    

    //
    // Tell the messaging infrastructure to expect a connection from our
    // about to be created process, and to associate it with this messaging
    // handler.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Accepting messages\n"
            ));
    }
    
    hr = m_pMessagingHandler->Initialize( this );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing messaging handler failed\n"
            ));

        goto exit;
    }

    //
    // Create the actual process.
    //

    if (m_BackwardCompatibilityEnabled)
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Starting Inetinfo W3WP Process\n"
                ));
        }

        hr = StartProcessInInetinfo();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not start process\n"
                ));

            goto exit;
        }

    }
    else
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Giving full permission to the WPG group on the desktop/winsta\n"
                ));
        }

        //
        // Make the current desktop accessible by the AppPool user
        // need to do it here rather than just on w3svc startup is because
        // someone else can change the ACL (and someone does during bootup)
        //
        hr = AlterDesktopForUser(m_pAppPoolConfig->GetWorkerProcessToken());
        if (FAILED(hr))
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Failed to configure desktop\n"
                ));

            goto exit;
        }

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Starting W3WP process\n"
                ));
        }
        hr = StartProcess();
        if ( FAILED( hr ) )
        {

            MarkAsTerminallyIll( CreateProcessFailedTerminalIllnessReason, 0, hr );
            hr = S_OK;
            goto exit;

        }


        hr = RegisterProcessWait();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not register wait on process handle\n"
                ));

            goto exit;
        }
    
    }

    hr = BeginStartupTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Beginning worker process startup timer failed\n"
            ));

        goto exit;
    }


    m_State = RegistrationPendingWorkerProcessState;


exit:

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing WORKER_PROCESS failed\n"
            ));

        DealWithInternalWorkerProcessFailure( hr );

    }


}   // WORKER_PROCESS::Initialize



/***************************************************************************++

Routine Description:

    Shut down the worker process. This can safely be called multiple times
    on an instance.

Arguments:

    BOOL ShutdownImmediately = tell worker processes to shutdown immediately.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::Shutdown(
    BOOL ShutdownImmediately
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    // take a reference, because we do not want to end up marking the
    // worker process as terminal and releasing it before we are done 
    // working with it here.
    Reference();

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // The actions needed for shutdown depend on the current state of
    // this object.
    //


    switch ( m_State )
    {

    case UninitializedWorkerProcessState:

        //
        // If we haven't even initialized this instance successfully, then
        // we don't need to do any work here. 
        //

        break;

    case RegistrationPendingWorkerProcessState:

        //
        // We can't tell the worker process to shut down right away,
        // because it hasn't yet called back to register with us, and thus
        // we have no means to communicate with it. However, we also
        // shouldn't just blow it away, because it may have already
        // started processing requests, or perhaps application running
        // inside of it may have modified persistent or shared state.
        // Therefore, remember that we are waiting to shut down, and once
        // the worker process registers, immediately start the shutdown
        // procedure.
        //

        m_State = RegistrationPendingShutdownPendingWorkerProcessState;
        m_ShutdownType = ShutdownImmediately;

        break;

    case RegistrationPendingShutdownPendingWorkerProcessState:

        //
        // We are already waiting to start shutdown as soon as possible;
        // no need for further action.
        //

        break;

    case RunningWorkerProcessState:

        //
        // Tell the worker process to shut down. Note that if starting
        // clean shutdown fails, the method will go ahead and Terminate()
        // the instance.
        //

        hr = InitiateProcessShutdown( ShutdownImmediately );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating process shutdown failed\n"
                ));

        }

        break;

    case ShutdownPendingWorkerProcessState:

        //
        // We are already shutting down; no need for further action.
        //

        break;

    case DeletePendingWorkerProcessState:

        //
        // We are already waiting to go away as soon as our ref count
        // hits zero; no need for further action.
        //

        break;

    default:

        //
        // Invalid state!
        //

        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initiating clean worker process shutdown failed\n"
            ));

        DealWithInternalWorkerProcessFailure( hr );
    }

    // Now if it wants to go away, that is fine with us.
    Dereference();

}   // WORKER_PROCESS::Shutdown


/***************************************************************************++

Routine Description:

    RequestCounters from the worker process.

Arguments:

    None.

Return Value:

    BOOL

--***************************************************************************/

BOOL
WORKER_PROCESS::RequestCounters(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // Only request counters if the worker process is in a running state
    // and if we aren't all ready waiting for the worker process to provide
    // counters.
    //

    if ( m_State == RunningWorkerProcessState && m_PerfCounterState == IdleWorkerProcessPerfCounterState )
    {

        hr = m_pMessagingHandler->RequestCounters();

        if ( FAILED( hr ) )
        {

            WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

            _snwprintf( StringizedProcessId, sizeof( StringizedProcessId ) 
                / sizeof ( WCHAR ), L"%lu", ( m_RegisteredProcessId ? m_RegisteredProcessId 
                                                                    : m_ProcessId ) );

            // To make prefast happy we null terminate, however the string was setup to take 
            // exactly the max size the snwprintf (including the null) can provide, 
            // so we don't worry about losing data.
            StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

            const WCHAR * EventLogStrings[2];
            EventLogStrings[0] = m_pAppPool->GetAppPoolId();
            EventLogStrings[1] = StringizedProcessId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_FAILED_TO_ISSUE_REQUEST_FOR_COUNTERS,   // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                      // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "RequestCounters message failed\n"
                ));
 
            return FALSE;
        }

        m_PerfCounterState = WaitingWorkerProcessPerfCounterState;    

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker Process counter state after requesting counters is now %d\n",
                m_PerfCounterState
                ));
        }

    }
    else
    {
        //
        // Only if we are not waiting for counters to be returned
        // should we remove ourselves from the count of worker processes
        // to be waited on.
        //
        if ( m_PerfCounterState != WaitingWorkerProcessPerfCounterState )
        {
            return FALSE;
        }
    }

    return TRUE;

}   // WORKER_PROCESS::RequestCounters

/***************************************************************************++

Routine Description:

    Have the worker process reset it's perf counter state
    if the state is set to answered.  If we are still waiting
    then leave it's state as waiting.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::ResetPerfCounterState(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( CheckSignature() );

    //
    // Only reset the state if the state is answered.
    // If it is waiting or idle then it should stay 
    // that way.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Worker process counter state before reseting is: %d\n",
            m_PerfCounterState
            ));
    }

    if ( m_PerfCounterState == AnsweredWorkerProcessPerfCounterState )
    {
        m_PerfCounterState = IdleWorkerProcessPerfCounterState;
    }

}   // WORKER_PROCESS::ResetPerfCounterState


/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities
    which may hold a reference to this object to release that reference
    (and not take any more), in order to break reference cycles.

    Note that this function may cause the instance to delete itself;
    instance state should not be accessed when unwinding from this call.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::Terminate(
    )
{

    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Only clean up if we haven't done so already.
    //

    if ( m_State != DeletePendingWorkerProcessState )
    {

        //
        // Set the state to show we're dead, and just waiting for our ref
        // count to hit zero.
        //

        m_State = DeletePendingWorkerProcessState;


        //
        // Cancel the startup timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelStartupTimer() ) );


        //
        // Cancel the shutdown timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelShutdownTimer() ) );

        //
        // Cancel the send ping timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelSendPingTimer() ) );


        //
        // Cancel the ping response timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelPingResponseTimer() ) );


        //
        // Close down the named pipe.
        //
        if ( m_pMessagingHandler )
        {
            m_pMessagingHandler->Terminate();

            m_pMessagingHandler->Dereference();
            m_pMessagingHandler = NULL;
        }

        //
        // Cancel the process handle wait, if present.
        //

        DBG_REQUIRE( SUCCEEDED( DeregisterProcessWait() ) );


        // Tell ASP that the worker process is terminating,
        // only if we actually have the pid from the wp.
        if ( m_RegisteredProcessId != INVALID_PROCESS_ID )
        {

            if ( GetWebAdminService()->
                GetUlAndWorkerManager()->
                GetAspPerfManager() != NULL )
            {
                GetWebAdminService()->
                    GetUlAndWorkerManager()->
                    GetAspPerfManager()->ProcessDied( m_RegisteredProcessId );
            }
        }
       
        if ( m_ProcessAlive )
        {

            //
            // Blow away the process.
            //

            KillProcess();

        }


        //
        // If we are still holding a reference to a worker process to replace,
        // tell it to shut down, and clean up the reference.
        //

        if ( m_pWorkerProcessToReplace != NULL )
        {
            m_pWorkerProcessToReplace->Shutdown( FALSE );

            m_pWorkerProcessToReplace->Dereference();
            m_pWorkerProcessToReplace = NULL;
        }


        //
        // If we haven't already told the parent app pool that our startup
        // attempt is over, we do so now.
        //

        if ( ! m_NotifiedAppPoolThatStartupAttemptDone )
        {
            m_pAppPool->WorkerProcessStartupAttemptDone( m_StartReason );
            m_NotifiedAppPoolThatStartupAttemptDone = TRUE;
        }


        //
        // Tell our parent to remove this instance from it's data structures,
        // and dereference the instance.
        //

        m_pAppPool->RemoveWorkerProcessFromList( this );

        //
        // Note: that may have been our last reference, so don't do any
        // more work here.
        //

    }

}   // WORKER_PROCESS::Terminate



/***************************************************************************++

Routine Description:

    Request a replacement for this worker process.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::InitiateReplacement(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT ( m_pAppPool );

    //
    // Check if we are already being replaced; if so, we ignore this new
    // request to do so.
    //

    if ( m_BeingReplaced )
    {
        return;
    }

    hr = m_pAppPool->RequestReplacementWorkerProcess( this );
    if ( FAILED( hr ) )
    {

        // It may be valid to disallow a worker process to be
        // replaced, it could be that we are not allowed to
        // do overlapping rotation.  We should not complain, 
        // we should just shutdown the existing worker process.
        if ( hr != E_FAIL )
        {
            WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

            _snwprintf( StringizedProcessId, sizeof( StringizedProcessId ) 
                / sizeof ( WCHAR ), L"%lu", ( m_RegisteredProcessId ? m_RegisteredProcessId 
                                                                    : m_ProcessId ) );

            // To make prefast happy we null terminate, however the string was setup to take 
            // exactly the max size the snwprintf (including the null) can provide, 
            // so we don't worry about losing data.
            StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

            const WCHAR * EventLogStrings[2];
            EventLogStrings[0] = m_pAppPool->GetAppPoolId();
            EventLogStrings[1] = StringizedProcessId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_FAILED_TO_OVERLAP_RECYCLE,   // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                      // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Requesting replacement worker process failed\n"
                ));
        }

        //
        // Since creating the replacement worker process failed, it may
        // not be calling back later to tell this instance to start
        // shutting down. Therefore, start shutdown ourselves. Note that
        // calling Shutdown() multiple times is ok.
        //

        Shutdown( FALSE );

        return;
    }


    //
    // Now that we are being replaced, our replacer will tell us to begin
    // our shutdown once it's start-up attempt is complete.
    //

    m_BeingReplaced = TRUE;


}   // WORKER_PROCESS::InitiateReplacement



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from a LIST_ENTRY to a WORKER_PROCESS.

Arguments:

    pListEntry - A pointer to the m_AppPoolListEntry member of a WORKER_PROCESS.

Return Value:

    The pointer to the containing WORKER_PROCESS.

--***************************************************************************/

// note: static!
WORKER_PROCESS *
WORKER_PROCESS::WorkerProcessFromAppPoolListEntry(
    IN const LIST_ENTRY * pListEntry
)
{

    WORKER_PROCESS * pWorkerProcess = NULL;

    DBG_ASSERT( pListEntry != NULL );

    //  get the containing structure, then verify the signature
    pWorkerProcess = CONTAINING_RECORD( pListEntry, WORKER_PROCESS, m_AppPoolListEntry );

    DBG_ASSERT( pWorkerProcess->m_Signature == WORKER_PROCESS_SIGNATURE );

    return pWorkerProcess;

}   // WORKER_PROCESS::WorkerProcessFromAppPoolListEntry



/***************************************************************************++

Routine Description:

    Determine whether this process is going to go away soon, i.e. if it is
    in the process of being replaced or shutting down. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if this worker process will go away soon, FALSE otherwise.

--***************************************************************************/

BOOL
WORKER_PROCESS::IsGoingAwaySoon(
    )
    const
{

    DBG_ASSERT ( CheckSignature() );

    //
    // If this instance is in a shutdown pending or delete pending state, or
    // if it is being replaced (and so is guaranteed to get shutdown soon) 
    // then we pronounce that it is going away soon.
    //

    return ( ( m_BeingReplaced ) ||
             ( m_State == RegistrationPendingShutdownPendingWorkerProcessState ) ||
             ( m_State == ShutdownPendingWorkerProcessState ) ||
             ( m_State == DeletePendingWorkerProcessState ) );

}   // WORKER_PROCESS::IsGoingAwaySoon



/***************************************************************************++

Routine Description:

    Handle the fact that the worker process has registered successfully
    via IPM. This does not mean that the worker process is up and running,
    it means that the pipe is connected and we now know the pid.

Arguments:

    RegisteredProcessId - The pid of the worker process, as communicated
    back via IPM during its registration. 

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::WorkerProcessRegistrationReceived(
    IN DWORD RegisteredProcessId
    )
{

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    // Verify that we haven't all ready been told the 
    // registration id.  If we have, then the worker 
    // process has become untrusted.
    if ( m_RegisteredProcessId != INVALID_PROCESS_ID )
    {
        DPERROR((
            DBG_CONTEXT,
            (DWORD)E_UNEXPECTED,
            "Received a new pid after the pid was already set for worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));

        MarkAsTerminallyIll( UntrustedWorkerProcessTerminalIllnessReason, 0, E_UNEXPECTED );
        return;
    }

    m_RegisteredProcessId = RegisteredProcessId;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Registration received from worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


}   // WORKER_PROCESS::WorkerProcessRegistrationReceived


/***************************************************************************++

Routine Description:

    Handle the fact that the worker process has reported a successful startup,
    at this point we stop the timers, and can shutdown other worker processes,
    even let the app pool know that we are up.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::WorkerProcessStartupSucceeded(
    )
{

    HRESULT hr = S_OK;
    WORKER_PROCESS_STATE PreviousState = UninitializedWorkerProcessState;

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( m_pAppPool );

    PreviousState = m_State;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Worker process entering running state (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }

    m_State = RunningWorkerProcessState;

    //
    // We've received the message, so get rid of the timer.
    //
    
    hr = CancelStartupTimer();
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling startup timer failed\n"
            ));

        goto exit;
    }


    //
    // Check to see if we were waiting to shut down as soon as
    // registration happened.
    //

    if ( PreviousState == RegistrationPendingShutdownPendingWorkerProcessState )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process shutdown was pending on registration; start now (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }

        Shutdown( m_ShutdownType );

    }
    else
    {
        //
        // This is the normal path; as such, we should have been in
        // the registration pending state.
        //

        DBG_ASSERT( PreviousState == RegistrationPendingWorkerProcessState );

        //
        // Notify the app pool that our startup is done.
        //
        m_pAppPool->WorkerProcessStartupAttemptDone( m_StartReason );
        m_NotifiedAppPoolThatStartupAttemptDone = TRUE;

        if ( m_pWorkerProcessToReplace != NULL )
        {
            //
            // If we were replacing another worker process, then shut it down
            // and clean up our reference to it.
            //

            m_pWorkerProcessToReplace->Shutdown( FALSE );

            m_pWorkerProcessToReplace->Dereference();
            m_pWorkerProcessToReplace = NULL;
        }

        //
        // Initiate starting of WP recycler
        //

        hr = SendWorkerProcessRecyclerParameters();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating start of worker process recycler failed\n"
                ));

            goto exit;
        }

        hr = BeginSendPingTimer();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Starting send ping timer failed\n"
                ));

            goto exit;
        }

    }

exit:

    if ( FAILED ( hr ) )
    {
        DealWithInternalWorkerProcessFailure( hr );
    }

}   // WORKER_PROCESS::WorkerProcessStartupSucceeded


/***************************************************************************++

Routine Description:

    Handle a response from the worker process to a previous ping message.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::PingReplyReceived(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( !m_BackwardCompatibilityEnabled );
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Ping reply received from worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }

    if ( ! m_AwaitingPingReply )
    {
        DPERROR((
            DBG_CONTEXT,
            (DWORD) E_UNEXPECTED,
            "Received a ping reply when no reply was warrented (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));

        MarkAsTerminallyIll( UntrustedWorkerProcessTerminalIllnessReason, 0, E_UNEXPECTED ); 
        return;
    }

    // Reset whether or not we have seen a ping failure and
    // not worried about it.
    m_IgnoredPingDueToDebugger = FALSE;
    m_AwaitingPingReply = FALSE;

    //
    // Cancel the timer that enforces a timely ping response; then start
    // the timer that will tell us when to ping again.
    //

    hr = CancelPingResponseTimer();
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling ping response timer failed\n"
            ));

        goto exit;
    }


    hr = BeginSendPingTimer();
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Starting send ping timer failed\n"
            ));

        goto exit;
    }


exit:

    // A failure will cause the WP to be terminated
    // and another WP can take it's place.
    if ( FAILED ( hr ) )
    {
        DealWithInternalWorkerProcessFailure( hr );
    }

}   // WORKER_PROCESS::PingReplyReceived

/***************************************************************************++

Routine Description:

    Records that a worker processes counters have been received.

Arguments:

    DWORD MessageLength - Length of message containing counters.
    const BYTE* pMessage - the counters themselves.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::RecordCounters(
    DWORD MessageLength,
    const BYTE* pMessage
    )
{

    PERF_MANAGER* pManager = NULL;

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Counters received from worker process (ptr: %p; pid: %lu; realpid: %lu; perf state: %d)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            m_PerfCounterState
            ));
    }

    //
    // If the worker process has not all ready answered then we 
    // can record counters.  
    //
    if ( m_PerfCounterState != AnsweredWorkerProcessPerfCounterState )
    {
        //
        // Remember that we have recorded counters for this worker 
        // process so we don't do it again.
        //
        m_PerfCounterState = AnsweredWorkerProcessPerfCounterState;

        //
        // This will let the performance manager know that it is waiting for
        // one less worker process to produce numbers.  When this hits Zero 
        // we will publish.
        //
        pManager = GetWebAdminService()->
                   GetUlAndWorkerManager()->
                   GetPerfManager();

        //
        // We could receive counters from a worker process and not
        // have a perf manager.  In this case, just ignor the message.
        //
        if ( pManager )
        {
            if ( !pManager->RecordCounters(MessageLength, pMessage) )
            {
                DPERROR((
                    DBG_CONTEXT,
                    (DWORD) E_UNEXPECTED,
                    "Perf counter data was not of correct size (ptr: %p; pid: %lu; realpid: %lu)\n",
                    this,
                    m_ProcessId,
                    m_RegisteredProcessId
                    ));

                MarkAsTerminallyIll( UntrustedWorkerProcessTerminalIllnessReason, 0, E_UNEXPECTED );
                return;
            }
        }
    }

}   // WORKER_PROCESS::RecordCountersReceived

/***************************************************************************++

Routine Description:

    Handles an hresult being sent in by the worker process

Arguments:

    HRESULT hrToHandle - the hresult to process

Return Value:

    VOID

--***************************************************************************/
VOID
WORKER_PROCESS::HandleHresult(
    HRESULT hrToHandle 
    )
{

    // Need to determine if we are attempting to startup the worker process,
    // if we are then if this is successful, we need to call the startup complete.
    if ( ( m_State == RegistrationPendingWorkerProcessState ) ||
         ( m_State == RegistrationPendingShutdownPendingWorkerProcessState ) )
    {
        if ( SUCCEEDED ( hrToHandle ) )
        {
            WorkerProcessStartupSucceeded();
            return;
        }
    }

    // we got an S_OK but are not in the startup phase.
    if ( SUCCEEDED ( hrToHandle ) )
    {
        DPERROR((
            DBG_CONTEXT,
            (DWORD) E_UNEXPECTED,
            "Received a S_OK response when no response was warrented (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));

        MarkAsTerminallyIll( UntrustedWorkerProcessTerminalIllnessReason, 0, E_UNEXPECTED );
        return;
    }

    //
    // We don't worry about the case where we got an S_OK but were not in the middle of
    // starting up.  I think this might be able to happen if we timeout right before we 
    // get the S_OK sent.
    //

    if ( FAILED ( hrToHandle ) ) 
    {
        //
        // Need to mark the worker process as terminally ill, this
        // may be during startup, or it may be anytime during the worker
        // processes lifetime.
        //
        MarkAsTerminallyIll( WorkerProcessPassedBadHresultTerminalIllnessReason, 0, hrToHandle );

        return;
    }

}   // WORKER_PROCESS::HandleHresult

/***************************************************************************++

Routine Description:

    Handle a request from the worker process to shut down. The response can
    either be to ignore it, if the shutdown request is refused, or to send
    a shutdown message if it is granted.

Arguments:

    ShutdownRequestReason - The reason the worker process is requesting
    shutdown.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::ShutdownRequestReceived(
    IN IPM_WP_SHUTDOWN_MSG ShutdownRequestReason
    )
{

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // Only requests below are if the wp has gone idle or if 
    // the wp has processed too many requests.  Neither of these
    // should ever happen in backward compatibile mode.
    if ( m_BackwardCompatibilityEnabled )
    {
        DPERROR((
            DBG_CONTEXT,
            (DWORD) E_UNEXPECTED,
            "A recycle was requested in backward compatibility mode (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));

        MarkAsTerminallyIll( UntrustedWorkerProcessTerminalIllnessReason, 0, E_UNEXPECTED );
        return;
    }

    //
    // Ignore shutdown requests from the worker process if we are not
    // currently in the running state.
    //
    if ( m_State != RunningWorkerProcessState )
    {
        return;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Process shutdown request received from worker process (ptr: %p; pid: %lu; realpid: %lu), reason: %lu\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            ShutdownRequestReason
            ));
    }


    if ( ShutdownRequestReason == IPM_WP_RESTART_COUNT_REACHED ||
         ShutdownRequestReason == IPM_WP_RESTART_SCHEDULED_TIME_REACHED ||
         ShutdownRequestReason == IPM_WP_RESTART_ELAPSED_TIME_REACHED ||
         ShutdownRequestReason == IPM_WP_RESTART_VIRTUAL_MEMORY_LIMIT_REACHED ||
         ShutdownRequestReason == IPM_WP_RESTART_ISAPI_REQUESTED_RECYCLE ||
         ShutdownRequestReason == IPM_WP_RESTART_PRIVATE_BYTES_LIMIT_REACHED )
    {

        const WCHAR * EventLogStrings[2];
        WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
        DWORD MessageId = 0;
        DWORD BitToCheck = 0;

        switch ( ShutdownRequestReason )
        {
            case IPM_WP_RESTART_ELAPSED_TIME_REACHED:
                MessageId = WAS_EVENT_RECYCLE_WP_TIME;
                BitToCheck = MD_APP_POOL_RECYCLE_TIME;
            break;

            case IPM_WP_RESTART_COUNT_REACHED:
                MessageId = WAS_EVENT_RECYCLE_WP_REQUEST_COUNT;
                BitToCheck = MD_APP_POOL_RECYCLE_REQUESTS;
            break;

            case IPM_WP_RESTART_SCHEDULED_TIME_REACHED:
                MessageId = WAS_EVENT_RECYCLE_WP_SCHEDULED;
                BitToCheck = MD_APP_POOL_RECYCLE_SCHEDULE;
            break;

            case IPM_WP_RESTART_VIRTUAL_MEMORY_LIMIT_REACHED:
                MessageId = WAS_EVENT_RECYCLE_WP_MEMORY;
                BitToCheck = MD_APP_POOL_RECYCLE_MEMORY;
            break;

            case IPM_WP_RESTART_ISAPI_REQUESTED_RECYCLE:
                MessageId = WAS_EVENT_RECYCLE_WP_ISAPI;
                BitToCheck = MD_APP_POOL_RECYCLE_ISAPI_UNHEALTHY;
            break;

            case IPM_WP_RESTART_PRIVATE_BYTES_LIMIT_REACHED:
                MessageId = WAS_EVENT_RECYCLE_WP_MEMORY_PRIVATE_BYTES;
                BitToCheck = MD_APP_POOL_RECYCLE_PRIVATE_MEMORY;
            break;
            
            default:
                // in this case the BitToCheck will be zero
                // and we just won't print a message, no real
                // bad path for retail.
                DBG_ASSERT( FALSE );
            break;
        }

        if ( ( m_pAppPool->GetRecycleLoggingFlags() & BitToCheck ) != 0 )
        {
            // String is declared to be long enough to handle 
            // the max size of a DWORD, which should be what this call
            // returns.
            _snwprintf( StringizedProcessId, sizeof( StringizedProcessId ) 
                / sizeof ( WCHAR ), L"%lu", ( m_RegisteredProcessId ? m_RegisteredProcessId 
                                                                    : m_ProcessId ) );

            // To make prefast happy we null terminate, however the string was setup to take 
            // exactly the max size the snwprintf (including the null) can provide, 
            // so we don't worry about losing data.
            StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

            EventLogStrings[0] = StringizedProcessId;
            EventLogStrings[1] = m_pAppPool->GetAppPoolId();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    MessageId,                              // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    S_OK                                    // error code
                    );
        }

        //
        // Time to replace this worker process. Request a replacement;
        // this instance will be informed to shut down later.
        //

        InitiateReplacement();

    }
    else if ( ShutdownRequestReason == IPM_WP_IDLE_TIME_REACHED )
    {

        //
        // This worker process is idle; tell it to shut down.
        //

        Shutdown( FALSE );

    }
    else
    {

        //
        // Invalid shutdown request reason!
        //
        DPERROR((
            DBG_CONTEXT,
            (DWORD) E_UNEXPECTED,
            "Received an invalid shutdown reason (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));

        MarkAsTerminallyIll( UntrustedWorkerProcessTerminalIllnessReason, 0, E_UNEXPECTED );

    }

}   // WORKER_PROCESS::ShutdownRequestReceived



/***************************************************************************++

Routine Description:

    Handle an error from the IPM layer.

Arguments:

    Error - The error code from IPM.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::IpmErrorOccurred(
    IN HRESULT Error
    )
{

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( ( m_State == ShutdownPendingWorkerProcessState ) && 
         ( ( Error == HRESULT_FROM_NT ( STATUS_PIPE_BROKEN ) ) ||
           ( Error == HRESULT_FROM_WIN32 ( ERROR_BROKEN_PIPE ) ) ) )
    {

        //
        // If we've asked the worker process to shut down, we expect
        // it to break off the pipe. Therefore, in this case, ignore
        // it unless we are in backward compatiblity mode.  If we are 
        // than this is the signal that the wp has shutdown so we need
        // to Terminate the worker process before ignoring the IPM call.
        //

        if (m_BackwardCompatibilityEnabled)
        {
            Terminate();
        }
        
        return;
    }

    //
    // If the handle has not signalled then we will go ahead and process
    // the IPM failure, but first let's give it every chance to be signalled.
    //
    // It looks like waiting just 1 ms works and is good enough ( 0 does not work )
    // however if this starts to fail, we probably will want to requeue the IPM error
    // and give a crash a chance to come through, instead of waiting for longer
    // periods of time, which block other process management.
    //
    if ( m_BackwardCompatibilityEnabled ||
         ( m_HandleSignalled == FALSE &&
         ( m_ProcessHandle == NULL || 
           WaitForSingleObject( m_ProcessHandle, 1 ) != WAIT_OBJECT_0 )))
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "IPM error occurred with worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }

        //
        // Losing communication with the worker process is bad. We consider
        // this a terminal condition.
        //

        MarkAsTerminallyIll( IPMErrorWorkerProcessTerminalIllnessReason, 0, Error );
    }
    else
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Ignoring IPM error so crash can be handled (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }
    }

}   // WORKER_PROCESS::IpmErrorOccurred

/***************************************************************************++

Routine Description:

    Handle shutting down the worker process when a untrusted communication
    arrives from the worker process.

Arguments:

    NONE

Return Value:

    VOID

--***************************************************************************/
VOID
WORKER_PROCESS::UntrustedIPMTransferReceived(
    )
{

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // If we no longer trust the worker process we want to either
    // abandon it or kill it.
    //
    DPERROR((
        DBG_CONTEXT,
        (DWORD) E_UNEXPECTED,
        "Messaging handler reported invalid data sent (ptr: %p; pid: %lu; realpid: %lu)\n",
        this,
        m_ProcessId,
        m_RegisteredProcessId
        ));

    MarkAsTerminallyIll( UntrustedWorkerProcessTerminalIllnessReason, 0, E_UNEXPECTED );

}   // WORKER_PROCESS::UntrustedIPMTransferReceived

/***************************************************************************++

Routine Description:

    Spin up a worker process in inetinfo.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::StartProcessInInetinfo(
    )
{

    DBG_ASSERT ( CheckSignature() );

    // Function should only be called in 
    // backward compatibility mode.
    DBG_ASSERT(m_BackwardCompatibilityEnabled);

    // Tell the Admin Service to signal inetinfo to 
    // launch the worker process.  The worker process
    // will signal us back by connecting to the ipm.
    // if it fails to we will time out the worker process.
    return GetWebAdminService()->LaunchInetinfo();
}

/***************************************************************************++

Routine Description:

    Spin up the actual process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::StartProcess(
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    STRU ExeWithPath;
    STRU ArgsForCommandLine;
    DWORD ReturnCode = 0;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    DBG_ASSERT( m_pAppPool );
    DBG_ASSERT( m_pAppPoolConfig );

    SecureZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );
    StartupInfo.lpDesktop = GetWebAdminService()->GetWPDesktopString();

    SecureZeroMemory( &ProcessInfo, sizeof( ProcessInfo ) );

    //
    // Create the command line.
    //

    hr = CreateCommandLine( &ExeWithPath, &ArgsForCommandLine );
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating command line failed\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Launching worker process with command line of %S\n",
            ArgsForCommandLine.QueryStr()
            ));
    }

    //
    // issue: when we fix change notifications to work for worker processes
    // identities, we will nedd to change this to read from the m_pAppPoolConfig
    // object instead.
    //

    DBG_ASSERT ( m_pAppPoolConfig->GetWorkerProcessToken() != NULL );

    //
    // Create the actual process.
    //
    // We create the process suspended so that, if necessary, we can
    // affinitize it to a particular processor.
    //
    // We pass as the current directory the current directory of the
    // web admin service DLL; the worker process EXE and its components
    // live in the same directory.
    //

    Success = CreateProcessAsUser(
                    m_pAppPoolConfig->GetWorkerProcessToken(),    // security token for new process
                    ExeWithPath.QueryStr(), // program name
                    ArgsForCommandLine.QueryStr(), // command line
                    NULL,                   // process security attributes
                    NULL,                   // thread security attributes
                    FALSE,                  // handle inheritance flag
                    CREATE_SUSPENDED | DETACHED_PROCESS,
                                            // creation flags
                    NULL,                   // environment block
                    GetWebAdminService()->GetCurrentDirectory(),
                                            // current directory name
                    &StartupInfo,           // STARTUPINFO
                    &ProcessInfo            // PROCESS_INFORMATION
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "New worker process created (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }

    //
    // at this point we have succeeded in starting
    // the process, so we can go ahead and hold on to 
    // the info we have about the process.
    //
    m_ProcessId = ProcessInfo.dwProcessId;
    m_ProcessHandle = ProcessInfo.hProcess;
    m_ProcessAlive = TRUE;

    //
    // If this worker process should be affinitized, do it now.
    //

    if ( m_pAppPoolConfig->GetSMPAffinitized() )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Affinitizing new process with mask: %p\n",
                m_pAppPoolConfig->GetSMPAffinitizedProcessorMask()
                ));
        }
        
        Success = SetProcessAffinityMask(
                        m_ProcessHandle,        // handle to process
                        m_pAppPoolConfig->GetSMPAffinitizedProcessorMask()   // process affinity mask
                        );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not set process affinity mask\n"
                ));

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPool->GetAppPoolId();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_FAILED_PROCESS_AFFINITY_SETTING,        // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                       // error code
                    );

            m_TerminallyIllShutdownRegardless = TRUE;

            goto exit;

        }

    }

    //
    // Before we let the process run, we need to add it to the Job Object
    //
    m_pAppPool->AddWorkerProcessToJobObject( this );

    //
    // Let the process run.
    //
    // Note that ResumeThread returns 0xFFFFFFFF to signal an error, or
    // the previous suspend count otherwise (which should always be one
    // in this case).
    //

    ReturnCode = ResumeThread( ProcessInfo.hThread );
    if ( ReturnCode == 0xFFFFFFFF )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not resume thread\n"
            ));

        goto exit;
    }
    else
    {
        DBG_ASSERT( ReturnCode == 1 );
    }


exit:

    if ( ProcessInfo.hThread != NULL )
    {
        DBG_REQUIRE( CloseHandle( ProcessInfo.hThread ) );
        ProcessInfo.hThread = NULL;
    }

    //
    // If we failed to start the process,
    // but we did get a handle to the process
    // we want to kill the process off, instead of 
    // letting it sit around not running.
    //
    if ( FAILED ( hr ) &&
         ProcessInfo.hProcess != NULL )
    {

        //
        // at this point we may have all ready saved
        // these values off, but we shouldn't of because
        // we have actually failed so we are resetting 
        // them back to null before we terminate the process.
        //
        m_ProcessId = INVALID_PROCESS_ID;
        m_ProcessHandle = NULL;
        m_ProcessAlive = FALSE;

        // Need the heavy handed terminate process since the process
        // can not be trusted to Exit if ExitProcess is called.
        Success = TerminateProcess(
                        ProcessInfo.hProcess,           // handle of process to terminate
                        KILLED_WORKER_PROCESS_EXIT_CODE // exit code for the process
                        );

        if ( ! Success )
        {
            DPERROR((
                DBG_CONTEXT,
                HRESULT_FROM_WIN32( GetLastError() ),
                "Terminating process failed\n"
                ));

        }

        DBG_REQUIRE( CloseHandle( ProcessInfo.hProcess ) );
        ProcessInfo.hProcess = NULL;
    }

    return hr;

}   // WORKER_PROCESS::StartProcess



/***************************************************************************++

Routine Description:

    Create the command line to pass to the worker process. It is of the
    form:
    "WorkerProcessExePath -a RegistationId [-r RestartRequestCount] [-t IdleTimeout] AppPoolId".

Arguments:

    pExeWithPath - The returned executable including it's path to launch.

    pCommandLineArgs - The arguments to be passed to the executable on launch.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CreateCommandLine(
    OUT STRU * pExeWithPath,
    OUT STRU * pCommandLineArgs
    )
{

    HRESULT hr = S_OK;
    ULONG PeriodicProcessRestartRequestCount = 0;
    ULONG IdleTimeoutInMinutes = 0;

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT(!m_BackwardCompatibilityEnabled);

    //
    // Buffer must be long enough to hold " -r [stringized restart request count]".
    //
    WCHAR RestartRequestCountSwitch[ 4 + MAX_STRINGIZED_ULONG_CHAR_COUNT ];

    //
    // Buffer must be long enough to hold " -t [stringized idle timeout]".
    //
    WCHAR IdleTimoutSwitch[ 4 + MAX_STRINGIZED_ULONG_CHAR_COUNT ];


    DBG_ASSERT( pExeWithPath != NULL && pCommandLineArgs != NULL );

    if ( pExeWithPath == NULL ||
         pCommandLineArgs == NULL )
    {
        return E_INVALIDARG;
    }

    //
    // Put in the path to the EXE.
    //
    hr = pExeWithPath->Append( GetWebAdminService()->GetCurrentDirectory() );
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }

    //
    // Put in the EXE name.
    //

    hr = pExeWithPath->Append( WORKER_PROCESS_EXE_NAME );
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }

    // 
    // Now also copy the file name into the arg list because that is what the system expects.
    //
    hr = pCommandLineArgs->Append( pExeWithPath->QueryStr() );
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to exe into the variable failed\n"
            ));

        goto exit;
    }

    //
    // Pass the registration id.
    //
    hr = pCommandLineArgs->Append( L" -a ");
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }

    hr = pCommandLineArgs->Append( m_pMessagingHandler->QueryPipeName() );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }


    //
    // If a periodic restart request count has been set (non-zero), then
    // put that information in the command line for the worker process.
    //

    if ( m_pAppPoolConfig->GetPeriodicProcessRestartRequestCount() != 0 )
    {

        PeriodicProcessRestartRequestCount = (DWORD) ( m_PercentValueForStaggering 
                                               * m_pAppPoolConfig->GetPeriodicProcessRestartRequestCount() ); 

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
        
            DBGPRINTF(( DBG_CONTEXT,
                        "\nRestartRequests = %d\n"
                        "Raw Number = %d \n"
                        "Staggering Percent = %f \n",
                        PeriodicProcessRestartRequestCount,
                        m_pAppPoolConfig->GetPeriodicProcessRestartRequestCount(),
                        m_PercentValueForStaggering ));
        }

        //
        // If the calculation reduces this to 0 requests, we still want recycling to
        // be on, so we need to up it to 1.  Need to check with Billkar on this behavior.
        //
        if ( PeriodicProcessRestartRequestCount == 0 )
        {
            PeriodicProcessRestartRequestCount = 1;
        }

        // String is declared to be long enough to handle 
        // 4 chars = " -r " + MAX_ULONG stringized value
        _snwprintf( RestartRequestCountSwitch, sizeof( RestartRequestCountSwitch ) / sizeof ( WCHAR ), L" -r %lu", PeriodicProcessRestartRequestCount );

        // To make prefast happy we null terminate, however the string was setup to take 
        // exactly the max size the snwprintf (including the null) can provide, 
        // so we don't worry about losing data.
        RestartRequestCountSwitch[ 4 + MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

        hr = pCommandLineArgs->Append( RestartRequestCountSwitch );
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying to string failed\n"
                ));

            goto exit;
        }

    }


    //
    // If an idle timeout has been set (non-zero), then put that information
    // in the command line for the worker process.
    //

    IdleTimeoutInMinutes = m_pAppPoolConfig->GetIdleTimeoutInMinutes();
    if ( IdleTimeoutInMinutes != 0 )
    {

        // String is declared to be long enough to handle 
        // 4 chars = " -t " + MAX_ULONG stringized value
        _snwprintf( IdleTimoutSwitch, sizeof( IdleTimoutSwitch ) / sizeof ( WCHAR ), L" -t %lu", IdleTimeoutInMinutes );
        // To make prefast happy we null terminate, however the string was setup to take 
        // exactly the max size the snwprintf (including the null) can provide, 
        // so we don't worry about losing data.
        IdleTimoutSwitch[ 4 + MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

        hr = pCommandLineArgs->Append( IdleTimoutSwitch );
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying to string failed\n"
                ));

            goto exit;
        }

    }

    // if centralized logging is enabled then pass a flag that
    // shows it is enabled.
    if ( GetWebAdminService()->IsCentralizedLoggingEnabled() )
    {
        // probably want to pick a different letter or something.
        hr=pCommandLineArgs->Append(L" -c");
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying to string failed\n"
                ));

            goto exit;
        }

    }


    hr = pCommandLineArgs->Append(L" -ap \"");
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }

    LPCWSTR pAppPoolId = m_pAppPool->GetAppPoolId();
    if ( pAppPoolId )
    {
        WCHAR pStrChar[2];

        // null terminate the string
        pStrChar[1] = L'\0';

        while ( *pAppPoolId != L'\0' )
        {
            if ( *pAppPoolId == L'\\' || *pAppPoolId == L'"' )
            {
                // append an extra slash if needed
                hr = pCommandLineArgs->Append( L"\\" );
                if ( FAILED( hr ) )
                {

                    DPERROR((
                        DBG_CONTEXT,
                        hr,
                        "Failed during escaping\n"
                        ));

                    goto exit;
                }

            }

            // Copy in the character we are dealing with
            pStrChar[0] = *pAppPoolId;

            // now append the actual character
            hr = pCommandLineArgs->Append( pStrChar );
            if ( FAILED( hr ) )
            {
                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Failed during escaping copying actuall character needed\n"
                    ));

                goto exit;
            }

            pAppPoolId++;

        }

    }

    // Now finish off the app pool id
    hr = pCommandLineArgs->Append(L"\"");
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }

exit:

    return hr;

}   // WORKER_PROCESS::CreateCommandLine

/***************************************************************************++

Routine Description:

    Handle the fact that this worker process is a lost cause. Clean it up.
    It will get replaced eventually if needed via demand starting or other
    mechanisms implemented by the app pool.

Arguments:

    TerminalIllnessReason - The reason the process is being declared 
    terminally ill.
    
    ProcessExitCode - The process exit code, if applicable; zero otherwise.

    ErrorCode       - HResult showing the process is having problems.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::MarkAsTerminallyIll(
    IN WORKER_PROCESS_TERMINAL_ILLNESS_REASON TerminalIllnessReason,
    IN DWORD ProcessExitCode,
    IN HRESULT ErrorCode
    )
{

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT ( m_pAppPool );

    // These are the only reasons that should be possible in BC mode.
    // If another reason fires, we will end up with the worker process 
    DBG_ASSERT ( !m_BackwardCompatibilityEnabled ||
                 TerminalIllnessReason == IPMErrorWorkerProcessTerminalIllnessReason ||
                 TerminalIllnessReason == StartupTookTooLongWorkerProcessTerminalIllnessReason ||
                 TerminalIllnessReason == InternalErrorWorkerProcessTerminalIllnessReason ||
                 TerminalIllnessReason == WorkerProcessPassedBadHresultTerminalIllnessReason );
    //
    // If we are already terminally ill, then don't do any more work here.
    //

    if ( m_TerminalIllReason != NotIllTerminalIllnessReason )
    {
        return;
    }

    // 
    // We all ready recorded that we were waiting on a debugger to release
    // a ping.  So now we just restart the timer and let it go.
    //
    if ( m_IgnoredPingDueToDebugger && 
         TerminalIllnessReason == PingFailureProcessTerminalIllnessReason )
    {
        return;
    }

    m_TerminalIllReason = TerminalIllnessReason;

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Marking worker process (ptr: %p; pid: %lu; realpid: %lu) as terminally ill; reason: %lu\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            TerminalIllnessReason
            ));
    }

    //
    // There are some routes ( like if creating the worker process failed ) that will log their own
    // errors.  In these cases we still have to treat the WP as terminally ill, but we don't want to 
    // add extra confusing messages to the event log.
    //
    if ( !m_TerminallyIllShutdownRegardless )
    {
        const WCHAR * EventLogStrings[3];
        WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
        WCHAR StringizedProcessExitCode[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
        DWORD MessageId;

        // String is declared to be long enough to handle 
        // the max size of a DWORD, which should be what this call
        // returns.
        _snwprintf( StringizedProcessId, sizeof( StringizedProcessId ) / sizeof ( WCHAR ), L"%lu", ( m_RegisteredProcessId ? m_RegisteredProcessId : m_ProcessId ) );
        // To make prefast happy we null terminate, however the string was setup to take 
        // exactly the max size the snwprintf (including the null) can provide, 
        // so we don't worry about losing data.
        StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

        // String is declared to be long enough to handle 
        // the max size of a DWORD, which should be what this call
        // returns.
        _snwprintf( StringizedProcessExitCode, sizeof( StringizedProcessExitCode ) / sizeof ( WCHAR ), L"%x", ProcessExitCode );
        // To make prefast happy we null terminate, however the string was setup to take 
        // exactly the max size the snwprintf (including the null) can provide, 
        // so we don't worry about losing data.
        StringizedProcessExitCode[ MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

        EventLogStrings[0] = m_pAppPool->GetAppPoolId();
        EventLogStrings[1] = StringizedProcessId;
        EventLogStrings[2] = StringizedProcessExitCode;

        switch ( TerminalIllnessReason )
        {

        case CrashWorkerProcessTerminalIllnessReason:

            MessageId = WAS_EVENT_WORKER_PROCESS_CRASH;
            break;

        case PingFailureProcessTerminalIllnessReason:

            MessageId = WAS_EVENT_WORKER_PROCESS_PING_FAILURE;
            break;

        case IPMErrorWorkerProcessTerminalIllnessReason:

            MessageId = WAS_EVENT_WORKER_PROCESS_IPM_ERROR;
            break;

        case StartupTookTooLongWorkerProcessTerminalIllnessReason:

            if ( ErrorCode == 0 )
            {
                ErrorCode = HRESULT_FROM_WIN32 ( ERROR_TIMEOUT );
            }

            MessageId = WAS_EVENT_WORKER_PROCESS_STARTUP_TIMEOUT;
            break;

        case ShutdownTookTooLongWorkerProcessTerminalIllnessReason:

            MessageId = WAS_EVENT_WORKER_PROCESS_SHUTDOWN_TIMEOUT;
            break;

        case InternalErrorWorkerProcessTerminalIllnessReason:

            MessageId = WAS_EVENT_WORKER_PROCESS_INTERNAL_ERROR;
            break;

        case WorkerProcessPassedBadHresultTerminalIllnessReason:

            MessageId = WAS_EVENT_WORKER_PROCESS_BAD_HRESULT;
            break;

        case CreateProcessFailedTerminalIllnessReason:

            MessageId = WAS_EVENT_FAILED_PROCESS_CREATION;
            break;

        case UntrustedWorkerProcessTerminalIllnessReason:

            MessageId = WAS_EVENT_WORKER_PROCESS_NOT_TRUSTED;
            break;

        default:

            //
            // Invalid state!
            //

            MessageId = 0;
            DBG_ASSERT( FALSE );
        
            break;

        }


        if ( MessageId != 0 )
        {

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                MessageId,                              // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                (DWORD) ErrorCode                       // error code
                );
        }

        // 
        // See if we care about a debugger being attached and if we do, check if we
        // really want to mark the worker process as ill.  If not, just get out of 
        // here.
        //
        if ( CheckIfDebuggerMakesWPHealthy ( TerminalIllnessReason ) )
        {
            // We not terminal yet.
            m_TerminalIllReason = NotIllTerminalIllnessReason;
            return;
        }

    }
 
    // 
    // If we are not in backward compatiblity mode
    // then report the worker process failure to the
    // app pool.
    //

    if ( !m_BackwardCompatibilityEnabled )
    {
        //
        // Report the failure to the app pool.
        //

        m_pAppPool->ReportWorkerProcessFailure( m_TerminallyIllShutdownRegardless );

    }
    else  // in BC mode, determine if we should trigger a shutdown
          // and log the fact that we are shutting down to the
          // event viewer.
    {
        BOOL fStopService = TRUE;

        //
        // if it is not the IPM then we do want to stop the service for sure
        // if it is IPM and one of these error codes then we need to figure out
        // if inetinfo crashed.  if it did not then we want to stop the service.
        //

        if ( TerminalIllnessReason == IPMErrorWorkerProcessTerminalIllnessReason &&
             ( ( ErrorCode == HRESULT_FROM_WIN32( ERROR_BROKEN_PIPE ) ) ||
               ( ErrorCode == HRESULT_FROM_NT ( STATUS_PIPE_BROKEN ) ) ) )
        {
            //
            // so inetinfo may have crashed, if it did we want the system
            // to handle the inetinfo failure in it's own way, we don't want
            // to shutdwon here.  but if it didn't then we had better shutdown.
            // originally we thought that we would not get these errors unless
            // there was a crash, but in some low resource conditions we can
            // get to this state, and it is bad for w3svc to be running with 
            // no worker process up in BC mode.
            // 

            // 
            // we will check 5 times sleeping 1/2 second each time
            // before we give up and declare that inetinfo did not crash
            // these numbers were picked arbitrarily
            //
            for ( DWORD i = 0; i < 5; i++ )
            {
                // Don't bother sleeping the first time through.

                if ( i > 0 ) 
                {
                    Sleep ( 500 );
                }

                //
                // The flag that is checked under here, is incremented
                // on a secondary thread.  It will not be decremented 
                // until a work item gets to run on this thread.
                //
                if ( GetWebAdminService()->
                        GetConfigAndControlManager()->
                        GetConfigManager()->
                        QueryInetinfoInCrashedState() )
                {
                    fStopService = FALSE;
                    break;
                }
            
            }
        }

        if ( fStopService )
        {
            //
            // Log an event declaring we are shutting down the 
            // W3SVC because of a failure with the worker process
            // currently running in inetinfo.
            //
            IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Shutting down service due to failure in WP in inetinfo\n"
                    ));
            }

            //
            // Log an event: worker process failure shutting down the server.
            //

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_WP_FAILURE_BC,     // message id
                    0,                           // count of strings
                    NULL,                        // array of strings
                    0                            // error code
                    );

            // 
            // Tell the service to shutdown.
            //

            GetWebAdminService()->RequestStopService(FALSE);

            // Tell WAS what to tell the SCM when we shutdown.
            GetWebAdminService()->SetHrToReportToSCM( ErrorCode );

        }  // End of shutting down the service

    } // end of bc mode worker process failure handling.

    //
    // Clean this baby up.
    //

    Terminate();

}   // WORKER_PROCESS::MarkAsTerminallyIll


/***************************************************************************++

Routine Description:

    Check if we are in one of the cases where it matters to us if the 
    debugger is attached and if it is, make sure if we want to terminate
    the worker process or not..

Arguments:

    TerminalIllnessReason - The reason the process is being declared 
    terminally ill.
    
Return Value:

    BOOL -  TRUE means that a debugger is in the way and we are still healthy.

--***************************************************************************/

BOOL
WORKER_PROCESS::CheckIfDebuggerMakesWPHealthy(
    IN WORKER_PROCESS_TERMINAL_ILLNESS_REASON TerminalIllnessReason
    )
{
    DBG_ASSERT( m_pAppPool );

    //
    // If we don't have a registered process id, or if we
    // don't have a reason that matches the reasons that are
    // safe to ignore.
    //
    if ( m_RegisteredProcessId == INVALID_PROCESS_ID ||
         m_ProcessAlive == FALSE ||
         ( TerminalIllnessReason != PingFailureProcessTerminalIllnessReason &&
           TerminalIllnessReason != StartupTookTooLongWorkerProcessTerminalIllnessReason &&
           TerminalIllnessReason != ShutdownTookTooLongWorkerProcessTerminalIllnessReason ) )
    {
        return FALSE;
    }

    //
    // Orphaning is enabled, so don't worry about checking for the debugger.
    //
    if ( m_pAppPoolConfig->IsOrphaningProcessesForDebuggingEnabled() )
    {
        return FALSE;
    }

    //
    // If there is no debugger attached.
    //
    if ( IsDebuggerAttachedToProcess ( m_RegisteredProcessId ) == FALSE )
    {
        return FALSE;
    }

    //
    // At this point we know we are going to ignore it, so we want to
    // possibly write an event log message and get out of here.
    //

    const WCHAR * EventLogStrings[2];
    WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

    // String is declared to be long enough to handle 
    // the max size of a DWORD, which should be what this call
    // returns.

    _snwprintf( StringizedProcessId, sizeof( StringizedProcessId ) / sizeof ( WCHAR ), L"%lu", m_RegisteredProcessId );

    EventLogStrings[0] = m_pAppPool->GetAppPoolId();
    EventLogStrings[1] = StringizedProcessId;

    switch ( TerminalIllnessReason )
    {

        case PingFailureProcessTerminalIllnessReason:

            m_IgnoredPingDueToDebugger = TRUE;

        break;

        case StartupTookTooLongWorkerProcessTerminalIllnessReason:

            m_IgnoredStartupTimelimitDueToDebugger = TRUE;

        break;

        case ShutdownTookTooLongWorkerProcessTerminalIllnessReason:

            m_IgnoredShutdownTimelimitDueToDebugger = TRUE;
            
        break;


        default:

            //
            // Invalid state!
            //

            DBG_ASSERT( FALSE );

        break;

    }

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            WAS_IGNORING_WP_FAILURE_DUE_TO_DEBUGGER,                              // message id
            sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                    // count of strings
            EventLogStrings,                        // array of strings
            S_OK);                                   // error code

    return TRUE;
}

/***************************************************************************++

Routine Description:

    Checks if a debugger is attached to the process that is 

Arguments:

    TerminalIllnessReason - The reason the process is being declared 
    terminally ill.
    
Return Value:

    BOOL -  TRUE if a worker process is attached

--***************************************************************************/

BOOL
WORKER_PROCESS::IsDebuggerAttachedToProcess(
    DWORD pid
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fUnderDebugger = FALSE;
    PROCESS_BASIC_INFORMATION   ProcessBasicInfo;
    HANDLE ProcessHandle = NULL;
    UINT_PTR Peb;
    UCHAR DebugFlagInProcess = 0;

    SecureZeroMemory( &ProcessBasicInfo, sizeof(ProcessBasicInfo) );

    ProcessHandle = OpenProcess ( PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid );
    if ( ProcessHandle == NULL )
    {
        fUnderDebugger = FALSE;
        goto exit;
    }

    Status = NtQueryInformationProcess(ProcessHandle, ProcessBasicInformation, &ProcessBasicInfo, sizeof(ProcessBasicInfo), NULL );
    if (!NT_SUCCESS(Status)) 
    {
        fUnderDebugger = FALSE;
        goto exit;
    }

    Peb = (UINT_PTR) ProcessBasicInfo.PebBaseAddress;

    // If the debugger is set, we will determine that here.
    if (!ReadProcessMemory(ProcessHandle, (LPVOID)(Peb + FIELD_OFFSET(PEB, BeingDebugged)), &DebugFlagInProcess, sizeof(DebugFlagInProcess), NULL )) 
    {
        fUnderDebugger = FALSE;
        goto exit;
    }

    if ( DebugFlagInProcess != 0 )
    {
        fUnderDebugger = TRUE;
    }

exit:

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }

    return fUnderDebugger;
}

/***************************************************************************++

Routine Description:

    Immediately terminate the actual process.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::KillProcess(
    )
{
    HRESULT hr = S_OK;

    BOOL Success = TRUE;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    DBG_ASSERT( m_ProcessAlive );
    DBG_ASSERT( m_ProcessHandle != NULL );
    DBG_ASSERT( m_ProcessId != INVALID_PROCESS_ID );
    DBG_ASSERT( m_pAppPoolConfig );

    // Todo:  Log if parts of this function fail.

    //
    // If this worker process is to be killed because it is terminally ill, 
    // and orphaning is enabled, then orphan the process. However, if it
    // is being killed for other reasons (say, fatal error service shutdown),
    // or if orphaning is not enabled, then actually kill the process. 
    //

    if ( ( m_TerminalIllReason != NotIllTerminalIllnessReason ) && m_pAppPoolConfig->IsOrphaningProcessesForDebuggingEnabled() )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "ORPHANING worker process instead of terminating (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        RunOrphanAction();

    }
    else
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Terminating worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }

        // Need the heavy handed terminate process since the process
        // can not be trusted to Exit if ExitProcess is called.
        Success = TerminateProcess(
                        m_ProcessHandle,                // handle of process to terminate
                        KILLED_WORKER_PROCESS_EXIT_CODE // exit code for the process
                        );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Terminating process failed\n"
                ));


            //
            // This can potentially fail if the process died by some other
            // means before we got a chance to kill it; therefore, we
            // continue on without considering this a fatal error.
            //

            hr = S_OK;
        }

    }


    //
    // The process as gone (at least as far as we're concerned).
    //

    m_ProcessAlive = FALSE;

    //
    // Note: we don't want to clear m_ProcessHandle or m_ProcessId;
    // see the comment at the declaration of m_ProcessAlive in the
    // header file.
    //

}   // WORKER_PROCESS::KillProcess



/***************************************************************************++

Routine Description:

    Perform the configured action (if any) on the orphaned process.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::RunOrphanAction(
    )
{

    // string will be "1=<DWORD>\02=<DWORD>\0"  
    // 256 characters should be plenty.
    WCHAR pEnvironment[ 256 ];

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT ( m_pAppPool );

    //
    // Set up an environment block with just the one expansion we want, namely
    // that %1% expands to the process id of the orphaned worker process and
    // that %2% expands to a DWORD representing the orphaning reason.
    //

    // 
    // The pEnvironment is sized to be 256 while we are only putting
    // in 1=<number>\02=<number>\0\0"  <number> == 11 characters
    // and includes the \0 that is following the number so ...
    // we are only going to put in it 27 characters or 54 bytes
    // 256 should be plenty of buffering.
    //
    _snwprintf( 
        pEnvironment, 
        sizeof( pEnvironment ) / sizeof ( WCHAR ), 
        L"1=%lu%c2=%lu%c", 
        m_RegisteredProcessId ? m_RegisteredProcessId : m_ProcessId, 
        L'\0',
        m_TerminalIllReason,
        L'\0'
        );

    // To make prefast happy we null terminate, however the string was setup to take 
    // exactly the max size the snwprintf (including the null) can provide, 
    // so we don't worry about losing data.
    pEnvironment[ 255 ] = '\0';

    RunAction( m_pAppPoolConfig->GetOrphanActionExecutable(),
                    m_pAppPoolConfig->GetOrphanActionParameters(),
                    pEnvironment,
                    m_pAppPool->GetAppPoolId(),
                    WAS_EVENT_ORPHAN_ACTION_FAILED );


}   // WORKER_PROCESS::RunOrphanAction


/***************************************************************************++

Routine Description:

    Initiate clean shutdown by sending the shutdown message to the worker
    process, and starting the timer to ensure it shuts down in time.
    Note that if starting clean shutdown fails, the method will go ahead
    and Terminate() the instance.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::InitiateProcessShutdown(
    BOOL ShutdownImmediately
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    //
    // We should never request a worker process shutdown, unless we are in 
    // FC mode, or if the W3SVC is stopping.
    //
    DBG_ASSERT ( !m_BackwardCompatibilityEnabled ||
                 GetWebAdminService()->GetServiceState() == SERVICE_STOP_PENDING );

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Beginning shutdown for worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    //
    // Tell the worker process to shut down.
    //

    m_State = ShutdownPendingWorkerProcessState;

    hr = m_pMessagingHandler->SendShutdown( ShutdownImmediately );
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Sending shutdown message failed\n"
            ));

        goto exit;
    }


    if ( !m_BackwardCompatibilityEnabled )
    {
        hr = BeginShutdownTimer( m_pAppPoolConfig->GetShutdownTimeLimitInSeconds() 
                                 * ONE_SECOND_IN_MILLISECONDS );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Beginning worker process shutdown timer failed\n"
                ));

            goto exit;
        }
    }


exit:

    return hr;

}   // WORKER_PROCESS::InitiateProcessShutdown



/***************************************************************************++

Routine Description:

    Set up a wait on the handle of the worker process, so that we will know
    if it crashes or otherwise goes away.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::RegisterProcessWait(
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    DBG_ASSERT( m_ProcessWaitHandle == NULL );


    Status = RtlRegisterWait(
                    &m_ProcessWaitHandle,       // returned wait handle
                    m_ProcessHandle,            // handle to wait on
                    &ProcessHandleSignaledCallback,
                                                // callback function
                    this,                       // context
                    INFINITE,                   // no timeout on wait
                    WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD
                                                // call once, in wait thread
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not register wait on process handle\n"
            ));

    }


    return hr;

}   // WORKER_PROCESS::RegisterProcessWait



/***************************************************************************++

Routine Description:

    Tear down the wait on the handle of the worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::DeregisterProcessWait(
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    if ( m_ProcessWaitHandle != NULL )
    {
        Status = RtlDeregisterWaitEx(
                        m_ProcessWaitHandle,    // handle of wait to cancel
                        ( HANDLE ) -1           // block until callbacks finish
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not de-register wait on process handle\n"
                ));

            goto exit;
        }
        m_ProcessWaitHandle = NULL;

    }


exit:

    return hr;

}   // WORKER_PROCESS::DeregisterProcessWait



/***************************************************************************++

Routine Description:

    This routine is called when the process handle has been signaled. This
    means the worker process went away, via a crash or otherwise. Therefore,
    clean up appropriately.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ProcessHandleSignaledWorkItem(
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    DWORD ProcessExitCode = 0;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Process handle has been signaled (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    m_ProcessAlive = FALSE;


    //
    // There are several reasons the process may have exited:
    // 1) The WAS may have killed it. If so, the exit code from the
    // process is the sentinel value that means it was killed.
    // 2) It may have correctly shut down as requested. To detect
    // this, we check if shutdown is pending, and if so, if the exit
    // code from the process is the sentinel value that means it was
    // a clean exit.
    // 3) It may have died on it's own (crash, termination on error,
    // etc.).
    //


    Success = GetExitCodeProcess(
                    m_ProcessHandle,    // process handle
                    &ProcessExitCode    // returned process exit code
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Getting process exit code failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Process exit code was: %x\n",
            ProcessExitCode
            ));
    }


    if ( ProcessExitCode == KILLED_WORKER_PROCESS_EXIT_CODE )
    {

        //
        // We killed it; take no further action here.
        //

        //
        // Sanity check: we should only have killed the worker process
        // as part of Terminate(), and so we should be in the delete
        // pending state.
        //
        // Potentially the worker process could incorrectly return this
        // error code, so in retail builds make sure we at least clean
        // up.
        //

        DBG_ASSERT( m_State == DeletePendingWorkerProcessState );

        if ( m_State != DeletePendingWorkerProcessState )
        {
            MarkAsTerminallyIll( CrashWorkerProcessTerminalIllnessReason, ProcessExitCode, 0 );
        }

        goto exit;

    }
    else if ( ( m_State == ShutdownPendingWorkerProcessState ) &&
              ( ProcessExitCode == CLEAN_WORKER_PROCESS_EXIT_CODE ) )
    {

        //
        // It shut down correctly as requested. Now we can clean up
        // this instance.
        //
        // Note that the shutdown timer will be cancelled in the
        // Terminate() method.
        //

        Terminate();

    }
    else
    {

        //
        // The worker process must have crashed, exited due to error,
        // or otherwise misbehaved.
        //


        MarkAsTerminallyIll( CrashWorkerProcessTerminalIllnessReason, ProcessExitCode, 0 );
    }


exit:

    return hr;

}   // WORKER_PROCESS::ProcessHandleSignaledWorkItem



/***************************************************************************++

Routine Description:

    If the worker process has taken too long to start up, then
    deal with it accordingly.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::StartupTimerExpiredWorkItem(
    )
{

    HRESULT hr = S_OK;
    //
    // See if we are still in a startup pending state.
    // If we are, then the worker process has taken too long. If not, then
    // either the state transition completed just as the timer expired, and
    // we should ignore this; or something else has happened to change the
    // state (for example, a crash), in which case we also ignore this.
    //

    DBG_ASSERT ( CheckSignature() );

    if ( ( m_State == RegistrationPendingWorkerProcessState ) ||
         ( m_State == RegistrationPendingShutdownPendingWorkerProcessState ) )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process has taken too long to start up (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        MarkAsTerminallyIll( StartupTookTooLongWorkerProcessTerminalIllnessReason, 0, 0 );

    }


    return hr;

}   // WORKER_PROCESS::StartupTimerExpiredWorkItem



/***************************************************************************++

Routine Description:

    If the worker process has taken too long to shut down, then
    deal with it accordingly.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ShutdownTimerExpiredWorkItem(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    //
    // See if we are still in a shutdown pending state.
    // If we are, then the worker process has taken too long. If not, then
    // either the state transition completed just as the timer expired, and
    // we should ignore this; or something else has happened to change the
    // state (for example, a crash), in which case we also ignore this.
    //

    if ( m_State == ShutdownPendingWorkerProcessState ) 
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process has taken too long to shut down (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        MarkAsTerminallyIll( ShutdownTookTooLongWorkerProcessTerminalIllnessReason, 0, 0 );

    }


    return hr;

}   // WORKER_PROCESS::ShutdownTimerExpiredWorkItem

/***************************************************************************++

Routine Description:

    Initiate a ping to the worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::SendPingWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    //
    // Clean up the timer that got us here.
    //

    hr = CancelSendPingTimer();
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling send ping timer failed\n"
            ));

        goto exit;
    }


    //
    // Only start a ping if we are currently in the running state.
    //

    if ( m_State != RunningWorkerProcessState )
    {
        goto exit;
    }


    DBG_ASSERT( ! m_AwaitingPingReply );

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Pinging worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    //
    // Send the ping message via IPM.
    //

    hr = m_pMessagingHandler->SendPing();
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Sending ping message failed\n"
            ));

        goto exit;
    }


    m_AwaitingPingReply = TRUE;


    //
    // Make sure the worker process responds in a timely manner.
    //

    hr = BeginPingResponseTimer();
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Starting ping response timer failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORKER_PROCESS::SendPingWorkItem



/***************************************************************************++

Routine Description:

    Handle the fact that the worker process has not responded to the ping
    within the time allowed.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::PingResponseTimerExpiredWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT(!m_BackwardCompatibilityEnabled);

    //
    // Clean up the timer that got us here.
    //

    hr = CancelPingResponseTimer();
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling ping response timer failed\n"
            ));

        goto exit;
    }


    //
    // If we aren't currently in the running state, then ignore the fact
    // that this timer expired. We may already be in the midst of shutting
    // down.
    //

    if ( m_State != RunningWorkerProcessState )
    {
        goto exit;
    }


    //
    // If we are still awaiting a reply, then the worker process hasn't
    // responded in a timely manner.
    //

    if ( m_AwaitingPingReply )
    {      
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process has not responded to ping within time limit (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        MarkAsTerminallyIll( PingFailureProcessTerminalIllnessReason, 0, 0 );

    }


exit:

    return hr;

}   // WORKER_PROCESS::PingResponseTimerExpiredWorkItem



/***************************************************************************++

Routine Description:

    Start the timer which ensures that process initialization happens in
    a timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginStartupTimer(
    )
{

    //
    // Record when startup wait began.
    //

    DBG_ASSERT ( CheckSignature() );

    m_StartupBeganTickCount = GetTickCount();

    return BeginTimer(
                &m_StartupTimerHandle,                  // timer handle
                &StartupTimerExpiredCallback,           // callback
                m_pAppPoolConfig->GetStartupTimeLimitInSeconds() * ONE_SECOND_IN_MILLISECONDS
                                                        // fire time
                );

}   // WORKER_PROCESS::BeginStartupTimer



/***************************************************************************++

Routine Description:

    Stop the timer which ensures that process initialization happens in
    a timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelStartupTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );

    if ( m_StartupTimerHandle != NULL )
    {

        //
        // If we really are cancelling the timer, determine the elapsed time.
        //
        // Note that tick counts are in milliseconds. Tick counts roll over 
        // every 49.7 days, but the arithmetic operation works correctly 
        // anyways in this case.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Cancelling startup timer; response time was: %lu milliseconds\n",
                GetTickCount() - m_StartupBeganTickCount
                ));
        }

    }


    return CancelTimer( &m_StartupTimerHandle );

}   // WORKER_PROCESS::CancelStartupTimer



/***************************************************************************++

Routine Description:

    Start the timer which ensures that process shutdown happens in a
    timely manner.

Arguments:

    ShutdownTimeLimitInMilliseconds - Number of milliseconds that this 
    worker process has in which to complete clean shutdown. If this time 
    is exceeded, the worker process will be terminated. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginShutdownTimer(
    IN ULONG ShutdownTimeLimitInMilliseconds
    )
{

    //
    // Record when shutdown wait began.
    //

    DBG_ASSERT ( CheckSignature() );

    m_ShutdownBeganTickCount = GetTickCount();

    return BeginTimer(
                &m_ShutdownTimerHandle,                 // timer handle
                &ShutdownTimerExpiredCallback,          // callback
                ShutdownTimeLimitInMilliseconds         // fire time
                );

}   // WORKER_PROCESS::BeginShutdownTimer



/***************************************************************************++

Routine Description:

    Stop the timer which ensures that process shutdown happens in a
    timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelShutdownTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );

    if ( m_ShutdownTimerHandle != NULL )
    {

        //
        // If we really are cancelling the timer, determine the elapsed time.
        //
        // Note that tick counts are in milliseconds. Tick counts roll over 
        // every 49.7 days, but the arithmetic operation works correctly 
        // anyways in this case.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Cancelling shutdown timer; response time was: %lu milliseconds\n",
                GetTickCount() - m_ShutdownBeganTickCount
                ));
        }

    }

    return CancelTimer( &m_ShutdownTimerHandle );

}   // WORKER_PROCESS::CancelShutdownTimer


/***************************************************************************++

Routine Description:

    Start the timer which tells us when to initiate a ping to the worker
    process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginSendPingTimer(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    //
    // Only start the ping timer if pinging is enabled.
    // It is not enabled if we are in backward compatible mode.
    //

    if ( ! m_pAppPoolConfig->IsPingingEnabled() 
        || m_BackwardCompatibilityEnabled)
    {
        goto exit;
    }


    return BeginTimer(
                &m_SendPingTimerHandle,                 // timer handle
                &SendPingTimerCallback,                 // callback
                m_pAppPoolConfig->GetPingIntervalInSeconds() * ONE_SECOND_IN_MILLISECONDS
                                                        // fire time
                );


exit:

    return hr;

}   // WORKER_PROCESS::BeginSendPingTimer



/***************************************************************************++

Routine Description:

    Stop the timer which tells us when to initiate a ping to the worker
    process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelSendPingTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );

    return CancelTimer( &m_SendPingTimerHandle );

}   // WORKER_PROCESS::CancelSendPingTimer



/***************************************************************************++

Routine Description:

    Start the timer which ensures that a ping response arrives in a
    timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginPingResponseTimer(
    )
{

    //
    // Record when the ping response wait began.
    //

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT(!m_BackwardCompatibilityEnabled);

    m_PingBeganTickCount = GetTickCount();

    return BeginTimer(
                &m_PingResponseTimerHandle,             // timer handle
                &PingResponseTimerExpiredCallback,      // callback
                m_pAppPoolConfig->GetPingResponseTimeLimitInSeconds() * ONE_SECOND_IN_MILLISECONDS
                                                        // fire time
                );

}   // WORKER_PROCESS::BeginPingResponseTimer



/***************************************************************************++

Routine Description:

    Stop the timer which ensures that a ping response arrives in a
    timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelPingResponseTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );
    
    if ( m_PingResponseTimerHandle != NULL )
    {
        //
        // If we really are cancelling the timer, determine the elapsed time.
        //
        // Note that tick counts are in milliseconds. Tick counts roll over 
        // every 49.7 days, but the arithmetic operation works correctly 
        // anyways in this case.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Cancelling ping response timer; response time was: %lu milliseconds\n",
                GetTickCount() - m_PingBeganTickCount
                ));
        }

    }

    return CancelTimer( &m_PingResponseTimerHandle );

}   // WORKER_PROCESS::CancelPingResponseTimer



/***************************************************************************++

Routine Description:

    Start one of the built in timers.

Arguments:

    pTimerHandle - Address of the timer handle to start.

    pCallbackFunction - Function to call when the timer fires.

    InitialFiringTime - Time in milliseconds before firing the timer.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginTimer(
    IN OUT HANDLE * pTimerHandle,
    IN WAITORTIMERCALLBACKFUNC pCallbackFunction,
    IN ULONG InitialFiringTime
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( pTimerHandle != NULL );
    DBG_ASSERT( pCallbackFunction != NULL );
    DBG_ASSERT( InitialFiringTime > 0 );


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( *pTimerHandle == NULL );


    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                // timer queue
                    pTimerHandle,               // returned timer handle
                    pCallbackFunction,          // callback function
                    this,                       // context
                    InitialFiringTime,          // initial firing time
                    0,                          // subsequent firing period
                    WT_EXECUTEINWAITTHREAD      // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create timer\n"
            ));

    }

    return hr;

}   // WORKER_PROCESS::BeginTimer



/***************************************************************************++

Routine Description:

    Stop one of the built in timers.

Arguments:

    pTimerHandle - Address of the timer handle to stop.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelTimer(
    IN OUT HANDLE * pTimerHandle
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT( pTimerHandle != NULL );
    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    //
    // If the timer is not present, we're done here.
    //
    if ( *pTimerHandle == NULL )
    {
        goto exit;
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    // Otherwise, there could be a race where the callback runs after
    // this worker process instance has been deleted, and so gives out
    // a bad pointer.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                            // the owning timer queue
                    *pTimerHandle,          // timer to cancel
                    ( HANDLE ) -1           // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel timer\n"
            ));

        goto exit;
    }

    *pTimerHandle = NULL;


exit:

    return hr;

}   // WORKER_PROCESS::CancelTimer



/***************************************************************************++

Routine Description:

    Deal with a failure internal to this worker process instance by marking
    this instance as terminally ill.

    Note: this method should be called in the case of failure at the end of
    all HRESULT-returning public methods of this class!!!

Arguments:

    Error - The failed HRESULT.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::DealWithInternalWorkerProcessFailure(
    IN HRESULT Error
    )
{

    DBG_ASSERT ( CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Internal WORKER_PROCESS error; marking as terminally ill: %lu\n",
            Error
            ));
    }


    //
    // If we had a failure bubble to here (which is shouldn't in "normal"
    // scenarios) then mark this instance as terminally ill. This will
    // terminate this instance.
    //
    MarkAsTerminallyIll( InternalErrorWorkerProcessTerminalIllnessReason, 0, Error );

}   // WORKER_PROCESS::DealWithInternalWorkerProcessFailure


/***************************************************************************++

Routine Description:

    Send process recycler related parameters to worker process.


Arguments:

    pWhatHasChanged - bit array of changed properties. If is is NULL then all the
    configuration values will be sent. If not then only those parameters will 
    be sent that have changed

    m_pAppPool will be used to retrieve the AppPool configuration values


Return Value:

    HRESULT

--***************************************************************************/


HRESULT
WORKER_PROCESS::SendWorkerProcessRecyclerParameters(
)
{
    HRESULT hr  = S_OK;

    DBG_ASSERT ( CheckSignature() );

    if( m_BackwardCompatibilityEnabled )
    {
        //
        // Do not do anything in backward compatibily mode
        // recycling applies only to new process mode
        //
        return NO_ERROR;
    }

    //
    // m_pAppPool must be valid when in new process mode
    //
    DBG_ASSERT( m_pAppPool != NULL );
    DBG_ASSERT( m_pAppPoolConfig != NULL );

    DWORD PeriodicProcessRestartPeriodInMinutes = 0;           

    if ( m_pAppPoolConfig->GetPeriodicProcessRestartPeriodInMinutes() != 0 )
    {
        PeriodicProcessRestartPeriodInMinutes =  (DWORD )          
             ( m_PercentValueForStaggering * m_pAppPoolConfig->GetPeriodicProcessRestartPeriodInMinutes() ); 

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {

            DBGPRINTF(( DBG_CONTEXT,
                    "\nRestartPeriodInMinutes = %d \n "
                    "Raw Number = %d \n"
                    "Staggering Value = %f \n",
                    PeriodicProcessRestartPeriodInMinutes,
                    m_pAppPoolConfig->GetPeriodicProcessRestartPeriodInMinutes(),
                    m_PercentValueForStaggering));
        }

        if ( PeriodicProcessRestartPeriodInMinutes == 0 )
        {
            PeriodicProcessRestartPeriodInMinutes = 1;
        }

    }

    hr = m_pMessagingHandler->SendPeriodicProcessRestartPeriodInMinutes(
            PeriodicProcessRestartPeriodInMinutes
            );
            
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing m_MessagingHandler.SendPeriodicProcessRestartPeriodInMinutes() failed\n"
        ));

        goto exit;
    }

    LPWSTR pPeriodicProcessRestartSchedule = 
            m_pAppPoolConfig->GetPeriodicProcessRestartSchedule();
            
    hr = m_pMessagingHandler->SendPeriodicProcessRestartSchedule(
            pPeriodicProcessRestartSchedule
            );
                            
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing m_MessagingHandler.SendPeriodicProcessRestartSchedule() failed\n"
        ));

        goto exit;
    }

    DWORD PeriodicProcessRestartMemoryUsageInKB = 
            m_pAppPoolConfig->GetPeriodicProcessRestartMemoryUsageInKB();

    DWORD PeriodicProcessRestartPrivateBytesInKB = 
            m_pAppPoolConfig->GetPeriodicProcessRestartMemoryPrivateUsageInKB();
            
    hr = m_pMessagingHandler->SendPeriodicProcessRestartMemoryUsageInKB(
            PeriodicProcessRestartMemoryUsageInKB,
            PeriodicProcessRestartPrivateBytesInKB
            );
                            
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing m_MessagingHandler.SendPeriodicProcessRestartMemoryUsageInKB() failed\n"
        ));

        goto exit;
    }

exit:

    return hr;

} //WORKER_PROCESS::SendWorkerProcessRecyclerParameters


/***************************************************************************++

Routine Description:

    The callback function invoked by the startup timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
StartupTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );

    UNREFERENCED_PARAMETER ( pWorkerProcess );
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for startup timer expired on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    //
    // Ignoring a failure here, if we can not
    // add this, then we are just not going to
    // acknowledge this failure.
    //

    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        StartupTimerExpiredWorkerProcessWorkItem
        );


    return;

}   // StartupTimerExpiredCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the shutdown timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
ShutdownTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    UNREFERENCED_PARAMETER ( pWorkerProcess );
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for shutdown timer expired on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    //
    // Ignoring a failure here, if we can not
    // add this, then we are just not going to
    // acknowledge this failure.
    //

    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        ShutdownTimerExpiredWorkerProcessWorkItem
        );


    return;

}   // ShutdownTimerExpiredCallback

/***************************************************************************++

Routine Description:

    The callback function invoked by the send ping timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
SendPingTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );

    UNREFERENCED_PARAMETER ( pWorkerProcess );
    
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for ping timer on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    //
    // Ignoring a failure here, if we can not
    // add this, then we are just not going to
    // acknowledge this failure.
    //

    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        SendPingWorkerProcessWorkItem
        );


    return;

}   // SendPingTimerCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the  ping response timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
PingResponseTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );

    UNREFERENCED_PARAMETER ( pWorkerProcess );    

    DBG_ASSERT ( pWorkerProcess->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for ping response timer on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    //
    // Ignoring a failure here, if we can not
    // add this, then we are just not going to
    // acknowledge this failure.
    //

    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        PingResponseTimerExpiredWorkerProcessWorkItem
        );


    return;

}   // PingResponseTimerExpiredCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the process handle wait. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
ProcessHandleSignaledCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    UNREFERENCED_PARAMETER ( pWorkerProcess );
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for process handle signaled on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    pWorkerProcess->SetHandleSignalled();

    //
    // Ignoring a failure here, if we can not
    // add this, then we are just not going to
    // acknowledge this failure.
    //



    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        ProcessHandleSignaledWorkerProcessWorkItem
        );


    return;

}   // ProcessHandleSignaledCallback

/***************************************************************************++

Routine Description:

    This routine will expand the command line and besides expanding out
    regular environment variables it will also expand out %1% to be the ProcessId
    passed in here. 

Arguments:

    LPWSTR OriginalPiece  The string to expand
    UNICODE_STRING FormattedPiece The formatted string ( must be GlobalFree'd by caller )
    DWORD ProcessId The process id to expand into the string.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
ExpandCommandLinePiece( 
    LPWSTR OriginalPiece,
    UNICODE_STRING* pFormattedPiece,
    LPVOID pEnvironment
    )
{
    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING UnformattedPiece;

    DBG_ASSERT ( pFormattedPiece );
    DBG_ASSERT ( pFormattedPiece->Buffer == NULL );

    //
    // Expand the string by stuffing in the process id of the orphaned
    // process. Any %1% sequences in the orphan action are replaced. Note that
    // that sequence does not need to be present.
    //
    // Note that FormatMessage(), _snwprintf(), etc. all are not suitable for
    // this task, because they can spew garbage or AV if the orphan action
    // contains unexpected formatting commands.
    //

    //
    // CODEWORK It might be nice to match the semantics of AeDebug, in terms
    // of using sprintf formatting sequences like %ld to mark replacements, 
    // instead of %1%. However, that would likely require writing our own 
    // replacement function. Could be done if needed, though. As it is, we
    // match the SCM service failure action semantics for replacements.
    //

    // First make sure we have a string
    if ( ( OriginalPiece == NULL ) ||
         ( OriginalPiece[0] == L'\0' ) )
    {
        // No expansion neccesary
        hr = S_OK;

        goto exit;
    }

    // Move the original piece into the unicode string.
    Status = RtlInitUnicodeStringEx( &UnformattedPiece, OriginalPiece );
    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not initialize the unformatted unicode string\n"
            ));

        goto exit;
    }

    pFormattedPiece->Length = 0;

    // Assumption is being made here that 256 is enough extra space for all 
    // expanded data.
    pFormattedPiece->MaximumLength = UnformattedPiece.MaximumLength + 256;

    pFormattedPiece->Buffer = ( LPWSTR )GlobalAlloc( GMEM_FIXED, pFormattedPiece->MaximumLength );
    if ( pFormattedPiece->Buffer == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }

    Status = RtlExpandEnvironmentStrings_U(
                    pEnvironment,
                    &UnformattedPiece,
                    pFormattedPiece,
                    NULL
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not expand environment strings\n"
            ));

        goto exit;
    }

exit:

    if ( FAILED ( hr ) )
    {
        if ( pFormattedPiece->Buffer != NULL )
        {
            DBG_REQUIRE( GlobalFree( pFormattedPiece->Buffer ) == NULL );
            pFormattedPiece->Buffer = NULL;
        }
    }

    return hr;


}

/***************************************************************************++

Routine Description:

    Simple check to make sure that some characters are in the string besides
    whitespace.  This will prevent us from trying to launch " ".

Arguments:

    LPWSTR str - the string to check

Return Value:

    BOOL - TRUE other characters exist besides spaces
           FALSE all the characters in the string are spaces ( or there are no
           characters in the string )

--***************************************************************************/
BOOL 
CharactersExist(
    LPCWSTR str
    )
{
    if ( str == NULL )
    {
        return FALSE;
    }

    while ( *str == L' ' )
    {
        str++;
    }

    if ( *str == L'\0' )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//static 
HRESULT 
WORKER_PROCESS::StaticInitialize()
{
    InitializeListHead(&s_WorkerProcessListHead);
    return S_OK;
}

//static
VOID
WORKER_PROCESS::StaticTerminate()
{
    DBG_ASSERT(IsListEmpty(&s_WorkerProcessListHead));
    return;
}



/***************************************************************************++

Routine Description:

    Launches an action.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
RunAction(
    LPCWSTR pExecutable,
    LPCWSTR pParameters,
    LPVOID  pEnvironment,
    LPCWSTR pAppPoolId,
    DWORD   ActionFailureMsgId
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
    STRU FullCommandLine;

    UNICODE_STRING FormattedString;

    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;

    DBG_ASSERT ( pAppPoolId );

    //
    // If no action is configured, then we're done.
    //

    if ( !CharactersExist( pExecutable ) )
    {
        return;
    }


    // Initialize the Formatted String to NULL so 
    // if we use it in cleanup before it is set we
    // will be guarantteed it is NULL.
    RtlInitUnicodeString( &FormattedString, NULL );

    // Need to put both strings together in one.
    hr = FullCommandLine.Copy(L"\"");
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Adding first quote on action failed.\n"
            ));

        goto exit;
    }

    hr = FullCommandLine.Append( pExecutable );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Adding executable to action failed\n"
            ));

        goto exit;
    }

    hr = FullCommandLine.Append(L"\" ");
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Adding second quote on action failed\n"
            ));

        goto exit;
    }

    hr = FullCommandLine.Append( pParameters );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Adding parameters to orphan action failed\n"
            ));

        goto exit;
    }


    // Expand out the exectuable.
    hr = ExpandCommandLinePiece( FullCommandLine.QueryStr(), 
                                 &FormattedString, 
                                 pEnvironment );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Expanding the string failed\n"
            ));

        goto exit;
    }

    DBG_ASSERT ( CharactersExist ( FormattedString.Buffer ) );

    SecureZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );

    SecureZeroMemory( &ProcessInfo, sizeof( ProcessInfo ) );

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Running action '%S'\n",
            FormattedString.Buffer
            ));
    }

    //
    // Run the command. We pass CREATE_NEW_CONSOLE to make sure that
    // if a batch file is specified, it has a console in which to execute.
    //

    //
    // CODEWORK For now, we always run the command in the account that 
    // WAS is running under (typically LocalSystem). This is probably 
    // ok for the usage patterns we envision. If desired, if we implement
    // per-apppool accounts to run under, we could use that same
    // account to run the action under too. 
    //

    //
    // We are passing everything as the parameters value, that is 
    // because we need to make sure the parameters contains the name of 
    // the executable as well as the rest of the parameters.  However,
    // we also pass the executable value to show that we are not at
    // risk for un-quoted space containing paths.
    //
    Success = CreateProcess(
                    pExecutable,       // executable
                    FormattedString.Buffer,       // parameters
                    NULL,                   // process security attributes
                    NULL,                   // thread security attributes
                    FALSE,                  // handle inheritance flag
                    CREATE_NEW_CONSOLE,     // creation flags
                    NULL,                   // environment block
                    NULL,                   // current directory name
                    &StartupInfo,           // STARTUPINFO
                    &ProcessInfo            // PROCESS_INFORMATION
                    );

    if ( ! Success )
    {

        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not run orphan action\n"
            ));

        goto exit;

    }


    DBG_REQUIRE( CloseHandle( ProcessInfo.hThread ) );
    DBG_REQUIRE( CloseHandle( ProcessInfo.hProcess ) );


exit:
    if ( FAILED( hr ) )
    {

        //
        // Log an event: Running action failed.
        //

        const WCHAR * EventLogStrings[2];

        EventLogStrings[0] = pAppPoolId;
        EventLogStrings[1] = ( FormattedString.Buffer != NULL ? FormattedString.Buffer : L"" );

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                ActionFailureMsgId,                     // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

    }



    if ( FormattedString.Buffer != NULL )
    {
        DBG_REQUIRE( GlobalFree( FormattedString.Buffer ) == NULL );
        FormattedString.Buffer = NULL;
    }

}   // RunAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\worker_process.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    worker_process.h

Abstract:

    The IIS web admin service worker process class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _WORKER_PROCESS_H_
#define _WORKER_PROCESS_H_


VOID
RunAction(
    LPCWSTR pExecutable,
    LPCWSTR pParameters,
    LPVOID  pEnvironment,
    LPCWSTR pAppPoolId,
    DWORD   ActionFailureMsgId
    );


//
// common #defines
//

#define WORKER_PROCESS_SIGNATURE        CREATE_SIGNATURE( 'WPRC' )
#define WORKER_PROCESS_SIGNATURE_FREED  CREATE_SIGNATURE( 'wprX' )

#define INVALID_PROCESS_ID 0



//
// structs, enums, etc.
//

// worker process states
enum WORKER_PROCESS_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedWorkerProcessState = 1,

    //
    // The process has been created, and we are waiting for it to
    // call back and register over the IPC channel.
    //
    RegistrationPendingWorkerProcessState,

    //
    // As per RegistrationPendingWorkerProcessState above, but as soon
    // as the process registers, we should begin shutting it down.
    //
    RegistrationPendingShutdownPendingWorkerProcessState,

    //
    // The process is running normally.
    //
    RunningWorkerProcessState,

    //
    // We have requested that the process shut down, and are waiting
    // for it to do so.
    //
    ShutdownPendingWorkerProcessState,

    //
    // The process has shut down or been killed. This object instance
    // can go away as soon as it's reference count hits zero.
    //
    DeletePendingWorkerProcessState,

};

// worker process counter gathering states
enum WORKER_PROCESS_PERF_COUNTER_STATE
{

    //
    // The object is not waiting for counters to 
    // come in, nor have counters arrived for the
    // current request.
    //
    IdleWorkerProcessPerfCounterState = 1,

    //
    // The object is waiting for a perf counter
    // message from the process.
    //
    WaitingWorkerProcessPerfCounterState,

    //
    // The object has received a response for
    // this counter request, do we should not
    // gather any more counters.
    //
    AnsweredWorkerProcessPerfCounterState,


};


// worker process terminal illness reasons
enum WORKER_PROCESS_TERMINAL_ILLNESS_REASON
{
    //
    // No Terminal Ill reason the worker process is healthy.

    NotIllTerminalIllnessReason = 0,

    //
    // The worker process crashed, exited, or somehow went away.
    //
    CrashWorkerProcessTerminalIllnessReason,

    //
    // The worker process failed to respond to a ping.
    //
    PingFailureProcessTerminalIllnessReason,

    //
    // An IPM error occurred with this worker process. 
    //
    IPMErrorWorkerProcessTerminalIllnessReason,

    //
    // The worker process took too long to start up.
    //
    StartupTookTooLongWorkerProcessTerminalIllnessReason,

    //
    // The worker process took too long to shut down.
    //
    ShutdownTookTooLongWorkerProcessTerminalIllnessReason,

    //
    // An internal error occurred.
    //
    InternalErrorWorkerProcessTerminalIllnessReason,

    //
    // A bad hresult was received from the worker process
    //
    WorkerProcessPassedBadHresultTerminalIllnessReason,

    //
    // Create process failed.
    //
    CreateProcessFailedTerminalIllnessReason,

    //
    // worker process sent some data over the pipe
    // that causes us to believe it has been compromised.
    //
    UntrustedWorkerProcessTerminalIllnessReason

};


// WORKER_PROCESS work items
enum WORKER_PROCESS_WORK_ITEM
{

    //
    // The process has gone away.
    //
    ProcessHandleSignaledWorkerProcessWorkItem = 1,

    //
    // The process has taken too long to start up.
    //
    StartupTimerExpiredWorkerProcessWorkItem,

    //
    // The process has taken too long to shut down.
    //
    ShutdownTimerExpiredWorkerProcessWorkItem,

    //
    // It is time to send a ping.
    //
    SendPingWorkerProcessWorkItem,

    //
    // The process has taken too long to respond to a ping.
    //
    PingResponseTimerExpiredWorkerProcessWorkItem,

};


//
// prototypes
//

class WORKER_PROCESS
    : public WORK_DISPATCH
{


//
// The  MESSAGING_HANDLER class is really a part of this class.
//

friend class MESSAGING_HANDLER;


public:

    static 
    HRESULT 
    StaticInitialize();

    static
    VOID
    StaticTerminate();

    WORKER_PROCESS(
        IN APP_POOL * pAppPool,
        IN APP_POOL_CONFIG_STORE * pAppPoolConfig,
        IN WORKER_PROCESS_START_REASON StartReason,
        IN WORKER_PROCESS * pWorkerProcessToReplace,
        IN DWORD  MaxProcessesToLaunch,
        IN DWORD  NumWPOnWayToMaxProcesses
       );

    virtual
    ~WORKER_PROCESS(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    VOID
    Initialize(
        );

    VOID
    Shutdown(
        BOOL ShutdownImmediately
        );

    VOID
    Terminate(
        );

    VOID
    InitiateReplacement(
        );

    inline
    PLIST_ENTRY
    GetAppPoolListEntry(
        )
    { return &m_AppPoolListEntry; }

    static
    WORKER_PROCESS *
    WorkerProcessFromAppPoolListEntry(
        IN const LIST_ENTRY * pListEntry
        );

    inline
    DWORD
    GetProcessId(
        )
        const
    { return m_ProcessId; }

    inline
    HANDLE
    GetProcessHandle(
        )
        const
    { return m_ProcessHandle; }

    inline
    DWORD
    GetRegisteredProcessId(
        )
        const
    { return m_RegisteredProcessId; }

    inline
    HANDLE
    GetWorkerProcessToken(
        )
        const
    { 
        DBG_ASSERT ( m_pAppPoolConfig );
        
        return m_pAppPoolConfig->GetWorkerProcessToken();
    }
    
    BOOL
    IsGoingAwaySoon(
        )
        const;

    BOOL
    RequestCounters(
        );

    VOID
    ResetPerfCounterState(
        );

    VOID
    RecordCounters(
        DWORD MessageLength,
        const BYTE* pMessage
        );

    VOID
    HandleHresult(
        HRESULT hrToHandle 
        );


    BOOL
    CheckSignature( 
        ) const
    { return ( m_Signature == WORKER_PROCESS_SIGNATURE ); }

    VOID
    SetHandleSignalled(
        ) 
    {
        m_HandleSignalled = TRUE;
    }

private:


    HRESULT
    SendWorkerProcessRecyclerParameters(
    );

    VOID
    WorkerProcessRegistrationReceived(
        IN DWORD RegisteredProcessId
        );

    VOID
    WorkerProcessStartupSucceeded(
        );


    VOID
    PingReplyReceived(
        );

    VOID
    ShutdownRequestReceived(
        IN IPM_WP_SHUTDOWN_MSG ShutdownRequestReason
        );

    VOID
    IpmErrorOccurred(
        IN HRESULT Error
        );

    VOID
    UntrustedIPMTransferReceived(
        );

    HRESULT
    StartProcess(
        );

    HRESULT
    StartProcessInInetinfo(
        );

    HRESULT
    CreateCommandLine(
        OUT STRU * pExeWithPath,
        OUT STRU * pCommandLineArgs
        );

    VOID
    MarkAsTerminallyIll(
        IN WORKER_PROCESS_TERMINAL_ILLNESS_REASON TerminalIllnessReason,
        IN DWORD ProcessExitCode,
        IN HRESULT ErrorCode
        );

    VOID
    KillProcess(
        );

    VOID
    RunOrphanAction(
        );

    HRESULT
    InitiateProcessShutdown(
        BOOL ShutdownImmediately
        );

    HRESULT
    RegisterProcessWait(
        );

    HRESULT
    DeregisterProcessWait(
        );

    HRESULT
    ProcessHandleSignaledWorkItem(
        );

    HRESULT
    StartupTimerExpiredWorkItem(
        );

    HRESULT
    ShutdownTimerExpiredWorkItem(
        );

    HRESULT
    SendPingWorkItem(
        );

    HRESULT
    PingResponseTimerExpiredWorkItem(
        );

    HRESULT
    BeginStartupTimer(
        );

    HRESULT
    CancelStartupTimer(
        );

    HRESULT
    BeginShutdownTimer(
        IN ULONG ShutdownTimeLimitInMilliseconds
        );

    HRESULT
    CancelShutdownTimer(
        );

    HRESULT
    BeginSendPingTimer(
        );

    HRESULT
    CancelSendPingTimer(
        );

    HRESULT
    BeginPingResponseTimer(
        );

    HRESULT
    CancelPingResponseTimer(
        );

    HRESULT
    BeginTimer(
        IN OUT HANDLE * pTimerHandle,
        IN WAITORTIMERCALLBACKFUNC pCallbackFunction,
        IN ULONG InitialFiringTime
        );

    HRESULT
    CancelTimer(
        IN OUT HANDLE * pTimerHandle
        );

    VOID
    DealWithInternalWorkerProcessFailure(
        IN HRESULT Error
        );

    BOOL
    IsDebuggerAttachedToProcess(
        DWORD pid
        );

    BOOL
    CheckIfDebuggerMakesWPHealthy(
        IN WORKER_PROCESS_TERMINAL_ILLNESS_REASON TerminalIllnessReason
        );


    DWORD m_Signature;

    // used by the owning APP_POOL to keep a list of its WORKER_PROCESSes
    LIST_ENTRY m_AppPoolListEntry;

    LONG m_RefCount;

    // for communication with the worker process
    MESSAGING_HANDLER * m_pMessagingHandler;

    // registration id used by the IPM layer to associate the process
    DWORD m_RegistrationId;

    WORKER_PROCESS_STATE m_State;

    // back pointer
    APP_POOL * m_pAppPool;

    // Worker processe holds on to a copy of the app pool configuration
    // information as it was set when the worker process was brought up.
    APP_POOL_CONFIG_STORE* m_pAppPoolConfig;

    // pid returned from CreateProcess
    DWORD m_ProcessId;

    //
    // The pid passed back by the worker process via IPM. This pid is
    // different that the pid returned by CreateProcess in one case,
    // namely when running worker processes under a debugger via 
    // ImageFileExecutionOptions. In this case CreateProcess returns
    // the pid of the debugger process, not the pid of the worker
    // process. 
    // 
    DWORD m_RegisteredProcessId;

    HANDLE m_ProcessHandle;

    // watching for the process to go away
    HANDLE m_ProcessWaitHandle;

    //
    // This flag remembers if the process is alive. We can't just set the
    // process handle to a valid handle vs. an invalid sentinel for this
    // purpose, because we will hold the handle open even after the process
    // dies. Doing this prevents the process id from being reused, which
    // would cause problems.
    //
    BOOL m_ProcessAlive;

    BOOL m_BeingReplaced;

    BOOL m_NotifiedAppPoolThatStartupAttemptDone;

    // startup timer
    HANDLE m_StartupTimerHandle;
    DWORD m_StartupBeganTickCount;

    // shutdown timer
    HANDLE m_ShutdownTimerHandle;
    DWORD m_ShutdownBeganTickCount;

    // send ping timer
    HANDLE m_SendPingTimerHandle;

    // ping response timer
    HANDLE m_PingResponseTimerHandle;
    DWORD m_PingBeganTickCount;

    BOOL m_AwaitingPingReply;

    // why was this worker process started?
    WORKER_PROCESS_START_REASON m_StartReason;

    // for replacement processes, who is the predecessor we need to retire?
    WORKER_PROCESS * m_pWorkerProcessToReplace;

    // remembers if the server is in backward compatibility mode.
    BOOL m_BackwardCompatibilityEnabled;

    // remembers what state this worker process is in
    // when it comes to perf counters.
    WORKER_PROCESS_PERF_COUNTER_STATE m_PerfCounterState;

    // if we are remembering a request to shutdown we need to know the type 
    // of request.
    BOOL m_ShutdownType;

    // Keep a list of all active WORKER_PROCESS objects
    LIST_ENTRY m_WorkerProcessListEntry;

    // head of list of all active WORKER_PROCESS objects
    static LIST_ENTRY s_WorkerProcessListHead;

    // If this is set then the terminally ill code will assume the
    // terminal reason has all ready been loged and will request
    // that the app pool shuts down regardless of if RFP has been hit.
    BOOL m_TerminallyIllShutdownRegardless;

    // Percentage value to multiply the recycling values
    // by when we are staggering the recycling times.

    FLOAT m_PercentValueForStaggering;

    WORKER_PROCESS_TERMINAL_ILLNESS_REASON m_TerminalIllReason;

    BOOL m_IgnoredStartupTimelimitDueToDebugger;
    BOOL m_IgnoredShutdownTimelimitDueToDebugger;
    BOOL m_IgnoredPingDueToDebugger;

    //
    // Used only to tell us to ignore an ipm error message.
    //
    BOOL m_HandleSignalled;

};  // class WORKER_PROCESS



#endif  // _WORKER_PROCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_item.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_item.cxx

Abstract:

    The class which encapsulates a work item, which is the unit of work
    placed on the WORK_QUEUE. 

    Threading: The work item can be filled out and submitted by any one 
    thread, but it will only be executed on the main worker thread.

Author:

    Seth Pollack (sethp)        26-Aug-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the WORK_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_ITEM::WORK_ITEM(
    )
{

#if DBG
    m_ListEntry.Flink = NULL;
    m_ListEntry.Blink = NULL; 
#endif  // DBG

    
    m_NumberOfBytesTransferred = 0;
    m_CompletionKey = 0;


    m_OpCode = 0;

    m_pWorkDispatch = NULL;
    
    // By default all work items should be deleted
    // once they have been processed.
    m_AutomaticDelete = TRUE;

    SecureZeroMemory( &m_Overlapped, sizeof( m_Overlapped ) );


#if DBG
    m_SerialNumber = 0;
#endif  // DBG

    m_Signature = WORK_ITEM_SIGNATURE;

}   // WORK_ITEM::WORK_ITEM



/***************************************************************************++

Routine Description:

    Destructor for the WORK_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_ITEM::~WORK_ITEM(
    )
{

    DBG_ASSERT( m_Signature == WORK_ITEM_SIGNATURE );
    
    m_Signature = WORK_ITEM_SIGNATURE_FREED;

    if ( m_pWorkDispatch != NULL )
    {

        //
        // Now that the work item is done, dereference the work dispatch 
        // object. 
        //

        m_pWorkDispatch->Dereference();
        m_pWorkDispatch = NULL;

    }
    
}   // WORK_ITEM::~WORK_ITEM



/***************************************************************************++

Routine Description:

    Execute the work item.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_ITEM::Execute(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( m_pWorkDispatch != NULL );


    // execute the work item
    hr = m_pWorkDispatch->ExecuteWorkItem( this );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Work item execution returned an error\n"
            ));

    }


    return hr;
    
}   // WORK_ITEM::Execute



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from an OVERLAPPED to a WORK_ITEM.

Arguments:

    pOverlapped - A pointer to the m_Overlapped member of a WORK_ITEM.

Return Value:

    The pointer to the containing WORK_ITEM.

--***************************************************************************/

// note: static!
WORK_ITEM *
WORK_ITEM::WorkItemFromOverlapped(
    IN const OVERLAPPED * pOverlapped
    )
{

    WORK_ITEM * pWorkItem = NULL;


    DBG_ASSERT( pOverlapped != NULL );


    //  get the containing structure, then verify the signature
    
    pWorkItem = CONTAINING_RECORD( pOverlapped, WORK_ITEM, m_Overlapped );

    DBG_ASSERT( pWorkItem->m_Signature == WORK_ITEM_SIGNATURE );


    return pWorkItem;

}   // WORK_ITEM::WorkItemFromOverlapped



/***************************************************************************++

Routine Description:

    Set the pointer to the WORK_DISPATCH-derived instance which will execute 
    this work item, and reference it appropriately.

Arguments:

    pWorkDispatch - The WORK_DISPATCH-derived instance which will be 
    responsible for executing the work item. Must be valid (non-NULL). 
    A Reference() call will be made to this instance inside this call.

Return Value:

    None.

--***************************************************************************/

VOID
WORK_ITEM::SetWorkDispatchPointer(
    IN WORK_DISPATCH * pWorkDispatch
    )
{

    DBG_ASSERT( pWorkDispatch != NULL );


    if ( m_pWorkDispatch != NULL )
    {

        //
        // This field is already set to something else, so dereference the 
        // old work dispatch pointer before overwriting it.
        //

        m_pWorkDispatch->Dereference();

    }


    //
    // Record and reference the new pointer so that it will stay around while 
    // the async work item is pending.
    //
    
    m_pWorkDispatch = pWorkDispatch; 

    m_pWorkDispatch->Reference();


    return;
    
}   // WORK_ITEM::SetWorkDispatchPointer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_queue.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_queue.cxx

Abstract:

    The IIS web admin service work queue class implementation. The queue is 
    simply a completion port which is managed by this class. Work may be 
    put on the queue either by associating a handle with this port, in 
    which case the handle's asynchronous i/o operations will complete here, 
    or by explicitly posting work items.

    All work on the queue is serviced by the one main worker thread. This 
    prevents a number of race conditions, and allows us to avoid taking locks 
    around state which is only accessed on this thread. It means however that 
    all "interesting" work in the web admin service must be packaged as work 
    items, i.e. classes which implement the WORK_DISPATCH interface. If a 
    different thread has work to do, it must queue it as a work item so that
    it will be executed on the main worker thread.
    
    Furthermore, these work items cannot do long-running operations, as 
    that would block other work in the queue. Instead, an asynchronous 
    approach (posting more work items later) must be taken for such 
    long-running tasks.

    Threading: Work can be enqueued from any thread. However, the main 
    worker thread is the only one who processes work items.

Author:

    Seth Pollack (sethp)        25-Aug-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the WORK_QUEUE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_QUEUE::WORK_QUEUE(
    )
    :
    m_DispenseWorkItemLock()
{

    m_CompletionPort = NULL;

    m_DeletePending = FALSE;

    m_CountWorkItemsOutstanding = 0;

    m_pAdvancedWorkItem = NULL;

    m_NumDropped = 0;
#if DBG
    InitializeListHead( &m_WorkItemsOutstandingListHead );

    m_CountWorkItemsGivenOut = 0;
#endif  // DBG

    m_Signature = WORK_QUEUE_SIGNATURE;

}   // WORK_QUEUE::WORK_QUEUE



/***************************************************************************++

Routine Description:

    Destructor for the WORK_QUEUE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_QUEUE::~WORK_QUEUE(
    )
{

    DBG_ASSERT( m_Signature == WORK_QUEUE_SIGNATURE );

    m_Signature = WORK_QUEUE_SIGNATURE_FREED;


    // verify that we have processed all outstanding work items
    DBG_ASSERT( m_CountWorkItemsOutstanding == 0 );

#if DBG
    DBG_ASSERT( IsListEmpty( &m_WorkItemsOutstandingListHead ) );
#endif  // DBG

    DBG_ASSERT( m_pAdvancedWorkItem == NULL );

    if ( m_CompletionPort != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_CompletionPort ) );
        m_CompletionPort = NULL;
    }


    m_DispenseWorkItemLock.Terminate();

}   // WORK_QUEUE::~WORK_QUEUE



/***************************************************************************++

Routine Description:

    Initialize the work queue by creating the i/o completion port.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::Initialize(
    )
{

    HRESULT hr = S_OK;


    //
    // Initialize the lock.
    //

    hr = m_DispenseWorkItemLock.Initialize();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Lock initialization failed\n"
            ));

        goto exit;
    }


    //
    // Create a new completion port.
    //
    // Note that we will only have the one main worker thread service this 
    // port, so the parameter passed here for the number of concurrent threads 
    // is unimportant.
    //
    
    m_CompletionPort = CreateIoCompletionPort(
                            INVALID_HANDLE_VALUE,   // file handle to associate
                            NULL,                   // existing completion port
                            0,                      // completion key
                            0                       // max threads == #processors
                            );


    if ( m_CompletionPort == NULL )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating completion port failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORK_QUEUE::Initialize



/***************************************************************************++

Routine Description:

    Return a blank work item to the caller. 

    In the case of explicitly queued (i.e. not real async i/o) work items, 
    ownership of this WORK_ITEM is automatically transferred back to the 
    work queue via the later call to QueueWorkItem() (even if that method 
    returns failure), and so therefore the WORK_ITEM instance must not be
    explicitly freed by the caller. 

    In the case of true async i/o work items, if the async i/o call succeeds,
    ownership of this WORK_ITEM is automatically transferred back to the 
    work queue. However, if initiating the async i/o call fails, the caller
    must free this WORK_ITEM via FreeWorkItem().

Arguments:

    ppWorkItem - Pointer to the place to put the new work item pointer; 
    a NULL pointer is returned on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::GetBlankWorkItem(
    OUT WORK_ITEM ** ppWorkItem
    )
{

    WORK_ITEM * pNewWorkItem = NULL; 
    HRESULT hr = S_OK;

    
    DBG_ASSERT( ppWorkItem != NULL );

    *ppWorkItem = NULL;


    // 
    // Allocate the new instance up front, before we take the critical section,
    // in order to reduce the time we hold that critical section.
    //


    // CODEWORK allocation cache for WORK_ITEMs?

    pNewWorkItem = new WORK_ITEM();

    if ( pNewWorkItem == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating WORK_ITEM failed\n"
            ));

        // note: early function exit
        return hr;
    }

    
    //
    // Prevent races with the shutdown code. Specifically we must
    // guarantee that once m_DeletePending is set, no other threads may
    // get further blank work items; and furthermore, that the count of 
    // outstanding work items is set atomically with the check of that
    // flag.
    //

    m_DispenseWorkItemLock.Lock();


    if ( m_DeletePending )
    {

        // 
        // Stop handing out work items in the shutdown case, so that we 
        // are guaranteed to quiesce.
        //
        
        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Not returning blank work item because work queue is shutting down\n"
                ));
        }

        hr = HRESULT_FROM_WIN32( ERROR_BUSY );

        // clean up the new instance, since we can't give it out
        delete pNewWorkItem;

        goto exit;
    }


    *ppWorkItem = pNewWorkItem;

    m_CountWorkItemsOutstanding++;


#if DBG

    //
    // Set the serial number.
    //
    
    m_CountWorkItemsGivenOut++;

    ( *ppWorkItem )->SetSerialNumber( m_CountWorkItemsGivenOut );


    //
    // Add to the work items outstanding list.
    //
    
    InsertHeadList( &m_WorkItemsOutstandingListHead, ( *ppWorkItem )->GetListEntry() );

#endif  // DBG

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        CHKINFO((
            DBG_CONTEXT, 
            "Created work item with serial number: %li; work items outstanding: %li\n",
            ( *ppWorkItem )->GetSerialNumber(),
            m_CountWorkItemsOutstanding
            ));
    }


exit:

    m_DispenseWorkItemLock.Unlock();


    return hr;
    
}   // WORK_QUEUE::GetBlankWorkItem



/***************************************************************************++

Routine Description:

    Explicitly queue a work item. In both success and failure cases, the 
    ownership of the WORK_ITEM is transferred to this class, and therefore
    the client may not free it, nor may the client access it after this call.

Arguments:

    pWorkItem - The work item. It must have originally come from a call to
    GetBlankWorkItem().

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::QueueWorkItem(
    IN WORK_ITEM * pWorkItem
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
#if DBG
    ULONG SerialNumber = 0;
#endif  // DBG



    DBG_ASSERT( pWorkItem != NULL );


#if DBG
    // remember serial number to prevent race later
    SerialNumber = pWorkItem->GetSerialNumber();
#endif  // DBG
    

    Success = PostQueuedCompletionStatus(
                    m_CompletionPort,                           // completion port
                    pWorkItem->GetNumberOfBytesTransferred(),   // #bytes transferred
                    pWorkItem->GetCompletionKey(),              // completion key
                    pWorkItem->GetOverlapped()                  // OVERLAPPED
                    );


    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Queueing work item failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {

        CHKINFO((
            DBG_CONTEXT, 
            "Queued work item with serial number: %li\n",
            SerialNumber
            ));

    }


exit:

    if ( FAILED( hr ) )
    {
    
        //
        // If queueing failed, free the work item here. (In the success case,
        // it will be freed once it is serviced.)
        //
        FreeWorkItem( pWorkItem );

    }


    return hr;

}   // WORK_QUEUE::QueueWorkItem



/***************************************************************************++

Routine Description:

    A shortcut routine for the common case of getting a work item, setting 
    the entry point and completion key, and submitting the work item.

Arguments:

    pWorkDispatch - The WORK_DISPATCH-derived instance which will be 
    responsible for executing the work item. Must be valid (non-NULL).
    
    OpCode - The opcode to set for this work item. 

Return Value:

    HRESULT. 

--***************************************************************************/

HRESULT
WORK_QUEUE::GetAndQueueWorkItem(
    IN WORK_DISPATCH * pWorkDispatch,
    IN ULONG_PTR OpCode
    )
{

    HRESULT hr = S_OK;
    WORK_ITEM * pWorkItem = NULL; 
    

    DBG_ASSERT( pWorkDispatch != NULL );


    hr = GetBlankWorkItem( &pWorkItem );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get a blank work item\n"
            ));

        goto exit;
    }


    pWorkItem->SetWorkDispatchPointer( pWorkDispatch );
    pWorkItem->SetOpCode( OpCode );


    hr = QueueWorkItem( pWorkItem );
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not queue work item\n"
            ));

        //
        // Note that in this failure case, pWorkItem was freed for us
        // by the QueueWorkItem() call.
        //
    
        goto exit;
    }


exit:

    return hr;
    
}   // WORK_QUEUE::GetAndQueueWorkItem



/***************************************************************************++

Routine Description:

    Associates an asynchronous i/o handle with the completion port of this
    work queue.

    Note that all subsequent asynchronous i/o operations on that handle must
    be done using WORK_ITEM instances to get the OVERLAPPED structure.

Arguments:

    HandleToBind - The i/o handle to associate with the completion port.
    
    CompletionKey - The key to return with i/o completions from this handle.
    Optional.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::BindHandleToCompletionPort(
    IN HANDLE HandleToBind,
    IN ULONG_PTR CompletionKey OPTIONAL
    )
{

    HANDLE ResultHandle = NULL;
    HRESULT hr = S_OK;


    DBG_ASSERT( HandleToBind != INVALID_HANDLE_VALUE );
    
    ResultHandle = CreateIoCompletionPort(
                        HandleToBind,       // file i/o handle
                        m_CompletionPort,   // completion port
                        CompletionKey,      // completion key
                        0                   // max threads == #processors
                        );


    if ( ResultHandle == NULL )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Binding handle to completion port failed\n"
            ));

    }


    // 
    // Note that in the success case, we do not need to do a CloseHandle()
    // on ResultHandle.
    //


    return hr;

}   // WORK_QUEUE::BindHandleToCompletionPort

/***************************************************************************++

Routine Description:

    Associates a job object with the completion port of this
    work queue.

    Note that all subsequent asynchronous i/o operations on that handle must
    be done using WORK_ITEM instances to get the OVERLAPPED structure.

Arguments:

    HandleToBind - The i/o handle to associate with the completion port.
    
    CompletionKey - The key to return with i/o completions from this handle.
    Optional.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::BindJobToCompletionPort(
    IN HANDLE JobToBind,
    IN LPOVERLAPPED pOverlapped
    )
{

    HRESULT hr = S_OK;
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT port;

    DBG_ASSERT ( m_CompletionPort );
    DBG_ASSERT ( JobToBind );
    DBG_ASSERT ( pOverlapped );

    port.CompletionKey = (LPVOID) pOverlapped;
    port.CompletionPort = m_CompletionPort;

    if ( ! SetInformationJobObject( JobToBind,
                                    JobObjectAssociateCompletionPortInformation,
                                    &port,
                                    sizeof( port ) ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Binding a completion port to a job object failed\n"
            ));

        goto exit;

    }

exit:

    return hr;

}   // WORK_QUEUE::BindJobToCompletionPort


/***************************************************************************++

Routine Description:

    Free a completed work item.

Arguments:

    pWorkItem - Pointer to the work item to free.

Return Value:

    None.

--***************************************************************************/

VOID
WORK_QUEUE::FreeWorkItem(
    IN WORK_ITEM * pWorkItem
    )
{

    DBG_ASSERT( pWorkItem != NULL );


    //
    // Synchronize, since the count of work items outstanding can be updated 
    // by multiple threads getting blank work items.
    //
    m_DispenseWorkItemLock.Lock();
    
    m_CountWorkItemsOutstanding--;


#if DBG

    //
    // Remove from the work items outstanding list.
    //

    RemoveEntryList( pWorkItem->GetListEntry() );
    ( pWorkItem->GetListEntry() )->Flink = NULL; 
    ( pWorkItem->GetListEntry() )->Blink = NULL; 

#endif  // DBG


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        CHKINFO((
            DBG_CONTEXT, 
            "Freeing work item with serial number: %li; work items outstanding: %li\n",
            pWorkItem->GetSerialNumber(),
            m_CountWorkItemsOutstanding
            ));
    }


    m_DispenseWorkItemLock.Unlock();


    delete pWorkItem;
    
}   // WORK_QUEUE::FreeWorkItem



/***************************************************************************++

Routine Description:

    Dequeue, execute, and free a work item.

Arguments:

    None.

Return Value:

    HRESULT - Failures from here will stop the service ( or the queue if it
              is on the config thread ).

--***************************************************************************/

HRESULT
WORK_QUEUE::ProcessWorkItem(
    )
{

    HRESULT hr = S_OK;
    WORK_ITEM * pWorkItem = NULL;
    DWORD dwCount = 0;

    //
    // if something is waiting then use it, other wise
    // go ahead and get a new item from the queue.
    //
    if (  m_pAdvancedWorkItem )
    {
        //
        // since we are single threaded, this ordering will
        // work without any issue to other threads coming in
        // and affecting the AdvancedWorkItem.
        //
        pWorkItem = m_pAdvancedWorkItem;
        m_pAdvancedWorkItem = NULL;
    }
    else
    {
        do
        {
            hr = DequeueWorkItem( INFINITE, &pWorkItem );
            if ( FAILED( hr ) )
            {   
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Dequeuing a work item failed\n"
                    ));

                Sleep ( 1000 );
            }

            dwCount ++;
        }
        while ( FAILED ( hr ) && dwCount < 100 );
    }

    if ( FAILED ( hr ) )
    {
        goto exit;
    }

    hr = pWorkItem->Execute();
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Work item execution failed\n"
            ));

    }


    //
    // Whether it succeeded or failed, always free the work item
    // if the work item is to be deleted.
    //

    if ( pWorkItem->DeleteWhenDone() )
    {
        FreeWorkItem( pWorkItem );
    }


exit:

    return hr;

}   // WORK_QUEUE::ProcessWorkItem

/***************************************************************************++

Routine Description:

    Dequeue's work item and passes it back to the caller, but also holds it
    to be processed the next time ProcessWorkItem is called.  If the caller 
    determines that this item can be ignored, it will call the drop advanced
    item.  You can only ever advance one item at a time.

Arguments:

    WORK_ITEM** ppWorkItem -- Work item, can be null if no item is waiting yet.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::AdvancePeakWorkItem(
    WORK_ITEM** ppWorkItem
    )
{

    HRESULT hr = S_OK;
    DBG_ASSERT ( ppWorkItem != NULL &&
                *ppWorkItem == NULL );

    DBG_ASSERT ( m_pAdvancedWorkItem == NULL );

    // testing on a 500mhz machine showed 10 too slow, and 50 working
    // since this is really an optimization for creating sites when 
    // we are in a production type world, this value should be fine.
    // we wait 250th of a second for new changes to come in.
    hr = DequeueWorkItem( 50, &m_pAdvancedWorkItem );
    if ( hr == HRESULT_FROM_WIN32( WAIT_TIMEOUT ) )
    {
        hr = S_OK;
    }

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Advancing a work item failed\n"
            ));

        goto exit;
    }

    *ppWorkItem = m_pAdvancedWorkItem;

exit:

    return hr;

}   // WORK_QUEUE::AdvancePeakWorkItem

/***************************************************************************++

Routine Description:

    If the caller decides that the next work item is not worthy of handling
    the caller can tell the queue to drop the item.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/

VOID
WORK_QUEUE::DropAdvancedWorkItem(
    )
{

    WORK_ITEM* pWorkItem = m_pAdvancedWorkItem;

    DBG_ASSERT ( pWorkItem != NULL );
    m_pAdvancedWorkItem = NULL;
    m_NumDropped++;

    //
    // We might be cleaning the queue but not have
    // gotten to the item to release the work_items
    // from the job objects, so we still need to do
    // the check if we really want to delete the 
    // work_item.
    //
    if ( pWorkItem->DeleteWhenDone() )
    {

        //
        // Free the work item. 
        //

        FreeWorkItem( pWorkItem );
    }

}   // WORK_QUEUE::DropAdvancedWorkItem

/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORK_QUEUE::Terminate(
    )
{

    HRESULT hr = S_OK;
    WORK_ITEM * pWorkItem = NULL;
    ULONG DequeueFailCount = 0;


    // prevent races with other threads attempting to get blank work items
    m_DispenseWorkItemLock.Lock();

    // prevent any more blank work items from being dispensed
    m_DeletePending = TRUE;

    m_DispenseWorkItemLock.Unlock();

    
    //
    // Dequeue, execute, and free all remaining work items, in order to free 
    // all resources. 
    //
    // We wake up periodically to check the count of work items outstanding 
    // because some work items might get explicitly freed via FreeWorkItem() 
    // on error paths, and never make it onto the queue for us to dequeue.
    //
    // Also, no explicit synchronization is necessary on this thread-shared 
    // variable because this is an aligned 32-bit read (and we are
    // guaranteed that this count cannot go back up once it has hit zero).
    //

    //
    // if we had advanced a work item, deal with it first.
    //
    if (  m_pAdvancedWorkItem )
    {
        pWorkItem = m_pAdvancedWorkItem;
        m_pAdvancedWorkItem = NULL;

        hr = pWorkItem->Execute();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Work item execution failed\n"
                ));

        }

        //
        // We might be cleaning the queue but not have
        // gotten to the item to release the work_items
        // from the job objects, so we still need to do
        // the check if we really want to delete the 
        // work_item.
        //
        if ( pWorkItem->DeleteWhenDone() )
        {

            //
            // Free the work item. 
            //

            FreeWorkItem( pWorkItem );
        }
    }

    // now start removing the rest from the queue.
    while ( m_CountWorkItemsOutstanding > 0 )
    {
    
        hr = DequeueWorkItem( ONE_SECOND_IN_MILLISECONDS, &pWorkItem );

        if ( FAILED( hr ) )
        {


            DBG_ASSERT( pWorkItem == NULL );


            if ( hr == HRESULT_FROM_WIN32( WAIT_TIMEOUT ) )
            {
            
                DBGPRINTF(( 
                    DBG_CONTEXT,
                    "Dequeuing work item timed out; work items still outstanding: %lu\n",
                    m_CountWorkItemsOutstanding 
                    ));

            } 
            else
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Couldn't dequeue a work item\n"
                    ));

            }

            DequeueFailCount++;

            if ( DequeueFailCount > 30 )
            {

                //
                // Forget about it; let's get out of here.
                //

                DBGPRINTF(( 
                    DBG_CONTEXT,
                    "Giving up waiting to dequeue remaining work items; work items still outstanding: %lu\n",
                    m_CountWorkItemsOutstanding 
                    ));


                //
                // On debug builds, assert if we are going to bail with work 
                // items still outstanding; it might signify a bug.
                //

                DBG_ASSERT( DequeueFailCount <= 30 );


                break;
            }
        }


        if ( pWorkItem != NULL )
        {
            //
            // Execute the work item. Ignore failures. 
            //

            hr = pWorkItem->Execute();

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Work item execution failed\n"
                    ));

            }

            //
            // We might be cleaning the queue but not have
            // gotten to the item to release the work_items
            // from the job objects, so we still need to do
            // the check if we really want to delete the 
            // work_item.
            //
            if ( pWorkItem->DeleteWhenDone() )
            {

                //
                // Free the work item. 
                //

                FreeWorkItem( pWorkItem );
            }
        }

    }


    return;    
    
}   // WORK_QUEUE::Terminate



/***************************************************************************++

Routine Description:

    Dequeue the next work item. Called by the main thread only. The thread
    will block on the completion port until a work item is available or the
    timeout is reached.

Arguments:

    Timeout - Time in milliseconds to wait for a work item, or INFINITE.

    ppWorkItem - Outputs the work item, or NULL on failure. 

Return Value:

    HRESULT. This method returns an error only if the dequeued failed (which 
    includes timeouts, where HRESULT_FROM_WIN32( WAIT_TIMEOUT ) is returned). 
    If instead the dequeue succeeded but returned a completion of a failed 
    i/o, this method returns S_OK, but records the i/o error in the work item.

--***************************************************************************/

HRESULT
WORK_QUEUE::DequeueWorkItem(
    IN DWORD Timeout,
    OUT WORK_ITEM ** ppWorkItem
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
    DWORD NumberOfBytesTransferred = 0;
    ULONG_PTR CompletionKey = 0;
    LPOVERLAPPED pOverlapped = NULL;


    DBG_ASSERT( ppWorkItem != NULL );

    *ppWorkItem = NULL;
    
    Success = GetQueuedCompletionStatus(
                    m_CompletionPort,           // completion port
                    &NumberOfBytesTransferred,  // #bytes transferred
                    &CompletionKey,             // completion key
                    &pOverlapped,               // OVERLAPPED
                    Timeout                     // time to wait
                    );


    if ( (! Success) && ( pOverlapped == NULL ) )
    {
        //
        // If pOverlapped isn't NULL, then the GetQueuedCompletionStatus
        // call succeeded, it's just that the i/o operation that generated
        // the completion failed. If it is NULL, then we have a timeout or
        // a real failure.
        //

        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // dequeue failed

        if ( hr == HRESULT_FROM_WIN32( WAIT_TIMEOUT ) )
        {
        
            IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Dequeuing work item timed out\n"
                    ));
            }

        } 
        else
        {
        
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Dequeueing work item failed\n"
                ));

        }

        goto exit;
    }


    if ( CompletionKey == 0 )
    {
        *ppWorkItem = WORK_ITEM::WorkItemFromOverlapped( pOverlapped );
    }
    else
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {

            DBGPRINTF((
                DBG_CONTEXT, 
                "CompletionKey = %08x\n"
                "pOverlapped = %08x\n"
                "size = %d \n",
                CompletionKey,
                pOverlapped,
                NumberOfBytesTransferred
                ));

        }

        // if we do have a CompletionKey, then it
        // is the address of the overlapped member in the
        // job object that we want to process.
        //
        // We are forced to handle this this way by the fact that the
        // Job Objects will send this pointer value back to us

        *ppWorkItem = WORK_ITEM::WorkItemFromOverlapped( ( LPOVERLAPPED ) CompletionKey );
    }

    DBG_ASSERT( *ppWorkItem != NULL );


    ( *ppWorkItem )->SetNumberOfBytesTransferred( NumberOfBytesTransferred );
    ( *ppWorkItem )->SetCompletionKey( CompletionKey );
   

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {

        CHKINFO((
            DBG_CONTEXT, 
            "Dequeued work item with serial number: %li\n",
            ( *ppWorkItem )->GetSerialNumber()
            ));

    }


exit:

    return hr;

}   // WORK_QUEUE::DequeueWorkItem



/***************************************************************************++

Routine Description:

    Attempt to queue a work item from a secondary thread (i.e., not the main
    worker thread). 

Arguments:

    pWorkDispatch - The WORK_DISPATCH-derived instance which will be 
    responsible for executing the work item. Must be valid (non-NULL).
    
    OpCode - The opcode to set for this work item. 

Return Value:

    None.

--***************************************************************************/

HRESULT
QueueWorkItemFromSecondaryThread(
    IN WORK_DISPATCH * pWorkDispatch,
    IN ULONG_PTR OpCode
    )
{

    DBG_ASSERT( pWorkDispatch != NULL );

    return GetWebAdminService()->GetWorkQueue()->GetAndQueueWorkItem(
                                                    pWorkDispatch,
                                                    OpCode);
    
    
}   // QueueWorkItemFromSecondaryThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_item.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_item.h

Abstract:

    The IIS web admin service work item class definition.

Author:

    Seth Pollack (sethp)        26-Aug-1998

Revision History:

--*/


#ifndef _WORK_ITEM_H_
#define _WORK_ITEM_H_



//
// common #defines
//

#define WORK_ITEM_SIGNATURE         CREATE_SIGNATURE( 'WITM' )
#define WORK_ITEM_SIGNATURE_FREED   CREATE_SIGNATURE( 'witX' )


//
// prototypes
//

class WORK_ITEM
{

public:

    WORK_ITEM(
        );

    virtual
    ~WORK_ITEM(
        );

    HRESULT
    Execute(
        );

    // "downcast" from a WORK_ITEM to an OVERLAPPED
    inline
    LPOVERLAPPED
    GetOverlapped(
        )
    { return &m_Overlapped; }

    // "upcast" from an OVERLAPPED to a WORK_ITEM
    static
    WORK_ITEM *
    WorkItemFromOverlapped(
        IN const OVERLAPPED * pOverlapped
        );

    VOID
    SetWorkDispatchPointer(
        IN WORK_DISPATCH * pWorkDispatch
        );

    WORK_DISPATCH*
    QueryWorkDispatchPointer(
        )
    {
        return m_pWorkDispatch;
    }

    inline
    VOID
    SetOpCode(
        IN ULONG_PTR OpCode
        )
    { m_OpCode = OpCode; }

    inline
    ULONG_PTR
    GetOpCode(
        )
        const
    { return m_OpCode; }

    inline
    VOID
    SetNumberOfBytesTransferred(
        IN DWORD NumberOfBytesTransferred
        )
    { m_NumberOfBytesTransferred = NumberOfBytesTransferred; }

    inline
    DWORD
    GetNumberOfBytesTransferred(
        )
        const
    { return m_NumberOfBytesTransferred; }

    inline
    VOID
    SetCompletionKey(
        IN ULONG_PTR CompletionKey
        )
    { m_CompletionKey = CompletionKey; }

    inline
    ULONG_PTR
    GetCompletionKey(
        )
        const
    { return m_CompletionKey; }

    BOOL 
    DeleteWhenDone(
        )
    { return m_AutomaticDelete; }

    VOID
    MarkToNotAutoDelete(
        )
    { m_AutomaticDelete = FALSE; }


#if DBG

    inline
    VOID
    SetSerialNumber(
        IN ULONG SerialNumber
        )
    { m_SerialNumber = SerialNumber; }

    inline
    ULONG
    GetSerialNumber(
        )
        const
    { return m_SerialNumber; }

    inline
    PLIST_ENTRY
    GetListEntry(
        )
    { return &m_ListEntry; }
    
#endif  // DBG


private:

    DWORD m_Signature;


#if DBG
    // used for keeping a list of work items outstanding
    LIST_ENTRY m_ListEntry;
#endif  // DBG


    //
    // Members used by work items that are real i/o completions. These do
    // not need to be set for non-i/o work items.
    //
    
    DWORD m_NumberOfBytesTransferred;
    ULONG_PTR m_CompletionKey;

    // opcode for work dispatch
    ULONG_PTR m_OpCode;


    // pointer for work dispatch
    WORK_DISPATCH * m_pWorkDispatch;


    // for queuing on the completion port
    OVERLAPPED m_Overlapped;


    BOOL m_AutomaticDelete;

#if DBG
    LONG m_SerialNumber;
#endif  // DBG


};  // class WORK_ITEM



#endif  // _WORK_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_queue.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_queue.h

Abstract:

    The IIS web admin service work queue class definition.

Author:

    Seth Pollack (sethp)        25-Aug-1998

Revision History:

--*/


#ifndef _WORK_QUEUE_H_
#define _WORK_QUEUE_H_



//
// common #defines
//

#define WORK_QUEUE_SIGNATURE        CREATE_SIGNATURE( 'WRKQ' )
#define WORK_QUEUE_SIGNATURE_FREED  CREATE_SIGNATURE( 'wrkX' )



//
// prototypes
//

class WORK_QUEUE
{

public:

    WORK_QUEUE(
        );

    virtual
    ~WORK_QUEUE(
        );

    HRESULT
    Initialize(
        );

    HRESULT
    GetBlankWorkItem(
        OUT WORK_ITEM ** ppWorkItem
        );

    HRESULT
    QueueWorkItem(
        IN WORK_ITEM * pWorkItem
        );

    HRESULT
    GetAndQueueWorkItem(
        IN WORK_DISPATCH * pWorkDispatch,
        IN ULONG_PTR OpCode
        );

    HRESULT
    BindHandleToCompletionPort(
        IN HANDLE HandleToBind,
        IN ULONG_PTR CompletionKey OPTIONAL
        );

    HRESULT
    BindJobToCompletionPort(
        IN HANDLE JobToBind,
        IN LPOVERLAPPED pOverlapped
        );

    VOID
    FreeWorkItem(
        IN WORK_ITEM * pWorkItem
        );

    HRESULT
    ProcessWorkItem(
        );

    HRESULT
    AdvancePeakWorkItem(
        WORK_ITEM** ppWorkItem
        );

    VOID
    DropAdvancedWorkItem(
        );


    VOID
    Terminate(
        );


private:

    HRESULT
    DequeueWorkItem(
        IN DWORD Timeout,
        OUT WORK_ITEM ** ppWorkItem
        );


    DWORD m_Signature;

    HANDLE m_CompletionPort;

    //
    // Prevent races between the shutdown code and other threads
    // attempting to get new blank work items; as well as
    // protecting access to the count of work items outstanding. 
    //
    LOCK m_DispenseWorkItemLock;

    BOOL m_DeletePending;
    
    ULONG m_CountWorkItemsOutstanding;

    // used to hold a work item, one in advanced so we can tell
    // if the work item should be ignored based on the current work item.
    WORK_ITEM* m_pAdvancedWorkItem;

    DWORD m_NumDropped;
#if DBG
    LIST_ENTRY m_WorkItemsOutstandingListHead;

    ULONG m_CountWorkItemsGivenOut;
#endif  // DBG
    

};  // class WORK_QUEUE



//
// helper functions
//


HRESULT
QueueWorkItemFromSecondaryThread(
    IN WORK_DISPATCH * pWorkDispatch,
    IN ULONG_PTR OpCode
    );



#endif  // _WORK_QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\fakewp\makefile.inc ===
$(O)\sausage.res: sausage.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\precomp.h ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        21-Feb-2000

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

// ensure that all GUIDs are initialized
#define INITGUID

// main project include
#include <iis.h>

#include <dbgutil.h>

// other standard includes
#include <stdio.h>
#include <stdlib.h>

// other project includes
#include <iadmw.h>

#include <iiscnfg.h>
#include <mb.hxx>


//
// Local prototypes.
//

extern "C" {

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    );

}   // extern "C"

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\makefile.inc ===
$(O)\baseobj.res: baseobj.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\fakewp\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        20-Jul-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <windows.h>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\baseobj.cxx ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Baseobj modifies properties using the admin base objects

Author:

    Emily Kruglick (EmilyK) 11/28/2000

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//



// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();



//
// Public functions.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;

    CREATE_DEBUG_PRINT_OBJECT( "baseobj" );
        
    if ( ! VALID_DEBUG_PRINT_OBJECT() )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Debug print object is not valid\n"
            ));
    }

    IMSAdminBase * pIMSAdminBase = NULL;
    BOOL fCoInit = FALSE;
    BOOL fCloseSiteKey = FALSE;
    METADATA_HANDLE hW3SVC = NULL;
    METADATA_RECORD mdrMDData;

    

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }
    
    fCoInit = TRUE;

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }


    //
    // Open the Sites Key so we can change the app pool
    //
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                    L"LM\\W3SVC",
                                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                    10,
                                    &hW3SVC );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Openning the site key failed\n"
            ));

        goto exit;
    }

    fCloseSiteKey = TRUE;

    mdrMDData.dwMDIdentifier    = MD_APPPOOL_APPPOOL_ID;
    mdrMDData.dwMDAttributes    = METADATA_NO_ATTRIBUTES;
    mdrMDData.dwMDUserType      = IIS_MD_UT_SERVER;
    mdrMDData.dwMDDataType      = STRING_METADATA;
    mdrMDData.dwMDDataLen       =( wcslen(L"DefaultAppPool") + 1 ) * sizeof (WCHAR); 
    mdrMDData.pbMDData          = (BYTE *) L"DefaultAppPool"; 

    hr = pIMSAdminBase->SetData(hW3SVC, L"1", &mdrMDData);
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new app pool failed\n"
            ));

        goto exit;
    }

    hr = pIMSAdminBase->DeleteKey( hW3SVC, L"apppools\\otheremspool");
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "deleting app pool failed\n"
            "apppools\\otheremspool"
            ));

        goto exit;
    }




exit:

    if ( fCloseSiteKey )
    {
        hr = pIMSAdminBase->CloseKey( hW3SVC );
        if ( FAILED( hr ) )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "closing the site key failed\n"
                ));

            goto exit;
        }
    }

    if (pIMSAdminBase)
    {
       pIMSAdminBase->Release();
    }

    if ( fCoInit )
    {
        CoUninitialize();
    }

    return hr;

}   // wmain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\baseobj2.cxx ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Baseobj modifies properties using the admin base objects

Author:

    Emily Kruglick (EmilyK) 11/28/2000

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//



// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();



//
// Public functions.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;
    BOOL    fRet = TRUE;
    IMSAdminBase * pIMSAdminBase = NULL;
    BOOL fCoInit = FALSE;
    MB* pMB = NULL;

    CREATE_DEBUG_PRINT_OBJECT( "baseobj" );
        
    if ( ! VALID_DEBUG_PRINT_OBJECT() )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Debug print object is not valid\n"
            ));
    }

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }
    
    fCoInit = TRUE;

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }

    pMB = new MB( pIMSAdminBase );
    if ( pMB == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = E_OUTOFMEMORY;

        goto exit;
    }

    fRet = pMB->Open( L"LM/W3SVC/", METADATA_PERMISSION_WRITE );
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }

    fRet = pMB->AddObject(L"100");
    if ( !fRet )
    {
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }

    fRet = pMB->SetString( L"100",
                           MD_KEY_TYPE,
                           IIS_MD_UT_SERVER,
                           L"IIsWebServer" );
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    fRet = pMB->SetString( L"100",
                           MD_SERVER_BINDINGS,
                           IIS_MD_UT_SERVER,
                           L":82:" );
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    fRet = pMB->SetDword( L"100",
                           MD_SERVER_COMMAND,
                           IIS_MD_UT_SERVER,
                           2 );
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }

    fRet = pMB->Close();
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }



exit:

    if ( pMB )
    {
        delete pMB;
    }

    if (pIMSAdminBase)
    {
       pIMSAdminBase->Release();
    }

    if ( fCoInit )
    {
        CoUninitialize();
    }

    return hr;

}   // wmain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\baseobj1.cxx ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Baseobj modifies properties using the admin base objects

Author:

    Emily Kruglick (EmilyK) 11/28/2000

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//



// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();



//
// Public functions.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;
    BOOL    fRet = TRUE;
    IMSAdminBase * pIMSAdminBase = NULL;
    BOOL fCoInit = FALSE;
    MB* pMB = NULL;

    CREATE_DEBUG_PRINT_OBJECT( "baseobj" );
        
    if ( ! VALID_DEBUG_PRINT_OBJECT() )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Debug print object is not valid\n"
            ));
    }

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }
    
    fCoInit = TRUE;

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }

    pMB = new MB( pIMSAdminBase );
    if ( pMB == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = E_OUTOFMEMORY;

        goto exit;
    }

    fRet = pMB->Open( L"LM/W3SVC/APPPOOLS", METADATA_PERMISSION_WRITE );
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }

    fRet = pMB->AddObject(L"EMTEST");
    if ( !fRet )
    {
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }

    fRet = pMB->SetString( L"EMTEST",
                           MD_KEY_TYPE,
                           IIS_MD_UT_SERVER,
                           L"IIsApplicationPool" );
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    fRet = pMB->SetDword( L"EMTEST",
                           MD_APPPOOL_COMMAND,
                           IIS_MD_UT_SERVER,
                           2 );
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }

    fRet = pMB->Close();
    if ( !fRet )
    {
        DBG_ASSERT( FALSE );
        hr =  HRESULT_FROM_WIN32( GetLastError() );

        goto exit;
    }



exit:

    if ( pMB )
    {
        delete pMB;
    }

    if (pIMSAdminBase)
    {
       pIMSAdminBase->Release();
    }

    if ( fCoInit )
    {
        CoUninitialize();
    }

    return hr;

}   // wmain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\upmbtodt\makefile.inc ===
$(O)\upmbtodt.res: upmbtodt.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\w3control\makefile.inc ===
$(O)\w3control.res: w3control.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\upmbtodt\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        28-Jan-1999

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <iis.h>

#include <dbgutil.h>

#include <stdio.h>

#undef DEFINE_GUID
#define INITGUID
#include <ole2.h>

#include <iadmw.h>

#include <iiscnfg.h>

#include <mb.hxx>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\fakewp\sausage.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    sausage.c

Abstract:

    Test exe code for the worker process. 

Author:

    Seth Pollack (sethp)        20-Jul-1998

Revision History:

--*/


#include "precomp.h"


/***************************************************************************++

Routine Description:

    The main entry point for the worker process.

Arguments:

    argc - Count of command line arguments.

    argv - Array of command line argument strings.

Return Value:

    INT

--***************************************************************************/

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    MessageBox(
        NULL,
        GetCommandLine(),
        GetCommandLine(),
        MB_OK
        );
                
    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\upmbtodt\upmbtodt.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    upmbtodt.cxx

Abstract:

    Tool to upgrade an existing IIS metabase to duct-tape, by adding app 
    pool information.

Author:

    Seth Pollack (sethp)        28-Jan-1999

Revision History:

--*/



#include "precomp.h"



//
// common #defines
//

#define APP_POOL_FORMERLY_INPROC L"DefaultAppPool1"
#define APP_POOL_FORMERLY_OUTOFPROCPOOLED L"DefaultAppPool2"
#define APP_POOL_ISOLATED_PREFIX L"IsolatedAppPool"


#define MAX_STRINGIZED_ULONG_CHAR_COUNT 11



//
// metabase paths, properties, etc.
//

// BUGBUG all copied from config_manager.h -- keep in sync

#define IIS_MD_W3SVC L"/LM/W3SVC"

#define IIS_MD_APP_POOLS L"/AppPools"

#define IIS_MD_VIRTUAL_SITE_ROOT L"/Root"

#define MD_APP_APPPOOL ( IIS_MD_HTTP_BASE + 111 )



//
// local prototypes
//

HRESULT
DoWork(
    );

HRESULT
DoWorkHelper(
    IN IMSAdminBase * pIMSAdminBase
    );

HRESULT
EnsureAllSitesHaveRootApplications(
    IN MB * pMetabase
    );

HRESULT
EnsureSiteHasRootApplication(
    IN MB * pMetabase,
    IN LPCWSTR pVirtualSiteKeyName,
    IN DWORD VirtualSiteId,
    OUT BOOL * pFixedVirtualSite
    );

HRESULT
CreateStandardAppPools(
    IN MB * pMetabase
    );

HRESULT
CreateAppPool(
    IN MB * pMetabase,
    LPCWSTR pAppPoolId
    );

HRESULT
SetAppPoolPropertyOnEachApplcation(
    IN MB * pMetabase
    );

HRESULT
EnumAllApplications(
    IN MB * pMetabase,
    OUT MULTISZ * pApplicationPaths
    );

HRESULT
StampApplicationsWithAppPools(
    IN MB * pMetabase,
    IN MULTISZ * pApplicationPaths
    );

HRESULT
StampApplicationWithAppPool(
    IN MB * pMetabase,
    IN LPCWSTR pApplicationPath
    );



//
// global variables
//

// usage information
const CHAR g_Usage[] = 
"Usage: upmbtodt [no flags supported] \n"
" \n"
"Stamp the necessary app pool information for duct-tape into the metabase. \n"
"In essence, this allows you to take an existing IIS installation's \n"
"metabase, with it's configured sites, apps, etc., and 'upgrade' it for use \n"
"with duct-tape. \n"
"In detail, what it does: \n"
"1) 'Fix' any sites with a missing root app (the app at '/' within a site), \n"
"by creating a root app for that site.\n"
"2) Add some standard app pools to the metabase. \n"
"3) For each app in the metabase, stamp it with an app pool property based \n"
"on its current AppIsolated property: If in-proc or out-of-proc-pooled, \n"
"assign to the appropriate standard app pool; if out-of-proc-isolated, \n"
"create a new app pool in the metabase, and assign this app to it. \n"
"Note: this tool may be run multiple times, however, if the set of apps \n"
"in the metabase has changed in the interim, app pools may be orphaned, \n"
"and isolated apps may be reassigned to different app pools. \n"
" \n"
;


// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();



/***************************************************************************++

Routine Description:

    The main entry point.

Arguments:

    argc - Count of command line arguments.

    argv - Array of command line argument strings.

Return Value:

    INT

--***************************************************************************/

extern "C"
INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;


    if ( argc > 1 )
    {
        //
        // Display usage information, and exit.
        //

        printf( g_Usage );

        return 0;
    }

    
    printf( "Starting...\n" );


    CREATE_DEBUG_PRINT_OBJECT( "upmbtodt" );
        
    if ( ! VALID_DEBUG_PRINT_OBJECT() )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Debug print object is not valid\n"
            ));
    }
        

    hr = DoWork();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "DoWork() failed\n"
            ));

    }


    DELETE_DEBUG_PRINT_OBJECT();


    return ( INT ) hr;

}   // wmain



/***************************************************************************++

Routine Description:



Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
DoWork(
    )
{

    HRESULT hr = S_OK;
    IMSAdminBase * pIMSAdminBase = NULL;
    

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }
    

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }


    hr = DoWorkHelper( pIMSAdminBase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "DoWorkHelper() failed\n"
            ));

        goto exit;
    }


    pIMSAdminBase->Release();

    CoUninitialize();


exit:

    return hr;

}   // DoWork



/***************************************************************************++

Routine Description:

    

Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
DoWorkHelper(
    IN IMSAdminBase * pIMSAdminBase
    )
{

    HRESULT hr = S_OK;
    MB Metabase( pIMSAdminBase );
    BOOL Success = TRUE;


    //
    // Open the metabase to the key containing configuration for the web
    // service on the local machine.
    //
    
    Success = Metabase.Open(
                    IIS_MD_W3SVC,
                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Opening metabase failed\n"
            ));

        goto exit;
    }


    hr = EnsureAllSitesHaveRootApplications( &Metabase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "EnsureAllSitesHaveRootApplications() failed\n"
            ));

    }


    hr = CreateStandardAppPools( &Metabase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "CreateStandardAppPools() failed\n"
            ));

    }


    hr = SetAppPoolPropertyOnEachApplcation( &Metabase );
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "SetAppPoolPropertyOnEachApplcation() failed\n"
            ));

    }


exit:

    return hr;

}   // DoWorkHelper

    

/***************************************************************************++

Routine Description:



Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
EnsureAllSitesHaveRootApplications(
    IN MB * pMetabase
    )
{

    DWORD EnumIndex = 0;
    WCHAR KeyName[ METADATA_MAX_NAME_LEN ];
    DWORD VirtualSiteId = 0;
    DWORD FixedVirtualSiteCount = 0;
    BOOL FixedVirtualSite = FALSE;
    HRESULT hr = S_OK;


    DBG_ASSERT( pMetabase != NULL );


    printf( "Scanning for missing site root applications...\n" );


    // enumerate all keys under IIS_MD_W3SVC
    
    while ( pMetabase->EnumObjects( 
                            NULL,
                            KeyName,
                            EnumIndex
                            ) )
    {

        //
        // See if we have a virtual site, as opposed to some other key, 
        // by checking if the key name is numeric (and greater than zero). 
        // Ignore other keys.
        //
        // Note that _wtol returns zero if the string passed to it is not 
        // numeric.
        //
        
        VirtualSiteId = _wtol( KeyName );

        if ( VirtualSiteId > 0 )
        {
            // got one

            hr = EnsureSiteHasRootApplication( pMetabase, KeyName, VirtualSiteId, &FixedVirtualSite ); 

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "EnsureSiteHasRootApplication() failed\n"
                    ));

                goto exit;
            }

            if ( FixedVirtualSite )
            {
                FixedVirtualSiteCount++;
            }

        }

        EnumIndex++;

    }


    // make sure we ran out of items, as opposed to a real error

    if ( GetLastError() != ERROR_NO_MORE_ITEMS ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
        
        goto exit;
    }


    printf( 
        "Total number of virtual sites fixed by adding a root application: %lu\n", 
        FixedVirtualSiteCount 
        );


exit: 

    return hr;

}   // EnsureAllSitesHaveRootApplications



/***************************************************************************++

Routine Description:

    Read the configuration for a particular virtual site from the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pVirtualSiteKeyName - The metabase key name for the virtual site being 
    read.

    VirtualSiteId - The id for the virtual site being read.

    pFixedVirtualSite - Returns FALSE if the metadata for the site was 
    sufficiently invalid that the site was not able to be started, TRUE 
    otherwise. Note that a FALSE value here does not by itself cause this 
    function to return an error. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
EnsureSiteHasRootApplication(
    IN MB * pMetabase,
    IN LPCWSTR pVirtualSiteKeyName,
    IN DWORD VirtualSiteId,
    OUT BOOL * pFixedVirtualSite
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    BOOL ValidRootApplicationExists = TRUE;
    //
    // Buffer must be long enough to hold "/[stringized virtual site id]/Root".
    //
    WCHAR SiteRootPath[ 1 + MAX_STRINGIZED_ULONG_CHAR_COUNT + ( sizeof( IIS_MD_VIRTUAL_SITE_ROOT ) / sizeof ( WCHAR ) ) + 1 ];
    //
    // Buffer must be long enough to hold "/LM/W3SVC/[stringized virtual site id]/Root".
    //
    WCHAR FullSiteRootPath[ ( sizeof( IIS_MD_W3SVC ) / sizeof ( WCHAR ) ) + ( sizeof( SiteRootPath ) / sizeof ( WCHAR ) ) ];
    STRU AppRoot;
    DWORD AppIsolated = 0;
    

    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pVirtualSiteKeyName != NULL );
    DBG_ASSERT( pFixedVirtualSite != NULL );


    *pFixedVirtualSite = FALSE; 


    _snwprintf( SiteRootPath, sizeof( SiteRootPath ) / sizeof ( WCHAR ), L"/%s%s", pVirtualSiteKeyName, IIS_MD_VIRTUAL_SITE_ROOT );


    //
    // Make sure that the root application exists for this site. 
    //

    Success = pMetabase->GetStr(
                                SiteRootPath,
                                MD_APP_ROOT,
                                IIS_MD_UT_WAM,
                                &AppRoot
                                );

    if ( ! Success )
    {

        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // check for "real" errors
        if ( hr != MD_ERROR_DATA_NOT_FOUND )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Reading app root property of application failed\n"
                ));

            goto exit;
        }

        hr = S_OK;
        
        ValidRootApplicationExists = FALSE;
    }


    Success = pMetabase->GetDword(
                                SiteRootPath,
                                MD_APP_ISOLATED,
                                IIS_MD_UT_WAM,
                                &AppIsolated
                                );

    if ( ! Success )
    {

        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // check for "real" errors
        if ( hr != MD_ERROR_DATA_NOT_FOUND )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Reading app isolated property of application failed\n"
                ));

            goto exit;
        }

        hr = S_OK;

        ValidRootApplicationExists = FALSE;
    }


    if ( ! ValidRootApplicationExists )
    {

        //
        // Fix it.
        //


        _snwprintf( FullSiteRootPath, sizeof( FullSiteRootPath ) / sizeof ( WCHAR ), L"%s%s", IIS_MD_W3SVC, SiteRootPath );


        Success = pMetabase->SetString(
                                SiteRootPath,
                                MD_APP_ROOT,
                                IIS_MD_UT_WAM,
                                FullSiteRootPath
                                );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() ); 

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting app root property of application failed\n"
                ));

            goto exit;
        }


        Success = pMetabase->SetDword(
                                SiteRootPath,
                                MD_APP_ISOLATED,
                                IIS_MD_UT_WAM,
                                0
                                );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() ); 

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting app isolated property of application failed\n"
                ));

            goto exit;
        }


        printf( 
            "Added a root application to virtual site: %lu\n", 
            VirtualSiteId
            );

        *pFixedVirtualSite = TRUE; 

    }


exit:

    return hr;

}   // EnsureSiteHasRootApplication



/***************************************************************************++

Routine Description:

    

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CreateStandardAppPools(
    IN MB * pMetabase
    )
{

    HRESULT hr = S_OK;


    printf( "Creating standard app pools...\n" );


    hr = CreateAppPool( pMetabase, APP_POOL_FORMERLY_INPROC );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "CreateAppPool() failed\n"
            ));

        goto exit;
    }


    hr = CreateAppPool( pMetabase, APP_POOL_FORMERLY_OUTOFPROCPOOLED );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "CreateAppPool() failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CreateStandardAppPools



/***************************************************************************++

Routine Description:

    

Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CreateAppPool(
    IN MB * pMetabase,
    LPCWSTR pAppPoolId
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    //
    // Buffer must be long enough to hold "/AppPools/[app pool id]".
    //
    WCHAR AppPoolPath[ ( sizeof( IIS_MD_APP_POOLS ) / sizeof ( WCHAR ) ) + 1 + METADATA_MAX_NAME_LEN ];


    _snwprintf( AppPoolPath, sizeof( AppPoolPath ) / sizeof ( WCHAR ), L"%s/%s", IIS_MD_APP_POOLS, pAppPoolId );


    //
    // Add the key for the new app pool.
    //

    Success = pMetabase->AddObject( AppPoolPath );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        if ( hr == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) )
        {
            // keep going if its already there

            hr = S_OK;
        }
        else
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Creating app pool failed\n"
                ));

            goto exit;
        }
    }


    printf( 
        "Created app pool with id: %S\n", 
        pAppPoolId
        );


exit:

    return hr;

}   // CreateAppPool



/***************************************************************************++

Routine Description:

    

Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
SetAppPoolPropertyOnEachApplcation(
    IN MB * pMetabase
    )
{

    HRESULT hr = S_OK;
    MULTISZ ApplicationPaths;


    printf( "Stamping the app pool property on each application...\n" );


    //
    // Enumerate all the applications. 
    //

    hr = EnumAllApplications( pMetabase, &ApplicationPaths );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Enumerating all applications failed\n"
            ));

        goto exit;
    }


    //
    // Now fix them up with app pool information.
    //

    hr = StampApplicationsWithAppPools(
                pMetabase, 
                &ApplicationPaths
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "StampApplicationsWithAppPools() failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // SetAppPoolPropertyOnEachApplcation



/***************************************************************************++

Routine Description:

    Enumerate and read all applications configured in the metabase.


Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pApplicationPaths - The returned MULTISZ containing the metabase paths
    to the applications.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
EnumAllApplications(
    IN MB * pMetabase,
    OUT MULTISZ * pApplicationPaths
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPaths != NULL );


    //
    // Find the paths of all applications in the metabase. We do this by 
    // asking for the paths to all metabase nodes which define the
    // MD_APP_ISOLATED property. This must be present on any application.
    //

    Success = pMetabase->GetDataPaths(
                                NULL,
                                MD_APP_ISOLATED,
                                ALL_METADATA,
                                pApplicationPaths
                                );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting paths of all applications failed\n"
            ));

        goto exit;
    }


    // get the MULTISZ in sync with its internal BUFFER
    pApplicationPaths->RecalcLen();


exit:

    return hr;

}   // EnumAllApplications



/***************************************************************************++

Routine Description:

    

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pApplicationPaths - A MULTISZ containing the metabase paths to the 
    applications.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
StampApplicationsWithAppPools(
    IN MB * pMetabase,
    IN MULTISZ * pApplicationPaths
    )
{

    HRESULT hr = S_OK;
    LPCWSTR pApplicationPath;


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPaths != NULL );


    pApplicationPath = pApplicationPaths->First();
    
    while ( pApplicationPath != NULL )
    {
        hr = StampApplicationWithAppPool(
                    pMetabase, 
                    pApplicationPath
                    );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "StampApplicationWithAppPool() failed\n"
                ));

            goto exit;
        }


        pApplicationPath = pApplicationPaths->Next( pApplicationPath );
    }


exit:

    return hr;

}   // StampApplicationsWithAppPools



/***************************************************************************++

Routine Description:



Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pApplicationPaths - The metabase path to the application starting from
    IIS_MD_W3SVC.
    
Return Value:

    HRESULT

--***************************************************************************/

HRESULT
StampApplicationWithAppPool(
    IN MB * pMetabase,
    IN LPCWSTR pApplicationPath
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    DWORD AppIsolated = 0;
    LPWSTR AppPoolId = NULL;
    //
    // Buffer must be long enough to hold "IsolatedAppPool[number]".
    //
    WCHAR NewAppPoolId[ ( sizeof( APP_POOL_ISOLATED_PREFIX ) / sizeof( WCHAR ) ) + MAX_STRINGIZED_ULONG_CHAR_COUNT + 1 ];
    static ULONG NewAppPoolIdNumber = 1;            // note: static!
    

    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPath != NULL );


    //
    // Check if this is the application at lm/w3svc, i.e. "/"; if so,
    // ignore it.
    //

    if ( ( *pApplicationPath == L'/' ) && ( *( pApplicationPath + 1 ) == L'\0' ) )
    {
        goto exit;
    }


    //
    // Read the MD_APP_ISOLATED property for this application. This property
    // is required, and in fact it must exist since we got this
    // application path by querying for this same property earlier
    // (while under the same metabase read lock).
    //

    Success = pMetabase->GetDword(
                                pApplicationPath,
                                MD_APP_ISOLATED,
                                IIS_MD_UT_WAM,
                                &AppIsolated
                                );

    if ( ! Success )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // if the property wasn't present, something is screwy
        DBG_ASSERT( hr != MD_ERROR_DATA_NOT_FOUND );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading app isolated property of application failed\n"
            ));

        goto exit;

    }


    //
    // Determine which app pool to assign.
    //

    switch ( AppIsolated ) 
    {

    case 0:         // in-proc

        AppPoolId = APP_POOL_FORMERLY_INPROC;
        
        break;

    case 1:         // out-of-proc isolated

        //
        // Generate a unique new app pool id, and create that new app pool.
        //
        // Note that this approach is simple, but doesn't support running 
        // the tool again later very well (after the set of apps may have 
        // changed), as app pools may be orphaned, and custom-configured
        // isolated app pools may be reassigned to different apps.
        //
        // In the future, consider using the app path, package name, or app
        // friendly name to generate the app pool id.
        //
        
        _snwprintf( NewAppPoolId, sizeof( NewAppPoolId ) / sizeof ( WCHAR ), L"%s%lu", APP_POOL_ISOLATED_PREFIX, NewAppPoolIdNumber );


        hr = CreateAppPool( pMetabase, NewAppPoolId );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "CreateAppPool() failed\n"
                ));

            goto exit;
        }


        AppPoolId = NewAppPoolId;

        NewAppPoolIdNumber++;
        
        break;

    case 2:         // out-of-proc pooled

        AppPoolId = APP_POOL_FORMERLY_OUTOFPROCPOOLED;
        
        break;

    default:
    
        break;
            
    }


    //
    // Set the new property.
    //

    Success = pMetabase->SetString(
                                pApplicationPath,
                                MD_APP_APPPOOL,
                                IIS_MD_UT_WAM,
                                AppPoolId
                                );

    if ( ! Success )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting app pool property of application failed\n"
            ));

        goto exit;

    }


    printf( 
        "Stamped app at path: %S with new app pool id: %S\n", 
        pApplicationPath,
        AppPoolId
        );


exit:

    return hr;

}   // StampApplicationWithAppPool
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\asp.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asp.cxx
    
Abstract:

    ASP dumpers

Author:
    Andy Morrison    (andymorr)

Revision History:
    Rayner D'Souza   (raynerd)  9th-Aug-2001 
    Asp Template Information dump added.

--*/

#include "precomp.hxx"

typedef struct sOptions {
    BOOL    fGlobals;
    BOOL    fPerfCtrs;
    BOOL    fTemplate;
    PUCHAR  TemplateBlock;
} tOptions;

BOOL    GetOptions(char *lpArgumentString,  tOptions  *pOptions);
BOOL    PrintGlobals();
BOOL    PrintPerfCtrs();
BOOL    PrintTempl(tOptions *pOptions);
void     ByteAlignOffset ( DWORD*   pcbOffset,  DWORD    cbAlignment );


DWORD g_CountersDumped = 0;

DWORD ReadDWord( char *symbol,  DWORD  *pdwValue )
{
    ULONG_PTR dw = GetExpression( symbol );
    *pdwValue = 0;
                                                                
    if ( dw ) {
        if ( ReadMemory( dw,
                         pdwValue,
                         sizeof(DWORD),
                         NULL )) {
            return TRUE;
        }
        else {
            dprintf("Failed to read memory for (%s).\n",symbol);
            return FALSE;
        }
    }
    else {
        dprintf("Failed to find (%s).  Verify private symbols\n",symbol);
        return FALSE;
    }
}

#define DumpCounter(pdwCounters, counter)    dprintf("%-24s = %d\n",#counter , pdwCounters[counter])
#define DumpAspGlobalDWORD(global)          {  DWORD dw; ReadDWord("&asp!"#global, &dw); dprintf("%-26s = %lx\n", #global, dw); }
#define DumpAspGlobalDSPointer(global, clsName)    {  DWORD dw; ReadDWord("&asp!"#global, &dw); dprintf("%-26s = %p (dt asp!"#clsName" %p)\n",#global, dw, dw); }
#define DumpAspGlobalDS(global, clsName)    {  ULONG_PTR dw; dw = GetExpression("&asp!"#global); dprintf("%-26s = %p (dt asp!"#clsName" %p)\n",#global, dw, dw); }

#define PrintWord(symbol)   dprintf("%-26s = %d\n",#symbol,symbol);
#define PrintGUID(addr)     dprintf ("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",*((DWORD *)(addr)),\
                            *((USHORT*)(addr+4)),*((USHORT*)(addr+6)),*((BYTE *)(addr+8)),*((BYTE *) (addr+9)),\
                            *((BYTE*)(addr+10)),*((BYTE*)(addr+11)),*((BYTE*)(addr+12)),*((BYTE*)(addr+13)),\
                            *((BYTE*)(addr+14)),*((BYTE*)(addr+15)));
#define PrintDWord(addr,dw)   {ReadMemory(addr,&dw,sizeof(DWORD),NULL); dprintf("%ld",dw);}


DECLARE_API( asp )
{
    tOptions    options;

    memset(&options, 0, sizeof(tOptions));

    if (GetOptions((CHAR *)args, &options) == FALSE) {
        PrintUsage("asp");
        return;
    }

    if (options.fGlobals && (PrintGlobals() == FALSE))
        return;

    if (options.fPerfCtrs && (PrintPerfCtrs() == FALSE))
        return;

    if (options.fTemplate && (PrintTempl(&options) == FALSE))
        return;

    return;
}

BOOL    PrintGlobals()
{
    dprintf("==============================================\n");
    dprintf("  Flags\n");
    dprintf("==============================================\n");
    DumpAspGlobalDWORD(g_fShutDownInProgress);
    DumpAspGlobalDWORD(g_fInitStarted);

    dprintf("==============================================\n");
    dprintf("  Global Data Structures\n");
    dprintf("==============================================\n");
    DumpAspGlobalDSPointer(g_pDirMonitor,   CDirMonitor);
    DumpAspGlobalDS(g_PerfData,             CPerfData);
    DumpAspGlobalDS(g_PerfMain,             CPerfMainBlock);
    DumpAspGlobalDS(g_ViperReqMgr,          CViperReqManager);
    DumpAspGlobalDS(g_ApplnMgr,             CApplnMgr);
    DumpAspGlobalDS(g_ScriptManager,        CScriptManager);
    DumpAspGlobalDS(g_TemplateCache,        CTemplateCacheManager);
    DumpAspGlobalDS(g_ApplnCleanupMgr,      CApplnCleanupMgr);
    DumpAspGlobalDS(g_FileAppMap,           CFileApplicationMap);

    dprintf("==============================================\n");
    dprintf("  Global Counters\n");
    dprintf("==============================================\n");
    DumpAspGlobalDWORD(g_nApplications);
    DumpAspGlobalDWORD(g_nApplicationsRestarting);
    DumpAspGlobalDWORD(g_nApplicationsRestarted);
    DumpAspGlobalDWORD(g_nApplnCleanupRequests);
    DumpAspGlobalDWORD(g_nAppRestartThreads);
    DumpAspGlobalDWORD(g_nSessions);
    DumpAspGlobalDWORD(g_nSessionObjectsActive);
    DumpAspGlobalDWORD(g_nSessionCleanupRequests);
    DumpAspGlobalDWORD(g_nBrowserRequests);
    DumpAspGlobalDWORD(g_nViperRequests);
    DumpAspGlobalDWORD(g_nFlushThreads);
    
    

    return TRUE;
}

/* 
Template Structure.
    HERE IS HOW IT WORKS
    --------------------
    - an 'offset' is the count of bytes from start-of-template to a location
      within template memory
    - at the start of the template are 3 USHORTs, the counts of script blocks,
      object-infos and HTML blocks, respectively
    - next are 4 ULONGs, each an offset to a block of offsets; in order, these are:
        offset-to-offset to first script engine name
        offset-to-offset to first script block (the script text itself)
        offset-to-offset to first object-info
        offset-to-offset to first HTML block
    - next are a variable number of ULONGs, each an offset to a particular
      template component.  In order these ULONGs are:
        Offsets to                  Count of offsets
        ----------                  ----------------
        script engine names         cScriptBlocks
        script blocks               cScriptBlocks
        object-infos                cObjectInfos
        HTML blocks                 cHTMLBlocks
    - next are the template components themselves, stored sequentially
      in the following order:
        script engine names
        script blocks
        object-infos
        HTML blocks

    HERE IS HOW IT LOOKS
    --------------------
    |--|--|--|                      3 template component counts (USHORTs)

    |-- --|-- --|                   4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |

    or, mnemonically:

     cS cO cH                       3 template component counts (USHORTs)

     offSE offSB offOb offHT        4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |

    =======================================================================
    The code first reads the 24Byte header. Calculates number of blocks available.
    It then reads the offset to offset table into memory. This gives it almost all the information it needs.
    Finally, it reads selected portions of the script Engine names and Object Infos to spew out interesting information.
    For all other cases (Script Blocks and HTML Blocks), it simply prints out the offset such that it could be copied to 
    dump relevant information.

*/
BOOL    PrintTempl(tOptions *pOptions)
{    
    DWORD i;
    dprintf ("=================================\n");  
    dprintf ("Printing ASP Template contents \n"); 
    dprintf ("=================================\n");  
    
    BYTE        TemplDataMem[sizeof(CTemplate)];
    CTemplate   *pLocalTempl = (CTemplate *) TemplDataMem;
    BYTE        *pHeader;  

    // Read the template Structure into memory.
    if (!ReadMemory ((ULONG_PTR)pOptions->TemplateBlock, pLocalTempl, sizeof(CTemplate), NULL))
    {
        dprintf ("asp!CTemplate not Found. Verify private symbols are loaded\n");
        return FALSE;
    }

    // Calculate amount of memory require to store the basic headers. 
    DWORD    cbRequiredHeader = (C_COUNTS_IN_HEADER * sizeof(USHORT)) + (C_OFFOFFS_IN_HEADER * sizeof(DWORD)); 
    
    pHeader = new BYTE[cbRequiredHeader];
    if (!pHeader) 
        return FALSE;

    // Print the raw starting point for those who want it 'vanilla'/plain.
    dprintf ("%-26s = (dc %p L %lX)\n","Start of Template dump", pLocalTempl->m_pbStart, (pLocalTempl->m_cbTemplate +3)/4);

    // Read the header
    if (!ReadMemory ((ULONG_PTR)pLocalTempl->m_pbStart,   pHeader,   cbRequiredHeader,  NULL))
    {
        DWORD err = GetLastError ();
        delete[] pHeader;
        dprintf ("ERROR (%ld) while reading CTemplate->m_pbStart\n",err);
        return FALSE;
    }
    
    // Save those in local variables.
    USHORT cScriptBlocks = (USHORT) *(pHeader);
    USHORT cObjectInfos = (USHORT) *(pHeader+2);
    USHORT cHTMLBlocks = (USHORT) *(pHeader+4);

    USHORT cBlockPtrs       = (2 * cScriptBlocks) + cObjectInfos + cHTMLBlocks;
    // Required to calculate what to read and what not to.
    DWORD OffsetToScriptEngineNames = (DWORD) *((DWORD *)(pHeader +8));
    DWORD OffsetToScriptBlocks= (DWORD) *((DWORD *)(pHeader +12));
    DWORD OffsetToObjectInfos= (DWORD) *((DWORD*)(pHeader +16));
    DWORD OffsetToHTMLBlocks= (DWORD) *((DWORD*)(pHeader +20));
    
    // Print out the metrics based on the counters.
    PrintWord (cScriptBlocks);
    PrintWord (cObjectInfos);
    PrintWord (cHTMLBlocks);

    // Dispose off as soon as you dont need memory. (Less chance of a memory leak)
    delete[] pHeader;    
    
    BYTE *pOffsetToOffset =  new BYTE[cBlockPtrs * sizeof(DWORD)];
    if (!pOffsetToOffset) 
        return FALSE;    
    
    // Read the OffsetTable.
    if (!ReadMemory ((ULONG_PTR)pLocalTempl->m_pbStart+cbRequiredHeader, pOffsetToOffset, cBlockPtrs * sizeof(DWORD),NULL))
    {
        DWORD err = GetLastError ();
        delete[] pOffsetToOffset;
        dprintf (" ERROR (%ld) while reading OffsetTable\n",err);        
        return FALSE;
    }

    // Process Script Blocks
    if (cScriptBlocks)
    {
        // Calculate and allocate the number of bytes to read.
        DWORD  BytesToRead = *((DWORD *)(pOffsetToOffset + (cScriptBlocks * sizeof(DWORD)))) - *((DWORD *)pOffsetToOffset);

        // Allocate memory
        BYTE *pScriptBlocks = new BYTE [BytesToRead];
        if (!pScriptBlocks)
        {
            delete[] pOffsetToOffset;
            dprintf ("ERROR Allocating memory for ScriptEngineNames");
            return FALSE;
        }

        // Read block containing the script engine names
        if (!ReadMemory ((ULONG_PTR)pLocalTempl->m_pbStart + *((DWORD *)pOffsetToOffset),  pScriptBlocks,  BytesToRead,
                                NULL))
        {
            // Failure..release all outstanding memory
            DWORD err = GetLastError ();
            delete[] pOffsetToOffset;
            delete[] pScriptBlocks;
            dprintf ("ERROR %ld while reading memory for ScriptEngine Names",err);
            return FALSE;
        }

        // Memory is in...spew out the contents.
        dprintf ("\n=================================\n");  
        dprintf ("Script Engine Names\n");
        dprintf ("index : Script Engine Name : PROGLANG_ID\n");
        dprintf ("=================================\n");  
        DWORD trav = 0;        
        for (i=0;i<cScriptBlocks;i++)
        {           
            //Read the size of BSTR
            DWORD BstrSize = *((DWORD*) (pScriptBlocks  + trav));
            trav += sizeof (DWORD);
            dprintf ("ScriptEngine[%d] : %s :",i,((char *)(pScriptBlocks + trav)));
            trav += BstrSize+ 1; // string Trem '\0' + byte alignment.
            ByteAlignOffset (&trav, sizeof(DWORD));
            PrintGUID(pScriptBlocks+trav);
            trav += sizeof(PROGLANG_ID);          //4 due to byte alignment
            dprintf ("\n");
        }

        //We are done with the pScriptBlocks.. release them
        delete[] pScriptBlocks;

        // Print out the pointers in such a way that they are easy to use in the debugger
        dprintf ("\n=================================\n");  
        dprintf ("Script Blocks\n");
        dprintf ("Index : Size of Block : Location of Block \n");
        dprintf ("=================================\n");  
        // Technically we would require to read the memory to get the lenghts of each block. 
        // But we will use a small hack here..Use the differences in offsets instead.        
        for (i=0;i<cScriptBlocks;i++)
        {
            DWORD sizeOfBlock;
            dprintf ("ScriptBlock[%d] : ",i);
            PrintDWord ((ULONG_PTR)pLocalTempl->m_pbStart + *((DWORD *)(pOffsetToOffset + (cScriptBlocks+i) * sizeof(DWORD))), sizeOfBlock);
            dprintf (": (du %p L %lX)\n",pLocalTempl->m_pbStart + *((DWORD *)(pOffsetToOffset + (cScriptBlocks+i) * sizeof(DWORD)))+sizeof(DWORD), sizeOfBlock/2);
        }
    }

    // Process object Infos
    if (cObjectInfos)
    {
        // Calculate the number of bytes to read.
        DWORD LastByteOnOffsets;
        if (cHTMLBlocks)
            LastByteOnOffsets = *((DWORD *)(pOffsetToOffset + ((cScriptBlocks *2)+ cObjectInfos)*sizeof(DWORD))); 
        else
            LastByteOnOffsets = pLocalTempl->m_cbTemplate ;

        DWORD BytesToRead = LastByteOnOffsets - *((DWORD *)(pOffsetToOffset + (cScriptBlocks *2)*sizeof(DWORD)));

        // Allocate BytesToRead
        BYTE *pObjectInfos = new BYTE [BytesToRead];
        if (!pObjectInfos)
        {
            dprintf ("ERROR : Cannot Allocate enough memory for Object Infos\n");
            delete[] pOffsetToOffset;
            return FALSE;
        }

        // Read block containing the Object Infos
        if (!ReadMemory ((ULONG_PTR)pLocalTempl->m_pbStart + *((DWORD *)(pOffsetToOffset + (cScriptBlocks *2)*sizeof(DWORD))),  
                                pObjectInfos,  BytesToRead,  NULL))
        {
            // Failure..release all outstanding memory
            DWORD err = GetLastError ();
            delete[] pOffsetToOffset;
            delete[] pObjectInfos;
            dprintf ("ERROR %ld while reading memory for Object Infos",err);
            return FALSE;
        }

        // Spew Contents
        dprintf ("\n=================================\n");  
        dprintf ("Object Infos\n");
        dprintf ("Index : ObjectName : CLSID : CompScope : CompModel \n");
        dprintf ("=================================\n");  
        DWORD trav = 0;
        for (i=0;i<cObjectInfos;i++)
        {    
            DWORD BstrSize = *((DWORD *)(pObjectInfos + trav));
            trav+= sizeof(ULONG);
            dprintf ("ObjectInfo[%d] : %s :",i,((char*)(pObjectInfos + trav)));
            trav += BstrSize + 1;       // terminating \0 + byte alignment
            ByteAlignOffset (&trav, sizeof(DWORD));            
            PrintGUID (pObjectInfos+trav);

            DWORD compScope = *((DWORD *)(pObjectInfos + trav+16));
            DWORD compModel = *((DWORD *)(pObjectInfos + trav+20));

            dprintf (" : ");
            // Print out the appropriate name of the Bit Field.
            if (compScope)
            {
                if (compScope & 0x00000001) 
                    dprintf (" csAppln ");
                if (compScope & 0x00000002) 
                    dprintf (" csSession ");
                if (compScope & 0x00000004) 
                    dprintf (" csPage ");
            }
            else 
                dprintf (" csUnknown ");
            
            dprintf (" : ");

            // Print out the appropriate name of the Bit Field.
            if (compModel)
            {
                if (compScope & 0x00000001) 
                    dprintf (" cmSingle ");
                if (compScope & 0x00000002) 
                    dprintf (" cmApartment ");
                if (compScope & 0x00000004) 
                    dprintf (" cmFree ");       
                if (compModel & 0x00000008)
                    dprintf (" cmBoth ");
            }
            else
                dprintf ("cmUnknown");

            dprintf ("\n");

            trav += 24; // size of CLSID + DWORD + DWORD;            
        }
        delete[] pObjectInfos;
    }

    // Process HTML Blocks
    if (cHTMLBlocks)
    {    
        dprintf ("\n=================================\n");  
        dprintf ("HTML Blocks\n");
        dprintf ("Index : Size of Block : Location of Block \n");
        dprintf ("=================================\n");  
        for (i=0;i<cHTMLBlocks;i++)
        {
            DWORD sizeOfBlock;
            dprintf ("HTMLBlock[%d] : ",i);
            PrintDWord ((ULONG_PTR)pLocalTempl->m_pbStart +  *((DWORD *)(pOffsetToOffset + (cScriptBlocks*2+cObjectInfos+i)*sizeof(DWORD))),sizeOfBlock);
            dprintf (" : (db %p L %lX)\n",pLocalTempl->m_pbStart +  *((DWORD *)(pOffsetToOffset + 
                                (cScriptBlocks*2+cObjectInfos+i)*sizeof(DWORD)))+sizeof(DWORD),sizeOfBlock);
        }
    }

    //done with everything..this is the only memory still lying around. 
    delete[] pOffsetToOffset;
    dprintf ("\n\n");                    
    
    return TRUE;    
}

/*===================================================================
    ByteAlignOffset
    Byte-aligns an offset value, based on size of source data
*/
void
ByteAlignOffset
(
DWORD*   pcbOffset,      // ptr to offset value
DWORD    cbAlignment // Alignment boundary
)
    {
        if (cbAlignment > 0)
        {
            --cbAlignment;
            if (*pcbOffset & cbAlignment)
                *pcbOffset = (*pcbOffset + cbAlignment + 1) & ~cbAlignment;
        }
    }

BOOL    PrintPerfCtrs()
{

    CPerfData           *pPerfData = (CPerfData *)GetExpression( "&asp!g_PerfData");

    BYTE                perfDataMem[sizeof(CPerfData)];
    CPerfData           *pLocalPerfData = (CPerfData *)perfDataMem;

    BYTE                perfBlockMem[sizeof(CPerfData)];
    CPerfProcBlockData  *pLocalPerfBlockData = (CPerfProcBlockData *)perfBlockMem;

    dprintf("Printing ASP Perf counters\n");

    if (pPerfData == NULL) {
        dprintf("asp!g_PerfData not found.  Verify private symbols are loaded\n");
        return FALSE;
    }

    if( !ReadMemory((ULONG_PTR)pPerfData, 
                    pLocalPerfData,
                    sizeof(CPerfData),
                    NULL)) {    
        dprintf("error reading CPerfData\n");
        return FALSE;
    }

    DWORD   *pdwCounters = pLocalPerfData->m_rgdwInitCounters;

    if (pLocalPerfData->m_fInited) {

        dprintf("PerfCounters inited\n\n");

        if ( !ReadMemory((ULONG_PTR)pLocalPerfData->m_pData,
                         pLocalPerfBlockData,
                         sizeof(CPerfProcBlockData),
                         NULL)) {
            dprintf("error reading CPerfData\n");
            return FALSE;
        }

        pdwCounters = pLocalPerfBlockData->m_rgdwCounters;
    }
    else {
    
        dprintf("WARNING!  PerfCounters not inited\n\n");
    }

    DumpCounter(pdwCounters, ID_DEBUGDOCREQ       );
    DumpCounter(pdwCounters, ID_REQERRRUNTIME     );
    DumpCounter(pdwCounters, ID_REQERRPREPROC     );
    DumpCounter(pdwCounters, ID_REQERRCOMPILE     );
    DumpCounter(pdwCounters, ID_REQERRORPERSEC    );
    DumpCounter(pdwCounters, ID_REQTOTALBYTEIN    );
    DumpCounter(pdwCounters, ID_REQTOTALBYTEOUT   );
    DumpCounter(pdwCounters, ID_REQEXECTIME       );
    DumpCounter(pdwCounters, ID_REQWAITTIME       );
    DumpCounter(pdwCounters, ID_REQCOMFAILED      );
    DumpCounter(pdwCounters, ID_REQBROWSEREXEC    );
    DumpCounter(pdwCounters, ID_REQFAILED         );
    DumpCounter(pdwCounters, ID_REQNOTAUTH        );
    DumpCounter(pdwCounters, ID_REQNOTFOUND       );
    DumpCounter(pdwCounters, ID_REQCURRENT        );
    DumpCounter(pdwCounters, ID_REQREJECTED       );
    DumpCounter(pdwCounters, ID_REQSUCCEEDED      );
    DumpCounter(pdwCounters, ID_REQTIMEOUT        );
    DumpCounter(pdwCounters, ID_REQTOTAL          );
    DumpCounter(pdwCounters, ID_REQPERSEC         );
    DumpCounter(pdwCounters, ID_SCRIPTFREEENG     );
    DumpCounter(pdwCounters, ID_SESSIONLIFETIME   );
    DumpCounter(pdwCounters, ID_SESSIONCURRENT    );
    DumpCounter(pdwCounters, ID_SESSIONTIMEOUT    );
    DumpCounter(pdwCounters, ID_SESSIONSTOTAL     );
    DumpCounter(pdwCounters, ID_TEMPLCACHE        );
    DumpCounter(pdwCounters, ID_TEMPLCACHEHITS    );
    DumpCounter(pdwCounters, ID_TEMPLCACHETRYS    );
    DumpCounter(pdwCounters, ID_TEMPLFLUSHES      );
    DumpCounter(pdwCounters, ID_TRANSABORTED      );
    DumpCounter(pdwCounters, ID_TRANSCOMMIT       );
    DumpCounter(pdwCounters, ID_TRANSPENDING      );
    DumpCounter(pdwCounters, ID_TRANSTOTAL        );
    DumpCounter(pdwCounters, ID_TRANSPERSEC       );
    DumpCounter(pdwCounters, ID_MEMORYTEMPLCACHE  );
    DumpCounter(pdwCounters, ID_MEMORYTEMPLCACHEHITS );
    DumpCounter(pdwCounters, ID_MEMORYTEMPLCACHETRYS );
	DumpCounter(pdwCounters, ID_ENGINECACHEHITS		);
	DumpCounter(pdwCounters, ID_ENGINECACHETRYS		);
	DumpCounter(pdwCounters, ID_ENGINEFLUSHES		);

    return TRUE;
}

BOOL    GetOptions(char         *lpArgumentString,
                   tOptions     *pOptions)
{
    BOOL    bOptionFound = FALSE;

    //
    // Interpret the command-line switch.
    //

    while (*lpArgumentString) {

        // skip any whitespace to get to the next argument

        while(isspace(*lpArgumentString))
            lpArgumentString++;

        // break if we hit the NULL terminator

        if (*lpArgumentString == '\0')
            break;

        // should be pointing to a '-' char

//        if (*lpArgumentString != '-') {
//            return FALSE;
//        }

        // Advance to option letter

        lpArgumentString++;

        // save the option letter

        char cOption = *lpArgumentString;

        // advance past the option letter

        lpArgumentString++;

        // note that at least one option was found

        bOptionFound = TRUE;

        switch( cOption ) {

            case 'g' :
            case 'G' :
                pOptions->fGlobals = TRUE;
                break;

            case 'p' :
            case 'P':
                pOptions->fPerfCtrs = TRUE;
                break;

            case 't':
            case 'T':
                pOptions->fTemplate = TRUE;
                sscanf(lpArgumentString, "%p", &pOptions->TemplateBlock);
                break;
            default :
                break;
//                return FALSE;
        }

        // move past the current argument

        while ((*lpArgumentString != ' ') 
               && (*lpArgumentString != '\t') 
               && (*lpArgumentString != '\0')) {
            lpArgumentString++;
        }
    }

    if (bOptionFound == FALSE) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\acache.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    acache.cxx
    
Abstract:

    ALLOC_CACHE_HANDLER dumpers

Author:

Revision History:

--*/

#include "precomp.hxx"

/************************************************************
 * Allocation cache Related functions
 ************************************************************/

IRTL_DLLEXP
ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig,
    IN BOOL  fEnableCleanupAsserts)
{}

IRTL_DLLEXP
ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{}


VOID
PrintAcacheHandler( IN ALLOC_CACHE_HANDLER * pachDebuggee,
                    IN ALLOC_CACHE_HANDLER * pachDebugger,
                    IN CHAR chVerbostity);

VOID
DumpAcacheGlobals( VOID );


VOID
DumpAcacheList(
    CHAR Verbosity
    );


DECLARE_API( acache )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    BOOL          fRet;
    ALLOC_CACHE_HANDLER * pach;

    //
    // Since ALLOC_CACHE_HANDLER is a C++ object with a non-void
    //  constructor, we will have to copy the contents to a temporary
    //  buffer and cast the value appropriately.
    //
    CHAR                 achItem[sizeof(ALLOC_CACHE_HANDLER)];
    ALLOC_CACHE_HANDLER * pachCopy = (ALLOC_CACHE_HANDLER *) achItem;

    while (*args == ' ')
        args++;

    if ( !*args )
    {
        PrintUsage( "acache" );
        return;
    }

    if ( *args == '-' )
    {
        args++;

        if ( *args == 'h' )
        {
            PrintUsage( "acache" );
            return;
        }

        if ( *args == 'g' )
        {
            DumpAcacheGlobals();
            return;
        }

        if ( *args == 'l' ) {

            DumpAcacheList( args[1] );
            return;
        }

    } // while

    //
    //  Treat the argument as the address of an AtqContext
    //

    dprintf( "inetdbg.acache: Trying to access %s\n",
             args );

    pach = (ALLOC_CACHE_HANDLER * ) GetExpression( args );

    if ( !pach )
    {
        dprintf( "inetdbg.acache: Unable to evaluate \"%s\"\n",
                 args );

        return;
    }

    moveBlock(achItem, (ULONG_PTR)pach, sizeof(ALLOC_CACHE_HANDLER));
    PrintAcacheHandler( pach, pachCopy, '2' );

    return;
} // DECLARE_API( acache )


VOID
PrintAcacheHandler( ALLOC_CACHE_HANDLER * pachDebuggee,
                    ALLOC_CACHE_HANDLER * pachDebugger,
                    CHAR  chVerbosity)
{
    if ( chVerbosity >= '0') {
        dprintf(
                "ACACHE[%8p] "
                , pachDebuggee
                );
        dstring( "Name", (PVOID) pachDebugger->m_pszName, 40);
    }

    if ( chVerbosity >= '1') {
        dprintf("\t(Size=%d bytes, Concurrency=%d, Threshold=%u)"
                " FillPattern=%08lX\n"
                "\tTotal=%d."
                " Calls:(Alloc=%d, Free=%d)"
                " FreeEntries=%d. Heap=%p\n"
                ,
                pachDebugger->m_acConfig.cbSize,
                pachDebugger->m_acConfig.nConcurrency,
                pachDebugger->m_acConfig.nThreshold,
                pachDebugger->m_nFillPattern,
                pachDebugger->m_nTotal,
                pachDebugger->m_nAllocCalls, pachDebugger->m_nFreeCalls,
                pachDebugger->m_nFreeEntries, pachDebugger->m_hHeap
                );
    }

    return;
} // PrintAcacheHandler()

VOID
PrintAcacheHandlerThunk( PVOID pachDebuggee,
                         PVOID pachDebugger,
                         CHAR  chVerbosity,
                         DWORD iCount)
{
    dprintf( "[%d] ", iCount);
    PrintAcacheHandler( (ALLOC_CACHE_HANDLER *) pachDebuggee,
                        (ALLOC_CACHE_HANDLER *) pachDebugger,
                        chVerbosity);
    return;
} // PrintAcacheHandlerThunk()

VOID
DumpAcacheGlobals( VOID )
{
    LIST_ENTRY * pachList;
    LIST_ENTRY   achList;

    dprintf("Allocation Cache Globals:\n");

    pachList = (LIST_ENTRY *)
        GetExpression( "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");

    if ( NULL == pachList) {

        dprintf( " Unable to get Allocation cache list object, %s\n",
                 "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");
        return;
    }

    move(achList, (ULONG_PTR)pachList);

    dprintf( " AllocCacheList  Flink = %08p  Blink = %08p\n",
             achList.Flink, achList.Blink
             );

    dprintf("\tsizeof(ALLOC_CACHE_HANDLER) = %d\n",
            sizeof(ALLOC_CACHE_HANDLER));
    return;
} // DumpAcacheGlobals()




VOID
DumpAcacheList(
    CHAR Verbosity
    )
{
    LIST_ENTRY *         pachListHead;

    pachListHead = (LIST_ENTRY *)
        GetExpression( "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");

    if ( NULL == pachListHead) {

        dprintf( " Unable to get Alloc Cache List object, %s\n",
                 "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");
        return;
    }

    EnumLinkedList( pachListHead, PrintAcacheHandlerThunk, Verbosity,
                    sizeof( ALLOC_CACHE_HANDLER),
                    FIELD_OFFSET( ALLOC_CACHE_HANDLER, m_lItemsEntry)
                    );
    return;
} // DumpAcacheList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\w3control\precomp.h ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        21-Feb-2000

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

extern "C" {

//
// System include files.
//

// ensure that all GUIDs are initialized
#define INITGUID

// main project include
#include <iis.h>

// other standard includes
#include <stdio.h>
#include <stdlib.h>

// other project includes
#include <dbgutil.h>
#include <w3ctrlps.h>



//
// Local prototypes.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    );

}   // extern "C"

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Version 5.0 (using 32-bit types)
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned short	_2BYTEPAD;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_RESERVED   3L  // All signatures from 3 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))




// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types


#define T_NOTYPE        0x0000      // uncharacterized type (no type)
#define T_ABS           0x0001      // absolute symbol
#define T_SEGMENT       0x0002      // segment type
#define T_VOID          0x0003      // void
#define T_PVOID         0x0103      // near pointer to void
#define T_PFVOID        0x0203      // far pointer to void
#define T_PHVOID        0x0303      // huge pointer to void
#define T_32PVOID       0x0403      // 16:32 near pointer to void
#define T_32PFVOID      0x0503      // 16:32 far pointer to void
#define T_64PVOID       0x0603      // 64 bit pointer to void
#define T_CURRENCY      0x0004      // BASIC 8 byte currency value
#define T_NBASICSTR     0x0005      // Near BASIC string
#define T_FBASICSTR     0x0006      // Far BASIC string
#define T_NOTTRANS      0x0007      // type not translated by cvpack
#define T_BIT           0x0060      // bit
#define T_PASCHAR       0x0061      // Pascal CHAR



//      Character types


#define T_CHAR          0x0010      // 8 bit signed
#define T_UCHAR         0x0020      // 8 bit unsigned
#define T_PCHAR         0x0110      // near pointer to 8 bit signed
#define T_PUCHAR        0x0120      // near pointer to 8 bit unsigned
#define T_PFCHAR        0x0210      // far pointer to 8 bit signed
#define T_PFUCHAR       0x0220      // far pointer to 8 bit unsigned
#define T_PHCHAR        0x0310      // huge pointer to 8 bit signed
#define T_PHUCHAR       0x0320      // huge pointer to 8 bit unsigned
#define T_32PCHAR       0x0410      // 16:32 near pointer to 8 bit signed
#define T_32PUCHAR      0x0420      // 16:32 near pointer to 8 bit unsigned
#define T_32PFCHAR      0x0510      // 16:32 far pointer to 8 bit signed
#define T_32PFUCHAR     0x0520      // 16:32 far pointer to 8 bit unsigned
#define T_64PCHAR       0X0610      // 64 bit pointer to 8 bit signed
#define T_64PUCHAR      0X0620      // 64 bit pointer to 8 bit unsigned




//      really a character types

#define T_RCHAR         0x0070      // really a char
#define T_PRCHAR        0x0170      // 16:16 near pointer to a real char
#define T_PFRCHAR       0x0270      // 16:16 far pointer to a real char
#define T_PHRCHAR       0x0370      // 16:16 huge pointer to a real char
#define T_32PRCHAR      0x0470      // 16:32 near pointer to a real char
#define T_32PFRCHAR     0x0570      // 16:32 far pointer to a real char
#define T_64PRCHAR      0x0670      // 64 bit pointer to a real char



//      really a wide character types

#define T_WCHAR         0x0071      // wide char
#define T_PWCHAR        0x0171      // 16:16 near pointer to a wide char
#define T_PFWCHAR       0x0271      // 16:16 far pointer to a wide char
#define T_PHWCHAR       0x0371      // 16:16 huge pointer to a wide char
#define T_32PWCHAR      0x0471      // 16:32 near pointer to a wide char
#define T_32PFWCHAR     0x0571      // 16:32 far pointer to a wide char
#define T_64PWCHAR      0x0671      // 64 bit pointer to a wide char


//      8 bit int types


#define T_INT1          0x0068      // 8 bit signed int
#define T_UINT1         0x0069      // 8 bit unsigned int
#define T_PINT1         0x0168      // near pointer to 8 bit signed int
#define T_PUINT1        0x0169      // near pointer to 8 bit unsigned int
#define T_PFINT1        0x0268      // far pointer to 8 bit signed int
#define T_PFUINT1       0x0269      // far pointer to 8 bit unsigned int
#define T_PHINT1        0x0368      // huge pointer to 8 bit signed int
#define T_PHUINT1       0x0369      // huge pointer to 8 bit unsigned int

#define T_32PINT1       0x0468      // 16:32 near pointer to 8 bit signed int
#define T_32PUINT1      0x0469      // 16:32 near pointer to 8 bit unsigned int
#define T_32PFINT1      0x0568      // 16:32 far pointer to 8 bit signed int
#define T_32PFUINT1     0x0569      // 16:32 far pointer to 8 bit unsigned int
#define T_64PINT1       0x0668      // 64 bit pointer to 8 bit signed int
#define T_64PUINT1      0x0669      // 64 bit pointer to 8 bit unsigned int


//      16 bit short types


#define T_SHORT         0x0011      // 16 bit signed
#define T_USHORT        0x0021      // 16 bit unsigned
#define T_PSHORT        0x0111      // near pointer to 16 bit signed
#define T_PUSHORT       0x0121      // near pointer to 16 bit unsigned
#define T_PFSHORT       0x0211      // far pointer to 16 bit signed
#define T_PFUSHORT      0x0221      // far pointer to 16 bit unsigned
#define T_PHSHORT       0x0311      // huge pointer to 16 bit signed
#define T_PHUSHORT      0x0321      // huge pointer to 16 bit unsigned

#define T_32PSHORT      0x0411      // 16:32 near pointer to 16 bit signed
#define T_32PUSHORT     0x0421      // 16:32 near pointer to 16 bit unsigned
#define T_32PFSHORT     0x0511      // 16:32 far pointer to 16 bit signed
#define T_32PFUSHORT    0x0521      // 16:32 far pointer to 16 bit unsigned
#define T_64PSHORT      0x0611      // 64 bit pointer to 16 bit signed
#define T_64PUSHORT     0x0621      // 64 bit pointer to 16 bit unsigned




//      16 bit int types


#define T_INT2          0x0072      // 16 bit signed int
#define T_UINT2         0x0073      // 16 bit unsigned int
#define T_PINT2         0x0172      // near pointer to 16 bit signed int
#define T_PUINT2        0x0173      // near pointer to 16 bit unsigned int
#define T_PFINT2        0x0272      // far pointer to 16 bit signed int
#define T_PFUINT2       0x0273      // far pointer to 16 bit unsigned int
#define T_PHINT2        0x0372      // huge pointer to 16 bit signed int
#define T_PHUINT2       0x0373      // huge pointer to 16 bit unsigned int

#define T_32PINT2       0x0472      // 16:32 near pointer to 16 bit signed int
#define T_32PUINT2      0x0473      // 16:32 near pointer to 16 bit unsigned int
#define T_32PFINT2      0x0572      // 16:32 far pointer to 16 bit signed int
#define T_32PFUINT2     0x0573      // 16:32 far pointer to 16 bit unsigned int
#define T_64PINT2       0x0672      // 64 bit pointer to 16 bit signed int
#define T_64PUINT2      0x0673      // 64 bit pointer to 16 bit unsigned int




//      32 bit long types


#define T_LONG          0x0012      // 32 bit signed
#define T_ULONG         0x0022      // 32 bit unsigned
#define T_PLONG         0x0112      // near pointer to 32 bit signed
#define T_PULONG        0x0122      // near pointer to 32 bit unsigned
#define T_PFLONG        0x0212      // far pointer to 32 bit signed
#define T_PFULONG       0x0222      // far pointer to 32 bit unsigned
#define T_PHLONG        0x0312      // huge pointer to 32 bit signed
#define T_PHULONG       0x0322      // huge pointer to 32 bit unsigned

#define T_32PLONG       0x0412      // 16:32 near pointer to 32 bit signed
#define T_32PULONG      0x0422      // 16:32 near pointer to 32 bit unsigned
#define T_32PFLONG      0x0512      // 16:32 far pointer to 32 bit signed
#define T_32PFULONG     0x0522      // 16:32 far pointer to 32 bit unsigned
#define T_64PLONG       0x0612      // 64 bit pointer to 32 bit signed
#define T_64PULONG      0x0622      // 64 bit pointer to 32 bit unsigned




//      32 bit int types


#define T_INT4          0x0074      // 32 bit signed int
#define T_UINT4         0x0075      // 32 bit unsigned int
#define T_PINT4         0x0174      // near pointer to 32 bit signed int
#define T_PUINT4        0x0175      // near pointer to 32 bit unsigned int
#define T_PFINT4        0x0274      // far pointer to 32 bit signed int
#define T_PFUINT4       0x0275      // far pointer to 32 bit unsigned int
#define T_PHINT4        0x0374      // huge pointer to 32 bit signed int
#define T_PHUINT4       0x0375      // huge pointer to 32 bit unsigned int

#define T_32PINT4       0x0474      // 16:32 near pointer to 32 bit signed int
#define T_32PUINT4      0x0475      // 16:32 near pointer to 32 bit unsigned int
#define T_32PFINT4      0x0574      // 16:32 far pointer to 32 bit signed int
#define T_32PFUINT4     0x0575      // 16:32 far pointer to 32 bit unsigned int
#define T_64PINT4       0x0674      // 64 bit pointer to 32 bit signed int
#define T_64PUINT4      0x0675      // 64 bit pointer to 32 bit unsigned int




//      64 bit quad types


#define T_QUAD          0x0013      // 64 bit signed
#define T_UQUAD         0x0023      // 64 bit unsigned
#define T_PQUAD         0x0113      // near pointer to 64 bit signed
#define T_PUQUAD        0x0123      // near pointer to 64 bit unsigned
#define T_PFQUAD        0x0213      // far pointer to 64 bit signed
#define T_PFUQUAD       0x0223      // far pointer to 64 bit unsigned
#define T_PHQUAD        0x0313      // huge pointer to 64 bit signed
#define T_PHUQUAD       0x0323      // huge pointer to 64 bit unsigned
#define T_32PQUAD       0x0413      // 16:32 near pointer to 64 bit signed
#define T_32PUQUAD      0x0423      // 16:32 near pointer to 64 bit unsigned
#define T_32PFQUAD      0x0513      // 16:32 far pointer to 64 bit signed
#define T_32PFUQUAD     0x0523      // 16:32 far pointer to 64 bit unsigned
#define T_64PQUAD       0x0613      // 64 bit pointer to 64 bit signed
#define T_64PUQUAD      0x0623      // 64 bit pointer to 64 bit unsigned



//      64 bit int types


#define T_INT8          0x0076      // 64 bit signed int
#define T_UINT8         0x0077      // 64 bit unsigned int
#define T_PINT8         0x0176      // near pointer to 64 bit signed int
#define T_PUINT8        0x0177      // near pointer to 64 bit unsigned int
#define T_PFINT8        0x0276      // far pointer to 64 bit signed int
#define T_PFUINT8       0x0277      // far pointer to 64 bit unsigned int
#define T_PHINT8        0x0376      // huge pointer to 64 bit signed int
#define T_PHUINT8       0x0377      // huge pointer to 64 bit unsigned int

#define T_32PINT8       0x0476      // 16:32 near pointer to 64 bit signed int
#define T_32PUINT8      0x0477      // 16:32 near pointer to 64 bit unsigned int
#define T_32PFINT8      0x0576      // 16:32 far pointer to 64 bit signed int
#define T_32PFUINT8     0x0577      // 16:32 far pointer to 64 bit unsigned int
#define T_64PINT8       0x0676      // 64 bit pointer to 64 bit signed int
#define T_64PUINT8      0x0677      // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types


#define T_OCT           0x0014      // 128 bit signed
#define T_UOCT          0x0024      // 128 bit unsigned
#define T_POCT          0x0114      // near pointer to 128 bit signed
#define T_PUOCT         0x0124      // near pointer to 128 bit unsigned
#define T_PFOCT         0x0214      // far pointer to 128 bit signed
#define T_PFUOCT        0x0224      // far pointer to 128 bit unsigned
#define T_PHOCT         0x0314      // huge pointer to 128 bit signed
#define T_PHUOCT        0x0324      // huge pointer to 128 bit unsigned

#define T_32POCT        0x0414      // 16:32 near pointer to 128 bit signed
#define T_32PUOCT       0x0424      // 16:32 near pointer to 128 bit unsigned
#define T_32PFOCT       0x0514      // 16:32 far pointer to 128 bit signed
#define T_32PFUOCT      0x0524      // 16:32 far pointer to 128 bit unsigned
#define T_64POCT        0x0614      // 64 bit pointer to 128 bit signed
#define T_64PUOCT       0x0624      // 64 bit pointer to 128 bit unsigned

//      128 bit int types


#define T_INT16         0x0078      // 128 bit signed int
#define T_UINT16        0x0079      // 128 bit unsigned int
#define T_PINT16        0x0178      // near pointer to 128 bit signed int
#define T_PUINT16       0x0179      // near pointer to 128 bit unsigned int
#define T_PFINT16       0x0278      // far pointer to 128 bit signed int
#define T_PFUINT16      0x0279      // far pointer to 128 bit unsigned int
#define T_PHINT16       0x0378      // huge pointer to 128 bit signed int
#define T_PHUINT16      0x0379      // huge pointer to 128 bit unsigned int

#define T_32PINT16      0x0478      // 16:32 near pointer to 128 bit signed int
#define T_32PUINT16     0x0479      // 16:32 near pointer to 128 bit unsigned int
#define T_32PFINT16     0x0578      // 16:32 far pointer to 128 bit signed int
#define T_32PFUINT16    0x0579      // 16:32 far pointer to 128 bit unsigned int
#define T_64PINT16      0x0678      // 64 bit pointer to 128 bit signed int
#define T_64PUINT16     0x0679      // 64 bit pointer to 128 bit unsigned int





//      32 bit real types


#define T_REAL32        0x0040      // 32 bit real
#define T_PREAL32       0x0140      // near pointer to 32 bit real
#define T_PFREAL32      0x0240      // far pointer to 32 bit real
#define T_PHREAL32      0x0340      // huge pointer to 32 bit real
#define T_32PREAL32     0x0440      // 16:32 near pointer to 32 bit real
#define T_32PFREAL32    0x0540      // 16:32 far pointer to 32 bit real
#define T_64PREAL32     0x0640      // 64 bit pointer to 32 bit real



//      48 bit real types


#define T_REAL48        0x0044      // 48 bit real
#define T_PREAL48       0x0144      // near pointer to 48 bit real
#define T_PFREAL48      0x0244      // far pointer to 48 bit real
#define T_PHREAL48      0x0344      // huge pointer to 48 bit real
#define T_32PREAL48     0x0444      // 16:32 near pointer to 48 bit real
#define T_32PFREAL48    0x0544      // 16:32 far pointer to 48 bit real
#define T_64PREAL48     0x0644      // 64 bit pointer to 48 bit real




//      64 bit real types


#define T_REAL64        0x0041      // 64 bit real
#define T_PREAL64       0x0141      // near pointer to 64 bit real
#define T_PFREAL64      0x0241      // far pointer to 64 bit real
#define T_PHREAL64      0x0341      // huge pointer to 64 bit real
#define T_32PREAL64     0x0441      // 16:32 near pointer to 64 bit real
#define T_32PFREAL64    0x0541      // 16:32 far pointer to 64 bit real
#define T_64PREAL64     0x0641      // 64 bit pointer to 64 bit real




//      80 bit real types


#define T_REAL80        0x0042      // 80 bit real
#define T_PREAL80       0x0142      // near pointer to 80 bit real
#define T_PFREAL80      0x0242      // far pointer to 80 bit real
#define T_PHREAL80      0x0342      // huge pointer to 80 bit real
#define T_32PREAL80     0x0442      // 16:32 near pointer to 80 bit real
#define T_32PFREAL80    0x0542      // 16:32 far pointer to 80 bit real
#define T_64PREAL80     0x0642      // 64 bit pointer to 80 bit real




//      128 bit real types


#define T_REAL128       0x0043      // 128 bit real
#define T_PREAL128      0x0143      // near pointer to 128 bit real
#define T_PFREAL128     0x0243      // far pointer to 128 bit real
#define T_PHREAL128     0x0343      // huge pointer to 128 bit real
#define T_32PREAL128    0x0443      // 16:32 near pointer to 128 bit real
#define T_32PFREAL128   0x0543      // 16:32 far pointer to 128 bit real
#define T_64PREAL128    0x0643      // 64 bit pointer to 128 bit real




//      32 bit complex types


#define T_CPLX32        0x0050      // 32 bit complex
#define T_PCPLX32       0x0150      // near pointer to 32 bit complex
#define T_PFCPLX32      0x0250      // far pointer to 32 bit complex
#define T_PHCPLX32      0x0350      // huge pointer to 32 bit complex
#define T_32PCPLX32     0x0450      // 16:32 near pointer to 32 bit complex
#define T_32PFCPLX32    0x0550      // 16:32 far pointer to 32 bit complex
#define T_64PCPLX32     0x0650      // 64 bit pointer to 32 bit complex




//      64 bit complex types


#define T_CPLX64        0x0051      // 64 bit complex
#define T_PCPLX64       0x0151      // near pointer to 64 bit complex
#define T_PFCPLX64      0x0251      // far pointer to 64 bit complex
#define T_PHCPLX64      0x0351      // huge pointer to 64 bit complex
#define T_32PCPLX64     0x0451      // 16:32 near pointer to 64 bit complex
#define T_32PFCPLX64    0x0551      // 16:32 far pointer to 64 bit complex
#define T_64PCPLX64     0x0651      // 64 bit pointer to 64 bit complex




//      80 bit complex types


#define T_CPLX80        0x0052      // 80 bit complex
#define T_PCPLX80       0x0152      // near pointer to 80 bit complex
#define T_PFCPLX80      0x0252      // far pointer to 80 bit complex
#define T_PHCPLX80      0x0352      // huge pointer to 80 bit complex
#define T_32PCPLX80     0x0452      // 16:32 near pointer to 80 bit complex
#define T_32PFCPLX80    0x0552      // 16:32 far pointer to 80 bit complex
#define T_64PCPLX80     0x0652      // 64 bit pointer to 80 bit complex




//      128 bit complex types


#define T_CPLX128       0x0053      // 128 bit complex
#define T_PCPLX128      0x0153      // near pointer to 128 bit complex
#define T_PFCPLX128     0x0253      // far pointer to 128 bit complex
#define T_PHCPLX128     0x0353      // huge pointer to 128 bit real
#define T_32PCPLX128    0x0453      // 16:32 near pointer to 128 bit complex
#define T_32PFCPLX128   0x0553      // 16:32 far pointer to 128 bit complex
#define T_64PCPLX128    0x0653      // 64 bit pointer to 128 bit complex




//      boolean types


#define T_BOOL08        0x0030      // 8 bit boolean
#define T_BOOL16        0x0031      // 16 bit boolean
#define T_BOOL32        0x0032      // 32 bit boolean
#define T_BOOL64        0x0033      // 64 bit boolean
#define T_PBOOL08       0x0130      // near pointer to  8 bit boolean
#define T_PBOOL16       0x0131      // near pointer to 16 bit boolean
#define T_PBOOL32       0x0132      // near pointer to 32 bit boolean
#define T_PBOOL64       0x0133      // near pointer to 64 bit boolean
#define T_PFBOOL08      0x0230      // far pointer to  8 bit boolean
#define T_PFBOOL16      0x0231      // far pointer to 16 bit boolean
#define T_PFBOOL32      0x0232      // far pointer to 32 bit boolean
#define T_PFBOOL64      0x0233      // far pointer to 64 bit boolean
#define T_PHBOOL08      0x0330      // huge pointer to  8 bit boolean
#define T_PHBOOL16      0x0331      // huge pointer to 16 bit boolean
#define T_PHBOOL32      0x0332      // huge pointer to 32 bit boolean
#define T_PHBOOL64      0x0333      // huge pointer to 64 bit boolean

#define T_32PBOOL08     0x0430      // 16:32 near pointer to 8 bit boolean
#define T_32PFBOOL08    0x0530      // 16:32 far pointer to 8 bit boolean
#define T_32PBOOL16     0x0431      // 16:32 near pointer to 18 bit boolean
#define T_32PFBOOL16    0x0531      // 16:32 far pointer to 16 bit boolean
#define T_32PBOOL32     0x0432      // 16:32 near pointer to 32 bit boolean
#define T_32PFBOOL32    0x0532      // 16:32 far pointer to 32 bit boolean
#define T_32PBOOL64     0x0433      // 16:32 near pointer to 64 bit boolean
#define T_32PFBOOL64    0x0533      // 16:32 far pointer to 64 bit boolean

#define T_64PBOOL08     0x0630      // 64 bit pointer to 8 bit boolean
#define T_64PBOOL16     0x0631      // 64 bit pointer to 18 bit boolean
#define T_64PBOOL32     0x0632      // 64 bit pointer to 32 bit boolean
#define T_64PBOOL64     0x0633      // 64 bit pointer to 64 bit boolean


#define T_NCVPTR        0x01f0      // CV Internal type for created near pointers
#define T_FCVPTR        0x02f0      // CV Internal type for created far pointers
#define T_HCVPTR        0x03f0      // CV Internal type for created huge pointers
#define T_32NCVPTR      0x04f0      // CV Internal type for created near 32-bit pointers
#define T_32FCVPTR      0x05f0      // CV Internal type for created far 32-bit pointers
#define T_64NCVPTR      0x06f0      // CV Internal type for created near 64-bit pointers

#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))


/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */



    // leaf indices starting records but referenced from symbol records

#define LF_MODIFIER_16t     0x0001
#define LF_POINTER_16t      0x0002
#define LF_ARRAY_16t        0x0003
#define LF_CLASS_16t        0x0004
#define LF_STRUCTURE_16t    0x0005
#define LF_UNION_16t        0x0006
#define LF_ENUM_16t         0x0007
#define LF_PROCEDURE_16t    0x0008
#define LF_MFUNCTION_16t    0x0009
#define LF_VTSHAPE          0x000a
#define LF_COBOL0_16t       0x000b
#define LF_COBOL1           0x000c
#define LF_BARRAY_16t       0x000d
#define LF_LABEL            0x000e
#define LF_NULL             0x000f
#define LF_NOTTRAN          0x0010
#define LF_DIMARRAY_16t     0x0011
#define LF_VFTPATH_16t      0x0012
#define LF_PRECOMP_16t      0x0013      // not referenced from symbol
#define LF_ENDPRECOMP       0x0014      // not referenced from symbol
#define LF_OEM_16t          0x0015      // oem definable type string
#define LF_TYPESERVER       0x0016      // not referenced from symbol

    // leaf indices starting records but referenced only from type records

#define LF_SKIP_16t         0x0200
#define LF_ARGLIST_16t      0x0201
#define LF_DEFARG_16t       0x0202
#define LF_LIST             0x0203
#define LF_FIELDLIST_16t    0x0204
#define LF_DERIVED_16t      0x0205
#define LF_BITFIELD_16t     0x0206
#define LF_METHODLIST_16t   0x0207
#define LF_DIMCONU_16t      0x0208
#define LF_DIMCONLU_16t     0x0209
#define LF_DIMVARU_16t      0x020a
#define LF_DIMVARLU_16t     0x020b
#define LF_REFSYM           0x020c
                            
#define LF_BCLASS_16t       0x0400
#define LF_VBCLASS_16t      0x0401
#define LF_IVBCLASS_16t     0x0402
#define LF_ENUMERATE        0x0403
#define LF_FRIENDFCN_16t    0x0404
#define LF_INDEX_16t        0x0405
#define LF_MEMBER_16t       0x0406
#define LF_STMEMBER_16t     0x0407
#define LF_METHOD_16t       0x0408
#define LF_NESTTYPE_16t     0x0409
#define LF_VFUNCTAB_16t     0x040a
#define LF_FRIENDCLS_16t    0x040b
#define LF_ONEMETHOD_16t    0x040c
#define LF_VFUNCOFF_16t     0x040d

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
#define LF_TI16_MAX         0x1000

#define LF_MODIFIER         0x1001
#define LF_POINTER          0x1002
#define LF_ARRAY            0x1003
#define LF_CLASS            0x1004
#define LF_STRUCTURE        0x1005
#define LF_UNION            0x1006
#define LF_ENUM             0x1007
#define LF_PROCEDURE        0x1008
#define LF_MFUNCTION        0x1009
#define LF_COBOL0           0x100a
#define LF_BARRAY           0x100b
#define LF_DIMARRAY         0x100c
#define LF_VFTPATH          0x100d
#define LF_PRECOMP          0x100e      // not referenced from symbol
#define LF_OEM              0x100f      // oem definable type string
                            
    // leaf indices starting records but referenced only from type records
                            
#define LF_SKIP             0x1200
#define LF_ARGLIST          0x1201
#define LF_DEFARG           0x1202
#define LF_FIELDLIST        0x1203
#define LF_DERIVED          0x1204
#define LF_BITFIELD         0x1205
#define LF_METHODLIST       0x1206
#define LF_DIMCONU          0x1207
#define LF_DIMCONLU         0x1208
#define LF_DIMVARU          0x1209
#define LF_DIMVARLU         0x120a
                            
#define LF_BCLASS           0x1400
#define LF_VBCLASS          0x1401
#define LF_IVBCLASS         0x1402
#define LF_FRIENDFCN        0x1403
#define LF_INDEX            0x1404
#define LF_MEMBER           0x1405
#define LF_STMEMBER         0x1406
#define LF_METHOD           0x1407
#define LF_NESTTYPE         0x1408
#define LF_VFUNCTAB         0x1409
#define LF_FRIENDCLS        0x140a
#define LF_ONEMETHOD        0x140b
#define LF_VFUNCOFF         0x140c
#define LF_NESTTYPEEX       0x140d
#define LF_MEMBERMODIFY     0x140e




#define LF_NUMERIC          0x8000
#define LF_CHAR             0x8000
#define LF_SHORT            0x8001
#define LF_USHORT           0x8002
#define LF_LONG             0x8003
#define LF_ULONG            0x8004
#define LF_REAL32           0x8005
#define LF_REAL64           0x8006
#define LF_REAL80           0x8007
#define LF_REAL128          0x8008
#define LF_QUADWORD         0x8009
#define LF_UQUADWORD        0x800a
#define LF_REAL48           0x800b
#define LF_COMPLEX32        0x800c
#define LF_COMPLEX64        0x800d
#define LF_COMPLEX80        0x800e
#define LF_COMPLEX128       0x800f
#define LF_VARSTRING        0x8010
                            
#define LF_OCTWORD          0x8017
#define LF_UOCTWORD         0x8018
                            
#define LF_PAD0             0xf0
#define LF_PAD1             0xf1
#define LF_PAD2             0xf2
#define LF_PAD3             0xf3
#define LF_PAD4             0xf4
#define LF_PAD5             0xf5
#define LF_PAD6             0xf6
#define LF_PAD7             0xf7
#define LF_PAD8             0xf8
#define LF_PAD9             0xf9
#define LF_PAD10            0xfa
#define LF_PAD11            0xfb
#define LF_PAD12            0xfc
#define LF_PAD13            0xfd
#define LF_PAD14            0xfe
#define LF_PAD15            0xff

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_RESERVED    = 0x10  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**		Notes on alignment
 *		Alignment of the fields in most of the type records is done on the 
 *		basis of the TYPTYPE record base.  That is why in most of the lf*
 *		records that the CV_typ_t (32-bit types) is located on what appears to
 *		be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *		records that are in a list (lfFieldList, lfMethodList), which are
 *		aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

	Record type			Change (f == field arrangement, p = padding added)
	----------------------------------------------------------------------
	lfModifer			f
	lfPointer			fp
	lfClass				f
	lfStructure			f
	lfUnion				f
	lfEnum				f
	lfVFTPath			p
    lfPreComp           p
	lfOEM				p
	lfArgList			p
	lfDerived			p
	mlMethod			p	(method list member)
	lfBitField			f
	lfDimCon			f
	lfDimVar			p
	lfIndex				p	(field list member)
	lfBClass			f	(field list member)
	lfVBClass			f	(field list member)
	lfFriendCls			p	(field list member)
	lfFriendFcn			p	(field list member)
	lfMember			f	(field list member)
	lfSTMember			f	(field list member)
	lfVFuncTab			p	(field list member)
	lfVFuncOff			p	(field list member)
	lfNestType			p	(field list member)

	DATASYM32			f
	PROCSYM32			f
	VPATHSYM32			f
	REGREL32			f
	THREADSYM32			f
	PROCSYMMIPS			f

	
*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union  {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t			utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union  {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t	attr;           // method attribute
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t		index;          // index to type record for procedure
    unsigned long	vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
	                                // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
	                                // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
	_2BYTEPAD       pad0;			// internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
	_2BYTEPAD       pad0;		// internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
	S_REGISTER_16t	=  0x0002, // Register variable
	S_CONSTANT_16t	=  0x0003, // constant symbol
	S_UDT_16t		=  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME       =  0x0009, // path to object file name
    S_ENDARG        =  0x000a, // end of argument/return list
	S_COBOLUDT_16t	=  0x000b, // special UDT for cobol that does not symbol pack
	S_MANYREG_16t	=  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry
                       
    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address
                       
    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation
                       
    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start
                       
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
    S_ALIGN         =  0x0402, // Used for page alignment of symbols
    S_LPROCREF      =  0x0403, // Local Reference to a procedure

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
S_TI16_MAX          =  0x1000,
	S_REGISTER		=  0x1001, // Register variable
	S_CONSTANT		=  0x1002, // constant symbol
	S_UDT			=  0x1003, // User defined type
	S_COBOLUDT		=  0x1004, // special UDT for cobol that does not symbol pack
	S_MANYREG		=  0x1005, // multiple register variable
	S_BPREL32		=  0x1006, // BP-relative
	S_LDATA32		=  0x1007, // Module-local symbol
	S_GDATA32		=  0x1008, // Global data symbol
	S_PUB32 		=  0x1009, // a public symbol (CV internal reserved)
	S_LPROC32		=  0x100a, // Local procedure start
	S_GPROC32		=  0x100b, // Global procedure start
	S_VFTABLE32 	=  0x100c, // address of virtual function table
	S_REGREL32		=  0x100d, // register relative address
	S_LTHREAD32 	=  0x100e, // local thread storage
	S_GTHREAD32 	=  0x100f, // global thread storage

	S_LPROCMIPS 	=  0x1010, // Local procedure start
	S_GPROCMIPS 	=  0x1011, // Global procedure start
                       
} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMPRO   = 0x06,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43

} CV_CPU_TYPE_e;




//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO:1; // frame pointer present
            unsigned char CV_PFLAG_INT  :1; // interrupt return
            unsigned char CV_PFLAG_FAR  :1; // far return
            unsigned char CV_PFLAG_NEVER:1; // function does not return
            unsigned char unused        :4; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_REGISTER_16t
	CV_typ16_t		typind; 	// Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_MANYREG_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;



typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_CONSTANT_16t
	CV_typ16_t		typind; 	// Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_UDT_16t | S_COBOLUDT_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;





typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    CV_GENERIC_STYLE_e style;   // return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,
    THUNK_ORDINAL_ADJUSTOR,
    THUNK_ORDINAL_VCALL,
    THUNK_ORDINAL_PCODE
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table			= 0x00,	// not executable
    CEXM_MDL_jumptable		= 0x01, // Compiler generated jump table
    CEXM_MDL_datapad		= 0x02, // Data padding for alignment
    CEXM_MDL_native			= 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol			= 0x21, // cobol
    CEXM_MDL_codepad		= 0x22, // Code padding for alignment
    CEXM_MDL_code			= 0x23, // code
	CEXM_MDL_sql			= 0x30,	// sql
    CEXM_MDL_pcode			= 0x40, // pcode
    CEXM_MDL_pcode32Mac		= 0x41,	// macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var16 {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
	CV_typ16_t		root;		// type index of the root of path
	CV_typ16_t		path;		// type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;




typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var32 {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;


typedef enum CV_HREG_e {
    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

	//
	// JAVA VM registers
	//

	CV_JAVA_PC		= 1,


} CV_HREG_e;

#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\csleak.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    csleak.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping
    critical section statistics for leak detection.

Author:

    Anil Ruia   (anilr)   10-May-2002

Revision History:

--*/

#include "precomp.hxx"
#include "stktrace.h"

#define MAX_STACK_TRACES 100000

struct
{
    DWORD DatabaseIndex;
    DWORD Instances;
} MyStackTrace[MAX_STACK_TRACES];

PVOID
GetStackBackTraceIndexAddress(
    IN DWORD BackTraceIndex
    )
{
    BOOL fReturn;
    PRTL_STACK_TRACE_ENTRY pBackTraceEntry;
    PSTACK_TRACE_DATABASE RtlpStackTraceDataBase;
    STACK_TRACE_DATABASE StackTraceDataBase;

    if (BackTraceIndex == 0)
    {
        return NULL;
    }

    RtlpStackTraceDataBase = (PSTACK_TRACE_DATABASE)GetExpression("poi(ntdll!RtlpStackTraceDataBase)");

    if (RtlpStackTraceDataBase == NULL)
    {
        return NULL;
    }

    fReturn = ReadMemory((ULONG_PTR)RtlpStackTraceDataBase,
                         &StackTraceDataBase,
                         sizeof(StackTraceDataBase),
                         NULL);
    if (!fReturn)
    {
        return NULL;
    }

    if (BackTraceIndex >= StackTraceDataBase.NumberOfEntriesAdded)
    {
        return NULL;
    }

    fReturn = ReadMemory((ULONG_PTR)(StackTraceDataBase.EntryIndexArray - BackTraceIndex),
                         &pBackTraceEntry,
                         sizeof(pBackTraceEntry),
                         NULL);
    if (!fReturn)
    {
        dprintf("unable to read stack back trace index (%d) entry at %p\n",
                BackTraceIndex,
                StackTraceDataBase.EntryIndexArray - BackTraceIndex);

        return NULL;
    }

    return pBackTraceEntry->BackTrace;
}

VOID
CritSecEnum(
    IN PVOID pvDebugee,
    IN PVOID pvDebugger,
    IN CHAR  chVerbosity,
    IN DWORD iCount
    )
/*++

 Enumerator for NT's standard doubly linked list LIST_ENTRY

  PFN_LIST_ENUMERATOR
     This is the callback function for printing the CLIENT_CONN object.

  Arguments:
    pvDebuggee  - pointer to object in the debuggee process
    pvDebugger  - pointer to object in the debugger process
    chVerbosity - character indicating the verbosity level desired

--*/
{
    RTL_CRITICAL_SECTION_DEBUG *pLocalDebug = (RTL_CRITICAL_SECTION_DEBUG *)pvDebugger;

    if (chVerbosity > 0)
    {
        dprintf("Critical-Section address %p, Stack-trace index %d\n",
                pLocalDebug->CriticalSection,
                pLocalDebug->CreatorBackTraceIndex);
    }

    if (pLocalDebug->CreatorBackTraceIndex >= MAX_STACK_TRACES)
    {
        dprintf("Too many stack traces, dropping index %d, recompile with higher MAX_STACK_TRACES\n", pLocalDebug->CreatorBackTraceIndex);
    }
    else
    {
        MyStackTrace[pLocalDebug->CreatorBackTraceIndex].Instances++;
    }
}

DECLARE_API( csleak )

/*++

Routine Description:

    This function is called as an NTSD extension to dump Critical
    Section statistics, i.e. a sorted list of stack traces with maximum
    critical sections initialized

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG lowerNoiseBound = 1;
    DWORD i,j;
    CHAR chVerbosity = 0;

    //
    // Interpret the command-line switch.
    //

    while (*args) {

        // skip any whitespace to get to the next argument

        while(isspace(*args))
            args++;

        // break if we hit the NULL terminator

        if (*args == '\0')
            break;

        // should be pointing to a '-' char

        if (*args != '-')
        {
            PrintUsage("csleak");
            return;
        }

        // Advance to option letter

        args++;

        // save the option letter

        char cOption = *args;

        // advance past the option letter

        args++;

        // skip past leading white space in the argument

        while(isspace(*args))
            args++;

        // if we didn't find anything after the option, error

        if (*args == '\0')
        {
            PrintUsage("csleak");
            return;
        }

        switch( cOption )
        {
            case 'm' :
                lowerNoiseBound = atoi(args);
                break;

            case 'v' :
                chVerbosity = (CHAR)atoi(args);
                break;

            default :
                PrintUsage("csleak");
                return;
        }

        // move past the current argument

        while ((*args != ' ') 
               && (*args != '\t') 
               && (*args != '\0'))
        {
            args++;
        }
    }

    for (i=0; i<MAX_STACK_TRACES; i++)
    {
        MyStackTrace[i].DatabaseIndex = i;
        MyStackTrace[i].Instances = 0;
    }

    LIST_ENTRY *pCritSecList = (LIST_ENTRY *)GetExpression("ntdll!RtlCriticalSectionList");
    
    if (pCritSecList == NULL)
    {
        dprintf("Cannot evaluate ntdll!RtlCriticalSectionList, please fix ntdll symbols\n");
        return;
    }

    EnumLinkedList(pCritSecList,
                   CritSecEnum,
                   chVerbosity,
                   sizeof(RTL_CRITICAL_SECTION_DEBUG),
                   FIELD_OFFSET(RTL_CRITICAL_SECTION_DEBUG, ProcessLocksList));

    for (i=0; i<MAX_STACK_TRACES; i++)
    {
        for (j=i+1; j<MAX_STACK_TRACES; j++)
        {
            if (MyStackTrace[i].Instances < MyStackTrace[j].Instances)
            {
                DWORD temp;

                temp = MyStackTrace[i].Instances;
                MyStackTrace[i].Instances = MyStackTrace[j].Instances;
                MyStackTrace[j].Instances = temp;

                temp = MyStackTrace[i].DatabaseIndex;
                MyStackTrace[i].DatabaseIndex = MyStackTrace[j].DatabaseIndex;
                MyStackTrace[j].DatabaseIndex = temp;
            }
        }

        if (MyStackTrace[i].Instances < lowerNoiseBound)
        {
            break;
        }

        dprintf("Instances %d, Index %d, stack-trace address %p\n",
                MyStackTrace[i].Instances,
                MyStackTrace[i].DatabaseIndex,
                GetStackBackTraceIndexAddress(MyStackTrace[i].DatabaseIndex));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\dbginet.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbginet.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    Internet Information Server

Author:

    Murali R. Krishnan (MuraliK)  16-Sept-1996

Revision History:

--*/

#include "precomp.hxx"



/************************************************************
 * Dump Symbols from stack
 ************************************************************/


DECLARE_API( ds )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    symbols on the stack.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR startingAddress;
    ULONG_PTR stack;
    ULONG_PTR i;
    CHAR symbol[MAX_SYMBOL_LEN];
    ULONG_PTR offset;
    PCHAR format;
    BOOL validSymbolsOnly = FALSE;
    MODULE_INFO moduleInfo;


    //
    // Skip leading blanks.
    //

    while( *args == ' ' ) {
        args++;
    }

    if( *args == '-' ) {
        args++;
        switch( *args ) {
        case 'v' :
        case 'V' :
            validSymbolsOnly = TRUE;
            args++;
            break;

        default :
            PrintUsage( "ds" );
            return;
        }
    }

    while( *args == ' ' ) {
        args++;
    }

    //
    // By default, start at the current stack location. Otherwise,
    // start at the given address.
    //

    if( !*args ) {
#if defined(_X86_)
        args = "esp";
#elif defined(_AMD64_)
        args = "rsp";
#elif defined(_IA64_)
        args = "sp";
#else
#error "unsupported CPU"
#endif
    }

    startingAddress = GetExpression( args );

    if( startingAddress == 0 ) {

        dprintf(
            "dtext!ds: cannot evaluate \"%s\"\n",
            args
            );

        return;

    }

    //
    // Ensure startingAddress is properly aligned.
    //

    startingAddress &= ~(sizeof(PVOID)-1);

    //
    // Read the stack.
    //

    for( i = 0 ; i < NUM_STACK_SYMBOLS_TO_DUMP ; startingAddress += sizeof(PVOID) ) {

        if( CheckControlC() ) {
            break;
        }

        if( ReadMemory(
                startingAddress,
                &stack,
                sizeof(stack),
                NULL
                ) ) {

            GetSymbol(
                (PVOID)stack,
                symbol,
                &offset
                );

            if( symbol[0] == '\0' ) {
                if( FindModuleByAddress(
                        stack,
                        &moduleInfo
                        ) ) {
                    strcpy( (CHAR *)symbol, moduleInfo.FullName );
                    offset = DIFF(stack - moduleInfo.DllBase);
                }
            }

            if( symbol[0] == '\0' ) {
                if( validSymbolsOnly ) {
                    continue;
                }
                format = "%08p : %08p\n";
            } else
            if( offset == 0 ) {
                format = "%08p : %08p : %s\n";
            } else {
                format = "%08p : %08p : %s+0x%p\n";
            }

            dprintf(
                format,
                startingAddress,
                stack,
                symbol,
                offset
                );

            i++;

        } else {

            dprintf(
                "dtext!ds: cannot read memory @ %lx\n",
                startingAddress
                );

            return;

        }

    }

    dprintf(
        "!dtext.ds %s%lx to dump next block\n",
        validSymbolsOnly ? "-v " : "",
        startingAddress
        );

} // DECLARE_API( ds )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\dbgirtl.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbgirtl.cxx

Abstract:

    This module contains the iisrtl-related ntsd debugger extensions for
    Internet Information Server

Author:

    George V. Reilly (georgere)   24-Mar-1998

Revision History:

--*/


#include "precomp.hxx"


//
// Worker routines.
//



//
// NTSD extension entrypoints.
//

DECLARE_API( lkhash )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an LKHash table

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG address;
    BOOLEAN verbose;

    //
    // Establish defaults.
    //

    verbose = FALSE;

    //
    // Skip any leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    //
    // Process switches.
    //

    while( *args == '-' ) {

        args++;

        while( *args != ' ' &&
               *args != '\t' &&
               *args != '\0' ) {

            switch( *args ) {
            case 'v' :
            case 'V' :
                verbose = !verbose;
                break;

            case '-' :  // Set the switches the way I like them. --keithmo
                verbose = TRUE;
                break;

            default :
                PrintUsage( "lkhash" );
                return;

            }

            args++;

        }

        while( *args == ' ' ||
               *args == '\t' ) {
            args++;
        }

    }

    if( *args != '\0' ) {

        //
        // Dump a single object.
        //

        address = GetExpression( args );

        if( address == 0 ) {

            dprintf(
                "dtext: cannot evaluate \"%s\"\n",
                args
                );

            return;

        }


        return;

    }


} // DECLARE_API( fcache )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\test\w3control\w3control.cxx ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    w3control.cxx

Abstract:

    IW3Control interface test app.

Author:

    Seth Pollack (sethp)        21-Feb-2000

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//

// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();


// usage information
const WCHAR g_Usage[] = 
L"Usage: w3control apppoolId\n";

#define W3_CONTROL_COMMAND_GETMODE W3_CONTROL_COMMAND_CONTINUE + 1
#define W3_CONTROL_COMMAND_RECYCLE W3_CONTROL_COMMAND_CONTINUE + 2

//
// Public functions.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;
    LPWSTR AppPoolId = NULL;
    IW3Control * pIW3Control = NULL;


    CREATE_DEBUG_PRINT_OBJECT( "w3control" );

    //
    // Validate and parse parameters.
    //

    if ( ( argc < 2 ) || ( argc > 2 ) )
    {
        wprintf( g_Usage );
        goto exit;
    }

    AppPoolId = argv[2];

    //
    // Prepare to make the call.
    //

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }


/*
    DBGPRINTF((
        DBG_CONTEXT, 
        "About to create instance\n"
        ));
*/

    hr = CoCreateInstance( 
                CLSID_W3Control,                    // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IW3Control,                     // IID
                ( VOID * * ) ( &pIW3Control )       // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating instance of IW3Control failed\n"
            ));

        goto exit;
    }


    //
    // Call the appropriate method.
    //

/*
    DBGPRINTF((
        DBG_CONTEXT, 
        "About to call method\n"
        ));
*/

    hr = pIW3Control->RecycleAppPool( AppPoolId );
    if ( FAILED( hr ) )
    {
        wprintf( L"call failed, hr=%x\n", hr );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Calling method on IW3Control failed\n"
            ));

        goto exit;
    }

    pIW3Control->Release();


    CoUninitialize();


    DELETE_DEBUG_PRINT_OBJECT();


exit:

    return ( INT ) hr;

}   // wmain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\dtext.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    dtext.cxx

Abstract:

    This module exports certain functions needed to be exported by new
    debugger extensions

Author:

    Anil Ruia (AnilR) 9-12-2002

Revision History:

--*/


#include "precomp.hxx"

WINDBG_EXTENSION_APIS   ExtensionApis;
EXT_API_VERSION         ApiVersion;

VOID WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    )
{
    memcpy(&ExtensionApis, lpExtensionApis, sizeof(ExtensionApis));
    ApiVersion.MajorVersion = MajorVersion;
    ApiVersion.MinorVersion = MinorVersion;
}

LPEXT_API_VERSION ExtensionApiVersion()
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\dbglkrh.cxx ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    dbglkrh.cxx

Abstract:

    LKRhash support

Author:

    George V. Reilly (GeorgeRe)  22-Feb-1999

Revision History:

--*/

#include "precomp.hxx"

#include "lkrcust.h"

#define LKR_CUST_DECLARE_TABLE
#include "lkrcust.h"

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets = 0;
LONG CLKRLinearHashTable::sm_cTables           = 0;
#endif // LOCK_INSTRUMENTATION

#define CMDNAME "lkrhash"

// There are several different DLLs in the IISRTL family. This is to
// allow us to set the name of the DLL on the fly.
// TODO: add a command to set this name dynamically.

#ifndef LKRHASH_NAME
# define LKRHASH_NAME "iisutil"
#endif // LKRHASH_NAME

CHAR g_szLKRhashDllName[MAX_PATH] = LKRHASH_NAME;

// sprintf-formatted string, e.g., "&%s!CLKRHashTable__sm_llGlobalList"
// Has to return LPSTR, not LPCSTR, because GetExpression is not const-correct
LPSTR
LKRhashDllVar(
    LPCSTR pszFormat)
{
    // we can get away with a static CHAR[] because debugger extensions
    // are single-threaded
    static CHAR szSymbol[MAX_SYMBOL_LEN];

    sprintf(szSymbol, pszFormat, g_szLKRhashDllName);
    return szSymbol;
}

#ifndef __LKRHASH_NO_NAMESPACE__
 #define STR_LKRHASH_NS "LKRhash__"
#else
 #define STR_LKRHASH_NS ""
#endif // !__LKRHASH_NO_NAMESPACE__

// Dummy implementations so that we can link

LKRHASH_NS::CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double   maxload,               // Upperbound on average chain length
    DWORD    initsize,              // Initial size of hash table.
    DWORD    num_subtbls,           // for signature compatiblity
                                    // with CLKRHashTable
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    : m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL),
      m_fMultiKeys(fMultiKeys)
{}

LKRHASH_NS::CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    : m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL),
      m_fMultiKeys(fMultiKeys)
{}

LKRHASH_NS::CLKRLinearHashTable::~CLKRLinearHashTable()
{}

LKRHASH_NS::CLKRHashTable::CLKRHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double   maxload,               // Upperbound on average chain length
    DWORD    initsize,              // Initial size of hash table.
    DWORD    num_subtbls,           // #subordinate hash tables
    bool            fMultiKeys      // Allow multiple identical keys?
    )
{}

LKRHASH_NS::CLKRHashTable::~CLKRHashTable()
{}



/************************************************************
 * Dump LKRhash tables
 ************************************************************/
const char*
LKRC2String(
    LK_RETCODE lkrc)
{
    const char* psz = NULL;

    switch (lkrc)
    {
    case LK_UNUSABLE:
        psz = "LK_UNUSABLE";
        break;
    case LK_ALLOC_FAIL:
        psz = "LK_ALLOC_FAIL";
        break;
    case LK_BAD_ITERATOR:
        psz = "LK_BAD_ITERATOR";
        break;
    case LK_BAD_RECORD:
        psz = "LK_BAD_RECORD";
        break;
    case LK_BAD_PARAMETERS:
        psz = "LK_BAD_PARAMETERS";
        break;
    case LK_NOT_INITIALIZED:
        psz = "LK_NOT_INITIALIZED";
        break;
    case LK_SUCCESS:
        psz = "LK_SUCCESS";
        break;
    case LK_KEY_EXISTS:
        psz = "LK_KEY_EXISTS";
        break;
    case LK_NO_SUCH_KEY:
        psz = "LK_NO_SUCH_KEY";
        break;
    case LK_NO_MORE_ELEMENTS:
        psz = "LK_NO_MORE_ELEMENTS";
        break;
    default:
        psz = "Unknown LK_RETCODE";
        break;
    }

    return psz;
}


enum {
    NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
    BUCKET_BYTE_SIZE = CNodeClump::BUCKET_BYTE_SIZE,
    HASH_INVALID_SIGNATURE =
        LKRHASH_NS::CLKRLinearHashTable::HASH_INVALID_SIGNATURE,
    LKLH_SIGNATURE =      LKRHASH_NS::CLKRLinearHashTable::SIGNATURE,
    LKLH_SIGNATURE_FREE = LKRHASH_NS::CLKRLinearHashTable::SIGNATURE_FREE,
    LKHT_SIGNATURE =      LKRHASH_NS::CLKRHashTable::SIGNATURE,
    LKHT_SIGNATURE_FREE = LKRHASH_NS::CLKRHashTable::SIGNATURE_FREE,
};


BOOL
EnumerateBucketChain(
    LKR_CUST_EXTN*    plce,
    IN LOCK_LOCKTYPE  ltBucketLockType,
    IN INT            iBkt,
    IN CBucket*       pbkt,
    IN INT            nVerbose)
{
    PSTR        cmdName = CMDNAME;
    BYTE        abBkt[BUCKET_BYTE_SIZE];
    DEFINE_CPP_VAR(CNodeClump, nc);
    CNodeClump* pnc = GET_CPP_VAR_PTR(CNodeClump, nc);
    CNodeClump* pncCurr;
    DWORD       cNodes = 0, cnc = 0;
    BOOL        fLockPrinted = FALSE;

    ReadMemory((ULONG_PTR)pbkt, abBkt, sizeof(abBkt), NULL);

    for (pncCurr = (CNodeClump*) ((PBYTE) pbkt + LockSize(ltBucketLockType));
         pncCurr != NULL;
         pncCurr = pnc->m_pncNext)
    {
        DWORD i, c;

        ReadMemory((ULONG_PTR)pncCurr, pnc, sizeof(nc), NULL);

        for (i = c = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                c++;
        }

        if (c == NODES_PER_CLUMP)
        {
            if (nVerbose >= 3)
                dprintf("  0-%d: -- empty\n", NODES_PER_CLUMP);
        }
        else
        {
            if (cnc++ == 0)
                PrintLock(ltBucketLockType, &pbkt->m_Lock, nVerbose);
            
            dprintf("Bucket %4d, %d:\n", iBkt, cnc);
            for (i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                {
                    if (nVerbose >= 3)
                        dprintf("  %d: --\n", i);
                    else
                        break;
                }
                else if (plce != NULL)
                {
                    if (!(*plce->m_pfn_Record_Dump)(pnc->m_pvNode[i],
                                                    pnc->m_dwKeySigs[i],
                                                    nVerbose))
                        return FALSE;
                }
            }
        }

        if (CheckControlC())
        {
            dprintf("\n^C\n");
            return FALSE;
        }

        const DWORD MAX_NODES = 20;
        if (++cNodes > MAX_NODES)
        {
            dprintf(DBGEXT ".%s: Bucket chain contains more than %d nodes! "
                    "Corrupted?\n", cmdName, MAX_NODES);
            return TRUE;
        }
    }

    return TRUE;
}



BOOL
EnumerateLKRLinearHashTable(
    LKR_CUST_EXTN*       plce,
    IN CLinearHashTable* plht,
    IN INT               nVerbose)
{
    PSTR cmdName = CMDNAME;
    CLinearHashTable lht(NULL, NULL, NULL, NULL, NULL);
    INT i;
    BOOL fRet = FALSE;
    LOCK_LOCKTYPE ltTableLockType  = LOCK_SPINLOCK;
    LOCK_LOCKTYPE ltBucketLockType = LOCK_SPINLOCK;
    CDirEntry* paDirSegs = NULL;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory((ULONG_PTR)plht, &lht, sizeof(lht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)plht);

        goto cleanup;
    }

    dprintf(
        "\n" DBGEXT ".%s: @ %p:\n"
        "    CLKRLinearHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    State = %d (%s)\n",
        cmdName,
        plht,
        lht.m_dwSignature,
        DECODE_SIGNATURE(lht.m_dwSignature),
        lht.m_dwSignature == LKLH_SIGNATURE
            ? "OK" : (lht.m_dwSignature == LKLH_SIGNATURE_FREE
                      ? "FREED" : "INVALID"),
        lht.m_szName,
        lht.m_lkrcState, LKRC2String(lht.m_lkrcState));

    if (nVerbose == 0)
        goto done;

    ltTableLockType  = (LOCK_LOCKTYPE) lht.m_nTableLockType;
    ltBucketLockType = (LOCK_LOCKTYPE) lht.m_nBucketLockType;
    dprintf(
        "    TableLock = %s, BucketLock = %s, Parent CLKRHashTable = %p\n",
        LockName(ltTableLockType),
        LockName(ltBucketLockType),
        lht.m_phtParent);

    dprintf(
        "    Size = %d, SegBits = %d, SegSize = %d, SegMask = %x\n",
        lht.m_lkts, lht.m_dwSegBits, lht.m_dwSegSize, lht.m_dwSegMask);
    dprintf(
        "    MaxLoad = %3.1f, paDirSegs = %p, cDirSegs = %d\n",
        lht.m_MaxLoad, lht.m_paDirSegs, lht.m_cDirSegs);
    dprintf(
        "    cRecords = %d, cActiveBuckets = %d, BucketSpins = %hd\n",
        lht.m_cRecords, lht.m_cActiveBuckets, lht.m_wBucketLockSpins);
    dprintf(
        "    nLevel = %d, dwBktAddrMask0 = %x, iExpansionIdx = %d\n",
        lht.m_nLevel, lht.m_dwBktAddrMask0, lht.m_iExpansionIdx);

    PrintLock(ltTableLockType, &plht->m_Lock, nVerbose);

    if (plce != NULL  &&  !(*plce->m_pfn_LKLH_Dump)(plht, nVerbose))
        goto done;
    
    if (nVerbose == 1)
        goto done;
    
    paDirSegs = (CDirEntry*) calloc(lht.m_cDirSegs, sizeof(CDirEntry));

    if (paDirSegs == NULL)
    {
        dprintf("Couldn't allocate %d bytes for directory segment\n",
                lht.m_cDirSegs * sizeof(CDirEntry));
        return fRet;
    }
    
    if (!ReadMemory((ULONG_PTR)lht.m_paDirSegs, paDirSegs,
                    sizeof(CDirEntry) * lht.m_cDirSegs, NULL))
        goto cleanup;

    for (i = 0;  i < (INT) (lht.m_cDirSegs * lht.m_dwSegSize);  i++)
    {
        const DWORD iSeg = i >> lht.m_dwSegBits;
        CLargeSegment* pseg =
            static_cast<CLargeSegment*>(paDirSegs[iSeg].m_pseg);

        if ((i & lht.m_dwSegMask) == 0)
            dprintf("Segment %d: %p\n", iSeg, pseg);

        if (pseg == NULL)
            continue;

        if (nVerbose >= 2)
        {
            CBucket* pbkt = pseg->m_bktSlots + (i & lht.m_dwSegMask);
            
            if (!EnumerateBucketChain(plce, ltBucketLockType,
                                      i, pbkt, nVerbose))
                goto cleanup;
        }

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;

  cleanup:
    memset(&lht, 0, sizeof(lht));
    free(paDirSegs);
    return fRet;
}



BOOL
EnumerateLKRhashTable(
    LKR_CUST_EXTN*    plce,
    IN CHashTable2*    pht,
    IN INT            nVerbose)
{
    CHashTable2 ht(NULL, NULL, NULL, NULL, NULL);
    PSTR cmdName = CMDNAME;
    CLinearHashTable** palhtDir = NULL;
    UINT i;
    BOOL fRet = FALSE;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory((ULONG_PTR)pht, &ht, sizeof(ht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)pht);

        goto cleanup;
    }

    dprintf(
        DBGEXT ".%s: @ %p:\n"
        "    CLKRHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    %d subtables, State = %d (%s)\n",
        cmdName,
        pht,
        ht.m_dwSignature,
        DECODE_SIGNATURE(ht.m_dwSignature),
        ht.m_dwSignature == LKHT_SIGNATURE
            ? "OK"
            : ht.m_dwSignature == LKHT_SIGNATURE_FREE
              ? "FREED"
              : "INVALID",
        ht.m_szName,
        ht.m_cSubTables,
        ht.m_lkrcState, LKRC2String(ht.m_lkrcState)
        );

    if (plce != NULL  &&  !(*plce->m_pfn_LKHT_Dump)(pht, nVerbose))
        goto done;
    
    if (nVerbose == 0)
        goto done;

    palhtDir = (CLinearHashTable**) calloc(ht.m_cSubTables,
                                           sizeof(CLinearHashTable*));
    if (!palhtDir)
        goto cleanup;
    
    if (!ReadMemory((ULONG_PTR)ht.m_palhtDir, palhtDir,
                    ht.m_cSubTables * sizeof(CLinearHashTable*), NULL))
        goto cleanup;

    for (i = 0;  i < ht.m_cSubTables;  ++i)
    {
        dprintf("\n%d : ", i);
        if (!EnumerateLKRLinearHashTable(plce, palhtDir[i], nVerbose))
            break;

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;
    
  cleanup:
    free(palhtDir);

    return fRet;
}



VOID
PrintLKRLinearHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CLinearHashTable*) psdDebugger)->m_dwSignature;

    if (dwSig != LKLH_SIGNATURE)
    {
        dprintf( "CLKRLinearHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee, dwSig, DECODE_SIGNATURE(dwSig),
                 LKLH_SIGNATURE, DECODE_SIGNATURE(LKLH_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) psdDebuggee,
                                    chVerbosity);
    dprintf("\n");
}



VOID
PrintLKRHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CHashTable2*) psdDebugger)->m_dwSignature;
    if (dwSig != LKHT_SIGNATURE)
    {
        dprintf( "CLKRHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee,
                 dwSig, DECODE_SIGNATURE(dwSig),
                 LKHT_SIGNATURE, DECODE_SIGNATURE(LKHT_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRhashTable(plce, (CHashTable2*) psdDebuggee,
                              chVerbosity);
    dprintf("\n");
}



VOID
DumpLKRsList(
    IN INT              nVerbose)
{
    CLockedDoubleList* plstHashTables = (CLockedDoubleList*) GetExpression(
                        LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                      "CLKRHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("%s!" STR_LKRHASH_NS
                              "CLKRHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CHashTable2),
                    FIELD_OFFSET( CHashTable2, m_leGlobalList));


    plstHashTables = (CLockedDoubleList*) GetExpression(
                      LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                    "CLKRLinearHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("!" STR_LKRHASH_NS
                              "CLKRLinearHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRLinearHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRLinearHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CLinearHashTable),
                    FIELD_OFFSET( CLinearHashTable, m_leGlobalList));
    return;
} // DumpLKRsList()





DECLARE_API( lkrhash )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an LKRhash table.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR lkrAddress = 0;
    INT nVerbose = 0;
    PSTR cmdName = CMDNAME;

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( *args == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    if ( *args == '-' )
    {
        args++;

        if ( *args == 'h' )
        {
            PrintUsage( cmdName );
            return;
        }

        if ( *args == 'l' ) {
            args++;
            if ('0' <= *args  &&  *args <= '9' ) {
                nVerbose = *args++ - '0';
            }
        }

        if ( *args == 'v' )
        {
            args++;
            nVerbose = 99;
        }

        if ( *args == 'g' )
        {
            args++;
            if ('0' <= *args  &&  *args <= '9' ) {
                nVerbose = *args++ - '0';
            }
            DumpLKRsList(nVerbose);
            return;
        }

    }

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    lkrAddress = (ULONG_PTR) GetExpression( args );

    if (lkrAddress == 0) {

        dprintf(
            DBGEXT ".%s: cannot evaluate \"%s\"\n",
            cmdName,
            args
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *args != ' ' &&
           *args != '\t' &&
           *args != '\0' ) {
        args++;
    }

    DWORD dwSig;
    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, (VOID*) lkrAddress, dwSig);

    if (plce == NULL)
        goto cleanup;
    
    if (dwSig == LKHT_SIGNATURE || dwSig == LKHT_SIGNATURE_FREE)
    { 
        EnumerateLKRhashTable(plce,
                              (CHashTable2*) lkrAddress,
                              nVerbose);
    }
    else if (dwSig == LKLH_SIGNATURE || dwSig == LKLH_SIGNATURE_FREE)
    { 
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) lkrAddress,
                                    nVerbose);
    }
    else
    {
        dprintf(DBGEXT ".%s: %p does not contain a valid LKRhash table\n",
                cmdName, (PVOID)lkrAddress);
    }
    
cleanup:
    return;
} // DECLARE_API( lkrhash )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\dbglocks.cxx ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    dbglocks.cxx

Abstract:

    Locks support

Author:

    George V. Reilly (GeorgeRe)  01-Mar-1999

Revision History:

--*/

#include "precomp.hxx"

#ifdef LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME ("lkrdbg")
# ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
LONG CSmallSpinLock::sm_cTotalLocks   = 0;
# endif

#ifdef TEST_LOCKS
LONG CSpinLock1::sm_cTotalLocks        = 0;
LONG CSpinLock2::sm_cTotalLocks       = 0;
#endif // TEST_LOCKS

LONG CSpinLock::sm_cTotalLocks       = 0;
LONG CReaderWriterLock::sm_cTotalLocks  = 0;
LONG CReaderWriterLock2::sm_cTotalLocks = 0;
LONG CReaderWriterLock3::sm_cTotalLocks = 0;
#else // !LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME 
#endif // !LOCK_INSTRUMENTATION

const char*
LockName(
    LOCK_LOCKTYPE lt)
{
    const char* pszName = NULL;

    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        pszName = "CSmallSpinLock";
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        pszName = "CSpinLock1";
        break;
    case LOCK_SPINLOCK2:
        pszName = "CSpinLock2";
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        pszName = "CSpinLock";
        break;
    case LOCK_FAKELOCK:
        pszName = "CFakeLock";
        break;
    case LOCK_CRITSEC:
        pszName = "CCritSec";
        break;
    case LOCK_READERWRITERLOCK:
        pszName = "CReaderWriterLock";
        break;
    case LOCK_READERWRITERLOCK2:
        pszName = "CReaderWriterLock2";
        break;
    case LOCK_READERWRITERLOCK3:
        pszName = "CReaderWriterLock3";
        break;
    default:
        pszName = "UnknownLockType";
        break;
    }

    return pszName;
};

int
LockSize(
    LOCK_LOCKTYPE lt)
{
    int cb = 0;

    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        cb = sizeof(CSmallSpinLock);
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        cb = sizeof(CSpinLock1);
        break;
    case LOCK_SPINLOCK2:
        cb = sizeof(CSpinLock2);
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        cb = sizeof(CSpinLock);
        break;
    case LOCK_FAKELOCK:
        cb = sizeof(CFakeLock);
        break;
    case LOCK_CRITSEC:
        cb = sizeof(CCritSec);
        break;
    case LOCK_READERWRITERLOCK:
        cb = sizeof(CReaderWriterLock);
        break;
    case LOCK_READERWRITERLOCK2:
        cb = sizeof(CReaderWriterLock2);
        break;
    case LOCK_READERWRITERLOCK3:
        cb = sizeof(CReaderWriterLock3);
        break;
    default:
        cb = 0;
        break;
    }

    return cb;
};



BOOL
Print_SmallSpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    CSmallSpinLock sl LOCK_DEFAULT_NAME;
#else // !LOCK_SMALL_SPIN_INSTRUMENTATION
    CSmallSpinLock sl;
#endif // !LOCK_SMALL_SPIN_INSTRUMENTATION

    ReadMemory((ULONG_PTR)pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSmallSpinLock (%p): Thread = %x\n",
            pvLock, sl.m_lTid);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



#ifdef TEST_LOCKS

BOOL
Print_SpinLock1(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock1 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock1 (%p): ssl = %x, Thread = %hd, Owners = %d, RW = %d\n",
            pvLock, sl.m_ssl.m_lLock, sl.m_nThreadId,
            (int) sl.m_cOwners, (int) sl.m_nRWState);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_SpinLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock2 (%p): Thread = %hd, Count = %hd\n",
            pvLock, sl.m_data.m_nThreadId, sl.m_data.m_cOwners);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}

#endif // TEST_LOCKS


BOOL
Print_SpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory((ULONG_PTR)pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock (%p): Thread = %d, Count = %d\n",
            pvLock,
            (sl.m_lTid & CSpinLock::THREAD_MASK) >> CSpinLock::THREAD_SHIFT,
            (sl.m_lTid & CSpinLock::OWNER_MASK) >> CSpinLock::OWNER_SHIFT);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_FakeLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_CritSec(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_ReaderWriterLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock sl LOCK_DEFAULT_NAME;

    ReadMemory((ULONG_PTR)pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock (%p): State = %x, Waiters = %d\n",
            pvLock, sl.m_nState, sl.m_cWaiting);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory((ULONG_PTR)pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock2 (%p): State = %x, Waiters = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock2::SL_STATE_MASK)
                >> CReaderWriterLock2::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock2::SL_WAITING_MASK)
                >> CReaderWriterLock2::SL_WAITING_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock3(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock3 sl LOCK_DEFAULT_NAME;

    ReadMemory((ULONG_PTR)pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock3 (%p): State = %x, Waiters = %d, "
            "Thrd = %x, Cnt = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock3::SL_STATE_MASK)
                >> CReaderWriterLock3::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock3::SL_WAITING_MASK)
                >> CReaderWriterLock3::SL_WAITING_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_THREAD_MASK)
                >> CReaderWriterLock3::SL_THREAD_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_OWNER_MASK)
                >> CReaderWriterLock3::SL_OWNER_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
PrintLock(
    LOCK_LOCKTYPE lt,
    IN PVOID      pvLock,
    IN INT        nVerbose)
{
    BOOL f = FALSE;
    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        f = Print_SmallSpinLock(pvLock, nVerbose);
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        f = Print_SpinLock1(pvLock, nVerbose);
        break;
    case LOCK_SPINLOCK2:
        f = Print_SpinLock2(pvLock, nVerbose);
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        f = Print_SpinLock(pvLock, nVerbose);
        break;
    case LOCK_FAKELOCK:
        f = Print_FakeLock(pvLock, nVerbose);
        break;
    case LOCK_CRITSEC:
        f = Print_CritSec(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK:
        f = Print_ReaderWriterLock(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK2:
        f = Print_ReaderWriterLock2(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK3:
        f = Print_ReaderWriterLock3(pvLock, nVerbose);
        break;
    default:
        f = FALSE;
        break;
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\enumheap.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    enumheap.cxx

Abstract:

    This module implements a heap enumerator.

Author:

    Keith Moore (keithmo) 31-Oct-1997

Revision History:

--*/

#include "precomp.hxx"


BOOLEAN
EnumProcessHeaps(
    IN PFN_ENUMHEAPS EnumProc,
    IN PVOID Param,
    IN HANDLE hCurrentProcess
    )

/*++

Routine Description:

    Enumerates all heaps in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each heap.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    PVOID * heapList;
    ULONG numHeaps;
    ULONG i;
    ULONGLONG remotePeb;
    PEB peb;
    HEAP heap;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    heapList = NULL;

    //
    // Get the process info.
    //

    GetPebAddress(0, &remotePeb);

    if( !ReadMemory(
            remotePeb,
            &peb,
            sizeof(peb),
            NULL
            ) ) {
        goto cleanup;
    }

    //
    // Allocate an array for the heap pointers, then read them from
    // the debugee.
    //

    numHeaps = peb.NumberOfHeaps;

    heapList = (PVOID *)malloc( numHeaps * sizeof(PVOID) );

    if( heapList == NULL ) {
        goto cleanup;
    }

    if( !ReadMemory(
            (ULONG_PTR)peb.ProcessHeaps,
            heapList,
            numHeaps * sizeof(PVOID),
            NULL
            ) ) {
        goto cleanup;
    }

    //
    // Now that we have the heap list, we can scan it and invoke the
    // enum proc.
    //

    for( i = 0 ; i < numHeaps ; i++ ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        if( !ReadMemory(
                (ULONG_PTR)heapList[i],
                &heap,
                sizeof(heap),
                NULL
                ) ) {
            goto cleanup;
        }

        if( heap.Signature != HEAP_SIGNATURE ) {
            dprintf(
                "Heap @ %p has invalid signature %08lx\n",
                heapList[i],
                heap.Signature
                );
            goto cleanup;
        }

        if( !EnumProc(
                Param,
                &heap,
                (PHEAP)heapList[i],
                i
                ) ) {
            break;
        }

    }

    //
    // Success!
    //

    result = TRUE;

cleanup:

    if( heapList != NULL ) {
        free( heapList );
    }

    return result;

}   // EnumProcessHeaps

BOOLEAN
EnumVirtualAllocdBlocks(
    IN PLIST_ENTRY pLocalHead,
    IN PLIST_ENTRY pRemoteHead,
    IN PFN_ENUMHEAPSEGMENTENTRIES EnumProc,
    IN PVOID Param)
{
    PLIST_ENTRY pRemoteNext;
    PHEAP_VIRTUAL_ALLOC_ENTRY pRemoteAddress;
    HEAP_VIRTUAL_ALLOC_ENTRY LocalAddress;

    pRemoteNext = pLocalHead->Flink;

    while (pRemoteNext != pRemoteHead)
    {
        pRemoteAddress = CONTAINING_RECORD(pRemoteNext,
                                           HEAP_VIRTUAL_ALLOC_ENTRY,
                                           Entry);

        if (!ReadMemory((ULONG_PTR)pRemoteAddress,
                        &LocalAddress,
                        sizeof(LocalAddress),
                        NULL))
        {
            return FALSE;
        }

        if (!EnumProc(Param,
                      &LocalAddress.BusyBlock,
                      &pRemoteAddress->BusyBlock))
        {
            return FALSE;
        }

        pRemoteNext = LocalAddress.Entry.Flink;
    }

    return TRUE;
}


BOOLEAN
EnumHeapSegments(
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN PFN_ENUMHEAPSEGMENTS EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heap segments within a heap.

Arguments:

    LocalHeap - Pointer to a local copy of the HEAP to enumerate.

    RemoteHeap - The actual address of the heap in the debugee.

    EnumProc - An enumeration proc that will be invoked for each heap
        segment.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    ULONG i;
    HEAP_SEGMENT heapSegment;

    //
    // Scan the segments.
    //

    for( i = 0 ; i < HEAP_MAXIMUM_SEGMENTS ; i++ ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        if( LocalHeap->Segments[i] != NULL ) {

            //
            // Read the segment, invoke the enumeration proc.
            //

            if( !ReadMemory(
                    (ULONG_PTR)LocalHeap->Segments[i],
                    &heapSegment,
                    sizeof(heapSegment),
                    NULL
                    ) ) {
                goto cleanup;
            }

            if( heapSegment.Signature != HEAP_SEGMENT_SIGNATURE ) {
                dprintf(
                    "HeapSegment @ %p has invalid signature %08lx\n",
                    LocalHeap->Segments[i],
                    heapSegment.Signature
                    );
                goto cleanup;
            }

            if( !EnumProc(
                    Param,
                    &heapSegment,
                    LocalHeap->Segments[i],
                    i
                    ) ) {
                break;
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapSegments


BOOLEAN
EnumHeapSegmentEntries(
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN PFN_ENUMHEAPSEGMENTENTRIES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heap entries in a heap segment.

Arguments:

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT to
        enumerate.

    RemoteHeapSegment - The actual address of hte heap segment in the
        debugee.

    EnumProc - An enumeration proc that will be invoked for each heap
        segment.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    PHEAP_ENTRY lastHeapEntry;
    PHEAP_ENTRY remoteHeapEntry;
    HEAP_ENTRY localHeapEntry;
    PHEAP_UNCOMMMTTED_RANGE remoteUCR;
    HEAP_UNCOMMMTTED_RANGE localUCR;

    //
    // Snag the beginning & ending limits of this segment.
    //

    remoteHeapEntry = LocalHeapSegment->FirstEntry;
    lastHeapEntry = LocalHeapSegment->LastValidEntry;

    //
    // If this segment has one or more uncommitted ranges, then
    // read the first one.
    //

    remoteUCR = LocalHeapSegment->UnCommittedRanges;

    if( remoteUCR != NULL ) {
        if( !ReadMemory(
                (ULONG_PTR)remoteUCR,
                &localUCR,
                sizeof(localUCR),
                NULL
                ) ) {
            goto cleanup;
        }
    }

    //
    // Scan the entries.
    //

    while(  remoteHeapEntry < lastHeapEntry ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        //
        // Read the heap entry, invoke the enumeration proc.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteHeapEntry,
                &localHeapEntry,
                sizeof(localHeapEntry),
                NULL
                ) ) {
           goto cleanup;
        }

        if( !EnumProc(
                Param,
                &localHeapEntry,
                remoteHeapEntry
                ) ) {
            break;
        }

        //
        // Advance to the next entry.
        //

        remoteHeapEntry = (PHEAP_ENTRY)( (PUCHAR)remoteHeapEntry +
            ( localHeapEntry.Size << HEAP_GRANULARITY_SHIFT ) );

        //
        // If this is the last entry in this run, then we'll need
        // some special handling to skip over the uncommitted ranges
        // (if any).
        //

        if( localHeapEntry.Flags & HEAP_ENTRY_LAST_ENTRY ) {

            if( remoteUCR == NULL ) {
                break;
            }

            //
            // Skip the uncommitted range, then read the next uncommitted
            // range descriptor if available.
            //

            remoteHeapEntry = (PHEAP_ENTRY)( (PUCHAR)remoteHeapEntry +
                localUCR.Size );

            remoteUCR = localUCR.Next;

            if( remoteUCR != NULL ) {
                if( !ReadMemory(
                        (ULONG_PTR)remoteUCR,
                        &localUCR,
                        sizeof(localUCR),
                        NULL
                        ) ) {
                   goto cleanup;
                }
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapSegmentEntries


BOOLEAN
EnumHeapFreeLists(
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN PFN_ENUMHEAPFREELISTS EnumProc,
    IN PVOID Param
    )
{

    BOOLEAN result = FALSE;
    ULONG i;
    PLIST_ENTRY nextEntry;
    PHEAP_FREE_ENTRY remoteFreeHeapEntry;
    HEAP_FREE_ENTRY localFreeHeapEntry;

    //
    // Scan the free lists.
    //

    for( i = 0 ; i < HEAP_MAXIMUM_FREELISTS ; i++ ) {

        nextEntry = LocalHeap->FreeLists[i].Flink;

        while( nextEntry != &RemoteHeap->FreeLists[i] ) {

            if( CheckControlC() ) {
                goto cleanup;
            }

            remoteFreeHeapEntry = CONTAINING_RECORD(
                                      nextEntry,
                                      HEAP_FREE_ENTRY,
                                      FreeList
                                      );

            //
            // Read the heap entry, invoke the enumerator.
            //

            if( !ReadMemory(
                    (ULONG_PTR)remoteFreeHeapEntry,
                    &localFreeHeapEntry,
                    sizeof(localFreeHeapEntry),
                    NULL
                    ) ) {
                goto cleanup;
            }

            if( !EnumProc(
                    Param,
                    &localFreeHeapEntry,
                    remoteFreeHeapEntry
                    ) ) {
                break;
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapFreeLists
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\dbgthunk.cxx ===
/*++


   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       dbgthunk.cxx

   Abstract:
       This module defines all thunks for inlined functions, so that the
       debugger extension DLL can be peacefully linked.

   Author:

       Murali R. Krishnan    ( MuraliK )     24-Aug-1997

   Environment:
       Debugging Mode - NTSD Debugger Extension DLL

   Project:

       IIS Debugger Extensions DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"

# undef DBG_ASSERT

# define minSize(a, b)  (((a) < (b)) ? (a) : (b))


DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *   Debugger Utility Functions
 ************************************************************/


/************************************************************
 *    Utility Functions
************************************************************/

VOID
dstring( CHAR * pszName, PVOID pvString, DWORD cbLen)
/*++
  Description:
    This function reads the data from the debuggee process at
    address [pvString] for specified length [cbLen] and echoes
    the string back on the debugger window.

  Arguments:
    pszName - pointer to string containing the name of the string read
    pvString - pointer to VOID specifying the location of the string
               in the debugee process
    cbLen   - count of bytes to be read at [pvString]

  Returns:
     None
--*/
{
    CHAR rgchString[10240];
    DWORD cLength = minSize( cbLen, sizeof(rgchString) -1);

    //
    // Read the data block from the debuggee process into local buffer
    //
    moveBlock( rgchString, (ULONG_PTR)pvString, cLength);

    rgchString[cLength] = '\0'; // terminate the string buffer
    dprintf( "%s = %s\n", pszName, rgchString);

    return;
} // dstring()



VOID
PrintLargeInteger( CHAR * pszName, LARGE_INTEGER * pli)
{
    CHAR  szLargeInt[100];

    RtlLargeIntegerToChar( pli,  // large integer location
                           10,   // base for conversion
                           sizeof(szLargeInt),
                           szLargeInt );
    dprintf( " %30s = %s\n", pszName, szLargeInt);
    return;

} // PrintLargeInteger()

VOID
Print2Dwords( CHAR * pszN1, DWORD d1,
              CHAR * pszN2, DWORD d2
              )
{
    dprintf("    %25s =%8d  %25s =%8d\n",
             pszN1, d1,
             pszN2, d2
             );
    return;
} // Print2Dwords()



BOOL
EnumLinkedList(
    IN LIST_ENTRY  *       pListHead,
    IN PFN_LIST_ENUMERATOR pfnListEnumerator,
    IN CHAR                chVerbosity,
    IN DWORD               cbSizeOfStructure,
    IN DWORD               cbListEntryOffset
    )
/*++
  Description:
    This function iterates over the NT's standard LIST_ENTRY structure
    (doubly linked circular list with header) and makes callbacks for
    objects found on the list.

  Arguments:
    pListHead  - pointer to List head in the debugee process
    pfnListEnumerator - pointer to callback function for the object on the list
    chVerbosity - character indicating the verbosity level desired
    cbSizeOfStructure - count of bytes of object's size
    cbListEntryOffset - count of bytes of offset of the List entry structure
                           inside the containing object

  Returns:
     TRUE on successful enumeration
     FALSE on failure
--*/
{
# define MAX_STRUCTURE_SIZE        (20480)
    CHAR           rgch[MAX_STRUCTURE_SIZE];
    PVOID          pvDebuggee = NULL;
    PVOID          pvDebugger = (PVOID ) rgch;

    LIST_ENTRY     leListHead;
    LIST_ENTRY *   pListEntry;

    CHAR           Symbol[256];
    DWORD          cItems = 0;

    if ( NULL == pListHead) {
        dprintf( "Invalid List given \n");
        return (FALSE);
    }

    if ( MAX_STRUCTURE_SIZE < cbSizeOfStructure) {
        dprintf( "Given size for structure %d exceeds default max %d bytes\n",
                 cbSizeOfStructure, MAX_STRUCTURE_SIZE);
        return (FALSE);
    }

    // make a local copy of the list head for navigation purposes
    MoveWithRet( leListHead, (ULONG_PTR)pListHead, FALSE);

    for ( pListEntry  = leListHead.Flink;
          pListEntry != pListHead;
          )
    {
        if ( CheckControlC() )
        {
            return (FALSE);
        }

        pvDebuggee = (PVOID ) ((PCHAR ) pListEntry - cbListEntryOffset);

        // make a local copy of the debuggee structure
        MoveBlockWithRet( rgch, (ULONG_PTR)pvDebuggee, cbSizeOfStructure, FALSE);

        cItems++;

        if( pfnListEnumerator ) {
            (*pfnListEnumerator)( pvDebuggee, pvDebugger, chVerbosity, cItems);
        }

        MoveWithRet( pListEntry, (ULONG_PTR)&pListEntry->Flink, FALSE );
    } // for all linked list entries

    dprintf( "%d entries traversed\n", cItems );

    return (TRUE);
} // EnumLinkedList()



/*++
  Description:
    COM objects registered as LocalServer result in running in a separate
    process. The base process communicates with these COM objects using RPC.
    It is often required to find the process id of destination process.


    The function cracks the process id of the target process given the first
    parameter to the function
       ole32!CRpcChannelBuffer__SendReceive()

  Argument:
  arg1 - pointer to string containing the parameter that is the hex-value
          of the RPC structure's location (which is the first param of
          function ole32!CRpcChannelBuffer__SendReceive())

 Standard NTSD parameters:
    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

  Returns:
    None

--*/
DECLARE_API( rpcoop )
{
#if _WIN64
    dprintf("rpcoop: Not implemented for 64bit");
#else
    DWORD *   pRpcParam1;
    DWORD    dwContent;

    while (*args == ' ')
        args++;

    if ( !*args )
    {
        PrintUsage( "rpcoop" );
        return;
    }

    if ( *args == '-' )
    {
        args++;

        if ( *args == 'h' )
        {
            PrintUsage( "rpcoop" );
            return;
        }

    } // while

    //
    //  Treat the argument as the param1 of the RPC function
    //

    pRpcParam1 = (DWORD * ) GetExpression( args );

    if ( !pRpcParam1 )
    {
        dprintf( "dtext.rpcoop: Unable to evaluate \"%s\"\n",
                 args );

        return;
    }

    //
    // get the contents of the memory at seventh DWORD to pRpcParam1
    // ie. get [pRpcParam1 + 0x6]
    //  - this is valid based on NT 4.0 SP3 code base :(
    //
    move( dwContent, (ULONG_PTR)pRpcParam1 + 0x6 );

    //
    // dwContent now contains the address of another structure
    //   that carries the remote process Id
    // get the contents of the memory at seventh DWORD to dwContent
    // ie. get [dwContent + 9]
    //  - this is valid based on NT 4.0 SP3 code base :(
    //
    DWORD  dwProcessId;

    move( dwProcessId, (ULONG_PTR)(((LPDWORD ) dwContent) + 9));

    //
    // dump the process id to debugger screen
    //
    dprintf("\tRPC process ID = %d (0x%x)\n", dwProcessId, dwProcessId);
#endif
    return;
} // DECLARE_API( rpcoop )

DECLARE_API( llc )

/*++

Routine Description:

    This function is called as an NTSD extension to count the LIST_ENTRYs
    on a linked list.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    PLIST_ENTRY remoteListHead;

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( *args == '\0' ) {
        PrintUsage( "llc" );
        return;
    }

    //
    // Get the list head.
    //

    remoteListHead = (PLIST_ENTRY)GetExpression( args );

    if( remoteListHead == NULL ) {
        dprintf( "!llc: cannot evaluate %s\n", args );
        return;
    }

    //
    // Let the enumerator do the dirty work.
    //

    EnumLinkedList(
        remoteListHead,
        NULL,
        0,
        sizeof(LIST_ENTRY),
        0
        );

}   // DECLARE_API( llc )


/************************************************************
 *  FAKE Functions
 *
 *  Fake the definitions of certain functions that belong only
 *   in the local compilation of w3svc & infocomm dlls
 *
 ************************************************************/

extern "C" {

    //
    // NTSD Extensions & CRTDLL likes to have the main() function
    // Let us throw this in as well, while we are in the business
    // of faking several other functions :)
    //

void _cdecl main( void )
{
    ;
}

}

__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
{ return (0); }




/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\enumpageheap.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    enumpageheap.cxx

Abstract:

    This module implements a page-heap enumerator.

Author:

    Anil Ruia (AnilR)      2-Mar-2001

Revision History:

--*/

#include "precomp.hxx"
#define DPH_HEAP_SIGNATURE       0xFFEEDDCC

BOOLEAN
EnumProcessPageHeaps(IN PFN_ENUMPAGEHEAPS EnumProc,
                     IN PVOID             Param)
/*++

Routine Description:

    Enumerates all pageheaps in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each heap.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/
{
    LIST_ENTRY *pRemotePageHeapHead;
    LIST_ENTRY LocalPageHeapHead;
    LIST_ENTRY *pListEntry;

    BOOL fPageHeapInitialized = GetExpression("poi(ntdll!RtlpDphPageHeapListInitialized)");
    if (!fPageHeapInitialized)
    {
        return TRUE;
    }

    pRemotePageHeapHead = (LIST_ENTRY *)GetExpression("ntdll!RtlpDphPageHeapList");
    if (pRemotePageHeapHead == NULL)
    {
        return TRUE;
    }

    if (!ReadMemory((ULONG_PTR)pRemotePageHeapHead,
                    &LocalPageHeapHead,
                    sizeof(LocalPageHeapHead),
                    NULL))
    {
        dprintf("Unable to read pageheap listhead at %p\n",
                pRemotePageHeapHead);

        return FALSE;
    }

    for (pListEntry = LocalPageHeapHead.Flink;
         pListEntry != pRemotePageHeapHead;
         )
    {
        if (CheckControlC())
        {
            return TRUE;
        }

        DPH_HEAP_ROOT  LocalHeapRoot;
        PDPH_HEAP_ROOT pRemoteHeapRoot;

        pRemoteHeapRoot = CONTAINING_RECORD(pListEntry,
                                            DPH_HEAP_ROOT,
                                            NextHeap);

        if (!ReadMemory((ULONG_PTR)pRemoteHeapRoot,
                        &LocalHeapRoot,
                        sizeof(LocalHeapRoot),
                        NULL))
        {
            dprintf("Unable to read pageheap at %p\n",
                    pRemoteHeapRoot);

            return FALSE;
        }

        if(LocalHeapRoot.Signature != DPH_HEAP_SIGNATURE)
        {
            dprintf("Pageheap @ %p has invalid signature %08lx\n",
                    pRemoteHeapRoot,
                    LocalHeapRoot.Signature);

            return FALSE;
        }

        if (!EnumProc(Param,
                      &LocalHeapRoot,
                      pRemoteHeapRoot))
        {
            dprintf("Error enumerating pageheap at %p\n",
                    pRemoteHeapRoot);

            return FALSE;
        }

        pListEntry = LocalHeapRoot.NextHeap.Flink;
    }

    return TRUE;
}

BOOLEAN
EnumPageHeapBlocks(IN PDPH_HEAP_BLOCK        pRemoteBlock,
                   IN PFN_ENUMPAGEHEAPBLOCKS EnumProc,
                   IN PVOID                  Param)
{
    BOOLEAN        result = TRUE;
    DPH_HEAP_BLOCK LocalBlock;

    while (pRemoteBlock != NULL)
    {
        if (CheckControlC())
        {
            break;
        }

        if (!ReadMemory((ULONG_PTR)pRemoteBlock,
                        &LocalBlock,
                        sizeof(LocalBlock),
                        NULL))
        {
            dprintf("Unable to read pageheap block at %p\n",
                    pRemoteBlock);

            result = FALSE;
            break;
        }

        if(!EnumProc(Param,
                     &LocalBlock,
                     pRemoteBlock))
        {
            result = FALSE;
            break;
        }

        pRemoteBlock = LocalBlock.pNextAlloc;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\enummod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    enummod.cxx

Abstract:

    This module implements a remote module enumerator.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "precomp.hxx"


BOOLEAN
EnumModules(
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all loaded modules in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each module.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    ULONGLONG remotePeb;
    PPEB peb;
    PPEB_LDR_DATA ldr;
    PLIST_ENTRY ldrHead, ldrNext;
    PLDR_DATA_TABLE_ENTRY ldrEntry;
    LDR_DATA_TABLE_ENTRY ldrEntryData;
    WCHAR tmpName[MAX_PATH];
    MODULE_INFO moduleInfo;

    //
    // Get the process info.
    //

    GetPebAddress(0, &remotePeb);
    peb = (PPEB)remotePeb;

    if( peb == NULL ) {
        return FALSE;
    }

    //
    // ldr = peb->Ldr
    //

    if( !ReadMemory(
            (ULONG_PTR)&peb->Ldr,
            &ldr,
            sizeof(ldr),
            NULL
            ) ) {
        return FALSE;
    }

    ldrHead = &ldr->InMemoryOrderModuleList;

    //
    // ldrNext = ldrHead->Flink;
    //

    if( !ReadMemory(
            (ULONG_PTR)&ldrHead->Flink,
            &ldrNext,
            sizeof(ldrNext),
            NULL
            ) ) {
        return FALSE;
    }

    while( ldrNext != ldrHead ) {

        if( CheckControlC() ) {
            break;
        }

        //
        // Read the LDR_DATA_TABLE_ENTRY structure and the module name.
        //

        ldrEntry = CONTAINING_RECORD(
                       ldrNext,
                       LDR_DATA_TABLE_ENTRY,
                       InMemoryOrderLinks
                       );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntry,
                &ldrEntryData,
                sizeof(ldrEntryData),
                NULL
                ) ) {
            return FALSE;
        }

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.BaseDllName.Buffer,
                tmpName,
                ldrEntryData.BaseDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.BaseName,
            "%ws",
            tmpName
            );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.FullDllName.Buffer,
                tmpName,
                ldrEntryData.FullDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.FullName,
            "%ws",
            tmpName
            );

        moduleInfo.DllBase = (ULONG_PTR)ldrEntryData.DllBase;
        moduleInfo.EntryPoint = (ULONG_PTR)ldrEntryData.EntryPoint;
        moduleInfo.SizeOfImage = (ULONG)ldrEntryData.SizeOfImage;

        //
        // Invoke the callback.
        //

        if( !(EnumProc)(
                Param,
                &moduleInfo
                ) ) {
            break;
        }

        ldrNext = ldrEntryData.InMemoryOrderLinks.Flink;

    }

    return TRUE;

}   // EnumModules
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\dumpoff.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dumpoff.cxx

Abstract:

    Structure dumper

Author:

    Bilal Alam      (balam)     Oct-17-1998 Initial Revision

--*/

#include "precomp.hxx"
#include "oemdbi.h"
#include "cvinfo.h"
#include "imagehlp.h"

#define INVALID_LENGTH              ((DWORD)-1)

#define MAX_MEMBERNAME_LENGTH       256
#define MAX_TYPENAME_LENGTH         256

typedef DWORD (*PFN_READ_MEMORY) (
    VOID * address, 
    DWORD cbBytes, 
    VOID *pBuffer 
);

typedef DWORD (*PFN_PRINTF) (
    CHAR * pszBuffer,
    DWORD cbBytes
);

typedef struct _STRUCTURE_MEMBER {
    CHAR                    achMemberName[ MAX_MEMBERNAME_LENGTH + 1 ];
    DWORD                   cbOffset;
    DWORD                   cbMaxSize;
} STRUCTURE_MEMBER, *PSTRUCTURE_MEMBER;

typedef struct _STRUCTURE_TEMPLATE {
    CHAR                    achName[ MAX_TYPENAME_LENGTH + 1 ];
    PSTRUCTURE_MEMBER       pMembers;
    DWORD                   cMembers;
    DWORD                   cUseful;
    DWORD                   cbTotalSize;
    DWORD                   Type;
} STRUCTURE_TEMPLATE, *PSTRUCTURE_TEMPLATE;

DWORD
GetOffset(
    BYTE *              pBuffer,
    DWORD *             pcbOffset
);

DWORD
ReadFieldList(
    TPI *               pTypeInterface,
    STRUCTURE_TEMPLATE* pStructure,
    lfFieldList *       pFieldList, 
    DWORD               cbLen,
    DWORD               dwFlags
);

DWORD
ReadBClass(
    TPI *               pTypeInterface,
    lfBClass *          pBClass, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadMember(
    lfMember*           pMember, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadNestType(
    lfNestType*         pNestType, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadOneMethod(
    lfOneMethod*        pOneMethod, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadMethod(
    lfMethod*           pMethod, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadVTable(
    lfVFuncTab*         pVTable, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadStaticMember(
    lfSTMember*         pStaticMember, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
InitializeStructureTemplate(
    PSTRUCTURE_TEMPLATE pTemplate
);

DWORD
TerminateStructureTemplate(
    PSTRUCTURE_TEMPLATE pTemplate
);

VOID
DumpoffUsage(
    VOID
);

DWORD
OutputTemplate(
    STRUCTURE_TEMPLATE *    pTemplate,
    CHAR *                  pszMemberName,
    DWORD                   dwFlags,
    PVOID                   pvAddress,
    PFN_READ_MEMORY         pfnReadMemory,
    PFN_PRINTF              pfnPrintf 
);

DWORD
BuildMemberList(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN TPI *                pTypeInterface,
    IN TI                   tiType,
    IN BOOL                 fTypeSizeOnly
);

DWORD
BuildMemberListForTypeName(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN PDB *                pPDB,
    IN LPSTR                pszTypeName
);

DWORD
FindMembersOfTypeSize(
    IN PDB *                pPDB,
    IN DWORD                cbSize,
    IN PFN_PRINTF           pfnPrintf
);

DWORD
OutputTemplate(
    STRUCTURE_TEMPLATE *    pTemplate,
    CHAR *                  pszMemberName,
    DWORD                   dwFlags,
    PVOID                   pvAddress,
    PFN_READ_MEMORY         pfnReadMemory,
    PFN_PRINTF              pfnPrintf 
)
/*++

Routine Description:

    Output a structure template.
    
    If pvAddress is NULL, then this function will output a general template
    of the structure, listing each member along with its offset from the 
    start of the structure.
    
    If pvAddress is non-NULL, then this function will output the structure
    with the memory at pvAddress cast as this type.  
    
    If pszMemberName is NULL, then the above two statements apply to all 
    members of the structure.  If pszMember is not NULL, then the statements
    apply only the member whose name is pszMember.
    
Arguments:

    pTemplate - Template to dump
    pszMemberName - Optional member name filter
    dwFlags - Flags describing Output() details.  Currently not supported
    pvAddress - Optional address of memory to cast as type
    pfnReadMemory - Provides read memory functionality
    pfnPrintf - Provides printf functionality

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD                   cCounter;
    BOOL                    fDidSomething = FALSE;
    PBYTE                   pBuffer = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    CHAR                    achFormat[ 256 ];
    DWORD                   cbRunningLength;
    BOOL                    fLastBitField = FALSE;
    DWORD                   cBitField = 0;
    DWORD                   dwTotalMask;
    DWORD                   cbSize;
    INT                     i;
    
    pBuffer = (PBYTE) LocalAlloc( LPTR, pTemplate->cbTotalSize );
    if ( pBuffer == NULL )
    {
        dwError = GetLastError();
        goto Finished;
    }

    // 
    // If address is specified, then read the amount required for this 
    // structure.  Otherwise, we are simply dumping the template and thus
    // output the size of the type 
    //
    
    if ( pvAddress )
    {
        dwError = pfnReadMemory( pvAddress, pTemplate->cbTotalSize, pBuffer );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Finished;
        }
    }
    else
    {
        _snprintf( achFormat,
                   sizeof( achFormat ),
                   "sizeof( %s %s ) = 0x%X bytes (%d bytes)\n",
                   pTemplate->Type == LF_CLASS ? "class" : "struct",
                   pTemplate->achName,
                   pTemplate->cbTotalSize,
                   pTemplate->cbTotalSize );
        pfnPrintf( achFormat, -1 );
    }
    
    //
    // Iterate through consequential members of type
    //
   
    for( cCounter = 0;
         cCounter < pTemplate->cUseful;
         cCounter++ )
    {
    
        //
        // Do filtering on member name if specified
        //
    
        if ( pszMemberName )
        {
            if ( fDidSomething )
            {
                break;
            }
            
            if ( strcmp( pTemplate->pMembers[ cCounter ].achMemberName,
                         pszMemberName ) )
            {
                continue;
            }
        }
        
        //
        // Dump member name
        //
        
        cbRunningLength = pfnPrintf( pTemplate->pMembers[ cCounter ].achMemberName,
                                     -1 );
        
        //
        // Formatting junk
        //
        
        for ( i = cbRunningLength;
              i < 25;
              i++ )
        {
            cbRunningLength += pfnPrintf( " ", -1 );
        }
        
        cbRunningLength += pfnPrintf( " = ", -1 );
        
        achFormat[ 0 ] = '\0';
        cbSize = pTemplate->pMembers[ cCounter ].cbMaxSize;
       
        if ( !pvAddress )
        {
            //
            // Just dumping template.  Output the offset from the start of 
            // the type
            //
        
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "+%8X",
                       pTemplate->pMembers[ cCounter ].cbOffset );
        }
        else if ( !cbSize ||
             ( ( cbSize == sizeof( DWORD ) ) && fLastBitField ) ) 
        {
            //
            // If the maxsize is 0, then this must be a bitfield
            // If the maxsize is 4, and the last item was a bit field, then
            // this must be the last bit of the bit field.
            //
            // BUGBUG:  Need to make this work for bit fields larger than 32
            //
            
            if ( !fLastBitField )
            {
                fLastBitField = TRUE;
            }
            cBitField++;
            
            dwTotalMask = (DWORD) *(DWORD*) ((PBYTE)pBuffer+
                             pTemplate->pMembers[ cCounter ].cbOffset);
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%s",
                       (dwTotalMask & (1 << ( cBitField - 1 ))) ? "TRUE" : "FALSE" );
            
            if ( cbSize == sizeof( DWORD ) )
            {
                fLastBitField = FALSE;
                cBitField = 0;
            }
        }
        else if ( cbSize != sizeof( DWORD ) )
        {
            //
            // If this structure is not a DWORD in size, then assume we don't 
            // know how to dump it affectly.  In this case, we will simply
            // dump out the address at which the member data starts
            //
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%08p..",
                       (PBYTE) pvAddress +
                         pTemplate->pMembers[ cCounter ].cbOffset );
        }
        else
        {
            //
            // This is a DWORD sized member.  We can dump out the value
            // effectively -> so we do it
            //
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%08X",
                       (DWORD) *(DWORD*) ((PBYTE)pBuffer+ 
                         pTemplate->pMembers[ cCounter ].cbOffset ) );
        }
        
        cbRunningLength += pfnPrintf( achFormat, -1 );
        
        //
        // Two column display.  Given 80 columns, seems like the only 
        // reasonable setting (maybe 1 column is useful?)
        //
        
        if ( pszMemberName ||
             ( cCounter % 2 ) )
        {
            pfnPrintf( "\n", -1 );
        }
        else
        {
            for ( i = cbRunningLength;
                  i < 40;
                  i++ )
            {
                pfnPrintf( " ", -1 );
            }
        }
        
        //
        // Keep tabs on whether we actually dumped something 
        //
        
        fDidSomething = TRUE;
    }
    
    if ( !fDidSomething )
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }
    
    pfnPrintf( "\n", -1 );

Finished:
    if ( pBuffer != NULL )
    {
        LocalFree( pBuffer );
    }
    return dwError;
}

DWORD
BuildMemberListForTypeName(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN PDB *                pPDB,
    IN LPSTR                pszTypeName
)
/*++

Routine Description:

    Build the structure template for a given type
    
Arguments:

    pTemplate - Template to populate (must have been previously inited)
    pPDB - PDB structure opened using MSDBI!PDBOpen
    pszTypeName - Name of type

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    TPI *                   pTypeInterface = NULL;
    TI                      RootTI;
    DWORD                   dwError = ERROR_SUCCESS;
    PB                      pb;
    
    if ( !pTemplate || !pPDB || !pszTypeName )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    //
    // Get the type interface
    //
    
    if ( !PDBOpenTpi( pPDB,
                      pdbRead,
                      &pTypeInterface ) )
    {
        dwError = GetLastError();
        goto Finished;
    }

    //
    // Does this PDB have the necessary type information?
    //

    if ( TypesQueryTiMinEx( pTypeInterface ) ==
         TypesQueryTiMacEx( pTypeInterface ) )
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }
    
    //
    // Lookup with specified type
    //
    
    if ( !TypesQueryTiForUDTEx( pTypeInterface,
                                pszTypeName,
                                TRUE,
                                &RootTI) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    strncpy( pTemplate->achName,
             pszTypeName,
             sizeof( pTemplate->achName ) - 1 );
    
    dwError = BuildMemberList( pTemplate,
                               pTypeInterface,
                               RootTI,
                               FALSE );

Finished:

    if ( pTypeInterface != NULL )
    {
        TypesClose( pTypeInterface );
    }
    return dwError;
}

DWORD
FindMembersOfTypeSize(
    IN PDB *                pPDB,
    IN DWORD                cbSize,
    IN PFN_PRINTF           pfnPrintf
)
/*++

Routine Description:

    Find members of a certain size.  Output these types
    
Arguments:

    pPDB - PDB structure opened using MSDBI!PDBOpen
    cbSize - Size in question
    pfnPrintf - Output routine

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    STRUCTURE_TEMPLATE      Template;
    TPI *                   pTypeInterface = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    TI                      tiMin;
    TI                      tiMax;
    TI                      tiCursor;
    CHAR                    achLast[ MAX_TYPENAME_LENGTH ];
    CHAR                    achBuffer[ 256 ];

    if ( !pPDB || !pfnPrintf || !cbSize )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    //
    // Get the type interface
    //
    
    if ( !PDBOpenTpi( pPDB,
                      pdbRead,
                      &pTypeInterface ) )
    {
        dwError = GetLastError();
        goto Finished;
    }

    //
    // Get min/max type indices
    //

    tiMin = TypesQueryTiMinEx( pTypeInterface );
    tiMax = TypesQueryTiMacEx( pTypeInterface );

    if ( tiMin == tiMax )
    {
        //
        // Probably no type info available in PDB
        //

        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }

    //
    // Cursor thru
    //

    achLast[ 0 ] = '\0';

    for ( tiCursor = tiMin;
          tiCursor < tiMax;
          tiCursor++ )
    {
        dwError = BuildMemberList( &Template,
                                   pTypeInterface,
                                   tiCursor,
                                   TRUE );
        if ( dwError != ERROR_SUCCESS )
        {
            if ( dwError == ERROR_NOT_SUPPORTED )
            {
                //
                // Not a struct/class. Ignore
                //

                dwError = ERROR_SUCCESS;
                continue;
            }
            else
            {
                break;
            }
        }

        if ( Template.cbTotalSize == cbSize &&
             strcmp( Template.achName, achLast ) )
        {
            pfnPrintf( Template.Type == LF_CLASS ? "class " : "struct ", -1 );
            pfnPrintf( Template.achName, -1 );
            pfnPrintf( "\n", -1 );

            strncpy( achLast,
                     Template.achName,
                     sizeof( achLast ) );
        }
        
    }
    
Finished:

    if ( pTypeInterface != NULL )
    {
        TypesClose( pTypeInterface );
    }
    return dwError;
}

DWORD
BuildMemberList(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN TPI *                pTypeInterface,
    IN TI                   tiType,
    IN BOOL                 fTypeSizeOnly
)
/*++

Routine Description:

    Build a template describing the given type.  This template contains
    an array of members representing the member of the type.
    
Arguments:

    pTemplate - Template to populate (must have been previously inited)
    pTypeInterface - Type interface
    tiType - Type ID to retrieve
    fStructSizeOnly - TRUE if we only need type size (and not the members)

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    TYPTYPE *               pType = NULL;
    lfStructure *           pStructure;
    lfFieldList *           pFieldList;
    PB                      pb;
    DWORD                   dwError = ERROR_SUCCESS;
    DWORD                   cbTotalSize = 0;
    DWORD                   cbStructSize = 0;
    DWORD                   cUseful;
    DWORD                   cbNameOffset;
    TI                      RootTI;

    if ( !pTypeInterface || !pTemplate )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    RootTI = tiType;
    
    //
    // Parse root record of the type, verifying that it is of type 
    // STRUCTURE or CLASS
    //
    
    if ( !TypesQueryPbCVRecordForTiEx( pTypeInterface,
                                       RootTI,
                                       &pb ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    pType = (TYPTYPE*) pb;

    if ( ( pType->leaf != LF_CLASS ) && 
         ( pType->leaf != LF_STRUCTURE ) )
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }
    pTemplate->Type = pType->leaf;
    
    pStructure = (lfStructure*) &(pType->leaf);

    cbNameOffset = GetOffset( pStructure->data, &cbStructSize );

    //
    // If we only need the overall structure size, then we can exit out now
    //

    if ( fTypeSizeOnly )
    {
        pTemplate->cbTotalSize = cbStructSize;

        memset( pTemplate->achName,
                0,
                sizeof( pTemplate->achName ) );

        strncpy( pTemplate->achName,
                 (LPSTR) pStructure->data + cbNameOffset + 1,
                 min( (DWORD) *(CHAR*)(pStructure->data + cbNameOffset),
                      sizeof( pTemplate->achName ) ) );

        goto Finished;
    }
    
    //
    // In allocating # of members for the structure, get upper bound by 
    // taking structure member count.
    //
    // BUGBUG:  Dynamically grow the list to avoid gross overestimation.
    //
    
    if ( pTemplate->cMembers < pStructure->count )
    {
        pTemplate->pMembers = (PSTRUCTURE_MEMBER) LocalAlloc( LPTR,
                                          sizeof( STRUCTURE_MEMBER ) *
                                            pStructure->count );
        if ( pTemplate->pMembers == NULL )
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto Finished;
        }

        pTemplate->cMembers = pStructure->count;
    }
    
    if ( !TypesQueryPbCVRecordForTi( pTypeInterface,
                                     pStructure->field,
                                     &pb ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    pType = (TYPTYPE*)pb;
    pFieldList = (lfFieldList*) &(pType->leaf);

    //
    // Read the list of the fields in the type
    //
    
    dwError = ReadFieldList( pTypeInterface,
                             pTemplate,
                             pFieldList,
                             pType->len,
                             0 );

    cUseful = pTemplate->cUseful;

    if ( cUseful && ( dwError == ERROR_SUCCESS ) )
    {
        pTemplate->pMembers[ cUseful - 1 ].cbMaxSize =
            cbStructSize - pTemplate->pMembers[ cUseful - 1 ].cbOffset;

        pTemplate->cbTotalSize = cbStructSize;
    }                                

Finished:

    return dwError;    
}

DWORD
ReadFieldList(
    IN TPI *                        pTypeInterface,
    IN STRUCTURE_TEMPLATE *         pTemplate,
    IN lfFieldList *                pFieldList,
    IN DWORD                        cbLen,
    IN DWORD                        dwFlags
)
/*++

Routine Description:

    Read the elements of the field list which represents the class/struct
    
Arguments:

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD               cbBytes = 0;
    PBYTE               pBuffer;
    DWORD               cbReturnSize = 0;
    BOOL                fExit = FALSE;
    CHAR                achMemberBuffer[ 256 ];
    DWORD               cbMemberBuffer;
    DWORD               dwError = ERROR_SUCCESS;
    DWORD               cFields = 0;
    DWORD               cbLastOffset = 0;

    while ( cbBytes < cbLen )
    {
        //
        // Account for padding the field list blob
        //
        
        for ( ; ; )
        {
            pBuffer = (PBYTE) pFieldList->data + cbBytes;
            if ( *(BYTE*)pBuffer < LF_PAD0 )
            {
                break;
            }
            cbBytes++;
        }
        
        //
        // After each padding block (if any), the first SHORT will contain
        // the field type of the next field in the struct/class.  Handle
        // each type accordingly.  If the handle function (Read*) returns 
        // a cbReturnSize of -1 then this type will not contribute to the
        // offsets in the struct/class.  For example, member functions.  
        //
        
        achMemberBuffer[ 0 ] = '\0';
        cbReturnSize = 0;
        cbMemberBuffer = sizeof( achMemberBuffer );
        
        switch ( *(USHORT*) pBuffer ) 
        {
        case LF_BCLASS:
            dwError = ReadBClass( pTypeInterface,
                                  (lfBClass*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
    
        case LF_MEMBER:
            dwError = ReadMember( (lfMember*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
            
        case LF_NESTTYPE:
            dwError = ReadNestType( (lfNestType*) pBuffer,
                                    &cbReturnSize,
                                    &cbBytes,
                                    achMemberBuffer,
                                    cbMemberBuffer );
            break;     
        
        case LF_ONEMETHOD:
            dwError = ReadOneMethod( (lfOneMethod*) pBuffer,
                                     &cbReturnSize,
                                     &cbBytes,
                                     achMemberBuffer,
                                     cbMemberBuffer );
            break;

        case LF_METHOD:
            dwError = ReadMethod( (lfMethod*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
       
        case LF_STMEMBER:
            dwError = ReadStaticMember( (lfSTMember*) pBuffer,
                                        &cbReturnSize,
                                        &cbBytes,
                                        achMemberBuffer,
                                        cbMemberBuffer );
            break;

        case LF_VFUNCTAB:
            dwError = ReadVTable( (lfVFuncTab*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
            
        default:
            fExit = TRUE;
            break;
        }
        
        if ( fExit )
        {
            break;
        }
        
        if ( dwError != ERROR_SUCCESS ||
             cbReturnSize == INVALID_LENGTH )
        {
            continue;
        }
        
        //
        // We got a useful member of the struct/class.  Add it to the 
        // template.
        //
        
        pTemplate->cUseful++;

        strncpy( pTemplate->pMembers[ cFields ].achMemberName,
                 achMemberBuffer,
                 sizeof( pTemplate->pMembers[ cFields ].achMemberName ) - 1 );

        pTemplate->pMembers[ cFields ].cbOffset = cbReturnSize;
        
        //
        // Calculate the maximum size of the previous member by taking the 
        // difference between the start offset of the member and the start 
        // offset of the previous member.  Note that this is not necessarily
        // the exact size because of potential alignment padding.  It is only
        // an upper bound on the size of the previous member.
        //
        
        if ( cFields )
        {
            pTemplate->pMembers[ cFields - 1 ].cbMaxSize =
                                            cbReturnSize - cbLastOffset;
        }
        
        cbLastOffset = cbReturnSize;
        
        cFields++;
    }
    
    return dwError;
}

DWORD
ReadBClass(
    IN TPI *                    pTypeInterface,
    IN lfBClass*                pBClass,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    OUT CHAR *                  pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of base class field
    
Arguments:

    pTypeInterface - MSDBI type interface
    pBClass - Points to a base class descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    PB                      pb;
    DWORD                   Offset;
    TYPTYPE*                pType;
    lfStructure *           pStructure;
    DWORD                   cbUnused;
    
    Offset = GetOffset( pBClass->offset, pcbReturnSize );
    *pcbOffset += sizeof( lfBClass ) + Offset;
    
    //
    // We have to lookup the name of the base class explicitly by using the 
    // index type in the base class descriptor
    //

    if ( !TypesQueryPbCVRecordForTiEx( pTypeInterface,
                                       pBClass->index,
                                       &pb ) )
    {
        return ERROR_FILE_NOT_FOUND;
    }
    
    //
    // Process/munge/extract
    // 
    
    pType = (TYPTYPE*)pb;
    pStructure = (lfStructure*) &(pType->leaf );

    Offset = GetOffset( pStructure->data, &cbUnused );
    
    memset( pszBuffer, 0, cbBuffer );
    memcpy( pszBuffer,
            (CHAR*) pStructure->data + Offset + 1,
            min( (DWORD) *(CHAR*) ( pStructure->data + Offset ), cbBuffer ) );
            
    return ERROR_SUCCESS;
}

DWORD
ReadMember(
    IN lfMember *               pMember,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a member
    
Arguments:

    pMember - Points to a member descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD Offset = GetOffset( pMember->offset, pcbReturnSize );

    memset( pszBuffer, 0, cbBuffer );
    memcpy( pszBuffer,
            (CHAR*) pMember->offset + Offset + 1,
            min( (DWORD) *(CHAR*) ( pMember->offset + Offset ), cbBuffer ) );
            
    *pcbOffset += sizeof( lfMember ) + Offset +  pMember->offset[Offset] + 1;

    return ERROR_SUCCESS;
}

DWORD
ReadOneMethod(
    IN lfOneMethod *            pOneMethod,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a non-overloaded member function.  
    We process this only to up the offset within the field list for 
    traversal purposes.  Member methods themselves have no affect on 
    the offsets/size of the data structure 
    
Arguments:

    pOneMethod - Method type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    CHAR *              pszSource = NULL;
    
    pszSource = (CHAR*) pOneMethod + sizeof( lfOneMethod );
    *pcbOffset += sizeof( lfOneMethod );
    if ( ( pOneMethod->attr.mprop == CV_MTintro ) ||
         ( pOneMethod->attr.mprop == CV_MTpureintro ) )
    {
        *pcbOffset += sizeof( LONG );
        pszSource += sizeof( LONG );
    }
    *pcbOffset += *(CHAR*)pszSource + 1;
    *pcbReturnSize = INVALID_LENGTH;

    return ERROR_SUCCESS;
}

DWORD
ReadMethod(
    IN lfMethod *               pMethod,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a member function.  We process this only to 
    up the offset within the field list for traversal purposes.  Member
    methods themselves have no affect on the offsets/size of the data 
    structure 
    
Arguments:

    pMethod - Method type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    *pcbOffset += sizeof( lfMethod ) + pMethod->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}

DWORD
ReadVTable(
    IN lfVFuncTab *             pVTable,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the vtable of the structure.
    
Arguments:

    pVTable - Vtable type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    *pcbOffset += sizeof( lfVFuncTab );
    
    strncpy( pszBuffer,
             "'vftable'",
             cbBuffer - 1 );

    //
    // Assume at the beginning of the data structure.  
    // 

    *pcbReturnSize = 0;
    
    return ERROR_SUCCESS;
}


DWORD
ReadStaticMember(
    IN lfSTMember *             pStaticMember,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
{
    *pcbOffset += sizeof( lfSTMember ) + pStaticMember->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}


DWORD
ReadNestType(
    IN lfNestType *             pNestType,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
{
    *pcbOffset += sizeof( lfNestType ) + pNestType->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}

DWORD
GetOffset(
    BYTE *              pBuffer,
    DWORD *             pcbOffset
)
/*++

Routine Description:

    Read the offset for the type record.  Then advance the cursor.
    
Arguments:

    pBuffer - Points to current position in field list buffer
    pcbOffset - Filled with offset of field member
    
Return Value:

    Amount to advance cursor to next field member

--*/
{
    USHORT leaf = *(USHORT*)pBuffer;
    
    if ( leaf < LF_NUMERIC )
    {
        *pcbOffset = leaf;
        return sizeof( leaf );
    }
    else
    {
        switch( leaf )
        {
        case LF_CHAR:
            *pcbOffset = *((char*)pBuffer);
            return sizeof(leaf) + sizeof(char);
        case LF_SHORT:
            *pcbOffset = *(short*)pBuffer;
            return sizeof(leaf) + sizeof(short);
        case LF_USHORT:
            *pcbOffset = *(USHORT*)pBuffer;
            return sizeof(leaf) + sizeof(USHORT);
        case LF_LONG:
            *pcbOffset = *(long*)pBuffer;
            return sizeof(leaf) + sizeof(long);
        case LF_ULONG:
            *pcbOffset = *(ULONG*)pBuffer;
            return sizeof(leaf) + sizeof(ULONG);
        }
    }
    return 0;
}

DWORD
InitializeStructureTemplate(
    IN PSTRUCTURE_TEMPLATE      pTemplate
)
/*++

Routine Description:

    Initialize structure template
    
Arguments:

    pTemplate - Template buffer to be initialized
    
Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( pTemplate == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pTemplate->pMembers       = NULL;
    pTemplate->cMembers       = 0;
    pTemplate->achName[ 0 ]   = '\0';
    pTemplate->cUseful        = 0;
    pTemplate->cbTotalSize    = 0;
    pTemplate->Type           = 0xFFFFFFFF;

    return ERROR_SUCCESS;
}

DWORD
TerminateStructureTemplate(
    IN PSTRUCTURE_TEMPLATE      pTemplate
)
/*++

Routine Description:

    Terminate structure template
    
Arguments:

    pTemplate - Template buffer to be terminated
    
Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( pTemplate == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pTemplate->pMembers )
    {
        LocalFree( pTemplate->pMembers );
        pTemplate->pMembers = NULL;
        pTemplate->cMembers = 0;
    }

    return ERROR_SUCCESS;
}

DWORD
OutputStructure(
    IN PDB *                    pDebug,
    IN CHAR *                   pszStructureType,
    IN CHAR *                   pszMemberName,
    IN DWORD                    dwFlags,
    IN VOID *                   pvAddress,
    IN PFN_READ_MEMORY          pfnReadMemory,
    IN PFN_PRINTF               pfnPrintf
)
/*++

Routine Description:

    Top level call to output a structure
    
Arguments:

    pDebug - PDB handle
    pszStructureType - Name of structure/class to dump
    pszMemberName - (optional) Name of particular member of structure to dump
    dwFlags - (not supported) 
    pvAddress - (optional) Address of start of structure
    pfnReadMemory - (optional) Function to read memory.  Not needed if 
                    pvAddress==NULL
    pfnPrintf - Output function

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    STRUCTURE_TEMPLATE          Template;
    DWORD                       dwError;
    
    if ( !pDebug || 
         !pszStructureType || 
         !pfnReadMemory || 
         !pfnPrintf )
    {
        return ERROR_INVALID_PARAMETER;    
    }

    dwError = InitializeStructureTemplate( &Template );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = BuildMemberListForTypeName( &Template,
                                          pDebug,
                                          pszStructureType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = OutputTemplate( &Template,
                              pszMemberName,
                              dwFlags,
                              pvAddress,
                              pfnReadMemory,
                              pfnPrintf );

    //
    // CODEWORK:  Cache the templates
    //

    TerminateStructureTemplate( &Template );

    return dwError;
}

DWORD
DoPrintf(
   CHAR *                   pszBuffer,
   DWORD                    cbBytes
)
/*++

Routine Description:

    Print out buffer
    
Arguments:

    pszBuffer - buffer to print
    cbBytes - Bytes to print

Return Value:

    Number of bytes printed

--*/
{
    dprintf( "%s", pszBuffer );
    return strlen( pszBuffer );
} 

DWORD
DoReadMemory(
    VOID *                  pvAddress,
    DWORD                   cbBytes,
    VOID *                  pBuffer 
)
/*++

Routine Description:

    Read debuggee memory into buffer
    
Arguments:

    pvAddress - Address to read
    cbBytes - # of bytes to read
    pBuffer - Buffer to be filled

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( ReadMemory( pvAddress, pBuffer, cbBytes, NULL ) )
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return GetLastError();
    }
}

VOID
DumpoffUsage(
    VOID
)
/*++

Routine Description:

    !dumpoff usage message
    
Arguments:

    None

Return Value:

    None

--*/
{
    dprintf(
        "Usage:  !dumpoff <pdb_file>!<type_name>[.<member_name>] [expression]\n"
        "        !dumpoff -s [<pdb_search_path>]\n"
        "\n"
        "pdb_file          Un-qualified name of PDB file (eg. KERNEL32, NTDLL)\n"
        "type_name         Name of type (struct/class) to dump, OR \n"
        "                  ==<cbHexSize> to dump struct/classes of size cbHexSize\n"
        "member_name       (optional) Name of member in type_name to dump\n"
        "expression        (optional) Address of memory to dump as type_name\n"
        "                  if not present, offset(s) are dumped\n"
        "pdb_search_path   Set the search path for PDBs\n"
        "\n"
        "Examples:  !dumpoff ntdll!_RTL_CRITICAL_SECTION 14d4d0\n"
        "           !dumpoff w3svc!HTTP_REQUEST._dwSignature w3svc!g_GlobalObj\n"
        "           !dumpoff ntdll!_RTL_CRITICAL_SECTION\n"
        "           !dumpoff w3svc!==840\n"
        "           !dumpoff -s \\\\mydrive\\pdbs;c:\\local\\pdbs\n"
    );
}

#if defined( _X86_ )
CHAR g_achPDBSearchPath[ 1024 ] = "\\\\x86fre\\symbols.pri\\retail\\dll";
#else
CHAR g_achPDBSearchPath[ 1024 ] = "\\\\alphafre\\symbols.pri\\retail\\dll";
#endif

DECLARE_API( dumpoff )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a structure
    based on debug info in PDB

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    CHAR *              pszPdb = NULL;
    CHAR *              pszType = NULL;
    CHAR *              pszAddress = NULL;
    CHAR *              pszMember = NULL;
    CHAR *              pszCursor = NULL;
    CHAR *              pszNext = NULL;
    CHAR                achArg1[ 256 ];
    CHAR                achArg2[ 256 ];
    CHAR                achBuffer[ 256 ] = "";
    CHAR                achFileName[ MAX_PATH + 1 ];
    CHAR                achFullPath[ MAX_PATH + 1 ];
    CHAR                achSymPath[ MAX_PATH + 1 ];
    BOOL                fRet;
    EC                  ec;
    PDB *               pDebug = NULL;
    DWORD               dwError;
    CHAR *              pszError = NULL;
    DWORD               cArguments;
    DWORD               cbSize;
    BOOL                fRetry = TRUE;

    //
    // get the debugger symbol path
    //

    fRet = SymGetSearchPath( hCurrentProcess,
                             achSymPath,
                             sizeof( achSymPath ) );
    if (!fRet )
    {
        //
        // If we couldn't get the default sym path, just use the SYSTEMROOT
        //

        dwError = GetEnvironmentVariableA( "SYSTEMROOT",
                                           achSymPath,
                                           sizeof( achSymPath ) );

        if ( dwError == 0 )
        {
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Unable to determine symbol path.  Error = %d\n",
                       GetLastError() );
            goto Finished;
        }
    }

    //
    // Parse out the argument. This is a fragile approach, but we
    // can live with that.
    // <pdbfile>!<type>[.member] [address]
    //

    cArguments = sscanf( (CHAR*) lpArgumentString, 
                         "%256s%256s", 
                         achArg1, 
                         achArg2 );
    
    if ( cArguments == EOF || cArguments == 0 )
    {
        DumpoffUsage();
        goto Finished;
    }

    //
    // Handle the !dumpoff -s [sympath] case
    //

    if ( ( achArg1[ 0 ] == '-' || achArg1[ 0 ] == '/' ) &&
         ( achArg1[ 1 ] == 's' || achArg1[ 1 ] == 'S' ) )
    {
        if ( cArguments == 2 )
        {
            strncpy( g_achPDBSearchPath,
                     achArg2,
                     sizeof( g_achPDBSearchPath ) );
        }

        dprintf( "PDB search path set to\n%s%s%s\n",
                 g_achPDBSearchPath,
                 *g_achPDBSearchPath ? "\n" : "",
                 achSymPath );
                 
        goto Finished;
    }

    //
    // Parse the regular !dumpoff command
    //
    
    pszPdb = achArg1;

    pszCursor = strchr( achArg1, '!' );
    if ( pszCursor == NULL )
    {
        DumpoffUsage();
        goto Finished;
    }
    *pszCursor = '\0';

    pszType = pszCursor + 1;
    
    pszCursor = strchr( pszType, '.' );
    if ( pszCursor != NULL )
    {
        *pszCursor = '\0';
        pszMember = pszCursor + 1;
    } 
    
    if ( cArguments > 1 )
    {
        pszAddress = achArg2;
    }

    //
    // done parsing, now get the PDB 
    //
    
    strncpy( achFileName,
             pszPdb,
             sizeof( achFileName ) - 1 );
    strncat( achFileName,
            ".pdb",
            sizeof( achFileName ) - 1 );

    //
    // Look for the PDB file.  First in the PDB search path, then sympath
    //

    pszCursor = g_achPDBSearchPath;

Retry:
    while ( pszCursor )
    {
        pszNext = strchr( pszCursor, ';' );
        if ( pszNext != NULL )
        {
            *pszNext = '\0';
        }
        
        fRet = SearchTreeForFile( pszCursor,
                                  achFileName,
                                  achFullPath );
        if ( fRet )
        {
            break;
        }
        
        if ( pszNext )
        {
            pszCursor = pszNext + 1;
        }
        else
        {
            pszCursor = NULL;
        }
    }

    if ( !pszCursor && fRetry )
    {
        fRetry = FALSE;
        
        // now try the debugger sympath

        pszCursor = achSymPath;
        goto Retry;
    }
    
    if ( !pszCursor )
    {
        _snprintf( achBuffer,
                   sizeof( achBuffer ),
                   "Couldn't find PDB file %s\n",
                   achFileName );
        goto Finished;
    }
    
    //
    // Open the PDB file
    //
    
    if ( !PDBOpen( achFullPath,
                   pdbRead,
                   0,
                   &ec,
                   achBuffer,
                   &pDebug ) )
    {
        _snprintf( achBuffer,
                   sizeof( achBuffer ),
                   "Error opening PDB file.  Error = %d\n",
                   ec );
        goto Finished;
    }

    if ( pszType[ 0 ] == '=' && pszType[ 1 ] == '=' )
    {
        //
        // Find all types of size after ==
        //

        cbSize = strtoul( pszType + 2,
                          NULL,
                          16 );

        dwError = FindMembersOfTypeSize( pDebug,
                                         cbSize,
                                         DoPrintf );
    }
    else
    {
        dwError = OutputStructure( pDebug,
                                   pszType,
                                   pszMember,
                                   0,
                                   pszAddress ? (VOID*) GetExpression( pszAddress ) : NULL, 
                                   DoReadMemory,
                                   DoPrintf );
    }

    if ( dwError != ERROR_SUCCESS )
    {
        switch ( dwError )
        {
        case ERROR_FILE_NOT_FOUND:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Could not find type '%s' in PDB file '%s'\n",
                       pszType,
                       achFullPath );
            break;
        case ERROR_NOT_SUPPORTED:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "PDB file '%s' does not contain necessary type info\n",
                       achFullPath );
            break;
        default:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Error dumping structure.  Error = %d\n", 
                       dwError );
        }

        goto Finished;
    }

Finished:

    if ( achBuffer[ 0 ] )
    {
        dprintf( "%s", achBuffer );
    }

    if ( pDebug )
    {
        PDBClose( pDebug );
    }
  
} // DECLARE_API( dumpoff )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\findmod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    findmod.cxx

Abstract:

    Locates module in the debugee containing a specific address.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"

typedef struct _ENUM_CONTEXT {
    ULONG_PTR ModuleAddress;
    PMODULE_INFO ModuleInfo;
    BOOLEAN Successful;
} ENUM_CONTEXT, *PENUM_CONTEXT;


BOOLEAN
CALLBACK
FmpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;

    context = (PENUM_CONTEXT)Param;

    if( context->ModuleAddress >= ModuleInfo->DllBase &&
        context->ModuleAddress < ( ModuleInfo->DllBase + ModuleInfo->SizeOfImage ) ) {

        CopyMemory(
            context->ModuleInfo,
            ModuleInfo,
            sizeof(*ModuleInfo)
            );

        context->Successful = TRUE;

    }

    return !context->Successful;

}   // FmpEnumProc


BOOLEAN
FindModuleByAddress(
    IN ULONG_PTR ModuleAddress,
    OUT PMODULE_INFO ModuleInfo
    )

/*++

Routine Description:

    Finds a module in the debugee that contains the specified address.

Arguments:

    ModuleAddress - The module address to search for.

    ModuleInfo - If successful, receives information describing the
        module found.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result;
    ENUM_CONTEXT context;

    context.ModuleAddress = ModuleAddress;
    context.ModuleInfo = ModuleInfo;
    context.Successful = FALSE;

    result = EnumModules(
                 FmpEnumProc,
                 (PVOID)&context
                 );

    if( result )  {
        result = context.Successful;
    }

    return result;

}   // FindModuleByAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\filter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filter.cxx

Abstract:

    Dump out ISAPI filter info

Author:

    Bilal Alam (balam)          Feb-25-2000

Revision History:

--*/

#include "precomp.hxx"

HRESULT
ReadSTRU(
    STRU *          pString,
    WCHAR *         pszBuffer,
    DWORD *         pcchBuffer
)
{
    DWORD           cbNeeded = pString->QueryCCH() + 1;
    
    if ( cbNeeded > *pcchBuffer )
    {
        *pcchBuffer = cbNeeded;
        return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }
    
    MoveBlockWithRet( (*(pszBuffer)), 
                      (ULONG_PTR)pString->m_Buff.m_pb,
                      pString->m_Buff.m_cb,
                      HRESULT_FROM_WIN32( ERROR_INVALID_ADDRESS ) );

    return NO_ERROR;
}

VOID
DumpFilterNotifications(
    DWORD               dwNotifications
)
{
    if ( dwNotifications & SF_NOTIFY_READ_RAW_DATA )
    {
        dprintf( "SF_NOTIFY_READ_RAW_DATA\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_PREPROC_HEADERS )
    {
        dprintf( "SF_NOTIFY_PREPROC_HEADERS\n" );
    }

    if ( dwNotifications & SF_NOTIFY_AUTHENTICATION )
    {
        dprintf( "SF_NOTIFY_AUTHENTICATION\n" );
    }

    if ( dwNotifications & SF_NOTIFY_URL_MAP )
    {
        dprintf( "SF_NOTIFY_URL_MAP\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_ACCESS_DENIED )
    {
        dprintf( "SF_NOTIFY_ACCESS_DENIED\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_SEND_RESPONSE )
    {
        dprintf( "SF_NOTIFY_SEND_RESPONSE\n" );
    }

    if ( dwNotifications & SF_NOTIFY_SEND_RAW_DATA )
    {
        dprintf( "SF_NOTIFY_SEND_RAW_DATA\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_LOG )
    {
        dprintf( "SF_NOTIFY_LOG\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_END_OF_REQUEST )
    {
        dprintf( "SF_NOTIFY_END_OF_REQUEST\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_END_OF_NET_SESSION )
    {
        dprintf( "SF_NOTIFY_END_OF_NET_SESSION\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_AUTH_COMPLETE )
    {
        dprintf( "SF_NOTIFY_AUTH_COMPLETE\n" );
    }
}

VOID
DumpFilterDll(
    ULONG_PTR           pFilterDllAddress,
    HTTP_FILTER_DLL *   pFilterDll
)
{
    STRU *              pStrName;
    WCHAR               achBuffer[ 256 ] = L"";
    DWORD               cchBuffer = 256;
    DEFINE_CPP_VAR(     HTTP_FILTER_DLL, FilterDll );
   
    if ( pFilterDll == NULL )
    {
        move( FilterDll, pFilterDllAddress );
        pFilterDll = GET_CPP_VAR_PTR( HTTP_FILTER_DLL, FilterDll );
    }
    
    //
    // Top line stuff
    //
    
    dprintf( "HTTP_FILTER_DLL %p :  cRefs = %d, Secure = %s, Non-Secure = %s\n", 
             (VOID*) pFilterDllAddress,
             pFilterDll->_cRef,
             ( pFilterDll->_dwFlags & SF_NOTIFY_SECURE_PORT ) ? "YES" : "NO",
             ( pFilterDll->_dwFlags & SF_NOTIFY_NONSECURE_PORT ) ? "YES" : "NO" );

    //
    // Print the ISAPI filter path
    //

    pStrName = (STRU*) &(pFilterDll->_strName); 

    ReadSTRU( pStrName,
              achBuffer,
              &cchBuffer );

    dprintf( "Filter Path = \"%ws\"\n", achBuffer );

    //
    // Dump out a nice list of configured notifications
    //
    
    dprintf( "\n" );
    DumpFilterNotifications( pFilterDll->_dwFlags );
}

VOID
DumpFilterDllThunk(
    PVOID               FilterAddress,
    PVOID               pFilter,
    CHAR                chVerbosity,
    DWORD               iThunk
)
{
    DumpFilterDll(
        (ULONG_PTR) FilterAddress,
        (HTTP_FILTER_DLL*) pFilter
        );
    
    dprintf( "-----------------------------------------------------\n" );
}

VOID
DumpFilterGlobals(
    VOID
)
{
    ULONG_PTR           filterListAddress;
    
    //
    // Dump out how many filters are loaded and then dump each HTTP_FILTER_DLL
    //

    filterListAddress = GetExpression("&w3core!HTTP_FILTER_DLL__sm_FilterHead");
    if (!filterListAddress) 
    {
        dprintf("couldn't evaluate w3core!HTTP_FILTER_DLL__sm_FilterHead\n");
        return;
    }

    EnumLinkedList(
        (LIST_ENTRY *) filterListAddress,
        DumpFilterDllThunk,
        0,
        sizeof(HTTP_FILTER_DLL),
        FIELD_OFFSET(HTTP_FILTER_DLL, _ListEntry)
        );
            
    
}


DECLARE_API( filter )
/*++

Routine Description:

    This function is called as an NTSD extension to reset a reference
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    CHAR                chCommand = 0;
    
    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) 
    {
        args++;
    }
    
    //
    // -g Globals
    // -x W3_FILTER_CONTEXT
    // -c W3_CONNECTION_CONTEXT
    // -d HTTP_FILTER_DLL
    // -l FILTER_LIST
    //
    
    if ( *args != '-' )
    {
        return;
    }
    chCommand = *(++args);
    args++;
     
    //
    // Skip more blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) 
    {
        args++;
    }
    
    switch( chCommand )
    {
    case 'g':
        DumpFilterGlobals();
        break;
    
    case 'x':
//        DumpFilterContext( GetExpression( args ) );
        break;
    
    case 'c':
//        DumpFilterContext( GetExpression( args ) );
        break;
        
    case 'd':
        DumpFilterDll( GetExpression( args ),
                       NULL );
        break;
    case 'l':
//        DumpFilterList( GetExpression( args ) );
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\heapfind.cxx ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    heapfind.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    bits of heap information.

Author:

    Keith Moore (keithmo) 01-Nov-1997
    Anil Ruia   (anilr)   02-Mar-2001

Revision History:

--*/

#include "precomp.hxx"

typedef struct _ENUM_CONTEXT {

    ULONG  SizeToDump;
    ULONG  DumpCount;
    ULONG  DumpNDWords;
    ULONG  DWordInBlockToSearchFor;
    PUCHAR BlockToSearchFor;
    BOOLEAN ContinueEnum;

} ENUM_CONTEXT, *PENUM_CONTEXT;

# define minSize(a, b)  (((a) < (b)) ? (a) : (b))


/************************************************************
 * Dump Heap Info
 ************************************************************/

void TestAndDumpEntry(
    PENUM_CONTEXT   context,
    PUCHAR          entryStart,
    ULONG           entryLength,
    VOID            *RemoteHeapEntry,
    ULONG           Flags)
{
    BOOLEAN dumpBlock = FALSE;

    //
    // Decide how to handle this request.
    //

    if( context->BlockToSearchFor != NULL ) {

        //
        // The user is looking for the heap block that contains a
        // specific address. If the current block is a match, then
        // dump it and terminate the enumeration.
        //

        if( context->BlockToSearchFor >= entryStart &&
            context->BlockToSearchFor < ( entryStart + entryLength ) ) {

            dumpBlock = TRUE;
            context->ContinueEnum = FALSE;

        }

    } else {

        //
        // The user is looking for blocks of a specific size. If the
        // size matches, or the user is looking for "big" blocks and
        // the current block is >= 64K, then dump it.
        //

        if( context->SizeToDump == entryLength ||
            ( context->SizeToDump == 0xFFFFFFFF && entryLength >= 65536 ) ) {

            // if looking for a particular DWORD in the memory, then enter
            // some loops below to get chunks of memory and search for the value

            if (context->DWordInBlockToSearchFor != 0) {

                DWORD dwBuff[1024];
                DWORD totalRead = 0;

                // the outer loop will handle the chunked reads of the data

                for (DWORD i=0; (totalRead < entryLength) && (dumpBlock == FALSE); i++) {

                    // determine how much to get this time.

                    DWORD cbToRead = minSize(sizeof(dwBuff), entryLength-totalRead);

                    // get the memory

                    moveBlock( dwBuff, (ULONG_PTR)entryStart+totalRead, cbToRead);

                    // record how much we've read so far

                    totalRead += cbToRead;

                    // for simplicity, declare a counter to hold the number of
                    // DWORDs to search.  Note that dropping the remainder in
                    // this case is desired.

                    DWORD dwToSearch = cbToRead/4;

                    // the inner loop will search the read memory for the desired
                    // block

                    for (DWORD j=0; (j < dwToSearch) && (dumpBlock == FALSE); j++) {

                        if (dwBuff[j] == context->DWordInBlockToSearchFor) {
                            dumpBlock = TRUE;
                            break;
                        }
                    }
                }
            }
            else {

                dumpBlock = TRUE;
            }

        }

    }

    if( dumpBlock ) {
        context->DumpCount++;
        dprintf(
            "HeapEntry @ %p [%p], flags = %02x, length = %lx\n",
            RemoteHeapEntry,
            entryStart,
            Flags,
            entryLength
            );

        // check to see if we need to dump the memory of the entry

        if (context->DumpNDWords) {

            // declare a buffer and determine how much to read.  Read no more than
            // the lesser of 1024, the entry's length or the user's request.

            DWORD dwString[1024];
            DWORD cLength = minSize( context->DumpNDWords*sizeof(DWORD), sizeof(dwString));
            if (cLength > entryLength)
                cLength = entryLength;

            //
            // Read the data block from the debuggee process into local buffer
            //
            moveBlock( dwString, (ULONG_PTR)entryStart, cLength);

            // adjust the length down to a count of DWORDs

            cLength /= 4;

            // print out the dword count request.  Make it look like 'dc' output

            for (DWORD i=0, j=0; i < cLength; i++, j = ((j + 1) & 3)) {

                // if the first dword on a line, print out the memory address
                // for the line

                if (j == 0)
                    dprintf(" %p  ", entryStart+(i*4));

                // print out the DWORD itself

                dprintf("%08x ", dwString[i]);

                // if at the end of the line, print out the ASCII chars

                if (j == 3) {
                    dprintf("  ");

                    // treat the dword array as an array of bytes and print
                    // out their ASCII values if printable

                    BYTE *pBytes = (BYTE *)&dwString[i-3];
                    for (DWORD k=0; k < 16; k++) {
                        if (isprint((UCHAR)pBytes[k])) {
                            dprintf("%c", pBytes[k]);
                        }
                        else {
                            dprintf(".");
                        }
                    }
                    dprintf("\n");
                }
            }

            // done printing out the requested dwords.  Handle the case
            // where there weren't an even multiple of 4 entries

            if (cLength & 3) {

                // first determine how many we were short

                DWORD numRem = cLength & 3;

                // pad out the display to get to the ASCII portion

                for (DWORD k=4-numRem; k > 0; k--)
                    dprintf("         ");

                dprintf("  ");

                // print out the ASCII values for the dwords that
                // were printed

                BYTE *pBytes = (BYTE *)&dwString[i-numRem];
                for (DWORD k=0; k < (numRem*4); k++) {
                    if (isprint((UCHAR)pBytes[k])) {
                        dprintf("%c", pBytes[k]);
                    }
                    else {
                        dprintf(".");
                    }
                }
                dprintf("\n");
            }
            dprintf("\n");
        }
    }
    
    return;
}

BOOLEAN
CALLBACK
HfpEnumHeapSegmentEntriesProc(
    IN PVOID Param,
    IN PHEAP_ENTRY LocalHeapEntry,
    IN PHEAP_ENTRY RemoteHeapEntry
    )

/*++

Routine Description:

    Callback invoked for each heap entry within a heap segment.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapEntry - Pointer to a local copy of the HEAP_ENTRY structure.

    RemoteHeapEntry - The remote address of the HEAP_ENTRY structure
        in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PUCHAR entryStart;
    ULONG entryLength;

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // allow user to break out of lengthy enumeration
    //
    
    if( CheckControlC() ) {
        context->ContinueEnum = FALSE;
        return TRUE;
    }

    //
    // Ignore free blocks.
    //

    if( !( LocalHeapEntry->Flags & HEAP_ENTRY_BUSY ) ) {
        return TRUE;
    }

    //
    // Calculate the start & length of the heap block.
    //

    if (LocalHeapEntry->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)
    {
        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock
            = CONTAINING_RECORD(RemoteHeapEntry, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock);
        entryStart = (PUCHAR)(VirtualAllocBlock + 1);

        VirtualAllocBlock = CONTAINING_RECORD(LocalHeapEntry, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock);
        entryLength = VirtualAllocBlock->CommitSize - LocalHeapEntry->Size;
    }
    else
    {
        entryStart = (PUCHAR)(RemoteHeapEntry + 1);

        entryLength = (LocalHeapEntry->Size << HEAP_GRANULARITY_SHIFT) -
                        RtlpGetUnusedBytes(LocalHeapEntry);
    }

    TestAndDumpEntry(context, 
                     entryStart, 
                     entryLength, 
                     RemoteHeapEntry, 
                     (ULONG)LocalHeapEntry->Flags);

    return context->ContinueEnum;

}   // HfpEnumHeapSegmentEntriesProc


BOOLEAN
CALLBACK
HfpEnumHeapSegmentsProc(
    IN PVOID Param,
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN ULONG HeapSegmentIndex
    )

/*++

Routine Description:

    Callback invoked for each heap segment within a heap.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT
        structure.

    RemoteHeapSegment - The remote address of the HEAP_SEGMENT
        structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // Enumerate the entries for the specified segment.
    //

    if( !EnumHeapSegmentEntries(
            LocalHeapSegment,
            RemoteHeapSegment,
            HfpEnumHeapSegmentEntriesProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving heap segment entries\n" );
        return FALSE;
    }

    return context->ContinueEnum;

}   // HfpEnumHeapSegmentsProc


BOOLEAN
CALLBACK
HfpEnumHeapsProc(
    IN PVOID Param,
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN ULONG HeapIndex
    )

/*++

Routine Description:

    Callback invoked for each heap within a process.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeap - Pointer to a local copy of the HEAP structure.

    RemoteHeap - The remote address of the HEAP structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // Enumerate the segments for the specified heap.
    //

    if( !EnumHeapSegments(
            LocalHeap,
            RemoteHeap,
            HfpEnumHeapSegmentsProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving heap segments for heap %p\n", RemoteHeap );
        return FALSE;
    }

    if (!EnumVirtualAllocdBlocks(
            &LocalHeap->VirtualAllocdBlocks,
            &RemoteHeap->VirtualAllocdBlocks,
            HfpEnumHeapSegmentEntriesProc,
            Param))
    {
        dprintf( "error retrieving virtual alloced blocks for heap %p\n", RemoteHeap );
        return FALSE;
    }

    return context->ContinueEnum;

}   // HfpEnumHeapsProc



BOOLEAN
CALLBACK
HfpEnumPageHeapBlockProc(
    IN PVOID Param,
    IN PDPH_HEAP_BLOCK pLocalBlock,
    IN PVOID pRemoteBlock
    )
{
    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    PUCHAR entryStart;
    ULONG entryLength;
    BOOLEAN dumpBlock = FALSE;

    entryStart = pLocalBlock->pUserAllocation;
    entryLength = pLocalBlock->nUserRequestedSize;

    TestAndDumpEntry(context, 
                     entryStart, 
                     entryLength, 
                     pRemoteBlock, 
                     (ULONG)pLocalBlock->UserFlags);

    return context->ContinueEnum;
}



BOOLEAN
CALLBACK
HfpEnumPageHeapProc(
    IN PVOID Param,
    IN PDPH_HEAP_ROOT pLocalHeap,
    IN PVOID pRemoteHeap
    )
{
    if (!EnumPageHeapBlocks(pLocalHeap->pBusyAllocationListHead,
                            HfpEnumPageHeapBlockProc,
                            Param))
    {
        dprintf("Error enumerating busy blocks for heap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    return TRUE;
}


DECLARE_API( heapfind )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    heap information.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;
    int          bOptionFound = FALSE;

    //
    // Setup.
    //

    RtlZeroMemory(
        &context,
        sizeof(context)
        );

    context.ContinueEnum = TRUE;


    //
    // Interpret the command-line switch.
    //

    while (*args) {

        // skip any whitespace to get to the next argument

        while(isspace(*args))
            args++;

        // break if we hit the NULL terminator

        if (*args == '\0')
            break;

        // should be pointing to a '-' char

        if (*args != '-') {
            PrintUsage("heapfind");
            return;
        }

        // Advance to option letter

        args++;

        // save the option letter

        char cOption = *args;

        // advance past the option letter

        args++;

        // note that at least one option was found

        bOptionFound = TRUE;

        // skip past leading white space in the argument

        while(isspace(*args))
            args++;

        // if we didn't find anything after the option, error

        if (*args == '\0') {
            PrintUsage("heapfind");
            return;
        }

        switch( cOption ) {
            case 'a' :
            case 'A' :
                sscanf(args, "%p", &context.BlockToSearchFor);
                break;

            case 's' :
            case 'S' :
                context.SizeToDump = (ULONG)strtoul( args, NULL, 16 );
                break;

            case 'd' :
            case 'D' :
                context.DumpNDWords = (ULONG)strtoul( args, NULL, 10 );
                break;

            case 'f' :
            case 'F' :
                context.DWordInBlockToSearchFor = (ULONG)strtoul( args, NULL, 16 );
                break;

            default :
                PrintUsage( "heapfind" );
                return;
        }

        // move past the current argument

        while ((*args != ' ') 
               && (*args != '\t') 
               && (*args != '\0')) {
            args++;
        }
    }

    if (bOptionFound == FALSE) {
        PrintUsage("heapfind");
        return;
    }

    // if the 'a' option was found, it should be the only
    // argument on the command line.  The rest don't make
    // sense.

    if ((context.BlockToSearchFor != NULL)
        && ((context.SizeToDump != 0)
            || (context.DumpNDWords != 0)
            || (context.DWordInBlockToSearchFor !=0))) {
        PrintUsage("heapfind");
        return;
    }

    //
    // Enumerate the heaps, which will enumerate the segments, which
    // will enumerate the entries, which will search for the specified
    // address or specified size.
    //

    if( !EnumProcessHeaps(
            HfpEnumHeapsProc,
            (PVOID)&context,
            hCurrentProcess
            ) ) {
        dprintf( "error retrieving process heaps\n" );
        return;
    }

    if (!EnumProcessPageHeaps(HfpEnumPageHeapProc,
                              &context))
    {
        dprintf( "error retrieving page heaps\n" );
        return;
    }

    if (context.DumpCount > 0)
    {
        dprintf( "Total count: %08lx\n", context.DumpCount);
    }

}   // DECLARE_API( heapfind )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allocation call was generated from on of the
//     target dlls.
//
// PAGE_HEAP_USE_FAULT_INJECTION
//
//     Fault inject heap allocation calls based on a simple 
//     probabilistic model (see FaultProbability and FaultTimeOut).
//
// PAGE_HEAP_PROTECT_META_DATA
//
//     Keep page heap metadata read only if we are not executing inside
//     the page heap code.
//
// PAGE_CHECK_NO_SERIALIZE_ACCESS
//
//     Additional checks for multi-threaded access for no_serialize
//     heaps. This flag can trigger false positives in MPheap. It needs
//     to be used only on processes that do not use MPheap-like heaps.
//
// PAGE_HEAP_USE_READONLY
//
//     The page following (or preceding) the user allocation is marked
//     RO instead of NA. This is useful when testing RPC servers which
//     by design during unmarshalling might go off by a few bytes when 
//     probing parameters. This is so for performance reasons.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_NO_UMDH_SUPPORT           0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040 // obsolete
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000
#define PAGE_HEAP_USE_READONLY              0x8000

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// If not zero controls the probability with which
// allocations will be failed on purpose by page heap
// manager. Timeout represents the initial period during
// process initialization when faults are not allowed.
//

extern ULONG RtlpDphFaultProbability;
extern ULONG RtlpDphFaultTimeOut;

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

//
// Functions needed to turn on/off fault injection.
// They are needed in the loader so that allocations
// succeed while in LdrLoadDll code path.
//

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\global.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.cxx

Abstract:

    This module dumps global worker process objects.
    NTSD debugger extension.

Author:

    Michael Courage (mcourage) 07-20-99

Revision History:

--*/

#include "precomp.hxx"

char * g_achShutdownReason[] = {
    "SHUTDOWN_REASON_ADMIN",
    "SHUTDOWN_REASON_ADMIN_GONE",
    "SHUTDOWN_REASON_IDLE_TIMEOUT",
    "SHUTDOWN_REASON_MAX_REQ_SERVED",
    "SHUTDOWN_REASON_FATAL_ERROR"
};

#define SHUTDOWN_TO_STRING( reason )                            \
    ((((reason) >= SHUTDOWN_REASON_ADMIN)                       \
    && ((reason) <= SHUTDOWN_REASON_FATAL_ERROR)) ?             \
    g_achShutdownReason[ (reason) ] : "<Invalid>")


DECLARE_API( global )
{
    ULONG_PTR ctxtPtrAddress;
    ULONG_PTR ctxtPtr;
    DEFINE_CPP_VAR( WP_CONTEXT, ctxt );
    WP_CONTEXT * pctxt = GET_CPP_VAR_PTR( WP_CONTEXT, ctxt );

    DEFINE_CPP_VAR( WP_CONFIG, config );
    WP_CONFIG * pconfig = GET_CPP_VAR_PTR( WP_CONFIG, config );

    DEFINE_CPP_VAR( WP_IDLE_TIMER, timer );
    WP_IDLE_TIMER * ptimer = GET_CPP_VAR_PTR( WP_IDLE_TIMER, timer );

    ctxtPtrAddress = GetExpression("&iiswp!g_pwpContext");

    if (ctxtPtrAddress) {
        move( ctxtPtr, ctxtPtrAddress );
        move( ctxt, ctxtPtr );

        dprintf(
            "WP_CONTEXT: %p\n"
            "    m_pConfigInfo = %p\n"
            "    m_ulAppPool.m_hAppPool = %p\n"
            "    m_nreqpool             @ %p\n"
            "        m_lRequestList     @ %p\n"
            "        m_csRequestList    @ %p\n"
            "        m_nRequests        = %d\n"
            "        m_nIdleRequests    = %d\n"
            "        m_dwSignature      = %08x\n"
            "        m_fShutdown        = %d\n"
            "        m_fAddingItems     = %d\n"
            "    m_hDoneEvent           = %p\n"
            "    m_fShutdown            = %d\n"
            "    m_ShutdownReason       = %s\n"
            "    m_pIdleTimer           = %p\n"
            "    m_WpIpm                @ %p\n"
            "        m_pWpContext       = %p\n"
            "        m_pMessageGlobal   = %p\n"
            "        m_pPipe            = %p\n"
            "        m_hConnectEvent    = %p\n"
            "        m_hTerminateEvent  = %p\n",
            ctxtPtr,
            pctxt->m_pConfigInfo,
            pctxt->m_ulAppPool.m_hAppPool,
            ctxtPtr + FIELD_OFFSET( WP_CONTEXT, m_nreqpool ),
            ctxtPtr
                + FIELD_OFFSET( WP_CONTEXT, m_nreqpool )
                + FIELD_OFFSET( UL_NATIVE_REQUEST_POOL, m_lRequestList ),
            ctxtPtr
                + FIELD_OFFSET( WP_CONTEXT, m_nreqpool )
                + FIELD_OFFSET( UL_NATIVE_REQUEST_POOL, m_csRequestList ),
            pctxt->m_nreqpool.m_nRequests,
            pctxt->m_nreqpool.m_nIdleRequests,
            pctxt->m_nreqpool.m_dwSignature,
            pctxt->m_nreqpool.m_fShutdown,
            pctxt->m_nreqpool.m_fAddingItems,
            pctxt->m_hDoneEvent,
            pctxt->m_fShutdown,
            SHUTDOWN_TO_STRING( pctxt->m_ShutdownReason ),
            pctxt->m_pIdleTimer,
            ctxtPtr + FIELD_OFFSET( WP_CONTEXT, m_WpIpm ),
            pctxt->m_WpIpm.m_pWpContext,
            pctxt->m_WpIpm.m_pMessageGlobal,
            pctxt->m_WpIpm.m_pPipe,
            pctxt->m_WpIpm.m_hConnectEvent,
            pctxt->m_WpIpm.m_hTerminateEvent
            );

        move( config, pctxt->m_pConfigInfo );
        dprintf(
            "WP_CONFIG: %p\n"
            "    m_pwszAppPoolName      = %p\n"
            "    m_pwszProgram          = %S\n"
            "    m_fSetupControlChannel = %d\n"
            "    m_fLogErrorsToEventLog = %d\n"
            "    m_fRegisterWithWAS     = %d\n"
            "    m_RestartCount         = %ld\n"
            "    m_NamedPipeId          = %ld\n"
            "    m_IdleTime             = %ld\n"
            "    m_mszURLList           @ %p ( MULTISZ )\n"
            "    m_ulcc                 @ %p\n"
            "        m_hControlChannel  = %p\n"
            "        m_ConfigGroupId    = %I64u\n"
            "        m_hAppPool         = %p\n\n",
            pctxt->m_pConfigInfo,
            pconfig->m_pwszAppPoolName,
            pconfig->m_pwszProgram,
            pconfig->m_fSetupControlChannel,
            pconfig->m_fLogErrorsToEventLog,
            pconfig->m_fRegisterWithWAS,
            pconfig->m_RestartCount,
            pconfig->m_NamedPipeId,
            pconfig->m_IdleTime,
            (ULONG_PTR) pctxt->m_pConfigInfo
                + FIELD_OFFSET( WP_CONFIG, m_mszURLList ),
            (ULONG_PTR) pctxt->m_pConfigInfo
                + FIELD_OFFSET( WP_CONFIG, m_ulcc ),
            pconfig->m_ulcc.m_hControlChannel,
            pconfig->m_ulcc.m_ConfigGroupId,
            pconfig->m_ulcc.m_hAppPool
            );

        move( timer, pctxt->m_pIdleTimer );
        dprintf(
            "WP_IDLE_TIMER: %p\n"
            "    m_BusySignal               = %ld\n"
            "    m_CurrentIdleTick          = %ld\n"
            "    m_IdleTime                 = %ld\n"
            "    m_hIdleTimeExpiredTimer    = %p\n"
            "    m_pContext                 = %p\n\n",
            ptimer->m_BusySignal,
            ptimer->m_CurrentIdleTick,
            ptimer->m_IdleTime,
            ptimer->m_hIdleTimeExpiredTimer,
            ptimer->m_pContext
            );

    } else {
        dprintf(
            "global: cannot evaluate iiswp!g_pwpContext\n"
            );
    }
} // DECLARE_API( nreq )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\exec.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    exec.cxx

Abstract:

    This module contains an NTSD debugger extension for executing
    external commands.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"


/************************************************************
 * Execute
 ************************************************************/


DECLARE_API( exec )

/*++

Routine Description:

    This function is called as an NTSD extension to ...

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    BOOL result;
    STARTUPINFOA startInfo;
    PROCESS_INFORMATION processInfo;

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    //
    // Use "cmd.exe" by default.
    //

    if( *args == '\0' ) {
        args = "cmd";
    }

    //
    // Set the prompt environment variable so the user will have clue.
    //

    SetEnvironmentVariableA(
        "PROMPT",
        "!dtext.exec - $p$g"
        );

    //
    // Launch it.
    //

    ZeroMemory(
        &startInfo,
        sizeof(startInfo)
        );

    ZeroMemory(
        &processInfo,
        sizeof(processInfo)
        );

    startInfo.cb = sizeof(startInfo);

    result = CreateProcessA(
                 NULL,                          // lpszImageName
                 (PSTR)args,                    // lpszCommandLine
                 NULL,                          // lpsaProcess
                 NULL,                          // lpsaThread
                 TRUE,                          // fInheritHandles
                 0,                             // fdwCreate
                 NULL,                          // lpvEnvironment
                 NULL,                          // lpszCurDir
                 &startInfo,                    // lpsiStartInfo
                 &processInfo                   // lppiProcessInfo
                 );

    if( result ) {

        //
        // Wait for the child process to terminate, then cleanup.
        //

        WaitForSingleObject( processInfo.hProcess, INFINITE );
        CloseHandle( processInfo.hProcess );
        CloseHandle( processInfo.hThread );

    } else {

        //
        // Could not launch the process.
        //

        dprintf(
            "cannot launch \"%s\", error %lu\n",
            args,
            GetLastError()
            );

    }

}   // DECLARE_API( exec )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

#if !defined(_WIN64)
    union {
        struct {

            //
            //  This field gives the size of the current block in allocation
            //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
            //  equals the size in bytes).
            //
            //  Except if this is part of a virtual alloc block then this
            //  value is the difference between the commit size in the virtual
            //  alloc entry and the what the user asked for.
            //

            USHORT Size;

            //
            // This field gives the size of the previous block in allocation
            // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
            // equals the size of the previous block in bytes).
            //

            USHORT PreviousSize;
        };

        volatile PVOID SubSegmentCode;
    };

#else
    
    USHORT Size;
    USHORT PreviousSize;

#endif

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    volatile UCHAR SegmentIndex;

#if defined(_WIN64)
    volatile PVOID SubSegmentCode;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
//  This block describes extra information that might be at the end of a
//  busy block.
//  Note: The heap code is assuming that:
//      sizeof( HEAP_ENTRY_EXTRA ) == sizeof( HEAP_ENTRY )
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {

    HEAP_ENTRY Entry;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //

    LIST_ENTRY FreeList;

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    SIZE_T AlignRound;
    SIZE_T AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;

    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //
    
    PVOID FrontEndHeap;
    
    USHORT FrontHeapLockCount;
    UCHAR FrontEndHeapType;
    UCHAR LastSegmentIndex;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\heappagi.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappagi.h

Abstract:

    The following definitions are internal to the debug heap manager,
    but are placed in this include file so that debugger extensions
    can reference the same structure definitions.  The following
    definitions are not intended to be referenced externally except
    by debugger extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

//
// Stack trace size. 
//
                                
#define DPH_MAX_STACK_LENGTH   16

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// DPH_HEAP_BLOCK
//

typedef struct _DPH_HEAP_BLOCK DPH_HEAP_BLOCK, *PDPH_HEAP_BLOCK;

struct _DPH_HEAP_BLOCK {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_BLOCK pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    SIZE_T  nVirtualBlockSize;

    SIZE_T  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    SIZE_T  nUserRequestedSize;
    SIZE_T  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

    PRTL_TRACE_BLOCK StackTrace;
};


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_BLOCK  pVirtualStorageListHead;
    PDPH_HEAP_BLOCK  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    SIZE_T                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_BLOCK  pBusyAllocationListHead;
    PDPH_HEAP_BLOCK  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    SIZE_T                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_BLOCK  pFreeAllocationListHead;
    PDPH_HEAP_BLOCK  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    SIZE_T                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_BLOCK  pAvailableAllocationListHead;
    PDPH_HEAP_BLOCK  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    SIZE_T                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_BLOCK  pUnusedNodeListHead;
    PDPH_HEAP_BLOCK  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    SIZE_T                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_BLOCK  pNodePoolListHead;
    PDPH_HEAP_BLOCK  pNodePoolListTail;
    ULONG                 nNodePools;
    SIZE_T                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    LIST_ENTRY NextHeap;

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;

    //
    // Heap creation stack trace.
    //

    PRTL_TRACE_BLOCK      CreateStackTrace;

    //
    // Thread ID of the first thread inside the heap.
    //

    HANDLE FirstThread;
};


//
// DPH_BLOCK_INFORMATION
//
// This structure is stored in every page heap allocated block.
// This information is not saved if the catch backward overruns
// flag is set.
//

#define DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED   0xABCDAAAA
#define DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED     0xDCBAAAAA
#define DPH_NORMAL_BLOCK_START_STAMP_FREE        (0xABCDAAAA - 1)
#define DPH_NORMAL_BLOCK_END_STAMP_FREE          (0xDCBAAAAA - 1)

#define DPH_PAGE_BLOCK_START_STAMP_ALLOCATED     0xABCDBBBB
#define DPH_PAGE_BLOCK_END_STAMP_ALLOCATED       0xDCBABBBB
#define DPH_PAGE_BLOCK_START_STAMP_FREE          (0xABCDBBBB - 1)
#define DPH_PAGE_BLOCK_END_STAMP_FREE            (0xDCBABBBB - 1)

#define DPH_NORMAL_BLOCK_SUFFIX 	0xA0
#define DPH_PAGE_BLOCK_PREFIX 	    0xB0
#define DPH_PAGE_BLOCK_INFIX 	    0xC0
#define DPH_PAGE_BLOCK_SUFFIX 	    0xD0
#define DPH_NORMAL_BLOCK_INFIX 	    0xE0
#define DPH_FREE_BLOCK_INFIX 	    0xF0

typedef struct _DPH_BLOCK_INFORMATION {

    ULONG StartStamp;

    PVOID Heap;
    SIZE_T RequestedSize;
    SIZE_T ActualSize;

    union {
        LIST_ENTRY FreeQueue;
        SLIST_ENTRY FreePushList;
        USHORT TraceIndex;
    };

    PVOID StackTrace;
    
    ULONG EndStamp;

    //
    // (SilviuC): This structure needs to be 8-byte aligned.
    // If it is not, applications expecting aligned blocks will get
    // unaligned ones because this structure will prefix their
    // allocations. Internet Explorer is one such application
    // that stops working in these conditions.
    //

} DPH_BLOCK_INFORMATION, * PDPH_BLOCK_INFORMATION;

//
// Error reasons used in debug messages
//

#define DPH_SUCCESS                           0x0000
#define DPH_ERROR_CORRUPTED_START_STAMP       0x0001
#define DPH_ERROR_CORRUPTED_END_STAMP         0x0002
#define DPH_ERROR_CORRUPTED_HEAP_POINTER      0x0004
#define DPH_ERROR_CORRUPTED_PREFIX_PATTERN    0x0008
#define DPH_ERROR_CORRUPTED_SUFFIX_PATTERN    0x0010
#define DPH_ERROR_RAISED_EXCEPTION            0x0020
#define DPH_ERROR_NO_NORMAL_HEAP              0x0040
#define DPH_ERROR_CORRUPTED_INFIX_PATTERN     0x0080
#define DPH_ERROR_DOUBLE_FREE                 0x0100


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\lkr-ulw3.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

BOOL
WINAPI
HEADER_HASH_LKHT_Dump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    dprintf("HEADER_HASH\n"
            "\tsm_pRequestHash=%p, sm_rgHeaders=%p\n",
            GetExpression("&HEADER_HASH__sm_pRequestHash"),
            GetExpression("&HEADER_HASH__sm_rgHeaders"));
    return TRUE;
}



BOOL
WINAPI
HEADER_RECORD_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide CWord ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(HEADER_RECORD, hdrec);
    HEADER_RECORD* phdrec = GET_CPP_VAR_PTR(HEADER_RECORD, hdrec); 

    // Copy the HEADER_RECORD from the debuggee's memory
    ReadMemory((ULONG_PTR)pvRecord, phdrec, sizeof(HEADER_RECORD), NULL);

    // Read the associated string from the debuggee's memory
    WCHAR wsz[64];
    ReadMemory((ULONG_PTR)phdrec->_pszName, wsz, sizeof(wsz), NULL);
    wsz[64-1] = L'\0';

    dprintf("    HEADER_RECORD=%p: HeaderIndex=%lu, Name=\"%S\"\n",
            pvRecord, phdrec->_ulHeaderIndex, wsz);

    return TRUE;
}



BOOL
WINAPI
W3_SITE_LIST_LKHT_Dump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    dprintf("W3_SITE_LIST, %d\n", nVerbose);
    return TRUE;
}



BOOL
WINAPI
W3_SITE_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide W3_SITE ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(W3_SITE, w3site);
    W3_SITE* pw3site = GET_CPP_VAR_PTR(W3_SITE, w3site); 

    // Copy the W3_SITE from the debuggee's memory
    ReadMemory((ULONG_PTR)pvRecord, &w3site, sizeof(W3_SITE), NULL);

    WCHAR wszSiteMBPath[MAX_PATH] = L"";
    DWORD cwcSiteMBPath =   ARRAYSIZE(wszSiteMBPath);
    STRU* pstruSiteMBPath = &pw3site->m_SiteMBPath;
    ReadSTRU(pstruSiteMBPath, wszSiteMBPath, &cwcSiteMBPath);

    WCHAR wszSiteMBRoot[MAX_PATH] = L"";
    DWORD cwcSiteMBRoot =   ARRAYSIZE(wszSiteMBRoot);
    STRU* pstruSiteMBRoot = &pw3site->m_SiteMBRoot;
    ReadSTRU(pstruSiteMBRoot, wszSiteMBRoot, &cwcSiteMBRoot);

    // TODO: dump some of these fields more deeply---perhaps keyed off nVerbose
    dprintf("    W3_SITE=%p (HashSig=%08x): Signature=%08x, "
                "cRefs=%d, SiteId=%d\n",
            pvRecord, dwSignature, pw3site->m_Signature,
                pw3site->m_cRefs, pw3site->m_SiteId);
    dprintf("\tSiteMBPath=\"%S\", SiteMBRoot=\"%S\",\n",
            wszSiteMBPath, wszSiteMBRoot);
    dprintf("\tpInstanceFilterList=%p, "
                "Logging=%p\n",
                pw3site->m_pInstanceFilterList,
                pw3site->m_pLogging);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\lkrcust.cpp ===
#include "precomp.hxx"
#include "lkrcust.h"


LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig)
{
    extern LKR_CUST_EXTN g_alce[];

    struct LKRheader {
        DWORD m_dwSignature;
        CHAR  m_szName[NAME_SIZE];
    };

    LKRheader lkrh;
    rdwSig = 0;
    
    if (!ReadMemory((ULONG_PTR)lkrAddress, &lkrh, sizeof(lkrh), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID) lkrAddress);

        return NULL;
    }

    rdwSig = lkrh.m_dwSignature;

    lkrh.m_szName[NAME_SIZE-1] = '\0';
    const INT cch = strlen(lkrh.m_szName);
    
    for (LKR_CUST_EXTN* plce = g_alce + 1;  // skip Dummys
         plce->m_pszTableName != NULL;
         ++plce)
    {
        if (strncmp(plce->m_pszTableName, lkrh.m_szName,
                    min(cch, plce->m_cchTableName)) == 0)
        {
            return plce;
        }
    }

    return &g_alce[0];  // Dummy methods
}



BOOL
WINAPI
Dummy_LKHT_Dump(
    IN LKRHASH_NS::CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_LKLH_Dump(
    IN LKRHASH_NS::CLKRLinearHashTable* plht,
    IN INT                  nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_Record_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    dprintf("Record=%p (HashSig=%08x)\n", pvRecord, dwSignature);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\lkrcust.h ===
#ifndef LKR_CUST_DECLARE_TABLE

#include "lkrhash.h"

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
 using namespace LKRhash;
 typedef LKRhash::CLKRLinearHashTable CLinearHashTable;
 typedef LKRhash::CLKRHashTable       CHashTable2;
#else
 #define LKRHASH_NS
 typedef CLKRLinearHashTable CLinearHashTable;
 typedef CLKRHashTable       CHashTable2;
#endif // !__LKRHASH_NO_NAMESPACE__

enum {
    NAME_SIZE           = LKRHASH_NS::CLKRHashTable::NAME_SIZE,
};

typedef
BOOL
(CALLBACK * PFN_LKHT_DUMP)(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose);

typedef
BOOL
(CALLBACK * PFN_LKLH_DUMP)(
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose);

typedef
BOOL
(CALLBACK * PFN_RECORD_DUMP)(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose);

struct LKR_CUST_EXTN {
    LPCSTR          m_pszTableName;
    int             m_cchTableName;
    PFN_LKHT_DUMP   m_pfn_LKHT_Dump;
    PFN_LKLH_DUMP   m_pfn_LKLH_Dump;
    PFN_RECORD_DUMP m_pfn_Record_Dump;
};

LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig);


# define BEGIN_LKR_EXTN_TABLE()

# define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKHT_Dump(                          \
    IN CLKRHashTable*   pht,            \
    IN INT              nVerbose);      \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKLH_Dump(                          \
    IN CLKRLinearHashTable* plht,       \
    IN INT                  nVerbose);  \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_Record_Dump(                        \
    IN const void* pvRecord,            \
    IN DWORD       dwSignature,         \
    IN INT         nVerbose);           \

# define END_LKR_EXTN_TABLE()


#else // LKR_CUST_DECLARE_TABLE


#undef BEGIN_LKR_EXTN_TABLE
#undef LKR_EXTN_DECLARE
#undef END_LKR_EXTN_TABLE


 #define BEGIN_LKR_EXTN_TABLE() \
    LKR_CUST_EXTN g_alce[] = {

 #define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
        { #_TableStr, sizeof(#_TableStr)-1, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump }, 

 #define END_LKR_EXTN_TABLE()   \
        { 0, 0, 0, 0},          \
        };


#endif // LKR_CUST_DECLARE_TABLE



// Important: do NOT put quotes around class name; i.e, first parameter
// should look like MimeMap, not "MimeMap".

BEGIN_LKR_EXTN_TABLE()
  LKR_EXTN_DECLARE(?,
                   Dummy_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   Dummy_Record_Dump)
  LKR_EXTN_DECLARE(HEADER_HASH,
                   HEADER_HASH_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   HEADER_RECORD_Dump)
  LKR_EXTN_DECLARE(W3_SITE_LIST,
                   W3_SITE_LIST_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   W3_SITE_Dump)
END_LKR_EXTN_TABLE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\heapstat.cxx ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    heapstat.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    heap statistics.

Author:

    Keith Moore (keithmo) 01-Nov-1997
    Anil Ruia   (anilr)   03-Mar-2001

Revision History:

--*/

#include "precomp.hxx"


#define MAX_SIZE    65536

// Large busy block (size exceeds MAX_SIZE)
#define MAX_LBBSIZE 1024


typedef struct _ENUM_CONTEXT {

    ULONG FreeJumbo;
    ULONG BusyJumbo;
    ULONG FreeJumboBytes;
    ULONG BusyJumboBytes;
    ULONG BusyOverhead;
    ULONG FreeOverhead;
    ULONG FreeCounters[MAX_SIZE];
    ULONG BusyCounters[MAX_SIZE];
    ULONG LargeBusyBlock[MAX_LBBSIZE];

} ENUM_CONTEXT, *PENUM_CONTEXT;

#define BYTES_TO_K(cb) ( ( (cb) + 512 ) / 1024 )


/************************************************************
 * Dump Heap Info
 ************************************************************/


BOOLEAN
CALLBACK
HspEnumHeapSegmentEntriesProc(
    IN PVOID Param,
    IN PHEAP_ENTRY LocalHeapEntry,
    IN PHEAP_ENTRY RemoteHeapEntry
    )

/*++

Routine Description:

    Callback invoked for each heap entry within a heap segment.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapEntry - Pointer to a local copy of the HEAP_ENTRY structure.

    RemoteHeapEntry - The remote address of the HEAP_ENTRY structure
        in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    ULONG entryLength;
    ULONG allocLength;

    //
    // Calculate the total length of this entry, including the heap
    // header and any "slop" at the end of the block.
    //

    if (LocalHeapEntry->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)
    {
        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock
            = CONTAINING_RECORD(LocalHeapEntry, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock);

        entryLength = VirtualAllocBlock->CommitSize;
        allocLength = entryLength - LocalHeapEntry->Size;
    }
    else
    {
        entryLength = LocalHeapEntry->Size << HEAP_GRANULARITY_SHIFT;
        allocLength = entryLength - RtlpGetUnusedBytes(LocalHeapEntry);
    }

    //
    // Adjust the appropriate accumulators.
    //

    if( LocalHeapEntry->Flags & HEAP_ENTRY_BUSY ) {

        context->BusyOverhead += entryLength;

        if( allocLength < MAX_SIZE ) {
            context->BusyCounters[allocLength] += 1;
        } else {
            context->BusyJumbo += 1;
            context->BusyJumboBytes += allocLength;

            if (context->LargeBusyBlock[MAX_LBBSIZE-1] == 0) {
                BOOL fFound = FALSE;
                UINT  i = 0;
                for (; context->LargeBusyBlock[i] != 0 && i < MAX_LBBSIZE; i++) {
                    if (allocLength == context->LargeBusyBlock[i]) {
                        fFound = TRUE;  
                        break;
                    }
                }
                if (!fFound && i < MAX_LBBSIZE-1) {
                   context->LargeBusyBlock[i] = allocLength; 
                }
            }
        }

    } else {

        context->FreeOverhead += entryLength;

        if( allocLength < MAX_SIZE ) {
            context->FreeCounters[allocLength] += 1;
        } else {
            context->FreeJumbo += 1;
            context->FreeJumboBytes += allocLength;
        }

    }

    return TRUE;

}   // HspEnumHeapSegmentEntriesProc


BOOLEAN
CALLBACK
HspEnumHeapSegmentsProc(
    IN PVOID Param,
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN ULONG HeapSegmentIndex
    )

/*++

Routine Description:

    Callback invoked for each heap segment within a heap.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT
        structure.

    RemoteHeapSegment - The remote address of the HEAP_SEGMENT
        structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    //
    // Enumerate the entries for the specified segment.
    //

    if( !EnumHeapSegmentEntries(
            LocalHeapSegment,
            RemoteHeapSegment,
            HspEnumHeapSegmentEntriesProc,
            Param
            ) ) {
        dprintf( "error retrieving heap segment entries\n" );
        return FALSE;
    }

    return TRUE;

}   // HspEnumHeapSegmentsProc


BOOLEAN
CALLBACK
HspEnumHeapsProc(
    IN PVOID Param,
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN ULONG HeapIndex
    )

/*++

Routine Description:

    Callback invoked for each heap within a process.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeap - Pointer to a local copy of the HEAP structure.

    RemoteHeap - The remote address of the HEAP structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    //
    // Enumerate the segments for the specified heap.
    //

    if( !EnumHeapSegments(
            LocalHeap,
            RemoteHeap,
            HspEnumHeapSegmentsProc,
            Param
            ) ) {
        dprintf( "error retrieving heap segments for heap %p\n", RemoteHeap );
        return FALSE;
    }

    if (!EnumVirtualAllocdBlocks(
            &LocalHeap->VirtualAllocdBlocks,
            &RemoteHeap->VirtualAllocdBlocks,
            HspEnumHeapSegmentEntriesProc,
            Param))
    {
        dprintf( "error retrieving virtual alloced blocks for heap %p\n", RemoteHeap );
        return FALSE;
    }

    return TRUE;

}   // HspEnumHeapsProc



BOOLEAN
CALLBACK
HspEnumPageHeapFreeBlockProc(
    IN PVOID Param,
    IN PDPH_HEAP_BLOCK LocalBlock,
    IN PVOID RemoteBlock
    )
{
    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    DWORD nSize = LocalBlock->nUserRequestedSize;

    context->FreeOverhead += nSize;

    if(nSize < MAX_SIZE)
    {
        context->FreeCounters[nSize] += 1;
    }
    else
    {
        context->FreeJumbo += 1;
        context->FreeJumboBytes += nSize;
    }

    return TRUE;
}



BOOLEAN
CALLBACK
HspEnumPageHeapBusyBlockProc(
    IN PVOID Param,
    IN PDPH_HEAP_BLOCK pLocalBlock,
    IN PVOID pRemoteBlock
    )
{
    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    DWORD nSize = pLocalBlock->nUserRequestedSize;

    context->BusyOverhead += nSize;

    if (nSize < MAX_SIZE)
    {
        context->BusyCounters[nSize] += 1;
    }
    else
    {
        context->BusyJumbo += 1;
        context->BusyJumboBytes += nSize;

        if (context->LargeBusyBlock[MAX_LBBSIZE-1] == 0)
        {
            BOOL fFound = FALSE;
            UINT  i = 0;
            for (; context->LargeBusyBlock[i] != 0 && i < MAX_LBBSIZE; i++)
            {
                if (nSize == context->LargeBusyBlock[i])
                {
                    fFound = TRUE;
                    break;
                }
            }

            if (!fFound && i < MAX_LBBSIZE-1)
            {
               context->LargeBusyBlock[i] = nSize;
            }
        }
    }

    return TRUE;
}



BOOLEAN
CALLBACK
HspEnumPageHeapProc(
    IN PVOID Param,
    IN PDPH_HEAP_ROOT pLocalHeap,
    IN PVOID          pRemoteHeap
    )
{
    if (!EnumPageHeapBlocks(pLocalHeap->pBusyAllocationListHead,
                            HspEnumPageHeapBusyBlockProc,
                            Param))
    {
        dprintf("Error enumerating busy blocks for pageheap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    if (!EnumPageHeapBlocks(pLocalHeap->pFreeAllocationListHead,
                            HspEnumPageHeapFreeBlockProc,
                            Param))
    {
        dprintf("Error enumerating free blocks for pageheap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    if (!EnumPageHeapBlocks(pLocalHeap->pAvailableAllocationListHead,
                            HspEnumPageHeapFreeBlockProc,
                            Param))
    {
        dprintf("Error enumerating available blocks for pageheap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    return TRUE;
}



DECLARE_API( heapstat )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    heap statistics.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    PENUM_CONTEXT context;
    ULONG i;
    ULONG busyBytes;
    ULONG totalBusy;
    ULONG totalFree;
    ULONG totalBusyBytes;
    ULONG lowerNoiseBound;

    //
    // Setup.
    //

    context = (PENUM_CONTEXT)malloc( sizeof(*context) );

    if( context == NULL ) {
        dprintf( "out of memory\n" );
        return;
    }

    RtlZeroMemory(
        context,
        sizeof(*context)
        );

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( *args == '\0' ) {
        lowerNoiseBound = 1;
    } else {
        lowerNoiseBound = strtoul( args, NULL, 16 );
    }

    //
    // Enumerate the heaps, which will enumerate the segments, which
    // will enumerate the entries, which will accumulate the statistics.
    //

    if( !EnumProcessHeaps(
            HspEnumHeapsProc,
            (PVOID)context,
            hCurrentProcess
            ) ) {
        dprintf( "error retrieving process heaps\n" );
        free( context );
        return;
    }

    //
    // Now enumerate the page-heaps
    //

    if (!EnumProcessPageHeaps(HspEnumPageHeapProc,
                              context))
    {
        dprintf( "error retrieving pageheaps\n" );
        free( context );
        return;
    }

    //
    // Dump 'em.
    //

    dprintf(
        "  Size :  NumBusy :  NumFree : BusyBytes\n"
        );

    totalBusy = 0;
    totalFree = 0;
    totalBusyBytes = 0;

    for( i = 0 ; i < MAX_SIZE ; i++ ) {

        busyBytes = i * context->BusyCounters[i];

        if( context->BusyCounters[i] >= lowerNoiseBound ||
            context->FreeCounters[i] >= lowerNoiseBound ) {

            dprintf(
                " %5lx : %8lx : %8lx :  %8lx (%10ldK)\n",
                i,
                context->BusyCounters[i],
                context->FreeCounters[i],
                busyBytes,
                BYTES_TO_K( busyBytes )
                );

        }

        totalBusy += context->BusyCounters[i];
        totalBusyBytes += busyBytes;
        totalFree += context->FreeCounters[i];

    }

    if( context->BusyJumbo >= lowerNoiseBound ||
        context->FreeJumbo >= lowerNoiseBound ) {

        dprintf(
            ">%5lx : %8lx : %8lx :  %8lx (%10ldK)\n",
            MAX_SIZE,
            context->BusyJumbo,
            context->FreeJumbo,
            context->BusyJumboBytes,
            BYTES_TO_K( context->BusyJumboBytes )
            );

        totalBusy += context->BusyJumbo;
        totalFree += context->FreeJumbo;
        totalBusyBytes += context->BusyJumboBytes;

    }

    if (context->LargeBusyBlock[0] != 0) {
        for (i = 0; i < MAX_LBBSIZE && context->LargeBusyBlock[i] != 0; i++) {
            dprintf("%8lx : \n", context->LargeBusyBlock[i]);
        }
    }

    dprintf(
        " Total : %8lx : %8lx :  %8lx (%10ldK)\n"
        "\n"
        " Total Heap Impact from Busy Blocks = %8lx (%10ldK)\n"
        " Total Heap Impact from Free Blocks = %8lx (%10ldK)\n",
        totalBusy,
        totalFree,
        totalBusyBytes,
        BYTES_TO_K( totalBusyBytes ),
        context->BusyOverhead,
        BYTES_TO_K( context->BusyOverhead ),
        context->FreeOverhead,
        BYTES_TO_K( context->FreeOverhead )
        );

    free( context );

}   // DECLARE_API( heapstat )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\help.cxx ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    help.cxx

Abstract:

    This module contains the help text for all commands supported by this
    NTSD debugger extension.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"

//
// The following structure defines the text displayed in response
// to the "!help" command. This text may also be displayed if invalid
// arguments are passed to a command.
//

typedef struct _HELP_MAP {

    //
    // This is the name of the command.
    //

    PSTR Command;

    //
    // This is a "one-liner" displayed when the user executes "!help".
    //

    PSTR OneLiner;

    //
    // This is the full help text displayed when the user executes
    // "!help <cmd>".
    //

    PSTR FullHelp;

} HELP_MAP, *PHELP_MAP;

HELP_MAP HelpMaps[] =
    {
        {
            "help",
            "Dump this list or help for specific command",
            "help [<cmd>] - Dump help for command\n"
            "  If no <cmd> is given, a list of all available commands is displayed\n"
        },

        {
            "ds",
            "Dump stack with symbols",
            "!ds [-v] <addr>  - Dump symbols on stack\n"
            "      -v == print valid symbols only\n"
            "      default addr == current stack pointer\n"
        },

        {
            "ref",
            "Dump reference trace log",
            "!ref <addr> [<context>...] - Dump reference trace log at <addr>\n"
        },

        {
            "rref",
            "Dump reference trace log in reverse order",
            "!rref <addr> [<context>...] - Same as ref, except dumps backwards\n"
        },

        {
            "resetref",
            "Reset reference trace log",
            "!resetref <addr> - Reset reference trace log at <addr>\n"
        },


        {
            "rpcoop",
            "Find process/thread ID buried in RPC parameters",
            "!rpcoop <addr> - given RPC param finds the process id for OOP\n"
            "  Verbosity Levels [v]\n"
            "      0 - Print one line summary\n"
            "      1 - Print level 1 information\n"
            "      2 - Print level 2 information\n"
        },

        {
            "mod",
            "Dump module info",
            "!mod [<addr>] - Dump module info\n"
            "  If <addr> is specified, only module containing <addr> is dumped\n"
        },

        {
            "ver",
            "Dump module version resources",
            "!ver [<module>] - Dump version resource for specified module\n"
            "  <module> may be either a module base address or name\n"
            "  If no <module> is specified, then all modules are dumped\n"
        },

        {
            "heapfind",
            "Find heap block by size or address",
            "!heapfind -a<addr> - Find heap block containing <addr>\n"
            "!heapfind [-f<x>] [-d<n>] -s<size> - Find all heap blocks of length <size>\n"
            "  -d<n> - Print first <n> DWORDs of heap block; where n is decimal\n"
            "  -f<x> - Only print heap blocks that contain <x> DWORD; where x is hexadecimal\n"
        },

        {
            "heapstat",
            "Dump heap statistics",
            "!heapstat <min> - Dump heap statistics\n"
            "  If <min> is present, then only those heap blocks with countes >= <min>\n"
            "  are displayed. Note that *all* heap blocks are included in the totals,\n"
            "  even if those blocks had counts too small to display.\n"
            "  If <min> is not present, all heap blocks are displayed\n"
        },

        {
            "acache",
            "Dump allocation cache structures",
            "!acache <addr>  - Dump Allocation Cache Handler at <addr>\n"
            "!acache -g      - Dump Allocation Cache global information\n"
            "!acache -l[0|1] - Dump Allocation Cache list at verbosity [v]\n"
        },

        {
            "gem",
            "Get current error mode",
            "!gem - Get current error mode\n"
        },

        {
            "exec",
            "Execute external command",
            "!exec [<cmd>] - Execute external command\n"
            "  Default <cmd> is CMD.EXE\n"
        },

        {
            "llc",
            "Counts items on a standard linked-list",
            "!llc <list_head> - Counts the LIST_ENTRYs present on the specified list head\n"
        },

        {
            "dumpoff",
            "Dump structure/class information based on debug info in PDB",
            "!dumpoff <PDB_file>!<Type_name>[.Member_name] [expression]\n"
            "  PDB_file - Non-qualified name of PDB file without extension (say, w3svc,infocomm)\n"
            "  Type_name - Name of type (say, HTTP_FILTER)\n"
            "  Member_name - Optional member of Type_name (say, _strURL)\n"
            "  Expression - Base address of type in question\n\n"
            "  Omitting expression prints offset information from structure\n"
            "  Example: !dtext.dumpoff W3SVC!HTTP_REQUEST 1fdde0\n"
        },

        {
            "vmstat",
            "Dump virtual memory statistics",
            "!vmstat - Dump virtual memory statistics"
        },

        {
            "vmmap",
            "Dump virtual memory map",
            "!vmmap - Dump virtual memory map"
        },

        {
            "nreq",
            "Dump specific (or all) UL_NATIVE_REQUEST",
            "!nreq [-<verbosity>] <addr> - Dump request at addr with optional verbosity\n"
            "!nreq [-<verbosity>] *      - Dump all UL_NATIVE_REQUESTs\n"
        },

        {
            "filter",
            "Dump ISAPI filter information",
            "!filter -g                  - Dump global filter information\n"
            "!filter -d <FILTER_DLL>     - Dump specified HTTP_FILTER_DLL"
            "!filter -l <FILTER_LIST>    - Dump specified FILTER_LIST\n"
            "!filter -x <FILTER_CONTEXT> - Dump specified FILTER_CONTEXT\n"
            "!filter -c <CONNECTION_CTXT>- Dump specified FILTER_CONNECTION_CONTEXT\n"
        },
        
#if 0
        {
            "global",
            "Dump global worker process structures",
            "!global - Dump global data"
        },
#endif

        {
            "lkrhash",
            "Dump LKRhash table structures",
            "!lkrhash [options] <addr>    - Dump LKRhash table at <addr>\n"
             "     -l[0-2] == verbosity level\n"
             "     -v      == very verbose\n"
             "     -g[0-2] == dump global list of LKRhashes at verbosity level\n"
        },
        
        {
            "asp",
            "Dump ASP structures",
            "!asp -g -p -t <addr>\n"
            "      -g - dump interesting ASP globals\n"
            "      -p - dump ASP Perf Counters\n"
            "      -t - dump ASP Template Information given Template address at <addr>\n"            
        },

        {
            "csleak",
            "finds the most heavy critical-section initializers",
            "!csleak [-m minNoise] [-v verbosity] - Only print stack-traces contributing to at least minNoise crit-secs, at verbosity specified\n"
        },

    };

#define NUM_HELP_MAPS ( sizeof(HelpMaps) / sizeof(HelpMaps[0]) )


PSTR
FindHelpForCommand(
    IN PCSTR CommandName
    )
{

    PHELP_MAP helpMap;
    ULONG i;

    for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
        if( _stricmp( helpMap->Command, CommandName ) == 0 ) {
            return helpMap->FullHelp;
        }
    }

    return NULL;

}   // FindHelpForCommand

VOID
PrintUsage(
    IN PCSTR CommandName
    )
{

    PSTR cmdHelp;
    PHELP_MAP helpMap;
    ULONG i;
    ULONG maxLength;
    ULONG length;

    dprintf( "Duct Tape debugging extension for Duct Tape Version 1.0\n" );

    if( CommandName == NULL ) {

        //
        // We'll display the one-liners for each command. Start by
        // scanning the commands to find the longest length. This makes the
        // output much prettier without having to manually tweak the
        // columns.
        //

        maxLength = 0;

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            length = (ULONG)strlen( helpMap->Command );
            if( length > maxLength ) {
                maxLength = length;
            }
        }

        //
        // Now actually display the one-liners.
        //

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            dprintf(
                "!%-*s - %s\n",
                maxLength,
                helpMap->Command,
                helpMap->OneLiner
                );
        }

    } else {

        //
        // Find a specific command and display the full help.
        //

        cmdHelp = FindHelpForCommand( CommandName );

        if( cmdHelp == NULL ) {
            dprintf( "unrecognized command %s\n", CommandName );
        } else {
            dprintf( "%s", cmdHelp );
        }

    }

} // PrintUsage()


DECLARE_API( help )
{

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( !strcmp( args, "?" ) ) {
        args = "help";
    }

    if( *args == '\0' ) {
        args = NULL;
    }

    PrintUsage( args );

} // DECLARE_API( help )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\nreq.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nreq.cxx

Abstract:

    This module dumps UL_NATIVE_REQUEST objects.
    NTSD debugger extension.

Author:

    Michael Courage (mcourage) 07-19-99

Revision History:

--*/

#include "precomp.hxx"

extern 
VOID
DumpReferenceLog(
    IN PSTR args,
    IN BOOLEAN fReverse
    );

char * g_achRequestState[] = {
    "NREQ_STATE_START",
    "NREQ_STATE_READ",
    "NREQ_STATE_PROCESS",
    "NREQ_STATE_ERROR",
    "NREQ_STATE_CLIENT_CERT"
    };

char * g_achVerbs[] = {
    "Unparsed",
    "Unknown",
    "Invalid",
    "OPTIONS",
    "GET",
    "HEAD",
    "POST",
    "PUT",
    "DELETE",
    "TRACE",
    "CONNECT",
    "TRACK",
    "MOVE",
    "COPY",
    "PROPFIND",
    "PROPPATCH",
    "MKCOL",
    "LOCK",
    "UNLOCK",
    "SEARCH",
};

char * g_achKnownHeaders[ HttpHeaderRequestMaximum ] = {
    "Cache-Control",        // 0
    "Connection",
    "Date",
    "Keep-Alive",
    "Pragma",
    "Trailer",              // 5
    "Transfer-Encoding",
    "Upgrade",
    "Via",
    "Warning",
    "Allow",                // 10
    "Content-Length",
    "Content-Type",
    "Content-Encoding",
    "Content-Language",
    "Content-Location",     // 15
    "Content-MD5",
    "Content-Range",
    "Expires",
    "LastModified",
    "Accept",               // 20
    "Accept-CharSet",
    "Accept-Encoding",
    "Accept-Language",
    "Authorization",
    "Cookie",               // 25
    "Expect",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",    // 30
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Max-Forwards",
    "Proxy-Authorization",  // 35
    "Referer",
    "Range",
    "TE",
    "Translate",
    "User-Agent"            // 40
};

VOID
DumpString(
    const WCHAR *   pszDebugeeAddress,
    DWORD           cbBuffer
)
{
    PVOID pBuffer = LocalAlloc( LPTR, cbBuffer + sizeof(WCHAR) );
    if ( pBuffer != NULL )
    {
        moveBlock( (*((CHAR*)pBuffer)), (ULONG_PTR)pszDebugeeAddress, cbBuffer );
        dprintf(
            "%ws",
            (LPWSTR) pBuffer
            );
        
        LocalFree( pBuffer);
    }
}

VOID
DumpString(
    const CHAR *    pszDebugeeAddress,
    DWORD           cbBuffer
)
{
    PVOID pBuffer = LocalAlloc( LPTR, cbBuffer + sizeof(CHAR) );
    if ( pBuffer != NULL )
    {
        moveBlock( (*((CHAR*)pBuffer)), (ULONG_PTR)pszDebugeeAddress, cbBuffer );
        dprintf(
            "%s",
            (LPSTR) pBuffer
            );
        
        LocalFree( pBuffer);
    }
}

VOID
DumpRequestVerb(
    HTTP_REQUEST*    pUlReq
)
{
    if ( pUlReq->Verb == HttpVerbUnknown )
    {
        DumpString( pUlReq->pUnknownVerb,
                    pUlReq->UnknownVerbLength );
    }
    else
    {
        dprintf( g_achVerbs[ pUlReq->Verb ] );
    }
}

VOID
DumpRequestRawUrl(
    HTTP_REQUEST *   pUlReq
)
{
    DumpString( pUlReq->pRawUrl,
                pUlReq->RawUrlLength );
}

VOID
DumpRequestVersion(
    HTTP_REQUEST *   pUlReq
)
{
    dprintf( "HTTP/%d.%d", pUlReq->Version.MajorVersion, pUlReq->Version.MinorVersion );
}

VOID
DumpRequestHeaders(
    HTTP_REQUEST *   pUlReq
)
{
    DWORD               cCounter;

    //
    // First dump out known headers
    //
    
    for ( cCounter = 0; 
          cCounter < HttpHeaderRequestMaximum;
          cCounter++ )
    {
        if ( pUlReq->Headers.KnownHeaders[ cCounter ].pRawValue != NULL )
        {
            dprintf( 
                "%s: ",
                g_achKnownHeaders[ cCounter ]
                );
            
            DumpString( pUlReq->Headers.KnownHeaders[ cCounter ].pRawValue,
                        pUlReq->Headers.KnownHeaders[ cCounter ].RawValueLength );
            
            dprintf( "\n" );
        }
    }
          
    //
    // Dump out unknown headers
    //
    
    HTTP_UNKNOWN_HEADER *pUnknown = NULL;
    
    pUnknown = (HTTP_UNKNOWN_HEADER *)
                        LocalAlloc( LPTR,
                                    sizeof( HTTP_UNKNOWN_HEADER ) * 
                                    pUlReq->Headers.UnknownHeaderCount );    
    if ( pUnknown == NULL )
    {
        return;
    }
    
    moveBlock( (*(pUnknown)), 
               (ULONG_PTR)pUlReq->Headers.pUnknownHeaders,
               sizeof( HTTP_UNKNOWN_HEADER ) * pUlReq->Headers.UnknownHeaderCount );
    
    for ( cCounter = 0;
          cCounter < pUlReq->Headers.UnknownHeaderCount;
          cCounter++ )
    {
        DumpString( pUnknown[ cCounter ].pName,
                    pUnknown[ cCounter ].NameLength );
                    
        dprintf( ": " );
        
        DumpString( pUnknown[ cCounter ].pRawValue,
                    pUnknown[ cCounter ].RawValueLength );
        
        dprintf( "\n" );
    }
    
    if ( pUnknown != NULL )
    {
        LocalFree( pUnknown );
    }
}

VOID
DumpNativeRequest(
    ULONG_PTR           nreqAddress,
    UL_NATIVE_REQUEST * pRequest,
    CHAR                chVerbosity
)
{
    char *              pszRequestState;
    char *              pbBuffer = NULL;
    HTTP_REQUEST *      pUlReq;
    CHAR                achRefCommand[ 256 ];
    
    if ( pRequest->_ExecState < NREQ_STATE_START ||
         pRequest->_ExecState > NREQ_STATE_CLIENT_CERT )
    {
        pszRequestState = "<Invalid>";
    }
    else
    {
        pszRequestState = g_achRequestState[ pRequest->_ExecState ];
    }
    
    //
    // Dump the bare minimum
    //
    
    dprintf(
        "%p : %s state = %s, refs = %d, pvContext = %p\n",
        nreqAddress,
        pRequest->_dwSignature == UL_NATIVE_REQUEST_SIGNATURE ? "" : " (INVALID!)",
        pszRequestState,
        pRequest->_cRefs,
        pRequest->_pvContext 
        );

    //
    // Next verbosity is still pretty trivial
    //

    if ( chVerbosity >= '1' )
    {
        dprintf(
            "\t_cbAsyncIOData       = %d\n"
            "\t_dwAsyncIOError      = %d\n"
            "\t_overlapped.Internal = %08x\n"
            "\t(UL_HTTP_REQUEST*)   = %p\n",
            pRequest->_cbAsyncIOData,
            pRequest->_dwAsyncIOError,
            pRequest->_Overlapped.Internal,
            pRequest->_pbBuffer
            );
    }
    
    //
    // Dump out some more useful stuff.  Now we will actually go to the
    // UL_HTTP_REQUEST structure
    // 
    // But do so only if the state is NREQ_STATE_PROCESS (i.e. we've read
    // the request
    //
    
    if ( pRequest->_ExecState != NREQ_STATE_PROCESS &&
         pRequest->_ExecState != NREQ_STATE_CLIENT_CERT )
    {
        return;
    }

    pbBuffer = (CHAR*) LocalAlloc( LPTR, pRequest->_cbBuffer );
    if ( pbBuffer == NULL )
    {
        return;
    }
    moveBlock( (*(pbBuffer)), 
               (ULONG_PTR)pRequest->_pbBuffer, 
               pRequest->_cbBuffer );
    pUlReq = (HTTP_REQUEST*) pbBuffer;

    //
    // Dump out the entire "stream"ized request
    //

    if ( chVerbosity >= '2' )
    {
        dprintf( 
            "\tConnectionId = %I64x\n"
            "\tRequestId    = %I64x\n"
            "-------------\n",
            pUlReq->ConnectionId,
            pUlReq->RequestId
            );

        //
        // Dump the request line
        //
            
        DumpRequestVerb( pUlReq );
        dprintf( " " );
        DumpRequestRawUrl( pUlReq );
        dprintf( " " );
        DumpRequestVersion( pUlReq );
        dprintf( "\n" );

        //
        // Dump the headers
        //
            
        DumpRequestHeaders( pUlReq );
        
        dprintf( 
            "-------------\n\n"
            );
    }

    if ( chVerbosity >= '3' )
    {    
        //
        // Dump out the reference log (if any)
        //

        sprintf( achRefCommand,
                 "poi(w3dt!UL_NATIVE_REQUEST__sm_pTraceLog) %p",
                 nreqAddress );
    
        DumpReferenceLog( achRefCommand, FALSE );   
    }
    
    //
    // Cleanup 
    //
    
    if ( pbBuffer != NULL )
    {
        LocalFree( pbBuffer );
    }
}

VOID
DumpNativeRequestThunk(
    PVOID nreqAddress,
    PVOID pnreq,
    CHAR  chVerbosity,
    DWORD iThunk
    )
{
    DumpNativeRequest(
        (ULONG_PTR) nreqAddress,
        (UL_NATIVE_REQUEST *) pnreq,
        chVerbosity
        );
    dprintf("\n");
}


VOID
DumpAllNativeRequests(
    CHAR chVerbosity
    )
{
    ULONG_PTR       reqlistAddress;

    reqlistAddress = GetExpression("&w3dt!UL_NATIVE_REQUEST__sm_RequestListHead");
    if (!reqlistAddress) 
    {
        dprintf("couldn't evaluate w3dt!UL_NATIVE_REQUEST__sm_RequestListHead\n");
        return;
    }

    EnumLinkedList(
        (LIST_ENTRY *) reqlistAddress,
        DumpNativeRequestThunk,
        chVerbosity,
        sizeof(UL_NATIVE_REQUEST),
        FIELD_OFFSET(UL_NATIVE_REQUEST, _ListEntry)
        );
}


DECLARE_API( nreq )
/*++

Routine Description:

    This function is called as an NTSD extension to reset a reference
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    ULONG_PTR               nreqAddress;
    CHAR                    chVerbosity = 0;
    DEFINE_CPP_VAR( UL_NATIVE_REQUEST, nreq );

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) 
    {
        args++;
    }
    
    //
    // Parse out verbosity if any
    //    
    
    if ( *args == '-' )
    {
        args++;
        chVerbosity = *args;
        
        if ( *args != '\0' )
        {
            args++;
        } 
    }
    
    //
    // Skip spaces again
    //
    
    while( *args == ' ' ||
           *args == '\t' ) 
    {
        args++;
    }
    
    //
    // * means list
    //
    
    if ( *args == '\0' ||
         *args == '*' ) 
    {
        //
        // Default verbosity on a list is minimal
        //
        
        if ( chVerbosity == 0 )
        {
            chVerbosity = '0';
        }
        
        DumpAllNativeRequests( chVerbosity );
    }
    else
    {
        nreqAddress = GetExpression( args );

        if (nreqAddress) {

            move( nreq, nreqAddress );

            //
            // Default verbosity on a single dump is high
            //
            
            if ( chVerbosity == 0 )
            {
                chVerbosity = '2';
            }

            DumpNativeRequest(
                nreqAddress,
                GET_CPP_VAR_PTR(UL_NATIVE_REQUEST, nreq),
                chVerbosity
                );

        } else {
            dprintf(
                "nreq: cannot evaluate \"%s\"\n",
                args
                );
        }
    }
} // DECLARE_API( nreq )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\mod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    mod.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping module
    information.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "precomp.hxx"

typedef struct _ENUM_CONTEXT {
    BOOLEAN FirstTime;
} ENUM_CONTEXT, *PENUM_CONTEXT;


/************************************************************
 * Dump Module Info
 ************************************************************/


BOOLEAN
CALLBACK
ModpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;

    context = (PENUM_CONTEXT)Param;

    if( context->FirstTime ) {
        context->FirstTime = FALSE;
        dprintf( "Start    End      Entry    Path\n" );
    }

    dprintf(
        "%08lx %08lx %08lx %s\n",
        ModuleInfo->DllBase,
        ModuleInfo->DllBase + ModuleInfo->SizeOfImage,
        ModuleInfo->EntryPoint,
        ModuleInfo->FullName
        );

    return TRUE;

}   // ModpEnumProc


DECLARE_API( mod )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    module information.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;
    MODULE_INFO modInfo;
    ULONG_PTR address;
    PSTR endPointer;

    context.FirstTime = TRUE;

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( *args == '\0' ) {

        //
        // No argument passed, dump all modules.
        //

        if( !EnumModules(
                ModpEnumProc,
                (PVOID)&context
                ) ) {
            dprintf( "error retrieving module list\n" );
        }

    } else {

        //
        // Try to find the module containing the specified address.
        //

        address = strtoul( args, &endPointer, 16 );

        if( *endPointer != ' ' && *endPointer != '\t' && *endPointer != '\0' ) {
            PrintUsage( "mod" );
            return;
        }

        if( FindModuleByAddress( address, &modInfo ) ) {
            ModpEnumProc( (PVOID)&context, &modInfo );
        } else {
            dprintf( "Cannot find %08lx\n", address );
        }

    }

}   // DECLARE_API( mod )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\ntstuff.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ntstuff.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    NT-specific properties.

Author:

    Keith Moore (keithmo) 08-Nov-1997

Revision History:

--*/

#include "precomp.hxx"



/************************************************************
 * Dump Current Error Mode
 ************************************************************/

DECLARE_API( gem )

/*++

Routine Description:

    This function is called as an NTSD extension to display the
    current error mode of the debugee.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    UINT errorMode;

    status = NtQueryInformationProcess(
                 hCurrentProcess,
                 ProcessDefaultHardErrorMode,
                 (PVOID)&errorMode,
                 sizeof(errorMode),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        dprintf( "Cannot query error mode, error %08lx\n", status );
        return;
    }

    if( errorMode & 1 ) {
        errorMode &= ~SEM_FAILCRITICALERRORS;
    } else {
        errorMode |= SEM_FAILCRITICALERRORS;
    }

    dprintf(
        "Current error mode = %08lx\n",
        errorMode
        );

    if( errorMode & SEM_FAILCRITICALERRORS ) {
        dprintf( "    SEM_FAILCRITICALERRORS\n" );
    }

    if( errorMode & SEM_NOGPFAULTERRORBOX ) {
        dprintf( "    SEM_NOGPFAULTERRORBOX\n" );
    }

    if( errorMode & SEM_NOALIGNMENTFAULTEXCEPT ) {
        dprintf( "    SEM_NOALIGNMENTFAULTEXCEPT\n" );
    }

    if( errorMode & SEM_NOOPENFILEERRORBOX ) {
        dprintf( "    SEM_NOOPENFILEERRORBOX\n" );
    }

}   // DECLARE_API( gem )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\iisres\makefile.inc ===
$(O)\iismsg.mc: *.mc $(IISBASEDIR)\inc\inetamsg.mc
    copy $(MESSAGEFILES) $(O)\iismsg.mc

$(O)\MSG00001.bin: $(O)\iismsg.mc
    mc -h $(PASS0_HEADERDIR) -r $(O)  $(O)\iismsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\stktrace.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This header file defines the format of the stack trace data base
    used to track caller backtraces.  This is a header file so debugger
    extensions can lookup entries in the database remotely.

Author:

    Steve Wood (stevewo) 13-Sep-1992

Revision History:

--*/

#ifndef _STKTRACE_H_
#define _STKTRACE_H_

typedef struct _RTL_STACK_TRACE_ENTRY {
    struct _RTL_STACK_TRACE_ENTRY *HashChain;
    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    PVOID BackTrace[ MAX_STACK_DEPTH ];
} RTL_STACK_TRACE_ENTRY, *PRTL_STACK_TRACE_ENTRY;

typedef struct _STACK_TRACE_DATABASE {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;

    PRTL_ACQUIRE_LOCK_ROUTINE AcquireLockRoutine;
    PRTL_RELEASE_LOCK_ROUTINE ReleaseLockRoutine;
    PRTL_OKAY_TO_LOCK_ROUTINE OkayToLockRoutine;

    BOOLEAN PreCommitted;
    BOOLEAN DumpInProgress;
    PVOID CommitBase;
    PVOID CurrentLowerCommitLimit;
    PVOID CurrentUpperCommitLimit;
    PCHAR NextFreeLowerMemory;
    PCHAR NextFreeUpperMemory;
    ULONG NumberOfEntriesLookedUp;
    ULONG NumberOfEntriesAdded;
    PRTL_STACK_TRACE_ENTRY *EntryIndexArray;    // Indexed by [-1 .. -NumberOfEntriesAdded]
    ULONG NumberOfBuckets;
    PRTL_STACK_TRACE_ENTRY Buckets[ 1 ];
} STACK_TRACE_DATABASE, *PSTACK_TRACE_DATABASE;

PSTACK_TRACE_DATABASE
RtlpAcquireStackTraceDataBase( VOID );

VOID
RtlpReleaseStackTraceDataBase( VOID );

#endif // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\oemdbi.h ===
// Debug Information API
// VC++5.0 Read-Only OEM Edition
// Copyright (C) 1993-1997, Microsoft Corp.  All Rights Reserved.

#ifndef __OEMDBI_INCLUDED__
#define __OEMDBI_INCLUDED__

typedef int             BOOL;
typedef unsigned        UINT;
typedef unsigned char   BYTE;
typedef unsigned long   ULONG;
typedef unsigned short  USHORT;
typedef unsigned long   DWORD;
typedef short           SHORT;
typedef long            LONG;
typedef char *          SZ;

typedef unsigned long   CV_typ_t;
typedef CV_typ_t        TI;     // PDB name for type index
typedef ULONG           INTV;   // interface version number
typedef ULONG           IMPV;   // implementation version number
typedef ULONG           SIG;    // unique (across PDB instances) signature
typedef ULONG           AGE;    // no. of times this instance has been updated
typedef BYTE*           PB;     // pointer to some bytes
typedef LONG            CB;     // count of bytes
typedef char*           SZ;     // zero terminated string
typedef char*           PCH;    // char ptr
typedef USHORT          IFILE;  // file index
typedef USHORT          IMOD;   // module index
typedef USHORT          ISECT;  // section index
typedef USHORT          LINE;   // line number
typedef LONG            OFF;    // offset
typedef BYTE            ITSM;   // type server map index

enum {
    PDBIntv50a  = 19970116,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntv     = PDBIntv50a,
};

enum {
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,    // max. length of error message
};

typedef CV_typ_t TI;        // type index
struct PDB;                 // program database
struct DBI;                 // debug information within the PDB
struct Mod;                 // a module within the DBI
struct TPI;                 // type info within the DBI
struct GSI;
struct Enum;                // generic enumerator
struct EnumContrib;         // enumerate contributions
struct Dbg;                 // misc debug data (FPO, OMAP, etc)

typedef struct PDB PDB;
typedef struct DBI DBI;
typedef struct Mod Mod;
typedef struct TPI TPI;
typedef struct GSI GSI;
typedef struct Enum Enum;
typedef struct EnumContrib EnumContrib;
typedef struct Dbg Dbg;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_MAX
};

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL

#define PDBAPI PDB_IMPORT_EXPORT

#define IN                  /* in parameter, parameters are IN by default */
#define OUT                 /* out parameter */

struct _tagSEARCHDEBUGINFO;
typedef BOOL (__stdcall * pfnFindDebugInfoFile) ( struct _tagSEARCHDEBUGINFO* );
typedef BOOL (__stdcall * PFNVALIDATEDEBUGINFOFILE) (const char* szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancillary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    SZ      szMod;                      // exe/dll
    SZ      szLib;                      // lib if appropriate
    SZ      szObj;                      // object file
    SZ *    rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char    szValidatedFile[PDB_MAX_PATH]; // output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
};

typedef enum DBGTYPE DBGTYPE;

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

PDBAPI( BOOL )
PDBOpenValidate(
    SZ szPDB,
    SZ szExeDir,
    SZ szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI( BOOL )
PDBOpen(
    SZ szPDB,
    SZ szMode,
    SIG sigInitial,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI( BOOL )
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface()
{
    return PDBExportValidateInterface(PDBIntv);
}

PDBAPI( EC )    PDBQueryLastError(PDB* ppdb, OUT char szError[cbErrMax]);
PDBAPI( INTV )  PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI( IMPV )  PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI( SZ )    PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI( SIG )   PDBQuerySignature(PDB* ppdb);
PDBAPI( AGE )   PDBQueryAge(PDB* ppdb);
PDBAPI( BOOL )  PDBOpenDBI(PDB* ppdb, SZ szMode, SZ szTarget, OUT DBI** ppdbi);
PDBAPI( BOOL )  PDBOpenTpi(PDB* ppdb, SZ szMode, OUT TPI** pptpi);
PDBAPI( BOOL )  PDBClose(PDB* ppdb);
PDBAPI( BOOL )  PDBOpenDBIEx(PDB* ppdb, const char* szTarget, const char* szMode, OUT DBI** ppdbi, pfnFindDebugInfoFile srchfcn);

PDBAPI( BOOL )  DBIOpenMod(DBI* pdbi, SZ szModule, SZ szFile, OUT Mod** ppmod);
PDBAPI( BOOL )  DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI( BOOL )  DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI( BOOL )  DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI( BOOL )  DBIQueryModFromAddr(DBI* pdbi, ISECT isect, OFF off, OUT Mod** ppmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb);
PDBAPI( BOOL )  DBIQuerySecMap(DBI* pdbi, OUT PB pb, CB* pcb);
PDBAPI( BOOL )  DBIQueryFileInfo(DBI* pdbi, OUT PB pb, CB* pcb);
PDBAPI( BOOL )  DBIClose(DBI* pdbi);
PDBAPI( BOOL )  DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI( BOOL )  DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI( BOOL )  DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI( BOOL )  DBIQueryLazyTypes(DBI* pdbi);
PDBAPI( BOOL )  DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI( BOOL )  DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI( BOOL )  DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);

PDBAPI( BOOL )  ModQueryCBName(Mod* pmod, OUT CB* pcb);
PDBAPI( BOOL )  ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT CB* pcb);
PDBAPI( BOOL )  ModQuerySymbols(Mod* pmod, PB pbSym, CB* pcb);
PDBAPI( BOOL )  ModQueryLines(Mod* pmod, PB pbLines, CB* pcb);
PDBAPI( BOOL )  ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI( BOOL )  ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI( BOOL )  ModQuerySecContrib(Mod* pmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI( BOOL )  ModQueryImod(Mod* pmod, OUT IMOD* pimod);
PDBAPI( BOOL )  ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI( BOOL )  ModClose(Mod* pmod);
PDBAPI( BOOL )  ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI( BOOL )  ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI( BOOL )  ModQueryTpi(Mod* pmod, OUT TPI** pptpi);

PDBAPI( void )  EnumContribRelease(EnumContrib* penum);
PDBAPI( void )  EnumContribReset(EnumContrib* penum);
PDBAPI( BOOL )  EnumContribNext(EnumContrib* penum);
PDBAPI( void )  EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);

PDBAPI( BOOL )  DbgClose(Dbg *pdbg);
PDBAPI( long )  DbgQuerySize(Dbg *pdbg);
PDBAPI( void )  DbgReset(Dbg *pdbg);
PDBAPI( BOOL )  DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI( BOOL )  DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI( BOOL )  DbgFind(Dbg *pdbg, IN OUT void *pelt);

// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)    TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT PB pb, IN OUT CB* pcb);
PDBAPI(BOOL)    TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT PB* ppb);
PDBAPI(TI)      TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)      TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(CB)      TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)    TypesClose(TPI* ptpi);
PDBAPI(BOOL)    TypesQueryTiForUDTEx(TPI* ptpi, char* sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)    TypesSupportQueryTiForUDT(TPI*);

// Map all old ones to new ones for new compilands.
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx

PDBAPI( PB )    GSINextSym (GSI* pgsi, PB pbSym);
PDBAPI( PB )    GSIHashSym (GSI* pgsi, SZ szName, PB pbSym);
PDBAPI( PB )    GSINearestSym (GSI* pgsi, ISECT isect, OFF off,OUT OFF* pdisp);//currently only supported for publics
PDBAPI( BOOL )  GSIClose(GSI* pgsi);

#if __cplusplus
};
#endif

#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((IMOD)(-1))

#define pdbRead                 "r"
#define pdbGetRecordsOnly       "c"         /* open PDB for type record access */

#endif // __OEMDBI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\ver.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ver.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping module
    version resources.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "precomp.hxx"

PSTR VersionLabels[] =
     {
         "CompanyName",
         "FileDescription",
         "FileVersion",
         "InternalName",
         "LegalCopyright",
         "OriginalFilename",
         "ProductName",
         "ProductVersion"
     };
#define NUM_LABELS ( sizeof(VersionLabels) / sizeof(VersionLabels[0]) )

typedef struct _ENUM_CONTEXT {
    PSTR ModuleName;
    INT NameLength;
} ENUM_CONTEXT, *PENUM_CONTEXT;


/************************************************************
 * Dump File Version Info
 ************************************************************/

PIMAGE_RESOURCE_DIRECTORY
FindResourceDir(
    IN PIMAGE_RESOURCE_DIRECTORY BaseResourceDir,
    IN PIMAGE_RESOURCE_DIRECTORY TargetResourceDir,
    IN USHORT ResourceId
    )

/*++

Routine Description:

    Finds the specified resource directory.

Arguments:

    BaseResourceDir - The (remote) address of the *start* of the resource
        section.

    TargetResourceDir - The (remote) address of the resource directory
        to search.

    ResourceId - The resource ID we're looking for.

Return Value:

    PIMAGE_RESOURCE_DIRECTORY - Pointer to the resource directory
        corresponding to ResourceId if successful, NULL otherwise.

--*/

{

    IMAGE_RESOURCE_DIRECTORY localDir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY localEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY remoteEntry;
    USHORT i;

    //
    // Read the target resource directory.
    //

    if( !ReadMemory(
            (ULONG_PTR)TargetResourceDir,
            &localDir,
            sizeof(localDir),
            NULL
            ) ) {
        return NULL;
    }

    //
    // Scan it.
    //

    remoteEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( TargetResourceDir + 1 );

    for( i = localDir.NumberOfNamedEntries + localDir.NumberOfIdEntries ;
         i > 0 ;
         i--, remoteEntry++ ) {

        //
        // Read the directory entry.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteEntry,
                &localEntry,
                sizeof(localEntry),
                NULL
                ) ) {
            return NULL;
        }

        //
        // If the entry is a directory and the IDs match, then return it.
        //

        if( localEntry.DataIsDirectory == 0 ) {
            continue;
        }

        if( localEntry.NameIsString == 0 &&
            localEntry.Id == ResourceId ) {

            return (PIMAGE_RESOURCE_DIRECTORY)
                       ( (ULONG_PTR)BaseResourceDir + localEntry.OffsetToDirectory );

        }

    }

    return NULL;

}   // FindResourceDir

PIMAGE_RESOURCE_DATA_ENTRY
FindResourceData(
    IN PIMAGE_RESOURCE_DIRECTORY BaseResourceDir,
    IN PIMAGE_RESOURCE_DIRECTORY TargetResourceDir,
    IN USHORT ResourceId
    )

/*++

Routine Description:

    Finds the specified resource data item.

Arguments:

    BaseResourceDir - The (remote) address of the *start* of the resource
        section.

    TargetResourceDir - The (remote) address of the resource directory
        to search.

    ResourceId - The resource ID we're looking for. This may be zero
        to return any resource.

Return Value:

    PIMAGE_RESOURCE_DATA_ENTRY - Pointer to the resource data entry
        corresponding to ResourceId if successful, NULL otherwise.

--*/

{

    IMAGE_RESOURCE_DIRECTORY localDir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY localEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY remoteEntry;
    USHORT i;

    //
    // Read the target resource directory.
    //

    if( !ReadMemory(
            (ULONG_PTR)TargetResourceDir,
            &localDir,
            sizeof(localDir),
            NULL
            ) ) {
        return NULL;
    }

    //
    // Scan it.
    //

    remoteEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( TargetResourceDir + 1 );

    for( i = localDir.NumberOfNamedEntries + localDir.NumberOfIdEntries ;
         i > 0 ;
         i--, remoteEntry++ ) {

        //
        // Read the directory entry.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteEntry,
                &localEntry,
                sizeof(localEntry),
                NULL
                ) ) {
            return NULL;
        }

        //
        // If the entry is not a directory and the IDs match (or the
        // requested ID is zero, meaning any ID) then return it.
        //

        if( localEntry.DataIsDirectory != 0 ) {
            continue;
        }

        if( localEntry.NameIsString == 0 &&
            ( localEntry.Id == ResourceId ||
              ResourceId == 0 ) ) {

            return (PIMAGE_RESOURCE_DATA_ENTRY)
                       ( (ULONG_PTR)BaseResourceDir + localEntry.OffsetToDirectory );

        }

    }

    return NULL;

}   // FindResourceData


BOOL
DumpVersionResource(
    IN PVOID VersionResource
    )

/*++

Routine Description:

    Dumps a version resource block.

Arguments:

    VersionResource - The version resource to dump.

Return Value:

    BOOL - TRUE if successful, FALSE if the version resource block
        was corrupt or unreadable.

--*/

{

    ULONG charSet;
    LPVOID version;
    UINT versionLength;
    INT i;
    VS_FIXEDFILEINFO * fixedFileInfo;
    CHAR label[MAX_PATH];

    //
    // Get the language/character-set pair.
    //

    if( !VerQueryValueA(
            VersionResource,
            "\\VarFileInfo\\Translation",
            &version,
            &versionLength
            ) ) {
        return FALSE;
    }

    charSet = *(LPDWORD)version;
    charSet = (DWORD)MAKELONG( HIWORD(charSet), LOWORD(charSet) );

    //
    // Get the root block so we can determine if this is a free or
    // checked build.
    //

    if( !VerQueryValueA(
             VersionResource,
             "\\",
             &version,
             &versionLength
             ) ) {
        return FALSE;
    }

    fixedFileInfo = (VS_FIXEDFILEINFO *)version;

    dprintf(
        "%-19s = 0x%08lx (%s)\n",
        "dwFileFlags",
        fixedFileInfo->dwFileFlags,
        ( ( fixedFileInfo->dwFileFlags & VS_FF_DEBUG ) != 0 )
            ? "CHECKED"
            : "FREE"
        );

    //
    // Dump the various version strings.
    //

    for( i = 0 ; i < NUM_LABELS ; i++ ) {

        wsprintfA(
            label,
            "\\StringFileInfo\\%08lX\\%s",
            charSet,
            VersionLabels[i]
            );

        if( VerQueryValueA(
                VersionResource,
                label,
                &version,
                &versionLength
                ) ) {
            dprintf(
                "%-19s = %s\n",
                VersionLabels[i],
                version
                );
        }

    }

    dprintf( "\n" );

    return TRUE;

}   // DumpVersionResource


VOID
FindAndDumpVersionResourceByAddress(
    IN ULONG_PTR ModuleAddress,
    IN PSTR ModuleName
    )

/*++

Routine Description:

    Locates and dumps the version resource for the module based at
    the specified address.

Arguments:

    ModuleAddress - The base address of the module to dump.

    ModuleName - The module name, for display purposes.

Return Value:

    None.

--*/

{

    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS ntHeaders;
    PIMAGE_OPTIONAL_HEADER optionalHeader;
    PIMAGE_DATA_DIRECTORY dataDir;
    PIMAGE_RESOURCE_DIRECTORY baseResourceDir;
    PIMAGE_RESOURCE_DIRECTORY tmpResourceDir;
    PIMAGE_RESOURCE_DATA_ENTRY dataEntry;
    IMAGE_RESOURCE_DATA_ENTRY localDataEntry;
    PVOID versionResource;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    versionResource = NULL;

    //
    // Read & validate the image headers.
    //

    if( !ReadMemory(
            ModuleAddress,
            &dosHeader,
            sizeof(dosHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.ver: cannot read DOS header @ 0x%p\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( dosHeader.e_magic != IMAGE_DOS_SIGNATURE ) {

        dprintf(
            "dtext.ver: module @ 0x%p has invalid DOS header\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( !ReadMemory(
            ModuleAddress + dosHeader.e_lfanew,
            &ntHeaders,
            sizeof(ntHeaders),
            NULL
            ) ) {

        dprintf(
            "dtext.ver: cannot read NT headers @ 0x%p\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( ntHeaders.Signature != IMAGE_NT_SIGNATURE ) {

        dprintf(
            "dtext.ver: module @ 0x%p has invalid NT headers\n",
            ModuleAddress
            );

        goto cleanup;

    }

    optionalHeader = &ntHeaders.OptionalHeader;

    if( optionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC ) {

        dprintf(
            "dtext.ver: module @ 0x%p has invalid optional header\n",
            ModuleAddress
            );

        goto cleanup;

    }

    //
    // Locate the resource.
    //

    dataDir = &optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];

    if( dataDir->VirtualAddress == 0 ||
        dataDir->Size == 0 ) {

        dprintf(
            "dtext.ver: module @ 0x%p has no resource information\n",
            ModuleAddress
            );

        goto cleanup;

    }

    baseResourceDir = (PIMAGE_RESOURCE_DIRECTORY)
                          ( ModuleAddress + dataDir->VirtualAddress );

    //
    // Now go and find the resource in the image. Since resources are
    // stored heirarchally, we're basically for the resource path:
    //
    //     VS_FILE_INFO\VS_VERSION_INFO\LanguageId
    //
    // For the language ID, we'll first try 0x409 (English) and if
    // that fails, we'll take any language.
    //

    dataEntry = NULL;

    tmpResourceDir = FindResourceDir(
                         baseResourceDir,
                         baseResourceDir,
                         (USHORT)VS_FILE_INFO
                         );

    if( tmpResourceDir != NULL ) {

        tmpResourceDir = FindResourceDir(
                             baseResourceDir,
                             tmpResourceDir,
                             (USHORT)VS_VERSION_INFO
                             );

        if( tmpResourceDir != NULL ) {

            dataEntry = FindResourceData(
                            baseResourceDir,
                            tmpResourceDir,
                            0x409
                            );

            if( dataEntry == NULL ) {

                dataEntry = FindResourceData(
                                baseResourceDir,
                                tmpResourceDir,
                                0
                                );

            }

        }

    }

    if( dataEntry == NULL ) {

        dprintf(
            "dtext.ver: cannot find version resource\n"
            );

        goto cleanup;

    }

    //
    // Actually read the dir entry.
    //

    if( !ReadMemory(
            (ULONG_PTR)dataEntry,
            &localDataEntry,
            sizeof(localDataEntry),
            NULL
            ) ) {

        dprintf(
            "dtext.ver: error reading resource\n"
            );

        goto cleanup;

    }

    //
    // Now we can allocate & read the resource.
    //

    versionResource = malloc( localDataEntry.Size );

    if( versionResource == NULL ) {

        dprintf(
            "dtext.ver: not enough memory\n"
            );

        goto cleanup;

    }

    if( !ReadMemory(
            ModuleAddress + localDataEntry.OffsetToData,
            versionResource,
            localDataEntry.Size,
            NULL
            ) ) {

        dprintf(
            "dtext.ver: error reading resource\n"
            );

        goto cleanup;

    }

    //
    // Dump it.
    //

    dprintf(
        "Module @ 0x%p = %s\n",
        ModuleAddress,
        ModuleName
        );

    if( !DumpVersionResource( versionResource ) ) {

        dprintf(
            "Cannot interpret version resource\n"
            );

        goto cleanup;

    }

cleanup:

    if( versionResource != NULL ) {
        free( versionResource );
    }

}   // FindAndDumpVersionResourceByAddress


BOOLEAN
CALLBACK
VerpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;
    INT baseNameLength;

    context = (PENUM_CONTEXT)Param;
    baseNameLength = strlen( ModuleInfo->BaseName );

    //
    // If the user wants all modules, or if the specified module matches
    // the "tail" of the module name, dump it.
    //

    if( context->ModuleName == NULL ||
        ( baseNameLength >= context->NameLength &&
          !_stricmp(
              context->ModuleName,
              ModuleInfo->BaseName + baseNameLength - context->NameLength
              ) ) ) {

        FindAndDumpVersionResourceByAddress(
            ModuleInfo->DllBase,
            ModuleInfo->BaseName
            );

    }

    return TRUE;

}   // VerpEnumProc


VOID
FindAndDumpVersionResourceByName(
    IN PSTR ModuleName
    )

/*++

Routine Description:

    Locates and dumps the version resource for the specified module.

Arguments:

    ModuleName - The name of the module to dump. If this is NULL then
        all modules are dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;

    context.ModuleName = ModuleName;

    if( ModuleName == NULL ) {
        context.NameLength = 0;
    } else {
        context.NameLength = strlen( ModuleName );
    }

    if( !EnumModules(
            VerpEnumProc,
            (PVOID)&context
            ) ) {
        dprintf( "error retrieving module list\n" );
    }

}   // FindAndDumpVersionResourceByName


DECLARE_API( ver )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    module version info.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG module;
    PSTR endPointer;

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( *args == '\0' ) {

        //
        // No argument passed, dump all modules.
        //

        FindAndDumpVersionResourceByName( NULL );

    } else {

        module = strtoul( args, &endPointer, 16 );

        if( *endPointer != ' ' && *endPointer != '\t' && *endPointer != '\0' ) {

            //
            // Assume the argument is actually a module name, not
            // a base address.
            //

            FindAndDumpVersionResourceByName( (PSTR)args );

        } else {

            FindAndDumpVersionResourceByAddress( module, NULL );

        }

    }

}   // DECLARE_API( ver )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\ref.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ref.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    Internet Information Server.

Author:

    Keith Moore (keithmo) 27-Aug-1997

Revision History:

--*/

#include "precomp.hxx"

//
// The maximum number of contexts that may be passed to the "ref"
// extension command on the command line.
//

#define MAX_REF_CONTEXT 64


/************************************************************
 * Dump Reference Traces
 ************************************************************/


BOOL
IsContextInList(
    IN PVOID Context,
    IN PVOID * ContextList,
    IN LONG NumContextsInList
    )

/*++

Routine Description:

    Scans the given context list looking for the specified context value.

Arguments:

    Context - The context value to look for.

    ContextList - The context list to scan.

    NumContextsInList - The number of contexts in the context list.

Return Value:

    BOOL - TRUE if the context value is in the list, FALSE if not.

--*/

{
    while( NumContextsInList > 0 ) {
        if( *ContextList == Context ) {
            return TRUE;
        }

        ContextList++;
        NumContextsInList--;
    }

    return FALSE;
}


VOID
DumpReferenceLog(
    IN PSTR args,
    IN BOOLEAN fReverse
    )

/*++

Routine Description:

    Dumps the specified reference log either forwards (fReverse == FALSE)
    or backwards (fReverse == TRUE).

Arguments:

    args - An expression specifying the reference log to
        dump.

    fReverse - The dump direction.

Return Value:

    None.

--*/

{
    ULONG_PTR refLogAddress = 0;
    ULONG_PTR entryAddress;
    LONG numEntries;
    TRACE_LOG logHeader;
    REF_TRACE_LOG_ENTRY logEntry;
    LONG i;
    ULONG_PTR offset;
    PCHAR format;
    PVOID specificContexts[MAX_REF_CONTEXT];
    LONG numSpecificContexts = 0;
    LONG index;
    LONG direction;
    PSTR cmdName;
    CHAR symbol[MAX_SYMBOL_LEN];

    direction = fReverse ? -1 : 1;
    cmdName = fReverse ? "rref" : "ref";

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( *args == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    refLogAddress = (ULONG_PTR)GetExpression( args );

    if( refLogAddress == 0 ) {

        dprintf(
            "dtext.%s: cannot evaluate \"%s\"\n",
            cmdName,
            args
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *args != ' ' &&
           *args != '\t' &&
           *args != '\0' ) {
        args++;
    }

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    //
    // If we have context values, use them.
    //

    while( *args != '\0' && numSpecificContexts < MAX_REF_CONTEXT ) {

        specificContexts[numSpecificContexts++] =
            (PVOID)GetExpression( args );

        while( *args != ' ' &&
               *args != '\t' &&
               *args != '\0' ) {
            args++;
        }

        while( *args == ' ' ||
               *args == '\t' ) {
            args++;
        }

    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.%s: cannot read memory @ %p\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    dprintf(
        "dtext.%s: log @ %p:\n"
        "    Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        cmdName,
        (PVOID)refLogAddress,
        logHeader.Signature,
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.LogBuffer
        );

    if( logHeader.LogBuffer > ( (PUCHAR)refLogAddress + sizeof(logHeader) ) ) {
        dprintf(
            "    Extra Data @ %p\n",
            (PVOID)( refLogAddress + sizeof(logHeader) )
            );
    }

    if( logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X ) {

        dprintf(
            "dtext.%s: log @ %p has invalid signature %08lx:\n",
            cmdName,
            (PVOID)refLogAddress,
            logHeader.Signature
            );

        return;

    }

    if( logHeader.EntrySize != sizeof(logEntry) ) {

        dprintf(
            "dtext.%s: log @ %p is not a ref count log\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    if( logHeader.NextEntry == -1 ) {

        dprintf(
            "dtext.%s: empty log @ %p\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    //
    // Calculate the starting address and number of entries.
    //

    if( fReverse ) {
        if( logHeader.NextEntry < logHeader.LogSize ) {
            numEntries = logHeader.NextEntry + 1;
            index = logHeader.NextEntry;
        } else {
            numEntries = logHeader.LogSize;
            index = logHeader.NextEntry % logHeader.LogSize;
        }
    } else {
        if( logHeader.NextEntry < logHeader.LogSize ) {
            numEntries = logHeader.NextEntry + 1;
            index = 0;
        } else {
            numEntries = logHeader.LogSize;
            index = ( logHeader.NextEntry + 1 ) % logHeader.LogSize;
        }
    }

    entryAddress = (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( index * sizeof(logEntry) );

    if( entryAddress >=
        ( (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( numEntries * sizeof(logEntry) ) ) ) {

        dprintf(
            "dtext.%s: log @ %p has invalid data\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    //
    // Dump the log.
    //

    for( ;
         numEntries > 0 ;
         index += direction,
         numEntries--,
         entryAddress += ( direction * sizeof(logEntry) ) ) {

        if( CheckControlC() ) {
            break;
        }

        if( index >= logHeader.LogSize ) {
            index = 0;
            entryAddress = (ULONG_PTR)logHeader.LogBuffer;
        } else if( index < 0 ) {
            index = logHeader.LogSize - 1;
            entryAddress = (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( index * sizeof(logEntry) );
        }

        if( !ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ) ) {

            dprintf(
                "dtext.%s: cannot read memory @ %p\n",
                cmdName,
                (ULONG_PTR)entryAddress
                );

            return;

        }

        if( ( numSpecificContexts == 0 ) ||
            IsContextInList(
                logEntry.Context,
                specificContexts,
                numSpecificContexts
                ) ) {

            dprintf(
                "\nThread = %08p, Context = %08p, NewRefCount = %-10ld : %ld\n",
                logEntry.Thread,
                logEntry.Context,
                logEntry.NewRefCount,
                index
                );

            if (    logEntry.Context1 != REF_TRACE_EMPTY_CONTEXT
                 || logEntry.Context2 != REF_TRACE_EMPTY_CONTEXT
                 || logEntry.Context3 != REF_TRACE_EMPTY_CONTEXT
                 ) {

                //
                //  if the caller passed extended context values,
                //  write them to the log
                //
                //  NOTE we use REF_TRACE_EMPTY_CONTEXT in all extended
                //  contexts as the signal that a caller does not use
                //  extended context - avoids spew for callers who don't care.
                //

                dprintf(
                    "Context1 = %08p, Context2 = %08p, Context3 = %08p\n",
                    logEntry.Context1,
                    logEntry.Context2,
                    logEntry.Context3
                    );
            }

            for( i = 0 ; i < REF_TRACE_LOG_STACK_DEPTH ; i++ ) {

                if( logEntry.Stack[i] == NULL ) {
                    break;
                }

                GetSymbol(
                    logEntry.Stack[i],
                    symbol,
                    &offset
                    );

                if( symbol[0] == '\0' ) {
                    format = "    %08p\n";
                } else
                if( offset == 0 ) {
                    format = "    %08p : %s\n";
                } else {
                    format = "    %08p : %s+0x%p\n";
                }

                dprintf(
                    format,
                    logEntry.Stack[i],
                    symbol,
                    offset
                    );

            }

        }

    }

} // DumpReferenceLog


DECLARE_API( ref )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a reference trace log.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    DumpReferenceLog( (PSTR)args, FALSE );

} // DECLARE_API( ref )


DECLARE_API( rref )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a reference trace log backwards.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    DumpReferenceLog( (PSTR)args, TRUE );

} // DECLARE_API( rref )


DECLARE_API( resetref )

/*++

Routine Description:

    This function is called as an NTSD extension to reset a reference
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR refLogAddress = 0;
    TRACE_LOG logHeader;

    //
    // Skip leading blanks.
    //

    while( *args == ' ' ||
           *args == '\t' ) {
        args++;
    }

    if( *args == '\0' ) {
        PrintUsage( "resetref" );
        return;
    }

    refLogAddress = GetExpression( args );

    if( refLogAddress == 0 ) {

        dprintf(
            "dtext.resetref: cannot evaluate \"%s\"\n",
            args
            );

        return;

    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            (ULONG_PTR)refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.resetref: cannot read memory @ %p\n",
            refLogAddress
            );

        return;

    }

    dprintf(
        "dtext.resetref: log @ %p:\n"
        "    Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %08lx\n",
        (PVOID) refLogAddress,
        logHeader.Signature,
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.LogBuffer
        );

    if( logHeader.LogBuffer > ( (PUCHAR)refLogAddress + sizeof(logHeader) ) ) {
        dprintf(
            "    Extra Data @ %08p\n",
            (PVOID) (refLogAddress + sizeof(logHeader))
            );
    }

    if( logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X ) {

        dprintf(
            "dtext.resetref: log @ %p has invalid signature %08lx:\n",
            (PVOID) refLogAddress,
            logHeader.Signature
            );

        return;

    }

    if( logHeader.EntrySize != sizeof(REF_TRACE_LOG_ENTRY) ) {

        dprintf(
            "dtext.resetref: log @ %p is not a ref count log\n",
            (PVOID) refLogAddress
            );

        return;

    }

    //
    // Reset it.
    //

    logHeader.NextEntry = -1;

    if( !WriteMemory(
            refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.resetref: cannot write memory @ %p\n",
            (PVOID) refLogAddress
            );

        return;

    }

    dprintf(
        "dtext.resetref: log @ %p reset\n",
        (PVOID) refLogAddress
        );

} // DECLARE_API( resetref )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\template.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    template.cxx

Abstract:

    This is just a template for creating new NTSD extension commands.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"


// Don't forget to add 'template' to dtext.def

DECLARE_API( template )

/*++

Routine Description:

    This function is called as an NTSD extension to ...

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        //
        // ???
        //

    } else {

        //
        // ???
        //

    }

}   // DECLARE_API( template )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\dtext\vm.cxx ===
/*++

Copyright (c) 1999-1999  Microsoft Corporation

Module Name:

    vm.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    virtual memory statistics.

Author:

    Keith Moore (keithmo) 15-Jan-1999

Revision History:

--*/

#include "precomp.hxx"


//
// Private constants.
//

#define SMALL_REGION        (64 * 1024)
#define MEDIUM_REGION       (1 * 1024 * 1024)

#define IS_SMALL(c)         ((c) <= SMALL_REGION)
#define IS_MEDIUM(c)        (((c) > SMALL_REGION) && ((c) <= MEDIUM_REGION))
#define IS_LARGE(c)         ((c) > MEDIUM_REGION)

#define PRINTF_FORMAT       "%-7s %*s %*s %*s %*s\n"

#define CCH_ULONG_COMMAS    sizeof("4,294,967,296")


//
// Private types.
//

typedef struct _INDIVIDUAL_STAT
{
    SIZE_T MinimumSize;
    SIZE_T MaximumSize;
    SIZE_T TotalSize;
    SIZE_T BlockCount;

} INDIVIDUAL_STAT, *PINDIVIDUAL_STAT;

typedef struct _VM_STATS
{
    INDIVIDUAL_STAT Summary;
    INDIVIDUAL_STAT Small;
    INDIVIDUAL_STAT Medium;
    INDIVIDUAL_STAT Large;

} VM_STATS, *PVM_STATS;

typedef struct PROTECT_MASK
{
    DWORD Bit;
    PSTR Name;

} PROTECT_MASK, *PPROTECT_MASK;


//
// Private globals.
//

PROTECT_MASK ProtectMasks[] =
    {
        {
            PAGE_NOACCESS,
            "NA"
        },

        {
            PAGE_NOCACHE,
            "NC"
        },

        {
            PAGE_GUARD,
            "G"
        },

        {
            PAGE_READONLY,
            "Rd"
        },

        {
            PAGE_READWRITE,
            "RdWr"
        },

        {
            PAGE_WRITECOPY,
            "WrCp"
        },

        {
            PAGE_EXECUTE,
            "Ex"
        },

        {
            PAGE_EXECUTE_READ,
            "ExRd"
        },

        {
            PAGE_EXECUTE_READWRITE,
            "ExRdWr"
        },

        {
            PAGE_EXECUTE_WRITECOPY,
            "ExWrCp"
        }
    };

#define NUM_PROTECT_MASKS (sizeof(ProtectMasks) / sizeof(ProtectMasks[0]))


//
// Private functions.
//

PSTR
ULongLongToString(
    IN ULONGLONG Value,
    OUT PSTR Buffer
    )
{

    PSTR p1;
    PSTR p2;
    CHAR ch;
    INT digit;
    INT count;
    BOOL needComma;
    INT length;

    //
    // Handling zero specially makes everything else a bit easier.
    //

    if( Value == 0 ) {
        Buffer[0] = '0';
        Buffer[1] = '\0';
        return Buffer;
    }

    //
    // Pull the least signifigant digits off the value and store them
    // into the buffer. Note that this will store the digits in the
    // reverse order.
    //

    p1 = p2 = Buffer;
    count = 3;
    needComma = FALSE;

    while( Value != 0 ) {

        if( needComma ) {
            *p1++ = ',';
            needComma = FALSE;
        }

        digit = (INT)( Value % 10 );
        Value = Value / 10;

        *p1++ = '0' + digit;

        count--;
        if( count == 0 ) {
            count = 3;
            needComma = TRUE;
        }

    }

    length = DIFF(p1 - Buffer);

    //
    // Reverse the digits in the buffer.
    //

    *p1-- = '\0';

    while( p1 > p2 ) {

        ch = *p1;
        *p1 = *p2;
        *p2 = ch;

        p2++;
        p1--;

    }

    return Buffer;

}   // ULongLongToString

VOID
InitVmStats(
    OUT PVM_STATS Stats
    )
{
    ZeroMemory( Stats, sizeof(*Stats) );
    Stats->Summary.MinimumSize = (SIZE_T)-1L;
    Stats->Small.MinimumSize = (SIZE_T)-1L;
    Stats->Medium.MinimumSize = (SIZE_T)-1L;
    Stats->Large.MinimumSize = (SIZE_T)-1L;

}   // InitVmStats

VOID
UpdateIndividualStat(
    IN OUT PINDIVIDUAL_STAT Stat,
    IN SIZE_T BlockSize
    )
{
    Stat->BlockCount++;
    Stat->TotalSize += BlockSize;

    if( BlockSize > Stat->MaximumSize ) {
        Stat->MaximumSize = BlockSize;
    }

    if( BlockSize < Stat->MinimumSize ) {
        Stat->MinimumSize = BlockSize;
    }

}   // UpdateIndividualStat

VOID
UpdateVmStats(
    IN OUT PVM_STATS Stats,
    IN SIZE_T BlockSize
    )
{
    UpdateIndividualStat( &Stats->Summary, BlockSize );

    if( IS_SMALL(BlockSize) ) {
        UpdateIndividualStat( &Stats->Small, BlockSize );
    }

    if( IS_MEDIUM(BlockSize) ) {
        UpdateIndividualStat( &Stats->Medium, BlockSize );
    }

    if( IS_LARGE(BlockSize) ) {
        UpdateIndividualStat( &Stats->Large, BlockSize );
    }

}   // UpdateVmStats

VOID
PrintVmStatsHeader(
    VOID
    )
{
    dprintf(
        PRINTF_FORMAT,
        "TYPE",
        CCH_ULONG_COMMAS,
        "MINIMUM",
        CCH_ULONG_COMMAS,
        "MAXIMUM",
        CCH_ULONG_COMMAS,
        "AVERAGE",
        CCH_ULONG_COMMAS,
        "BLK COUNT"
        );

    dprintf(
        PRINTF_FORMAT,
        "~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~~~"
        );

}   // PrintVmStatsHeader

VOID
PrintIndividualStat(
    IN PSTR Name,
    IN PINDIVIDUAL_STAT Stat
    )
{
    SIZE_T average;
    SIZE_T minsize;
    CHAR minStr[CCH_ULONG_COMMAS];
    CHAR maxStr[CCH_ULONG_COMMAS];
    CHAR avgStr[CCH_ULONG_COMMAS];
    CHAR countStr[CCH_ULONG_COMMAS];

    if( Stat->BlockCount == 0 ) {
        average = 0;
        minsize = 0;
    } else {
        average = Stat->TotalSize / Stat->BlockCount;
        minsize = Stat->MinimumSize;
    }

    dprintf(
        PRINTF_FORMAT,
        Name,
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)minsize,
            minStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)Stat->MaximumSize,
            maxStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)average,
            avgStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)Stat->BlockCount,
            countStr
            )
        );

}   // PrintIndividualStat

VOID
PrintVmStats(
    IN PSTR Name,
    IN PVM_STATS Stats
    )
{
    dprintf( "%s:\n", Name );

    PrintIndividualStat( "Small", &Stats->Small );
    PrintIndividualStat( "Medium", &Stats->Medium );
    PrintIndividualStat( "Large", &Stats->Large );
    PrintIndividualStat( "Summary", &Stats->Summary );

    dprintf( "\n" );

}   // PrintVmStats

PSTR
VmProtectToString(
    IN DWORD Protect,
    OUT PSTR Buffer
    )
{
    INT i;
    PPROTECT_MASK mask;

    Buffer[0] = '\0';

    for( i = 0, mask = &ProtectMasks[0] ;
        (i < NUM_PROTECT_MASKS) && (Protect != 0) ;
        i++, mask++ ) {
        if( mask->Bit & Protect ) {
            Protect &= ~mask->Bit;
            if( Buffer[0] != '\0' ) {
                strcat( Buffer, "|" );
            }
            strcat( Buffer, mask->Name );
        }
    }

    if( Protect != 0 ) {
        if( Buffer[0] != '\0' ) {
            strcat( Buffer, "|" );
        }
        sprintf( Buffer + strlen(Buffer), "%08lx", Protect );
    }

    return Buffer;

}   // VmProtectToString

PSTR
VmStateToString(
    IN DWORD State,
    OUT PSTR Buffer
    )
{
    PSTR result;
    CHAR invalidStr[sizeof("12345678")];

    switch( State )
    {
    case MEM_COMMIT:
        result = "Commit";
        break;

    case MEM_RESERVE:
        result = "Reserve";
        break;

    case MEM_FREE:
        result = "Free";
        break;

    default:
        sprintf( invalidStr, "%08lx", State );
        result = invalidStr;
        break;
    }

    strcpy( Buffer, result );
    return Buffer;

}   // VmStateToString

PSTR
VmTypeToString(
    IN DWORD Type,
    OUT PSTR Buffer
    )
{
    PSTR result;
    CHAR invalidStr[sizeof("12345678")];

    switch( Type )
    {
    case MEM_PRIVATE:
        result = "Private";
        break;

    case MEM_MAPPED:
        result = "Mapped";
        break;

    case MEM_IMAGE:
        result = "Image";
        break;

    case 0:
        result = "";
        break;

    default:
        sprintf( invalidStr, "%08lx", Type );
        result = invalidStr;
        break;
    }

    strcpy( Buffer, result );
    return Buffer;

}   // VmTypeToString


/************************************************************
 * Dump Virtual Memory Info
 ************************************************************/


DECLARE_API( vmstat )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    virtual memory statistics.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    ULONG_PTR address;
    MEMORY_BASIC_INFORMATION memInfo;
    VM_STATS freeStats;
    VM_STATS reserveStats;
    VM_STATS commitStats;
    VM_STATS privateStats;
    VM_STATS mappedStats;
    VM_STATS imageStats;

    //
    // Setup.
    //

    InitVmStats( &freeStats );
    InitVmStats( &reserveStats );
    InitVmStats( &commitStats );
    InitVmStats( &privateStats );
    InitVmStats( &mappedStats );
    InitVmStats( &imageStats );

    address = 0;

    //
    // Scan the virtual address space.
    //

    for( ; ; ) {
        status = NtQueryVirtualMemory(
                     hCurrentProcess,
                     (PVOID)address,
                     MemoryBasicInformation,
                     &memInfo,
                     sizeof(memInfo),
                     NULL
                     );

        if( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Interpret the memory state.
        //

        switch( memInfo.State ) {
        case MEM_FREE:
            UpdateVmStats( &freeStats, memInfo.RegionSize );
            break;

        case MEM_RESERVE:
            UpdateVmStats( &reserveStats, memInfo.RegionSize );
            break;

        case MEM_COMMIT:
            UpdateVmStats( &commitStats, memInfo.RegionSize );
            break;
        }

        //
        // Interpret the memory type.
        //

        switch( memInfo.Type ) {
        case MEM_PRIVATE:
            UpdateVmStats( &privateStats, memInfo.RegionSize );
            break;

        case MEM_MAPPED:
            UpdateVmStats( &mappedStats, memInfo.RegionSize );
            break;

        case MEM_IMAGE:
            UpdateVmStats( &imageStats, memInfo.RegionSize );
            break;
        }

        //
        // Advance to the next block.
        //

        address += memInfo.RegionSize;
    }

    //
    // Dump it.
    //

    PrintVmStatsHeader();
    PrintVmStats( "Free", &freeStats );
    PrintVmStats( "Reserve", &reserveStats );
    PrintVmStats( "Commit", &commitStats );
    PrintVmStats( "Private", &privateStats );
    PrintVmStats( "Mapped", &mappedStats );
    PrintVmStats( "Image", &imageStats );

}   // DECLARE_API( vmstat )


DECLARE_API( vmmap )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the debugee's virtual memory address space.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    ULONG_PTR address;
    MEMORY_BASIC_INFORMATION memInfo;
    CHAR protectStr[32];
    CHAR aprotectStr[32];
    CHAR stateStr[16];
    CHAR typeStr[16];

    //
    // Setup.
    //

    address = 0;

    dprintf(
        "%-*s %-*s %-*s  %-13s %-13s %-8s %-8s\n",
        sizeof(PVOID) * 2,
        "Start",
        sizeof(PVOID) * 2,
        "Stop",
        sizeof(PVOID) * 2,
        "Length",
        "AllocProtect",
        "Protect",
        "State",
        "Type"
        );

    //
    // Scan the virtual address space.
    //

    for( ; ; ) {
        status = NtQueryVirtualMemory(
                     hCurrentProcess,
                     (PVOID)address,
                     MemoryBasicInformation,
                     &memInfo,
                     sizeof(memInfo),
                     NULL
                     );

        if( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Dump the current entry.
        //

        dprintf(
            "%p-%p %p  %-13s %-13s %-8s %-8s\n",
            memInfo.BaseAddress,
            (ULONG_PTR)memInfo.BaseAddress + memInfo.RegionSize - 1,
            memInfo.RegionSize,
            VmProtectToString( memInfo.AllocationProtect, aprotectStr ),
            VmProtectToString( memInfo.Protect, protectStr ),
            VmStateToString( memInfo.State, stateStr ),
            VmTypeToString( memInfo.Type, typeStr )
            );

        //
        // Advance to the next block.
        //

        address += memInfo.RegionSize;
    }

}   // DECLARE_API( vmmap )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991-1996           **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        MuraliK     3-July-1996 Rewrote the buffer class
*/

#include "precomp.hxx"

# include <buffer.hxx>
# include "dbgutil.h"



/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets m_cb, m_pb and m_fIsDynAlloced

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

********************************************************************/

BOOL
BUFFER::GetNewStorage( UINT cbRequested )
{
    if ( cbRequested <= m_cb) {

        return TRUE;
    }

    DBG_ASSERT( !IsDynAlloced());  // otherwise I should free up the block :(
    m_pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !m_pb ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    } else {
        m_pb[0] = '\0'; // just store null
        m_cb = cbRequested;
        m_fIsDynAlloced = 1;
    }

    return (m_pb != NULL);
} // BUFFER::GetNewStorage()



/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd. m_pb, m_cb, m_fIsDynAlloced changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

********************************************************************/

BOOL
BUFFER::ReallocStorage( UINT cbNewRequested )
{
    if ( cbNewRequested <= m_cb) {

        return (TRUE);
    }

    HANDLE hNewMem = ((IsDynAlloced()) ?
                      (::LocalReAlloc( m_pb, cbNewRequested, LMEM_MOVEABLE )):
                      (::LocalAlloc( NONZEROLPTR, cbNewRequested))
                      );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    if ( !IsDynAlloced()) {
        // First time this block is allocated. Copy over old contents.
        CopyMemory( (BYTE* ) hNewMem, m_pb, m_cb);
        m_fIsDynAlloced = 1;
    }

    m_pb = (BYTE *) hNewMem;
    m_cb = cbNewRequested;

    DBG_ASSERT( m_pb != NULL );

    return TRUE;
} // BUFFER::ReallocStorage()



/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

********************************************************************/

VOID BUFFER::VerifyState() const
{
    //
    //  1. If Dynamically Allocated ==>
    //       m_pb points to something other than m_rgb &
    //       m_cb > INLINED_BUFFER_LEN
    //  2. If not Dynamicall Allocated ==>
    //       (a)  it can be using user-supplied buffer & any sized
    //       (b)  it can be using inlined buffer & m_cb == INLINED_BUFFER_LEN
    //

    DBG_ASSERT(( IsDynAlloced() && (m_pb != m_rgb) &&
                 (m_cb > INLINED_BUFFER_LEN)) ||
               ( !IsDynAlloced() &&
                 ( m_pb != m_rgb || m_cb == INLINED_BUFFER_LEN)
                 )
               );

} // BUFFER::VerifyState()



/*******************************************************************

    NAME:       BUFFER::FreeMemory

    SYNOPSIS:   Frees the heap memory associated with this buffer object

********************************************************************/

VOID
BUFFER::FreeMemory(
    VOID
    )
{
    if ( IsDynAlloced()) {
        ::LocalFree( (HANDLE)m_pb );
        m_pb = m_rgb;
        m_cb = INLINED_BUFFER_LEN;
        m_fIsDynAlloced = 0;
    }

    m_rgb[0] = '\0';  // reset the contents
}



BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DBG_ASSERT( pBCI );
    DBG_ASSERT( pBCI->_ListEntry.Flink == NULL );

    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}



DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        DBG_ASSERT( pBCI->_ListEntry.Flink != NULL );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}



BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}



DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}

/***************************** End Of File ******************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\adminmonitor.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    adminmonitor.cxx

        This code is used to monitor the IISAdmin service and let
        dependent services know when it crashes and how to handle
        that crash.

        When the dependent service launches a thread with the StartIISAdminMonitor
        on it, it will start monitoring the iis admin process.  If the process
        crashes it will decide on the action to take and will notify the
        service through call back functions to take the particular action.

        The service must also call the StopIISAdminMonitor when it is exiting
        so the thread that the StartIISAdminMonitor can be released.
*/


#include "precomp.hxx"

#pragma warning(push, 4)
#include "adminmonitor.h"

#define MS_WAIT_FOR_IISRESET_TO_SHUT_SERVICE_DOWN 60000  // 1 minute
#define MS_MAX_WAIT_FOR_INETINFO_TO_RESTART 120000 // 2 minutes
#define MS_INCREMENT_WAIT_TO_CHECK_FOR_INETINFO_TO_RESTART 5000 // 5 seconds



HANDLE g_IISAdminMonitorShutdownEvent;
HANDLE g_hIISAdminMonitorThread;
DWORD  g_dwIISAdminThreadId;

enum IISRESET_ACTION
{
    NoReset = 0,
    FullReset,
    InetinfoResetOnly
};

enum MONITOR_ACTION_TO_TAKE
{
    MonitorActionExit = 0,
    MonitorActionRehook,
    MonitorActionShutdown
};

struct MONITOR_THREAD_START_STRUCT
{
    PFN_IISAdminNotify pfnNotifyIISAdminCrash;
    HANDLE             hStartupFinished;
    HRESULT            hrForStartup;
};

DWORD WINAPI
StartMonitoring(
    LPVOID pMonitorStartupStructAsVoid
    );

VOID
MonitorProcess(
    IN PFN_IISAdminNotify pCallbackFcn,
    IN OUT BOOL* pfRehook,
    IN MONITOR_THREAD_START_STRUCT* pMonitorStruct
    );

HRESULT
GetProcessHandleForInetinfo(
    OUT HANDLE*    phInetinfoProcess
    );


/***************************************************************************++

Routine Description:

    This routine handles all the monitoring of the IISAdmin process and
    the decision making logic to decide what to do when the process has
    problems.  It will used the callback functions provided to let the
    service know what it needs to do in case of a IISAdmin crash.

Arguments:

    Routine to call when we want to tell the service to do something or to
    know about something because inetinfo had a problem.


    NOTE:  This routine should not lead to shutting down the monitor.
           Since it is launched on the monitor thread and the shutdown
           routine for the monitor will wait for the monitor thread to
           complete, it will cause a deadlock.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
StartIISAdminMonitor(
    PFN_IISAdminNotify pfnNotifyIISAdminCrash
    )
{
    HRESULT hr = S_OK;
    MONITOR_THREAD_START_STRUCT MonitorStruct;

    // Initialize the startup monitor structure.
    MonitorStruct.hStartupFinished = NULL;
    MonitorStruct.pfnNotifyIISAdminCrash = pfnNotifyIISAdminCrash;
    MonitorStruct.hrForStartup = S_OK;

    if ( pfnNotifyIISAdminCrash == NULL )
    {
        return E_INVALIDARG;
    }

    //
    // Create the shutdown event so we can signal when we need
    // this thread to exit.  If we have all ready created this event
    // it means we are trying to monitor multiple times in one process
    // this is not allowed.
    //

    DBG_ASSERT ( g_IISAdminMonitorShutdownEvent == NULL );
    if ( g_IISAdminMonitorShutdownEvent != NULL )
    {
        hr = E_UNEXPECTED;

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Start monitoring called when we were all ready "
                                "monitoring, setting hr to equal %08x\n",
                                hr));

        goto exit;
    }

    // Local Event that is just used to tell this thread that the startup
    // thread has gotten far enough to report that the admin monitor started
    // successfully.
    MonitorStruct.hStartupFinished = CreateEvent(    
                                       NULL,  // default security descriptor
                                       TRUE,  // manual-reset (must ResetEvent)
                                       FALSE, // initial state = not signalled
                                       NULL );// not a named event
    if ( MonitorStruct.hStartupFinished == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Can not create startup complete event for monitoring "
                                "the inetinfo process, hr = %08x\n",
                                hr));
        goto exit;
    }

    //
    // need to create the shutdown event.
    // since it is not named, don't worry about
    // openning an allready existing event.
    //
    // note that it is not manually reset, because if it has been
    // called, even if we weren't listening at that momement we still
    // want to know it was triggered the next time we start listening.
    //
    g_IISAdminMonitorShutdownEvent = CreateEvent(
                                       NULL,  // default security descriptor
                                       TRUE,  // manual-reset (must ResetEvent)
                                       FALSE, // initial state = not signalled
                                       NULL );// not a named event

    if ( g_IISAdminMonitorShutdownEvent == NULL )
    {
        // there has been a problem creating the event
        // need to return the error

        hr = HRESULT_FROM_WIN32(GetLastError());

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Can not create shutdown event for monitoring "
                                "the inetinfo process, hr = %08x\n",
                                hr));

        goto exit;
    }

    //
    // Now that we have the shutdown event we can
    // go ahead and spin up the process.
    //

    g_hIISAdminMonitorThread = CreateThread( NULL,  // default security descriptor
                                             // Big initial size to prevent stack overflows
                                             IIS_DEFAULT_INITIAL_STACK_SIZE,
                                             StartMonitoring, // function to call
                                             (LPVOID) &MonitorStruct,  // callback function
                                             0,     // thread can run immediately
                                             &g_dwIISAdminThreadId );


    if ( g_hIISAdminMonitorThread == NULL )
    {
        hr = HRESULT_FROM_WIN32 ( GetLastError() );
        goto exit;
    }

    // Wait for the other thread to get far enough.  We don't
    // worry about the return value here, because there is nothing
    // we can really do about it.
    WaitForSingleObject ( MonitorStruct.hStartupFinished, INFINITE );

exit:

    // Pickup the failed hr from the 
    // other thread if we got
    // that far.
    if ( SUCCEEDED( hr ) && FAILED ( MonitorStruct.hrForStartup ) )
    {
        hr = MonitorStruct.hrForStartup;    
    }

    if ( FAILED ( hr ) )
    {
        if ( g_IISAdminMonitorShutdownEvent )
        {
            CloseHandle ( g_IISAdminMonitorShutdownEvent );
            g_IISAdminMonitorShutdownEvent = NULL;
        }
    }

    if ( MonitorStruct.hStartupFinished != NULL )
    {
        CloseHandle( MonitorStruct.hStartupFinished );
        MonitorStruct.hStartupFinished = NULL;
    }

    return hr;
}

/***************************************************************************++

Routine Description:

  Routine shutsdown the monitoring thread, so that the service
  can exit.  It will block waiting for the thread to complete.

  If the shutdown event does not exist, it will not do anything.

Arguments:

   None

Return Value:

    VOID.

--***************************************************************************/
VOID
StopIISAdminMonitor(
    )
{
    //
    // issue, we need to use a critical section or something to prevent
    // this handle from being changed while we are in this code.
    //
    if ( g_IISAdminMonitorShutdownEvent )
    {
        SetEvent ( g_IISAdminMonitorShutdownEvent );
    }

    if ( g_hIISAdminMonitorThread )
    {
        //
        // make sure we are not on the thread that we are trying to stop
        // if we are we will deadlock.
        //
        DBG_ASSERT ( GetCurrentThreadId() != g_dwIISAdminThreadId );

        DWORD dwWaitResult = WaitForSingleObject ( g_hIISAdminMonitorThread, INFINITE );

        if ( dwWaitResult != WAIT_OBJECT_0 )
        {
            DBG_ASSERT ( dwWaitResult == WAIT_OBJECT_0 );
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to wait for iis admin thread to shutdown. hr = %08x\n",
                       HRESULT_FROM_WIN32(GetLastError()) ));
        }

        IF_DEBUG ( INET_MONITOR )
        {
            DBGPRINTF((DBG_CONTEXT, "Inetinfo monitor thread has completed\n" ));
        }

        CloseHandle( g_hIISAdminMonitorThread );
        g_hIISAdminMonitorThread = NULL;
    }

    // now that the thread has exited we no longer need the shutdown event
    // so go ahead and close it down.
    if ( g_IISAdminMonitorShutdownEvent )
    {
        CloseHandle ( g_IISAdminMonitorShutdownEvent );
        g_IISAdminMonitorShutdownEvent = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Routine figures out if iisreset is even enabled on the machine.

Arguments:

    None.

Return Value:

    BOOL  - True, IISReset is enabled
            False, IISReset is not enabled.

Note:  Routine has been copied from the iisreset code.
If the value is set to 1, or non-existant then IISReset is enabled.
If the value is set to anything other than 1 then IISReset is disabled.
I am keeping it like this for backward compatibility, even though it seems
more correct to have 0 be disabled and everything else be enabled.

--***************************************************************************/
BOOL
IsIISResetEnabled(
    )
{
    BOOL    fSt = FALSE;
    HKEY    hKey;
    DWORD   dwValue;
    DWORD   dwType;
    DWORD   dwSize;


    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       TEXT("SOFTWARE\\Microsoft\\INetStp"),
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey,
                              TEXT("EnableRestart"),
                              0,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( dwType == REG_DWORD )
            {
                fSt = ( dwValue == 1 );
            }
            else
            {
                fSt = TRUE;
            }
        }
        else
        {
            fSt = TRUE;
        }

        RegCloseKey( hKey );
    }

    return fSt;
}

/***************************************************************************++

Routine Description:

    Routine determines the timer values needed to recover from a crash.

Arguments:

    DWORD* pmsWaitForServiceShutdown,
    DWORD* pmsWaitForInetinfoToRestart,
    DWORD* pmsCheckIntervalForInetinfoToRestart

Return Value:

    None.


--***************************************************************************/
VOID
GetRegistryControlsForInetinfoCrash(
    DWORD* pmsWaitForServiceShutdown,
    DWORD* pmsWaitForInetinfoToRestart,
    DWORD* pmsCheckIntervalForInetinfoToRestart
    )
{
    HKEY    hKey;
    DWORD   dwValue;
    DWORD   dwType;
    DWORD   dwSize;

    DBG_ASSERT ( pmsWaitForServiceShutdown != NULL );
    DBG_ASSERT ( pmsWaitForInetinfoToRestart != NULL );
    DBG_ASSERT ( pmsCheckIntervalForInetinfoToRestart != NULL );

    if ( pmsWaitForServiceShutdown == NULL ||
         pmsWaitForInetinfoToRestart == NULL ||
         pmsCheckIntervalForInetinfoToRestart == NULL )
    {
        return;
    }


    // set the values to the defaults.
    *pmsWaitForServiceShutdown = MS_WAIT_FOR_IISRESET_TO_SHUT_SERVICE_DOWN;
    *pmsWaitForInetinfoToRestart = MS_MAX_WAIT_FOR_INETINFO_TO_RESTART;
    *pmsCheckIntervalForInetinfoToRestart = MS_INCREMENT_WAIT_TO_CHECK_FOR_INETINFO_TO_RESTART;

    // now check if there are registry overrides in place.
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGISTRY_KEY_IISADMIN_PARAMETERS_W,
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey,
                              REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_SHUTDOWN_AFTER_INETINFO_CRASH_W,
                              0,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( ( dwType == REG_DWORD ) && ( dwValue != 0 ))
            {
                *pmsWaitForServiceShutdown = dwValue;
            }
        }

        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey,
                              REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_RESTART_AFTER_INETINFO_CRASH_W ,
                              0,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( ( dwType == REG_DWORD ) && ( dwValue != 0 ))
            {
                *pmsWaitForInetinfoToRestart = dwValue;
            }
        }

        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey,
                              REGISTRY_VALUE_IISADMIN_MS_CHECK_INTERVAL_FOR_INETINFO_TO_RESTART_W,
                              0,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( ( dwType == REG_DWORD ) && ( dwValue != 0 ))
            {
                *pmsCheckIntervalForInetinfoToRestart = dwValue;
            }
        }

        RegCloseKey( hKey );
    }
}


/***************************************************************************++

Routine Description:

    Routine looks through the SCM information and determines the expected
    behavior of IISReset.

Arguments:

    IN  SC_HANDLE hIISAdminService
    OUT IISRESET_ACTION* pExpectedResetAction


Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
DetermineIISResetState(
    IN  SC_HANDLE hIISAdminService,
    OUT IISRESET_ACTION* pExpectedResetAction
    )
{
    HRESULT hr = S_OK;


    // In normal configuration, QueryServiceConfig2 is returning that we need
    //  atleast 136 bytes to retreive this data.  I suspect that the extra bytes
    // ( SERVICE_FAILURE_ACTIONS is only 20 bytes ) are for the extra memory
    // that the actions point to at the end.  Note that the below code will
    // adjust if this guess is not correct.

    BUFFER FailureDataBuffer(150);
    SERVICE_FAILURE_ACTIONS* pFailureActions = NULL;
    DWORD dwBytesNeeded = 0;
    BOOL fRunFileConfigured = FALSE;

    IISRESET_ACTION ResetAction = NoReset;

    DBG_ASSERT ( hIISAdminService != NULL );
    DBG_ASSERT ( pExpectedResetAction != NULL );

    if ( hIISAdminService == NULL ||
         pExpectedResetAction == NULL )
    {
        return E_INVALIDARG;
    }

    // Check if IISReset is enabled in the registry, if it is not then
    // don't bother with the scm.
    // Issue which is beter to check first?  Can do it either way.
    //
    if ( IsIISResetEnabled() == FALSE )
    {
        ResetAction = NoReset;
        goto exit;
    }

    // Need to find out if IISReset is set on the IISAdmin Service
    // and need to also figure out if it has a command line argument for
    // partial reset.

    if ( ! QueryServiceConfig2( hIISAdminService,
                                SERVICE_CONFIG_FAILURE_ACTIONS,
                                (LPBYTE) FailureDataBuffer.QueryPtr(),
                                FailureDataBuffer.QuerySize(),
                                &dwBytesNeeded ) )
    {
        DWORD dwErr = GetLastError();

        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            // try again with the larger size before failing

            if ( !FailureDataBuffer.Resize( dwBytesNeeded ) )
            {
                hr = HRESULT_FROM_WIN32 ( GetLastError() );

                // error case, always spew
                DBGPRINTF((DBG_CONTEXT, "Failed to resize the buffer to the appropriate size, "
                                        "hr = %08x attempted size = %d\n",
                                        hr,
                                        dwBytesNeeded));

                goto exit;
            }

            if ( ! QueryServiceConfig2( hIISAdminService,
                                        SERVICE_CONFIG_FAILURE_ACTIONS,
                                        (LPBYTE) FailureDataBuffer.QueryPtr(),
                                        FailureDataBuffer.QuerySize(),
                                        &dwBytesNeeded ) )

            {
                hr = HRESULT_FROM_WIN32 ( GetLastError () );

                // error case, always spew
                DBGPRINTF((DBG_CONTEXT, "( 1 ) Failed to query the IISAdmin service config, "
                                        "hr = %08x bytes needed = %d\n",
                                        hr,
                                        dwBytesNeeded));

                goto exit;
            }
        }
        else  // not a resizing issue.
        {
            hr = HRESULT_FROM_WIN32( dwErr );

            // error case, always spew
            DBGPRINTF((DBG_CONTEXT, "( 2 ) Failed to query the IISAdmin service config, "
                                    "hr = %08x bytes needed = %d\n",
                                    hr,
                                    dwBytesNeeded));
            goto exit;
        }

    }

    pFailureActions = reinterpret_cast<SERVICE_FAILURE_ACTIONS*>( FailureDataBuffer.QueryPtr() );

    // check that atleast one of the actions are set to run a file,
    // if they are then check the command line argument.
    for ( DWORD i = 0; i < pFailureActions->cActions; i++ )
    {
        if ( pFailureActions->lpsaActions[i].Type == SC_ACTION_RUN_COMMAND )
        {
            fRunFileConfigured = TRUE;
            break;
        }
    }

    // If we didn't find any actions configured to run then we
    // need to search no farther.  Reset is not setup.
    if ( !fRunFileConfigured )
    {
        ResetAction = NoReset;
        goto exit;
    }

    // Now that we know that we are planning on running an action
    // we need to check the command line argument
    if ( pFailureActions->lpCommand == NULL )
    {
        // This is the default value, but just in case it changes
        // we are setting it here too.
        ResetAction = NoReset;
        goto exit;
    }

    IF_DEBUG ( INET_MONITOR )
    {
        DBGPRINTF((DBG_CONTEXT, "IISAdmin pFailureActions = %S \n ",
                                pFailureActions->lpCommand));
    }

    // first convert the FailureActions command line to lower case.
    // this does an inplace conversion.  the return value is the
    // same as the string passed in so no need to check it.
    _wcslwr( pFailureActions->lpCommand );

    // look to see if "iisreset" is in the string.
    if ( wcsstr( pFailureActions->lpCommand, L"iisreset" ) == NULL )
    {
        // we know that we don't have iisreset set on iisadmin
        ResetAction = NoReset;
        goto exit;
    }

    // look to see if the "/start" flag is in the string
    if ( wcsstr( pFailureActions->lpCommand, L"/start" ) == NULL )
    {
        // at this point we know that iisreset is on, but the endure
        // flag is not set.  so we want to just wait to be recycled.

        ResetAction = FullReset;
        goto exit;
    }
    else
    {
        // if we did find the flag then we can assume that we are
        // going to attempt to stay up during the recycle.
        ResetAction = InetinfoResetOnly;
        goto exit;
    }


exit:

    // If we aren't going to fail the routine
    // we should set the out parameter.
    if ( SUCCEEDED ( hr ) )
    {
        *pExpectedResetAction = ResetAction;
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    This routine handles all the monitoring of the IISAdmin process and
    the decision making logic to decide what to do when the process has
    problems.  It will used the callback functions provided to let the
    service know what it needs to do in case of a IISAdmin crash.

Arguments:

    LPVOID pMonitorStartupStructAsVoid -- pointer to the struct containing needed
                                          info for startup.

Return Value:

    HRESULT.

--***************************************************************************/
DWORD WINAPI
StartMonitoring(
    LPVOID pMonitorStartupStructAsVoid
    )
{
    DBG_ASSERT ( pMonitorStartupStructAsVoid != NULL );

    MONITOR_THREAD_START_STRUCT* pMonitorStruct =  (MONITOR_THREAD_START_STRUCT*) pMonitorStartupStructAsVoid;
    PFN_IISAdminNotify pfnNotifyIISAdminCrash = pMonitorStruct->pfnNotifyIISAdminCrash;

    BOOL fRehook = FALSE;
    do
    {
        MonitorProcess ( pfnNotifyIISAdminCrash, 
                         &fRehook,
                         pMonitorStruct);

        // Only pass it the first time through
        pMonitorStruct = NULL;

    } while ( fRehook );

    return S_OK;
}

/***************************************************************************++

Routine Description:

  Routine figures out the process that contains iisadmin and returns
  a handle to it.

Arguments:

    OUT HANDLE* phInetinfoProcess


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
GetProcessHandleForInetinfo(
    OUT HANDLE*    phInetinfoProcess
    )
{
    HRESULT hr = S_OK;
    DWORD NumTries = 0;
    BOOL fContinue = TRUE;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS_PROCESS  statusProcess;
    DWORD dwBytesNeeded = 0;
    HANDLE hInetinfoProcess = NULL;

    DBG_ASSERT ( phInetinfoProcess != NULL );
    *phInetinfoProcess = NULL;


    hSCM = OpenSCManager( NULL,  // local machine
                                    NULL,  // services active database
                                    GENERIC_READ );
    if ( hSCM == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Could not open the scm manager, "
                                "hr = %08x\n",
                                 hr));
        goto exit;
    }

    hService = OpenService( hSCM,
                            L"IISADMIN",
                            GENERIC_READ );
    if ( hService == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Could not open the iisadmin service,"
                                "hr = %08x\n",
                                 hr));
        goto exit;
    }

    //
    // Get the current service status for the IISAdmin Service.
    //
    if ( !QueryServiceStatusEx( hService,
                                SC_STATUS_PROCESS_INFO,
                                (LPBYTE) &statusProcess,
                                sizeof ( statusProcess ),
                                &dwBytesNeeded ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF((DBG_CONTEXT, "Failed querying the iisadmin service for it's process info, "
                                "hr = %08x, BytesNeeded = %d\n",
                                hr,
                                dwBytesNeeded));
        goto exit;
    }

    //
    // do this in a loop incase the process id is change on us.
    //
    do
    {
        //
        // grab the process id that we are holding so
        // that we can make sure the process id doesn't change
        // while we are openning the process.
        //

        DWORD dwProcessId = statusProcess.dwProcessId;
        //
        // Use the process id to grab the inetinfo process.
        //
        hInetinfoProcess = OpenProcess( SYNCHRONIZE,
                                        FALSE,
                                        dwProcessId );

        if ( hInetinfoProcess == NULL )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT, "Could not open the inetinfo process, "
                                    "hr = %08x\n",
                                    hr));
            goto exit;
        }

        // Need to check that we got the correct process ( could of changed,
        // since we last got the process id )

        //
        // Get the current service status for the IISAdmin Service.
        //
        if ( !QueryServiceStatusEx( hService,
                                    SC_STATUS_PROCESS_INFO,
                                    (LPBYTE) &statusProcess,
                                    sizeof ( statusProcess ),
                                    &dwBytesNeeded ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF((DBG_CONTEXT, "Failed querying the iisadmin service for it's process info, "
                                    "hr = %08x, BytesNeeded = %d\n",
                                    hr,
                                    dwBytesNeeded));
            goto exit;
        }

        if ( dwProcessId == statusProcess.dwProcessId )
        {
            // we have the correct handle.
            fContinue = FALSE;
        }
        else
        {
            // 5 is a completely random number, but if we have not gotten it right by the
            // 5th time, something is more than a little wrong.  Fail the hookup.
            if ( NumTries > 5 )
            {
                // error case, always spew
                DBGPRINTF((DBG_CONTEXT, "Process id for the process we got and the current "
                                        "inetinfo process don't match, failing the hookup \n "));

                hr = E_UNEXPECTED;

                fContinue = FALSE;
            }
            else
            {
                // error case, always spew ( we should never really have to try more than once )
                DBGPRINTF((DBG_CONTEXT, "Process id for the process we got and the current "
                                        "inetinfo process don't match, trying again \n "));

                // need to release the process handle.
                DBG_ASSERT ( hInetinfoProcess != NULL );
                CloseHandle ( hInetinfoProcess );
                hInetinfoProcess = NULL;

                NumTries++;
            }
        }


    } while ( fContinue );

exit:

    if ( SUCCEEDED ( hr ) )
    {
        *phInetinfoProcess = hInetinfoProcess;
    }
    else
    {
        if ( hInetinfoProcess != NULL )
        {
            CloseHandle ( hInetinfoProcess );
            hInetinfoProcess = NULL;
        }
    }

    if ( hService )
    {
        CloseServiceHandle(hService);
    }

    if ( hSCM )
    {
        CloseServiceHandle(hSCM);
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Routine will determine whether or not we should shutdown the service
    for this crash.

Arguments:

    None

Return Value:

    MONITOR_ACTION_TO_TAKE

--***************************************************************************/
MONITOR_ACTION_TO_TAKE
AdminMonitorRequiresShutdown(
    )
{
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;

    MONITOR_ACTION_TO_TAKE ActionToTake = MonitorActionShutdown;
    DWORD msWaitForServiceShutdown = 0;
    DWORD msWaitForInetinfoToRestart = 0;
    DWORD msCheckIntervalForInetinfoToRestart = 0;

    IISRESET_ACTION ExpectedResetAction = NoReset;

    //
    // we need to get the configuration information for the
    // handling the crash correctly.  this is read everytime
    // from the registry, but if inetinfo is crashing, performance
    // is not the most important consideration.
    //
    // Note that this routine returns VOID.
    //
    GetRegistryControlsForInetinfoCrash( &msWaitForServiceShutdown,
                                         &msWaitForInetinfoToRestart,
                                         &msCheckIntervalForInetinfoToRestart );

    hSCM = OpenSCManager( NULL,  // local machine
                            NULL,  // services active database
                            GENERIC_READ );
    if ( hSCM == NULL )
    {
        // Without the SCM manager we won't be able to detect
        // a thing, so tell the service to shutdown.

        ActionToTake = MonitorActionShutdown;
        goto exit;
    }

    hService = OpenService( hSCM,
                            L"IISADMIN",
                            GENERIC_READ );

    if ( hService == NULL )
    {
        // Without the iisadmin service we won't be able to
        // detect a thing either, so tell the service to shutdown.
        ActionToTake = MonitorActionShutdown;
        goto exit;
    }
    
    //
    // Now go ahead and figure out what specific action
    // we need to take.
    //
    DetermineIISResetState(hService, &ExpectedResetAction);

    IF_DEBUG ( INET_MONITOR )
    {
        DBGPRINTF((DBG_CONTEXT, "Reset action is %d \n",
                                (DWORD) ExpectedResetAction));
    }

    //
    // If we expect a full reset and we get a shutdown event
    // in the amount of time we are willing to wait, then we
    // just go ahead and do nothing and exit.
    //
    if ( ExpectedResetAction == FullReset )
    {
        if ( WaitForSingleObject( g_IISAdminMonitorShutdownEvent,
                                  msWaitForServiceShutdown )
             == WAIT_OBJECT_0 )
        {
            ActionToTake = MonitorActionExit;
            goto exit;
        }
    }

    if ( ExpectedResetAction == InetinfoResetOnly )
    {

        SERVICE_STATUS_PROCESS  statusProcess;
        DWORD dwBytesNeeded;

        //
        // Need to find the inetinfo process id if
        // we are going to detect when the service restarts.
        //
        for ( DWORD i = 0;
              i < msWaitForInetinfoToRestart;
              i = i + msCheckIntervalForInetinfoToRestart )
        {
            // rest a while
            Sleep( msCheckIntervalForInetinfoToRestart );

            // If we can get the service info then check 
            // it, if not, maybe we will have better luck
            // on the next loop round.
            if ( QueryServiceStatusEx( hService,
                                        SC_STATUS_PROCESS_INFO,
                                        (LPBYTE) &statusProcess,
                                        sizeof ( statusProcess ),
                                        &dwBytesNeeded ) )
            {
                // see if the service is back up and running
                if ( statusProcess.dwCurrentState == SERVICE_RUNNING )
                {
                    ActionToTake = MonitorActionRehook;
                    goto exit;
                }
            }
        }

    }  // end of looking for iisadmin to restart.

    DBG_ASSERT ( ActionToTake == MonitorActionShutdown );

exit:

    if ( hService )
    {
        CloseServiceHandle ( hService );
    }

    if ( hSCM )
    {
        CloseServiceHandle ( hSCM );
    }
    
    return ActionToTake;
}


/***************************************************************************++

Routine Description:

    Routine is used to monitor the inetinfo process and initiate appropriate
    actions when there is a problem.  All code in this routine can be repeatedly
    called, for instance if we think we have recovered from a problem this function
    will automatically be called to start us monitoring again.

Arguments:

    IN PFN_IISAdminNotify pCallbackFcn,
    IN OUT BOOL* pfRehook
    IN MONITOR_THREAD_START_STRUCT* pMonitorStruct = If this is not null then
                                         it is the first time through and we need
                                         to set the hrForStartup and Signal the event
                                         when we have completed the startup code


Return Value:

    VOID

--***************************************************************************/
VOID
MonitorProcess(
    IN PFN_IISAdminNotify pCallbackFcn,
    IN OUT BOOL* pfRehook,
    IN MONITOR_THREAD_START_STRUCT* pMonitorStruct
    )
{

    HRESULT hr = S_OK;
    HANDLE hInetinfoProcess = NULL;
    MONITOR_ACTION_TO_TAKE ActionToTake = MonitorActionShutdown;

    DBG_ASSERT ( pfRehook != NULL );

    BOOL fRehook = *pfRehook;
    *pfRehook = FALSE;

    DBG_ASSERT ( pCallbackFcn != NULL );

    //
    // Get the current process handle for inetinfo.
    //
    hr = GetProcessHandleForInetinfo ( &hInetinfoProcess );
    if ( FAILED ( hr ) )
    {
        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Failed to get inetinfo process handle "
                                "hr = %08x\n",
                                hr));
        goto exit;
    }

    //
    // Now that we have the process and we are about to wait on it, go
    // ahead and first tell the service that it can rehook, if we need to.
    //
    if ( fRehook )
    {
        //
        // Note:  This path can not end up calling the StopIISAdminMonitor or
        //        we will hit a dead lock.  While we could stop the StopIISAdminMonitor
        //        from waiting for the thread to exit, we would give up the
        //        ability during the shutdown to know that we are free of this thread.
        //
        pCallbackFcn(RehookAfterInetinfoCrash);

    }

    //
    // Setup the wait handles array
    // and wait on either inetinfo to have a problem
    // or for us to be told to stop monitoring the process
    //

    HANDLE WaitHandles[2];

    WaitHandles[0] = g_IISAdminMonitorShutdownEvent;
    WaitHandles[1] = hInetinfoProcess;

    if ( pMonitorStruct != NULL )
    {
        // It was initialized to this and shouldn't of changed yet.
        DBG_ASSERT ( pMonitorStruct->hrForStartup == S_OK );

        // Should be set if we were given a monitor structure 
        DBG_ASSERT ( pMonitorStruct->hStartupFinished != NULL );

        // There is nothing we can do if we get here
        // and this fails, so we don't check the return
        // value.
        SetEvent ( pMonitorStruct->hStartupFinished );

        // We null it out so we don't signal again in this routine.
        // It won't matter that we null it in other functions since
        // it was passed by value.
        pMonitorStruct = NULL;
    }

    DWORD dwWaitResult = WaitForMultipleObjects( 2,
                                           WaitHandles,
                                           FALSE,  // return if any handles signal
                                           INFINITE );


    IF_DEBUG ( INET_MONITOR )
    {
        DBGPRINTF((DBG_CONTEXT, "WaitResult = %d \n", dwWaitResult ));
    }

    if ( dwWaitResult == WAIT_FAILED )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "WaitForMultipleObjects failed, "
                                "hr = %08x\n",
                                 hr));
        goto exit;
    }

    //
    // Need to determine if we are just shutting down or if we have
    // an event we need to process.
    //
    if ( dwWaitResult == WAIT_OBJECT_0 )
    {
        // we are just trying to shutdown.
        DBG_ASSERT ( hr == S_OK );
        goto exit;
    }

    // Assume inetinfo has signalled.
    DBG_ASSERT ( dwWaitResult == WAIT_OBJECT_0 + 1 );

    //
    // Note:  The this routine may not call the
    //        StopIISAdminMonitor routine or we will
    //        deadlock.  ( There is an assert to protect
    //        in checked builds )
    //
    pCallbackFcn(NotifyAfterInetinfoCrash);

    ActionToTake = AdminMonitorRequiresShutdown();
    if ( ActionToTake == MonitorActionShutdown )
    {

        // At this point we know that we need to tell the service to shutdown
        // so we will before we exit.
        //
        // Note:  The this routine may not call the
        //        StopIISAdminMonitor routine or we will
        //        deadlock.  ( There is an assert to protect
        //        in checked builds )
        //
        pCallbackFcn( ShutdownAfterInetinfoCrash );
        *pfRehook = FALSE;
    }
    else if ( ActionToTake == MonitorActionRehook )
    {
        // we need to tell the service to rehook.
        // the service will actually be told after
        // we start monitoring again, so for now
        // all we need to do is set pfRehook to true
        *pfRehook = TRUE;
    }
    else if ( ActionToTake == MonitorActionExit )
    {
        // by doing nothing we will naturally stop.
        *pfRehook = FALSE;
    }


exit:

    if ( hInetinfoProcess != NULL )
    {
        CloseHandle ( hInetinfoProcess );
        hInetinfoProcess = NULL;
    }

    if ( FAILED ( hr ) )
    {
        // Tell the using code that there has been a 
        // system failure, so it can tell the users.
        pCallbackFcn( SystemFailureMonitoringInetinfo );

        // Don't even attempt to rehook for notifications.
        *pfRehook = FALSE;
    }

    //
    // If we get here and we have not set this, then
    // we know that we are still in startup and we need
    // to signal it now.
    //
    if ( pMonitorStruct != NULL )
    {
        // It was initialized to this and shouldn't of changed yet.
        DBG_ASSERT ( pMonitorStruct->hrForStartup == S_OK );

        // The hr should be failed if we got here and didn't get
        // signalled above.
        DBG_ASSERT ( FAILED ( hr ) );

        // Save off the hr so we can report it back.
        pMonitorStruct->hrForStartup = hr;

        // Should be set if we were given a monitor structure 
        DBG_ASSERT ( pMonitorStruct->hStartupFinished != NULL );

        // There is nothing we can do if we get here
        // and this fails, so we don't check the return
        // value.
        SetEvent ( pMonitorStruct->hStartupFinished );

        // We null it out so we don't signal again in this routine.
        // It won't matter that we null it in other functions since
        // it was passed by value.
        pMonitorStruct = NULL;
    }


}  // MonitorProcess

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
#include <irtlmisc.h>

/************************************************************
 *     Global Variables
 ************************************************************/

DEBUG_PRINTS  *  g_pDebug = NULL;      \
DECLARE_PLATFORM_TYPE();
                                                                               //
/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {       
        CREATE_DEBUG_PRINT_OBJECT("iisutil");
    
        if (!VALID_DEBUG_PRINT_OBJECT()) 
        {
            return FALSE;
        }
    
        DisableThreadLibraryCalls(hInstance);
        
        BOOL fRet = InitializeIISUtilProcessAttach();
        return fRet;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TerminateIISUtilProcessDetach();

        DELETE_DEBUG_PRINT_OBJECT();
  
        return TRUE;
    }
    
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\acache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       acache.cxx

   Abstract:
       This module implements the Allocation cache handler and associated
        objects.

   Author:

       Murali R. Krishnan    ( MuraliK )     12-Sept-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/

// TODO:
// * (Debug only) Add guard blocks before and after each allocation to detect
//   under- and overruns.
// * (Debug only) Change the order of the freelist to FIFO (instead of
//   LIFO) to help catch cases of a block being free'd while something
//   else still points to it and then getting reused.

/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#include <acache.hxx>

#include <irtlmisc.h>

static
DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue
   );

#define PRIVATE_HEAP

//
// # of CPUs in machine (for allocation threshold scaling)
//
DWORD g_cCPU = 1;

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ACACHE_CONFIG_PARAMS_REG_KEY[] = ACACHE_REG_PARAMS_REG_KEY;

/************************************************************
 *    Inlined Documentation on Alloc-Cache
 *
 * Allocation Cache:
 *    This module is to cache the commonly allocated objects
 *    to serve following goals
 *      1) we can have maximum reuse of blocks
 *      2) avoid traffic to the process heap manager
 *      3) gather statistics for understanding of usage
 *
 * Details on Allocation Cache:
 *   There is one ALLOC_CACHE_HANDLER (shortly ACH) object per
 *   object that we decide to cache. The ACH is initialized by
 *   the configuration supplied during its construction. ACH serves
 *   as the main object for allocation/free of the objects it is created
 *   to cache. ACH gathers statistics of various operations and provides
 *   hooks to export the gathered statistics. There is a periodic cleanup
 *   scavenger that frees up long unused blocks thus reducing the working
 *   set of the system.
 *
 *   All ACH objects created are chained and maintained in the global
 *   list of allocation cache handler objects. This global list is used
 *   for enumeration, debugging, and statistics dumps
 *
 * Allocation cache Configuration:
 *
 *   Each ACH object is created with the ALLOC_CACHE_CONFIGURATION that
 *   specifies the (concurrency factor, threshold, size) desired.
 *   The concurrency factor ensures that we support the specified level
 *   of concurrency in allocations. The threshold specifies the number
 *   of objects that we will maintain (max) in the free-list. When the
 *   threshold is exceeded the freed objects are pushed to the process
 *   pool until the currently active objects fall below the threshold.
 *   In addition, each ACH object also retains a read-only name for the
 *   object allocated - for friendly tracking purposes.
 *
 *   There is also a global configuration parameter that specifies the
 *   Lookaside cleanup interval.
 *
 * Allocation and Free:
 *   Allocation allocates one free object from the free-list if any exist.
 *   Otherwise the allocation will result in fetching a new object from
 *   the process heap manager.
 *   A free adds the freed object to the free-list if the # free objects
 *   is less than the threshold specified. Otherwise the object is freed
 *   to the process heap manager.
 *   Statistics are gathered during both allocation and free operations.
 *
 * Statistics:
 *   Statistics are gathered during the alloc/free operations throughout
 *   the life-time of the ACH. These statistics are reported via the
 *   DumpStatsToHtml() exported function. The statistics can also be
 *   gathered by the NTSD helper function.
 *
 * Scheduled List cleanup:
 *   There is a scheduled work item for the lookaside cleanup interval.
 *   The callback function walks through the list of ACH items on global
 *   list and takes snapshot of the # allocation calls. On a subsequent
 *   walk-through, if the # allocation calls remains the same (which will
 *   be the case if there is no allocation activity), then, the entire
 *   list of alloced objects is pruned. This pruning reduces the working
 *   set of the process.
 ************************************************************/

/************************************************************
 *    Static Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

CRITICAL_SECTION ALLOC_CACHE_HANDLER::sm_csItems;
BOOL             ALLOC_CACHE_HANDLER::sm_fInitCsItems = FALSE;
LIST_ENTRY       ALLOC_CACHE_HANDLER::sm_lItemsHead;
HANDLE           ALLOC_CACHE_HANDLER::sm_hTimer = NULL;
LONG             ALLOC_CACHE_HANDLER::sm_nFillPattern = 0xACA50000 ;


// This class is used to implement the free list.  We cast the free'd
// memory block to a CFreeList*.  The signature is used to guard against
// double deletion.  We also fill memory with a pattern.

class CFreeList
{
public:
    SINGLE_LIST_ENTRY Next;
    DWORD             dwSig;

    enum {
        FREESIG = (('A') | ('C' << 8) | ('a' << 16) | (('$' << 24) | 0x80)),
    };
};


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Initialize(VOID)
{
    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    // initialize the class statics
    InitializeListHead( &sm_lItemsHead);

    if( !InitializeCriticalSectionAndSpinCount(&sm_csItems, 
                                               0x80000000 /* precreate event */ |
                                               IIS_DEFAULT_CS_SPIN_COUNT ) )
    {
        return FALSE;
    }
    sm_fInitCsItems = TRUE;
        
    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Initialize()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Cleanup(VOID)
{
    DBG_ASSERT( sm_hTimer == NULL);

    DBG_ASSERT( IsListEmpty(&sm_lItemsHead));
    if ( sm_fInitCsItems )
    {
        DeleteCriticalSection( &sm_csItems);
        sm_fInitCsItems = FALSE;
    }

    return ( TRUE);

} // ALLOC_CACHE_HANDLER::Cleanup()


/* class static */
VOID
ALLOC_CACHE_HANDLER::InsertNewItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    InsertTailList( &sm_lItemsHead, &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::InsertNewItem()



/* class static */
VOID
ALLOC_CACHE_HANDLER::RemoveItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    RemoveEntryList( &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::RemoveItem()



/* class static */
BOOL
ALLOC_CACHE_HANDLER::DumpStatsToHtml(
   OUT CHAR * pchBuffer,
   IN OUT LPDWORD lpcchBuffer )
/*++
  Description:
    This function dumps the stats on all allocation cached objects
     to HTML format for diagnostics

  Arguments:
    pchBuffer - pointer to buffer that will contain the html results
    lpcchBuffer - pointer to DWORD containing the size of buffer on entry
               On return this contains the # of bytes written out to buffer

  Return:
    TRUE for success and FALSE for failure
    Look at GetLastError() for the error code.
--*/
{
    LIST_ENTRY  * pEntry;
    DWORD  iCount, cch;
    DWORD  cbTotalMem = 0;
    BOOL   fRet = TRUE;

    if ( (lpcchBuffer == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    EnterCriticalSection( &sm_csItems);

    if ( 300 < *lpcchBuffer ) {

        // Print the header blob
        cch = wsprintfA( pchBuffer,
                         "\r\nAllocCacheTable Data <br>\r\n"
                         "<TABLE BORDER> <TR> "
                         "<TH> Item Name </TH> "
                         "<TH> Config(concurr, threshold, size) </TH> "
                         "<TH> # Total Items </TH> "
                         "<TH> # Alloc Calls </TH> "
                         "<TH> # Free Calls </TH> "
                         "<TH> # Free Entries </TH> "
                         "<TH> # Total Size (bytes) </TH> "
                         "<TH> Fill Pattern </TH> "
                         "<TH> Heap </TH> "
                         " </TR>\r\n"
                         );
    } else {
        cch = 300;
    }

    for ( pEntry = sm_lItemsHead.Flink, iCount = 0;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink, iCount++
          ) {

        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        cbTotalMem += pach->m_acConfig.cbSize * pach->m_nTotal;

        if ( (cch + 160 + strlen( pach->m_pszName)) < *lpcchBuffer) {
            cch += wsprintfA( pchBuffer + cch,
                              " <TR> <TD> [%d] %s </TD>"
                              " <TD> (%d, %d, %d) </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> 0x%08lX </TD>"
                              " <TD> %p </TD>"
                              " </TR>\r\n"
                              ,
                              iCount, pach->m_pszName,
                              pach->m_acConfig.nConcurrency,
                              pach->m_acConfig.nThreshold,
                              pach->m_acConfig.cbSize,
                              pach->m_nTotal,
                              pach->m_nAllocCalls,
                              pach->m_nFreeCalls,
                              pach->m_nFreeEntries,
                              pach->m_acConfig.cbSize * pach->m_nTotal,
                              pach->m_nFillPattern,
                              pach->m_hHeap
                              );
        } else {
            cch += 160 + strlen( pach->m_pszName);
        }
    } // for

    LeaveCriticalSection( &sm_csItems);

    //
    // dump the final summary
    //
    if ( (cch + 100 ) < *lpcchBuffer) {
        cch += wsprintfA( pchBuffer + cch,
                          " <b>"
                          " <TR> </TR>"
                          " <TR> <TD> Total </TD> <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> %4d </TD>"
                          " </TR>"
                          "</b>\r\n"
                          " </TABLE>\r\n\r\n"
                          ,
                          cbTotalMem
                          );
    } else {
        cch += 100;
    }

    if ( *lpcchBuffer < cch ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fRet = FALSE;
    }

    *lpcchBuffer = cch;

    return (fRet);
} // ALLOC_CACHE_HANDLER::DumpStatsToHtml()

extern "C"
BOOL AllocCacheDumpStatsToHtml( OUT CHAR * pch,
                                IN OUT LPDWORD lpcchBuff)
{
    return ( ALLOC_CACHE_HANDLER::DumpStatsToHtml( pch, lpcchBuff));
}

/* class static */
BOOL
ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval( VOID )
{
    DWORD               dwError;
    DWORD               dwVal = 0;
    HKEY                hkey;

    dwError = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                             g_PSZ_ACACHE_CONFIG_PARAMS_REG_KEY,
                             0,
                             KEY_READ,
                             &hkey);

    if ( dwError == NO_ERROR ) {

        //
        // get the lookaside list cleanup period
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL,
                                   ACACHE_REG_DEFAULT_CLEANUP_INTERVAL );

        DBG_REQUIRE( !RegCloseKey( hkey ) );
    }

    if ( dwVal != 0 )
    {
        BOOL fRet = TRUE;
        fRet = CreateTimerQueueTimer( 
                    &sm_hTimer,
                    NULL, // default timer queue
                    ALLOC_CACHE_HANDLER::CleanupAllLookasides,
                    NULL, // context
                    dwVal * 1000,
                    dwVal * 1000,
                    WT_EXECUTELONGFUNCTION );
      
        if ( !fRet )
        {
            return FALSE;
        }
    }

    return TRUE;
} // ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval( VOID )
{
    BOOL fReturn = TRUE;
    if ( sm_hTimer != NULL )
    {
        BOOL fRet = TRUE;
        fRet = DeleteTimerQueueTimer( 
                    NULL, // default timer queue
                    sm_hTimer,
                    INVALID_HANDLE_VALUE // wait for all callbacks to return
                    );
        sm_hTimer = NULL;
        if ( !fRet )
        {
            return FALSE;
        }

    }

    return ( fReturn);
} // ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval()


//static
void CALLBACK
ALLOC_CACHE_HANDLER::CleanupAllLookasides(
    PVOID,              /* pvContext */
    BOOLEAN             /* TimerOrWaitFired */
)
{
    LIST_ENTRY *        pEntry;

    EnterCriticalSection( &sm_csItems);

    for ( pEntry = sm_lItemsHead.Flink;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink )
    {
        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        IF_DEBUG( ALLOC_CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                         "Cleaning lookaside list for '%s' handler\n",
                         pach->m_pszName ));
        }

        pach->CleanupLookaside( FALSE );
    }

    LeaveCriticalSection( &sm_csItems);
} // ALLOC_CACHE_HANDLER::CleanupAllLookasides()




/************************************************************
 *    Member Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig,
    IN BOOL fEnableCleanupAsserts /* = TRUE */
    )
    : m_fValid ( FALSE),
      m_nTotal       (0),
      m_nAllocCalls  (0),
      m_nFreeCalls   (0),
      m_nFreeEntries (0),
      m_pszName      (pszName),
      m_nLastAllocCount(0),
      m_hHeap        (NULL),
      m_fCleanupAssertsEnabled(fEnableCleanupAsserts),
      m_fcsInitialized  (FALSE)
{
    DBG_ASSERT( NULL != pacConfig );
    m_acConfig = *pacConfig;

    if ( pacConfig->nThreshold == INFINITE) {
        // this will be compared against a signed value. So be careful.
        m_acConfig.nThreshold = 0x7FFFFFFF;
    } else {
        // scale by the number of processors on MP machines
        m_acConfig.nThreshold *= g_cCPU;
    }

    // make sure the block is big enough to hold a CFreeList
    m_acConfig.cbSize = max(m_acConfig.cbSize, sizeof(CFreeList));
    // round up the block size to a multiple of the size of a LONG (for
    // the fill pattern in Free()).
    m_acConfig.cbSize = 
        (m_acConfig.cbSize + sizeof(LONG) - 1) & ~(sizeof(LONG) - 1);

    if( InitializeCriticalSectionAndSpinCount(&m_csLock, 
                                              0x80000000 /* precreate event */ |
                                              IIS_DEFAULT_CS_SPIN_COUNT ) )
    {   
        //
        // If the allocation failed, thats OK.  We'll just use
        // the static sm_csItems as the critical section
        //
        // Better this, than a constructor which can fail and a tonne
        // of botched callers
        //
        
        m_fcsInitialized = TRUE;
    }
    
    m_lHead.Next = NULL;
    m_nFillPattern = InterlockedIncrement(&sm_nFillPattern);

    //
    // Create private heap
    //

#ifdef PRIVATE_HEAP
    m_hHeap = HeapCreate( 0, 0, 0 );

    if( m_hHeap == NULL )
    {
        //
        // If we couldn't allocate our own heap, just use the process
        // heap
        //
        
        m_hHeap = GetProcessHeap();
        
        DBG_ASSERT( m_hHeap != NULL );
    }
#endif

    ALLOC_CACHE_HANDLER::InsertNewItem( this);
    m_fValid = TRUE;
    return;
} // ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER()



ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{
    if ( m_fValid) {

        ALLOC_CACHE_HANDLER::RemoveItem( this);

        CleanupLookaside( TRUE );

        
#ifdef PRIVATE_HEAP
        if ( m_hHeap )
        {   
            //
            // Only destroy the heap if we created it
            //
            
            if ( m_hHeap != GetProcessHeap() )
            {
                DBG_REQUIRE( HeapDestroy( m_hHeap ) );
            }
            
            m_hHeap = NULL;
        }
#endif
    }

    if (m_fCleanupAssertsEnabled) {
        DBG_ASSERT( 0 == m_nTotal );
        DBG_ASSERT( m_lHead.Next == NULL);
    }

    if (m_fcsInitialized)
    {
        DeleteCriticalSection( & m_csLock);
        m_fcsInitialized = FALSE;
    }
    
    return;
} // ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER()

VOID
ALLOC_CACHE_HANDLER::Lock(
    VOID
)
{
    if ( m_fcsInitialized )
    { 
        EnterCriticalSection( &m_csLock ); 
    }
    else
    {
        //
        // This may seem a bit slimey, but not as slimey as
        // having a contructor which can fail, with a tonne
        // of botched initializations throughout server
        //
            
        EnterCriticalSection( &sm_csItems );
    }
}

VOID
ALLOC_CACHE_HANDLER::Unlock(
    VOID
)
{
    if ( m_fcsInitialized )
    {
        LeaveCriticalSection( & m_csLock);
    }
    else
    {
        //
        // See comment above
        //
            
        LeaveCriticalSection( &sm_csItems );
    }
}    

VOID
ALLOC_CACHE_HANDLER::CleanupLookaside(
    IN BOOL             fForceCleanup
)
/*++
  Description:
    This function cleans up the lookaside list by removing excess storage space
    used by the objects allocated by this instance. This function is
    used by the periodic scavenging operation as well as for final cleanup.

  Arguments:
    fForceCleanup - forces a cleanup operation always.

  Returns:
     None
--*/
{
    if ( !fForceCleanup )
    {
        //
        // We are called for the regular scavenging operation
        // Take a snapshot of the # allocation calls so that
        //  we may cleanup space when services are idle.
        //

        IF_DEBUG( ALLOC_CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                         "AllocCalls = %ld, LastAllocCount = %ld\n",
                         m_nAllocCalls,
                         m_nLastAllocCount ));
        }

        if ( m_nAllocCalls != m_nLastAllocCount )
        {
            InterlockedExchange( &m_nLastAllocCount,
                                 m_nAllocCalls );
            return;
        }
    }

    SINGLE_LIST_ENTRY listHeadCopy;

    //
    // make a copy of the first element in the list inside the lock
    // Free the entire chain outside the locked section.
    // Otherwise on a busy system the threads will be waiting for
    //  this thread to complete
    //

    Lock();
    listHeadCopy.Next = m_lHead.Next;

    //
    // we are about to cleanup all entries -> so set state back properly.
    //
    m_lHead.Next      = NULL;
    m_nFreeEntries    = 0; // no more free-entries available
    Unlock();

    //
    // free up all the entries in the list
    //

    PSINGLE_LIST_ENTRY pl;
    pl = PopEntryList( &listHeadCopy);
    while ( pl != NULL) {

        InterlockedDecrement( &m_nTotal);
#ifdef PRIVATE_HEAP
        HeapFree( m_hHeap, 0, pl );
#else
        ::LocalFree(pl);
#endif
        pl = PopEntryList( &listHeadCopy);
    } // for

    DBG_ASSERT( listHeadCopy.Next == NULL);

    return;
} // ALLOC_CACHE_HANDLER::CleanupLookaside()



LPVOID
ALLOC_CACHE_HANDLER::Alloc( VOID )
{
    LPVOID pv = NULL;

    if ( m_nFreeEntries > 0) {

        //
        // There are free entries available - allocate from the free pool
        //

        // Only acquire the lock if there's potentially something to grab
        Lock();

        // Check again if the free entry is available.
        if ( m_nFreeEntries > 0) {
            pv = (LPVOID) PopEntryList( & m_lHead);  // get the real object
            m_nFreeEntries--;
        }

        Unlock();

        if ( NULL != pv ) {
            CFreeList* pfl = (CFreeList*) pv;
            // If the signature is wrong then somebody's been scribbling
            // on memory that they've freed
            DBG_ASSERT(pfl->dwSig == CFreeList::FREESIG);
            pfl->dwSig = 0; // clear; just in case caller never overwrites
        }
    }

    if ( NULL == pv) {

        //
        // No free entry. Need to alloc a new object.
        //
        
#ifdef PRIVATE_HEAP
        DBG_ASSERT( m_hHeap != NULL );

        pv = (LPVOID) HeapAlloc( m_hHeap,
                                 HEAP_ZERO_MEMORY,
                                 m_acConfig.cbSize );
                                 
        if ( pv == NULL )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
#else
        pv = (LPVOID) LocalAlloc( LPTR, m_acConfig.cbSize );
#endif
        if ( NULL != pv) {
            // update counters
            InterlockedIncrement( &m_nTotal);
        }
    }

    if ( NULL != pv ) {
        InterlockedIncrement( &m_nAllocCalls);
    }

    return ( pv);
} // ALLOC_CACHE_HANDLER::Alloc()



BOOL
ALLOC_CACHE_HANDLER::Free( LPVOID pv)
{
    // Assume that this is allocated using the Alloc() function
    DBG_ASSERT( NULL != pv);

    // use a signature to check against double deletions
    CFreeList* pfl = (CFreeList*) pv;
    DBG_ASSERT(pfl->dwSig != CFreeList::FREESIG);

#ifdef _DEBUG
    // Fill the memory with an improbable pattern that is unique
    // to this allocator (for identification in the debugger)
    RtlFillMemoryUlong(pv, m_acConfig.cbSize, m_nFillPattern);
#else  // !_DEBUG
    // Start filling the space beyond the portion overlaid by the initial
    // CFreeList.  Fill at most 6 DWORDS.
    LONG* pl = (LONG*) (pfl+1);

    for (LONG cb = (LONG)min(6 * sizeof(LONG),m_acConfig.cbSize) - sizeof(CFreeList);
         cb > 0;
         cb -= sizeof(LONG))
    {
        *pl++ = m_nFillPattern;
    }
#endif // !_DEBUG

    // Now, set the signature
    pfl->dwSig = CFreeList::FREESIG;

    // store the items in the alloc cache.

    if ( m_nFreeEntries >= m_acConfig.nThreshold) {

        //
        // threshold for free entries is exceeded. free the object to
        //  process pool
        //
        
#ifdef PRIVATE_HEAP
        HeapFree( m_hHeap, 0, pv );
#else
        ::LocalFree(pv);
#endif

        InterlockedDecrement( &m_nTotal);
    } else {

        //
        // Store the given pointer in the single linear list
        //

        Lock();
        PushEntryList( &m_lHead,  &pfl->Next);
        m_nFreeEntries++;
        Unlock();
    }

    InterlockedIncrement( &m_nFreeCalls);

    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Free()




VOID
ALLOC_CACHE_HANDLER::Print( VOID)
{
    CHAR  rgchBuffer[8192];
    DWORD cchBuffer = sizeof(rgchBuffer);

    DBG_REQUIRE( IpPrint( rgchBuffer, &cchBuffer));

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));

    return;
} // ALLOC_CACHE_HANDLER::Print()



BOOL
ALLOC_CACHE_HANDLER::IpPrint( OUT CHAR * pchBuffer, IN OUT LPDWORD pcchSize)
{
    DWORD cchUsed;

    cchUsed = wsprintfA( pchBuffer,
                         "[%d]ALLOC_CACHE_HANDLER[%08p]. Config: "
                         " ObjSize = %d. Concurrency=%d. Thres=%d.\n"
                         " TotalObjs = %d. Calls: Alloc(%d), Free(%d)."
                         " FreeEntries = %d. FillPattern = 0x%08lX.\n"
                         ,
                         GetCurrentThreadId(),
                         this,
                         m_acConfig.cbSize,
                         m_acConfig.nConcurrency,
                         m_acConfig.nThreshold,
                         m_nTotal, m_nAllocCalls, m_nFreeCalls,
                         m_nFreeEntries, m_nFillPattern
                         );
    Lock();

    // NYI: Print the list of individual pointers
    Unlock();

    DBG_ASSERT( *pcchSize > cchUsed);
    *pcchSize = cchUsed;

    return (TRUE);
} // ALLOC_CACHE_HANDLER::IpPrint()



VOID
ALLOC_CACHE_HANDLER::QueryStats( IN ALLOC_CACHE_STATISTICS * pacStats )
{
    DBG_ASSERT( pacStats != NULL );

    pacStats->acConfig      = m_acConfig;
    pacStats->nTotal        = m_nTotal;
    pacStats->nAllocCalls   = m_nAllocCalls;
    pacStats->nFreeCalls    = m_nFreeCalls;
    pacStats->nFreeEntries  = m_nFreeEntries;

    return;
} // ALLOC_CACHE_HANDLER::QueryStats()


//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\datetime.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      datetime.cxx

   Abstract:

      This module exports common functions for date and time fields,
      Expanding into strings and manipulation.

   Author:

           Murali R. Krishnan    ( MuraliK )    3-Jan-1995

--*/

#include "precomp.hxx"

#include <stdlib.h>


# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

#define IMPLEMENTATION_EXPORT

#include <datetime.hxx>


class dllexp CDateTime
{
public:
    FILETIME_UINT64 m_ftu;
    SYSTEMTIME      m_st;
    
    CDateTime()
    { /* do nothing */ }

    CDateTime(const SYSTEMTIME& rst)
    { SetTime(rst); }
      
    CDateTime(const FILETIME& rft)
    { SetTime(rft); }

    CDateTime(const FILETIME& rft, const SYSTEMTIME& rst)
    { m_ftu.ft = rft; m_st = rst; }
    
    BOOL
    GetCurrentTime()
    {
        GetSystemTimeAsFileTime(&m_ftu.ft);
        return FileTimeToSystemTime(&m_ftu.ft, &m_st);
    }

    BOOL
    SetTime(const SYSTEMTIME& rst)
    { m_st = rst; return SystemTimeToFileTime(&m_st, &m_ftu.ft); }

    BOOL
    SetTime(const FILETIME& rft)
    { m_ftu.ft = rft; return FileTimeToSystemTime(&m_ftu.ft, &m_st); }
};



static const CHAR  g_rgchTwoDigits[100][2] =
{
    { '0', '0' }, { '0', '1' }, { '0', '2' }, { '0', '3' }, { '0', '4' },
    { '0', '5' }, { '0', '6' }, { '0', '7' }, { '0', '8' }, { '0', '9' },

    { '1', '0' }, { '1', '1' }, { '1', '2' }, { '1', '3' }, { '1', '4' },
    { '1', '5' }, { '1', '6' }, { '1', '7' }, { '1', '8' }, { '1', '9' },

    { '2', '0' }, { '2', '1' }, { '2', '2' }, { '2', '3' }, { '2', '4' },
    { '2', '5' }, { '2', '6' }, { '2', '7' }, { '2', '8' }, { '2', '9' },

    { '3', '0' }, { '3', '1' }, { '3', '2' }, { '3', '3' }, { '3', '4' },
    { '3', '5' }, { '3', '6' }, { '3', '7' }, { '3', '8' }, { '3', '9' },

    { '4', '0' }, { '4', '1' }, { '4', '2' }, { '4', '3' }, { '4', '4' },
    { '4', '5' }, { '4', '6' }, { '4', '7' }, { '4', '8' }, { '4', '9' },

    { '5', '0' }, { '5', '1' }, { '5', '2' }, { '5', '3' }, { '5', '4' },
    { '5', '5' }, { '5', '6' }, { '5', '7' }, { '5', '8' }, { '5', '9' },

    { '6', '0' }, { '6', '1' }, { '6', '2' }, { '6', '3' }, { '6', '4' },
    { '6', '5' }, { '6', '6' }, { '6', '7' }, { '6', '8' }, { '6', '9' },

    { '7', '0' }, { '7', '1' }, { '7', '2' }, { '7', '3' }, { '7', '4' },
    { '7', '5' }, { '7', '6' }, { '7', '7' }, { '7', '8' }, { '7', '9' },

    { '8', '0' }, { '8', '1' }, { '8', '2' }, { '8', '3' }, { '8', '4' },
    { '8', '5' }, { '8', '6' }, { '8', '7' }, { '8', '8' }, { '8', '9' },

    { '9', '0' }, { '9', '1' }, { '9', '2' }, { '9', '3' }, { '9', '4' },
    { '9', '5' }, { '9', '6' }, { '9', '7' }, { '9', '8' }, { '9', '9' },
};


//
//  Constants
//

#define APPEND_STR(a,b)  \
    {CopyMemory(a,b,sizeof(b));  a += sizeof(b)-sizeof(CHAR);}

#define APPEND_PSZ( pszTail, psz )          \
    { DWORD cb = strlen( psz );             \
      CopyMemory( (pszTail), (psz), cb + 1 );\
      (pszTail) += cb;                      \
    }

//
// Makes a two-digit zero padded number (i.e., "23", or "05")
//

inline
VOID
AppendTwoDigits(
    CHAR*& rpszTail,
    DWORD Num
    )
{
    if ( Num < 100 )
    {
        rpszTail[0] = g_rgchTwoDigits[Num][0];
        rpszTail[1] = g_rgchTwoDigits[Num][1];
        rpszTail[2] = '\0';
        rpszTail += 2;
    }
    else
    {
        DBG_ASSERT(!"Num >= 100");
    }
}


//
// Years conversion
//


#define MAX_CACHED_YEARS 32
static DWORD g_nMinYear = 0, g_nMaxYear = 0;
static char  g_aszYears[MAX_CACHED_YEARS][4+1];

typedef CDataCache<CDateTime> CCacheTime;
static CCacheTime             g_ctCurrentTime;

void
InitializeDateTime()
{
    SYSTEMTIME    st;
    GetSystemTime(&st);

    g_nMinYear = st.wYear - MAX_CACHED_YEARS / 2;
    g_nMaxYear = g_nMinYear + MAX_CACHED_YEARS - 1;

    DBG_ASSERT(1000 <= g_nMinYear  &&  g_nMaxYear <= 9999);

    for (DWORD i = g_nMinYear;  i <= g_nMaxYear;  i++)
    {
        _itoa( i, g_aszYears[i - g_nMinYear], 10 );
    }

    CDateTime dt(st);
    g_ctCurrentTime.Write(dt);
}


void
TerminateDateTime()
{
    // nothing to be done, at least for now
}


inline
VOID
AppendYear(
    CHAR* &rpszTail,
    DWORD dwYear
    )
{
    DBG_ASSERT(g_nMinYear >= 1000);
    DWORD i = dwYear - g_nMinYear;
    
    if (i < MAX_CACHED_YEARS)
    {
        DBG_ASSERT(g_nMinYear <= dwYear  &&  dwYear <= g_nMaxYear);
        const char* pszYear = g_aszYears[i];
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail = '\0';
    }
    else
    {
        CHAR  __ach[32];
        DBG_ASSERT( dwYear >= 1000 && dwYear <= 9999 );
        _itoa( dwYear, __ach, 10 );

        CopyMemory( rpszTail, __ach, 4+1 );
        rpszTail += 4;
    }
}


// Since ::GetSystemTime is relatively expensive (310 instructions) and
// ::GetSystemTimeAsFileTime is pretty cheap (20 instructions), we cache
// the SYSTEMTIME representation of the current time with an accuracy of
// 1.0 seconds.

BOOL
IISGetCurrentTime(
    OUT FILETIME*   pft,
    OUT SYSTEMTIME* pst)
{
    BOOL fUpdatedCachedTime = FALSE;
    CDateTime dt;
    
    while (! g_ctCurrentTime.Read(dt))
    {
        // empty loop
    }
    
    FILETIME_UINT64 ftu;
    GetSystemTimeAsFileTime(&ftu.ft);
    
    if (ftu.u64 - dt.m_ftu.u64 >= FILETIME_1_SECOND)
    {
#undef WT_INSTRUCTION_COUNTS
        
#ifndef WT_INSTRUCTION_COUNTS
        fUpdatedCachedTime = TRUE;
        dt.SetTime(ftu.ft);
        g_ctCurrentTime.Write(dt);
#endif
    }
    
    if (pft != NULL)
        *pft = dt.m_ftu.ft;
    if (pst != NULL)
        *pst = dt.m_st;

    return fUpdatedCachedTime;
}



/************************************************************
 *   Data
 ************************************************************/
static const CHAR* s_rgchDays[] =  {
    "Sun", "Mon", "Tue", "Wed",
    "Thu", "Fri", "Sat"
};

static const CHAR* s_rgchMonths[] = {
    "Jan", "Feb", "Mar", "Apr",
    "May", "Jun", "Jul", "Aug",
    "Sep", "Oct", "Nov", "Dec"
};

LPCSTR
DayOfWeek3CharNames(DWORD dwDayOfWeek)
{
    return s_rgchDays[dwDayOfWeek];
}

LPCSTR
Month3CharNames(DWORD dwMonth)
{
    return s_rgchMonths[dwMonth];
}

// Custom hash table for make_month() for mapping "Apr" to 4
static const CHAR MonthIndexTable[64] = {
   -1,'A',  2, 12, -1, -1, -1,  8, // A to G
   -1, -1, -1, -1,  7, -1,'N', -1, // F to O
    9, -1,'R', -1, 10, -1, 11, -1, // P to W
   -1,  5, -1, -1, -1, -1, -1, -1, // X to Z
   -1,'A',  2, 12, -1, -1, -1,  8, // a to g
   -1, -1, -1, -1,  7, -1,'N', -1, // f to o
    9, -1,'R', -1, 10, -1, 11, -1, // p to w
   -1,  5, -1, -1, -1, -1, -1, -1  // x to z
};


static const BYTE TensDigit[10] = { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 };


/************************************************************
 *    Functions
 ************************************************************/

WORD
iis_2atoi(
    PCHAR s
    )
/*++

    Converts a 2 character string to integer

    Arguments:
        s   String to convert

    Returns:
        numeric equivalent, 0 on failure.
--*/
{

    DWORD tens = s[0] - '0';
    DWORD ones = s[1] - '0';

    if ( (tens <= 9) && (ones <= 9) ) {
        return((WORD)(TensDigit[tens] + ones));
    }
    return(0);
}

#if 1
WORD
make_month(
    PCHAR s
    )
{
    UCHAR monthIndex;
    UCHAR c;
    LPCSTR monthString;

    //
    // use the third character as the index
    //

    c = (s[2] - 0x40) & 0x3F;

    monthIndex = MonthIndexTable[c];

    if ( monthIndex < 13 ) {
        goto verify;
    }

    //
    // ok, we need to look at the second character
    //

    if ( monthIndex == 'N' ) {

        //
        // we got an N which we need to resolve further
        //

        //
        // if s[1] is 'u' then Jun, if 'a' then Jan
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 1;
        } else {
            monthIndex = 6;
        }

    } else if ( monthIndex == 'R' ) {

        //
        // if s[1] is 'a' then March, if 'p' then April
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 3;
        } else {
            monthIndex = 4;
        }
    } else {
        goto error_exit;
    }

verify:

    monthString = s_rgchMonths[monthIndex-1];

    if ( (s[0] == monthString[0]) &&
         (s[1] == monthString[1]) &&
         (s[2] == monthString[2]) ) {

        return(monthIndex);

    } else if ( (toupper(s[0]) == monthString[0]) &&
                (tolower(s[1]) == monthString[1]) &&
                (tolower(s[2]) == monthString[2]) ) {

        return monthIndex;
    }

error_exit:
    return(0);

} // make_month
#else
int
make_month(
    CHAR * s
    )
{
    int i;

    for (i=0; i<12; i++)
        if (!_strnicmp(s_rgchMonths[i], s, 3))
            return i + 1;
    return 0;
}
#endif

BOOL
SystemTimeToGMT(
    IN  const SYSTEMTIME & st,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    DBG_ASSERT( pszBuff != NULL);

    if ( cbBuff < GMT_STRING_SIZE )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    APPEND_PSZ( pszBuff, s_rgchDays[st.wDayOfWeek] );   // 0-based
    *pszBuff++ = ',';
    *pszBuff++ = ' ';
    AppendTwoDigits( pszBuff, st.wDay );
    *pszBuff++ = ' ';
    APPEND_PSZ( pszBuff, s_rgchMonths[st.wMonth - 1] ); // 1-based
    *pszBuff++ = ' ';
    AppendYear( pszBuff, st.wYear );
    *pszBuff++ = ' ';
    AppendTwoDigits( pszBuff, st.wHour );
    *pszBuff++ = ':';
    AppendTwoDigits( pszBuff, st.wMinute );
    *pszBuff++ = ':';
    AppendTwoDigits( pszBuff, st.wSecond );
    *pszBuff++ = ' ';
    *pszBuff++ = 'G';
    *pszBuff++ = 'M';
    *pszBuff++ = 'T';
    *pszBuff   = '\0';

    return ( TRUE);

} // SystemTimeToGMT()


BOOL
NtLargeIntegerTimeToLocalSystemTime(
    IN const LARGE_INTEGER * pliTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in Local Time zone.

  Arguments:
    pliTime        pointer to large integer containing the time in NT format.
    pst            pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            27-Apr-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG.
--*/
{
    FILETIME  ftLocal;

    if ( pliTime == NULL || pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    //  Convert the given large integer to local file time and
    //  then convert that to SYSTEMTIME.
    //   structure, containing the time details.
    //  I dont like this cast ( assumes too much about time structures)
    //   but again suitable methods are not available.
    //
    return (FileTimeToLocalFileTime((FILETIME *) pliTime,
                                     &ftLocal) &&
            FileTimeToSystemTime(&ftLocal, pst)
            );

} // NtLargeIntegerTimeToLocalSystemTime()


BOOL
SystemTimeToGMTEx(
    IN  const SYSTEMTIME & st,
    OUT CHAR *      pszBuff,
    IN  DWORD       cbBuff,
    IN  DWORD       csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;
    FILETIME    ft;

    DBG_ASSERT( pszBuff != NULL);

    //
    //  If an offset is specified, calculate that now
    //

    if (!SystemTimeToFileTime( &st, &ft )) {
        return(FALSE);
    }

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) FILETIME_1_SECOND;

    ft.dwHighDateTime = liTime.HighPart;
    ft.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
} // SystemTimeToGMTEx


BOOL
FileTimeToGMT(
    IN  const FILETIME   & ft,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      ft         File time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.
--*/
{
    SYSTEMTIME st;

    if (FileTimeToSystemTime(&ft, &st))
        return SystemTimeToGMT(st, pszBuff, cbBuff);
    else
        return FALSE;
}


BOOL
FileTimeToGMTEx(
    IN  const FILETIME   & ft,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff,
    IN  DWORD              csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      ft         File time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;

    DBG_ASSERT( pszBuff != NULL);

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) FILETIME_1_SECOND;

    FILETIME ft2 = ft;
    ft2.dwHighDateTime = liTime.HighPart;
    ft2.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft2, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
}

BOOL
NtLargeIntegerTimeToSystemTime(
    IN const LARGE_INTEGER & liTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in GMT

  Arguments:
    liTime             large integer containing the time in NT format.
    pst                pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            3-Jan-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG. Will that make a difference ? God knows.
       Or substitute whatever you want for God...
--*/
{
    FILETIME ft;

    if ( pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // convert li to filetime
    //

    ft.dwLowDateTime = liTime.LowPart;
    ft.dwHighDateTime = liTime.HighPart;

    //
    // convert to system time
    //

    if (!FileTimeToSystemTime(&ft,pst)) {
        return(FALSE);
    }

    return ( TRUE);

} // NtLargeIntegerTimeToSystemTime()

BOOL
NtSystemTimeToLargeInteger(
    IN  const SYSTEMTIME * pst,
    OUT LARGE_INTEGER *    pli
    )
{

    FILETIME ft;

    //
    // Convert to file time
    //

    if ( !SystemTimeToFileTime( pst, &ft ) ) {
        return(FALSE);
    }

    //
    // Convert file time to large integer
    //

    pli->LowPart = ft.dwLowDateTime;
    pli->HighPart = ft.dwHighDateTime;

    return(TRUE);
}

BOOL
StringTimeToFileTime(
    IN  const CHAR * pszTime,
    OUT LARGE_INTEGER * pliTime
    )
/*++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format

  Arguments:
    pszTime             String representation of time field
    pliTime             large integer containing the time in NT format.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library

--*/
{

    CHAR * s;
    SYSTEMTIME    st;

    if (pszTime == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    st.wMilliseconds = 0;

    if ((s = strchr(pszTime, ','))) {

        DWORD len;

        //
        // Thursday, 10-Jun-93 01:29:59 GMT
        // or: Thu, 10 Jan 1993 01:29:59 GMT */
        //

        s++;

        while (*s && *s==' ') s++;
        len = strlen(s);

        if (len < 18) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( *(s+2) == '-' ) {        /* First format */

            st.wDay = (WORD) atoi(s);
            st.wMonth = (WORD) make_month(s+3);
            st.wYear = (WORD) atoi(s+7);
            st.wHour = (WORD) atoi(s+10);
            st.wMinute = (WORD) atoi(s+13);
            st.wSecond = (WORD) atoi(s+16);

        } else {                /* Second format */

            if (len < 20) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }

            st.wDay = iis_2atoi(s);
            st.wMonth = make_month(s+3);
            st.wYear = iis_2atoi(s+7) * 100  +  iis_2atoi(s+9);
            st.wHour = iis_2atoi(s+12);
            st.wMinute = iis_2atoi(s+15);
            st.wSecond = iis_2atoi(s+18);

        }
    } else {    /* Try the other format:  Wed Jun  9 01:29:59 1993 GMT */

        s = (CHAR *) pszTime;
        while (*s && *s==' ') s++;

        if ((int)strlen(s) < 24) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        st.wDay = (WORD) atoi(s+8);
        st.wMonth = (WORD) make_month(s+4);
        st.wYear = (WORD) atoi(s+20);
        st.wHour = (WORD) atoi(s+11);
        st.wMinute = (WORD) atoi(s+14);
        st.wSecond = (WORD) atoi(s+17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if ( st.wYear < 1000 ) {
        if ( st.wYear < 50 ) {
            st.wYear += 2000;
        } else {
            st.wYear += 1900;
        }
    }

    if ( !NtSystemTimeToLargeInteger( &st,pliTime )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    return(TRUE);
}


/************************************************************
 *  Cached Date Time Formats
 *
 *  Formatting Date and Time for
 *    HTTP headers & Logging Requests
 *    is a costly operation.
 *  Using default NT Formatting operations with wsprintf()
 *    consumes about 6000 instructions/transaction
 *
 *  Following code addresses this issue by
 *   1) Caching formatted date/time pair for all purposes
 *   2) Caching is done at the granularity of seconds/minute
 *      If there is a match till seconds, we return entire
 *        formatted information.
 *      If there is a match till the minutes, then the seconds
 *        portion is over-written using a seconds-lookup-table.
 *
 *   Murali R. Krishnan (MuraliK)   23-Feb-1996
 ************************************************************/

//
// The delimiter string is :  <logDelimiterChar><blank>
// The delimiter char should be same as the one used for LOG_RECORD
//   in the file: ilogcls.cxx
//
const CHAR G_PSZ_LOG_DELIMITER[3] = ", ";



#ifdef ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  InterlockedIncrement( &m_nAccesses)
# define CdtCountMisses()    InterlockedIncrement( &m_nMisses)

# else  // ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  /* do nothing */
# define CdtCountMisses()    /* do nothing */

# endif // ENABLE_AUX_COUNTERS






VOID
DATETIME_FORMAT_ENTRY::CopyFormattedData(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime) const
{
    //
    // copy the formatted date/time information
    //
    
    CopyMemory(pchDateTime,
               m_rgchDateTime,
               m_cbDateTime
               );
    
    if ( m_stDateTime.wSecond != pst->wSecond) {
        
        //
        // seconds do not match. update seconds portion alone
        //
        
        LPSTR pch = pchDateTime + m_cchOffsetSeconds;
        
        *pch       = g_rgchTwoDigits[pst->wSecond][0];
        *(pch + 1) = g_rgchTwoDigits[pst->wSecond][1];
    }
    
    return;
}



BOOL
CDFTCache::CopyFormattedData(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime) const
{
    // See <readmost.hxx> for an explanation of this routine
    const LONG nSequence = _ReadSequence();
    
    // Is the data being updated on another thread?
    if (nSequence != UPDATING)
    { 
        // The weird const_cast syntax is necessitated by the volatile
        // attribute on m_tData (DATETIME_FORMAT_ENTRY).
        LPCSTR pchDate = FormattedBuffer();
        DWORD cbDateTime = DateTimeChars();
        
        // Copy the string
        CopyMemory(pchDateTime, pchDate, cbDateTime);
        
        if (Seconds() != pst->wSecond) {
            
            //
            // seconds do not match. update seconds portion alone
            //
            
            LPSTR pch = pchDateTime + OffsetSeconds();
            
            *pch       = g_rgchTwoDigits[pst->wSecond][0];
            *(pch + 1) = g_rgchTwoDigits[pst->wSecond][1];
        }

        // If the sequence number is unchanged, the read was valid.
        const LONG nSequence2 = _ReadSequence();

        return (nSequence == nSequence2);
    }

    return FALSE;
}



VOID
ASCLOG_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    CHAR rgchTime[25];
    CHAR * pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );


    //
    // Format date for Logging (dftLog)

    //  Format is:
    //      <Date><DelimiterString><Time><DelimiterString>
    //
    // We need to generate the date format again, only if it changes
    //

    pchDateTime = pdft->m_rgchDateTime;
    if ( !SameDate( &pdft->m_stDateTime, pst) ) {

        ::GetDateFormatA(LOCALE_SYSTEM_DEFAULT,
                                     LOCALE_NOUSEROVERRIDE,
                                     pst, NULL,
                                     pchDateTime,
                                     15);

        strcat( pchDateTime, G_PSZ_LOG_DELIMITER);

        //
        // cache the date length for future use.
        //

        pdft->m_cchDateLen = strlen( pchDateTime);

    }

    cchLen = pdft->m_cchDateLen;

    //
    // format the time portion
    //

    ::GetTimeFormatA( LOCALE_SYSTEM_DEFAULT,
                                 (LOCALE_NOUSEROVERRIDE |
                                  TIME_FORCE24HOURFORMAT|
                                  TIME_NOTIMEMARKER),
                                 pst, NULL,
                                 rgchTime, 15);

    DBG_ASSERT(strlen(rgchTime) + strlen( G_PSZ_LOG_DELIMITER) <
               sizeof(rgchTime));
    strcat( rgchTime, G_PSZ_LOG_DELIMITER);

    //
    // append time to date generated
    //

    DBG_ASSERT( cchLen > 0); // range is fine
    strcpy(pchDateTime + cchLen, rgchTime);

    DBG_ASSERT( strlen( pchDateTime) < sizeof( pdft->m_rgchDateTime));

    //
    // Calculate the offset for seconds based on time format.
    // the time is usually formatted as hh:mm:ss if wHour >= 10  Offset =6
    //       and is formatted as         h:mm:ss if wHour < 10   Offset =5
    //

    pdft->m_cchOffsetSeconds = ( cchLen + 5 + ((pst->wHour < 10) ? 0 : 1));

    //
    // !!! for the german locale, it's always hh:mm:ss
    //

    if ( pdft->m_rgchDateTime[pdft->m_cchOffsetSeconds] == ':' ) {
        pdft->m_cchOffsetSeconds++;
    }

    pdft->m_cbDateTime = strlen( pdft->m_rgchDateTime) + 1;
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // ASCLOG_DATETIME_CACHE::GenerateDateTimeString


VOID
EXTLOG_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

    Used for W3C Extended Logging format.
     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    PCHAR pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );

    //
    //  Format is:
    //      Date    YYYY-MM-DD
    //      Time    HH:MM:SS
    //

    pchDateTime = pdft->m_rgchDateTime;
    if ( !SameDate( &pdft->m_stDateTime, pst) ) {

        AppendYear( pchDateTime, pst->wYear );
        *pchDateTime++ = '-';
        AppendTwoDigits( pchDateTime, pst->wMonth );
        *pchDateTime++ = '-';
        AppendTwoDigits( pchDateTime, pst->wDay );

        //
        // cache the date length for future use.
        //

        pchDateTime++;
        pdft->m_cchDateLen = strlen( pdft->m_rgchDateTime );
        DBG_ASSERT( pdft->m_cchDateLen == 10 );

    } else {

        DBG_ASSERT( pdft->m_cchDateLen == 10 );
        pchDateTime += (pdft->m_cchDateLen+1);
    }

    cchLen = pdft->m_cchDateLen;

    //
    // format the time portion
    //

    AppendTwoDigits( pchDateTime, pst->wHour );
    *pchDateTime++ = ':';
    AppendTwoDigits( pchDateTime, pst->wMinute );
    *pchDateTime++ = ':';
    AppendTwoDigits( pchDateTime, pst->wSecond );
    pchDateTime++;

    //
    // Calculate the offset for seconds based on time format.
    // YYYY-MM-DD HH:MM:SS
    //

    pdft->m_cchOffsetSeconds = cchLen + 7;
    pdft->m_cbDateTime = DIFF(pchDateTime - (PCHAR)pdft->m_rgchDateTime);
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // EXTLOG_DATETIME_CACHE::GenerateDateTimeString



VOID
W3_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    CHAR  rgchTime[25];
    PCHAR pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );

    //
    // Format date for Logging (dftGmt)
    //  Format is:
    //   Date: <date-time> GMT\r\n
    //

    pchDateTime = pdft->m_rgchDateTime;

    static const char szDate[] = "Date: ";
    static const char szCRLF[] = "\r\n";

    CopyMemory( pchDateTime, szDate, sizeof(szDate) - 1 );
    pchDateTime += sizeof(szDate) - 1;

    if ( !::SystemTimeToGMT( *pst,
                       pchDateTime,
                       sizeof(pdft->m_rgchDateTime)
                         - sizeof( szDate) - sizeof(szCRLF) + 1 ) )
    {
        pdft->m_rgchDateTime[0] = '\0';
    } else {

        pchDateTime += strlen( pchDateTime );

        pdft->m_cchOffsetSeconds =
                DIFF(pchDateTime - pdft->m_rgchDateTime)
                - 2         // minus 2 digits for seconds
                - 4;        // minus " GMT"

        pdft->m_cchDateLen = pdft->m_cchOffsetSeconds 
                - 7;        // minus " hh:mm:"

        CopyMemory( pchDateTime, szCRLF, sizeof(szCRLF) );
    }

    pdft->m_cbDateTime = ( strlen( pdft->m_rgchDateTime ) + 1);
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // W3_DATETIME_CACHE::GenerateDateTimeString




CACHED_DATETIME_FORMATS::CACHED_DATETIME_FORMATS( VOID )
    :
#if ENABLE_AUX_COUNTERS
    m_nMisses       ( 0),
    m_nAccesses     ( 0),
#endif // ENABLE_AUX_COUNTERS
    m_idftCurrent   ( 0)
{
    DATETIME_FORMAT_ENTRY dft;
    ZeroMemory( &dft, sizeof(dft));
    for (int i = 0;  i < CACHE_SIZE;  i++)
    {
        m_rgDateTimes[i].Write(dft);
    }
}



DWORD
CACHED_DATETIME_FORMATS::GetFormattedDateTime(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime
    )
/*++
  This function obtains formatted string for date specified in *pst.

  It uses a cache to do lookup for the formatted date and time.

  If all entries fail, then it calls the Formatting functions to
    generate a new format.

  It has been experimentally determined that the cost of formatting is too
    high and hence we resort to caching and this comprehensive lookup function.

  Also this function is NOT a GENERAL PURPOSE DATE-FORMAT cacher.
   We cache with the ASSUMPTION that the date format requests will be for
   consecutive time intervals.

  Arguments:
    pst   - pointer to SYSTEMTIME
    pchDateTime - pointer to character buffer into which the formatted
                     date will be copied.

  Returns:
    Length of string (excluding the NULL terminator)

--*/
{
    DBG_ASSERT( pst != NULL && pchDateTime != NULL);

    CdtCountAccesses();
    
    CDFTCache* pdft;
    LONG i = m_idftCurrent + CACHE_SIZE; // modulo operation in loop
                                        //   => start at m_idftCurrent

    // m_rgDateTimes is a circular buffer of CDFTCaches.  The current entry
    // is pointed to by m_idftCurrent.  The second-most recent entry is at
    // (m_idftCurrent - 1) % CACHE_SIZE.  Etc.
    for (int j = CACHE_SIZE  ;  --j >= 0;  i--)
    {
        pdft = &m_rgDateTimes[i & CACHE_MASK];
        
        if (pdft->IsHit(pst)
            &&  pdft->CopyFormattedData(pst, pchDateTime))
        {
            return pdft->DateTimeChars() - 1;
        }
    }
    
    // Not found in cache?  Then generate the time string and add it
    DATETIME_FORMAT_ENTRY dft;
    dft.m_stDateTime.wYear = 0; // invalid date

    GenerateDateTimeString(&dft, pst);
    i = InterlockedIncrement(const_cast<LONG*>(&m_idftCurrent));
    pdft = &m_rgDateTimes[i & CACHE_MASK];
    pdft->Write(dft);

    CdtCountMisses();

    //
    // The date time format is valid. Copy formatted date time.  It is 
    // assumed that the buffer has sufficient space for the formatted date
    //

    dft.CopyFormattedData(pst, pchDateTime);
    return dft.m_cbDateTime - 1;
} // CACHED_DATETIME_FORMATS::GetFormattedDateTime()



DWORD
CACHED_DATETIME_FORMATS::GetFormattedCurrentDateTime(
    OUT PCHAR pchDateTime
    )
{
    DBG_ASSERT(pchDateTime != NULL);
    SYSTEMTIME st;
    IISGetCurrentTimeAsSystemTime(&st);
    return GetFormattedDateTime(&st, pchDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\chunkbuffer.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     headerbuffer.cxx

   Abstract:
     Maintains a list of response/request headers and takes care of all the
     buffering goo.  The goo here is keeping useful information in a buffer
     which can be realloced (and thus re-based) under us.
 
   Author:
     Bilal Alam (balam)             18-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "chunkbuffer.hxx"

HRESULT
CHUNK_BUFFER::AllocateSpace(
    DWORD               cbSize,
    CHAR * *            ppvBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    cbSize - Size needed
    ppvBuffer - Set to point to buffer on success
    
Return Value:

    HRESULT

--*/
{
    
    HRESULT         hr = NO_ERROR;
    BYTE *          pDest;
   
    if ( ppvBuffer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    //
    // Resize the buffer if needed
    //
    
    if ( _pBufferCurrent->_cbSize < cbSize + _pBufferCurrent->_cbOffset )
    {
        hr = AddNewBlock( cbSize );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Copy the actual string
    //

    pDest = ((BYTE*) (_pBufferCurrent->_pchBuffer)) + _pBufferCurrent->_cbOffset;

    _pBufferCurrent->_cbOffset += cbSize;

    *ppvBuffer = (CHAR *)pDest;
    
    return NO_ERROR;
    
}

HRESULT
CHUNK_BUFFER::AllocateSpace(
    DWORD               cbSize,
    WCHAR * *           ppvBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    cbSize - Size needed
    ppvBuffer - Set to point to buffer on success
    
Return Value:

    HRESULT

--*/
{
    //
    // Advance the current offset by 1 if it is not aligned to WCHAR
    //
    if (_pBufferCurrent->_cbOffset % sizeof(WCHAR))
    {
        _pBufferCurrent->_cbOffset++;
    }
   
    return AllocateSpace(cbSize, (CHAR **)ppvBuffer);
}

HRESULT
CHUNK_BUFFER::AllocateSpace(
    DWORD               cbSize,
    PVOID *             ppvBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    cbSize - Size needed
    ppvBuffer - Set to point to buffer on success
    
Return Value:

    HRESULT

--*/
{
    DWORD               cbOffBy;
    
    cbOffBy = _pBufferCurrent->_cbOffset % sizeof( ULONG_PTR );
    if ( cbOffBy )
    {
        _pBufferCurrent->_cbOffset += cbOffBy;
    }
    
    return AllocateSpace(cbSize, (CHAR **)ppvBuffer);
}

HRESULT
CHUNK_BUFFER::AllocateSpace(
    CHAR *              pszHeaderValue,
    DWORD               cchHeaderValue,
    CHAR * *            ppszBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    pszHeaderValue - String to duplicate into buffer
    cchHeaderValue - Character count of string
    ppszBuffer - Set to point to space allocated for string
    
Return Value:

    HRESULT

--*/
{
    DWORD           cbRequired;
    DWORD           cbNewBlock;
    BUFFER_LINK *   pBufferLink;
    HRESULT         hr = NO_ERROR;
    BYTE *          pDest;
   
    if ( pszHeaderValue == NULL ||
         ppszBuffer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Resize the buffer if needed
    //
    
    cbRequired = ( cchHeaderValue + 1 );
    if ( _pBufferCurrent->_cbSize < cbRequired + _pBufferCurrent->_cbOffset )
    {
        hr = AddNewBlock( cbRequired );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Copy the actual string
    //

    pDest = ((BYTE*) (_pBufferCurrent->_pchBuffer)) + _pBufferCurrent->_cbOffset;

    memcpy( pDest,
            pszHeaderValue,
            cchHeaderValue );
    ((CHAR *)pDest)[cchHeaderValue] = '\0';

    _pBufferCurrent->_cbOffset += cbRequired;

    *ppszBuffer = (CHAR *) pDest;
    
    return NO_ERROR;
}

HRESULT
CHUNK_BUFFER::AllocateSpace(
    LPWSTR              pszHeaderValue,
    DWORD               cchHeaderValue,
    LPWSTR *            ppszBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    pszHeaderValue - String to duplicate into buffer
    cchHeaderValue - Character count of string
    ppszBuffer - Set to point to space allocated for string
    
Return Value:

    HRESULT

--*/
{
    DWORD           cbRequired;
    DWORD           cbNewBlock;
    BUFFER_LINK *   pBufferLink;
    HRESULT         hr = NO_ERROR;
    BYTE *          pDest;
   
    if ( pszHeaderValue == NULL ||
         ppszBuffer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Advance the current offset by 1 if it is not aligned to WCHAR
    //
    if (_pBufferCurrent->_cbOffset % sizeof(WCHAR))
    {
        _pBufferCurrent->_cbOffset++;
    }
   
    //
    // Resize the buffer if needed
    //
    
    cbRequired = ( cchHeaderValue + 1 ) * sizeof( WCHAR );
    if ( _pBufferCurrent->_cbSize < cbRequired + _pBufferCurrent->_cbOffset )
    {
        cbNewBlock = max( cbRequired + sizeof(BUFFER_LINK), BUFFER_MIN_SIZE ); 

        pBufferLink = (BUFFER_LINK*) LocalAlloc( LPTR,
                                                 cbNewBlock );
        if ( pBufferLink == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        pBufferLink->_cbSize = cbNewBlock - sizeof( BUFFER_LINK );
        pBufferLink->_pNext = NULL;
        pBufferLink->_cbOffset = 0;
        
        //
        // Link up the buffer
        //
        
        _pBufferCurrent->_pNext = pBufferLink;
        _pBufferCurrent = pBufferLink;
    }
    
    //
    // Copy the actual string
    //

    pDest = ((BYTE*) (_pBufferCurrent->_pchBuffer)) + _pBufferCurrent->_cbOffset;

    memcpy( pDest,
            pszHeaderValue,
            cchHeaderValue * sizeof(WCHAR) );
    ((WCHAR *)pDest)[cchHeaderValue] = L'\0';

    _pBufferCurrent->_cbOffset += cbRequired;

    *ppszBuffer = (LPWSTR) pDest;
    
    return NO_ERROR;
}

HRESULT 
CHUNK_BUFFER::AddNewBlock( 
    DWORD cbSize 
    )
/*++

Routine Description:

    If there is currently not enough space in internal buffer
    get new block off the heap (of minimum cbSize) 

Arguments:

    cbSize - number of bytes requested by caller of AllocateSpace
    
Return Value:

    HRESULT

--*/    
{
    DWORD           cbNewBlock;
    BUFFER_LINK *   pBufferLink;
    
    cbNewBlock = max( cbSize + sizeof(BUFFER_LINK), BUFFER_MIN_SIZE ); 

    pBufferLink = (BUFFER_LINK*) LocalAlloc( LPTR,
                                             cbNewBlock );
    if ( pBufferLink == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    pBufferLink->_cbSize = cbNewBlock - sizeof( BUFFER_LINK );
    pBufferLink->_pNext = NULL;
    pBufferLink->_cbOffset = 0;

    _dwHeapAllocCount++;
    
    //
    // Link up the buffer
    //
    
    _pBufferCurrent->_pNext = pBufferLink;
    _pBufferCurrent = pBufferLink;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\dbgutil.h ===
/*++

   Copyright    (c)   1994-1998    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
// define DEBUG_FLAGS_VAR to assure that DebugFlags will stay private to
// iisutil. This is important in the case when iisutil is linked as static library
//
#define DEBUG_FLAGS_VAR g_dwDebugFlagsIISUtil

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

    
// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_ALLOC_CACHE          0x01000000
# define DEBUG_SCHED                0x02000000
# define DEBUG_RESOURCE             0x04000000
# define DEBUG_INET_MONITOR         0x08000000
# define DEBUG_PIPEDATA             0x10000000

// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\init_iisutil.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
#include <irtlmisc.h>
#include <issched.hxx>
#include "sched.hxx"
#include "lkrhash.h"
#include "_locks.h"
#include "tokenacl.hxx"
#include "datetime.hxx"
#include <normalize.hxx>


/************************************************************
 *     Global Variables
 ************************************************************/


DECLARE_DEBUG_VARIABLE();
DWORD  DEBUG_FLAGS_VAR = 0;

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\W3SVC"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisUtilRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IisUtil";

//
// Stuff to handle components which must initialized/terminated outside
// the loader lock
//

static INT                     s_cIISUtilInitRefs;
static CRITICAL_SECTION        s_csIISUtilInit;
extern CRITICAL_SECTION        g_SchedulerCritSec;

typedef enum
{
    IISUTIL_INIT_NONE = 0,
    IISUTIL_INIT_DEBUG_OBJECT,
    IISUTIL_INIT_LOCKS,
    IISUTIL_INIT_GCSINIT,
    IISUTIL_INIT_GCSSCHEDULER,
    IISUTIL_INIT_SECONDS_TIMER,
    IISUTIL_INIT_ALLOC_CACHE_HANDLER,
    IISUTIL_INIT_LKRHASH
} IISUTIL_INIT_STATUS;

static IISUTIL_INIT_STATUS     s_InitStatus = IISUTIL_INIT_NONE;


BOOL InitializeIISUtilProcessAttach(
    VOID
)
{
    BOOL fReturn = TRUE; 

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisUtilRegLocation, DEBUG_ERROR );

    IF_DEBUG(INIT_CLEAN) 
    {
        DBGPRINTF((DBG_CONTEXT, "InitializeIISUtilProcessAttach\n"));
    }

    if ( !Locks_Initialize() )
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    s_InitStatus = IISUTIL_INIT_LOCKS;
    
    if( !InitializeCriticalSectionAndSpinCount(&s_csIISUtilInit, 
                                               0x80000000 /* precreate event */) )
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    s_InitStatus = IISUTIL_INIT_GCSINIT;

#ifndef REMOVE_SCHED
    if( !InitializeCriticalSectionAndSpinCount(&g_SchedulerCritSec, 
                                               0x80000000 /* precreate event */) )
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    s_InitStatus = IISUTIL_INIT_GCSSCHEDULER;
#endif
    
    if( !InitializeSecondsTimer() )
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    s_InitStatus = IISUTIL_INIT_SECONDS_TIMER;
    
    if ( !ALLOC_CACHE_HANDLER::Initialize() )
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    s_InitStatus = IISUTIL_INIT_ALLOC_CACHE_HANDLER;
    
    if ( !LKRHashTableInit() )
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    s_InitStatus = IISUTIL_INIT_LKRHASH;

    return TRUE;
    
Cleanup:
    TerminateIISUtilProcessDetach();
    return fReturn;
}


VOID
TerminateIISUtilProcessDetach(
    VOID
)

{
    IF_DEBUG(INIT_CLEAN)
    {
        DBGPRINTF((DBG_CONTEXT,
                   "TerminateIISUtilProcessDetach\n"));
    }
        
    
    switch( s_InitStatus )
    {
    case IISUTIL_INIT_LKRHASH:
        LKRHashTableUninit();
        
    case IISUTIL_INIT_ALLOC_CACHE_HANDLER:
        ALLOC_CACHE_HANDLER::Cleanup();
    
    case IISUTIL_INIT_SECONDS_TIMER:
        TerminateSecondsTimer();

#ifndef REMOVE_SCHED        
    case IISUTIL_INIT_GCSSCHEDULER:
        DeleteCriticalSection( &g_SchedulerCritSec );
#endif        

    case IISUTIL_INIT_GCSINIT:
        DeleteCriticalSection( &s_csIISUtilInit );
    
    case IISUTIL_INIT_LOCKS:
        Locks_Cleanup();
        
    }    

} 

BOOL
WINAPI 
InitializeIISUtil(
    VOID
)
{
    BOOL fReturn = TRUE;  // ok
    HRESULT hr = NO_ERROR;

    EnterCriticalSection(&s_csIISUtilInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "InitializeIISUtil, %d %s\n",
                   s_cIISUtilInitRefs, (s_cIISUtilInitRefs == 0 ? "initializing" : "")));

    if (s_cIISUtilInitRefs++ == 0)
    {

#ifndef REMOVE_SCHED
       
        if (!SchedulerInitialize())
        {
            DBGPRINTF((DBG_CONTEXT, "Initializing Scheduler Failed\n"));
            fReturn = FALSE;
        }

        IF_DEBUG(INIT_CLEAN)
            DBGPRINTF((DBG_CONTEXT, "Scheduler Initialized\n"));

#endif
        if ( !ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval() )
        {
            fReturn = FALSE;
        }
        
        hr = InitializeTokenAcl();

        if ( FAILED( hr ) )
        {
            SetLastError( WIN32_FROM_HRESULT( hr ) );
            fReturn = FALSE;
        }

        InitializeDateTime();

        UlInitializeParsing();

        InitializeNormalizeUrl();
    }
    
    LeaveCriticalSection(&s_csIISUtilInit);

    return fReturn;
}



/////////////////////////////////////////////////////////////////////////////
// Additional termination needed

VOID
WINAPI 
TerminateIISUtil(
    VOID
)
{
    EnterCriticalSection(&s_csIISUtilInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "TerminateIISUtil, %d %s\n",
                   s_cIISUtilInitRefs, (s_cIISUtilInitRefs == 1 ? "Uninitializing" : "")));

    if (--s_cIISUtilInitRefs == 0)
    {
        DBG_REQUIRE(ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval());
#ifndef REMOVE_SCHED    
        SchedulerTerminate();
#endif    
        TerminateDateTime();

        UninitializeTokenAcl();

    }

    LeaveCriticalSection(&s_csIISUtilInit);

  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\etwtrace.cxx ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    etwtrace.cpp (ETW tracelogging)

Abstract:

    This module implements the Event Tracer for Windows (ETW)
    tracing capability.

Author:

    Melur Raghuraman (mraghu)       08-May-2001

Revision History:

--*/

//
//--> Include other headers from the project
//
#include "precomp.hxx"
#include <etwtrace.hxx>


//
// Default Event logged uses the standard EVENT_TRACE_HEADER
// followed by  a variable list of arguments
//

typedef struct _ETW_TRACE_EVENT {
    EVENT_TRACE_HEADER  Header;
    MOF_FIELD           MofField[MAX_MOF_FIELDS];
} ETW_TRACE_EVENT, *PETW_TRACE_EVENT;



CEtwTracer::CEtwTracer()
/*++

Routine Description:
    Class Constructor.
    Initializes the private members.
    Creates a mutex to synchronize enable/disable calls. 

Arguments:
    none

Return Value:

--*/
{
    m_fTraceEnabled = FALSE;
    m_fTraceSupported = TRUE;
    m_fTraceInitialized = FALSE;
    m_hTraceLogger     = ((TRACEHANDLE)INVALID_HANDLE_VALUE);
    m_hProviderReg     = ((TRACEHANDLE)INVALID_HANDLE_VALUE);
    m_ulEnableFlags    = 0;
    m_ulEnableLevel    = 0;
}

CEtwTracer::~CEtwTracer() 
/*++

Routine Description:
    Class Destructor. 

Arguments:
    none

Return Value:

--*/

{
}


ULONG CEtwTracer::Register(
    const GUID * ControlGuid,
    LPWSTR ImagePath,
    LPWSTR MofResourceName
    )
 
/*++

Routine Description:

    Registers with ETW tracing framework. 
    This function should not be called more than once, on 
    Dll Process attach only. 

Arguments:
    none

Return Value:
    Returns the return value from RegisterTraceGuids. 

--*/
{

    OSVERSIONINFO osVer;

    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (m_fTraceInitialized == TRUE) {
            return ERROR_SUCCESS;
    }

    m_fTraceSupported = FALSE;

    if (GetVersionEx(&osVer) == FALSE) {
        return ERROR_NOT_SUPPORTED;
    }
    else if ((osVer.dwPlatformId != VER_PLATFORM_WIN32_NT) || 
             (osVer.dwBuildNumber < ETW_TRACER_BUILD)) {
        return ERROR_NOT_SUPPORTED;
    }


    //Create the guid registration array
    TRACE_GUID_REGISTRATION TraceGuidReg[] =
    {
      { 
        (LPGUID) &IISEventGuid, 
        NULL 
      }
    };
    
    //Now register this process as a WMI trace provider.
    ULONG status;

    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(ImagePath);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, ImagePath);
    }

    status = RegisterTraceGuids(
        (WMIDPREQUEST)ControlCallback,  // Enable/disable function.
        this,                           // RequestContext parameter
        (LPGUID)ControlGuid,            // Provider GUID
        1,                              // TraceGuidReg array size
        TraceGuidReg,                   // Array of TraceGuidReg structures
        FileName,                       // Optional WMI - MOFImagePath
        MofResourceName,                // Optional WMI - MOFResourceName
        &m_hProviderReg);               // Handle required to unregister.
    m_fTraceInitialized = TRUE;
    m_fTraceSupported = TRUE;
    return status;
}

ULONG CEtwTracer::UnRegister() 
/*++

Routine Description:
        Unregisters the provider from ETW. This function
        should only be called once from DllMain Detach process.

Arguments:
    none

Return Value:
    Return value from UnregisterTraceGuids. 

--*/
{

    ULONG status;

    if (m_fTraceSupported == FALSE) {
        return ERROR_NOT_SUPPORTED;
    }
    status = UnregisterTraceGuids( m_hProviderReg );
    m_hProviderReg = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    m_fTraceInitialized = FALSE;
    return status;
}

ULONG CEtwTracer::CtrlCallback(
    WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize, 
    PVOID Buffer
    )
/*++

Routine Description:

    This function handles the ETW control callbak. 
    It enables or disables tracing. On enable, it also
    reads the flag and level that was passed in by the
    trace console / trace controller.  This routine is synchorized
    by a critical section so multiple enable/disable notifications
    are serialized. 

Arguments:
    none

Return Value:
    ERROR_SUCCESS on success.
    ERROR_INVALID_HANDLE if a bad handle is passed from ETW.
    ERROR_INVALID_PARAMETER if an invalid parameter is sent by ETW. 

--*/
{
    
    ULONG ret = ERROR_SUCCESS;
    LONG Level=0;

    switch(RequestCode) {
    
    case WMI_ENABLE_EVENTS:                  //Enable tracing!

        m_hTraceLogger = (TRACEHANDLE) GetTraceLoggerHandle( Buffer );
        
        //This should never happen...
        if (m_hTraceLogger == (TRACEHANDLE)INVALID_HANDLE_VALUE ) {
            m_fTraceEnabled = FALSE;
            ret = ERROR_INVALID_HANDLE;
            break;
        }

        //Get other trace related info
        Level = GetTraceEnableLevel(m_hTraceLogger);
        m_ulEnableFlags =  GetTraceEnableFlags(m_hTraceLogger);
        if (Level > ETWMAX_TRACE_LEVEL) {
            Level = ETWMAX_TRACE_LEVEL;
        }

        m_ulEnableLevel = 1 << Level;   

        m_fTraceEnabled = TRUE;         //Enable the trace events

        break;
    
    case WMI_DISABLE_EVENTS:            //Disable tracing
        m_fTraceEnabled = FALSE;
        m_ulEnableFlags = 0;
        m_ulEnableLevel = 0;
        
        m_hTraceLogger = (TRACEHANDLE)INVALID_HANDLE_VALUE;
        break;
    
    default:                            //This should never happen
        ret = ERROR_INVALID_PARAMETER;
    }

    return ret;
}

ULONG
CEtwTracer::EtwTraceEvent(
    IN LPCGUID pGuid,
    IN ULONG   EventType,
    ...
    )
/*++

Routine Description:

    This is the routine called to log a trace event with ETW.     


Arguments:
    pGuid     - Supplies a pointer to the Guid of the event
    EventType - Type of the event being logged.
    ...       - List of arguments to be logged with this event
                These are in pairs of
                    PVOID - ptr to argument
                    ULONG - size of argument
                and terminated by a pointer to NULL, length of zero pair

Return Value:
    Status - Completion status
--*/
{
    if (!m_fTraceInitialized || !m_fTraceSupported || !m_fTraceEnabled) {
        return ERROR_NOT_SUPPORTED;
    }
    else {
        ULONG status;
        ETW_TRACE_EVENT EtwEvent;

        ULONG i;
        va_list ArgList;
        PVOID source;
        SIZE_T len;

        RtlZeroMemory(& EtwEvent, sizeof(EVENT_TRACE_HEADER));

        va_start(ArgList, EventType);
        for (i = 0; i < MAX_MOF_FIELDS; i ++) {
            source = va_arg(ArgList, PVOID);
            if (source == NULL)
                break;
            len = va_arg(ArgList, SIZE_T);
            if (len == 0)
                break;
            EtwEvent.MofField[i].DataPtr = (ULONGLONG) source;
            EtwEvent.MofField[i].Length  = (ULONG) len;
        }
        va_end(ArgList);

        EtwEvent.Header.Flags = WNODE_FLAG_TRACED_GUID |
                               WNODE_FLAG_USE_MOF_PTR |
                               WNODE_FLAG_USE_GUID_PTR;

        EtwEvent.Header.Size = (USHORT) (sizeof(EVENT_TRACE_HEADER) + 
                                         (i * sizeof(MOF_FIELD)));
        EtwEvent.Header.Class.Type = (UCHAR) EventType;
        EtwEvent.Header.GuidPtr = (ULONGLONG)pGuid;

        status = TraceEvent(m_hTraceLogger, (PEVENT_TRACE_HEADER)&EtwEvent);

        return status;
    }
}

extern "C" {

ULONG WINAPI ControlCallback(
    WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize, 
    PVOID Buffer) 
/*++

Routine Description:

    ETW likes to have a standard C function for a control callback,
    so simply wrap a call to the global instance's CtrlCallback function. 

Arguments:
    none

Return Value:
    Return value from the CtrlCallback function. 

--*/
{

    CEtwTracer * Tracer = (CEtwTracer*) Context;

    return Tracer->CtrlCallback( RequestCode, Context, InOutBufferSize, Buffer);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\eventlog.cxx ===
/*++

   Copyright    (c)    1996-1997        Microsoft Corporation

   Module Name:
        eventlog.cxx

   Abstract:

        This module defines the generic class for logging events.


   Author:

        Murali R. Krishnan    (MuraliK)    28-Sept-1994

--*/

#include "precomp.hxx"

//
//  Include Headers
//

# include <dbgutil.h>
# include <eventlog.hxx>


EVENT_LOG::EVENT_LOG(
    IN LPCWSTR lpszSource
    )
/*++

   Description
     Constructor function for given event log object.
     Initializes event logging services.

   Arguments:

      lpszSource:    Source string for the Event.

   Note:

     This is intended to be executed once only.
     This is not to be used for creating multiple event
      log handles for same given source name.
     But can be used for creating EVENT_LOG objects for
      different source names.

--*/
:
    m_ErrorCode         (NO_ERROR)
{


    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Initializing Event Log for %S[%p]\n",
                    lpszSource, this ));
    }

    //
    //  Register as an event source.
    //

    m_hEventSource = RegisterEventSourceW( NULL, lpszSource);

    if ( m_hEventSource != NULL ) {

        //
        //  Success!
        //

        IF_DEBUG( ERROR) {
            DBGPRINTF( ( DBG_CONTEXT,
                         " Event Log for %S initialized (hEventSource=%p)\n",
                         lpszSource,
                         m_hEventSource));
        }
    } else {

        //
        // An Error in initializing the event log.
        //

        m_ErrorCode = GetLastError();
        DBGPRINTF( ( DBG_CONTEXT,
                     "Could not register event source (%S) ( Error %lu)\n",
                     lpszSource,
                     m_ErrorCode));
    }

    return;

} // EVENT_LOG::EVENT_LOG()



EVENT_LOG::~EVENT_LOG(
    VOID
    )
/*++

    Description:
        Destructor function for given EVENT_LOG object.
        Terminates event logging functions and closes
         event log handle

--*/
{

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "Terminating events logging[%p]\n",
                        this));
    }


    //
    // If there is a valid Events handle, deregister it
    //

    if ( m_hEventSource != NULL) {

        BOOL fSuccess;

        fSuccess = DeregisterEventSource( m_hEventSource);

        if ( !fSuccess) {

            //
            // An Error in DeRegistering
            //

            m_ErrorCode = GetLastError();

            IF_DEBUG( INIT_CLEAN) {

                DBGPRINTF( ( DBG_CONTEXT,
                             "Termination of EventLog[%p] failed."
                             " error %lu\n",
                             this,
                             m_ErrorCode));
            }
        }

        //
        //  Reset the handle's value. Just as a precaution
        //
        m_hEventSource = NULL;
    }


    IF_DEBUG( API_EXIT) {
        DBGPRINTF( ( DBG_CONTEXT, "Terminated events log[%p]\n",this));
    }

} /* EVENT_LOG::~EVENT_LOG() */



VOID
EVENT_LOG::LogEvent(
        IN DWORD  idMessage,
        IN WORD   nSubStrings,
        IN const WCHAR * rgpszSubStrings[],
        IN DWORD  errCode)
/*++

     Description:
        Log an event to the event logger

     Arguments:

       idMessage           Identifies the event message

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       rgpszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{

    WORD wType;                // Type of Event to be logged

    //
    //  Find type of message for the event log
    //

    IF_DEBUG( API_ENTRY)  {

        DWORD i;

        DBGPRINTF( ( DBG_CONTEXT,
                    "reporting event %08lX, Error Code = %lu\n",
                    idMessage,
                    errCode ));

        for( i = 0 ; i < nSubStrings ; i++ ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "    substring[%lu] = %S\n",
                       i,
                       rgpszSubStrings[i] ));
        }
    }

    if ( NT_INFORMATION( idMessage)) {

        wType = EVENTLOG_INFORMATION_TYPE;

    } else {

        if ( NT_WARNING( idMessage)) {

            wType = EVENTLOG_WARNING_TYPE;

        } else {

            wType = EVENTLOG_ERROR_TYPE;

            DBG_ASSERT(NT_ERROR( idMessage));
        }
    }

    //
    //  Log the event
    //

    EVENT_LOG::LogEventPrivate( idMessage,
                              wType,
                              nSubStrings,
                              rgpszSubStrings,
                              errCode);


    return;

} /* EVENT_LOG::LogEvent() */


//
//  Private functions.
//

VOID
EVENT_LOG::LogEventPrivate(
    IN DWORD   idMessage,
    IN WORD    wEventType,
    IN WORD    nSubStrings,
    IN const WCHAR  * apszSubStrings[],
    IN DWORD   errCode
    )
/*++

     Description:
        Log an event to the event logger.
        ( Private version, includes EventType)

     Arguments:

       idMessage           Identifies the event message

       wEventType          Specifies the severety of the event
                            (error, warning, or informational).

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       apszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{
    VOID  * pRawData  = NULL;
    DWORD   cbRawData = 0;
    BOOL    fReport;
    DWORD   dwErr;

    if ( m_hEventSource == NULL ) {

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Attempt to log with no event source\n"));
        }
        return;
    }

    ASSERT( (nSubStrings == 0) || (apszSubStrings != NULL));

    if( errCode != 0 ) {
        pRawData  = &errCode;
        cbRawData = sizeof(errCode);
    }

    m_ErrorCode  = NO_ERROR;
    dwErr = GetLastError();


    fReport = ReportEventW(
                       m_hEventSource,                   // hEventSource
                       wEventType,                       // fwEventType
                       0,                                // fwCategory
                       idMessage,                        // IDEvent
                       NULL,                             // pUserSid,
                       nSubStrings,                      // cStrings
                       cbRawData,                        // cbData
                       (LPCWSTR *) apszSubStrings,       // plpszStrings
                       pRawData );                       // lpvData

    if ( !fReport ) {

        IF_DEBUG( ERROR) {

            m_ErrorCode = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                        "Cannot report event for %p, error %lu\n",
                        this,
                        m_ErrorCode));
        }
    }
    else {
        SetLastError( dwErr );
    }

}  // EVENT_LOG::LogEventPrivate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\helpfunc.cxx ===
#include "precomp.hxx"
#include <limits.h>

DWORD
ReadRegDword(
   IN HKEY     hKey,
   IN LPCTSTR  pszRegistryPath,
   IN LPCTSTR  pszValueName,
   IN DWORD    dwDefaultValue 
   )
/*++

Routine Description:

    Reads a DWORD value from the registry

Arguments:
    
    hKey - a predefined registry handle value

    pszRegistryPath - the subkey to open

    pszValueName - The name of the value.

    dwDefaultValue - The default value to use if the
        value cannot be read.


Return Value:

    DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    LONG err;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;
    DWORD dwReturnValue = dwDefaultValue;

    err = RegOpenKeyEx( hKey,
                        pszRegistryPath,
                        0,
                        KEY_READ,
                        &hKey
                        );
    if (ERROR_SUCCESS == err)
    {
        err = RegQueryValueEx( hKey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer 
                               );

        if( ( ERROR_SUCCESS == err ) && ( REG_DWORD == dwType ) ) 
        {
            dwReturnValue = dwBuffer;
        }
        RegCloseKey(hKey);
    }

    return dwReturnValue;
}

int
SAFEIsSpace(UCHAR c)
{
    // don't call if parameter is outside of 0->127 inclusive
    if (c >= 0 && c <= SCHAR_MAX)
    {
        return isspace(c);
    }
    
    return 0;
}

int
SAFEIsXDigit(UCHAR c)
{
    // don't call if parameter is outside of 0->127 inclusive
    if (c >= 0 && c <= SCHAR_MAX)
    {
        return isxdigit(c);
    }
    
    return 0;
}




//
// turn on Low Fragmentation Heap for all of the current process heaps
//
VOID
MakeAllProcessHeapsLFH()
{
    HANDLE hHeaps[1024];
    DWORD dwRet = GetProcessHeaps(1024, hHeaps);

    for (DWORD i = 0; i < dwRet; i++)
    {
        HANDLE hHeap = hHeaps[i];

        DBG_ASSERT(NULL != hHeap);

        //
        // this is the magic make this heap LFH value
        //
        ULONG Value = 2;
        HeapSetInformation( hHeap,
                            HeapCompatibilityInformation,
                            &Value,
                            sizeof(Value));
    }
    
    return;
}


/***************************************************************************++

Routine Description:

    Read a DWORD value from any service.

Arguments:

    Path - The path to the key we are reading.

    RegistryValueName - The value to read.

    DefaultValue - The default value to return if the registry value is 
    not present or cannot be read.

Return Value:

    DWORD - The parameter value.

--***************************************************************************/

DWORD
ReadDwordParameterValueFromAnyService(
    IN LPCWSTR Path,
    IN LPCWSTR RegistryValueName,
    IN DWORD DefaultValue
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HKEY KeyHandle = NULL;
    DWORD DataType = 0;
    DWORD Buffer = 0;
    DWORD DataLength = sizeof( Buffer );
    DWORD Result = DefaultValue;


    DBG_ASSERT( RegistryValueName != NULL );
    DBG_ASSERT( Path );

    Win32Error = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,             // base key
                        Path,                           // path
                        0,                              // reserved
                        KEY_READ,                       // access
                        &KeyHandle                      // returned key handle
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Opening registry key failed\n"
            ));

        goto exit;
    }


    //
    // Try to read the value; it may not be present.
    //

    Win32Error = RegQueryValueEx(
                        KeyHandle,                      // key handle
                        RegistryValueName,              // value name
                        NULL,                           // reserved
                        &DataType,                      // output datatype
                        ( LPBYTE ) &Buffer,             // data buffer
                        &DataLength                     // buffer/data length
                        );

    if ( Win32Error != NO_ERROR )
    {

        hr = HRESULT_FROM_WIN32( Win32Error );

        if ( hr  != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Reading registry value failed\n"
                ));
        }

        goto exit;
    }


    if ( DataType == REG_DWORD )
    {

        //
        // Return the value read.
        //

        Result = Buffer;

    }

exit:

    if ( KeyHandle != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
        KeyHandle = NULL;
    }


    return Result;

}   // ReadDwordValueFromRegistry


/***************************************************************************++

Routine Description:

    Set a string value from any service.

Arguments:

    Path - The path to the key we are reading.

    RegistryValueName - The entry to set.

    pNewValue - The value to write into the registry.

Return Value:

    DWORD - win 32 error code

--***************************************************************************/

DWORD
SetStringParameterValueInAnyService(
    IN LPCWSTR Path,
    IN LPCWSTR RegistryValueName,
    IN LPCWSTR pNewValue
    )
{

    DWORD Win32Error = NO_ERROR;
    HKEY  KeyHandle = NULL;

    DBG_ASSERT( RegistryValueName != NULL );
    DBG_ASSERT( Path );
    DBG_ASSERT( pNewValue );

    Win32Error = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,             // base key
                        Path,                           // path
                        0,                              // reserved
                        KEY_WRITE,                      // access
                        &KeyHandle                      // returned key handle
                        );

    if ( Win32Error != NO_ERROR )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(Win32Error),
            "Openning registry key for write failed\n"
            ));

        goto exit;
    }


    //
    // Try to read the value; it may not be present.
    //

    Win32Error = RegSetValueExW(
                        KeyHandle,                         // key handle
                        RegistryValueName,                 // value name
                        NULL,                              // reserved
                        REG_SZ,                            // output datatype
                        ( LPBYTE ) pNewValue,              // data buffer
                        (((DWORD) wcslen(pNewValue)) + 1 ) * sizeof(WCHAR)  // buffer/data length
                        );
    if ( Win32Error != NO_ERROR )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(Win32Error),
            "Failed writing string value\n"
            ));

        goto exit;
    }


exit:

    if ( KeyHandle != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
        KeyHandle = NULL;
    }

    return Win32Error;

}   // SetStringParameterValueInAnyService

/***************************************************************************++

Routine Description:

    Set a string value from any service.

Arguments:

    Path - The path to the key we are reading.

    RegistryValueName - The entry to set.

    pValue - The value to write into the registry.

    cbSizeOfValue - The number of bytes in pValue.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
ReadStringParameterValueFromAnyService(
    IN LPCWSTR Path,
    IN LPCWSTR RegistryValueName,
    IN LPCWSTR pValue,
    IN DWORD*  pcbSizeOfValue
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HKEY  KeyHandle = NULL;
    DWORD DataType = 0;

    DBG_ASSERT( RegistryValueName != NULL );
    DBG_ASSERT( Path );
    DBG_ASSERT( pcbSizeOfValue );
    DBG_ASSERT( pValue || *pcbSizeOfValue == 0 );

    Win32Error = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,             // base key
                        Path,                           // path
                        0,                              // reserved
                        KEY_READ,                       // access
                        &KeyHandle                      // returned key handle
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32(Win32Error);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to open registry key \n"
            ));

        goto exit;
    }

    //
    // Try to read the value; it may not be present.
    //

    Win32Error = RegQueryValueEx(
                        KeyHandle,                      // key handle
                        RegistryValueName,              // value name
                        NULL,                           // reserved
                        &DataType,                      // output datatype
                        ( LPBYTE ) pValue,              // data buffer
                        pcbSizeOfValue                  // buffer/data length
                        );
    if ( Win32Error != NO_ERROR )
    {

        hr = HRESULT_FROM_WIN32(Win32Error);

        if ( Win32Error != ERROR_MORE_DATA )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Inetinfo: Failed reading registry value \n"
                ));
        }

        goto exit;
    }

    if ( DataType != REG_SZ )
    {
        hr = E_UNEXPECTED;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Key was not of string type \n"
            ));

        goto exit;
    }

exit:

    if ( KeyHandle != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
        KeyHandle = NULL;
    }

    return hr;

}   // ReadStringValueFromRegistry

BOOL
IsSSLReportingBackwardCompatibilityMode()
{
    if ( ReadDwordParameterValueFromAnyService( 
                REGISTRY_KEY_HTTPFILTER_PARAMETERS_W,
                REGISTRY_VALUE_CURRENT_MODE, 
                0 ) == 0 )
    {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff (moved to locks.cxx)
--*/

#include "precomp.hxx"

#define IMPLEMENTATION_EXPORT


typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }

    //
    // see if this is winnt
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetVersionEx failed with %d\n",
                    GetLastError() ));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibraryA("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtInvalid;
    }

    g_PlatformType = pt;
    return(pt);

} // IISGetPlatformType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\irtldbg.cpp ===
// Implementation of debug support functions

#include "precomp.hxx"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>

#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>


IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vsntprintf(tszBuff, sizeof(tszBuff) / sizeof(TCHAR), ptszFormat, args);
    // _vsntprintf doesn't always NUL-terminate the buffer
    tszBuff[RTL_NUMBER_OF(tszBuff)-1] = TEXT('\0');
    va_end(args);

    DBGPRINTF(( DBG_CONTEXT, "%ls", tszBuff ));
}



#ifdef IRTLDEBUG

# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef IRTLDBG_RUNNING_AS_SERVICE

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    int nResult = FALSE;
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        // If using MFC's TRACE macro (AfxTrace), the report hook
        // (AspAssertHandler) will get called with _CRT_WARN.  Ignore.
        pszMessageTitle = "Warning";
        *pnReturn = 0;
        return FALSE;

    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;

    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(malloc(strlen(pszErrorText) + strlen(szInfo) + 1));

    if (NULL == pszMessageText)
        return FALSE;

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        nResult = TRUE;  // tell _CrtDbgReport to run
    }

    free(pszMessageText);
    
    return nResult;
}
#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000



void
IrtlDebugInit()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // If we end up in _CrtDbgReport, don't put up a message box
    // _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // IRTLDBG_RUNNING_AS_SERVICE

    
    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
IrtlDebugTerm()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000
}

#endif //IRTLDEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\lkrhash.cpp ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash

--*/

#include "precomp.hxx"


#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__


#ifdef LKRHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CLKRhashAllocator* LKRHASH_NS::CLASS::sm_palloc = NULL;            \

# define DECLARE_ALLOCATOR_LHTSUBCLASS(CLASS)            \
  CLKRhashAllocator* LKRHASH_NS::CLKRLinearHashTable::CLASS::sm_palloc = NULL; \


  DECLARE_ALLOCATOR(CLKRLinearHashTable);
  // DECLARE_ALLOCATOR(CLKRHashTable);
  DECLARE_ALLOCATOR(CNodeClump);
  DECLARE_ALLOCATOR(CSmallSegment);
  DECLARE_ALLOCATOR(CMediumSegment);
  DECLARE_ALLOCATOR(CLargeSegment);

#endif // LKRHASH_ALLOCATOR_NEW


static bool s_fInitialized = false;


// -------------------------------------------------------------------------
// Initialize per-class allocators
// -------------------------------------------------------------------------

bool
LKRHashTableInit()
{
    bool f = true;

    IRTLTRACE0("LKRHashTableInit\n");

#define INIT_ALLOCATOR(CLASS, N)                                \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLASS, N, f);                         \

#define INIT_ALLOCATOR_LHTSUBCLASS(CLASS, N)                    \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLKRLinearHashTable::CLASS, N, f);     \


    INIT_ALLOCATOR(CLKRLinearHashTable,        20);
    // INIT_ALLOCATOR(CLKRHashTable,               4);
    INIT_ALLOCATOR(CNodeClump,    200);
    INIT_ALLOCATOR(CSmallSegment,   5);
    INIT_ALLOCATOR(CMediumSegment,  5);
    INIT_ALLOCATOR(CLargeSegment,   5);

    s_fInitialized = f;

    return f;
} // LKRHashTableInit



// -------------------------------------------------------------------------
// Destroy per-class allocators
// -------------------------------------------------------------------------

void
LKRHashTableUninit()
{
#define UNINIT_ALLOCATOR(CLASS)                        \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLASS);                    \

#define UNINIT_ALLOCATOR_LHTSUBCLASS(CLASS)            \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLKRLinearHashTable::CLASS);\

    UNINIT_ALLOCATOR(CLKRLinearHashTable);
    // UNINIT_ALLOCATOR(CLKRHashTable);
    UNINIT_ALLOCATOR(CNodeClump);
    UNINIT_ALLOCATOR(CSmallSegment);
    UNINIT_ALLOCATOR(CMediumSegment);
    UNINIT_ALLOCATOR(CLargeSegment);

    s_fInitialized = false;

#ifdef IRTLDEBUG
    CLKRLinearHashTable::sm_llGlobalList.Lock();
    if (! CLKRLinearHashTable::sm_llGlobalList.IsEmpty())
    {
        IRTLTRACE0("CLKRLinearHashTable::sm_llGlobalList is not Empty\n");
        for (CListEntry* ple = CLKRLinearHashTable::sm_llGlobalList.First();
             ple != CLKRLinearHashTable::sm_llGlobalList.HeadNode();
             ple = ple->Flink)
        {
            CLKRLinearHashTable* plht
                = CONTAINING_RECORD(ple, CLKRLinearHashTable, m_leGlobalList);
            IRTLTRACE2("CLKRLinearHashTable %p, \"%hs\" not deleted\n",
                       plht, plht->m_szName);
        }
        IRTLASSERT(! "CLKRLinearHashTable::sm_llGlobalList is not Empty");
    }
    CLKRLinearHashTable::sm_llGlobalList.Unlock();
    
    CLKRHashTable::sm_llGlobalList.Lock();
    if (! CLKRHashTable::sm_llGlobalList.IsEmpty())
    {
        IRTLTRACE0("CLKRHashTable::sm_llGlobalList is not Empty\n");
        for (CListEntry* ple = CLKRHashTable::sm_llGlobalList.First();
             ple != CLKRHashTable::sm_llGlobalList.HeadNode();
             ple = ple->Flink)
        {
            CLKRHashTable* pht
                = CONTAINING_RECORD(ple, CLKRHashTable, m_leGlobalList);
            IRTLTRACE2("CLKRHashTable %p, \"%hs\" not deleted\n",
                       pht, pht->m_szName);
        }
        IRTLASSERT(! "CLKRHashTable::sm_llGlobalList is not Empty");
    }
    CLKRHashTable::sm_llGlobalList.Unlock();
#endif // IRTLDEBUG
    
    IRTLTRACE0("LKRHashTableUninit done\n");
} // LKRHashTableUninit



// See if countdown loops are faster than countup loops for traversing
// a CNodeClump
#ifdef LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = NODES_PER_CLUMP;  --x >= 0;  )
#else // !LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = 0;  x < NODES_PER_CLUMP;  ++x)
#endif // !LKR_COUNTDOWN


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets    = 0;

LONG CLKRLinearHashTable::sm_cTables              = 0;
#endif // LOCK_INSTRUMENTATION


#ifndef LKR_NO_GLOBAL_LIST
CLockedDoubleList CLKRLinearHashTable::sm_llGlobalList;
CLockedDoubleList CLKRHashTable::sm_llGlobalList;
#endif // LKR_NO_GLOBAL_LIST



// CLKRLinearHashTable --------------------------------------------------------
// Public Constructor for class CLKRLinearHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD         /*num_subtbls*/,  // for compatiblity with CLKRHashTable
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(static_cast<BYTE>(TableLock::LockType())),
      m_nBucketLockType(static_cast<BYTE>(BucketLock::LockType())),
      m_phtParent(NULL),    // directly created, no owning table
      m_fMultiKeys(fMultiKeys)
{
    STATIC_ASSERT(1 <= LK_DFLT_MAXLOAD  && LK_DFLT_MAXLOAD <= NODES_PER_CLUMP);
    STATIC_ASSERT(0 <= NODE_BEGIN  &&  NODE_BEGIN < NODES_PER_CLUMP);
    STATIC_ASSERT(!(0 <= NODE_END  &&  NODE_END < NODES_PER_CLUMP));

    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// CLKRLinearHashTable --------------------------------------------------------
// Private Constructor for class CLKRLinearHashTable, used by CLKRHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(static_cast<BYTE>(TableLock::LockType())),
      m_nBucketLockType(static_cast<BYTE>(BucketLock::LockType())),
      m_phtParent(phtParent),
      m_fMultiKeys(fMultiKeys)
{
    IRTLASSERT(m_phtParent != NULL);
    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// _Initialize -------------------------------------------------------------
// Do all the real work of constructing a CLKRLinearHashTable
// -------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Initialize(
    PFnExtractKey   pfnExtractKey,
    PFnCalcKeyHash  pfnCalcKeyHash,
    PFnEqualKeys    pfnEqualKeys,
    PFnAddRefRecord pfnAddRefRecord,
    LPCSTR          pszName,
    double          maxload,
    DWORD           initsize)
{
    m_dwSignature =     SIGNATURE;
    m_dwBktAddrMask0 =  0;
    m_dwBktAddrMask1 =  0;
    m_iExpansionIdx =   0;
    m_paDirSegs =       NULL;
    m_lkts =            LK_MEDIUM_TABLESIZE;
    m_dwSegBits =       0;
    m_dwSegSize =       0;
    m_dwSegMask =       0;
    m_lkrcState =       LK_UNUSABLE;
    m_MaxLoad =         LK_DFLT_MAXLOAD;
    m_nLevel =          0;
    m_cDirSegs =        0;
    m_cRecords =        0;
    m_cActiveBuckets =  0;
    m_wBucketLockSpins= LOCK_USE_DEFAULT_SPINS;
    m_pfnExtractKey =   pfnExtractKey;
    m_pfnCalcKeyHash =  pfnCalcKeyHash;
    m_pfnEqualKeys =    pfnEqualKeys;
    m_pfnAddRefRecord = pfnAddRefRecord;

    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(m_pfnExtractKey != NULL
               && m_pfnCalcKeyHash != NULL
               && m_pfnEqualKeys != NULL
               && m_pfnAddRefRecord != NULL);

    IRTLASSERT(s_fInitialized);

    if (!s_fInitialized)
        return (m_lkrcState = LK_NOT_INITIALIZED);

    if (m_pfnExtractKey == NULL
            || m_pfnCalcKeyHash == NULL
            || m_pfnEqualKeys == NULL
            || m_pfnAddRefRecord == NULL)
        return (m_lkrcState = LK_BAD_PARAMETERS);

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad = (maxload <= 1.0)  ?  LK_DFLT_MAXLOAD  :  maxload;
    m_MaxLoad = min(m_MaxLoad, 10 * NODES_PER_CLUMP);

    // Choose the size of the segments according to the desired "size" of
    // the table, small, medium, or large.
    LK_TABLESIZE lkts;

    if (initsize == LK_SMALL_TABLESIZE)
    {
        lkts = LK_SMALL_TABLESIZE;
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        lkts = LK_MEDIUM_TABLESIZE;
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        lkts = LK_LARGE_TABLESIZE;
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::INITSIZE  <= initsize <=  MAX_DIRSIZE * Large::INITSIZE
        initsize = min(max(initsize, CSmallSegment::INITSIZE),
                       (MAX_DIRSIZE >> CLargeSegment::SEGBITS)
                            * CLargeSegment::INITSIZE);

        // Guess a table size
        if (initsize <= 8 * CSmallSegment::INITSIZE)
            lkts = LK_SMALL_TABLESIZE;
        else if (initsize >= CLargeSegment::INITSIZE)
            lkts = LK_LARGE_TABLESIZE;
        else
            lkts = LK_MEDIUM_TABLESIZE;
    }

    return _SetSegVars(lkts, initsize);
} // CLKRLinearHashTable::_Initialize



// CLKRHashTable ----------------------------------------------------------
// Constructor for class CLKRHashTable.
// ---------------------------------------------------------------------

CLKRHashTable::CLKRHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Bound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD           num_subtbls,    // Number of subordinate hash tables.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_palhtDir(NULL),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_BAD_PARAMETERS)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    _InsertThisIntoGlobalList();

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL
               && pfnAddRefRecord != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL
            || pfnAddRefRecord == NULL)
        return;

    if (!s_fInitialized)
    {
        m_lkrcState = LK_NOT_INITIALIZED;
        return;
    }

    LK_TABLESIZE lkts = NumSubTables(initsize, num_subtbls);

#ifdef IRTLDEBUG
    int cBuckets = initsize;
    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = CLargeSegment::INITSIZE;

    IRTLTRACE(TEXT("CLKRHashTable: %s, %d subtables, initsize = %d, ")
              TEXT("total #buckets = %d\n"),
              ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
               (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
              num_subtbls, initsize, cBuckets * num_subtbls);
#else
    UNREFERENCED_PARAMETER(lkts);
#endif // IRTLDEBUG

    m_lkrcState = LK_ALLOC_FAIL;
    m_palhtDir  = _AllocateSubTableArray(num_subtbls);

    if (m_palhtDir == NULL)
        return;
    else
    {
        m_cSubTables = num_subtbls;
        for (DWORD i = 0;  i < m_cSubTables;  i++)
            m_palhtDir[i] = NULL;
    }

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i] = _AllocateSubTable(pszName, pfnExtractKey,
                                          pfnCalcKeyHash, pfnEqualKeys,
                                          pfnAddRefRecord, maxload,
                                          initsize, this, fMultiKeys);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                _FreeSubTable(m_palhtDir[j]);
            _FreeSubTableArray(m_palhtDir);
            m_cSubTables = 0;
            m_palhtDir   = NULL;

            return;
        }
    }

    m_nSubTableMask = m_cSubTables - 1;
    // power of 2?
    if ((m_nSubTableMask & m_cSubTables) != 0)
        m_nSubTableMask = -1;

    m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail
} // CLKRHashTable::CLKRHashTable



// ~CLKRLinearHashTable ------------------------------------------------------
// Destructor for class CLKRLinearHashTable
//-------------------------------------------------------------------------

CLKRLinearHashTable::~CLKRLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the table
    WriteLock();
    _Clear(false);
    WriteUnlock();

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRLinearHashTable::~CLKRLinearHashTable



// ~CLKRHashTable ------------------------------------------------------------
// Destructor for class CLKRHashTable
//-------------------------------------------------------------------------
CLKRHashTable::~CLKRHashTable()
{
    // Must delete the subtables in forward order (unlike
    // delete[], which starts at the end and moves backwards) to
    // prevent possibility of deadlock by acquiring the subtable
    // locks in a different order from the rest of the code.
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
        _FreeSubTable(m_palhtDir[i]);

    _FreeSubTableArray(m_palhtDir);

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRHashTable::~CLKRHashTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRLinearHashTable::NumSubTables(
    DWORD&, DWORD&)
{
    LK_TABLESIZE lkts = LK_MEDIUM_TABLESIZE;

    return lkts;
} // CLKRLinearHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        int nCPUs = NumProcessors();
        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = max(1, nCPUs);
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * nCPUs;
            break;
        }
    }

    rnum_subtbls = min(MAX_SUBTABLES, rnum_subtbls);

    return lkts;
} // CLKRHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindBucket
// Synopsis: Find a bucket, given its signature. The bucket is locked
//           before returning. Assumes table is already locked, to avoid
//           race conditions.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CBucket*
CLKRLinearHashTable::_FindBucket(
    DWORD dwSignature,
    bool  fLockForWrite) const
{
    IRTLASSERT(IsValid());
    IRTLASSERT(m_dwBktAddrMask0 > 0);
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT(2 < m_dwSegBits  &&  m_dwSegBits < 20
               &&  m_dwSegSize == (1U << m_dwSegBits)
               &&  m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(IsReadLocked()  ||  IsWriteLocked());
    
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    
    CBucket* const pbkt = _Bucket(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (fLockForWrite)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();
    
    return pbkt;
} // CLKRLinearHashTable::_FindBucket



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsNodeCompact
// Synopsis: validates that a node is correctly compacted
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsNodeCompact(
    CBucket* const pbkt) const
{
    CNodeClump* pncCurr;
    CNodeClump* pncPrev;
    bool fEmpty  = pbkt->m_ncFirst.InvalidSignature(NODE_BEGIN);
    int  cErrors = fEmpty ? !pbkt->m_ncFirst.IsLastClump() : 0;

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (fEmpty)
            {
                cErrors += (!pncCurr->InvalidSignature(i));
                cErrors += (!pncCurr->IsEmptyNode(i));
            }
            else if (pncCurr->InvalidSignature(i))
            {
                fEmpty = true;
                cErrors += (!pncCurr->IsEmptyNode(i));
                cErrors += (!pncCurr->IsLastClump());
            }
            else // still in non-empty portion
            {
                cErrors += (pncCurr->InvalidSignature(i));
                cErrors += (pncCurr->IsEmptyNode(i));
            }
        }
    }

    return cErrors;
} // CLKRLinearHashTable::_IsNodeCompact



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTable
// Synopsis:
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CLKRHashTable::SubTable*
CLKRHashTable::_SubTable(
    DWORD dwSignature) const
{
    IRTLASSERT(m_lkrcState == LK_SUCCESS
               &&  m_palhtDir != NULL  &&  m_cSubTables > 0);
    
    const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
    DWORD       index = dwSignature;
    
    index = (((index * PRIME + 12345) >> 16)
             | ((index * 69069 + 1) & 0xffff0000));
    
    if (m_nSubTableMask >= 0)
        index &= m_nSubTableMask;
    else
        index %= m_cSubTables;

    return m_palhtDir[index];
} // CLKRHashTable::_SubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTableIndex
// Synopsis:
//------------------------------------------------------------------------

int
CLKRHashTable::_SubTableIndex(
    CLKRHashTable::SubTable* pst) const
{
    int index = -1;
    
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        if (pst == m_palhtDir[i])
        {
            index = i;
            break;
        }
    }

    IRTLASSERT(index >= 0);

    return index;
} // CLKRHashTable::_SubTableIndex



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash table. If this causes the
//           average chain length to exceed the upper bound, the table is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the table, unless
//               fOverwrite==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash table not in usable state
//           LK_BAD_RECORD, if record is bad.
//
// TODO: honor m_fMultiKeys and allow multiple identical keys.
// This will require keeping all identical signatures contiguously
// within a bucket chain, and keeping all identical keys contigously
// within that set of contigous signatures. With a good hash function,
// there should not be identical signatures without also having
// identical keys. Also, need to modify _DeleteNode. This modification
// is needed for EqualRange and for hash_multiset and hash_multimap
// to work.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to table
    DWORD       dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult
#endif // LKR_STL_ITERATORS
    )
{
    IRTLASSERT(IsUsable()
               &&  pvRecord != NULL
               &&  dwSignature != HASH_INVALID_SIGNATURE);

    // find the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
#endif // LKR_STL_ITERATORS
    
    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE lkrc = LK_SUCCESS;
    CNodeClump* pncFree = NULL;
    int         iFreePos = NODE_BEGIN - NODE_STEP;
    CNodeClump* pncPrev = NULL;
    bool        fUpdate = false;
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    CNodeClump* pncCurr = &pbkt->m_ncFirst;

    // walk down the entire bucket chain, looking for matching hash
    // signatures and keys

    do
    {
        IRTLASSERT(pncCurr != NULL);

        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());

                pncFree  = pncCurr;
                iFreePos = i;
                goto insert;
            }

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  (pvRecord == pncCurr->m_pvNode[i]  ||
                    _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i]))))
            {
                if (fOverwrite)
                {
                    // If we allow overwrites, this is the slot to do it to
                    fUpdate  = true;
                    pncFree  = pncCurr;
                    iFreePos = i;
                    goto insert;
                }
                else
                {
                    // overwrites forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }
        }

        pncPrev = pncCurr;
        pncCurr = pncCurr->m_pncNext;

    } while (pncCurr != NULL);

  insert:
    if (pncFree != NULL)
    {
        pncCurr = pncFree;
        IRTLASSERT(0 <= iFreePos  &&  iFreePos < NODES_PER_CLUMP);
    }
    else
    {
        // No free slots.  Attach the new node to the end of the chain
        IRTLASSERT(iFreePos == NODE_BEGIN - NODE_STEP);
        pncCurr = _AllocateNodeClump();

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncPrev != NULL  &&  pncPrev->IsLastClump());
        pncPrev->m_pncNext = pncCurr;
        iFreePos = NODE_BEGIN;
    }

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, +1);

    if (fUpdate)
    {
        // We're overwriting an existing record.  Adjust the old record's
        // refcount downwards.  (Doing ++new, --old in this order ensures
        // that the refcount won't briefly go to zero if new and old are
        // the same record.)
        IRTLASSERT(!pncCurr->IsEmptyAndInvalid(iFreePos));
        _AddRefRecord(pncCurr->m_pvNode[iFreePos], -1);
    }
    else
    {
        IRTLASSERT(pncCurr->IsEmptyAndInvalid(iFreePos));
        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));
    }

    pncCurr->m_dwKeySigs[iFreePos] = dwSignature;
    pncCurr->m_pvNode[iFreePos]    = pvRecord;

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
#ifdef LKR_STL_ITERATORS
        // Don't call _Expand() if we're putting the result into an
        // iterator, as _Expand() tends to invalidate any other
        // iterators that might be in use.
        if (piterResult != NULL)
        {
            piterResult->m_plht =         this;
            piterResult->m_pnc =          pncCurr;
            piterResult->m_dwBucketAddr = dwBktAddr;
            piterResult->m_iNode =        (short) iFreePos;

            // Add an extra reference on the record, as the one added by
            // _InsertRecord will be lost when the iterator's destructor
            // fires or its assignment operator is used
            piterResult->_AddRef(+1);
        }
        else
#endif // LKR_STL_ITERATORS
        {
            // If the average load factor has grown too high, we grow the
            // table one bucket at a time.
            while (m_cRecords > m_MaxLoad * m_cActiveBuckets)
            {
                // If _Expand returns an error code (viz. LK_ALLOC_FAIL), it
                // just means that there isn't enough spare memory to expand
                // the table by one bucket. This is likely to cause problems
                // elsewhere soon, but this hashtable has not been corrupted.
                // If the call to _AllocateNodeClump above failed, then we do
                // have a real error that must be propagated back to the caller
                // because we were unable to insert the element at all.
                if (_Expand() != LK_SUCCESS)
                    break;  // expansion failed
            }
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_InsertRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::InsertRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InsertRecord(
    const void* pvRecord,
    bool fOverwrite /*=false*/)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk = pst->_InsertRecord(pvRecord, hash_val, fOverwrite);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::InsertRecord



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           table (if it exists).
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    DWORD           dwSignature
    )
{
    IRTLASSERT(IsUsable());

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[i])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[i]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        unsigned nContractedRecords = m_cRecords; 

        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedRecords += nContractedRecords >> 4;

        // Always want to have at least m_dwSegSize buckets
        while (m_cActiveBuckets * m_MaxLoad > nContractedRecords
               && m_cActiveBuckets > m_dwSegSize)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteKey(
    const DWORD_PTR pnKey)
{
    if (!IsUsable())
        return m_lkrcState;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(pnKey);
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteKey(pnKey, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteKey



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash table (if it
//           exists).  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If _DeleteKey were called for
//           a record that doesn't exist in the table, it could delete some
//           completely unrelated record that happened to have the same key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the table.
//           LK_UNUSABLE, if hash table not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    DWORD       dwSignature
    )
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    UNREFERENCED_PARAMETER(pnKey);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);

                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        unsigned nContractedRecords = m_cRecords; 

        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedRecords += nContractedRecords >> 4;

        // Always want to have at least m_dwSegSize buckets
        while (m_cActiveBuckets * m_MaxLoad > nContractedRecords
               && m_cActiveBuckets > m_dwSegSize)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteRecord(
    const void* pvRecord)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteRecord(pvRecord, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//
// TODO: Is the rpncPrev parameter really necessary?
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_DeleteNode(
    CBucket*     pbkt,      // bucket chain containing node
    CNodeClump*& rpnc,      // actual node
    CNodeClump*& rpncPrev,  // predecessor of actual node, or NULL
    int&         riNode)    // index within node
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);
    IRTLASSERT(0 <= riNode  &&  riNode < NODES_PER_CLUMP);
    IRTLASSERT(!rpnc->IsEmptyAndInvalid(riNode));

#ifdef IRTLDEBUG
    // Check that the node clump really does belong to the bucket
    CNodeClump* pnc1 = &pbkt->m_ncFirst;

    while (pnc1 != NULL  &&  pnc1 != rpnc)
         pnc1 = pnc1->m_pncNext;

    IRTLASSERT(pnc1 == rpnc);
#endif // IRTLDEBUG

    // Release the reference to the record
    _AddRefRecord(rpnc->m_pvNode[riNode], -1);

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // TODO: honor m_fMultiKeys

    // Compact the nodeclump by moving the very last node back to the
    // newly freed slot
    CNodeClump* pnc2   = rpnc;
    int         iNode2 = riNode;

    // Find the last nodeclump in the chain
    while (!pnc2->IsLastClump())
    {
         pnc2 = pnc2->m_pncNext;
         iNode2 = NODE_BEGIN;
    }

    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP);
    IRTLASSERT(!pnc2->IsEmptyAndInvalid(iNode2));

    // Find the first empty slot in the nodeclump
    while (iNode2 != NODE_END  &&  !pnc2->IsEmptySlot(iNode2))
    {
        iNode2 += NODE_STEP;
    }

    // Back up to last non-empty slot
    iNode2 -= NODE_STEP;
    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP
               &&  !pnc2->IsEmptyAndInvalid(iNode2));
    IRTLASSERT(iNode2+NODE_STEP == NODE_END
               ||  pnc2->IsEmptyAndInvalid(iNode2+NODE_STEP));

#ifdef IRTLDEBUG
    // Check that all the remaining nodes are empty
    IRTLASSERT(pnc2->IsLastClump());
    for (int iNode3 = iNode2 + NODE_STEP;
         iNode3 != NODE_END;
         iNode3 += NODE_STEP)
    {
        IRTLASSERT(pnc2->IsEmptyAndInvalid(iNode3));
    }
#endif // IRTLDEBUG

    // Move the last node's data back to the current node
    rpnc->m_pvNode[riNode]    = pnc2->m_pvNode[iNode2];
    rpnc->m_dwKeySigs[riNode] = pnc2->m_dwKeySigs[iNode2];

    // Blank the old last node.
    // Correct even if (rpnc, riNode) == (pnc2, iNode2).
    pnc2->m_pvNode[iNode2]    = NULL;
    pnc2->m_dwKeySigs[iNode2] = HASH_INVALID_SIGNATURE;

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Back up riNode by one, so that the next iteration of the loop
    // calling _DeleteNode will end up pointing to the same spot.
    if (riNode != NODE_BEGIN)
    {
        riNode -= NODE_STEP;
    }
    else
    {
        // rewind rpnc and rpncPrev to previous node
        if (rpnc == &pbkt->m_ncFirst)
        {
            riNode = NODE_BEGIN - NODE_STEP;
        }
        else
        {
            riNode = NODE_END;
            rpnc = rpncPrev;
            if (rpnc == &pbkt->m_ncFirst)
            {
                rpncPrev = NULL;
            }
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

    // Is the last node clump now completely empty?  Delete, if possible
    if (iNode2 == NODE_BEGIN  &&  pnc2 != &pbkt->m_ncFirst)
    {
        // Find preceding nodeclump
        CNodeClump* pnc3 = &pbkt->m_ncFirst;
        while (pnc3->m_pncNext != pnc2)
        {
            pnc3 = pnc3->m_pncNext;
            IRTLASSERT(pnc3 != NULL);
        }

        pnc3->m_pncNext = NULL;
#ifdef IRTLDEBUG
        pnc2->m_pncNext = NULL; // or dtor will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pnc2);
    }

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));

    return true;
} // CLKRLinearHashTable::_DeleteNode



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKey(
    const DWORD_PTR  pnKey,  // Key value of the record, depends on key type
    DWORD        dwSignature,// hash signature
    const void** ppvRecord   // resultant record
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult
#endif // LKR_STL_ITERATORS
    ) const
{
    IRTLASSERT(IsUsable()  &&  ppvRecord != NULL);

    *ppvRecord = NULL;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;
    int iNode = NODE_BEGIN - NODE_STEP;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
#endif // LKR_STL_ITERATORS
    
    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        FOR_EACH_NODE(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(iNode));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[iNode])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[iNode]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                    *ppvRecord = pncCurr->m_pvNode[iNode];
                    lkrc = LK_SUCCESS;

                    // bump the reference count before handing the record
                    // back to the user.  The user should decrement the
                    // reference count when finished with this record.
                    _AddRefRecord(*ppvRecord, +1);
                    goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();

#ifdef LKR_STL_ITERATORS
    if (piterResult != NULL  &&  lkrc == LK_SUCCESS)
    {
        piterResult->m_plht =         const_cast<CLKRLinearHashTable*>(this);
        piterResult->m_pnc =          pncCurr;
        piterResult->m_dwBucketAddr = dwBktAddr;
        piterResult->m_iNode =        (short) iNode;
    }
#endif // LKR_STL_ITERATORS

    return lkrc;
} // CLKRLinearHashTable::_FindKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindKey(
    const DWORD_PTR pnKey,
    const void**    ppvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindKey(pnKey, hash_val, ppvRecord);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindKey



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the table
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the table
//           LK_UNUSABLE, if hash table not in usable state
// Note:     The record is *not* AddRef'd.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the table
    DWORD       dwSignature  // hash signature
    ) const
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    UNREFERENCED_PARAMETER(pnKey);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                lkrc = LK_SUCCESS;

                goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // CLKRLinearHashTable::_FindRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindRecord(
    const void* pvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindRecord(pvRecord, hash_val);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindRecord



#ifdef LKR_APPLY_IF

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    LK_PREDICATE lkp = LKP_PERFORM;
    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    DWORD dw = _Apply(pfnAction, pvState, lkl, lkp);
    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRLinearHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_Apply(pfnAction, pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();
    return dw;
} // CLKRLinearHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                          pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();
    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (IsValid())
        dw = _DeleteIf(pfnPredicate, pvState, lkp);
    WriteUnlock();

    return dw;
} // CLKRLinearHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    WriteUnlock();

    return dw;
} // CLKRHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    return _ApplyIf(_PredTrue, pfnAction, pvState, lkl, rlkp);
} // CLKRLinearHashTable::_Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !IsWriteLocked()  :  !IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (lkl == LKL_WRITELOCK)
                            pbkt->WriteUnlock();
                        else
                            pbkt->ReadUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            pbkt->ReadUnlock();
                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(! "Unknown LK_ACTION in ApplyIf");
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in ApplyIf");
                        break;
                    }
                }
            }
        }

      unlock:
        if (lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_DeleteIf(
    PFnRecordPred  pfnPredicate,
    void*          pvState,
    LK_PREDICATE& rlkp)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        pbkt->WriteUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            pbkt->WriteUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in DeleteIf");
                        break;
                    }
                }
            }
        }

      unlock:
        pbkt->WriteUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_DeleteIf

#endif // LKR_APPLY_IF



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKRLinearHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (!IsValid())
    {
        _ReadOrWriteUnlock(fReadLocked);
        return LK_UNUSABLE;
    }

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       retcode = 0;

    // Check every bucket
    for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
    {
        CBucket* const pbkt = _Bucket(i);

        IRTLASSERT(pbkt != NULL);
        retcode += !(pbkt != NULL);

        pbkt->ReadLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        // Walk the bucket chain
        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int j;

            FOR_EACH_NODE(j)
            {
                if (pncCurr->IsEmptySlot(j))
                {
                    IRTLASSERT(pncCurr->IsLastClump());
                    retcode += !(pncCurr->IsLastClump());

                    for (int k = j;  k != NODE_END;  k += NODE_STEP)
                    {
                        IRTLASSERT(pncCurr->IsEmptyNode(k));
                        retcode += !pncCurr->IsEmptyNode(k);
                        IRTLASSERT(pncCurr->InvalidSignature(k));
                        retcode += !pncCurr->InvalidSignature(k);
                    }
                    break;
                }

                if (!pncCurr->IsEmptySlot(j))
                {
                    ++cRecords;

                    const DWORD_PTR pnKey = _ExtractKey(pncCurr->m_pvNode[j]);

                    DWORD dwSignature = _CalcKeyHash(pnKey);
                    IRTLASSERT(dwSignature != HASH_INVALID_SIGNATURE);
                    retcode += !(dwSignature != HASH_INVALID_SIGNATURE);
                    IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[j]);
                    retcode += !(dwSignature == pncCurr->m_dwKeySigs[j]);

                    DWORD address = _BucketAddress(dwSignature);
                    IRTLASSERT(address == i);
                    retcode += !(address == i);

                    if (address != i || dwSignature != pncCurr->m_dwKeySigs[j])
                        cMisplaced++;
                }
                else // pncCurr->IsEmptySlot(j)
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(j));
                    retcode += !pncCurr->IsEmptyAndInvalid(j);
                }
            }
            if (pncPrev != NULL)
            {
                IRTLASSERT(pncPrev->m_pncNext == pncCurr);
                retcode += !(pncPrev->m_pncNext == pncCurr);
            }
        }
        pbkt->ReadUnlock();
    }

    if (cRecords != m_cRecords)
        ++retcode;

    IRTLASSERT(cRecords == m_cRecords);
    retcode += !(cRecords == m_cRecords);

    if (cMisplaced > 0)
        retcode = cMisplaced;

    IRTLASSERT(cMisplaced == 0);
    retcode += !(cMisplaced == 0);

    _ReadOrWriteUnlock(fReadLocked);

    return retcode;
} // CLKRLinearHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKRHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    int retcode = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        retcode += m_palhtDir[i]->CheckTable();

    return retcode;
} // CLKRHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    if (!IsUsable())
        return;

    IRTLASSERT(IsWriteLocked());

    // If we're Clear()ing the table AND the table has no records, we
    // can return immediately. The dtor, however, must clean up completely.
    if (fShrinkDirectory  &&  0 == m_cRecords)
        return;

#ifdef IRTLDEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // IRTLDEBUG

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             )
        {
            int i;

            FOR_EACH_NODE(i)
            {

                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(pncCurr->IsLastClump());
                    break;
                }
                else
                {
                    _AddRefRecord(pncCurr->m_pvNode[i], -1);
                    pncCurr->m_pvNode[i]    = NULL;
                    pncCurr->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                    m_cRecords--;

#ifdef IRTLDEBUG
                    ++cDeleted;
#endif // IRTLDEBUG
                }
            } // for (i ...

            pncPrev = pncCurr;
            pncCurr = pncCurr->m_pncNext;
            pncPrev->m_pncNext = NULL;

            if (pncPrev != &pbkt->m_ncFirst)
                _FreeNodeClump(pncPrev);
        } // for (pncCurr ...

        pbkt->WriteUnlock();
    } // for (iBkt ...

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all segments
    for (DWORD iSeg = 0;  iSeg < m_cActiveBuckets;  iSeg += m_dwSegSize)
    {
        _FreeSegment(_Segment(iSeg));
        _Segment(iSeg) = NULL;
    }

    _FreeSegmentDirectory();
    m_nLevel = m_cActiveBuckets = m_iExpansionIdx = 0;
    m_dwBktAddrMask0 = 1;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    // set directory of segments to minimum size
    if (fShrinkDirectory)
    {
        DWORD cInitialBuckets = 0;

        if (LK_SMALL_TABLESIZE == m_lkts)
            cInitialBuckets = CSmallSegment::INITSIZE;
        else if (LK_MEDIUM_TABLESIZE == m_lkts)
            cInitialBuckets = CMediumSegment::INITSIZE;
        else if (LK_LARGE_TABLESIZE == m_lkts)
            cInitialBuckets = CLargeSegment::INITSIZE;
        else
            IRTLASSERT(! "Unknown LK_TABLESIZE");

        _SetSegVars(m_lkts, cInitialBuckets);
    }
} // CLKRLinearHashTable::_Clear



//------------------------------------------------------------------------
// Function: CLKRHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRHashTable::Clear()
{
    WriteLock();
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->_Clear(true);
    WriteUnlock();
} // CLKRHashTable::Clear



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRLinearHashTable::GetStatistics() const
{
    CLKRHashTableStats stats;

    if (!IsUsable())
        return stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                              / (1ui64 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = NODES_PER_CLUMP;
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
        {
            int acc = 0;

            for (CNodeClump* pncCurr = &_Bucket(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                int j;

                FOR_EACH_NODE(j)
                {
                    if (!pncCurr->IsEmptySlot(j))
                    {
                        acc++;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _Bucket(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           ++;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                empty++;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx) /(1ui64 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                    low_sl  = static_cast<double>(low_count)
                        / (2.0 * m_iExpansionIdx);
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                    high_sl = static_cast<double>(high_count)
                        / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // CLKRLinearHashTable::GetStatistics



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRHashTable::GetStatistics() const
{
    CLKRHashTableStats hts;

    if (!IsUsable())
        return hts;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        CLKRHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // CLKRHashTable::GetStatistics



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts,
    DWORD        cInitialBuckets)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
      {
        m_lkts      = LK_SMALL_TABLESIZE;
        m_dwSegBits = CSmallSegment::SEGBITS;
        m_dwSegSize = CSmallSegment::SEGSIZE;
        m_dwSegMask = CSmallSegment::SEGMASK;
        STATIC_ASSERT(CSmallSegment::SEGSIZE == (1U<<CSmallSegment::SEGBITS));
        STATIC_ASSERT(CSmallSegment::SEGMASK == (CSmallSegment::SEGSIZE-1));
        break;
      }
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
      {
        m_lkts      = LK_MEDIUM_TABLESIZE;
        m_dwSegBits = CMediumSegment::SEGBITS;
        m_dwSegSize = CMediumSegment::SEGSIZE;
        m_dwSegMask = CMediumSegment::SEGMASK;
        STATIC_ASSERT(CMediumSegment::SEGSIZE ==(1U<<CMediumSegment::SEGBITS));
        STATIC_ASSERT(CMediumSegment::SEGMASK == (CMediumSegment::SEGSIZE-1));
        break;
      }
        
    case LK_LARGE_TABLESIZE:
      {
        m_lkts      = LK_LARGE_TABLESIZE;
        m_dwSegBits = CLargeSegment::SEGBITS;
        m_dwSegSize = CLargeSegment::SEGSIZE;
        m_dwSegMask = CLargeSegment::SEGMASK;
        STATIC_ASSERT(CLargeSegment::SEGSIZE == (1U<<CLargeSegment::SEGBITS));
        STATIC_ASSERT(CLargeSegment::SEGMASK == (CLargeSegment::SEGSIZE-1));
        break;
      }
    }

    m_dwBktAddrMask0 = m_dwSegMask;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    m_nLevel         = m_dwSegBits;
    m_cActiveBuckets = cInitialBuckets;

    IRTLASSERT(m_cActiveBuckets > 0);

    IRTLASSERT(m_nLevel == m_dwSegBits);
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));

    IRTLASSERT(m_dwSegBits > 0);
    IRTLASSERT(m_dwSegSize == (1U << m_dwSegBits));
    IRTLASSERT(m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(m_dwBktAddrMask0 == m_dwSegMask);

    // adjust m_dwBktAddrMask0 (== m_dwSegMask) to make it large
    // enough to distribute the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
    }

    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask0;

    // create and clear directory of segments
    DWORD cDirSegs = MIN_DIRSIZE;
    while (cDirSegs < (m_cActiveBuckets >> m_dwSegBits))
        cDirSegs <<= 1;

    cDirSegs = min(cDirSegs, MAX_DIRSIZE);
    IRTLASSERT((cDirSegs << m_dwSegBits) >= m_cActiveBuckets);

    m_lkrcState = LK_ALLOC_FAIL;
    m_paDirSegs = _AllocateSegmentDirectory(cDirSegs);

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = cDirSegs;
        IRTLASSERT(m_cDirSegs >= MIN_DIRSIZE
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = (m_cActiveBuckets + m_dwSegSize - 1) >> m_dwSegBits;
        IRTLASSERT(dwMaxSegs <= m_cDirSegs);

        IRTLTRACE(TEXT("InitSegDir: m_lkts = %d, m_cActiveBuckets = %lu, ")
                  TEXT("m_dwSegSize = %lu, bits = %lu\n")
                  TEXT("m_cDirSegs = %lu, dwMaxSegs = %lu, ")
                  TEXT("segment total size = %lu bytes\n"),
                  m_lkts, m_cActiveBuckets,
                  m_dwSegSize, m_dwSegBits,
                  m_cDirSegs, dwMaxSegs,
                  m_dwSegSize * sizeof(CBucket));

        m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail

        for (DWORD i = 0;  i < dwMaxSegs;  i++)
        {
            CSegment* pSeg = _AllocateSegment();
            if (pSeg != NULL)
                m_paDirSegs[i].m_pseg = pSeg;
            else
            {
                // problem: deallocate everything
                m_lkrcState = LK_ALLOC_FAIL;
                for (DWORD j = i;  j-- > 0;  )
                {
                    _FreeSegment(m_paDirSegs[j].m_pseg);
                    m_paDirSegs[j].m_pseg = NULL;
                }
                _FreeSegmentDirectory();
                break;
            }
        }
    }

    if (m_lkrcState != LK_SUCCESS)
    {
        m_paDirSegs = NULL;
        m_cDirSegs  = m_cActiveBuckets = m_iExpansionIdx = 0;

        // Propagate error back up to parent (if it exists). This ensures
        // that all of the parent's public methods will start failing.
        if (m_phtParent != NULL)
            m_phtParent->m_lkrcState = m_lkrcState;
    }

    return m_lkrcState;
} // CLKRLinearHashTable::_SetSegVars




#include <stdlib.h>

LONG g_cAllocDirEntry = 0;
LONG g_cAllocNodeClump = 0;
LONG g_cAllocSmallSegment = 0;
LONG g_cAllocMediumSegment = 0;
LONG g_cAllocLargeSegment = 0;

extern "C"
__declspec(dllexport)
bool
GetAllocCounters()
{
return true;
}

// #define LKR_RANDOM_MEMORY_FAILURES 1000  // 1..RAND_MAX (32767)

// Memory allocation wrappers to allow us to simulate allocation
// failures during testing

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

CDirEntry* const
CLKRLinearHashTable::_AllocateSegmentDirectory(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocDirEntry);

    CDirEntry* const paDirSegs = new CDirEntry [n];

#ifdef IRTLDEBUG
    for (size_t i = 0;  i < n;  ++i)
        IRTLASSERT(paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    return paDirSegs;
} // CLKRLinearHashTable::_AllocateSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegmentDirectory()
{
#ifdef IRTLDEBUG
    for (size_t i = 0;  i < m_cDirSegs;  ++i)
        IRTLASSERT(m_paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    delete [] m_paDirSegs;
    m_paDirSegs = NULL;
    m_cDirSegs = 0;
    return true;
} // CLKRLinearHashTable::_FreeSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateNodeClump
// Synopsis: 
//------------------------------------------------------------------------

CNodeClump* const
CLKRLinearHashTable::_AllocateNodeClump()
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocNodeClump);
    return new CNodeClump;
} // CLKRLinearHashTable::_AllocateNodeClump



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeNodeClump
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeNodeClump(
    CNodeClump* pnc)
{
    delete pnc;
    return true;
} // CLKRLinearHashTable::_FreeNodeClump



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegment
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

CSegment* const
CLKRLinearHashTable::_AllocateSegment(
    ) const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CSmallSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CMediumSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CLargeSegment, m_bktSlots2));

    CSegment* pseg = NULL;

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CSmallSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocSmallSegment);
        pseg = new CSmallSegment;
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CMediumSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocMediumSegment);
        pseg = new CMediumSegment;
        break;
        
    case LK_LARGE_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLargeSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocLargeSegment);
        pseg = new CLargeSegment;
        break;
    }

    IRTLASSERT(pseg != NULL);

    if (pseg != NULL  &&  BucketLock::PerLockSpin() == LOCK_INDIVIDUAL_SPIN)
    {
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }

    return pseg;
} // CLKRLinearHashTable::_AllocateSegment



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegment(
    CSegment* pseg) const
{
    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        delete static_cast<CSmallSegment*>(pseg);
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        delete static_cast<CMediumSegment*>(pseg);
        break;
        
    case LK_LARGE_TABLESIZE:
        delete static_cast<CLargeSegment*>(pseg);
        break;
    }

    return true;
} // CLKRLinearHashTable::_FreeSegment



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable** const
CLKRHashTable::_AllocateSubTableArray(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    return new SubTable* [n];
} // CLKRHashTable::_AllocateSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTableArray(
    CLKRHashTable::SubTable** palht)
{
    delete [] palht;
    return true;
} // CLKRHashTable::_FreeSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTable
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable* const
CLKRHashTable::_AllocateSubTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    return new SubTable(pszName, pfnExtractKey, pfnCalcKeyHash,
                        pfnEqualKeys,  pfnAddRefRecord,
                        maxload, initsize, phtParent, fMultiKeys);
} // CLKRHashTable::_AllocateSubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTable
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTable(
    CLKRHashTable::SubTable* plht)
{
    delete plht;
    return true;
} // CLKRHashTable::_FreeSubTable




//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Expand
// Synopsis: Expands the table by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed due to lack of memory.
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Expand()
{
    if (m_cActiveBuckets >= MAX_DIRSIZE * m_dwSegSize - 1)
        return LK_ALLOC_FAIL;  // table is not allowed to grow any more

    WriteLock();

    // double segment directory size if necessary
    if (m_cActiveBuckets >= m_cDirSegs * m_dwSegSize)
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);
        DWORD cDirSegsNew = (m_cDirSegs == 0) ? MIN_DIRSIZE : m_cDirSegs << 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  j++)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j].m_pseg = NULL;
            }

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
        else
        {
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
    }

    // locate the new bucket, creating a new segment if necessary
    ++m_cActiveBuckets;

    DWORD     dwOldBkt = m_iExpansionIdx;
    DWORD     dwNewBkt = (1 << m_nLevel) | dwOldBkt;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    IRTLASSERT(_Segment(dwOldBkt) != NULL);
    CSegment* psegNew  = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _AllocateSegment();
        if (psegNew == NULL)
        {
            --m_cActiveBuckets;
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
        _Segment(dwNewBkt) = psegNew;
    }

    // prepare to relocate records to the new bucket
    CBucket* pbktOld = _Bucket(dwOldBkt);
    CBucket* pbktNew = _Bucket(dwNewBkt);

    // get locks on the two buckets involved
    pbktOld->WriteLock();
    pbktNew->WriteLock();

    // Now work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _SplitRecordSet, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.

    CNodeClump* pncFreeList = NULL;
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // If the old bucket has more than one CNodeClump, there's a chance that
    // we'll need extra CNodeClumps in the new bucket too.  If it doesn't,
    // we definitely won't. One CNodeClump is enough to prime the freelist.
    if (!pbktOld->m_ncFirst.IsLastClump())
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            --m_cActiveBuckets;
        }
    }

    // adjust expansion pointer, level, and mask
    if (lkrc == LK_SUCCESS)
    {
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            // m_dwBktAddrMask0 = 00011..111
            IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
            IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
        }
    }

    DWORD iExpansionIdx = m_iExpansionIdx;  // save to avoid race conditions
    DWORD dwBktAddrMask = m_dwBktAddrMask0; // ditto

    // Release the table lock before doing the actual relocation
    WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        lkrc = _SplitRecordSet(&pbktOld->m_ncFirst, &pbktNew->m_ncFirst,
                               iExpansionIdx, dwBktAddrMask,
                               dwNewBkt, pncFreeList);
    }

    pbktNew->WriteUnlock();
    pbktOld->WriteUnlock();

    return lkrc;
} // CLKRLinearHashTable::_Expand



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SplitRecordSet
// Synopsis: Split records between the old and new buckets.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SplitRecordSet(
    CNodeClump* pncOldTarget,
    CNodeClump* pncNewTarget,
    DWORD       iExpansionIdx,
    DWORD       dwBktAddrMask,
    DWORD       dwNewBkt,
    CNodeClump* pncFreeList     // list of free nodes available for reuse
    )
{
    CNodeClump  ncFirst = *pncOldTarget;    // save head of old target chain
    CNodeClump* pncOldList = &ncFirst;
    CNodeClump* pncTmp;
    int         iOldSlot = NODE_BEGIN;
    int         iNewSlot = NODE_BEGIN;

    // clear target buckets
    pncOldTarget->Clear();
    pncNewTarget->Clear();

    // scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            // node already empty?
            if (pncOldList->IsEmptySlot(i))
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
                continue;
            }

            // calculate bucket address of this node
            DWORD dwBkt = _H0(pncOldList->m_dwKeySigs[i], dwBktAddrMask);
            if (dwBkt < iExpansionIdx)
                dwBkt = _H1(pncOldList->m_dwKeySigs[i], dwBktAddrMask);

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // node in new bucket chain full?
                if (iNewSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];
                iNewSlot += NODE_STEP;
            }

            // no, record stays in its current bucket chain
            else
            {
                // node in old bucket chain full?
                if (iOldSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    iOldSlot = NODE_BEGIN;
                }

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[i];
                iOldSlot += NODE_STEP;
            }

            // clear old slot
            pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            pncOldList->m_pvNode[i]    = NULL;
        }

        // keep walking down the original bucket chain
        pncTmp     = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

#ifdef IRTLDEBUG
    ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_SplitRecordSet



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Contract
// Synopsis: Contract the table by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Contract()
{
    WriteLock();

    IRTLASSERT(m_cActiveBuckets >= m_dwSegSize);

    // Always keep at least m_dwSegSize buckets in the table;
    // i.e., one segment's worth.
    if (m_cActiveBuckets <= m_dwSegSize)
    {
        WriteUnlock();
        return LK_ALLOC_FAIL;
    }

    // update the state variables (expansion ptr, level and mask)
    if (m_iExpansionIdx > 0)
        --m_iExpansionIdx;
    else
    {
        --m_nLevel;
        m_iExpansionIdx = (1 << m_nLevel) - 1;
        IRTLASSERT(m_nLevel > 0  &&  m_iExpansionIdx > 0);
        m_dwBktAddrMask0 >>= 1;
        IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
        m_dwBktAddrMask1 >>= 1;
        IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
        IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    }

    // The last bucket is the one that will be emptied
    CBucket* pbktLast = _Bucket(m_cActiveBuckets - 1);
    pbktLast->WriteLock();

    // Decrement after calculating pbktLast, or _Bucket() will assert.
    --m_cActiveBuckets;

    // Where the nodes from pbktLast will end up
    CBucket* pbktNew = _Bucket(m_iExpansionIdx);
    pbktNew->WriteLock();

    // Now we work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _MergeRecordSets, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.
    
    CNodeClump* pnc;
    int         c = 0;

    // First, count the number of items in the old bucket
    for (pnc = &pbktLast->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pnc->IsEmptySlot(i))
            {
                IRTLASSERT(!pnc->IsEmptyAndInvalid(i));
                c++;
            }
        }
    }

    // Then, subtract off the number of empty slots in the new bucket
    for (pnc = &pbktNew->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pnc->IsEmptySlot(i))
            {
                IRTLASSERT(pnc->IsEmptyAndInvalid(i));
                c--;
            }
        }
    }

    CNodeClump* pncFreeList = NULL;  // list of nodes available for reuse
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // Do we need to allocate CNodeClumps to accommodate the surplus items?
    if (c > 0)
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
            lkrc = LK_ALLOC_FAIL;
        else if (c > NODES_PER_CLUMP)
        {
            // In the worst case, we need a 2-element freelist for
            // _MergeRecordSets. Two CNodeClumps always suffice since the
            // freelist will be augmented by the CNodeClumps from the old
            // bucket as they are processed.
            pnc = _AllocateNodeClump();
            if (pnc == NULL)
            {
                _FreeNodeClump(pncFreeList);
                lkrc = LK_ALLOC_FAIL;
            }
            else
                pncFreeList->m_pncNext = pnc;
        }
    }

    // Abort if we couldn't allocate enough CNodeClumps
    if (lkrc != LK_SUCCESS)
    {
        // undo the changes to the state variables
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx  = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
        }
        ++m_cActiveBuckets;

        // Unlock the buckets and the table
        pbktLast->WriteUnlock();
        pbktNew->WriteUnlock();
        WriteUnlock();

        return lkrc;
    }

    // Copy the chain of records from pbktLast
    CNodeClump ncOldFirst = pbktLast->m_ncFirst;

    // destroy pbktLast
    pbktLast->m_ncFirst.Clear();
    pbktLast->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef IRTLDEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
        {
            CBucket* pbkt = &_Segment(m_cActiveBuckets)->Slot(i);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->m_ncFirst.IsLastClump());

            int j;

            FOR_EACH_NODE(j)
            {
                IRTLASSERT(pbkt->m_ncFirst.IsEmptyAndInvalid(j));
            }
        }
#endif // IRTLDEBUG
        _FreeSegment(_Segment(m_cActiveBuckets));
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= (m_cDirSegs * m_dwSegSize) >> 1
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        // Memory allocation failure here does not require us to abort; it
        // just means that the directory of segments is larger than we'd like.
        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < cDirSegsNew;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the table lock before doing the reorg
    WriteUnlock();

    lkrc = _MergeRecordSets(pbktNew, &ncOldFirst, pncFreeList);

    pbktNew->WriteUnlock();

#ifdef IRTLDEBUG
    ncOldFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return lkrc;
} // CLKRLinearHashTable::_Contract



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_MergeRecordSets
// Synopsis: Merge two record sets.  Copy the contents of pncOldList
//           into pbktNewTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_MergeRecordSets(
    CBucket*    pbktNewTarget,
    CNodeClump* pncOldList,
    CNodeClump* pncFreeList
    )
{
    IRTLASSERT(pbktNewTarget != NULL  &&  pncOldList != NULL);

    CNodeClump*   pncTmp = NULL;
    CNodeClump* const pncOldFirst = pncOldList;
    CNodeClump*   pncNewTarget = &pbktNewTarget->m_ncFirst;
    int           iNewSlot;

    // find the first nodeclump in the new target bucket with an empty slot
    while (!pncNewTarget->IsLastClump())
    {
        FOR_EACH_NODE(iNewSlot)
        {
            if (pncNewTarget->IsEmptySlot(iNewSlot))
                break;
        }

        if (iNewSlot == NODE_END)
            pncNewTarget = pncNewTarget->m_pncNext;
        else
            break;
    }

    IRTLASSERT(pncNewTarget != NULL);

    // find the first empty slot in pncNewTarget;
    // if none, iNewSlot == NODE_END
    FOR_EACH_NODE(iNewSlot)
    {
        if (pncNewTarget->IsEmptySlot(iNewSlot))
        {
            break;
        }
    }
    
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pncOldList->IsEmptySlot(i))
            {
                // any empty slots left in pncNewTarget?
                if (iNewSlot == NODE_END)
                {
                    // no, so walk down pncNewTarget until we find another
                    // empty slot
                    while (!pncNewTarget->IsLastClump())
                    {
                        pncNewTarget = pncNewTarget->m_pncNext;

                        FOR_EACH_NODE(iNewSlot)
                        {
                            if (pncNewTarget->IsEmptySlot(iNewSlot))
                                goto found_slot;
                        }
                    }

                    // Oops, reached the last nodeclump in pncNewTarget
                    // and it's full.  Get a new nodeclump off the free
                    // list, which is big enough to handle all needs.
                    IRTLASSERT(pncNewTarget != NULL);
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

              found_slot:
                // We have an empty slot in pncNewTarget
                IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < NODES_PER_CLUMP
                       &&  pncNewTarget != NULL
                       &&  pncNewTarget->IsEmptyAndInvalid(iNewSlot));

                // Let's copy the node from pncOldList
                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];

                // Clear old slot
                pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                pncOldList->m_pvNode[i]    = NULL;

                // find the next free slot in pncNewTarget
                while ((iNewSlot += NODE_STEP) != NODE_END)
                {
                    if (pncNewTarget->IsEmptySlot(iNewSlot))
                    {
                        break;
                    }
                }
            }
            else // iNewSlot != NODE_END
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
            }
        }

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // Append to the free list.  Don't put the first node of
        // pncOldList on the free list, as it's a stack variable.
        if (pncTmp != pncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

    return LK_SUCCESS;
} // CLKRLinearHashTable::_MergeRecordSets



#ifdef LKR_DEPRECATED_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);
    if (piter->m_lkl == LKL_WRITELOCK)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = NODE_BEGIN - NODE_STEP;

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
} // CLKRLinearHashTable::_InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
} // CLKRHashTable::InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode != NODE_BEGIN - NODE_STEP)
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, -1);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((piter->m_iNode += NODE_STEP) != NODE_END)
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
                if (pvRecord != NULL)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, +1);
                    return LK_SUCCESS;
                }
                else // pvRecord == NULL
                {
#ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(piter->m_pnc->IsLastClump());
                    for (int i = piter->m_iNode;
                         i != NODE_END;
                         i += NODE_STEP)
                    {
                        IRTLASSERT(piter->m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = NODE_BEGIN - NODE_STEP;
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _Bucket(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = NODE_BEGIN - NODE_STEP;
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
} // CLKRLinearHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    // Table is already locked
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
} // CLKRHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the table?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, -1);
        }
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
} // CLKRLinearHashTable::_CloseIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    LK_RETCODE lkrc = LK_SUCCESS;

    if (!IsValid())
        lkrc = LK_UNUSABLE;
    else
    {
        // Are we abandoning the iterator before we've reached the end?
        // If so, close the subtable iterator.
        if (piter->m_plht != NULL)
        {
            IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
            CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
            piter->m_plht->_CloseIterator(pBaseIter);
        }
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return lkrc;
} // CLKRHashTable::CloseIterator

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRLinearHashTable::Iterator
CLKRLinearHashTable::Begin()
{
    Iterator iter(this, &_Bucket(0)->m_ncFirst, 0, NODE_BEGIN - NODE_STEP);

    LKR_ITER_TRACE(_TEXT("  LKLH:Begin(it=%p, plht=%p)\n"), &iter, this);
    
    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRLinearHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable_Iterator::Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRLinearHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_plht != NULL);
    IRTLASSERT(m_dwBucketAddr < m_plht->m_cActiveBuckets);
    IRTLASSERT(m_pnc != NULL);
    IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == m_iNode));

    // Release the reference acquired in the previous call to _Increment
    if (fDecrementOldValue)
        _AddRef(-1);

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((m_iNode += NODE_STEP) != NODE_END)
            {
                const void* pvRecord = m_pnc->m_pvNode[m_iNode];

                if (pvRecord != NULL)
                {
                    IRTLASSERT(!m_pnc->InvalidSignature(m_iNode));

                    // Add a new reference
                    _AddRef(+1);

                    LKR_ITER_TRACE(_TEXT("  LKLH:++(this=%p, plht=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_plht, m_pnc,
                                   m_dwBucketAddr, m_iNode, pvRecord);

                    return true;
                }
                else // pvRecord == NULL
                {
#if 0 //// #ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(m_pnc->IsLastClump());

                    for (int i = m_iNode;  i != NODE_END;  i += NODE_STEP)
                    {
                        IRTLASSERT(m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            m_iNode = NODE_BEGIN - NODE_STEP;
            m_pnc = m_pnc->m_pncNext;

        } while (m_pnc != NULL);

        // Try the next bucket, if there is one
        if (++m_dwBucketAddr < m_plht->m_cActiveBuckets)
        {
            CBucket* pbkt = m_plht->_Bucket(m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            m_pnc = &pbkt->m_ncFirst;
        }

    } while (m_dwBucketAddr < m_plht->m_cActiveBuckets);

    // We have fallen off the end of the hashtable. Set iterator equal
    // to end(), the empty iterator.
    LKR_ITER_TRACE(_TEXT("  LKLH:End(this=%p, plht=%p)\n"), this, m_plht);

    m_plht = NULL;
    m_pnc = NULL;
    m_dwBucketAddr = 0;
    m_iNode = 0;

    //// IRTLASSERT(this->operator==(Iterator())); // == end()

    return false;
} // CLKRLinearHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Insert
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    bool fSuccess = (_InsertRecord(pvRecord,
                                  _CalcKeyHash(_ExtractKey(pvRecord)),
                                  fOverwrite,
                                  &riterResult)
                     == LK_SUCCESS);

    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fSuccess
               ?  _IsValidIterator(riterResult)
               :  riterResult == End());

    return fSuccess;
} // CLKRLinearHashTable::Insert()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_Erase(
    Iterator& riter,
    DWORD     dwSignature)
{
    CNodeClump* pncCurr, *pncPrev;
    CBucket* const pbkt = riter.m_plht->_Bucket(riter.m_dwBucketAddr);

    LKR_ITER_TRACE(_TEXT("  LKLH:_Erase:pre(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);

    pbkt->WriteLock();

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        if (pncCurr == riter.m_pnc)
            break;
    }
    IRTLASSERT(pncCurr != NULL);

    // Release the iterator's reference on the record
    const void* pvRecord = riter.m_pnc->m_pvNode[riter.m_iNode];
    IRTLASSERT(pvRecord != NULL);
    _AddRefRecord(pvRecord, -1);

    // _DeleteNode will leave iterator members pointing to the
    // preceding record
    int iNode = riter.m_iNode;
    IRTLVERIFY(_DeleteNode(pbkt, riter.m_pnc, pncPrev, iNode));

    if (iNode == NODE_END)
        LKR_ITER_TRACE(_TEXT("\t_Erase(BKT=%p, PNC=%p, PREV=%p, INODE=%d)\n"),
                       pbkt, riter.m_pnc, pncPrev, iNode);
                  
    riter.m_iNode = (short) ((iNode == NODE_END)  ? NODE_END-NODE_STEP : iNode);

    pbkt->WriteUnlock();

    // Don't contract the table. Likely to invalidate the iterator,
    // if iterator is being used in a loop

    return true;
} // CLKRLinearHashTable::_Erase()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:pre(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    bool fSuccess = _Erase(riter, dwSignature);
    bool fIncrement = false;
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL,
                   (fSuccess ? "true" : "false"));
    
    // _Erase left riter pointing to the preceding record.
    // Move to next record.
    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter == End());
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post++(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n  LKLH:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT("  LKLH:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    bool        fFound   = (_FindKey(pnKey, hash_val, &pvRecord, &riterResult)
                            == LK_SUCCESS);

    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());
    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);

    return fFound;
} // CLKRLinearHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT("  LKLH:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound ?  _IsValidIterator(riterFirst) :  riterFirst == End());

    IRTLASSERT(riterLast.m_iNode  != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRLinearHashTable::EqualRange



//------------------------------------------------------------------------
// Function: CLKRHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRHashTable::Iterator
CLKRHashTable::Begin()
{
    Iterator iter(this, -1);

    LKR_ITER_TRACE(_TEXT(" LKHT:Begin(it=%p, pht=%p)\n"), &iter, this);

    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_ist != -1);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRHashTable_Iterator::_Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_pht != NULL);
    IRTLASSERT(-1 <= m_ist
               &&  m_ist < static_cast<int>(m_pht->m_cSubTables));

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (m_subiter.m_plht == NULL)
        {
            while (++m_ist < static_cast<int>(m_pht->m_cSubTables))
            {
                LKR_ITER_TRACE(_TEXT(" LKHT:++IST=%d\n"), m_ist);
                m_subiter = m_pht->m_palhtDir[m_ist]->Begin();

                if (m_subiter.m_plht != NULL)
                {
                    LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                                   _TEXT("LHT=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_pht, m_ist,
                                   m_subiter.m_plht, m_subiter.m_pnc,
                                   m_subiter.m_dwBucketAddr, m_subiter.m_iNode,
                                   m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]
                                  );
                    return true;
                }
            }
            
            // There are no more subtables left.
            LKR_ITER_TRACE(_TEXT(" LKHT:End(this=%p, pht=%p)\n"), this, m_pht);

            m_pht = NULL;
            m_ist = 0;

            //// IRTLASSERT(this->operator==(Iterator())); // == end()
            
            return false;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        m_subiter._Increment(fDecrementOldValue);

        if (m_subiter.m_plht != NULL)
        {
            LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                           _TEXT("LHT=%p, NC=%p, BA=%u, IN=%d, Rec=%p)\n"),
                           this, m_pht, m_ist,
                           m_subiter.m_plht, m_subiter.m_pnc,
                           m_subiter.m_dwBucketAddr, m_subiter.m_iNode, 
                           m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]);
            return true;
        }
    }
} // CLKRHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRHashTable::Insert
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);

    bool f = (pst->_InsertRecord(pvRecord, hash_val, fOverwrite,
                                 &riterResult.m_subiter)
              == LK_SUCCESS);

    if (f)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(f  ?  _IsValidIterator(riterResult)  :  riterResult == End());

    return f;
} // CLKRHashTable::Insert



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD     dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    SubTable* const pst   = _SubTable(dwSignature);

    IRTLASSERT(pst == riter.m_subiter.m_plht);

    if (pst != riter.m_subiter.m_plht)
        return false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:pre(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    // _Erase left riter pointing to the preceding record. Move to
    // next record.
    bool fSuccess = pst->_Erase(riter.m_subiter, dwSignature);
    bool fIncrement = false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   ((riter.m_subiter.m_pnc && riter.m_subiter.m_iNode >= 0)
                        ? riter.Record() : NULL),
                   (fSuccess ? "true" : "false"));

    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_ist != -1);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter  == End());

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post++(iter=%p, pht=%p, ist=%d, ")
                   _TEXT("plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n LKHT:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    bool        fFound   = (pst->_FindKey(pnKey, hash_val, &pvRecord,
                                          &riterResult.m_subiter)
                            == LK_SUCCESS);
    if (fFound)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());

    return fFound;
} // CLKRHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_ist != -1);
    IRTLASSERT(fFound ? _IsValidIterator(riterFirst) : riterFirst == End());

    IRTLASSERT(riterLast.m_ist != -1);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRHashTable::EqualRange


#endif // LKR_STL_ITERATORS



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKRHashTable::WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->WriteLock();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::WriteLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKRHashTable::ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ReadLock();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ReadLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::WriteUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
        m_palhtDir[i]->WriteUnlock();
        IRTLASSERT(m_palhtDir[i]->IsWriteUnlocked());
    }
} // CLKRHashTable::WriteUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
        m_palhtDir[i]->ReadUnlock();
        IRTLASSERT(m_palhtDir[i]->IsReadUnlocked());
    }
} // CLKRHashTable::ReadUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteLocked
// Synopsis: Are all subtables write-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsWriteLocked();
    }
    return fLocked;
} // CLKRHashTable::IsWriteLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadLocked
// Synopsis: Are all subtables read-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsReadLocked();
    }
    return fLocked;
} // CLKRHashTable::IsReadLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteUnlocked
// Synopsis: Are all subtables write-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsWriteUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsWriteUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadUnlocked
// Synopsis: Are all subtables read-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsReadUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsReadUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertSharedToExclusive
// Synopsis: Convert the read lock to a write lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertSharedToExclusive() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertSharedToExclusive();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::ConvertSharedToExclusive



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertExclusiveToShared
// Synopsis: Convert the write lock to a read lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertExclusiveToShared() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertExclusiveToShared();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ConvertExclusiveToShared



//------------------------------------------------------------------------
// Function: CLKRHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        cSize += m_palhtDir[i]->Size();

    return cSize;
} // CLKRHashTable::Size



//------------------------------------------------------------------------
// Function: CLKRHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
} // CLKRHashTable::MaxSize



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  i++)
        f = f && m_palhtDir[i]->IsValid();

    if (!f)
        m_lkrcState = LK_UNUSABLE;

    return f;
} // CLKRHashTable::IsValid



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

    if (BucketLock::PerLockSpin() != LOCK_INDIVIDUAL_SPIN)
        return;
    
    for (DWORD i = 0;  i < m_cDirSegs;  i++)
    {
        CSegment* pseg = m_paDirSegs[i].m_pseg;

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_dwSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
} // CLKRLinearHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetBucketLockSpinCount() const
{
    return m_wBucketLockSpins;
} // CLKRLinearHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
} // CLKRHashTable::SetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetTableLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  (WORD) LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
} // CLKRHashTable::GetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
} // CLKRHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetBucketLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  (WORD) LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
} // CLKRHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::MultiKeys
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::MultiKeys() const
{
    return ((m_cSubTables == 0)
            ?  false
            :  m_palhtDir[0]->MultiKeys());
} // CLKRHashTable::MultiKeys



#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\logbuff.cxx ===
#include "precomp.hxx"

#include "stdio.h"

#include "logbuff.hxx"

//static
HRESULT
W3_TRACE_LOG_FACTORY::CreateTraceLogFactory(W3_TRACE_LOG_FACTORY ** ppLogFactory, HANDLE hFile)
{
    DBG_ASSERT(ppLogFactory);
    DBG_ASSERT(hFile);
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    W3_TRACE_LOG_FACTORY * pLogFactory = NULL;
    
    *ppLogFactory = NULL;

    pLogFactory = new W3_TRACE_LOG_FACTORY;
    if (NULL == pLogFactory)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    
    fRet = InitializeCriticalSectionAndSpinCount( 
                                &pLogFactory->m_cs,
                                0x80000000 /* precreate event */ | 
                                IIS_DEFAULT_CS_SPIN_COUNT );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }
    pLogFactory->m_fInitCs = TRUE;  
    
    pLogFactory->m_hFile = hFile;
    pLogFactory->m_ulBufferSizeInBytes = 0;
    pLogFactory->m_hTimer = NULL;
    
    fRet = CreateTimerQueueTimer(&pLogFactory->m_hTimer,
                                    NULL,
                                    TimerCallback,
                                    pLogFactory,
                                    30 * 1000,
                                    30 * 1000,
                                    WT_EXECUTELONGFUNCTION); // CreateTimerQueueTimer
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
        
    *ppLogFactory = pLogFactory;

    pLogFactory = NULL;

    hr = S_OK;

exit:

    if (pLogFactory)
    {
        pLogFactory->DestroyTraceLogFactory();
        pLogFactory = NULL;
    }
    
    return hr;
}

VOID
W3_TRACE_LOG_FACTORY::DestroyTraceLogFactory()
{
    if (m_hTimer)
    {
        DBG_REQUIRE(DeleteTimerQueueTimer(NULL, m_hTimer, INVALID_HANDLE_VALUE));
        m_hTimer = NULL;
    }

    // issue the final write
    TimerCallback(this, TRUE);

    // don't closehandle here, the owner of the tracelogfactory owns the handle
    m_hFile = NULL;
    
    m_ulBufferSizeInBytes = 0;
    
    if ( m_fInitCs )
    {
        DeleteCriticalSection(&m_cs);
        m_fInitCs = FALSE;
    }

    delete this;
}

HRESULT
W3_TRACE_LOG_FACTORY::CreateTraceLog(W3_TRACE_LOG ** ppTraceLog)
{
    HRESULT hr = S_OK;
    W3_TRACE_LOG * pTraceLog = NULL;

    DBG_ASSERT(ppTraceLog);
    *ppTraceLog = NULL;

    pTraceLog = new W3_TRACE_LOG(this);
    if (NULL == pTraceLog)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    *ppTraceLog = pTraceLog;

    pTraceLog = NULL;

    hr = S_OK;
exit:
    if (pTraceLog)
    {
        pTraceLog->DestroyTraceLog();
        pTraceLog = NULL;
    }
    
    return hr;
}
HRESULT
W3_TRACE_LOG_FACTORY::AppendData(LPVOID pvData, ULONG cbSize)
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    ULONG ulNewSize = 0;
    
    EnterCriticalSection(&m_cs);

    ulNewSize = m_ulBufferSizeInBytes + cbSize;
    
    fRet = m_Buffer.Resize(ulNewSize, ulNewSize);
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    memcpy((BYTE*)m_Buffer.QueryPtr() + m_ulBufferSizeInBytes, pvData, cbSize);

    m_ulBufferSizeInBytes = ulNewSize;

    hr = S_OK;
exit:
    LeaveCriticalSection(&m_cs);
    
    return S_OK;
}

//static
VOID CALLBACK
W3_TRACE_LOG_FACTORY::TimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
{
    W3_TRACE_LOG_FACTORY * pThis = (W3_TRACE_LOG_FACTORY*)lpParameter;
    DWORD dwNumBytesWritten = 0;
    BOOL fRet = FALSE;
    
    DBG_ASSERT(pThis);
    DBG_ASSERT(pThis->m_hFile);

    EnterCriticalSection(&pThis->m_cs);

    fRet = WriteFile(pThis->m_hFile,
                              pThis->m_Buffer.QueryPtr(),
                              pThis->m_ulBufferSizeInBytes,
                              &dwNumBytesWritten,
                              NULL); //WriteFile

    pThis->m_ulBufferSizeInBytes = 0;
    
    LeaveCriticalSection(&pThis->m_cs);

    return;
}

W3_TRACE_LOG::W3_TRACE_LOG(W3_TRACE_LOG_FACTORY * pLogFactory) :
    m_pLogFactory(pLogFactory),
    m_fCritSecInitialized(FALSE),
    m_fBuffer(TRUE),
    m_lIndentLevel(0),
    m_fBlock(FALSE),
    m_ulBufferSizeInBytes(0)
{
    DBG_ASSERT(pLogFactory);
}

VOID
W3_TRACE_LOG::DestroyTraceLog()
{
    //
    //BUGBUG big perf improvement
    // instead of copying this object's data - just append this object to a list of W3_TRACE_LOGs in the factory
    // and let the factory delete this object when it has committed the data to disk
    //
    if (m_pLogFactory)
    {
        m_pLogFactory->AppendData(m_Buffer.QueryPtr(), m_ulBufferSizeInBytes);
        m_pLogFactory = NULL;
    }

    delete this;
    return;
}

W3_TRACE_LOG::~W3_TRACE_LOG()
{
    if (m_fCritSecInitialized)
    {
        DeleteCriticalSection(&m_cs);
        m_fCritSecInitialized = FALSE;
    }
    DBG_ASSERT(NULL == m_pLogFactory);
}

VOID 
W3_TRACE_LOG::SetBlocking(BOOL fBlock)
{
    if (fBlock == m_fBlock)
    {
        // no change
        return;
    }

    m_fBlock = !!fBlock;
    if (m_fBlock && !m_fCritSecInitialized)
    {
        m_fCritSecInitialized = InitializeCriticalSectionAndSpinCount(&m_cs, 
                                          0x80000000 /* precreate event */ | IIS_DEFAULT_CS_SPIN_COUNT );
    }
}

VOID
W3_TRACE_LOG::SetBuffering(BOOL fBuffer)
{
    if (fBuffer == m_fBuffer)
    {
        return;
    }

    m_fBuffer = !!fBuffer;
    if (!m_fBuffer)
    {
        // we are no longer buffering, but we were before.  Dump the buffer out now
        DBG_ASSERT(m_pLogFactory);
        m_pLogFactory->AppendData(m_Buffer.QueryPtr(), m_ulBufferSizeInBytes);        
    }
    
    return;
}

VOID
W3_TRACE_LOG::ClearBuffer()
{
    if (m_fBlock)
    {
        DBG_ASSERT(m_fCritSecInitialized);
        EnterCriticalSection(&m_cs);
    }
    
    m_ulBufferSizeInBytes = 0;
    
    if (m_fBlock)
    {
        DBG_ASSERT(m_fCritSecInitialized);
        LeaveCriticalSection(&m_cs);
    }
    
    return;
}

HRESULT
W3_TRACE_LOG::Trace(LPCWSTR pszFormat, ...)
{
    HRESULT hr = S_OK;
    int cch = 0;
    BOOL fRet = FALSE;
    va_list argsList;
    
    va_start(argsList, pszFormat);
    
    if (m_fBlock)
    {
        if (!m_fCritSecInitialized)
        {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            goto exit;
        }
        DBG_ASSERT(m_fCritSecInitialized);
        EnterCriticalSection(&m_cs);
    }

    fRet = m_Buffer.Resize(m_ulBufferSizeInBytes + 1024, m_ulBufferSizeInBytes + 2048);
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    
    cch = _vsnwprintf((WCHAR*)m_Buffer.QueryPtr() +  m_ulBufferSizeInBytes, m_ulBufferSizeInBytes + 1024, pszFormat, argsList);
    // check for negative return value indicating error
    m_ulBufferSizeInBytes += cch;

    if (!m_fBuffer)
    {
        DBG_ASSERT(m_pLogFactory);
        hr = m_pLogFactory->AppendData(m_Buffer.QueryPtr(), m_ulBufferSizeInBytes);
        ClearBuffer();
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    hr = S_OK;
exit:
    
    if (m_fBlock && m_fCritSecInitialized)
    {
        DBG_ASSERT(m_fCritSecInitialized);
        LeaveCriticalSection(&m_cs);
    }

    va_end(argsList);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\memorylog.cxx ===
#include "precomp.hxx"
#include "memorylog.hxx"

CMemoryLog::CMemoryLog(DWORD dwMaxByteSize) :
  m_fValid(FALSE),
  m_fCritSecInitialized(FALSE)
{
    BOOL fRet;
    
    fRet = m_buf.Resize(dwMaxByteSize);
    if (fRet)
    {
        m_fValid = TRUE;
    }

    m_pBufferBegin = (CHAR*) m_buf.QueryPtr();
    m_pLastMessageEnd = (CHAR*) m_buf.QueryPtr();
    m_pBufferEnd = ((CHAR*) m_buf.QueryPtr()) + m_buf.QuerySize();

    fRet = InitializeCriticalSectionAndSpinCount(&m_cs, 
                                0x80000000 /* precreate event */ | 
                                IIS_DEFAULT_CS_SPIN_COUNT );
    if (FALSE != fRet)
    {
        m_fCritSecInitialized = TRUE;
    }

}

CMemoryLog::~CMemoryLog()
{
    m_pBufferBegin = NULL;
    m_pLastMessageEnd = NULL;
    m_pBufferEnd = NULL;
    m_fValid = FALSE;

    if (m_fCritSecInitialized)
    {
        DeleteCriticalSection(&m_cs);
        m_fCritSecInitialized = FALSE;
    }
}

//
// Appends to end of the circular memory log.  
// 
DWORD
CMemoryLog::Append(LPCSTR pszOutput,
                   DWORD cchLen
                  )
{
    // make sure internal state can accept this request
    if (FALSE == m_fValid ||
        FALSE == m_fCritSecInitialized )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // make sure the string length will fit inside the buffer
    if (cchLen + 1 > m_buf.QuerySize())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CHAR * pWhereToWriteMessage = NULL;

    // need to synchronize access to m_pLastMessageEnd
    EnterCriticalSection(&m_cs);

    // check if the new message will fit into the remaining space in the buffer
    // previous end (+1) + new length + 1 for NULL
    if (m_pLastMessageEnd + cchLen + 1 < m_pBufferEnd)
    {
        // it will fit in remaining space
        pWhereToWriteMessage = m_pLastMessageEnd;
    }
    else
    {
        // start over at the beginning
        pWhereToWriteMessage = (CHAR*)m_buf.QueryPtr();

        // don't leave extra old goo sitting around in the buffer
        ZeroMemory(m_pLastMessageEnd, m_pBufferEnd - m_pLastMessageEnd);
    }
    
    // set end of message to pWhere + length + 1 for NULL
    m_pLastMessageEnd = pWhereToWriteMessage + cchLen + 1;

    LeaveCriticalSection(&m_cs);

    // the following memcpy is outside of the criticalsection - 
    // this introduces a race between leaving the criticalsection and 
    // looping back through the buffer before we finish writing.
    // how likely is this?  Not very.
    //
    // In addition - moving the memcpy inside of the critsec makes the time spent
    // quite a bit larger than some simple load/stores that are currently there.
    // 
    // Plus this is a debugging aid - life isn't fair.

    // actually do the copy
    memcpy(pWhereToWriteMessage, pszOutput, cchLen);

    // write out a NULL to indicate end of message
    *(pWhereToWriteMessage + cchLen) = NULL;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\mb_notify.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    mb_notify.cxx

Abstract:

    Type definitions for handling metabase change notifications.

Author:

    Taylor Weiss (TaylorW)       26-Jan-1999

Revision History:

--*/

#include <precomp.hxx>
#include <iadmw.h>
#include <mb.hxx>
#include <mb_notify.h>
#include <initguid.h>


//
// Contruction and Destruction
//

MB_BASE_NOTIFICATION_SINK::MB_BASE_NOTIFICATION_SINK()
    : m_Refs(1),
      m_SinkCookie(0),
      m_fStartedListening(FALSE)
{
    m_fInitCsListener = InitializeCriticalSectionAndSpinCount(&m_csListener,
                                          0x80000000 | IIS_DEFAULT_CS_SPIN_COUNT );
}

MB_BASE_NOTIFICATION_SINK::~MB_BASE_NOTIFICATION_SINK()
{
    // The owner of this object needs to start and stop
    DBG_ASSERT( m_SinkCookie == 0 );

    if (m_fInitCsListener)
    {
        DeleteCriticalSection(&m_csListener);
        m_fInitCsListener = FALSE;
    }


}

//
// IUnknown
//

STDMETHODIMP_(ULONG)
MB_BASE_NOTIFICATION_SINK::AddRef()
{
    ULONG CurrentRefs = InterlockedIncrement( &m_Refs );

    return CurrentRefs;
}

STDMETHODIMP_(ULONG)
MB_BASE_NOTIFICATION_SINK::Release()
{
    ULONG CurrentRefs = InterlockedDecrement( &m_Refs );

    if( CurrentRefs == 0 )
    {
        delete this;
    }
    return CurrentRefs;
}

STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::QueryInterface(REFIID iid, void ** ppvObject)
{

    *ppvObject = NULL;

    if( iid == IID_IUnknown ||
        iid == IID_IMSAdminBaseSink )
    {
        *ppvObject = (IMSAdminBaseSink *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    DBG_ASSERT( *ppvObject );
    ((IUnknown *)*ppvObject)->AddRef();

    return S_OK;
}

STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::SynchronizedShutdownNotify()
{
    return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
}


//
// IMSAdminBaseSink
//
// Dummy implemenation
//


STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::ShutdownNotify()
{
    HRESULT hr = E_FAIL;
    if (!m_fInitCsListener)
    {
        return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    EnterCriticalSection( &m_csListener );
    if ( m_fStartedListening )
    {
        hr = SynchronizedShutdownNotify();
    }
    LeaveCriticalSection( &m_csListener );

    return hr;
}

STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::SinkNotify(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
    )
{

    HRESULT hr = E_FAIL;
    if (!m_fInitCsListener)
    {
        return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    EnterCriticalSection( &m_csListener );
    if ( m_fStartedListening )
    {
        hr = SynchronizedSinkNotify( dwMDNumElements,
                          pcoChangeList );
    }
    LeaveCriticalSection( &m_csListener );

    return hr;
}

// Public interface

HRESULT
MB_BASE_NOTIFICATION_SINK::StartListening( IUnknown * pUnkAdminBase )
/*++
Routine Description:

    Set up the metabase sink.

    StartListening and stop listening use m_SinkCookie and do no
    synchronization. Caller must synchronize.

Arguments:

    pUnkAdminBase - Base object pointer

Return Value:

--*/
{
    DBG_ASSERT( m_SinkCookie == 0 );

    if (!m_fInitCsListener)
    {
        return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    IConnectionPointContainer * pContainer = NULL;
    IConnectionPoint *          pConnectionPoint = NULL;

    HRESULT hr =
    pUnkAdminBase->QueryInterface( IID_IConnectionPointContainer,
                                   (void **)&pContainer );

    if( SUCCEEDED(hr) )
    {
        hr = pContainer->FindConnectionPoint( IID_IMSAdminBaseSink,
                                              &pConnectionPoint );

        if( SUCCEEDED(hr) )
        {
            hr = pConnectionPoint->Advise( (IMSAdminBaseSink *)this,
                                           &m_SinkCookie );

            if( FAILED(hr) )
            {
                CoDisconnectObject( (IMSAdminBaseSink*) this, 0 );
            }

            pConnectionPoint->Release();
        }

        pContainer->Release();
    }

    if ( SUCCEEDED(hr) )
    {
        EnterCriticalSection( &m_csListener );

        m_fStartedListening = TRUE;

        LeaveCriticalSection( &m_csListener );
    }
    return hr;
}

HRESULT
MB_BASE_NOTIFICATION_SINK::StopListening( IUnknown * pUnkAdminBase )
/*++
Routine Description:

    Set up the metabase sink.

Arguments:

    pUnkAdminBase - Base object pointer

Return Value:

--*/
{
    HRESULT hr = S_FALSE;

    if (!m_fInitCsListener)
    {
        return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    if( m_SinkCookie != 0 )
    {
        IConnectionPointContainer * pContainer = NULL;
        IConnectionPoint *          pConnectionPoint = NULL;

        hr = pUnkAdminBase->QueryInterface( IID_IConnectionPointContainer,
                                            (void **)&pContainer );

        if( SUCCEEDED(hr) )
        {
            hr = pContainer->FindConnectionPoint( IID_IMSAdminBaseSink,
                                                  &pConnectionPoint );

            if( SUCCEEDED(hr) )
            {
                hr = pConnectionPoint->Unadvise( m_SinkCookie );

                pConnectionPoint->Release();
            }

            pContainer->Release();
        }

        // If we fail on any of the above calls we aren't listening
        // any more

        m_SinkCookie = 0;
    }

    CoDisconnectObject( (IMSAdminBaseSink*) this, 0 );

    EnterCriticalSection( &m_csListener );

    m_fStartedListening = FALSE;

    LeaveCriticalSection( &m_csListener );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\mb.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mb.cxx

Abstract:

    This module implements the MB class using the DCOM interface.

    The old MB class (IIS4.0) was used internally within the IIS codebase to 
    access the metabase objects locally inprocess. This allowed  access to
    the metabase using the inprocess ANSI/COM interface.
  
    In the current incarnation, MB class attempts to support the following:
    o  Support UNICODE only interface to items
    o  Use only the DCOM interface of the Metabase (IMSAdminBase interface)
    o  Expose similar functionality like the MB class.

    Return Values:
      Almost all MB class members return BOOL values. 
      TRUE indicates success in the operation and FALSE indicates a failure.
      The class is expected to be used in-process for code that is mostly
        reliant on the Win32 style error reporting, it sets the error code in
        the thread and exposes them via GetLastError() interface.
Author:

    Murali Krishnan (MuraliK)        03-Nov-1998

Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"

#include <iadmw.h>
#include <mb.hxx>
#include "dbgutil.h"

//
//  Default timeout
//

#define MB_TIMEOUT           (30 * 1000)

//
//  Default timeout for SaveData
//

#define MB_SAVE_TIMEOUT      (10 * 1000)        // milliseconds


/************************************************************
 *     Member Functions of MB
 ************************************************************/

MB::MB( IMSAdminBase * pAdminBase )
    : m_pAdminBase( pAdminBase ),
      m_hMBPath ( NULL)
{
    DBG_ASSERT( m_pAdminBase != NULL);

    //
    // Add ref the admin base object so that we can keep this object around.
    // 
    m_pAdminBase->AddRef();
}

MB::~MB( VOID )
{
    //
    // Close the metabase handle if we have it open
    // 
    if ( NULL != m_hMBPath) {
        //
        // Close can sometimes fail with error RPC_E_DISCONNECTED.
        // Do not Assert
        //
        Close();
    }

    //
    // Release the AdminBase object here 
    //
    if ( NULL != m_pAdminBase) {
        m_pAdminBase->Release();
        m_pAdminBase = NULL;
    }
} // MB::~MB()




/*********************************************************************++

Routine Description:

    Opens the metabase and saves the metabase handle in the current object.
    Note: If there is already an opened handle, this method will fail.

Arguments:

    hOpenRoot - Relative root or METADATA_MASTER_ROOT_HANDLE
    pwszPath  - Path to open
    dwFlags   - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())
    The handle opened is stored inside the MB object.

--*********************************************************************/
BOOL 
MB::Open( METADATA_HANDLE hOpenRoot,
          LPCWSTR    pwszPath,
          DWORD      dwFlags )
{
    HRESULT hr;

    if ( m_hMBPath != NULL) {
        SetLastError( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));
        return (FALSE);
    }

    hr = m_pAdminBase->OpenKey( hOpenRoot,
                                pwszPath,
                                dwFlags,
                                MB_TIMEOUT,
                                &m_hMBPath );
    
    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ) );
    return FALSE;
} // MB::Open()



/*********************************************************************++
  Routine Descrition:
    This function closes the metabase handle that we have open in 
    this MB object

  Arguments:
    None

  Returns:
    TRUE on success
    FALSE if there are any errors. Use GetLastError() to retrieve the error
      on failure.
--*********************************************************************/

BOOL MB::Close( VOID )
{
    if ( m_hMBPath )
    {
        HRESULT hr;

        hr = m_pAdminBase->CloseKey( m_hMBPath );

        if (FAILED(hr)) {
            SetLastError( HRESULTTOWIN32( hr));
            return (FALSE);
        }

        m_hMBPath = NULL;
    }

    return TRUE;
} // MB::Close()



/*********************************************************************++
  Routine Descrition:
    This function saves all the changes that we have made using current
    metabase object.

  Arguments:
    None

  Returns:
    TRUE on success
    FALSE if there are any errors. Use GetLastError() to retrieve the error
      on failure.
--*********************************************************************/
BOOL MB::Save( VOID )
{
    HRESULT hr;
    METADATA_HANDLE mdhRoot;

    if ( NULL != m_pAdminBase) { 
        hr = m_pAdminBase->SaveData();

        if ( FAILED( hr)) {
            SetLastError( HRESULTTOWIN32( hr));
            return (FALSE);
        }
    }
        
    return (TRUE);
} // MB::Save()




/*********************************************************************++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath    - Path to get the data on
    dwFlags    - Inerhitance flags
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to data
    pcbData    - Size of pvData, receives size of object
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetAll( IN LPCWSTR     pszPath,
            DWORD          dwFlags,
            DWORD          dwUserType,
            BUFFER *       pBuff,
            DWORD *        pcRecords,
            DWORD *        pdwDataSetNumber )
{
    DWORD   RequiredSize;
    HRESULT hr;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    do {

        hr = m_pAdminBase->
            GetAllData( m_hMBPath,
                        pszPath,
                        dwFlags,
                        dwUserType,
                        ALL_METADATA,
                        pcRecords,
                        pdwDataSetNumber,
                        pBuff->QuerySize(),
                        (PBYTE)pBuff->QueryPtr(),
                        &RequiredSize
                        );
        
        // See if we got it, and if we failed because of lack of buffer space
        // try again.
        
        if ( SUCCEEDED(hr) ) {
                return TRUE;
        }
        
        //
        // Some sort of error, most likely not enough buffer space. Keep
        // trying until we get a non-fatal error.
        //
        
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32 &&
            HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
            
            // Not enough buffer space. RequiredSize contains the amount
            // the metabase thinks we need.
            
            if ( !pBuff->Resize(RequiredSize) ) {
                
                // Not enough memory to resize.
                return FALSE;
            }
        } else {
          
            //
            // Some other failure: return the failure to caller
            //

            SetLastError(HRESULTTOWIN32(hr));
            break;
        }
    } while (FAILED(hr));

    return FALSE;
} // MB::GetAll()



/*********************************************************************++
  Routine Description:
    This function retrieves the data set number from the metabase
     for the given path.

  Arguments:
    pszPath - pointer to string containing the path for metabase item
    pdwDataSetNumber - pointer to DWORD that will contain the dataset
               number on return.

  Returns:
    TRUE on success. FALSE for failure
--*********************************************************************/
BOOL
MB::GetDataSetNumber(IN LPCWSTR pszPath,
                     OUT DWORD * pdwDataSetNumber)
{
    DWORD   RequiredSize;
    HRESULT hr;

    DBG_ASSERT ( m_pAdminBase != NULL);

    //
    //  NULL metabase handle is permitted here
    //

    hr = m_pAdminBase->GetDataSetNumber( m_hMBPath, pszPath, pdwDataSetNumber);
    if (FAILED (hr)) {
        SetLastError( HRESULTTOWIN32( hr));
        return (FALSE);
    }

    return (TRUE);
} // MB::GetDataSetNumber()



/*********************************************************************++
  Routine Description:
    Enumerates and obtain the name of the object at given index position
     within the given path in the tree.

  Arguments:
    pszPath - pointer to string containing the path for metabase item
    pszName - pointer to a buffer that will contain the name of the item
              at index position [dwIndex]. The buffer should at least be
              ADMINDATA_MAX_NAME_LEN+1 character in length
    dwIndex - index for the item to be enumerated.

  Returns:
    TRUE on success. FALSE for failure.
    ERROR_NO_MORE_ITEMS when the end of the list is reached.

  A typical use is to enumerate for all items starting at index 0 and 
   enumerating till the return value is FALSE with error = ERROR_NO_MORE_ITEMS
--*********************************************************************/
BOOL
MB::EnumObjects( IN LPCWSTR  pszPath,
                 OUT LPWSTR  pszName,
                 IN DWORD    dwIndex )
{
    HRESULT hr = m_pAdminBase->EnumKeys( m_hMBPath,
                                           pszPath,
                                           pszName,
                                           dwIndex );

    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ));
    return FALSE;
} // MB::EnumObjects()


BOOL
MB::AddObject( IN LPCWSTR pszPath)
{
    HRESULT hr;
    
    hr = m_pAdminBase->AddKey( m_hMBPath, pszPath);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);

} // MB::AddObject()


BOOL
MB::DeleteObject( IN LPCWSTR pszPath)
{
    HRESULT hr;
    
    hr = m_pAdminBase->DeleteKey( m_hMBPath, pszPath);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // MB::DeleteObject()


BOOL
MB::DeleteData(
   IN LPCWSTR  pszPath,
   IN DWORD    dwPropID,
   IN DWORD    dwUserType,
   IN DWORD    dwDataType )
{
    HRESULT hr = m_pAdminBase->DeleteData( m_hMBPath,
                                           pszPath,
                                           dwPropID,
                                           dwDataType
                                           );
    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ));
    return(FALSE);
} // MB::DeleteData()


BOOL
MB::GetSystemChangeNumber( OUT DWORD * pdwChangeNumber)
{
    HRESULT hr = m_pAdminBase->GetSystemChangeNumber( pdwChangeNumber);
    
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} 


/*********************************************************************++

Routine Description:

    Sets a metadata property on an opened metabase path.

Arguments:

    pszPath    - Path to set data on
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to data buffer containing the data.
    cbData     - Size of data
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::SetData( IN LPCWSTR pszPath,
             IN DWORD   dwPropID,
             IN DWORD   dwUserType,
             IN DWORD   dwDataType,
             IN VOID *  pvData,
             IN DWORD   cbData,
             IN DWORD   dwFlags )
{
    HRESULT hr;
    METADATA_RECORD mdr;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    mdr.dwMDIdentifier = dwPropID;
    mdr.dwMDAttributes = dwFlags;
    mdr.dwMDUserType   = dwUserType;
    mdr.dwMDDataType   = dwDataType;
    mdr.dwMDDataLen    = cbData;
    mdr.pbMDData       = (BYTE * ) pvData;

    hr = m_pAdminBase->SetData(m_hMBPath, pszPath, &mdr);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);

} // MB::SetData()




/*********************************************************************++

Routine Description:

    Obtains the metadata requested in the call. 
    It uses the current opened metabase path for getting the data.

Arguments:

    pszPath    - Path to get data on
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to buffer in which the data will be obtained
    pcbData    - Size of data
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetData( IN LPCWSTR pszPath,
             IN DWORD   dwPropID,
             IN DWORD   dwUserType,
             IN DWORD   dwDataType,
             OUT VOID * pvData,
             IN OUT DWORD *  pcbData,
             IN DWORD   dwFlags)
{
    HRESULT hr;
    METADATA_RECORD mdr;
    DWORD           dwRequiredDataLen;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    mdr.dwMDIdentifier = dwPropID;
    mdr.dwMDAttributes = dwFlags;
    mdr.dwMDUserType   = dwUserType;
    mdr.dwMDDataType   = dwDataType;
    mdr.dwMDDataLen    = *pcbData;
    mdr.pbMDData       = (BYTE * ) pvData;

    hr = m_pAdminBase->GetData(m_hMBPath, pszPath, &mdr, &dwRequiredDataLen);

    if (SUCCEEDED(hr)) {
        *pcbData = mdr.dwMDDataLen;
        return ( TRUE);
    } 

    *pcbData = dwRequiredDataLen;

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // MB::GetData()



/*********************************************************************++

Routine Description:

    Obtains the paths beneath the given path in the metadata tree.
    It uses the current opened metabase path for getting the data.

Arguments:

    pszPath - Path to get data on
    dwPropID - Metabase property ID
    dwDataType - Type of data being set (dword, string etc)
    pBuff    - pointer to BUFFER object that will contain the resulting data

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetDataPaths(IN LPCWSTR   pszPath,
                 IN DWORD     dwPropID,
                 IN DWORD     dwDataType,
                 IN BUFFER *  pBuff )
{
    HRESULT hr;
    METADATA_RECORD mdr;
    DWORD           cchRequiredDataLen;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    do { 

        hr = m_pAdminBase->GetDataPaths( m_hMBPath, 
                                         pszPath,
                                         dwPropID,
                                         dwDataType,
                                         pBuff->QuerySize() / sizeof(WCHAR),
                                         (LPWSTR ) pBuff->QueryPtr(),
                                         &cchRequiredDataLen
                                         );
        
        if ( SUCCEEDED( hr)) {
            
            return (TRUE);
        }

        // Some sort of error, most likely not enough buffer space. Keep
        // trying until we get a non-fatal error.
        
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32 &&
            HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) 
        {
            
            // Not enough buffer space. 
            // cchRequiredDataLen contains the # of wide chars that metabase
            //    thinks we need.
            
            if ( !pBuff->Resize( (cchRequiredDataLen + 1) * sizeof(WCHAR)) )
            {
                
                // Not enough memory to resize.
                return FALSE;
            }
        } else {

            // unknown failure. return failure
            break;
        }

    } while (FAILED(hr));

    DBG_ASSERT( FAILED(hr));

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // MB::GetDataPaths()


/*********************************************************************++

Routine Description:

    Get child paths

Arguments:

    pszPath - Path to get data on
    pBuff    - pointer to BUFFER object that will contain the resulting data

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetChildPaths(IN LPCWSTR   pszPath,
                  IN BUFFER *  pBuff )
{
    HRESULT hr;
    METADATA_RECORD mdr;
    DWORD           cchRequiredDataLen;
    IMSAdminBase3 * pNewBase;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    hr = m_pAdminBase->QueryInterface( IID_IMSAdminBase3_W,
                                       (void**) &pNewBase );
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
 
    do { 
    
        hr = pNewBase->GetChildPaths( m_hMBPath,
                                      pszPath,
                                      pBuff->QuerySize() / sizeof(WCHAR),
                                      (LPWSTR ) pBuff->QueryPtr(),
                                      &cchRequiredDataLen
                                      );
        
        if ( SUCCEEDED( hr)) {
           
            pNewBase->Release(); 
            return (TRUE);
        }

        // Some sort of error, most likely not enough buffer space. Keep
        // trying until we get a non-fatal error.
        
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32 &&
            HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) 
        {
            
            // Not enough buffer space. 
            // cchRequiredDataLen contains the # of wide chars that metabase
            //    thinks we need.
            
            if ( !pBuff->Resize( (cchRequiredDataLen + 1) * sizeof(WCHAR)) )
            {
                pNewBase->Release();
                // Not enough memory to resize.
                return FALSE;
            }
        } else {

            // unknown failure. return failure
            break;
        }

    } while (FAILED(hr));

    DBG_ASSERT( FAILED(hr));

    SetLastError( HRESULTTOWIN32( hr));
    
    pNewBase->Release();
    
    return (FALSE);
} // MB::GetDataPaths()

/*********************************************************************++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.
    The retrieved string is stored in the STR object supplied.

Arguments:

    pszPath    - Path to get data on
    dwPropID   - property id to retrieve
    dwUserType - User type for this property
    pstrValue  - string that receives the value
    dwFlags    - Metabase flags
    pszDefault - Default value to use if the string isn't found, NULL
        for no default value (i.e., will return an error).

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetStr( IN LPCWSTR  pszPath,
            IN DWORD    dwPropID,
            IN DWORD    dwUserType,
            OUT STRU * pstrValue,
            IN DWORD    dwFlags,
            IN LPCWSTR  pszDefault )

{
    HRESULT hr = S_OK;
    DWORD cbSize = pstrValue->QueryBuffer()->QuerySize();

    do {

        if ( GetData( pszPath,
                       dwPropID,
                       dwUserType,
                       STRING_METADATA,
                       pstrValue->QueryBuffer()->QueryPtr(),
                       &cbSize,
                       dwFlags )
             ) {

            //
            // we got the data - bail out
            //
            pstrValue->SyncWithBuffer();
            return (TRUE);
            
        } else {
            
            if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND ) {
                
                // 
                // No item found. Use the default.
                //
                if ( pszDefault != NULL ) {
                    
                    hr =  pstrValue->Copy( (const LPWSTR ) pszDefault );

                    if ( FAILED( hr ) )
                    {
                        SetLastError( WIN32_FROM_HRESULT( hr ) );
                        return (FALSE);
                    }

                    return (TRUE);
                }

                return FALSE;
            } else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                if (TRUE == pstrValue->QueryBuffer()->Resize( cbSize ) )
                {
                    // 
                    // reallocation of buffer for holding the string is sufficient
                    // Now try again.
                    // 
                    continue;
                }
                else
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
            } else {
                SetLastError( WIN32_FROM_HRESULT( hr ) );
                return (FALSE);
            }
        }
    } while (TRUE);  // loop till you get out with error or success.

    return FALSE;
} // MB::GetStr()



/*********************************************************************++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath    - Path to get data on
    dwPropID   - property id to retrieve
    dwUserType - User type for this property
    pMultiszValue - multi-string that receives the value
    dwFlags    - Metabase flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetMultisz(
    IN LPCWSTR    pszPath,
    IN DWORD      dwPropID,
    IN DWORD      dwUserType,
    OUT MULTISZ * pMultiszValue,
    IN DWORD      dwFlags
    )

{
    DWORD cbSize = pMultiszValue->QuerySize();

    do {
        
        if ( GetData( pszPath,
                       dwPropID,
                       dwUserType,
                       MULTISZ_METADATA,
                       pMultiszValue->QueryStr(),
                       &cbSize,
                       dwFlags ))
        {
            //
            // we got the data - bail out
            //
            
            goto Succeeded;
        } else {

            if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND ) 
            {
                return FALSE;
            }
            else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                      pMultiszValue->Resize( cbSize ) )
            {
                continue;
            }

            return FALSE;
        }
    } while ( TRUE);

Succeeded:

    //
    //  Value was read directly into the buffer so update the member
    //  variables
    //

    pMultiszValue->RecalcLen();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\mbtest.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     mbtest.cxx

   Abstract:
     Test program for the MB class

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#undef DEFINE_GUID
#define INITGUID
#include <ole2.h>
#include <iadmw.h>
#include <mb.hxx>

#include <iostream.h>
#include <iiscnfg.h>

#include <stdio.h>
#include <string.hxx>

#include "dbgutil.h"

//
// namespace std only works with iostream; but I cannot find a way
// to link if I were to use the <iostream> as is.
// I need to fiddle with CPlusPlus compiler flags - for later use
// using namespace std;

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

/************************************************************
 *    Functions
 ************************************************************/


void CreateAndTestMB( IMSAdminBase * pAdminBase);


extern "C" INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    HRESULT hr;
    IMSAdminBase * pAdminBase = NULL;

    CREATE_DEBUG_PRINT_OBJECT( "mbtest");

    //
    // Initialize COM
    //
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED);
    if (FAILED( hr)) {
        cout << "Failed to initialize COM. Error = "
             << ios::hex << hr << endl;
        exit(1);
    }

    //
    // Create the Admin Base object
    //

    hr = CoCreateInstance(
                          GETAdminBaseCLSID( TRUE),   // refCLSID
                          NULL,                       // punkOuter
                          CLSCTX_SERVER,              // dwClsCtx
                          IID_IMSAdminBase,           // Admin Base object
                          reinterpret_cast<LPVOID *> (&pAdminBase)
                          );
    if (FAILED(hr)) {
        cout << "Failed to create Admin Base object. Error = "
             << ios::hex << hr << endl;
        exit (1);
    }

    CreateAndTestMB(pAdminBase);

    // release of pAdminBase is done here
    pAdminBase->Release();

    CoUninitialize();

    DELETE_DEBUG_PRINT_OBJECT();
    return (0);
} // wmain()


void ReportStatus( IN LPCSTR pszItem, IN BOOL fRet)
{
    cout << pszItem << " returns => " << fRet << endl;
    if (!fRet) {
        cout << "\t Error= " << GetLastError() << endl;
        cout << "\t Error= " << hex << GetLastError() << endl;
    }
}


void RunEnumerationTest( IN MB * pmb, LPCWSTR psz, int level)
{
    BOOL fRet;
    static CHAR  rgszBlanks[] =
        "                                                       "
        "                                                       "
        ;

    // set the blanking interval for our use.
    if ( level >= sizeof(rgszBlanks)) { level = sizeof(rgszBlanks); }

    WCHAR wchNext[200];
    DWORD len = lstrlen( psz);
    lstrcpy( wchNext, psz);
    if ( len > 1) {
        wchNext[len++] = L'/';
        wchNext[len] = L'\0';
    }


    WCHAR rgszName[ADMINDATA_MAX_NAME_LEN];
    for ( DWORD i = 0; i < 10; i++ ) {
        fRet = pmb->EnumObjects( psz, rgszName, i);
        if (!fRet) {
            break;
        } else {
            rgszBlanks[level] = '\0';
            printf( "%s[%p] => %S\n", rgszBlanks, psz, i, rgszName);
            rgszBlanks[level] = ' '; // reset the blanks

            //
            // recurse to printout other elements
            //
            lstrcpy( wchNext + len, rgszName);
            RunEnumerationTest( pmb, wchNext, level+1);
        }
    } // for
} // RunEnumerationTest()




/*++
  Routine Description:
   This function creates the MB class object, calls test methods and runs
    the various method calls on the MB object
    to ensure that this is working well.

  Arguments:
    pAdminBase - pointer to Admin Base object

  Returns:
    None
--*/
void CreateAndTestMB(IMSAdminBase * pAdminBase)
{
    MB  mb1( pAdminBase);
    BOOL fRet;

    cout << "In CreateAndTestMB() "
         << (reinterpret_cast<LPVOID> (pAdminBase))
         << endl;

    fRet = mb1.Open( L"/w3svc");
    ReportStatus( "Open(/w3svc)", fRet);

    fRet = mb1.Save();
    ReportStatus( "Save()", fRet);

    DWORD dsNumber = 0;
    fRet = mb1.GetDataSetNumber( L"/w3svc", &dsNumber);
    ReportStatus( "GetDataSetNumber(/w3svc)", fRet);

    if (fRet) {
        cout << "\t Data Set Number is " << dsNumber << endl;
    }

    fRet = mb1.GetDataSetNumber( NULL, &dsNumber);
    ReportStatus( "GetDataSetNumber(NULL)", fRet);

    if (fRet) {
        cout << "\t Data Set Number (NULL) is " << dsNumber << endl;
    }

    //
    // Test Enumeration of the objects
    //
    //    RunEnumerationTest( &mb1, L"/", 0);
    //    cout << "Enumeration at root completed" << endl;


    fRet = mb1.Close();
    ReportStatus( "Close()", fRet);


    fRet = mb1.Open( L"/lm");
    ReportStatus( "Open(/lm/w3svc)", fRet);

    //
    // Test the Get operations
    //

    STRU stru;
    fRet = mb1.GetStr( L"/w3svc",
                       MD_ASP_SCRIPTERRORMESSAGE,
                       ASP_MD_UT_APP,
                       &stru,
                       METADATA_INHERIT,
                       L"Value Not Found"
                       );
    ReportStatus( "GetStr( /w3svc/AspScriptErrorMessage)", fRet);
    if (fRet) {
        printf( "\tGetStr( AspScriptErrorMessage) =>%S\n", stru.QueryStr());
    }

    fRet = mb1.Close();
    ReportStatus( "Close()", fRet);

    cout << "Exiting CreateAndTestMB() " << endl;
    return;
} // CreateAndTestMB()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\locks.cpp ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#include "precomp.hxx"

#define IMPLEMENTATION_EXPORT
#include <locks.h>
#include "_locks.h"


// Thunking wrapper for ::SetCriticalSectionSpinCount that will work on
// systems that don't have this API in kernel32

DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount)
{
    return CCritSec::SetSpinCount(lpCriticalSection, dwSpinCount);
}


BOOL
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection)
{
    return InitializeCriticalSectionAndSpinCount( lpCriticalSection, 
                                                  IIS_DEFAULT_CS_SPIN_COUNT );
}



//------------------------------------------------------------------------
// Not all Win32 platforms support all the functions we want. Set up dummy
// thunks and use GetProcAddress to find their addresses at runtime.

typedef
BOOL
(WINAPI * PFN_SWITCH_TO_THREAD)(
    VOID
    );

static BOOL WINAPI
FakeSwitchToThread(
    VOID)
{
    return FALSE;
}

PFN_SWITCH_TO_THREAD  g_pfnSwitchToThread = NULL;


typedef
BOOL
(WINAPI * PFN_TRY_ENTER_CRITICAL_SECTION)(
    IN OUT LPCRITICAL_SECTION lpCriticalSection
    );

static BOOL WINAPI
FakeTryEnterCriticalSection(
    LPCRITICAL_SECTION /*lpCriticalSection*/)
{
    return FALSE;
}

PFN_TRY_ENTER_CRITICAL_SECTION g_pfnTryEnterCritSec = NULL;


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;

DWORD g_cProcessors = 0;


class CSimpleLock
{
  public:
    CSimpleLock()
        : m_l(0)
    {}

    void Enter()
    {
        while (Lock_AtomicExchange(const_cast<LONG*>(&m_l), 1) != 0)
            Sleep(0);
    }

    void Leave()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_l), 0);
    }

    volatile LONG m_l;
};


BOOL g_fLocksInitialized = FALSE;
CSimpleLock g_lckInit;

BOOL
Locks_Initialize()
{
    if (!g_fLocksInitialized)
    {
        g_lckInit.Enter();
    
        if (!g_fLocksInitialized)
        {
            // load kernel32 and get NT-specific entry points
            HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

            if (hKernel32 != NULL)
            {
                g_pfnSwitchToThread = (PFN_SWITCH_TO_THREAD)
                    GetProcAddress(hKernel32, "SwitchToThread");
                
                g_pfnTryEnterCritSec = (PFN_TRY_ENTER_CRITICAL_SECTION)
                    GetProcAddress(hKernel32, "TryEnterCriticalSection");
                
                g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT)
                    GetProcAddress(hKernel32, "SetCriticalSectionSpinCount");
            }
            
            if (g_pfnSwitchToThread == NULL)
                g_pfnSwitchToThread = FakeSwitchToThread;
            
            if (g_pfnTryEnterCritSec == NULL)
                g_pfnTryEnterCritSec = FakeTryEnterCriticalSection;
            
            if (g_pfnSetCSSpinCount == NULL)
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
            
            g_cProcessors = NumProcessors();

            Lock_AtomicExchange((LONG*) &g_fLocksInitialized, TRUE);
        }
        
        g_lckInit.Leave();
    }

    return TRUE;
}


BOOL
Locks_Cleanup()
{
    return TRUE;
}



#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__


#define LOCK_DEFAULT_SPIN_DATA(CLASS)                       \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    strcpy(ls.m_szName, m_szName);                              \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION
# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()
#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

double
RandomBackoffFactor()
{
    static const double s_aFactors[] = {
        1.020, 0.965,  0.890, 1.065,
        1.025, 1.115,  0.940, 0.995,
        1.050, 1.080,  0.915, 0.980,
        1.010,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
    DWORD nRand = ::GetCurrentThreadId();

    return s_aFactors[nRand % nFactors];
}



//------------------------------------------------------------------------
// Function: SleepTime
// Synopsis: Calculate the next sleep interval, in milliseconds
// Parameters:
//      cYields: number of times this thread has called SwitchOrSleep()
//               while trying to acquire the lock.
//------------------------------------------------------------------------

DWORD
SleepTime(
    DWORD cYields)
{
    static const DWORD aSleepTimes[] = {
        0, 1, 10, 100,
    };

    const DWORD NumSleepTimes = (sizeof(aSleepTimes) / sizeof(aSleepTimes[0]));

    DWORD dwSleepTime;

    if (cYields >= NumSleepTimes)
    {
        // We've yielded a number of times. Force the thread to 
        // call Sleep(LOCKS_SLEEPTIME). This minimizes CPU utilization
        // in pathological cases where a large number of threads are
        // contending on a lock that has been held for a long time.
        // This also prevents priority inversion.

        dwSleepTime = LOCKS_SLEEPTIME;
    }
    else
    {
        dwSleepTime = aSleepTimes[cYields];
    }

    return dwSleepTime;
}


//------------------------------------------------------------------------
// Function: SwitchOrSleep
// Synopsis: Either Sleep()s or calls SwitchToThread() to yield the processor
//------------------------------------------------------------------------

void
SwitchOrSleep(
    DWORD dwSleepMSec)
{
    bool fMustSleep = false;

    if (0 != dwSleepMSec)
    {
        // Always honor a non-zero sleeptime
        fMustSleep = true;
    }
    else if (! g_pfnSwitchToThread())
    {
        // SwitchToThread() found no runnable threads on this CPU
        fMustSleep = true;
    }

    if (fMustSleep)
    {
        Sleep(dwSleepMSec);
    }
}



// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION

LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION


//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_PROLOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
    
    DWORD dwSleepTime  = 0;

    IRTLASSERT(SleepTime(0) == dwSleepTime);

    LONG  cBaseSpins  = sm_wDefaultSpinCount;
    LONG  cBaseSpins2 = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == _CurrentThreadId())
    {
        IRTLASSERT(
           !"CSmallSpinLock: Illegally attempted to acquire lock recursively");
        DebugBreak();
    }

    for (DWORD cYields = 0;  !_TryLock();  ++cYields)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = (int) (cBaseSpins2 * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion.  Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run.  If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock.  NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable.  If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU.  We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~100,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...

                    dwSleepTime = SleepTime(cYields);
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

            SwitchOrSleep(dwSleepTime) ;

            dwSleepTime = SleepTime(cYields);
        }
    }

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_EPILOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
}



// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;

    IRTLASSERT(SleepTime(0) == dwSleepTime);

    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = sm_wDefaultSpinCount;

    cBaseSpins = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    for (DWORD cYields = 0;  !fAcquiredLock;  ++cYields)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  sm_wDefaultSpinCount != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    dwSleepTime = SleepTime(cYields);

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION

            SwitchOrSleep(dwSleepTime) ;

            dwSleepTime = SleepTime(cYields);
        }

        // Is the lock unowned?
        if (_TryLock())
            fAcquiredLock = true; // got the lock
    }

    IRTLASSERT((m_lTid & OWNER_MASK) > 0
               &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);

bool
CCritSec::TryWriteLock()
{
    IRTLASSERT(g_pfnTryEnterCritSec != NULL);
    return g_pfnTryEnterCritSec(&m_cs) ? true : false;
}

//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    IRTLASSERT(g_pfnSetCSSpinCount != NULL);
    return g_pfnSetCSSpinCount(pcs, dwSpinCount);
}


// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);



// CRtlResource static member variables

LOCK_DEFAULT_SPIN_DATA(CRtlResource);
LOCK_STATISTICS_DATA(CRtlResource);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CRtlResource);


// CShareLock static member variables

LOCK_DEFAULT_SPIN_DATA(CShareLock);
LOCK_STATISTICS_DATA(CShareLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CShareLock);



// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;

    IRTLASSERT(SleepTime(0) == dwSleepTime);

    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (DWORD cYields = 0;  ;  ++cYields)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();
            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION
        
        SwitchOrSleep(dwSleepTime) ;

        dwSleepTime = SleepTime(cYields);

        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);


void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;

    IRTLASSERT(SleepTime(0) == dwSleepTime);

    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (DWORD cYields = 0;  ;  ++cYields)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;

        dwSleepTime = SleepTime(cYields);
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);


void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(SPIN_WRITE);
}


void
CReaderWriterLock3::_LockSpin(
    SPIN_TYPE st)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;

    IRTLASSERT(SleepTime(0) == dwSleepTime);

    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (DWORD cYields = 0;  ;  ++cYields)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock;

            if (st == SPIN_WRITE)
                fLock = _TryWriteLock(0);
            else if (st == SPIN_READ)
                fLock = _TryReadLock();
            else
            {
                IRTLASSERT(st == SPIN_READ_RECURSIVE);
                fLock = _TryReadLockRecursive();
            }

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;

        dwSleepTime = SleepTime(cYields);
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT((st == SPIN_WRITE)  ?  IsWriteLocked()  :  IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\multisz.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    multisz.cxx

    This module contains a light weight multi-string class


    FILE HISTORY:
        KeithMo     20-Jan-1997 Created from string.cxx

*/

#include "precomp.hxx"


# include <dbgutil.h>
# include <multisz.hxx>
//# include <auxctrs.h>

# include <tchar.h>

//
//  Private Definitions
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128


DWORD
MULTISZ::CalcLength( const WCHAR * str,
                     LPDWORD pcStrings )
{
    DWORD count = 0;
    DWORD total = 1;
    DWORD len;

    while( *str ) {
        len = ::wcslen( str ) + 1;
        total += len;
        str += len;
        count++;
    }

    if( pcStrings != NULL ) {
        *pcStrings = count;
    }

    return total;

}   // MULTISZ::CalcLength


BOOL
MULTISZ::FindString( const WCHAR * str )
{

    WCHAR * multisz;

    //
    // Sanity check.
    //

    DBG_ASSERT( QueryStr() != NULL );
    DBG_ASSERT( str != NULL );
    DBG_ASSERT( *str != '\0' );

    //
    // Scan it.
    //

    multisz = QueryStr();

    while( *multisz != '\0' ) {

        if( !::wcscmp( multisz, str ) ) {

            return TRUE;

        }

        multisz += ::wcslen( multisz ) + 1;

    }

    return FALSE;

}   // MULTISZ::FindString


BOOL
MULTISZ::FindStringNoCase( const WCHAR * str )
{

    WCHAR * multisz;

    //
    // Sanity check.
    //

    DBG_ASSERT( QueryStr() != NULL );
    DBG_ASSERT( str != NULL );
    DBG_ASSERT( *str != '\0' );

    //
    // Scan it.
    //

    multisz = QueryStr();

    while( *multisz != '\0' ) {

        if( !_wcsicmp( multisz, str ) ) {

            return TRUE;

        }

        multisz += wcslen( multisz ) + 1;

    }

    return FALSE;

}   // MULTISZ::FindStringNoCase


VOID
MULTISZ::AuxInit( const WCHAR * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        DWORD cStrings;
        int cbCopy = CalcLength( pInit, &cStrings ) * sizeof(WCHAR);
        fRet = Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = (cbCopy)/sizeof(WCHAR);
            m_cStrings = cStrings;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        Reset();

    }

} // MULTISZ::AuxInit()


/*******************************************************************

    NAME:       MULTISZ::AuxAppend

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZ::AuxAppend( const WCHAR * pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 4 );

    if( cbThis == 4 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis -= sizeof(WCHAR);

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    //AcIncrement( CacMultiszAppend);
    if ( QuerySize() < cbThis + cbStr + sizeof(WCHAR))
    {
        if ( !Resize( cbThis + cbStr + sizeof(WCHAR)  
             + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);

    *(WCHAR *)((BYTE *)QueryPtr() + cbThis + cbStr) = L'\0';

    m_cchLen = CalcLength( (const WCHAR *)QueryPtr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppend()


#if 0

BOOL
MULTISZ::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the UNICODE version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         11-30-94
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

      //
      //  Inquiring the size of buffer alone
      //
      *lpcch = QueryCCH() + 1;    // add one character for terminating null
    } else {

        //
        // Copy after conversion from ANSI to Unicode
        //
        int  iRet;
        iRet = MultiByteToWideChar( CP_ACP,   MB_PRECOMPOSED,
                                    QueryStrA(),  QueryCCH() + 1,
                                    lpszBuffer, (int )*lpcch);

        if ( iRet == 0 || iRet != (int ) *lpcch) {

            //
            // Error in conversion.
            //
            fReturn = FALSE;
        }
    }

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
#endif

BOOL
MULTISZ::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    register DWORD cch = QueryCCH();

    if ( *lpcch >= cch) {

        DBG_ASSERT( lpszBuffer);
        memcpy( lpszBuffer, QueryStr(), cch * sizeof(WCHAR));
    } else {
        DBG_ASSERT( *lpcch < cch);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\multisza.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    multisz.cxx

    This module contains a light weight multi-string class


    FILE HISTORY:
        KeithMo     20-Jan-1997 Created from string.cxx

*/

#include "precomp.hxx"


# include <dbgutil.h>
# include <multisza.hxx>

//
//  Private Definitions
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128

// static
DWORD
MULTISZA::CalcLength(const CHAR * str,
                     LPDWORD pcStrings)
{
    DWORD count = 0;
    DWORD total = 1;
    DWORD len;

    while( *str ) {
        len = strlen( str ) + 1;
        total += len;
        str += len;
        count++;
    }

    if( pcStrings != NULL ) {
        *pcStrings = count;
    }

    return total;

}   // MULTISZA::CalcLength


BOOL
MULTISZA::FindString( const CHAR * str )
{

    CHAR * multisz;

    //
    // Sanity check.
    //

    DBG_ASSERT( QueryStr() != NULL );
    DBG_ASSERT( str != NULL );
    DBG_ASSERT( *str != '\0' );

    //
    // Scan it.
    //

    multisz = QueryStr();

    while( *multisz != '\0' ) {

        if( !strcmp( multisz, str ) ) {

            return TRUE;

        }

        multisz += strlen( multisz ) + 1;

    }

    return FALSE;

}   // MULTISZA::FindString


VOID
MULTISZA::AuxInit( const BYTE * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        DWORD cStrings;
        int cbCopy = CalcLength( (const CHAR *)pInit, &cStrings );
        fRet = Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = cbCopy;
            m_cStrings = cStrings;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        Reset();

    }

} // MULTISZA::AuxInit()


/*******************************************************************

    NAME:       MULTISZ::AuxAppend

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZA::AuxAppend(const BYTE * pStr,
                         UINT cbStr,
                         BOOL fAddSlop)
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 2 );

    if( cbThis == 2 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis -= sizeof(CHAR);

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbStr + sizeof(CHAR))
    {
        if ( !Resize( cbThis + cbStr + sizeof(CHAR)  
             + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);

    *((CHAR *)QueryPtr() + cbThis + cbStr) = '\0';

    m_cchLen = CalcLength( (const CHAR *)QueryPtr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppend()


/*******************************************************************

    NAME:       MULTISZA::AuxAppendW

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZA::AuxAppendW(LPCWSTR pStr,
                          UINT cbStr,
                          BOOL fAddSlop)
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 2 );

    if( cbThis == 2 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis -= sizeof(CHAR);

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbStr + sizeof(CHAR))
    {
        if ( !Resize( cbThis + cbStr + sizeof(CHAR)  
             + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    for (DWORD i=0; i < cbStr; i++)
    {
        QueryStr()[cbThis + i] = (CHAR)pStr[i];
    }

    QueryStr()[cbThis + cbStr] = '\0';

    m_cchLen = CalcLength(QueryStr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppendW()


BOOL
MULTISZA::CopyToBuffer(CHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    DWORD cch = QueryCCH() + 1;

    if ( *lpcch >= cch) {

        DBG_ASSERT( lpszBuffer);
        CopyMemory( lpszBuffer, QueryStr(), cch);
    } else {
        DBG_ASSERT( *lpcch < cch);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // MULTISZA::CopyToBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\reftrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>
#include <pudebug.h>
#include <reftrace.h>
#include <stktrace.h>


PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    return CreateTraceLog(
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/
{

    DestroyTraceLog( Log );

}   // DestroyRefTraceLog


//
// N.B. For IISCaptureStackBackTrace() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// WriteRefTraceLog[Ex]() with the __cdecl modifier and disable the frame
// pointer omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

LONG
__cdecl
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    )
/*++

Routine Description:

    Writes a new entry to the specified ref count trace log. The entry
    written contains the updated reference count and a stack backtrace
    leading up to the current caller.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context - An uninterpreted context to associate with the log entry.

Return Value:

    Index of entry in log.

--*/
{

    return WriteRefTraceLogEx(
        Log,
        NewRefCount,
        Context,
        REF_TRACE_EMPTY_CONTEXT, // suppress use of optional extra contexts
        REF_TRACE_EMPTY_CONTEXT,
        REF_TRACE_EMPTY_CONTEXT
        );

}   // WriteRefTraceLog




LONG
__cdecl
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1, // optional extra context
    IN PVOID Context2, // optional extra context
    IN PVOID Context3  // optional extra context
    )
/*++

Routine Description:

    Writes a new "extended" entry to the specified ref count trace log.
    The entry written contains the updated reference count, stack backtrace
    leading up to the current caller and extra context information.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context  - An uninterpreted context to associate with the log entry.
    Context1 - An uninterpreted context to associate with the log entry.
    Context2 - An uninterpreted context to associate with the log entry.
    Context3 - An uninterpreted context to associate with the log entry.

    NOTE Context1/2/3 are "optional" in that the caller may suppress
    debug display of these values by passing REF_TRACE_EMPTY_CONTEXT
    for each of them.

Return Value:

    Index of entry in log.

--*/
{

    REF_TRACE_LOG_ENTRY entry;
    ULONG hash;
    DWORD cStackFramesSkipped;

    //
    // Initialize the entry.
    //

    RtlZeroMemory(
        &entry,
        sizeof(entry)
        );

    //
    //  Set log entry members.
    //

    entry.NewRefCount = NewRefCount;
    entry.Context = Context;
    entry.Thread = GetCurrentThreadId();
    entry.Context1 = Context1;
    entry.Context2 = Context2;
    entry.Context3 = Context3;

    //
    // Capture the stack backtrace. Normally, we skip two stack frames:
    // one for this routine, and one for IISCaptureStackBackTrace() itself.
    // For non-Ex callers who come in via WriteRefTraceLog,
    // we skip three stack frames.
    //

    if (    entry.Context1 == REF_TRACE_EMPTY_CONTEXT
         && entry.Context2 == REF_TRACE_EMPTY_CONTEXT
         && entry.Context3 == REF_TRACE_EMPTY_CONTEXT
         ) {

         cStackFramesSkipped = 2;

    } else {

         cStackFramesSkipped = 1;

    }

    IISCaptureStackBackTrace(
        cStackFramesSkipped,
        REF_TRACE_LOG_STACK_DEPTH,
        entry.Stack,
        &hash
        );

    //
    // Write it to the log.
    //

    return WriteTraceLog(
        Log,
        &entry
        );

}   // WriteRefTraceLogEx

#pragma optimize( "", on )      // restore frame pointer omission (FPO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\pipedata.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pipedata.cxx

Abstract:

    Imlementation of encapsulation of message passing over named pipes.

    IPM_MESSAGEs are delivered messages from the other side of the pipe
    IPM_MESSAGE_ACCEPTORs is the interface clients of this API must implement

    IPM_MESSAGE_PIPE is the creation, deletion, and write interface for this API

    Threading: 
        It is valid to call the API on any thread
        Callbacks can occur on an NT thread, or on the thread that was calling into the API.

Author:

    Jeffrey Wall (jeffwall)     9/12/2001

Revision History:

--*/

#include "precomp.hxx"
#include "pipedata.hxx"
#include "pipedatap.hxx"

/***************************************************************************++

Routine Description:

    Wrap ReadFile with a slightly nicer semantic
    Signal the event in pOverlapped if rountine completes inline
    
Arguments:

    hFile       - the file handle
    pBuffer     - buffer that gets the bytes
    cbBuffer    - size of the buffer
    pOverlapped - overlapped i/o thingy
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IpmReadFile(
    HANDLE       hFile,
    PVOID        pBuffer,
    DWORD        cbBuffer,
    LPOVERLAPPED pOverlapped
    )
{
    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT,
            "IpmReadFile called with hFile=%d, pBuffer=%p, cbBuffer=%d, pOvl=%p\n",
            hFile,
            pBuffer,
            cbBuffer,
            pOverlapped
            ));
    }
    
    BOOL fRet;
    fRet = ReadFile(hFile, 
                    pBuffer,
                    cbBuffer,
                    NULL,
                    pOverlapped); //ReadFile
    if (FALSE == fRet)
    {
        // io may be pending
        if (ERROR_IO_PENDING == GetLastError())
        {
            return S_OK;
        }
        if (ERROR_MORE_DATA == GetLastError())
        {
            // the call completed inline, but the read size was greater than the buffer passed in
            SetEvent(pOverlapped->hEvent);
            return S_OK;
            
        }
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
    
}


/***************************************************************************++

Routine Description:

    Wrap WriteFile with a slightly nicer semantic.  
    Signal the event in pOverlapped if rountine completes inline
    
Arguments:

    hFile       - the file handle
    pBuffer     - buffer that has the bytes
    cbBuffer    - # of bytes in the buffer
    pOverlapped - overlapped i/o thingy
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IpmWriteFile(
    HANDLE       hFile,
    PVOID        pBuffer,
    DWORD        cbBuffer,
    LPOVERLAPPED pOverlapped
    )
{
    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT,
            "IpmWriteFile called with hFile=%d, pBuffer=%p, cbBuffer=%d, pOvl=%p\n",
            hFile,
            pBuffer,
            cbBuffer,
            pOverlapped
            ));
    }

    BOOL fRet;

    fRet = WriteFile(hFile,
                     pBuffer,
                     cbBuffer,
                     NULL,
                     pOverlapped); // WriteFile
    if (FALSE == fRet)
    {
        if (ERROR_IO_PENDING == GetLastError())
        {
            return S_OK;
        }
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

/***************************************************************************++

Routine Description:

    Construct IPM_MESSAGE_PIPE
    
Arguments:

    None
    
Return Value:

    void

--***************************************************************************/
IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPE() :
    m_hPipe(INVALID_HANDLE_VALUE),
    m_pAcceptor(NULL),
    m_cMessages(0),
    m_fServerSide(FALSE),
    m_hrDisconnect(S_OK),
    m_cAcceptorUseCount(0),
    m_fCritSecInitialized(FALSE)
{
    DBG_ASSERT(!IsValid());
    InitializeListHead(&m_listHead);
    m_dwSignature = IPM_MESSAGE_PIPE_SIGNATURE;
}

/***************************************************************************++

Routine Description:

    Destruct IPM_MESSAGE_PIPE
    
Arguments:

    None
    
Return Value:

    void

--***************************************************************************/
IPM_MESSAGE_PIPE::~IPM_MESSAGE_PIPE()
{
    DBG_ASSERT(IsValid());
    m_dwSignature = IPM_MESSAGE_PIPE_SIGNATURE_FREED;
    
    DBG_ASSERT(IsListEmpty(&m_listHead));

    if (m_fCritSecInitialized)
    {
        DeleteCriticalSection(&m_critSec);
        m_fCritSecInitialized = FALSE;
    }
    
    DBG_ASSERT(INVALID_HANDLE_VALUE == m_hPipe);
    
    DBG_ASSERT(NULL == m_pAcceptor);
    
    DBG_ASSERT(0 == m_cMessages);
}

BOOL 
IPM_MESSAGE_PIPE::IsValid()
{ 
    return (IPM_MESSAGE_PIPE_SIGNATURE == m_dwSignature); 
}

/***************************************************************************++

Routine Description:

    Increment counter for the number of outstanding messages
    
Arguments:

    None
    
Return Value:

    void

--***************************************************************************/
VOID 
IPM_MESSAGE_PIPE::IpmMessageCreated(IPM_MESSAGE_IMP * pMessage)
{
    DBG_ASSERT(IsValid());

    EnterCriticalSection(&m_critSec);

    InsertTailList(&m_listHead, pMessage->GetListEntry());

    LONG cMessages = InterlockedIncrement(&m_cMessages); 

    LeaveCriticalSection(&m_critSec);

    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT, "IPM_MESSAGE_PIPE::IpmMessageCreated m_cMessages = %d\n", cMessages));
    }
}

/***************************************************************************++

Routine Description:

    decrement counter for the number of outstanding messages
    
Arguments:

    None
    
Return Value:

    void

--***************************************************************************/
VOID 
IPM_MESSAGE_PIPE::IpmMessageDeleted(IPM_MESSAGE_IMP * pMessage) 
{ 
    DBG_ASSERT(IsValid());

    EnterCriticalSection(&m_critSec);

    RemoveEntryList(pMessage->GetListEntry());

    LONG cMessages = InterlockedDecrement(&m_cMessages); 
    
    LeaveCriticalSection(&m_critSec);

    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT, "IPM_MESSAGE_PIPE::IpmMessageDeleted m_cMessages = %d\n", cMessages));
    }
}
    
/***************************************************************************++

Routine Description:

    Create one end of the pipe, and wait for client side to connect, or issue the first client side read
    
Arguments:

    pAcceptor - callback message acceptor
    pszPipeName - name of pipe to create or connect to
    fServerSide - true, create the server side.  If false, create the client side.
    pSa - security attributes to create pipe with
    ppPipe - outgoing created pipe
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::CreateIpmMessagePipe(IPM_MESSAGE_ACCEPTOR * pAcceptor, // callback class
                                           LPCWSTR pszPipeName, // name of pipe
                                           BOOL fServerSide,  // TRUE for CreateNamedPipe, FALSE for CreateFile
                                           PSECURITY_ATTRIBUTES   pSa, // security attributes to apply to pipe
                                           IPM_MESSAGE_PIPE ** ppPipe)  // outgoing pipe
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;

    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT, "IPM_MESSAGE_PIPE::CreateMessagePipe called name=%S\n", pszPipeName));
    }
    
    IPM_MESSAGE_PIPE * pPipe = NULL;
    IPM_MESSAGE_IMP * pMessage = NULL;

    HANDLE hPipe = INVALID_HANDLE_VALUE;
    
    DBG_ASSERT(NULL != pAcceptor);
    DBG_ASSERT(NULL != pszPipeName);
    DBG_ASSERT(NULL != ppPipe);

    *ppPipe = NULL;

    pPipe = new IPM_MESSAGE_PIPE();
    if (NULL == pPipe)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::CreateMessagePipe failed allocation of IPM_MESSAGE_PIPE, hr = %x\n",
            hr
            ));
        goto exit;
    }

    
    fRet = InitializeCriticalSectionAndSpinCount(&pPipe->m_critSec, 
                              0x80000000 /* precreate event */ | IIS_DEFAULT_CS_SPIN_COUNT );
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    pPipe->m_fCritSecInitialized = TRUE;

    pPipe->m_pAcceptor = pAcceptor;
    pPipe->m_fServerSide = fServerSide;
    
    if (fServerSide)
    {
        // call create named pipe, place pipe in message mode, and call ConnectPipe to wait for client connection
        hPipe = CreateNamedPipe( pszPipeName,
                                 PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
                                 PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
                                 1, // maximum number of instances
                                 4096, // out buffer size advisory
                                 4096, // in buffer size advisory
                                 0, // default creation timeout
                                 pSa // security attributes
                                 ); // CreateNamedPipe
    
        if (INVALID_HANDLE_VALUE == hPipe)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::CreateMessagePipe failed CreateNamedPipe, hr = %x\n",
                hr
                ));
            goto exit;
        }

        hr = IPM_MESSAGE_IMP::CreateMessage(&pMessage, pPipe);
        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::CreateMessagePipe failed CreateMessage, hr = %x\n",
                hr
                ));
            goto exit;
        }
        pMessage->SetMessageType(IPM_MESSAGE_IMP_CONNECT);
        
        // IPM_MESSAGE_PIPE now owns this pipe handle
        pPipe->m_hPipe = hPipe;
        hPipe = INVALID_HANDLE_VALUE;
        
        if (!ConnectNamedPipe(pPipe->m_hPipe, 
                              pMessage->GetOverlapped()))
        {
            DWORD dwError = GetLastError();
            if (ERROR_IO_PENDING != dwError)
            {
                hr = HRESULT_FROM_WIN32(dwError);
                DBGPRINTF((DBG_CONTEXT,
                    "IPM_MESSAGE_PIPE::CreateMessagePipe failed ConnectNamedPipe, hr = %x\n",
                    hr
                    ));
                goto exit;
            }
        }
        else
        {
            DBG_ASSERT(!"Unexpected - pipe is connected prior to creation of worker process");
            hr = E_FAIL;
            goto exit;
        }

        // ConnectNamedPipe now has responsibility for releasing the message reference on IO completion
        pMessage = NULL;
    }
    else // if fServerSide
    {
        // call create file, place pipe in message mode, and call pAcceptor->PipeConnected (it is at CreateFile success)

        hPipe = CreateFile( pszPipeName,
                            GENERIC_READ | GENERIC_WRITE,
                            0, // no sharing
                            pSa, // security descriptor
                            OPEN_EXISTING,
                            FILE_FLAG_OVERLAPPED,
                            NULL // no template file
                            ); // CreateFile
        if (INVALID_HANDLE_VALUE == hPipe)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::CreateMessagePipe failed CreateFile, hr = %x\n",
                hr
                ));
            goto exit;
        }
        
        //
        // Place pipe is message mode
        //
        DWORD dwReadModeFlag = PIPE_READMODE_MESSAGE;
        if (!SetNamedPipeHandleState(hPipe, &dwReadModeFlag, NULL, NULL)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::CreateMessagePipe failed SetNamedPipeHandleState, hr = %x\n",
                hr
                ));
            goto exit;
        }

        // IPM_MESSAGE_PIPE now owns this pipe handle
        pPipe->m_hPipe = hPipe;
        hPipe = INVALID_HANDLE_VALUE;
        
        pPipe->m_pAcceptor->PipeConnected();
        
        //
        // issue the first read, guess a reasonable first size
        //
        hr = pPipe->ReadMessage(g_dwDefaultReadSize);
        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::CreateMessagePipe failed ReadMessage, hr = %x\n",
                hr
                ));
            goto exit;
        }
        
    } // if fServerSide

    // function caller now owns this IPM_MESSAGE_PIPE
    *ppPipe = pPipe;
    pPipe = NULL;
    
    DBG_ASSERT(S_OK == hr);
exit:
    if (pMessage)
    {
        pMessage->DereferenceMessage();
        pMessage = NULL;
    }

    if (hPipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hPipe);
        hPipe = INVALID_HANDLE_VALUE;
    }

    if (pPipe)
    {
        if (pPipe->m_hPipe != INVALID_HANDLE_VALUE)
        {
            CloseHandle(pPipe->m_hPipe);
            pPipe->m_hPipe = INVALID_HANDLE_VALUE;
        }
        pPipe->m_pAcceptor = NULL;
        delete pPipe;
    }
    
    return hr;
}

/***************************************************************************++

Routine Description:

    destroy the MESSAGE_PIPE
    rountine does not return until all MESSAGEs are delivered / destroyed
    
Arguments:

    None
    
Return Value:

    void

--***************************************************************************/
VOID
IPM_MESSAGE_PIPE::DestroyIpmMessagePipe()
{
    DBG_ASSERT(IsValid());

    DWORD dwSleepCount = 0;
    
    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::DestroyMessagePipe called this=%p\n",
            this
            ));
    }

    if (m_hPipe != INVALID_HANDLE_VALUE)
    {
        if (m_fServerSide)
        {
            DBG_REQUIRE(TRUE == DisconnectNamedPipe(m_hPipe));
        }
        else
        {
            // on the client side, we can't force a disconnect any other way
            CloseHandle(m_hPipe);
            m_hPipe = INVALID_HANDLE_VALUE;
        }
    }

    EnterCriticalSection(&m_critSec);
    
    while(m_cMessages || m_cAcceptorUseCount)
    {
        DBGPRINTF((DBG_CONTEXT, "IPM_MESSAGE_PIPE::DestroyIpmMessagePipe waiting for messages to drain, %d\n", dwSleepCount));

        LeaveCriticalSection(&m_critSec);
        if (dwSleepCount < 10)
        {
            // if we are under one second of waiting, sleep for a short time
            Sleep(100);
        }
        else
        {
            // we've been waiting longer, sleep for one second
            Sleep(1000);
        }
        EnterCriticalSection(&m_critSec);

        dwSleepCount++;
    }

    DBG_ASSERT(IsListEmpty(&m_listHead));
    DBG_ASSERT(0 == m_cAcceptorUseCount);

    LeaveCriticalSection(&m_critSec);
    
    DBG_ASSERT(IsListEmpty(&m_listHead));
    DBG_ASSERT(0 == m_cAcceptorUseCount);

    if (m_hPipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hPipe);
        m_hPipe = INVALID_HANDLE_VALUE;
    }
    
    // Notify the acceptor (if it hasn't already been notified) that the pipe has been ended
    NotifyPipeDisconnected(HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE));

    delete this;
    
    return;
}

/***************************************************************************++

Routine Description:

    Notify the MESSAGE_ACCEPTOR when the pipe has disconnected. 
    Makes sure to only notify disconnect exactly once.
    
Arguments:

    hrError - error the pipe disconnected with
    
Return Value:

    void

--***************************************************************************/
VOID
IPM_MESSAGE_PIPE::NotifyPipeDisconnected(HRESULT hrError)
{
    DBG_ASSERT(IsValid());

    IPM_MESSAGE_ACCEPTOR * pAcceptor = NULL;
    
    EnterCriticalSection(&m_critSec);

    if (0 == m_cAcceptorUseCount)
    {
        if (m_pAcceptor)
        {
            pAcceptor = m_pAcceptor;
            m_pAcceptor = NULL;
        }
    }
    else if (SUCCEEDED(m_hrDisconnect))
    {
        // The acceptor is currently being used.  Therefore, we save away the HRESULT 
        // that we need to call disconnect with once the acceptor refcount drops
        m_hrDisconnect = hrError;
    }
    
    LeaveCriticalSection(&m_critSec);

    // do this outside of the critsec, to avoid holding the critsec across function calls to unknown functions
    if (pAcceptor)
    {
        pAcceptor->PipeDisconnected(hrError);
        pAcceptor = NULL;
    }
    
    return;
}

VOID
IPM_MESSAGE_PIPE::IncrementAcceptorInUse()
{
    DBG_ASSERT(IsValid());
    
    EnterCriticalSection(&m_critSec);

    m_cAcceptorUseCount++;

    LeaveCriticalSection(&m_critSec);

    return;
}

VOID
IPM_MESSAGE_PIPE::DecrementAcceptorInUse()
{
    DBG_ASSERT(IsValid());

    IPM_MESSAGE_ACCEPTOR * pAcceptor = NULL;

    EnterCriticalSection(&m_critSec);

    // if the acceptorusecount is one, this is the only message currently
    // using the acceptor.  If m_hrDisconnect is FAILED, then 
    // NotifyPipeDisconnected has been called at least once.
    if (1 == m_cAcceptorUseCount &&
       FAILED(m_hrDisconnect))
    {
        pAcceptor = m_pAcceptor;
        m_pAcceptor = NULL;
    }

    LeaveCriticalSection(&m_critSec);

    // do this outside of the critsec, to avoid holding the critsec across function calls to unknown functions
    if (pAcceptor)
    {
        pAcceptor->PipeDisconnected(m_hrDisconnect);
        pAcceptor = NULL;
    }

    EnterCriticalSection(&m_critSec);

    // do this after the notify disconnect to prevent DestroyIpmMessagePipe
    // from returning too early in shutdown cases
    m_cAcceptorUseCount--;

    LeaveCriticalSection(&m_critSec);

    // don't touch anything!
    // This object could be deleted after the LeaveCriticalSection
    
    return;
}

/***************************************************************************++

Routine Description:

    Issues an overlapped read on the pipe of a given size
    
Arguments:

    dwSize - byte size to issue read for
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::ReadMessage(DWORD dwSize)
{
    DBG_ASSERT(IsValid());
    HRESULT hr = S_OK;
    IPM_MESSAGE_IMP * pMessage = NULL;

    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::ReadMessage called with size=%d\n",
            dwSize
            ));
    }
    
    hr = IPM_MESSAGE_IMP::CreateMessage(&pMessage, this);
    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::ReadMessage failed CreateMessage, hr = %x\n",
            hr
            ));
        goto exit;
    }
    
    pMessage->SetMessageType(IPM_MESSAGE_IMP_READ);

    hr = pMessage->AllocateDataLength(dwSize);
    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::ReadMessage failed allocation of Read Buffer, hr = %x, size = %d\n",
            hr,
            dwSize
            ));
        goto exit;
    }

    // take a reference on the message for the I/O completion to have    
    pMessage->ReferenceMessage();

    hr = IpmReadFile(m_hPipe,
                     pMessage->GetRealDataPtr(),
                     dwSize,
                     pMessage->GetOverlapped());
    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::ReadMessage failed IpmReadFile, hr = %x\n",
            hr
            ));

        // release the reference that the I/O completion would have released
        pMessage->DereferenceMessage();

        goto exit;
    }

    DBG_ASSERT(S_OK == hr);

exit:

    if (pMessage)
    {
        pMessage->DereferenceMessage();
        pMessage = NULL;
    }

    if (FAILED(hr))
    {
        NotifyPipeDisconnected(hr);
    }
    
    return hr;
}

/***************************************************************************++

Routine Description:

    Issues an overlapped write to the named pipe 
        containing the opcode and data in one message
    
Arguments:

    opcode - IPM_OPCODE that this message is
    dwDataLen - size of the data to push over the pipe
    pbData - pointer to the data
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::WriteMessage(IPM_OPCODE opcode,
                                DWORD dwDataLen,
                                LPVOID pbData)
{
    DBG_ASSERT(IsValid());
    HRESULT hr = S_OK;
    IPM_MESSAGE_IMP * pMessage = NULL;
    DWORD dwWriteSize = dwDataLen + OPCODE_SIZE;
    
    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::WriteMessage called with opcode=%d, len=%d, writesize=%d\n",
            opcode,
            dwDataLen,
            dwWriteSize
            ));
    }
    
    hr = IPM_MESSAGE_IMP::CreateMessage(&pMessage, this);
    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::WriteMessage failed CreateMessage, hr = %x\n",
            hr
            ));
        goto exit;
    }

    pMessage->SetMessageType(IPM_MESSAGE_IMP_WRITE);

    hr = pMessage->AllocateDataLength(dwWriteSize);
    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::WriteMessage failed allocation of WriteBuffer, hr = %x, size=%d\n",
            hr,
            dwWriteSize
            ));
        goto exit;
    }

    // first zero the message header
    ZeroMemory(pMessage->GetRealDataPtr(), OPCODE_SIZE);

    // Write the opcode into the beginning of the message header
    memcpy(pMessage->GetRealDataPtr(), &opcode, sizeof(opcode));

    // verify that we both have a size of data and a data pointer to copy from
    if (dwDataLen && pbData)
    {
        // finally copy over the real data
        memcpy(pMessage->GetRealDataPtr() + OPCODE_SIZE, pbData, dwDataLen);
    }
    
    pMessage->SetDataLen(dwWriteSize);

    // take a reference on the message for the I/O completion to have    
    pMessage->ReferenceMessage();

    hr = IpmWriteFile(m_hPipe,
                      pMessage->GetRealDataPtr(),
                      dwWriteSize,
                      pMessage->GetOverlapped());
    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::WriteMessage failed IpmWriteFile, hr = %x\n",
            hr
            ));

        // release the reference that the I/O completion would have released
        pMessage->DereferenceMessage();

        goto exit;
    }

    DBG_ASSERT(S_OK == hr);

exit:
    if (pMessage)
    {
        pMessage->DereferenceMessage();
        pMessage = NULL;
    }
    
    if (FAILED(hr))
    {
        NotifyPipeDisconnected(hr);
    }

    return hr;
}

/***************************************************************************++

Routine Description:

    Creates and sets up an IPM_MESSAGE_IMP for use by IPM_MESSAGE_PIPE
    
Arguments:

    ppMessage - outgoing IPM_MESSAGE_IMP
    pPipe - pipe to associate this MESSAGE_IMP with
    
Return Value:

    HRESULT

--***************************************************************************/
//static 
HRESULT
IPM_MESSAGE_IMP::CreateMessage(IPM_MESSAGE_IMP ** ppMessage, IPM_MESSAGE_PIPE * pPipe)
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    IPM_MESSAGE_IMP * pMessage = NULL;
    HANDLE hEvent = NULL;
    HANDLE hRegisteredWait = NULL;
    
    DBG_ASSERT(NULL != ppMessage);
    *ppMessage = NULL;
    
    pMessage = new IPM_MESSAGE_IMP(pPipe);
    if (NULL == pMessage)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::CreateMessage failed allocation of IPM_MESSAGE_IMP, hr = %x\n",
            hr
            ));
        goto exit;
    }

    hEvent = CreateEvent(NULL, // security
                         TRUE, // manual reset
                         FALSE, // initial state - not signaled
                         NULL); // no name
    if (NULL == hEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::CreateMessage failed CreateEvent, hr = %x\n",
            hr
            ));
        goto exit;
    }

    pMessage->GetOverlapped()->hEvent = hEvent;
    // pMessage now owns the handle
    hEvent = NULL;    
    
    fRet = RegisterWaitForSingleObject(&hRegisteredWait,
                                       pMessage->GetOverlapped()->hEvent,
                                       IPM_MESSAGE_PIPE::MessagePipeCompletion,
                                       pMessage,
                                       INFINITE,
                                       WT_EXECUTEONLYONCE);
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::CreateMessage failed RegisterWaitForSingleObject, hr = %x\n",
            hr
            ));
        goto exit;
    }

    // pMessage now owns this handle
    pMessage->SetRegisteredWait(hRegisteredWait);
    hRegisteredWait = NULL;
    
    // take the outbound reference on the message
    pMessage->ReferenceMessage();
    *ppMessage = pMessage;
    
    pMessage = NULL;
    
    DBG_ASSERT(S_OK == hr);

exit:
    if (hEvent)
    {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
    if (hRegisteredWait)
    {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
    if (pMessage)
    {
        delete pMessage;
        pMessage = NULL;
    }
    
    return hr;  
}


/***************************************************************************++

Routine Description:

    Validate data read from the pipe conforms to expected sizing for the type of data
        
Arguments:

    pMessage - message read in
    dwNumBytesTransferred - number of bytes taken from pipe
    fServerSide - if this is a server side pipe
    
Return Value:

    BOOL

--***************************************************************************/
BOOL
IsReadDataOk( IPM_MESSAGE_IMP * pMessage, DWORD dwNumBytesTransferred, BOOL fServerSide )
{
    if (pMessage->GetMessageType() == IPM_MESSAGE_IMP_READ)
    {
        //
        // Do some size validation
        //
        if ( dwNumBytesTransferred < sizeof(IPM_OPCODE) ||
             dwNumBytesTransferred < OPCODE_SIZE )
        {
            // We received a write that doesn't even have enough bytes for an opcode
            // or the number of bytes transferred didn't meet the OPCODE_SIZE mininmum imposed
            // in WriteMessage
            DBGPRINTF((DBG_CONTEXT, "size validation failed on: %d\n", dwNumBytesTransferred));
            return FALSE;
        }

        //
        // Do some data type validation
        //
        if ( pMessage->GetOpcode() <= IPM_OP_MINIMUM || 
             pMessage->GetOpcode() >= IPM_OP_MAXIMUM )
        {
            // The opcode was out of line with anything reasonable
            DBGPRINTF((DBG_CONTEXT, "data validation failed on: %d\n", pMessage->GetOpcode() ));
            return FALSE;
        }

        //
        // Do some max size validation
        //
        if ( pMessage->GetDataLen() > MAXLONG )
        {
            // The size of the data was too big regardless of the type
            DBGPRINTF((DBG_CONTEXT, "max size validation failed on: %d %d\n", pMessage->GetOpcode(), pMessage->GetDataLen() ));
            return FALSE;            
        }
        
        //
        // Do some data type and data size validation
        //
        if ( pMessage->GetDataLen() != IPM_OP_DATA_SIZE[pMessage->GetOpcode()].sizeMaximumAndRequiredSize &&
             IPM_OP_DATA_SIZE[pMessage->GetOpcode()].sizeMaximumAndRequiredSize != MAXLONG )
        {
            // The size of the data was too big for the type of data being reported
            DBGPRINTF((DBG_CONTEXT, "data type + data size validation failed on: %d %d\n", pMessage->GetOpcode(), pMessage->GetDataLen() ));
            return FALSE;
        }

        //
        // Do some server side expectation validation
        //
        if ( (fServerSide && !IPM_OP_DATA_SIZE[pMessage->GetOpcode()].fServerSideExpectsThisMessage) ||
             (!fServerSide && IPM_OP_DATA_SIZE[pMessage->GetOpcode()].fServerSideExpectsThisMessage) )
        {
            // the metadata did not have this as a valid message to receive for this side of the pipe
            DBGPRINTF((DBG_CONTEXT, "server side validation failed on: %d \n", pMessage->GetOpcode() ));
            return FALSE;
        }
    }

    return TRUE;

}


/***************************************************************************++

Routine Description:

    Read / Write / Connect completion routine

    Determines if Read / Write / Connect was successful.
    If so, notifies the MESSAGE_ACCEPTOR associated with the MESSAGE_PIPE that the MESSAGE
        is associated with.
    If Read was not of sufficient size, a new read is issued, and must complete inline.

    If the operation failed for any other reason, calls PipeDisconnected on MESSAGE_ACCEPTOR

    If operation was finally successful, AND it was a read or connect, issues a new read to continue
        getting data from the pipe.  This way, only one read is outstanding at any time
        
Arguments:

    pvoid - pointer to IPM_MESSAGE_IMP that completed
    TimerOrWaitFired - always FALSE
    
Return Value:

    void

--***************************************************************************/
//static 
VOID 
CALLBACK 
IPM_MESSAGE_PIPE::MessagePipeCompletion(LPVOID pvoid, 
                                                           BOOLEAN TimerOrWaitFired)
{
    DBG_ASSERT(NULL != pvoid);
    DBG_ASSERT(FALSE == TimerOrWaitFired);
    
    IF_DEBUG(PIPEDATA)
    {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPECompletion called with pv = %p\n",
            pvoid
            ));
    }
    
    HRESULT hr = S_OK;
    DWORD dwReadSize = 0;
    BOOL fDisconnect = FALSE;
    
    IPM_MESSAGE_IMP * pMessage = (IPM_MESSAGE_IMP*) pvoid;
    DBG_ASSERT(pMessage->IsValid());
    
    IPM_MESSAGE_PIPE * pThis = pMessage->GetMessagePipe();
    DBG_ASSERT(pThis->IsValid());

    // while this routine executes, make sure that the IPM_MESSAGE_PIPE doesn't go away
    // and that the acceptor stays valid (or invalid)
    pThis->IncrementAcceptorInUse();
    
    if (NULL == pThis->m_pAcceptor)
    {
        // can't callback to anything, therefore just get out
        goto done;
    }

    BOOL fRet = FALSE;
    DWORD dwNumBytesTransferred = 0;
    
    fRet = GetOverlappedResult(pThis->m_hPipe,
                               pMessage->GetOverlapped(),
                               &dwNumBytesTransferred,
                               FALSE);

    // we've been signaled that this IO is done.  Assert that.
    DBG_ASSERT(ERROR_IO_INCOMPLETE != GetLastError());

    if (TRUE == fRet)
    {
        //
        // begin handling the completely received message
        //
        IF_DEBUG(PIPEDATA)
        {
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPECompletion overlapped io succeeded numbytestransferred=%d\n",
                dwNumBytesTransferred
                ));
        }
        
        // successful completion occurred
        switch(pMessage->GetMessageType())
        {
        case IPM_MESSAGE_IMP_CONNECT:

            // notify the IPM_MESSAGE_PIPE client that the pipe is connected
            pThis->m_pAcceptor->PipeConnected();

            // and issue the first read for a reasonable size
            dwReadSize = g_dwDefaultReadSize;

            break;

        case IPM_MESSAGE_IMP_READ:

            // set the message's read length (it may have been less than what was allocated)
            pMessage->SetDataLen(dwNumBytesTransferred);

            if ( !IsReadDataOk(pMessage, dwNumBytesTransferred, pThis->m_fServerSide) )
            {
                pThis->m_pAcceptor->PipeMessageInvalid();
            }
            else
            {
                // notify the IPM_MESSAGE_PIPE client that a message has been received
                pThis->m_pAcceptor->AcceptMessage(pMessage);

                // and issue a new read for a reasonable size
                dwReadSize = g_dwDefaultReadSize;
            }

            
            break;

        case IPM_MESSAGE_IMP_WRITE:
            // do nothing
            break;

        default:
            DBG_ASSERT(!"Invalid completion!");
            break;
        }
    }
    else 
    {
        IF_DEBUG(PIPEDATA)
        {
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPECompletion overlapped io failed lasterror=%d\n",
                GetLastError()
                ));
        }

        // fRet == FALSE, ie GetOverlappedResult failed
        switch(pMessage->GetMessageType())
        {
        case IPM_MESSAGE_IMP_CONNECT:
        case IPM_MESSAGE_IMP_WRITE:
            // if a connect or a write fails, the pipe is declared dead
            fDisconnect = TRUE;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        case IPM_MESSAGE_IMP_READ:
            // a read could fail because the buffer passed was not large enough

            if (ERROR_MORE_DATA == GetLastError())
            {
                IF_DEBUG(PIPEDATA)
                {
                    DBGPRINTF((DBG_CONTEXT, "********ERROR_MORE_DATA path, dwNumBytesTransferred=%d\n", dwNumBytesTransferred));
                }
                // discover the size of the next message
                DWORD dwRemaining = 0;
                fRet = PeekNamedPipe(pThis->m_hPipe,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &dwRemaining); // PeekNamedPipe
                IF_DEBUG(PIPEDATA)
                {
                    DBGPRINTF((DBG_CONTEXT, "********dwRemaining = %d\n", dwRemaining));
                }
                if (FALSE == fRet)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    fDisconnect = TRUE;
                }
                else
                {
                    DWORD dwMessageSize = dwNumBytesTransferred + dwRemaining;
                    IF_DEBUG(PIPEDATA)
                    {
                        DBGPRINTF((DBG_CONTEXT, "********reallocating size = %d\n", dwMessageSize));
                    }
                    hr = pMessage->Reallocate(dwMessageSize);
                    if (FAILED(hr))
                    {
                        fDisconnect = TRUE;
                        break;
                    }

                    hr = IpmReadFile(pThis->m_hPipe,
                                     pMessage->GetRealDataPtr() + dwNumBytesTransferred,
                                     dwRemaining,
                                     pMessage->GetOverlapped());
                    if (FAILED(hr))
                    {
                        fDisconnect = TRUE;
                        break;
                    }
                    
//bugbug - assert that the readfile call completed inline

                    if ( !IsReadDataOk(pMessage, dwMessageSize, pThis->m_fServerSide) )
                    {
                        pThis->m_pAcceptor->PipeMessageInvalid();
                    }
                    else
                    {
                        // notify the IPM_MESSAGE_PIPE client that a message has been received
                        pThis->m_pAcceptor->AcceptMessage(pMessage);

                        // and issue a new read for a reasonable size
                        dwReadSize = g_dwDefaultReadSize;
                    }
                }
            }
            else
            {
                // the read failed for some other reason
                fDisconnect = TRUE;
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            break;
        }
            
    } // if (TRUE == GetOverlapped Result)

    // release the reference taken for this I/O competion.
    pMessage->DereferenceMessage();
    pMessage = NULL;

    // if there is another read to be done, do it
    if (dwReadSize)
    {
        IF_DEBUG(PIPEDATA)
        {
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPECompletion issuing read\n",
                dwNumBytesTransferred
                ));
        }

        DBG_ASSERT(!fDisconnect);
        
        hr = pThis->ReadMessage(dwReadSize);
        if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPECompletion ReadMessage failed hr=%x\n",
            hr
            ));
        
            // the read failed, need to disconnect the pipe
            fDisconnect = TRUE;
        }
    }

    // if there was an error, make sure to notify the acceptor
    if (fDisconnect)
    {
        IF_DEBUG(PIPEDATA)
        {
            DBGPRINTF((DBG_CONTEXT,
                "IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPECompletion disconnecting, hr=%x\n",
                hr
                ));
        }
        pThis->NotifyPipeDisconnected(hr);
    }

done:
    if (pMessage)
    {
        pMessage->DereferenceMessage();
        pMessage = NULL;
    }

    // Release the IPM_MESSAGE_PIPE reference we took at the beginning of this function
    pThis->DecrementAcceptorInUse();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\normalize.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     normalize.cxx

   Abstract:
     Normalize Url
 
   Author:
     jaroslad       9-12-2001

   Environment:
     Win32 - User Mode

   Project:
     IISUTIL.DLL
--*/

#include "precomp.hxx"
#include "normalize.hxx"

BOOL    g_fEnableNonUTF8;
BOOL    g_fEnableDBCS;
BOOL    g_fFavorDBCS;
BOOL    g_fIsSystemDBCS;

HRESULT
InitializeNormalizeUrl(
    VOID
)
{
    HKEY    hKey;
    DWORD   dwType;
    DWORD   dwData;
    DWORD   cbData;
    WORD    wPrimaryLangID;

    //
    // Read the registry settings on how to handle URLs
    //
    
    g_fEnableNonUTF8 = TRUE;
    g_fEnableDBCS = FALSE;
    g_fFavorDBCS = FALSE;
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\http\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        if ( RegQueryValueEx( hKey,
                              L"EnableNonUTF8",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            g_fEnableNonUTF8 = !!dwData;
        }
        
        if ( g_fEnableNonUTF8 )
        {
            if ( RegQueryValueEx( hKey,
                                  L"EnableDBCS",
                                  NULL,
                                  &dwType,
                                  (LPBYTE) &dwData,
                                  &cbData ) == ERROR_SUCCESS &&
                 dwType == REG_DWORD )
            {
                g_fEnableDBCS = !!dwData;
            }
        }
        else
        {
            g_fEnableDBCS = FALSE;
        }
        
        if ( g_fEnableDBCS )
        {
            if ( RegQueryValueEx( hKey,
                                  L"FavorDBCS",
                                  NULL,
                                  &dwType,
                                  (LPBYTE) &dwData,
                                  &cbData ) == ERROR_SUCCESS &&
                 dwType == REG_DWORD )
            {
                g_fFavorDBCS = !!dwData;
            }
        }
        else
        {
            g_fFavorDBCS = FALSE;
        }
        
        RegCloseKey( hKey );
    }


    wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    g_fIsSystemDBCS = ( wPrimaryLangID == LANG_JAPANESE ||
                        wPrimaryLangID == LANG_CHINESE  ||
                        wPrimaryLangID == LANG_KOREAN );

    return NO_ERROR;
}

//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000


//
//  Private globals.
//

INT p_StateTable[16] =
    {
        // state 0
        0 ,             // other
        0 ,             // "."
        4 ,             // EOS
        1 ,             // "\"

        //  state 1
        0 ,              // other
        2 ,             // "."
        4 ,             // EOS
        1 ,             // "\"

        // state 2
        0 ,             // other
        3 ,             // "."
        4 ,             // EOS
        1 ,             // "\"

        // state 3
        0 ,             // other
        0 ,             // "."
        4 ,             // EOS
        1               // "\"
    };



INT p_ActionTable[16] =
    {
        // state 0
            ACTION_EMIT_CH,             // other
            ACTION_EMIT_CH,             // "."
            ACTION_EMIT_CH,             // EOS
            ACTION_EMIT_CH,             // "\"

        // state 1
            ACTION_EMIT_CH,             // other
            ACTION_NOTHING,             // "."
            ACTION_EMIT_CH,             // EOS
            ACTION_NOTHING,             // "\"

        // state 2
            ACTION_EMIT_DOT_CH,         // other
            ACTION_NOTHING,             // "."
            ACTION_EMIT_CH,             // EOS
            ACTION_NOTHING,             // "\"

        // state 3
            ACTION_EMIT_DOT_DOT_CH,     // other
            ACTION_EMIT_DOT_DOT_CH,     // "."
            ACTION_BACKUP,              // EOS
            ACTION_BACKUP               // "\"
    };

// since max states = 4, we calculat the index by multiplying with 4.
# define IndexFromState( st)   ( (st) * 4)


// the following table provides the index for various ISA Latin1 characters
//  in the incoming URL.
// It assumes that the URL is ISO Latin1 == ASCII
INT  p_rgIndexForChar[] = {

    2,   // null char
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1 thru 10
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 11 thru 20
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 21 thru 30
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 31 thru 40
    0, 0, 0, 0, 0, 1, 3, 0, 0, 0,  // 41 thru 50  46 = '.' 47 = '/'
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 51 thru 60
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 61 thru 70
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 71 thru 80
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 81 thru 90
    0, 3, 0, 0, 0, 0, 0, 0, 0, 0,  // 91 thru 100  92 = '\\'
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 101 thru 110
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 111 thru 120
    0, 0, 0, 0, 0, 0, 0, 0         // 121 thru 128
};

#define IS_UTF8_TRAILBYTE(ch)      (((ch) & 0xc0) == 0x80)


/*******************************************************************

    NAME:       IsUTF8URL

    ENTRY:      pszPath - The path to sanitize.

    HISTORY:
        atsusk     06-Jan-1998 Created.

********************************************************************/

BOOL IsUTF8URL(CHAR * pszPath)
{
    CHAR    ch;

    if ( g_fFavorDBCS )
    {
        return ( MultiByteToWideChar( CP_ACP,
                                      MB_ERR_INVALID_CHARS,
                                      pszPath,
                                      -1,
                                      NULL,
                                      0) == 0);
    }

    while (ch = *pszPath++) {

        if (ch & 0x80) {
            wchar_t wch;
            int     iLen;
            BOOL    bDefault = FALSE;
            char    chTrail1;
            char    chTrail2;

            chTrail1 = *pszPath++;
            if (chTrail1) {
                chTrail2 = *pszPath;
            } else {
                chTrail2 = 0;
            }

            if ( ((ch & 0xF0) == 0xE0) &&
              IS_UTF8_TRAILBYTE(chTrail1) &&
              IS_UTF8_TRAILBYTE(chTrail2) ) {

                // handle three byte case
                // 1110xxxx 10xxxxxx 10xxxxxx
                wch = (wchar_t) (((ch & 0x0f) << 12) |
                                ((chTrail1 & 0x3f) << 6) |
                                (chTrail2 & 0x3f));
                pszPath++;

            } else
            if ( ((ch & 0xE0) == 0xC0) &&
              IS_UTF8_TRAILBYTE(chTrail1) ) {

                // handle two byte case
                // 110xxxxx 10xxxxxx

                wch = (wchar_t) (((ch & 0x1f) << 6) | (chTrail1 & 0x3f));

            } else
                return FALSE;

            iLen = WideCharToMultiByte( CP_ACP,
                                        0,
                                        &wch,
                                        1,
                                        NULL,
                                        0,
                                        NULL,
                                        &bDefault );

            if (bDefault == TRUE || iLen == 0 || iLen > 2)
                return FALSE;
        }
    }

    return TRUE;
}   // IsUTF8URL()


/*******************************************************************

    NAME:       CanonURL

    SYNOPSIS:   Sanitizes a path by removing bogus path elements.

                As expected, "/./" entries are simply removed, and
                "/../" entries are removed along with the previous
                path element.

                To maintain compatibility with URL path semantics
                 additional transformations are required. All backward
                 slashes "\\" are converted to forward slashes. Any
                 repeated forward slashes (such as "///") are mapped to
                 single backslashes.

                A state table (see the p_StateTable global at the
                beginning of this file) is used to perform most of
                the transformations.  The table's rows are indexed
                by current state, and the columns are indexed by
                the current character's "class" (either slash, dot,
                NULL, or other).  Each entry in the table consists
                of the new state tagged with an action to perform.
                See the ACTION_* constants for the valid action
                codes.

    ENTRY:      pszPath - The path to sanitize.
                fIsDBCSLocale - Indicates the server is in a
                    locale that uses DBCS.

    HISTORY:
        KeithMo     07-Sep-1994 Created.
        MuraliK     28-Apr-1995 Adopted this for symbolic paths

********************************************************************/
INT
CanonURL(
    CHAR * pszPath,
    BOOL   fIsDBCSLocale
    )
{
    UCHAR * pszSrc;
    UCHAR * pszDest;
    DWORD ch;
    INT   index;
    BOOL  fDBCS = FALSE;
    DWORD cchMultiByte = 0;

    DBG_ASSERT( pszPath != NULL );

    //
    // Always look for UTF8 except when DBCS characters are detected
    //
    BOOL fScanForUTF8 = IsUTF8URL(pszPath);

    // If fScanForUTF8 is true, this URL is UTF8. don't recognize DBCS.
    if (fIsDBCSLocale && fScanForUTF8) {
        fIsDBCSLocale = FALSE;
    }

    //
    //  Start our scan at the first character
    //

    pszSrc = pszDest = (UCHAR *) pszPath;

    //
    //  State 0 is the initial state.
    //
    index = 0; // State = 0

    //
    //  Loop until we enter state 4 (the final, accepting state).
    //

    do {

        //
        //  Grab the next character from the path and compute its
        //  next state.  While we're at it, map any forward
        //  slashes to backward slashes.
        //

        index = IndexFromState( p_StateTable[index]); // 4 = # states
        ch = (DWORD ) *pszSrc++;

        //
        //  If this is a DBCS trailing byte - skip it
        //

        if ( !fIsDBCSLocale )
        {
            index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);
        }
        else
        {
            if ( fDBCS )
            {
                //
                // If this is a 0 terminator, we need to set next
                // state accordingly
                //

                if ( ch == 0 )
                {
                    index += p_rgIndexForChar[ ch ];
                }

                //
                // fDBCS == TRUE means this byte was a trail byte.
                // index is implicitly set to zero.
                //
                fDBCS = FALSE;
            }
            else
            {
                index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);

                if ( IsDBCSLeadByte( (UCHAR)ch ) )
                {
                    //
                    // This is a lead byte, so the next is a trail.
                    //
                    fDBCS = TRUE;
                }
            }
        }

        //
        //  Interesting UTF8 characters always have the top bit set
        //

        if ( (ch & 0x80) && fScanForUTF8 )
        {
            wchar_t wch;
            UCHAR mbstr[2];

            //
            //  This is a UTF8 character, convert it here.
            //  index is implicitly set to zero.
            //
            if ( cchMultiByte < 2 )
            {
                char chTrail1;
                char chTrail2;

                chTrail1 = *pszSrc;
                if (chTrail1) {
                    chTrail2 = *(pszSrc+1);
                } else {
                    chTrail2 = 0;
                }
                wch = 0;

                if ((ch & 0xf0) == 0xe0)
                {
                    // handle three byte case
                    // 1110xxxx 10xxxxxx 10xxxxxx

                    wch = (wchar_t) (((ch & 0x0f) << 12) |
                                     ((chTrail1 & 0x3f) << 6) |
                                     (chTrail2 & 0x3f));

                    cchMultiByte = WideCharToMultiByte( CP_ACP,
                                                        0,
                                                        &wch,
                                                        1,
                                                        (LPSTR) mbstr,
                                                        2,
                                                        NULL,
                                                        NULL );

                    ch = mbstr[0];
                    pszSrc += (3 - cchMultiByte);

                    // WinSE 12843: Security Fix, Index should be updated for this character
                    index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);

                } else if ((ch & 0xe0) == 0xc0)
                {
                    // handle two byte case
                    // 110xxxxx 10xxxxxx

                    wch = (wchar_t) (((ch & 0x1f) << 6) | (chTrail1 & 0x3f));

                    cchMultiByte = WideCharToMultiByte( CP_ACP,
                                                        0,
                                                        &wch,
                                                        1,
                                                        (LPSTR) mbstr,
                                                        2,
                                                        NULL,
                                                        NULL );

                    ch = mbstr[0];
                    pszSrc += (2 - cchMultiByte);

                    // WinSE 12843: Security Fix, Index should be updated for this character
                    index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);
                }

            } else {
                //
                // get ready to emit 2nd byte of converted character
                //
                ch = mbstr[1];
                cchMultiByte = 0;
            }
        }


        //
        //  Perform the action associated with the state.
        //

        switch( p_ActionTable[index] )
        {
        case ACTION_EMIT_DOT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_CH :
            *pszDest++ = (CHAR ) ch;
            /* fall through */

        case ACTION_NOTHING :
            break;

        case ACTION_BACKUP :
            if( (pszDest > ( (UCHAR *) pszPath + 1 ) ) && (*pszPath == '/'))
            {
                pszDest--;
                DBG_ASSERT( *pszDest == '/' );

                *pszDest = '\0';
                pszDest = (UCHAR *) strrchr( pszPath, '/') + 1;
            }

            *pszDest = '\0';
            break;

        default :
            DBG_ASSERT( !"Invalid action code in state table!" );
            index = IndexFromState(0) + 2;    // move to invalid state
            DBG_ASSERT( p_StateTable[index] == 4);
            *pszDest++ = '\0';
            break;
        }

    } while( p_StateTable[index] != 4 );

    //
    // point to terminating nul
    //
    if (p_ActionTable[index] == ACTION_EMIT_CH) {
        pszDest--;
    }

    DBG_ASSERT(*pszDest == '\0' && pszDest > (UCHAR*) pszPath);

    return DIFF(pszDest - (UCHAR*)pszPath);
}   // CanonURL()



HRESULT
NormalizeUrl(
    LPSTR   pszStart
    )
/*++

Routine Description:

    Normalize URL

Arguments:

    strUrl - URL to be updated to a canonical URI

Return value:

    TRUE if no error, otherwise FALSE

--*/
{
    CHAR * pchParams;
    CHAR * pch;
    CHAR * pszACU;
    CHAR   chParams;
    LPSTR   pszSlash;
    LPSTR   pszURL;
    LPSTR   pszValue;
    BOOL    fSt;
    STACK_STRA( strChgUrl, MAX_PATH );
    HRESULT hr;
    DWORD   cchInput;

    if ( pszStart == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    cchInput = strlen( pszStart );

    if ( *pszStart != '/' )
    {
        //
        // assume HTTP URL, skip protocol & host name by
        // searching for 1st '/' following "//"
        //
        // We handle this information as a "Host:" header.
        // It will be overwritten by the real header if it is
        // present.
        //
        // We do not check for a match in this case.
        //

        if ( (pszSlash = strchr( pszStart, '/' )) && pszSlash[1] == '/' )
        {
            pszSlash += 2;
            if ( pszURL = strchr( pszSlash, '/' ) )
            {
                //
                // update pointer to URL to point to the 1st slash
                // following host name
                //

                pszValue = pszURL;
            }
            else
            {
                //
                // if no single slash following host name
                // consider the URL to be empty.
                //

                pszValue = pszSlash + strlen( pszSlash );
            }

            memmove( pszStart, pszValue, strlen(pszValue)+1 );
        }

        //
        // if no double slash, this is not a fully qualified URL
        // and we leave it alone.
        //
    }

    //
    //  Check for a question mark which indicates this URL contains some
    //  parameters and break the two apart if found
    //

    if ( (pchParams = strchr( pszStart, '?' )) )
    {
        *pchParams = '\0';
    }

    //
    // Unescape wants a STR ( sigh )
    //

    hr = strChgUrl.Copy( (CHAR*)pszStart );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = strChgUrl.Unescape();

    if ( FAILED( hr ) )
    {
        return hr;
    }

    strncpy( pszStart, strChgUrl.QueryStr(), cchInput );
    pszStart[cchInput] = '\0';

    //
    //  Canonicalize the URL
    //

    CanonURL( pszStart, g_fIsSystemDBCS );

    return NO_ERROR;
}




HRESULT
NormalizeUrlOld(
    LPSTR    pszUrl
)
/*++

Routine Description:

    NormalizeUrl wrapper (used by ISAPI filter and extension support functions)

Parameters:

    pszUrl           - On entry, the URL to be normalized
                       On return, the normalized URL
                       (size of normalized URL is always <= not normalized URL)
   
Return Value:
    
    HRESULT

--*/
{
    HRESULT hr = NO_ERROR;
    
    if ( pszUrl )
    {
        STACK_BUFFER( buffUrlOutput, MAX_PATH );
        STACK_STRA(   strUrlA, MAX_PATH );
        LPWSTR        szQueryString;
        DWORD         cchData;
        DWORD         cbOutput;

        cchData = strlen( pszUrl );

        //
        // Prepare the Output string
        //
        
        if ( !buffUrlOutput.Resize( ( cchData + 1 ) *sizeof( WCHAR ) ) )  
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        //
        // Normalize it
        //

        hr = UlCleanAndCopyUrl(
            (PUCHAR)pszUrl,
            cchData,
            &cbOutput,
            (WCHAR *) buffUrlOutput.QueryPtr(),
            &szQueryString
            );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Terminate the string at the query so that the
        // query string doesn't appear in the output.  IIS 5
        // truncated in this way.
        //

        if ( szQueryString != NULL )
        {
            ((WCHAR *) buffUrlOutput.QueryPtr())[ cbOutput - wcslen( szQueryString )] = 0;
        }

        //
        // Write the normalized URL over the input data
        //

        hr = strUrlA.CopyW( (WCHAR *) buffUrlOutput.QueryPtr() );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Normalized string will never be longer than the original one
        //
        
        DBG_ASSERT( strUrlA.QueryCCH() <= cchData );

        strcpy( pszUrl, strUrlA.QueryStr() );

        hr = NO_ERROR;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    return hr;
}


HRESULT
NormalizeUrlW(
    LPWSTR    pszUrl
)
/*++

Routine Description:

    unicode version of NormalizeUrl wrapper (used by ISAPI filter and extension support functions)

Parameters:

    pszUrl           - On entry, the URL to be normalized
                       On return, the normalized URL
                       (size of normalized URL is always <= not normalized URL)
   
Return Value:
    
    HRESULT

--*/
{

    HRESULT hr = NO_ERROR;
    
    if ( pszUrl )
    {
        STACK_BUFFER( buffUrlOutput, MAX_PATH );
        STACK_STRA(   strUrlA, MAX_PATH );
        LPWSTR        szQueryString;
        DWORD         cchData;
        DWORD         cbOutput;

        cchData = wcslen( pszUrl );

        hr = strUrlA.CopyWToUTF8( pszUrl );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Prepare Output string
        //
        
        if ( !buffUrlOutput.Resize( ( cchData + 1 ) *sizeof( WCHAR ) ) )  
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        //
        // Normalize it
        //

        hr = UlCleanAndCopyUrl(
            (PUCHAR)strUrlA.QueryStr(),
            strUrlA.QueryCB(),
            &cbOutput,
            (WCHAR *) buffUrlOutput.QueryPtr(),
            &szQueryString
            );

        if ( FAILED( hr ) )
        {
            return hr;
        }


        //
        // Terminate the string at the query so that the
        // query string doesn't appear in the output.  IIS 5
        // truncated in this way.
        //

        if ( szQueryString != NULL )
        {
            ((WCHAR *) buffUrlOutput.QueryPtr())[ cbOutput - wcslen( szQueryString )] = 0;
        }

        //
        // normalized string will never be longer than the original one
        //

        DBG_ASSERT( cbOutput <= cchData * sizeof( WCHAR )  );

        //
        // Write the normalized URL over the input data
        //

        wcscpy( pszUrl, (WCHAR *) buffUrlOutput.QueryPtr() );

        hr = NO_ERROR;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\resource.cxx ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

--*/

#include "precomp.hxx"

#include "dbgutil.h"
# include "irtlmisc.h"
#include <tsres.hxx>

//
//  The semaphore wait time before retrying the wait
//

#define INET_RES_TIMEOUT            (2 * 60 * 1000)

# define InetResPrint( s)  \
{ CHAR buff[256];  \
  wsprintfA s ; \
  OutputDebugStringA( buff);  \
}

#if DBG
LONG g_InetResourcesCreated = 0;
LONG g_InetResourcesDeleted = 0;
#endif



extern "C"
BOOL
InetInitializeResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{

    PLATFORM_TYPE platformType;

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction.
    //

    if( !INITIALIZE_CRITICAL_SECTION( &Resource->CriticalSection ) )
    {
        return FALSE;
    }

    //
    // The critical section's DebugInfo field is only valid under NT.
    // If we're running under NT, then set the critical section type
    // to mark this as a resource. This is useful when debugging resource
    // leaks.
    //

    platformType = IISGetPlatformType();

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {
        Resource->CriticalSection.DebugInfo->Type = RTL_RESOURCE_TYPE;
    }

    Resource->DebugInfo = NULL;

    //
    //  Initialize flags so there is a default value.
    //  (Some apps may set RTL_RESOURCE_FLAGS_LONG_TERM to affect timeouts.)
    //

    Resource->Flags = 0;

    //
    //  Initialize the shared and exclusive waiting counters and semaphore.
    //  The counters indicate how many are waiting for access to the resource
    //  and the semaphores are used to wait on the resource.  Note that
    //  the semaphores can also indicate the number waiting for a resource
    //  however there is a race condition in the alogrithm on the acquire
    //  side if count if not updated before the critical section is exited.
    //

    Resource->SharedSemaphore = IIS_CREATE_SEMAPHORE(
                                    "RTL_RESOURCE::SharedSemaphore",
                                    Resource,
                                    0,
                                    MAXLONG
                                    );

    if ( !Resource->SharedSemaphore ) {
        return FALSE;
    }

    Resource->NumberOfWaitingShared = 0;

    Resource->ExclusiveSemaphore = IIS_CREATE_SEMAPHORE(
                                       "RTL_RESOURCE::ExclusiveSemaphore",
                                       Resource,
                                       0,
                                       MAXLONG
                                       );

    if ( !Resource->ExclusiveSemaphore ){
        CloseHandle( Resource->SharedSemaphore );

        return FALSE;
    }

    Resource->NumberOfWaitingExclusive = 0;

    //
    //  Initialize the current state of the resource
    //

    Resource->NumberOfActive = 0;

    Resource->ExclusiveOwnerThread = NULL;

#if DBG
    InterlockedIncrement( &g_InetResourcesCreated );
#endif

    return TRUE;
}


BOOL
InetAcquireResourceShared(
    IN PRTL_RESOURCE Resource,
    IN BOOL          Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    DWORD          ret;
    ULONG          TimeoutCount = 0;
    DWORD          TimeoutTime  = INET_RES_TIMEOUT;
    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If it is not currently acquired for exclusive use then we can acquire
    //  the resource for shared access.  Note that this can potentially
    //  starve an exclusive waiter however, this is necessary given the
    //  ability to recursively acquire the resource shared.  Otherwise we
    //  might/will reach a deadlock situation where a thread tries to acquire
    //  the resource recusively shared but is blocked by an exclusive waiter.
    //
    //  The test to reanable not starving an exclusive waiter is:
    //
    //      if ((Resource->NumberOfWaitingExclusive == 0) &&
    //          (Resource->NumberOfActive >= 0)) {
    //

    if (Resource->NumberOfActive >= 0) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section
        //

        Resource->NumberOfActive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise check to see if this thread is the one currently holding
    //  exclusive access to the resource.  And if it is then we change
    //  this shared request to an exclusive recusive request and grant
    //  access to the resource.
    //

    } else if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

        //
        //  The resource is ours (recusively) so indicate that we have it
        //  and exit the critial section
        //

        Resource->NumberOfActive -= 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise we'll have to wait for access.
    //

    } else {

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting shared,
        //  release the lock, and wait on the shared semaphore
        //

        Resource->NumberOfWaitingShared += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->SharedSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceShared] Sem timeout\n",
                          Resource));

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }

            InetResPrint((buff,
                          "%08x::[InetAcquireResourceShared] Re-Waiting\n",
                          Resource));

            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceShared] "
                          "WaitForSingleObject Failed\n",
                          Resource));

        }
    }

    //
    //  Now the resource is ours, for shared access
    //

    return TRUE;

}


extern "C"
BOOL
InetAcquireResourceExclusive(
    IN PRTL_RESOURCE Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    ULONG TimeoutCount = 0;
    DWORD TimeoutTime  = INET_RES_TIMEOUT;
    DWORD ret;

    //
    //  Loop until the resource is ours or exit if we cannot wait.
    //

    while (TRUE) {

        //
        //  Enter the critical section
        //

        EnterCriticalSection(&Resource->CriticalSection);

        //
        //  If there are no shared users and it is not currently acquired for
        //  exclusive use then we can acquire the resource for exclusive
        //  access.  We also can acquire it if the resource indicates exclusive
        //  access but there isn't currently an owner.
        //

        if ((Resource->NumberOfActive == 0)

                ||

            ((Resource->NumberOfActive == -1) &&
             (Resource->ExclusiveOwnerThread == NULL))) {

            //
            //  The resource is ours, so indicate that we have it and
            //  exit the critical section
            //

            Resource->NumberOfActive = -1;

            Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Otherwise check to see if we already have exclusive access to the
        //  resource and can simply recusively acquire it again.
        //

        if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

            //
            //  The resource is ours (recusively) so indicate that we have it
            //  and exit the critial section
            //

            Resource->NumberOfActive -= 1;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting exclusive,
        //  release the lock, and wait on the exclusive semaphore
        //

        Resource->NumberOfWaitingExclusive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceExclusive] "
                          "Sem Timeout\n",
                          Resource));

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceExclusive] "
                          "Re-Waiting\n",
                          Resource));
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceExclusive] "
                          "WaitForSingleObject Failed\n",
                          Resource));
        }
    }

    return TRUE;
}


extern "C"
BOOL
InetReleaseResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  Test if the resource is acquired for shared or exclusive access
    //

    if (Resource->NumberOfActive > 0) {

        //
        //  Releasing shared access to the resource, so decrement
        //  the number of shared users
        //

        Resource->NumberOfActive -= 1;

        //
        //  If the resource is now available and there is a waiting
        //  exclusive user then give the resource to the waiting thread
        //

        if ((Resource->NumberOfActive == 0) &&
            (Resource->NumberOfWaitingExclusive > 0)) {

            //
            //  Set the resource state to exclusive (but not owned),
            //  decrement the number of waiting exclusive, and release
            //  one exclusive waiter
            //

            Resource->NumberOfActive = -1;
            Resource->ExclusiveOwnerThread = NULL;

            Resource->NumberOfWaitingExclusive -= 1;

            if ( !ReleaseSemaphore(
                         Resource->ExclusiveSemaphore,
                         1,
                         &PreviousCount
                         )) {
                return FALSE;
            }
        }

    } else if (Resource->NumberOfActive < 0) {

        //
        //  Releasing exclusive access to the resource, so increment the
        //  number of active by one.  And continue testing only
        //  if the resource is now available.
        //

        Resource->NumberOfActive += 1;

        if (Resource->NumberOfActive == 0) {

            //
            //  The resource is now available.  Remove ourselves as the
            //  owner thread
            //

            Resource->ExclusiveOwnerThread = NULL;

            //
            //  If there is another waiting exclusive then give the resource
            //  to it.
            //

            if (Resource->NumberOfWaitingExclusive > 0) {

                //
                //  Set the resource to exclusive, and its owner undefined.
                //  Decrement the number of waiting exclusive and release one
                //  exclusive waiter
                //

                Resource->NumberOfActive = -1;
                Resource->NumberOfWaitingExclusive -= 1;

                if ( !ReleaseSemaphore(
                             Resource->ExclusiveSemaphore,
                             1,
                             &PreviousCount
                             )) {
                    return FALSE;
                }

            //
            //  Check to see if there are waiting shared, who should now get
            //  the resource
            //

            } else if (Resource->NumberOfWaitingShared > 0) {

                //
                //  Set the new state to indicate that all of the shared
                //  requesters have access and there are no more waiting
                //  shared requesters, and then release all of the shared
                //  requsters
                //

                Resource->NumberOfActive = Resource->NumberOfWaitingShared;

                Resource->NumberOfWaitingShared = 0;

                if ( !ReleaseSemaphore(
                             Resource->SharedSemaphore,
                             Resource->NumberOfActive,
                             &PreviousCount
                             )) {
                    return FALSE;
                }
            }
        }

#if DBG
    } else {

        //
        //  The resource isn't current acquired, there is nothing to release
        //  so tell the user the mistake
        //


        InetResPrint((buff,
                      "%08x::[InetReleaseResource] "
                      "Resource released too many times!\n",
                      Resource));
        DebugBreak();
#endif
    }

    //
    //  Exit the critical section, and return to the caller
    //

    LeaveCriticalSection(&Resource->CriticalSection);

    return TRUE;
}


extern "C"
BOOL
InetConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for shared access into
    one acquired for exclusive access.  Upon return from the procedure
    the resource is acquired for exclusive access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for shared access

Return Value:

    None

--*/

{
    DWORD ret;
    DWORD TimeoutTime  = INET_RES_TIMEOUT;
    ULONG TimeoutCount = 0;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == 1) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section, and return
        //

        Resource->NumberOfActive = -1;

        Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is currently acquired exclusive and it's us then
    //  we already have exclusive access
    //

    if ((Resource->NumberOfActive < 0) &&
        (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread)) {

        //
        //  We already have exclusive access to the resource so we'll just
        //  exit the critical section and return
        //

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is acquired by more than one shared then we need
    //  to wait to get exclusive access to the resource
    //

    if (Resource->NumberOfActive > 1) {

        //
        //  To wait we will decrement the fact that we have the resource for
        //  shared, and then loop waiting on the exclusive lock, and then
        //  testing to see if we can get exclusive access to the resource
        //

        Resource->NumberOfActive -= 1;

        while (TRUE) {

            //
            //  Increment the number of waiting exclusive, exit and critical
            //  section and wait on the exclusive semaphore
            //

            Resource->NumberOfWaitingExclusive += 1;

            LeaveCriticalSection(&Resource->CriticalSection);
rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            InetResPrint((buff,
                          "%08x::[InetConvertSharedToExclusive] Sem timeout\n",
                          Resource));

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }
            InetResPrint((buff,
                          "%08x::[InetConvertSharedToExclusive] Re-Waiting\n",
                          Resource));
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            InetResPrint((buff,
                          "%08x::[InetConvertSharedToExclusive] "
                          "WaitForSingleObject Failed\n",
                          Resource));

            return FALSE;
        }

            //
            //  Enter the critical section
            //

            EnterCriticalSection(&Resource->CriticalSection);

            //
            //  If there are no shared users and it is not currently acquired
            //  for exclusive use then we can acquire the resource for
            //  exclusive access.  We can also acquire it if the resource
            //  indicates exclusive access but there isn't currently an owner
            //

            if ((Resource->NumberOfActive == 0)

                    ||

                ((Resource->NumberOfActive == -1) &&
                 (Resource->ExclusiveOwnerThread == NULL))) {

                //
                //  The resource is ours, so indicate that we have it and
                //  exit the critical section and return.
                //

                Resource->NumberOfActive = -1;

                Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }

            //
            //  Otherwise check to see if we already have exclusive access to
            //  the resource and can simply recusively acquire it again.
            //

            if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

                //
                //  The resource is ours (recusively) so indicate that we have
                //  it and exit the critical section and return.
                //

                Resource->NumberOfActive -= 1;

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }
        }

    }

    //
    //  The resource is not currently acquired for shared so this is a
    //  spurious call
    //

#if DBG
    InetResPrint((buff,
                  "%08x::[InetConvertSharedToExclusive] "
                  "Failed error - SHARED_RESOURCE_CONV_ERROR\n",
                  Resource));
    DebugBreak();
#endif

    return FALSE;
}


extern "C"
BOOL
InetConvertExclusiveToShared(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for exclusive access into
    one acquired for shared access.  Upon return from the procedure
    the resource is acquired for shared access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for exclusive access

Return Value:

    None

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == -1) {

        Resource->ExclusiveOwnerThread = NULL;

        //
        //  Check to see if there are waiting shared, who should now get the
        //  resource along with us
        //

        if (Resource->NumberOfWaitingShared > 0) {

            //
            //  Set the new state to indicate that all of the shared requesters
            //  have access including us, and there are no more waiting shared
            //  requesters, and then release all of the shared requsters
            //

            Resource->NumberOfActive = Resource->NumberOfWaitingShared + 1;

            Resource->NumberOfWaitingShared = 0;

            if ( !ReleaseSemaphore(
                         Resource->SharedSemaphore,
                         Resource->NumberOfActive - 1,
                         &PreviousCount
                         )) {
                return FALSE;
            }
        } else {

            //
            //  There is no one waiting for shared access so it's only ours
            //

            Resource->NumberOfActive = 1;

        }

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;

    }

    //
    //  The resource is not currently acquired for exclusive, or we've
    //  recursively acquired it, so this must be a spurious call
    //

#if DBG
    InetResPrint((buff,
                  "%08x::[InetConvertExclusiveToShared] "
                  "Failed error - SHARED_RESOURCE_CONV_ERROR\n",
                  Resource));
    DebugBreak();
#endif

    return FALSE;
}


extern "C"
VOID
InetDeleteResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    DeleteCriticalSection( &Resource->CriticalSection );
    CloseHandle(Resource->SharedSemaphore);
    CloseHandle(Resource->ExclusiveSemaphore);
    ZeroMemory( Resource, sizeof( *Resource ) );

#if DBG
    InterlockedIncrement( &g_InetResourcesDeleted );
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\sched.cxx ===
/*++
TODO: fix !inetdbg.sched

   Copyright    (c)    1995-2001     Microsoft Corporation

   Module Name:

       sched.cxx

   Abstract:

        This module contains a simple timer interface for scheduling future
        work items


   Author:

        John Ludeman    (johnl)     17-Jul-1995

   Project:

        Internet Servers Common Server DLL

   Revisions:
        Murali R. Krishnan  (MuraliK)     16-Sept-1996
          Added scheduler items cache
        George V. Reilly      (GeorgeRe)        May-1999
          Removed the global variables; turned into refcounted objects, so
          that code will survive stops and restarts when work items take a
          long time to complete
        Jeffrey Wall        (jeffwall)    April 2001
          Switched API to use NT public CreateTimerQueue,
          CreateTimerQueueTimer and DeleteTimerQueueEx
--*/

//
//  Include Headers
//

#include "precomp.hxx"

#include <ole2.h>
#include <issched.hxx>

#include "sched.hxx"


// Initialize class static members
LONG              SCHEDULER::sm_nID = 0;
LONG              TIMER::sm_lLastCookie = 0;

//
//  Global data items
//
SCHEDULER*         g_pScheduler = NULL;
CRITICAL_SECTION   g_SchedulerCritSec;

ULONG              cSchedInits = 0;
ULONG              cSchedUninits = 0;


/************************************************************
 *  Public functions of Scheduler
 ************************************************************/


BOOL
SchedulerInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "SchedulerInitialize: inits=%d, uninits=%d\n",
                        cSchedInits, cSchedUninits));
    }

    ++cSchedInits;

    unsigned idThread;
    LONG     i, numThreads;

    SCHEDULER* const psd = SCHEDULER::CreateScheduler();
    if (psd == NULL)
    {
        return FALSE;
    }
    DBG_ASSERT(psd->CheckSignature());

    EnterCriticalSection(&g_SchedulerCritSec);

    // Update the global pointer to the scheduler
    SCHEDULER* const psd2 =
        (SCHEDULER*) InterlockedCompareExchangePointer((VOID**)&g_pScheduler, psd, NULL);

    TIMER::ResetCookie();

    LeaveCriticalSection(&g_SchedulerCritSec);

    if (psd2 != NULL)
    {
        psd->Terminate();
    }

    return TRUE;
} // SchedulerInitialize()

VOID
SchedulerTerminate(
    VOID
    )
/*++

Routine Description:

    Terminates and cleans up the scheduling package.  Any items left on the
    list are *not* called during cleanup.

    Blocks until all callbacks are completed and removed.

--*/
{
    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "SchedulerTerminate: inits=%d, uninits=%d\n",
                                  cSchedInits, cSchedUninits));
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    // Grab the global pointer, then set it to NULL
    SCHEDULER* const psd =
        (SCHEDULER*) InterlockedExchangePointer((VOID**)&g_pScheduler, NULL);

    ++cSchedUninits;

    if (psd)
    {
        // blocks until all callbacks have finished
        psd->Terminate();
    }

    LeaveCriticalSection(&g_SchedulerCritSec);

    return;
}

DWORD
WINAPI
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    BOOL               fPeriodic /* = FALSE */
    )
/*++

Routine Description:

    Adds a timed work item to the work list

Arguments:

    pfnCallback - Function to call
    pContext - Context to pass to the callback
    msecTime - number of milliseconds to wait before calling timeout
    fPeriodic - whether or not timer reactivates every msecTime periods
    fCoInitializeCallback - whether or not callback function should be coinitialized

Return Value:

    zero on failure, non-zero on success.  The return value can be used to
    remove the scheduled work item.

--*/
{
    BOOL               fCoInitializeCallback = TRUE;

    if (!g_pScheduler)
    {
        return ERROR_NOT_READY;
    }

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "ScheduleWorkItem: callback=%p context=%p time=%d periodic=%d Com=%d\n",
                        pfnCallback,
                        pContext,
                        msecTime,
                        fPeriodic,
                        fCoInitializeCallback));
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return ERROR_NOT_READY;
    }

    DWORD dwRet;
    dwRet = TIMER::Create(g_pScheduler,
                           pfnCallback,
                           pContext,
                           msecTime,
                           fPeriodic,
                           fCoInitializeCallback);
    LeaveCriticalSection(&g_SchedulerCritSec);

    return dwRet;
}

// function prototype for decision routine
typedef BOOL (WINAPI *P_DECISION_ROUTINE )(PLIST_ENTRY, PVOID);

BOOL
WalkList(PLIST_ENTRY pListHead,
         P_DECISION_ROUTINE pfnDecision,
         PVOID pContext)
/*++

Routine Description:

    Walks list pointed to by pListHead calling pfnDecision with pContext until
    1) list is done being walked OR
    2) pfnDecision returns TRUE

Arguments:
    pListHead - list head
    pfnDecision - pointer to decision function
    pContext - pointer to context

Return Value:

    TRUE if any call to pfnDecision returns TRUE
    FALSE if NO call to pfnDecision returns TRUE

--*/
{
    BOOL fRet = FALSE;

    PLIST_ENTRY pEntry = pListHead->Flink;

    while(pEntry != pListHead)
    {
        fRet = pfnDecision(pEntry, pContext);
        if (fRet)
        {
            break;
        }

        pEntry = pEntry->Flink;
    }
    return fRet;
}

struct FindTimerData
/*++
Struct Description:

    one pointer for cookie and found timer

--*/
{
    DWORD dwCookie;
    TIMER * pTimer;
};

BOOL
WINAPI
FindTimerEntry(PLIST_ENTRY pEntry,
               PVOID pvftd)
/*++

Routine Description:
    Determines if current pEntry is the timer being searched for

Arguments:
    pEntry - pointer to TIMER under consideration
    pvftd - void pointer to FindTimerData

Return Value:

    TRUE if TIMER matches, false otherwise

--*/
{
    TIMER * pTimer = TIMER::TimerFromListEntry(pEntry);
    FindTimerData * pftd = reinterpret_cast<FindTimerData*>(pvftd);

    if (pTimer->GetCookie() == pftd->dwCookie)
    {
        pftd->pTimer = pTimer;
        // don't continue enumeration
        return TRUE;
    }

    // continue enumeration
    return FALSE;
}

TIMER *
FindTimerNoLock(DWORD dwCookie)
/*++

Routine Description:
    Finds timer associated with cookie by walking timer list
    DOES NOT LOCK LIST

Arguments:
    dwCookie - cookie being looked for

Return Value:
    NULL if associated TIMER not found, otherwise TIMER *

--*/
{
    FindTimerData ftd;
    ftd.dwCookie = dwCookie;
    ftd.pTimer = NULL;

    WalkList(g_pScheduler->GetListHead(), FindTimerEntry, reinterpret_cast<PVOID>(&ftd));

    return ftd.pTimer;
}

TIMER *
FindTimer(DWORD dwCookie)
/*++

Routine Description:

    Finds a TIMER associated with a given cookie
    LOCKS LIST

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    NULL if not found, otherwise TIMER * with cookie equal to dwCookie

--*/
{
    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return NULL;
    }

    TIMER * pTimer = FindTimerNoLock(dwCookie);

    LeaveCriticalSection(&g_SchedulerCritSec);

    return pTimer;
}

BOOL
WINAPI
RemoveWorkItem(
    DWORD  dwCookie
    )
/*++

Routine Description:

    Removes a scheduled work item

    If NOT called from callback associated with cookie, function blocks waiting for all callbacks to finish.
    otherwise, queues deletion of TIMER, but no more callbacks will occur.

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    TRUE if the item was found, FALSE if the item was not found.

--*/
{
    TIMER * pTimer = NULL;

    if (!g_pScheduler)
    {
        return ERROR_NOT_READY;
    }

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "RemoveWorkItem: cookie=%d\n",
                        dwCookie));
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return FALSE;
    }

    pTimer = FindTimerNoLock(dwCookie);
    if (pTimer)
    {
        // remove this timer from the running list
        pTimer->RemoveFromList();
    }

    LeaveCriticalSection(&g_SchedulerCritSec);

    if (pTimer)
    {
        pTimer->Terminate();
    }
    else
    {
        SetLastError(ERROR_NOT_FOUND);
    }

    return pTimer ? TRUE : FALSE;
} // RemoveWorkItem()


DWORD
WINAPI
ScheduleAdjustTime(
    DWORD dwCookie,
    DWORD msecNewTime
    )
/*++

Routine Description:

    Reschedules a given work item

    If NOT called from callback associated with cookie, function blocks waiting
    for all callbacks to finish on previous TIMER.

    if called from callback associated with cookie,
    queues deletion of previous TIMER, and some callbacks MAY still occur

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem
    msecNewTime - new time period

Return Value:

    Win32 error code: NO_ERROR => success.

    if item not found, returns ERROR_NOT_FOUND
    if item found but couldn't be rescheduled returns ERROR_OUT_OF_MEMORY

--*/
{
    DWORD dwRet = ERROR_NOT_FOUND;
    TIMER * pTimer = NULL;

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "ScheduleAdjustTime: cookie=%d time=%d\n",
                        dwCookie,
                        msecNewTime));
    }

    if (!g_pScheduler)
    {
        return ERROR_NOT_READY;
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return ERROR_NOT_READY;
    }

    pTimer = FindTimerNoLock(dwCookie);
    if (pTimer)
    {
        //
        // create the new timer and have it be on the list when we leave critsec
        // AND guarantee that the old timer won't ever call the callback function
        //
        pTimer->RemoveFromList();

        dwRet = pTimer->CopyTimer(msecNewTime);
    }

    LeaveCriticalSection(&g_SchedulerCritSec);

    if (pTimer)
    {
        pTimer->Terminate();
    }
    else
    {
        return ERROR_NOT_FOUND;
    }

    return dwRet;
} // ScheduleAdjustTime()


//
// Implementation of SCHEDULER
//

//static
SCHEDULER*
SCHEDULER::CreateScheduler()
/*++

Routine Description:
    Creates the SCHEDULER object

Arguments:
    void

Return Value:
    NULL if scheduler couldn't be created, otherwise SCHEDULER*

--*/
{
    SCHEDULER* pScheduler = new SCHEDULER();
    if (NULL == pScheduler)
    {
        goto error;
    }

    pScheduler->m_hDeletionEvent =
        CreateEvent(NULL,   // security descriptor
                    TRUE,   // manual reset
                    FALSE,  // initial state
                    NULL);  // name
    if (NULL == pScheduler->m_hDeletionEvent)
    {
        goto error;
    }

    pScheduler->m_hQueue = CreateTimerQueue();
    if (NULL == pScheduler->m_hQueue)
    {
        goto error;
    }

    return pScheduler;
error:
    delete pScheduler;
    return NULL;
}

SCHEDULER::SCHEDULER() :
    m_dwSignature(SIGNATURE_SCHEDULER),
    m_nID(InterlockedIncrement(&sm_nID)),
    m_hQueue(NULL),
    m_hDeletionEvent(NULL),
    m_cRef(0)
/*++

Routine Description:

    Constructor
Arguments:

    void

Return Value:

    void
--*/
{
    InitializeListHead(&m_listTimerHead);
}

void
SCHEDULER::Terminate()
/*++

Routine Description:

    Tears down and deletes a SCHEDULER

    Terminates all TIMERs still active
    Blocks waiting until all TIMER objects have released their reference on SCHEDULER
    Blocks waiting until all CALLBACK functions have returned by calling DeleteTimerQueue with blocking


Arguments:

    void

Return Value:

    void

--*/
{
    DBG_ASSERT(CheckSignature());

    BOOL fRet;
    DWORD dwSpinCount = 0;
    HANDLE hQueue = NULL;
    
    //
    // there should be zero remaining work items
    //

    DBG_ASSERT(IsListEmpty(&m_listTimerHead));

    LeaveCriticalSection(&g_SchedulerCritSec);

    while (0 != m_cRef )
    {
        // wait for the TIMER to be deleted in TIMER::PostTerminate
        // and release its reference on the scheduler
        Sleep(100);
        dwSpinCount++;
        if (300 <= dwSpinCount)
        {
            DBG_ASSERT(!"Scheduler taking too long to shut down because of outstanding reference");
        }
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(0 == m_cRef);
    
    hQueue = m_hQueue;
    m_hQueue = NULL;

    LeaveCriticalSection(&g_SchedulerCritSec);
    
    // All the TIMERs are gone now
    // however, some NT Timers may still be around -> wait for those to complete
    fRet = DeleteTimerQueueEx(hQueue,
                              INVALID_HANDLE_VALUE);
    
    DBG_ASSERT(FALSE != fRet);
    
    hQueue = NULL;

    EnterCriticalSection(&g_SchedulerCritSec);

    // can't touch this
    delete this;

    return;
} // SCHEDULER::Terminate()


SCHEDULER::~SCHEDULER()
/*++

Routine Description:
    destructor

Arguments:
    void

Return Value:
    void

--*/
{
    DBG_ASSERT(CheckSignature());
    DBG_ASSERT(IsListEmpty(&m_listTimerHead));
    DBG_ASSERT(NULL == m_hQueue);

    if (m_hDeletionEvent)
    {
        CloseHandle(m_hDeletionEvent);
        m_hDeletionEvent = NULL;
    }

    m_dwSignature = SIGNATURE_SCHEDULER_FREE;
}


//static
DWORD
TIMER::Create(SCHEDULER        *pScheduler,
               PFN_SCHED_CALLBACK pfnCallback,
               PVOID              pContext,
               DWORD              msecTime,
               BOOL               fPeriodic,
               BOOL               fCoInitializeCallback,
               DWORD              dwCookie /* = 0 */
               )
/*++

Routine Description:
    Creates a TIMER object and adds the object to the active TIMER list

Arguments:
    pScheduler - owning scheduler
    pfnCallback - callback function
    pContext - context for callback
    msecTime - timeout
    fPeriodic - callback multiple times?
    fCoInitializeCallback - Should callback be CoInited?
    dwCookie - optional - preset cookie to give new object

Return Value:
    Cookie for new TIMER object, zero if not created.

--*/
{
    BOOL fRet;

    TIMER * pTimer = NULL;
    // allocate storage for the new timer
    pTimer = new TIMER(pScheduler);
    if (NULL == pTimer)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto done;
    }

    pTimer->m_pfnCallback = pfnCallback;
    pTimer->m_pContext = pContext;
    pTimer->m_fPeriodic = fPeriodic;
    pTimer->m_fCoInitializeCallback = fCoInitializeCallback;

    if (dwCookie)
    {
        // reuse a previously handed out cookie
        pTimer->m_dwCookie = dwCookie;
    }
    else
    {
        pTimer->m_dwCookie = InterlockedIncrement(&sm_lLastCookie);
        DBG_ASSERT(sm_lLastCookie != 0);
        //
        // BUGBUG: handle cookie wrap-around
        //
    }

    InsertHeadList(pScheduler->GetListHead(), &pTimer->m_listEntry);

    fRet = pTimer->CreateTimer(msecTime);
    if (FALSE == fRet)
    {
        pTimer->RemoveFromList();
        delete pTimer;
        pTimer = NULL;
        goto done;
    }

done:
    return pTimer ? pTimer->GetCookie() : 0;
}

BOOL
TIMER::CreateTimer(DWORD msecTime)
/*++

Routine Description:
    Creates a TimerQueueTimer associated with the TIMER object

Arguments:
    msecTime - timeout for timer

Return Value:
    FALSE if timer couldn't be created, otherwise TRUE

--*/
{
    BOOL fRet = FALSE;

    DWORD dwPeriod = 0;
    ULONG ulFlags = 0;

    if (m_fPeriodic)
    {
        // timer period is set
        dwPeriod = msecTime;
    }
    else
    {
        // if we aren't periodic, we only execute once
        ulFlags |= WT_EXECUTEONLYONCE;
    }

    // callback function could take long time to complete
    ulFlags |= WT_EXECUTELONGFUNCTION;

    fRet = CreateTimerQueueTimer(&m_hTimer,                 // pointer to HANDLE for new timer
                                 m_pScheduler->GetQueue(),  // TimerQueue
                                 TimerCallback,             // Callback function
                                 (PVOID)(DWORD_PTR)(m_dwCookie), // callback parameter
                                 msecTime,                  // first due time
                                 dwPeriod,                  // repition period
                                 ulFlags);                  // creation flags
    if (FALSE == fRet)
    {
        goto done;
    }

done:
    return fRet;
} // CreateTimer()

TIMER::TIMER(SCHEDULER * pScheduler) :
    m_dwSignature(SIGNATURE_TIMER),
    m_pScheduler(pScheduler),
    m_lCallbackThreadId(0)
/*++

Routine Description:
    Constructor

Arguments:
    pScheduler - associated scheduler

Return Value:
    void

--*/
{
    DBG_ASSERT(NULL != pScheduler);
    m_pScheduler->ReferenceScheduler();
}

TIMER::~TIMER()
/*++

Routine Description:
    TIMER destructor

Arguments:
    void

Return Value:
    void

--*/
{
    DBG_ASSERT(CheckSignature());
    m_dwSignature = SIGNATURE_TIMER_FREE;

    DBG_ASSERT(NULL == m_hTimer);

    m_pScheduler->DereferenceScheduler();
}

void
TIMER::Terminate()
/*++

Routine Description:
    Begins (and sometimes finished) TIMER destruction.

    If current callback thread is NOT the same thread calling TIMER::Terminate
    Do a blocking call to DeleteTimerQueueTimer, then delete the current object

    If current callback thread IS the same thread calling TIMER::Terminate
    Register a wait for the callback to complete, and make a non blocking call
    to DeleteTimerQueueTimer and wait for the RegisterWait to fire and delete the
    current object

Arguments:
    void

Return Value:
    void

--*/
{
    DBG_ASSERT(CheckSignature());

    BOOL fRet;

    LONG lThreadId = GetCurrentThreadId();
    LONG lPrevThreadId = 0;

    lPrevThreadId = InterlockedCompareExchange(&m_lCallbackThreadId,
                                               -1,
                                               lThreadId);
    
    if (lPrevThreadId == lThreadId)
    {
        // We are currently on the callback thread for this TIMER.
        // Therefore, we cannot delete it.  Rather, we have placed a -1 in the CallbackThreadId,
        // and this will be deleted when we return from the callout.

        (void) DeleteTimerQueueTimer(m_pScheduler->GetQueue(), // queue to use
                                     m_hTimer,                 // timer to delete
                                     NULL);                    // event to signal - don't block
        // if this call failed, there is nothing we can do.
        // we do expect that ERROR_IO_PENDING should be the last error
        // however, NT has changed this return semantic once or twice and it is better not to assert.
        m_hTimer = NULL;
    }
    else
    {
        //
        // Since we are not on the callback thread, block until all of the callbacks have completed
        //
        fRet = DeleteTimerQueueTimer(m_pScheduler->GetQueue(),  // queue to use
                                     m_hTimer,                  // timer to delete
                                     INVALID_HANDLE_VALUE);     // event to signal - block

        DBG_ASSERT(FALSE != fRet);

        m_hTimer = NULL;

        delete this;
    }

    
    return;
}

DWORD
TIMER::CopyTimer(DWORD msecTime)
/*++

Routine Description:
    Create a copy of the current object and add the copy to the running timer list

Arguments:
    msecTime - timeout period for new TIMER

Return Value:
    ERROR_SUCCESS on success, ERROR_NOT_ENOUGH_MEMORY on failure

--*/
{
    DBG_ASSERT(CheckSignature());

    DWORD dwRet;

    // create a new TIMER with the same cookie as this object
    dwRet = TIMER::Create(m_pScheduler,
                          m_pfnCallback,
                          m_pContext,
                          msecTime,
                          m_fPeriodic,
                          m_fCoInitializeCallback,
                          m_dwCookie);
    if (0 == dwRet)
    {
        // failed allocation on new timer
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DBG_ASSERT(m_dwCookie == dwRet);

    return ERROR_SUCCESS;
}

//static
VOID
TIMER::TimerCallback(PVOID lpParameter,
                      BOOLEAN TimerOrWaitFired)
/*++

Routine Description:
    TimerCallback function

    Find TIMER associated with this callback
    if no other callbacks are occurring with this timer,
    CoInitialize if required, then
    callback to interesting function
    CoUninitialize if required then
    if this was a one shot timer, delete it.
    otherwise see if timer is still valid and if so, reset
    the current thread

Arguments:
    lpParameter - cookie for timer currently firing
    TimerOrWaitFired - not used

Return Value:
    void

--*/
{
    DWORD dwCookie = (DWORD)(DWORD_PTR)(lpParameter);

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return;
    }

    TIMER * pTimer = FindTimerNoLock(dwCookie);
    if (NULL == pTimer)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return;
    }

    DBG_ASSERT(pTimer->CheckSignature());

    BOOL fCoInitializeCallback = pTimer->m_fCoInitializeCallback;
    BOOL fPeriodic = pTimer->m_fPeriodic;

    LONG lThreadId = GetCurrentThreadId();
    LONG lPrevThreadId = 0;

    lPrevThreadId = InterlockedCompareExchange(&pTimer->m_lCallbackThreadId,
                                               lThreadId,
                                               0);

    LeaveCriticalSection(&g_SchedulerCritSec);

    if (0 != lPrevThreadId)
    {
        // another TIMER callback is currently occurring
        // on this timer.  don't callback twice.
        return;
    }

    if (fCoInitializeCallback)
    {
        CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }

    // Do the actual callback
    pTimer->m_pfnCallback(pTimer->m_pContext);

    if (fCoInitializeCallback)
    {
        CoUninitialize();
    }

    if (!fPeriodic)
    {
        RemoveWorkItem(dwCookie);
    }

    //
    // If the callback thread ID on the timer is this thread, just clear out the ID.
    //
    lPrevThreadId = InterlockedCompareExchange(&pTimer->m_lCallbackThreadId,
                                               0,
                                               lThreadId);
    if (lThreadId != lPrevThreadId)
    {
        //
        // if a call to RemoveWorkItime was made while this callback
        // was outstanding, from this thread, we need to cleanup the timer now!
        //

        DBG_ASSERT(-1 == lPrevThreadId);
        
        delete pTimer;
        
        pTimer = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\secfcns.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    secfns.cxx

        Declarations for some functions that support working with
        security SID, ACLS, TOKENS, and other pieces.
*/

#include "precomp.hxx"

#pragma warning(push, 4)

#include <secfcns_all.h>
#include <Aclapi.h>

/***************************************************************************++

Routine Description:

    Figures out how much memory is needed and allocates the memory
    then requests the well known sid to be copied into the memory.  If
    all goes well then the SID is returned, if anything fails the 
    SID is not returned.  

Arguments:

    WELL_KNOWN_SID_TYPE SidType = Enum value for the SID being requested.
    PSID* ppSid = Ptr to the pSid that is returned.

Return Value:

    DWORD - Win32 Status Code.

--***************************************************************************/
DWORD 
AllocateAndCreateWellKnownSid( 
    WELL_KNOWN_SID_TYPE SidType,
    PSID* ppSid
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    PSID  pSid  = NULL;
    DWORD cbSid = 0;

    DBG_ASSERT ( ppSid != NULL && *ppSid == NULL );

    if ( ppSid == NULL ||
         *ppSid != NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the size of memory needed for the sid.
    //
    if ( CreateWellKnownSid(SidType, NULL, NULL, &cbSid ) )
    {
        // If CreateWellKnownSid passed then there is a problem
        // because we passed in NULL for the pointer to the sid.

        dwErr = ERROR_NOT_SUPPORTED;

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating a sid worked with no memory allocated for it. ( This is not good )\n"
            ));

        DBG_ASSERT ( FALSE );
        goto exit;
    }

    //
    // Get the error code and make sure it is
    // not enough space allocated.
    //
    dwErr = GetLastError();
    if ( dwErr != ERROR_INSUFFICIENT_BUFFER ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Getting the SID length failed, can't create the sid (Type = %d)\n",
            SidType
            ));

        goto exit;
    }

    //
    // If we get here then the error code was expected, so
    // lose it now.
    //
    dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( cbSid > 0 );

    // 
    // At this point we know the size of the sid to allocate.
    //
    pSid = (PSID) GlobalAlloc(GMEM_FIXED, cbSid);
    if ( pSid == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to allocate space for SID\n"
            ));

        goto exit;
    }

    // 
    // Ok now we can get the SID
    //
    if ( !CreateWellKnownSid (SidType, NULL, pSid, &cbSid) )
    {
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating SID failed ( SidType = %d )\n",
            SidType
            ));

        goto exit;
    }

    DBG_ASSERT ( dwErr == ERROR_SUCCESS );

exit:

    //
    // If we are returning a failure here, we don't
    // want to actually set the ppSid value.  It may
    // not get freed.
    //
    if ( dwErr != ERROR_SUCCESS && pSid != NULL)
    {
        GlobalFree( pSid );
        pSid = NULL;
    }
    else
    {
        //
        // Otherwise we should return the value
        // to the caller.  The caller must 
        // use FreeWellKnownSid to free this value.
        //
        *ppSid = pSid;
    }
        
    return dwErr;
}

/***************************************************************************++

Routine Description:

    Frees memory that was allocated by the 
    AllocateAndCreateWellKnownSid function.

Arguments:

    PSID* ppSid = Ptr to the pointer to be freed and set to NULL.

Return Value:

    VOID.

--***************************************************************************/
VOID 
FreeWellKnownSid( 
    PSID* ppSid
    )
{
    DBG_ASSERT ( ppSid );

    if ( *ppSid != NULL )
    {
        GlobalFree ( *ppSid );
        *ppSid = NULL;
    }
}

/***************************************************************************++

Routine Description:

    Routine will create an acl for a well known sid and return it.
    It allocates all the memory so you don't have to.  But you do have to
    call FreeWellKnownAcl to free the memory.

    It also returns the size of memory allocated.

   
Arguments:

    WELL_KNOWN_SID_TYPE SidType = Enum value for the SID being requested.
    BOOL  fAccessAllowedAcl = Is this an allow or deny acl.
    PACL* ppAcl = the acl beign returned
    DWORD* pcbAcl = count of bytes in the acl being returned
    ACCESS_MASK AccessMask = the access mask that is being allowed or denied

Return Value:

    DWORD - Win32 Status Code.

  Note:  This code was writen to provide ACL's for COM interfaces but
         is not in use yet.  However, it may be useful when fix the acl'ing
         for the IISRESET interface as well as the WAS interface so I am leaving
         it in.  

--***************************************************************************/
DWORD 
AllocateAndCreateWellKnownAcl( 
    WELL_KNOWN_SID_TYPE SidType,
    BOOL  fAccessAllowedAcl,
    PACL* ppAcl,
    DWORD* pcbAcl,
    ACCESS_MASK AccessMask
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    PSID  pSid = NULL;
    DWORD dwSizeOfAcl = sizeof( ACL );
    PACL pAcl = NULL;

    DBG_ASSERT ( ppAcl != NULL && *ppAcl == NULL );
    DBG_ASSERT ( pcbAcl != NULL );

    if ( ppAcl == NULL ||
         *ppAcl != NULL ||
         pcbAcl == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pcbAcl = 0;

    //
    // Create the sid
    //
    dwErr = AllocateAndCreateWellKnownSid ( SidType, &pSid );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating SID failed ( SidType = %d )\n",
            SidType
            ));

        goto exit;
    }

    //
    // Figure out the side of the ACL to create.
    //

    // It all ready has the size of the ACl from above.

    // add in the size of the ace.
    if ( fAccessAllowedAcl ) 
    {
        ACCESS_ALLOWED_ACE a;
        dwSizeOfAcl = dwSizeOfAcl + sizeof ( a ) - sizeof ( a.SidStart );
    }
    else
    {
        ACCESS_DENIED_ACE d;
        dwSizeOfAcl = dwSizeOfAcl + sizeof ( d ) - sizeof ( d.SidStart );
    }

    // don't forget the size of the sid as well.
    dwSizeOfAcl += GetLengthSid (pSid);


    // Now create enough space for all.
    pAcl = reinterpret_cast< PACL > ( GlobalAlloc(GMEM_FIXED, dwSizeOfAcl) ); 
    if ( pAcl == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failure allocating space for the acl\n"
            ));

        goto exit;

    }
        
    // Now initalize the ACL.
    if ( !InitializeAcl ( pAcl, dwSizeOfAcl, ACL_REVISION ) )
    {
        dwErr = GetLastError();

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failure initializing the acl\n"
            ));

        goto exit;

    }

    // Now add an acl of the appropriate type.
    if ( fAccessAllowedAcl )
    {
        if ( !AddAccessAllowedAce( pAcl, ACL_REVISION, 
                                   AccessMask, pSid ) )
        {
            dwErr = GetLastError();

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Failure adding the access allowed ace to the acl\n"
                ));

            goto exit;
        }
    }
    else
    {
        if ( !AddAccessDeniedAce( pAcl, ACL_REVISION, 
                                   AccessMask, pSid ) )
        {
            dwErr = GetLastError();

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Failure adding the access denied ace to the acl\n"
                ));

            goto exit;
        }
    }


    // if we make it here then we have succeeded in creating the 
    // acl, and we will be returning it out.

    *ppAcl = pAcl;
    *pcbAcl = dwSizeOfAcl;


exit:

    //
    // No matter what, we need to free the original sid that
    // was created for us.
    //
    FreeWellKnownSid( &pSid );

    //
    // If we are not returning the acl out
    // then we need to free any memory we created.
    //
    if ( *ppAcl == NULL )
    {
        FreeWellKnownAcl ( &pAcl );
    }
        
    return dwErr;
}

/***************************************************************************++

Routine Description:

    Frees memory that was allocated by the 
    AllocateAndCreateWellKnownAcl function.

Arguments:

    PACL* ppAcl = Ptr to the pointer to be freed and set to NULL.

Return Value:

    VOID.

--***************************************************************************/
VOID 
FreeWellKnownAcl( 
    PACL* ppAcl
    )
{
    DBG_ASSERT ( ppAcl );

    if ( *ppAcl != NULL )
    {
        GlobalFree ( *ppAcl );
        *ppAcl = NULL;
    }
}

/***************************************************************************++

Routine Description:

    Set EXPLICIT_ACCESS settings for wellknown sid.

Arguments:

    EXPLICIT_ACCESS* pea = Pointer the to structure whose values are being set
    DWORD            dwAccessPermissions = access permissions
    ACCESS_MODE      AccessMode = mode of access ( setting or granting or deleteing )
    PSID             pSID = who the permissions are being granted to

Return Value:

    VOID


--***************************************************************************/
VOID 
SetExplicitAccessSettings( EXPLICIT_ACCESS* pea,
                           DWORD            dwAccessPermissions,
                           ACCESS_MODE      AccessMode,
                           PSID             pSID
    )
{
    pea->grfInheritance= NO_INHERITANCE;
    pea->Trustee.TrusteeForm = TRUSTEE_IS_SID;
    pea->Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;

    pea->grfAccessMode = AccessMode;
    pea->grfAccessPermissions = dwAccessPermissions;
    pea->Trustee.ptstrName  = (LPTSTR) pSID;
}

/***************************************************************************++

Routine Description:

    Constructor for CSecurityDispenser class

Arguments:

    

Return Value:


--***************************************************************************/
CSecurityDispenser::CSecurityDispenser() :
    m_pLocalSystemSID ( NULL ),
    m_pLocalServiceSID ( NULL ),
    m_pNetworkServiceSID ( NULL ),
    m_pAdministratorsSID( NULL )
{
}

/***************************************************************************++

Routine Description:

    Destructor for CSecurityDispenser class

Arguments:

    

Return Value:


--***************************************************************************/
CSecurityDispenser::~CSecurityDispenser() 
{
    //
    // FreeWellKnownSid will only free if it is not null
    // and will set to null once it is done.
    //

    FreeWellKnownSid ( &m_pLocalSystemSID );
    FreeWellKnownSid ( &m_pLocalServiceSID );
    FreeWellKnownSid ( &m_pNetworkServiceSID );
    FreeWellKnownSid ( &m_pAdministratorsSID );

}


/***************************************************************************++

Routine Description:

    Gets security id's for the well known accounts that IIS deals with.

Arguments:

    WELL_KNOWN_SID_TYPE sidId = Identifier of the SID we are looking for 
    PSID* ppSid = the sid to return

Return Value:

    DWORD - NtSuccess code, ( used here so functions that don't expose HRESULTS
                              can still use this function )

    Note:  These sids are valid for the life of this object, no more, so don't
    hold on to these's sids for a long time.

--***************************************************************************/
DWORD 
CSecurityDispenser::GetSID(
    WELL_KNOWN_SID_TYPE sidId, 
    PSID* ppSid
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( ( ppSid != NULL ) && ( ( *ppSid ) == NULL ) );

    if ( ppSid == NULL ||
         *ppSid != NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch ( sidId )
    {
        case ( WinLocalSystemSid):

            // if we have the local system sid return it.
            if ( m_pLocalSystemSID != NULL )
            {
                *ppSid = m_pLocalSystemSID;

                goto exit;

            }
            
        break;

        case ( WinLocalServiceSid ):

            // if we have the LocalService system sid return it.
            if ( m_pLocalServiceSID != NULL )
            {
                *ppSid = m_pLocalServiceSID;

                goto exit;
            }

        break;

        case ( WinNetworkServiceSid ):
            
            // if we have the NetworkService system sid return it.
            if ( m_pNetworkServiceSID != NULL )
            {
                *ppSid = m_pNetworkServiceSID;

                goto exit;
            }

        break;

        case ( WinBuiltinAdministratorsSid ):

            // if we have the Administrators sid return it.
            if ( m_pAdministratorsSID != NULL )
            {
                *ppSid = m_pAdministratorsSID;

                goto exit;
            }

        break;

        default:

            DBG_ASSERT ( FALSE ) ;
            dwErr = ERROR_INVALID_PARAMETER;
            goto exit;

    }

    // if we get here then we haven't created the sid yet, so we
    // need to do that now.

    dwErr = AllocateAndCreateWellKnownSid( sidId, ppSid );
    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to create the sid we were looking for\n",
            sidId
            ));

        goto exit;
    }

    //
    // Now hold on to the security id so we won't have
    // to worry about creating it again later.
    //
    switch ( sidId )
    {
        case ( WinLocalSystemSid ):

            m_pLocalSystemSID = *ppSid;

        break;

        case ( WinLocalServiceSid ):

            m_pLocalServiceSID = *ppSid;

        break;

        case ( WinNetworkServiceSid ):

            m_pNetworkServiceSID = *ppSid;
            
        break;

        case ( WinBuiltinAdministratorsSid ):

            m_pAdministratorsSID = *ppSid;

        break;

        default:

            DBG_ASSERT ( FALSE ) ;
            goto exit;

    }

exit:

    return dwErr;

}

/***************************************************************************++

Routine Description:

    Gets security id's for the well known accounts that IIS deals with.

Arguments:

    PSID* ppSid = the IIS_WPG sid to return

Return Value:

    DWORD - Win32Error code


--***************************************************************************/
DWORD 
CSecurityDispenser::GetIisWpgSID(
    PSID* ppSid
    )
{
    DWORD  dwErr = ERROR_SUCCESS;
    DWORD  cbSid = m_buffWpgSid.QuerySize();
    BUFFER buffDomainName;
    DWORD  cchDomainName  = buffDomainName.QuerySize() / sizeof(WCHAR);;
    SID_NAME_USE peUse;

    DBG_ASSERT ( ( ppSid != NULL ) && ( ( *ppSid ) == NULL ) );

    if ( ppSid == NULL ||
         *ppSid != NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If we all ready have the IisWpgSID then go ahead 
    // and return it instead of recreating it.
    //
    if ( m_fWpgSidSet )
    {
        *ppSid = m_buffWpgSid.QueryPtr();
        return ERROR_SUCCESS;
    }

    // if we get here then we haven't created the sid yet, so we
    // need to do that now.

    //
    // obtain the logon sid of the IIS_WPG group
    //
    while(!LookupAccountName(NULL,
                             L"IIS_WPG",
                             m_buffWpgSid.QueryPtr(),
                             &cbSid,
                             (LPWSTR)buffDomainName.QueryPtr(),
                             &cchDomainName,
                             &peUse))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = GetLastError();

            DPERROR((
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not look up the IIS_WPG group sid.\n"
                ));

            return dwErr;
        }

        if (!m_buffWpgSid.Resize(cbSid) ||
            !buffDomainName.Resize(cchDomainName * sizeof(WCHAR)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DPERROR((
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Failed to allocate appropriate space for the WPG sid\n"
                ));

            return dwErr;
        }
    }

    // If we got here we got the SID set
    m_fWpgSidSet = TRUE;
    *ppSid = m_buffWpgSid.QueryPtr();

    return ERROR_SUCCESS;

}

/***************************************************************************++

Routine Description:

    This function takes a handle and changes it's security attributes
    to allow administrators rights to get and set process information for
    processes created under this identity.

Arguments:

    hTokenToAdjust -- The token we are adjusting

Return Value:

    DWORD - NtSuccess code, ( used here so functions that don't expose HRESULTS
                              can still use this function )


--***************************************************************************/
DWORD
CSecurityDispenser::AdjustTokenForAdministrators(
    HANDLE hTokenToAdjust
    )
{

    DWORD               dwErr           = ERROR_SUCCESS;
    DWORD               cbNeededSize    = 0;
    PSID                pAdminSid       = NULL;
    EXPLICIT_ACCESS     ea;
    TOKEN_DEFAULT_DACL  NewDefaultDacl;
    BUFFER              TokDefDaclBuffer;

    // Default the dacl, just incase it wasn't in the 
    // constructor of this class.
    NewDefaultDacl.DefaultDacl = NULL;


    DBG_ASSERT ( hTokenToAdjust != NULL && 
                 hTokenToAdjust != INVALID_HANDLE_VALUE );

    if ( hTokenToAdjust == NULL ||
         hTokenToAdjust == INVALID_HANDLE_VALUE )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Need to get the default dacl for the token we
    // are modifying.
    //
    if ( !GetTokenInformation( hTokenToAdjust,
                               TokenDefaultDacl,
                               NULL,
                               0,
                               &cbNeededSize ) )
    {
        dwErr = GetLastError();

        if ( dwErr != ERROR_INSUFFICIENT_BUFFER )
        {

            DPERROR((
                DBG_CONTEXT,
                HRESULT_FROM_WIN32( dwErr ),
                "Failed to get size of default token\n"
                ));

            goto exit;
        }

        dwErr = ERROR_SUCCESS;
    }
    else
    {
        dwErr = ERROR_OPEN_FAILED;

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( dwErr ),
            "Did not get an error when we expected to ( changed the error to this hr ) \n"
            ));

        goto exit;
    }

    //
    // Now resize the buffer to be the right size
    if ( ! TokDefDaclBuffer.Resize( cbNeededSize ) )
    {
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to resize the buffer for default dacl to %d\n",
            cbNeededSize
            ));

        goto exit;
    }

    //
    // Zero out the memory just to be safe.
    //
    memset ( TokDefDaclBuffer.QueryPtr(), 0, cbNeededSize );

    //
    // Need to change the local system token to have a default acl
    // with GENERIC_ACCESS for all administrators.  This will allow
    // processes created from here to have their affinitization changed.
    //
    if ( !GetTokenInformation( hTokenToAdjust,
                               TokenDefaultDacl,
                               TokDefDaclBuffer.QueryPtr(),
                               cbNeededSize,
                               &cbNeededSize ) )
    {
        dwErr = GetLastError();

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to get the default token\n"
            ));

        goto exit;
    }

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    dwErr = GetSID(WinBuiltinAdministratorsSid, &pAdminSid);
    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( dwErr ),
            "Getting Admin Sid Failed\n"
            ));

        goto exit;
    }
   
    //
    // Now setup the access structure to allow 
    // read access for the trustee.
    //

    SetExplicitAccessSettings(&ea, 
                              PROCESS_QUERY_INFORMATION  | 
                              PROCESS_SET_INFORMATION,
                              GRANT_ACCESS,
                              pAdminSid);

    dwErr = SetEntriesInAcl( 1,
                             &ea,
                             ((TOKEN_DEFAULT_DACL*)(TokDefDaclBuffer.QueryPtr()))->DefaultDacl,
                             &(NewDefaultDacl.DefaultDacl) );

    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to set entries in token\n"
            ));

        goto exit;
    }

    //
    // now set the token to have the right acls.
    //
    if (!SetTokenInformation( hTokenToAdjust,
                               TokenDefaultDacl,
                               &NewDefaultDacl,
                               sizeof ( NewDefaultDacl ) ) )
    {
        dwErr = GetLastError();

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to reset token's default actl\n"
            ));

        goto exit;
    }

exit:

    //
    // if we got a acl back it is time to free it.
    //
    if ( NewDefaultDacl.DefaultDacl )
    {
        LocalFree( NewDefaultDacl.DefaultDacl );
        NewDefaultDacl.DefaultDacl = NULL;
    }

    return dwErr;
}


DWORD
GetTokenSID(
    HANDLE hToken,
    TOKEN_OWNER ** ppTokenOwner
    )
{
    DWORD dwRet = NO_ERROR;
    TOKEN_OWNER * ptokenOwner = NULL;
    
    BOOL fRet = FALSE;
    DWORD dwSize = 0;

    DBG_ASSERT(hToken != NULL);
    DBG_ASSERT(ppTokenOwner != NULL);
    *ppTokenOwner = NULL;
    
    fRet = GetTokenInformation(hToken,
                            TokenOwner,
                            NULL,
                            0,
                            &dwSize);
    if (FALSE == fRet)
    {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            dwRet = GetLastError();
            goto exit;
        }
    }

    ptokenOwner = (TOKEN_OWNER*)new BYTE[dwSize];
    if (NULL == ptokenOwner)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    
    fRet = GetTokenInformation(hToken,
                            TokenOwner,
                            ptokenOwner,
                            dwSize,
                            &dwSize);
    if (FALSE == fRet)
    {
        dwRet = GetLastError();
        goto exit;
    }

    *ppTokenOwner = ptokenOwner;
    ptokenOwner = NULL;
    dwRet = NO_ERROR;

exit:
    delete [] ptokenOwner;
    ptokenOwner = NULL;
    return dwRet;                           
}

struct SECURITY_ATTRIBUTES_PRIVATE : public SECURITY_ATTRIBUTES
{
    PACL                   m_pAcls;
    TOKEN_OWNER           *m_pTokenOwner;
};

/***************************************************************************++

Routine Description:

    This function takes a handle and creates a SECURITY_ATTRIBUTES with LocalSystem 
    and the TOKEN in the HANDLE having full access
    
Arguments:

    hToken - token we are creating SECURITY_ATTRIBUTES for
    PSECURITY_ATTRIBUTES* ppSa - Ptr to the security attribute being returned.

Return Value:

    DWORD - NtSuccess code, ( used here so functions that don't expose HRESULTS
                              can still use this function )


--***************************************************************************/
DWORD 
GetSecurityAttributesForHandle(
    HANDLE hToken,
    PSECURITY_ATTRIBUTES* ppSa
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    // Number of total sids.
    DWORD                  NumberOfSidsTotal = 1;

    // local variables to hold values until we know we succeeded.
    PEXPLICIT_ACCESS       pEa = NULL;
    PACL                   pAcls = NULL;
    PSECURITY_DESCRIPTOR   pSd = NULL;
    SECURITY_ATTRIBUTES_PRIVATE *pSa = NULL;
    TOKEN_OWNER           *pTokenOwner = NULL;
    
    // Make sure we can return a result.
    DBG_ASSERT ( ( ppSa != NULL ) && ( (*ppSa) == NULL ) );

    if ( ppSa == NULL ||
         *ppSa != NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( NULL == hToken )
    {
        // if there was no token, use the default SECURITY_ATTRIBUTES, NULL.
        pSa = NULL;
        dwErr = ERROR_SUCCESS;
        goto exit;
    }

    pEa = new EXPLICIT_ACCESS[NumberOfSidsTotal];
    if ( pEa == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pEa, sizeof(EXPLICIT_ACCESS) * NumberOfSidsTotal);

    // get the sid for the token passed in 
    dwErr = GetTokenSID( hToken, &pTokenOwner );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    // can use the number of well known sids since this will
    // always follow that list.
    SetExplicitAccessSettings( &(pEa[0]),
                               GENERIC_READ | GENERIC_WRITE,
                               GRANT_ACCESS,
                               pTokenOwner->Owner );


    // Create a new ACL that contains the new ACEs.
    // You don't need the ACEs after this point.
    //
    dwErr = SetEntriesInAcl(NumberOfSidsTotal, pEa, NULL, &pAcls);
    if ( dwErr != ERROR_SUCCESS ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    pSd = new SECURITY_DESCRIPTOR;
    if ( pSd == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pSd, sizeof(SECURITY_DESCRIPTOR));

    if (!InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    } 

    if (!SetSecurityDescriptorDacl(pSd, 
            TRUE,     // fDaclPresent flag   
            pAcls, 
            FALSE))   // not a default DACL 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    }                                

    pSa = new SECURITY_ATTRIBUTES_PRIVATE;
    if ( pSa == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pSa, sizeof(SECURITY_ATTRIBUTES));

    pSa->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSa->lpSecurityDescriptor = pSd;
    pSa->bInheritHandle = FALSE;

    pSa->m_pAcls = pAcls;
    pSa->m_pTokenOwner = pTokenOwner;
    
exit:

    // Don't need to hold this memory, so always go ahead and free it.
    if ( pEa )
    {
        delete [] pEa;
        pEa = NULL;
    }

    if ( dwErr == ERROR_SUCCESS )
    {

        // Setup the return value.
        *ppSa = pSa;
        pSa = NULL;
    }
    else
    {
        if ( pAcls )
        {
            LocalFree ( pAcls );
            pAcls = NULL;
        }

        if ( pSd )
        {
            delete pSd;
            pSd = NULL;
        }

        if ( pSa )
        {
            delete pSa;
            pSa = NULL;
        }

        if (pTokenOwner)
        {
            delete [] pTokenOwner;
            pTokenOwner = NULL;
        }
    }
    
    return dwErr;
}


VOID FreeSecurityAttributes(PSECURITY_ATTRIBUTES pSa)
{
    SECURITY_ATTRIBUTES_PRIVATE * pSaPriv = (SECURITY_ATTRIBUTES_PRIVATE*) pSa;

    if ( pSa != NULL )
    {

        LocalFree(pSaPriv->m_pAcls);
        delete pSaPriv->lpSecurityDescriptor;
        delete [] pSaPriv->m_pTokenOwner;
        delete pSaPriv;

    }
    
    return;
}

DWORD GenerateNameWithGUID(LPCWSTR pwszPrefix, STRU* pStr)
{
    HRESULT hr = S_OK;
    RPC_STATUS rpcErr = RPC_S_OK;
    DWORD err = ERROR_SUCCESS;
    UUID uuid;
    LPWSTR pszUUID = NULL;

    if ( pStr == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    rpcErr = UuidCreate(&uuid);
    if ( rpcErr != RPC_S_OK )
    {
        err = ERROR_CAN_NOT_COMPLETE;
        goto exit;
    }

    rpcErr = UuidToStringW(&uuid, &pszUUID);
    if ( rpcErr != RPC_S_OK )
    {
        err = ERROR_CAN_NOT_COMPLETE;
        goto exit;
    }

    if ( pwszPrefix != NULL )
    {
        hr = pStr->Copy( pwszPrefix );
        if ( FAILED ( hr ) )
        {
            err = ERROR_OUTOFMEMORY;
            goto exit;
        }
    }
    else
    {
        pStr->Reset();
    }

    hr = pStr->Append( pszUUID );
    if ( FAILED ( hr ) )
    {
        err = ERROR_OUTOFMEMORY;
        goto exit;
    }

exit:

    if (pszUUID)
    {
        RpcStringFreeW(&pszUUID);
        pszUUID = NULL;
    }

    return err;
}



#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\pudebug.cxx ===
/*++

    Copyright (c) 1994-1998  Microsoft Corporation

    Module  Name :
        pudebug.cxx

    Abstract:

        This module defines functions required for
         Debugging and logging messages for a dynamic program.

    Author:
         Murali R. Krishnan ( MuraliK )    10-Sept-1994

    Revisions:
         MuraliK  13-Nov-1998  Ported over the IIS-DuctTape project
--*/


/************************************************************
 * Include Headers
 ************************************************************/
# include "precomp.hxx"

# include <stdio.h>
# include <stdlib.h>
# include <stdarg.h>
# include <string.h>

# include "pudebug.h"
# include "memorylog.hxx"

/*************************************************************
 * Global Variables and Default Values
 *************************************************************/

# define MAX_PRINTF_OUTPUT  ( 10240)

# define DEFAULT_DEBUG_FLAGS_VALUE  ( 0)
# define DEBUG_FLAGS_REGISTRY_LOCATION_A   "DebugFlags"
# define DEBUG_BREAK_ENABLED_REGKEYNAME_A  "BreakOnAssert"

/*************************************************************
 *   Functions
 *************************************************************/

/********************************************************************++

Routine Description:
   This function creates a new DEBUG_PRINTS object for the required
     program.

Arguments:
      pszPrintLabel     pointer to null-terminated string containing
                         the label for program's debugging output
      dwOutputFlags     DWORD containing the output flags to be used.

Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*********************************************************************/
LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
    IN const char *         pszPrintLabel,
    IN DWORD                dwOutputFlags)
{

   LPDEBUG_PRINTS   pDebugPrints;

   pDebugPrints = (LPDEBUG_PRINTS ) GlobalAlloc( GPTR, sizeof( DEBUG_PRINTS));

   if ( pDebugPrints != NULL) {

        if ( strlen( pszPrintLabel) < MAX_LABEL_LENGTH) {

            strcpy( pDebugPrints->m_rgchLabel, pszPrintLabel);
        } else {
            strncpy( pDebugPrints->m_rgchLabel,
                     pszPrintLabel, MAX_LABEL_LENGTH - 1);
            pDebugPrints->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
                // terminate string
        }

        memset( pDebugPrints->m_rgchLogFilePath, 0, MAX_PATH);
        memset( pDebugPrints->m_rgchLogFileName, 0, MAX_PATH);

        pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;

        pDebugPrints->m_dwOutputFlags = dwOutputFlags;
        pDebugPrints->m_StdErrHandle  = GetStdHandle( STD_ERROR_HANDLE);

        if ( pDebugPrints->m_StdErrHandle == NULL )
        {
            pDebugPrints->m_StdErrHandle = INVALID_HANDLE_VALUE;
        }

        pDebugPrints->m_fInitialized = TRUE;
        pDebugPrints->m_fBreakOnAssert= TRUE;
        pDebugPrints->m_pMemoryLog = NULL;
    }


   return ( pDebugPrints);
} // PuCreateDebugPrintsObject()




/********************************************************************++

Routine Description:
    This function cleans up the pDebugPrints object and
      frees the allocated memory.

    Arguments:
       pDebugPrints     poitner to the DEBUG_PRINTS object.

    Returns:
        NULL  on  success.
        pDebugPrints() if the deallocation failed.

--*********************************************************************/
LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    if ( pDebugPrints != NULL) {

        PuCloseDbgMemoryLog(pDebugPrints);
        DWORD dwError = PuCloseDbgPrintFile( pDebugPrints);

        if ( dwError != NO_ERROR) {

            SetLastError( dwError);
        } else {

            // returns NULL on success
            pDebugPrints =
                (LPDEBUG_PRINTS ) GlobalFree( pDebugPrints);
        }
    }

    return ( pDebugPrints);

} // PuDeleteDebugPrintsObject()




VOID
PuSetDbgOutputFlags(
    IN OUT LPDEBUG_PRINTS   pDebugPrints,
    IN DWORD                dwFlags)
{

    if ( pDebugPrints == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
    } else {

        pDebugPrints->m_dwOutputFlags = dwFlags;
    }

    return;
} // PuSetDbgOutputFlags()



DWORD
PuGetDbgOutputFlags(
    IN const LPDEBUG_PRINTS      pDebugPrints)
{
    return ( pDebugPrints != NULL) ? pDebugPrints->m_dwOutputFlags : 0;

} // PuGetDbgOutputFlags()


static DWORD
PuOpenDbgFileLocal(
   IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    if ( pDebugPrints == NULL)
        return ERROR_INVALID_PARAMETER;

    if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Silently return as a file handle exists.
        //
        return ( NO_ERROR);
    }

    pDebugPrints->m_LogFileHandle =
                      CreateFileA( pDebugPrints->m_rgchLogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

    if ( pDebugPrints->m_LogFileHandle == INVALID_HANDLE_VALUE) {

        CHAR  pchBuffer[1024];
        DWORD dwError = GetLastError();

        wsprintfA( pchBuffer,
                  " Critical Error: Unable to Open File %s. Error = %d\n",
                  pDebugPrints->m_rgchLogFileName, dwError);
        OutputDebugStringA( pchBuffer);

        return ( dwError);
    }

    return ( NO_ERROR);
} // PuOpenDbgFileLocal()





DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFileName,
   IN const char *            pszPathForFile)
/********************************************************************++

  Opens a Debugging log file. This function can be called to set path
  and name of the debugging file.

  Arguments:
     pszFileName           pointer to null-terminated string containing
                            the name of the file.

     pszPathForFile        pointer to null-terminated string containing the
                            path for the given file.
                           If NULL, then the old place where dbg files were
                           stored is used or if none,
                           default windows directory will be used.

   Returns:
       Win32 error codes. NO_ERROR on success.

--*********************************************************************/

{
    if ( pszFileName == NULL || pDebugPrints == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    //
    //  Setup the Path information. if necessary.
    //

    if ( pszPathForFile != NULL) {

        // Path is being changed.

        if ( strlen( pszPathForFile) < MAX_PATH) {

            strcpy( pDebugPrints->m_rgchLogFilePath, pszPathForFile);
        } else {

            return ( ERROR_INVALID_PARAMETER);
        }
    } else {

        if ( pDebugPrints->m_rgchLogFilePath[0] == '\0' &&  // no old path
            !GetWindowsDirectoryA( pDebugPrints->m_rgchLogFilePath, MAX_PATH)) {

            //
            //  Unable to get the windows default directory. Use current dir
            //

            strcpy( pDebugPrints->m_rgchLogFilePath, ".");
        }
    }

    //
    // Should need be, we need to create this directory for storing file
    //


    //
    // Form the complete Log File name and open the file.
    //
    if ( (strlen( pszFileName) + strlen( pDebugPrints->m_rgchLogFilePath))
         >= MAX_PATH) {

        return ( ERROR_NOT_ENOUGH_MEMORY);
    }

    //  form the complete path
    strcpy( pDebugPrints->m_rgchLogFileName, pDebugPrints->m_rgchLogFilePath);

    if ( pDebugPrints->m_rgchLogFileName[ strlen(pDebugPrints->m_rgchLogFileName) - 1]
        != '\\') {
        // Append a \ if necessary
        strcat( pDebugPrints->m_rgchLogFileName, "\\");
    };
    strcat( pDebugPrints->m_rgchLogFileName, pszFileName);

    return  PuOpenDbgFileLocal( pDebugPrints);

} // PuOpenDbgPrintFile()




DWORD
PuReOpenDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
/********************************************************************++

  This function closes any open log file and reopens a new copy.
  If necessary. It makes a backup copy of the file.

--*********************************************************************/

{
    if ( pDebugPrints == NULL) {
        return ( ERROR_INVALID_PARAMETER);
    }

    PuCloseDbgPrintFile( pDebugPrints);      // close any existing file.

    if ( pDebugPrints->m_dwOutputFlags & DbgOutputBackup) {

        // MakeBkupCopy();

        OutputDebugStringA( " Error: MakeBkupCopy() Not Yet Implemented\n");
    }

    return PuOpenDbgFileLocal( pDebugPrints);

} // PuReOpenDbgPrintFile()




DWORD
PuCloseDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
{
    DWORD dwError = NO_ERROR;

    if ( pDebugPrints == NULL ) {
        dwError = ERROR_INVALID_PARAMETER;
    } else {

        if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

            FlushFileBuffers( pDebugPrints->m_LogFileHandle);

            if ( !CloseHandle( pDebugPrints->m_LogFileHandle)) {

                CHAR pchBuffer[1024];

                dwError = GetLastError();

                wsprintfA( pchBuffer,
                          "CloseDbgPrintFile() : CloseHandle( %p) failed."
                          " Error = %d\n",
                          pDebugPrints->m_LogFileHandle,
                          dwError);
                OutputDebugStringA( pchBuffer);
            }

            pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return ( dwError);
} // DEBUG_PRINTS::CloseDbgPrintFile()

DWORD
PuOpenDbgMemoryLog(IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    DWORD dwError;
    CMemoryLog * pLog = NULL;

    if (NULL == pDebugPrints)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (NULL != pDebugPrints->m_pMemoryLog)
    {
        dwError = ERROR_SUCCESS;
        goto done;
    }

    pLog = new CMemoryLog(1024 * 512);  // max size of 512 K
    if (NULL == pLog)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    // save away the pointer
    pDebugPrints->m_pMemoryLog = pLog;

    // make sure output gets to the log
    pDebugPrints->m_dwOutputFlags |= DbgOutputMemory;

    dwError = NO_ERROR;
done:
    return dwError;
}

DWORD
PuCloseDbgMemoryLog(IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    DWORD dwError;

    if (NULL == pDebugPrints)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto done;
    }
    if (NULL != pDebugPrints->m_pMemoryLog)
    {
        CMemoryLog * pLog = (CMemoryLog*) (pDebugPrints->m_pMemoryLog);
        delete pLog;
        pDebugPrints->m_pMemoryLog = NULL;
    }

    dwError = NO_ERROR;
done:
    return dwError;
}

VOID
PupOutputMessage( 
   IN LPDEBUG_PRINTS  pDebugPrints,
   IN STRA           *straOutput
   )
{
  if ( pDebugPrints != NULL)
  {
      if ( ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) &&
           ( pDebugPrints->m_StdErrHandle != INVALID_HANDLE_VALUE ) ) {
          
          DWORD nBytesWritten;
          
          ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                             straOutput->QueryStr(),
                             straOutput->QueryCCH(),
                             &nBytesWritten,
                             NULL);
      }
      
      if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
           pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {
          
          DWORD nBytesWritten;
          
          //
          // Truncation of log files. Not yet implemented.
          
          ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                             straOutput->QueryStr(),
                             straOutput->QueryCCH(),
                             &nBytesWritten,
                             NULL);
          
      }

      if ( (pDebugPrints->m_dwOutputFlags & DbgOutputMemory) &&
           (NULL != pDebugPrints->m_pMemoryLog) )
      {
            CMemoryLog* pLog = (CMemoryLog*) (pDebugPrints->m_pMemoryLog);
            pLog->Append(straOutput->QueryStr(), straOutput->QueryCCH());
      }
           
  }


  if ( pDebugPrints == NULL ||
       pDebugPrints->m_dwOutputFlags & DbgOutputKdb)
  {
      OutputDebugStringA( straOutput->QueryStr() );
  }

  return;
}

void
FormatMsgToBuffer( IN OUT STRA * pSTRAOutput, 
                   IN LPDEBUG_PRINTS pDebugPrints, 
                   IN LPCSTR    pszFilePath, 
                   IN DWORD     nLineNum, 
                   IN LPCSTR	   pszFunctionName,
                   IN LPCSTR    pszFormat,
                   IN va_list * pargsList)
{
    LPCSTR pszFileName = strrchr( pszFilePath, '\\');
    int cchPrologue = 0;
    HRESULT hr = S_OK;
    DWORD cchOutput = 0;

    //
    //  Skip the complete path name and retain file name in pszName
    //

    if ( pszFileName== NULL) {

       // if skipping \\ yields nothing use whole path.
       pszFileName = pszFilePath;  
    }

    // Format the message header as: tid label!function [file @ line number]:message
    cchPrologue = wsprintfA( pSTRAOutput->QueryStr(), 
                            "%lu %hs!%hs [%hs @ %d]:",
                            GetCurrentThreadId(),
                            pDebugPrints ? pDebugPrints->m_rgchLabel : "??",
                            pszFunctionName,
                            pszFileName, 
                            nLineNum);

    // we directly touched the buffer - however, wait to SyncWithBuffer
    // until the rest of the operations are done.  Do NOT call QueryCCH() it will be WRONG.

   
    // Format the incoming message using vsnprintf() so that the overflows are
    //  captured
   
    cchOutput = _vsnprintf( pSTRAOutput->QueryStr() + cchPrologue,
                             pSTRAOutput->QuerySize() - cchPrologue - 1,
                             pszFormat, *pargsList);
       
    if ( cchOutput == -1 )
    {
        // couldn't fit this in the original STRA size.  Try a heap allocation.
        hr = pSTRAOutput->Resize(MAX_PRINTF_OUTPUT);
        if (FAILED(hr))
        {
            // Can't allocate, therefore don't give back half done results
            pSTRAOutput->Reset();
            return;
        }

        cchOutput = _vsnprintf( pSTRAOutput->QueryStr() + cchPrologue,
                                 pSTRAOutput->QuerySize() - cchPrologue - 1,
                                 pszFormat, *pargsList);
        if (cchOutput == -1)
        {
            // we need to NULL terminate, as _vsnprintf failed to do that for us.
            pSTRAOutput->QueryStr()[pSTRAOutput->QuerySize() - 1] = '\0';
        }
    }           

    // we directly touched the buffer - therefore:
    pSTRAOutput->SyncWithBuffer();

    return;
} // FormatMsgToBuffer()


/********************************************************************++
Routine Description:
   Main function that examines the incoming message and prints out a header
    and the message.

Arguments:
  pDebugPrints - pointer to the debug print object 
  pszFilePaht  - pointer to the file from where this function is called
  nLineNum     - Line number within the file
  pszFormat    - formatting string to use.

Returns:
  None
--*********************************************************************/

VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS     	pDebugPrints,
   IN const char *            		pszFilePath,
   IN int              			       nLineNum,
   IN const char *				pszFunctionName,
   IN const char *            		pszFormat,
   ...)
{
   STACK_STRA(straOutput, 256);
   va_list argsList;
   DWORD dwErr;

   // get a local copy of the error code so that it is not lost
  dwErr = GetLastError();

  va_start( argsList, pszFormat);
  FormatMsgToBuffer( &straOutput, 
                     pDebugPrints, 
                     pszFilePath, 
                     nLineNum, 
                     pszFunctionName,
                     pszFormat,
                     &argsList);
  
  va_end( argsList);
  
  //
  // Send the outputs to respective files.
  //
  PupOutputMessage( pDebugPrints, &straOutput);


  SetLastError( dwErr );

  return;
} // PuDbgPrint()

void
FormatMsgToBufferW( IN OUT STRU * pSTRUOutput, 
                   IN LPDEBUG_PRINTS pDebugPrints, 
                   IN LPCSTR    pszFilePath, 
                   IN DWORD     nLineNum, 
                   IN LPCSTR   pszFunctionName,
                   IN LPCWSTR    pszFormat,
                   IN va_list * pargsList)
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   int cchPrologue = 0;
   HRESULT hr = S_OK;
   DWORD cchOutput = 0;

   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      // if skipping \\ yields nothing use whole path.
      pszFileName = pszFilePath;  
   }

    // Format the message header as: tid label!function [file @ line number]:message
   cchPrologue = wsprintfW( pSTRUOutput->QueryStr(),
                           L"%lu %hs!%hs [%hs @ %d]:",
                           GetCurrentThreadId(),
                           pDebugPrints ? pDebugPrints->m_rgchLabel : "??",
                           pszFunctionName,
                           pszFileName, 
                           nLineNum);

   // we directly touched the buffer - however, wait to SyncWithBuffer
   // until the rest of the operations are done.  Do NOT call QueryCCH() it will be WRONG.
   
   // Format the incoming message using vsnprintf() so that the overflows are
   //  captured
   
   cchOutput = _vsnwprintf( pSTRUOutput->QueryStr() + cchPrologue,
                            pSTRUOutput->QueryBuffer()->QuerySize() / sizeof(WCHAR) - cchPrologue - 1, // this is a count of characters
                            pszFormat, *pargsList);
       
   if ( cchOutput == -1 )
   {
       // couldn't fit this in the original STRA size.  Try a heap allocation.
       hr = pSTRUOutput->Resize(MAX_PRINTF_OUTPUT);
       if (FAILED(hr))
       {
           // Can't allocate, therefore don't give back half done results
           pSTRUOutput->Reset();
           return;
       }

       cchOutput = _vsnwprintf( pSTRUOutput->QueryStr() + cchPrologue,
                                pSTRUOutput->QueryBuffer()->QuerySize() / sizeof(WCHAR) - cchPrologue - 1, // this is a count of characters
                                pszFormat, *pargsList);
       if (cchOutput == -1)
       {
           // we need to NULL terminate, as _vsnprintf failed to do that for us.
           pSTRUOutput->QueryStr()[(pSTRUOutput->QueryBuffer()->QuerySize() / sizeof(WCHAR)) - 1] = L'\0';
       }
   }           

   // we directly touched the buffer - therefore:
   pSTRUOutput->SyncWithBuffer();

  return;
} // FormatMsgToBuffer()

extern "C"
VOID
PuDbgPrintW(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFilePath,
   IN int                     nLineNum,
   IN const char *		pszFunctionName,
   IN const WCHAR *            pszFormat,
   ...
)
{
   STACK_STRU(struOutput, 256);
   va_list argsList;
   DWORD dwErr;
   HRESULT hr;
   // get a local copy of the error code so that it is not lost
  dwErr = GetLastError();

  va_start( argsList, pszFormat);
  FormatMsgToBufferW( &struOutput, 
                     pDebugPrints, 
                     pszFilePath, 
                     nLineNum, 
                     pszFunctionName,
                     pszFormat,
                     &argsList);
  
  va_end( argsList);
  
  //
  // Send the outputs to respective files.
  //
  STACK_STRA(straOutput, 256);
  hr = straOutput.CopyWTruncate(struOutput.QueryStr(), struOutput.QueryCCH());
  if (FAILED(hr))
  {
    goto done;
  }
  
  PupOutputMessage( pDebugPrints, &straOutput);

done:

  SetLastError( dwErr );

  return;
}

/********************************************************************++
Routine Description:
   This function behaves like PuDbgPrint() but also prints out formatted
   Error message indicating what failed.

Arguments:
  pDebugPrints - pointer to the debug print object 
  pszFilePaht  - pointer to the file from where this function is called
  nLineNum     - Line number within the file
  dwError      - Error code for which the formatted error message should
                  be printed
  pszFormat    - formatting string to use.

Returns:
  None
--*********************************************************************/
VOID
PuDbgPrintError(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunctionName, 
   IN DWORD                dwError,
   IN const char *         pszFormat,
   ...) // argsList
{
   STACK_STRA(straOutput, 256);
   va_list argsList;
   DWORD dwErr;

   // get a local copy of the error code so that it is not lost
  dwErr = GetLastError();

  va_start( argsList, pszFormat);
  FormatMsgToBuffer( &straOutput, 
                     pDebugPrints, 
                     pszFilePath, 
                     nLineNum, 
                     pszFunctionName, 
                     pszFormat,
                     &argsList);
  
  va_end( argsList);


  //
  // obtain the formatted error message for error code
  // 

  LPSTR lpErrorBuffer = NULL;
  DWORD nRet;
  nRet = 
      FormatMessageA((FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                      FORMAT_MESSAGE_FROM_SYSTEM),
                     NULL,     // lpSource
                     dwError,
                     LANG_NEUTRAL,
                     (LPSTR ) &lpErrorBuffer, // pointer to store buffer allocated
                     0,    // size of buffer
                     NULL  // lpArguments
                     );

  if (lpErrorBuffer)
  {
    CHAR pszErrorOut[64];  // 64 from: (/t=)4 + (Error(=)7 + (%x=)18 (0x + 16hex on 64 bit systems) + (): =)3 == 32 + some more slop
    _snprintf( pszErrorOut,
               sizeof(pszErrorOut) / sizeof(CHAR),
               "\tError(%x): ",
               dwError);
    pszErrorOut[63] = '\0';

    // if these appends fail, nothing to be done about it therefore just ignore the return values
    straOutput.Append(pszErrorOut);

    straOutput.Append(lpErrorBuffer);
    straOutput.Append("\n");
  }

  //
  // Send the outputs to respective files.
  //
  PupOutputMessage( pDebugPrints, &straOutput);

  // free the buffer if any was allocated  
  if ( lpErrorBuffer != NULL) {
      LocalFree (lpErrorBuffer);
  }

  SetLastError( dwErr );

  return;
} // PuDbgPrintError()



VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunctionName,
   IN const char *         pszDump
   )
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   DWORD dwErr;
   DWORD cbDump;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;
   }

   dwErr = GetLastError();

   // No message header for this dump
   cbDump = strlen( pszDump);

   //
   // Send the outputs to respective files.
   //

   if ( pDebugPrints != NULL)
   {
       if ( ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) &&
            ( pDebugPrints->m_StdErrHandle != INVALID_HANDLE_VALUE ) ) {
           
           DWORD nBytesWritten;
           
           ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                              pszDump,
                              cbDump,
                              &nBytesWritten,
                              NULL);
       }
       
       if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
            pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {
           
           DWORD nBytesWritten;
           
           //
           // Truncation of log files. Not yet implemented.
           
           ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                              pszDump,
                              cbDump,
                              &nBytesWritten,
                              NULL);
           
       }

       if ( (pDebugPrints->m_dwOutputFlags & DbgOutputMemory) &&
            (NULL != pDebugPrints->m_pMemoryLog) )
       {
           CMemoryLog * pLog = (CMemoryLog*)(pDebugPrints->m_pMemoryLog);
           pLog->Append(pszDump, cbDump);
       }
   }

   if ( pDebugPrints == NULL
       ||  pDebugPrints->m_dwOutputFlags & DbgOutputKdb)
   {
       OutputDebugStringA( pszDump);
   }

   SetLastError( dwErr );

  return;
} // PuDbgDump()

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

INT
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszFunctionName, 
    IN const char *               pszExpression,
    IN const char *               pszMessage)
/********************************************************************++
    This function calls assertion failure and records assertion failure
     in log file.

--*********************************************************************/

{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum, pszFunctionName,
                " Assertion (%s) Failed: %s\n"
                " use !cxr %p to dump context\n",
                pszExpression,
                pszMessage,
                &context);

    DebugBreak();

    return 0;
} // PuDbgAssertFailed()

#pragma optimize( "", on )      // restore frame pointer omission (FPO)



VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszFunctionName
    )
/********************************************************************++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*********************************************************************/

{
    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum, pszFunctionName,
                " TickCount = %u\n",
                GetTickCount()
                );

    return;
} // PrintOutCurrentTime()




DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault)
/********************************************************************++
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key.
  If there is any error the default value is returned.
--*********************************************************************/

{
    DWORD err;
    DWORD dwDebug = dwDefault;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               DEBUG_FLAGS_REGISTRY_LOCATION_A,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDebug = dwBuffer;
        }
    }

    return dwDebug;
} // PuLoadDebugFlagsFromReg()




DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault)
/********************************************************************++
Description:
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key location in registry.
  If there is any error the default value is returned.

Arguments:
  pszRegKey - pointer to registry key location from where to read the key from
  dwDefault - default values in case the read from registry fails

Returns:
   Newly read value on success
   If there is any error the dwDefault is returned.
--*********************************************************************/

{
    HKEY        hkey = NULL;

    DWORD dwVal = dwDefault;

    DWORD dwError = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                  pszRegKey,
                                  0,
                                  KEY_READ,
                                  &hkey);
    if ( dwError == NO_ERROR) {
        dwVal = PuLoadDebugFlagsFromReg( hkey, dwDefault);
        RegCloseKey( hkey);
        hkey = NULL;
    }

    return ( dwVal);
} // PuLoadDebugFlagsFromRegStr()





DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg)
/********************************************************************++
  Saves the debug flags in registry. On failure returns the error code for
   the operation that failed.

--*********************************************************************/
{
    DWORD err;

    if( hkey == NULL ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(hkey,
                             DEBUG_FLAGS_REGISTRY_LOCATION_A,
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwDbg,
                             sizeof(dwDbg) );
    }

    return (err);
} // PuSaveDebugFlagsInReg()


VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    )
{
    //
    // This space intentionally left blank.
    //

}   // PuDbgCaptureContext


/****************************** End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\stktrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    Implements IISCaptureStackBackTrace().

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>
#include <pudebug.h>
#include <stktrace.h>

USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Implementation of IISCaptureStackBackTrace() for all platforms.

Arguments:

    See RtlCaptureStackBackTrace() below.

Return Value:

    USHORT - Always 0.

--*/
{
    return RtlCaptureStackBackTrace(FramesToSkip,
                                    FramesToCapture,
                                    BackTrace,
                                    BackTraceHash);

}   // IISCaptureStackBackTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\stktrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This module contains public declarations and definitions for capturing
    stack back traces.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\string.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class.


    FILE HISTORY:
        Johnl       15-Aug-1994 Created
        MuraliK     27-Feb-1995 Modified to be a standalone module with buffer.
        MuraliK     2-June-1995 Made into separate library
        MCourage    12-Feb-1999 Another rewrite. All unicode of course.

*/

#include "precomp.hxx"


//
// Normal includes only for this module to be active
//

# include <string.hxx>


//
//  Private Definations
//

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
     (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + L'A'                           \
        : (nDigit) + L'0')


// Change a hexadecimal digit to its numerical equivalent
#define TOHEX( ch )                                     \
    ((ch) > L'9' ?                                      \
        (ch) >= L'a' ?                                  \
            (ch) - L'a' + 10 :                          \
            (ch) - L'A' + 10                            \
        : (ch) - L'0')

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128



/***************************************************************************++

Routine Description:

    Appends to the string starting at the (byte) offset cbOffset.

Arguments:

    pStr     - A unicode string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/


HRESULT
STRU::AuxAppend(
    const BYTE * pStr,
    ULONG        cbStr,
    ULONG        cbOffset,
    BOOL         fAddSlop
    )
{
    DBG_ASSERT( pStr );
    DBG_ASSERT( cbStr % 2 == 0 );
    DBG_ASSERT( cbOffset <= QueryCB() );
    DBG_ASSERT( cbOffset % 2 == 0 );
    
    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + cbStr + sizeof(WCHAR) )
    {
        UINT uNewSize = cbOffset + cbStr;

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(WCHAR);
        }
        
        if ( !m_Buff.Resize(uNewSize) ) {
            //
            // CODEWORK: BUFFER should return HRESULTs
            //
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    //
    // copy the exact string and append a null character
    //
    memcpy(
        (BYTE *) m_Buff.QueryPtr() + cbOffset,
        pStr,
        cbStr
        );

    //
    // set the new length
    //
    m_cchLen = (cbStr + cbOffset) / sizeof(WCHAR);

    //
    // append NUL character
    //
    *(QueryStr() + m_cchLen) = L'\0';

    return S_OK;
}

/***************************************************************************++

Routine Description:

    Convert and append an ANSI string to the string starting at 
    the (byte) offset cbOffset

Arguments:

    pStr     - An ANSI string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STRU::AuxAppendA(
    const BYTE * pStr,
    ULONG        cbStr,
    ULONG        cbOffset,
    BOOL         fAddSlop
    )
{
    WCHAR *             pszBuffer;
    
    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );
    DBG_ASSERT( cbOffset % 2 == 0 );
    
    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + (cbStr * sizeof( WCHAR )) + sizeof(WCHAR) )
    {
        UINT uNewSize = cbOffset + cbStr*sizeof(WCHAR);

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(WCHAR);
        }
        
        if ( !m_Buff.Resize(uNewSize) ) {
            //
            // CODEWORK: BUFFER should return HRESULTs
            //
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    //
    // Use MultiByteToWideChar to populate the buffer.
    //

    pszBuffer = (WCHAR*)((BYTE*) m_Buff.QueryPtr() + cbOffset);

    if ( !MultiByteToWideChar( CP_ACP,
                               MB_PRECOMPOSED,
                               (LPSTR)pStr,
                               -1,
                               pszBuffer,
                               m_Buff.QuerySize() ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // set the new length
    //
    m_cchLen = (cbStr*sizeof(WCHAR) + cbOffset) / sizeof(WCHAR);

    //
    // append NUL character
    //
    *(QueryStr() + m_cchLen) = L'\0';

    return S_OK;
}

HRESULT
STRU::CopyToBuffer( 
    WCHAR *         pszBuffer, 
    DWORD *         pcb
    ) const
{
    HRESULT         hr = S_OK;
    
    if ( pcb == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DWORD cbNeeded = (QueryCCH() + 1) * sizeof(WCHAR);
    if ( *pcb >= cbNeeded && 
         pszBuffer != NULL )
    {
        //
        // Do the copy
        //
        memcpy(pszBuffer, QueryStr(), cbNeeded);
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }
    
    *pcb = cbNeeded;
    
    return hr;
}

HRESULT STRU::Unescape()
/*++
  Unescape the string (URL or QueryString)
--*/
{
    WCHAR   *pScan;

    //
    // First convert any +'s to spaces
    //

    for (pScan = wcschr(QueryStr(), '+');
         pScan != NULL;
         pScan = wcschr(pScan + 1, L'+'))
    {
        *pScan = L' ';
    }

    //
    // Now take care of any escape characters
    //

    WCHAR   *pDest;
    WCHAR   *pNextScan;
    BOOL    fChanged = FALSE;

    pDest = pScan = wcschr(QueryStr(), L'%');

    while (pScan)
    {
        if ((pScan[1] == L'u' || pScan[1] == L'U') &&
            iswxdigit(pScan[2]) &&
            iswxdigit(pScan[3]) &&
            iswxdigit(pScan[4]) &&
            iswxdigit(pScan[5]))
        {
            *pDest = TOHEX(pScan[2]) * 4096 + TOHEX(pScan[3]) * 256
                + TOHEX(pScan[4]) * 16 + TOHEX(pScan[5]);

            pDest++;
            pScan += 6;
            fChanged = TRUE;
        }
        else if (iswxdigit(pScan[1]) && iswxdigit(pScan[2]))
        {
            *pDest = TOHEX(pScan[1]) * 16 + TOHEX(pScan[2]);

            pDest++;
            pScan += 3;
            fChanged = TRUE;
        }
        else   // Not an escaped char, just a '%'
        {
            if (fChanged)
            {
                *pDest = *pScan;
            }

            pDest++;
            pScan++;
        }

        //
        // Copy all the information between this and the next escaped char
        //
        pNextScan = wcschr(pScan, L'%');

        if (fChanged)   // pScan!=pDest, so we have to copy the char's
        {
            if (!pNextScan)   // That was the last '%' in the string
            {
                memmove(pDest,
                        pScan,
                        (QueryCCH() - DIFF(pScan - QueryStr()) + 1) *
                        sizeof(WCHAR));
            }
            else
            {  
                // There is another '%', move intermediate chars
                DWORD dwLen;
                if (dwLen = DIFF(pNextScan - pScan))
                {
                    memmove(pDest,
                            pScan,
                            dwLen * sizeof(WCHAR));
                    pDest += dwLen;
                }
            }
        }

        pScan = pNextScan;
    }

    if (fChanged)
    {
        m_cchLen = wcslen(QueryStr());  // for safety recalc the length
    }

    return S_OK;
}

WCHAR * SkipWhite( 
    WCHAR * pwch 
)
{
    while ( ISWHITEW( *pwch ) )
    {
        pwch++;
    }

    return pwch;
}

WCHAR * SkipTo( 
    WCHAR * pwch, WCHAR wch 
)
{
    while ( *pwch && *pwch != L'\n' && *pwch != wch )
        pwch++;

    return pwch;
}

VOID 
WCopyToA(
    WCHAR      * wszSrc,
    CHAR       * szDest
    )
{
   while( *szDest++ = ( CHAR )( *wszSrc++ ) )
   { ; }
}

VOID 
ACopyToW(
    CHAR       * szSrc,
    WCHAR      * wszDest
    )
{
   while( *wszDest++ = ( WCHAR )( *szSrc++ ) )
   { ; }
}

WCHAR *
FlipSlashes(
    WCHAR *             pszPath
)
/*++

Routine Description:

    Simple utility to convert forward slashes to back slashes

Arguments:

    pszPath - Path to convert
    
Return Value:

    Returns pointer to original converted string

--*/
{
    WCHAR   ch;
    WCHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != L'\0' )
    {
        if( ch == L'/' )
        {
            *pszScan = L'\\';
        }

        pszScan++;
    }

    return pszPath;
}

static CHAR * s_rgchDays[] =  {
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat" };

CHAR * s_rgchMonths[] = {
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec" };

HRESULT
MakePathCanonicalizationProof(
    IN LPWSTR               pszName,
    OUT STRU*               pstrPath
    )
/*++

Routine Description:

    This functions adds a prefix
    to the string, which is "\\?\UNC\" for a UNC path, and "\\?\" for
    other paths.  This prefix tells Windows not to parse the path.

Arguments:

    IN  pszName     - The path to be converted
    OUT pstrPath    - Output path created

Return Values:

    HRESULT

--*/
{
    HRESULT hr;

    if ( pszName[ 0 ] == L'\\' && pszName[ 1 ] == L'\\' )
    {
        //
        // If the path is already canonicalized, just return
        //

        if ( ( pszName[ 2 ] == '?' || pszName[ 2 ] == '.' ) &&
             pszName[ 3 ] == '\\' )
        {
            hr = pstrPath->Copy( pszName );

            if ( SUCCEEDED( hr ) )
            {
                //
                // If the path was in DOS form ("\\.\"),
                // we need to change it to Win32 from ("\\?\")
                //

                pstrPath->QueryStr()[2] = L'?';
            }

            return hr;
        }

        pszName += 2;


        if ( FAILED( hr = pstrPath->Copy( L"\\\\?\\UNC\\" ) ) )
        {
            return hr;
        }
    }
    else
    {
        if ( FAILED( hr = pstrPath->Copy( L"\\\\?\\" ) ) )
        {
            return hr;
        }
    }

    return pstrPath->Append( pszName );
}

LONG
CompareStringNoCase(
    IN const WCHAR * String1,
    IN const WCHAR * String2,
    IN DWORD cchString1,  // defaults to zero
    IN DWORD cchString2   // defaults to zero
    )
/*++

Routine Description:

    Uses the system local to determine if the strings are 
    equal regardless of case.

Arguments:
    
    IN const WCHAR * String1 = First String to Compare
    IN const WCHAR * String2 = Second String to Compare
    IN DWORD cchString1 = 0  = A length of the first string if we know it.
    IN DWORD cchString2 = 0  = A length of the second string if we know it.


Return Value:

    LONG - ( same rules that work for wcscmp )
           Less than zero if string1 less than string2 ( actually return -1 )
           Equals zero if string1 equals string2
           Greater than zero if string1 greater than string2 ( actually return 1 )
--*/
{ 
    int RetVal = 0;  // used to capture the return value for the CompareString

    // These checks are done to avoid the part
    // below where we do wcslen, and it may be null.
    // Even though we won't have to do this if the 
    // size is passed in, we still do this for 
    // consistency.
    
    // if the keys are null then 
    // they are considered equal
    if ( String1 == NULL && String2 == NULL )
    {
        return 0;
    }

    // we know that both aren't null so
    // if just the first key is null we
    // assume it is less than the second
    if ( String1 == NULL )
    {
        return -1;
    }

    // we know that both aren't null so 
    // if just the second key is null we
    // assume it is greater than the first
    if ( String2 == NULL )
    {
        return 1;
    }

    // At this point we know we don't have any nulls
    // to deal with.  Now we need to determine if we have
    // sizes.  If the size is zero then we need to use
    // the wcslen to figure it out.

    if ( cchString1 == 0 )
    {
        cchString1 = wcslen( String1 );
    }

    if ( cchString2 == 0 )
    {
        cchString2 = wcslen( String2 );
    }
    
    RetVal = CompareString( LOCALE_SYSTEM_DEFAULT,
                            NORM_IGNORECASE,
                            String1,
                            cchString1,
                            String2,
                            cchString2 );
    switch ( RetVal )
    {
        case ( CSTR_EQUAL ):
            return 0;
        break;
        case ( CSTR_LESS_THAN ):
            return -1;
        break;
        case ( CSTR_GREATER_THAN ):
            return 1;
        break;
        default:
            // This can happen if CompareString returns 0 
            // which means it failed, or an unexpected value.
            DBG_ASSERT ( L"CompareString Failed \n");
            return -1;
        break;
    }
} 

HRESULT STRU::Escape()
{
    WCHAR *  pch     = QueryStr();   
    int     i        = 0;
    WCHAR   ch;
    HRESULT hr       = S_OK;
    
    // Set to true if any % escaping occurs
    BOOL fEscapingDone = FALSE;

    //
    // if there are any characters that need to be escaped we copy the
    // entire string character by character into strTemp, escaping as
    // we go, then at the end copy all of strTemp over
    //
    STRU  strTemp;

    while ( ch = pch[i] )
    {
        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( !iswalnum(ch) &&
             ch != L'/' &&
             ch != L'.' )
        {
            if (FALSE == fEscapingDone)
            {
                // first character in the string that needed escaping
                fEscapingDone = TRUE;

                // copy all of the previous buffer into buffTemp
                hr = strTemp.Copy(this->QueryStr(), 
                                  i);
                if (FAILED(hr))
                {
                    return hr;
                }
            }

            //
            //  Create the string to append for the current character
            //
            
            WCHAR pchHex[6];
            DWORD cchToCopy;
            pchHex[0] = L'%';

            if (ch < 256)
            {
                pchHex[2] = HEXDIGIT( ch % 16 );
                ch /= 16;
                pchHex[1] = HEXDIGIT( ch % 16 );

                cchToCopy = 3;
            }
            else
            {
                pchHex[1] = L'u';
                pchHex[5] = HEXDIGIT( ch % 16 );
                ch /= 16;
                pchHex[4] = HEXDIGIT( ch % 16 );
                ch /= 16;
                pchHex[3] = HEXDIGIT( ch % 16 );
                ch /= 16;
                pchHex[2] = HEXDIGIT( ch % 16 );

                cchToCopy = 6;
            }

            hr = strTemp.Append(pchHex, cchToCopy);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            // if no escaping done, no need to copy
            if (fEscapingDone)
            {
                // if ANY escaping done, copy current character into new buffer
                strTemp.Append(&pch[i], 1);
            }
        }

        // inspect the next character in the string
        i++;
    }

    if (fEscapingDone)
    {
        // the escaped string is now in strTemp
        hr = this->Copy(strTemp);
    }

    return hr;

} // STRU::Escape()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\stringa.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class.


    FILE HISTORY:
        Johnl       15-Aug-1994 Created
        MuraliK     27-Feb-1995 Modified to be a standalone module with buffer.
        MuraliK     2-June-1995 Made into separate library
*/

#include "precomp.hxx"


//
// Normal includes only for this module to be active
//

# include <stringa.hxx>
# include <stringau.hxx>

//
//  Private Definations
//

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
     (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

// Change a hexadecimal digit to its numerical equivalent
#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128



/***************************************************************************++

Routine Description:

    Appends to the string starting at the (byte) offset cbOffset.

Arguments:

    pStr     - An ANSI string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT STRA::AuxAppend(const BYTE * pStr,
                        ULONG        cbStr,
                        ULONG        cbOffset,
                        BOOL         fAddSlop)
{
    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + cbStr + sizeof(CHAR) )
    {
        UINT uNewSize = cbOffset + cbStr;

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(CHAR);
        }

        if ( !m_Buff.Resize(uNewSize) ) {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // copy the exact string and append a null character
    //
    memcpy((BYTE *)m_Buff.QueryPtr() + cbOffset,
           pStr,
           cbStr);

    //
    // set the new length
    //
    m_cchLen = cbStr + cbOffset;

    //
    // append NULL character
    //
    *(QueryStr() + m_cchLen) = '\0';

    return S_OK;
}


/***************************************************************************++

Routine Description:

    Convert and append a UNICODE string to the string starting at
    the (byte) offset cbOffset

Arguments:

    pStr     - A UNICODE string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT STRA::AuxAppendW(const WCHAR * pStr,
                         ULONG         cchStr,
                         ULONG         cbOffset,
                         BOOL          fAddSlop)
{
    int iRet;

    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );

    if (cchStr == 0)
    {
        return S_OK;
    }

    if (cbOffset == 0)
    {
        iRet = ConvertUnicodeToMultiByte(pStr,
                                         &m_Buff,
                                         cchStr);
        if (-1 == iRet)
        {
            // could not convert
            return HRESULT_FROM_WIN32(GetLastError());
        }

        m_cchLen = iRet;
        DBG_ASSERT(strlen(QueryStr()) == m_cchLen);
        return S_OK;
    }
    else
    {
        STACK_BUFFER( buffTemp, 128);

        iRet = ConvertUnicodeToMultiByte(pStr,
                                         &buffTemp,
                                         cchStr);
        if (-1 == iRet)
        {
            // could not convert
            return HRESULT_FROM_WIN32(GetLastError());
        }

        return AuxAppend((const BYTE *)buffTemp.QueryPtr(),
                         iRet,
                         cbOffset,
                         fAddSlop);
    }
}

/***************************************************************************++

Routine Description:

    Convert and append a UNICODE string to the string starting at
    the (byte) offset cbOffset

Arguments:

    pStr     - A UNICODE string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT STRA::AuxAppendWTruncate(const WCHAR * pStr,
                                 ULONG         cchStr,
                                 ULONG         cbOffset,
                                 BOOL          fAddSlop)
{
    CHAR *pszBuffer;

    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + cchStr + sizeof(CHAR) )
    {
        UINT uNewSize = cbOffset + cchStr;

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(CHAR);
        }

        if ( !m_Buff.Resize(uNewSize) ) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

    }

    //
    // Copy/convert the UNICODE string over (by making two bytes into one)
    //
    pszBuffer = (CHAR *)((BYTE *)m_Buff.QueryPtr() + cbOffset);
    for (unsigned int i = 0; i < cchStr; i++)
    {
        pszBuffer[i] = (CHAR)pStr[i];
    }

    //
    // set the new length
    //
    m_cchLen = cchStr + cbOffset;

    //
    // append NULL character
    //
    *(QueryStr() + m_cchLen) = '\0';

    return S_OK;
}


HRESULT STRA::CopyWToUTF8Unescaped(const STRU& stru)
{ 
    return STRA::CopyWToUTF8Unescaped(stru.QueryStr(), stru.QueryCCH()); 
}

HRESULT STRA::CopyWToUTF8Unescaped(LPCWSTR cpchStr, DWORD cch)
{
    HRESULT hr = S_OK;
    int iRet;

    if (cch == 0)
    {
        Reset();
        return S_OK;
    }

    iRet = ConvertUnicodeToUTF8(cpchStr,
                                &this->m_Buff,
                                cch);
    if (-1 == iRet)
    {
        // could not convert
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    m_cchLen = iRet;

    DBG_ASSERT(strlen(reinterpret_cast<CHAR*>(this->m_Buff.QueryPtr())) == m_cchLen);
done:
    return hr;
}

HRESULT STRA::CopyWToUTF8(const STRU& stru)
{ 
    return STRA::CopyWToUTF8(stru.QueryStr(), stru.QueryCCH()); 
}

HRESULT STRA::CopyWToUTF8(LPCWSTR cpchStr, DWORD cch)
{
    HRESULT hr = S_OK;

    hr = STRA::CopyWToUTF8Unescaped(cpchStr, cch);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = STRA::Escape();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT STRA::Unescape()
/*++
  Unescape the string (URL or QueryString)
--*/
{
    CHAR   *pScan;

    //
    // First convert any +'s to spaces
    //

    for (pScan = strchr(QueryStr(), '+');
         pScan != NULL;
         pScan = strchr(pScan + 1, '+'))
    {
        *pScan = ' ';
    }

    //
    // Now take care of any escape characters
    //

    CHAR   *pDest;
    CHAR   *pNextScan;
    WCHAR   wch;
    DWORD   dwLen;
    BOOL    fChanged = FALSE;

    pDest = pScan = strchr(QueryStr(), '%');

    while (pScan)
    {
        if ((pScan[1] == 'u' || pScan[1] == 'U') &&
            SAFEIsXDigit(pScan[2]) &&
            SAFEIsXDigit(pScan[3]) &&
            SAFEIsXDigit(pScan[4]) &&
            SAFEIsXDigit(pScan[5]))
        {
            wch = TOHEX(pScan[2]) * 4096 + TOHEX(pScan[3]) * 256
                + TOHEX(pScan[4]) * 16 + TOHEX(pScan[5]);

            dwLen = WideCharToMultiByte(CP_ACP,
                                        0,
                                        &wch,
                                        1,
                                        (LPSTR) pDest,
                                        2,
                                        NULL,
                                        NULL);

            pDest += dwLen;
            pScan += 6;
            fChanged = TRUE;
        }
        else if (SAFEIsXDigit(pScan[1]) && SAFEIsXDigit(pScan[2]))
        {
            *pDest = TOHEX(pScan[1]) * 16 + TOHEX(pScan[2]);

            pDest ++;
            pScan += 3;
            fChanged = TRUE;
        }
        else   // Not an escaped char, just a '%'
        {
            if (fChanged)
            {
                *pDest = *pScan;
            }

            pDest++;
            pScan++;
        }

        //
        // Copy all the information between this and the next escaped char
        //
        pNextScan = strchr(pScan, '%');

        if (fChanged)   // pScan!=pDest, so we have to copy the char's
        {
            if (!pNextScan)   // That was the last '%' in the string
            {
                memmove(pDest,
                        pScan,
                        QueryCCH() - DIFF(pScan - QueryStr()) + 1);
            }
            else
            {
                // There is another '%', move intermediate chars
                if (dwLen = DIFF(pNextScan - pScan))
                {
                    memmove(pDest,
                            pScan,
                            dwLen);
                    pDest += dwLen;
                }
            }
        }

        pScan = pNextScan;
    }

    if (fChanged)
    {
        m_cchLen = strlen(QueryStr());  // for safety recalc the length
    }

    return S_OK;
}

/*******************************************************************

    NAME:       STRA::Escape

    SYNOPSIS:   Replaces non-ASCII characters with their hex equivalent

    NOTES:      If no characters need to be escaped, each character is simply
                walked once and compared a few times.

                If a character must be escaped, all previous characters
                are copied into a local temporary STRA and then all following
                characters are copied into the temporary.  At the end of the
                function the temporary STRA is copied back to this.

    HISTORY:
        Johnl   17-Aug-1994     Created
        jeffwall 1-May-2001     made somewhat efficient

********************************************************************/

HRESULT STRA::Escape(BOOL fEscapeHighBitCharsOnly /* = FALSE */,
                     BOOL fDontEscapeQueryString /* = FALSE */ )
{
    CHAR *  pch      = QueryStr();
    int     i        = 0;
    BYTE    ch;
    HRESULT hr       = S_OK;
    BOOL    fRet;

    BOOL    fContinueEscaping = TRUE;

    // Set to true if any % escaping occurs
    BOOL fEscapingDone = FALSE;

    // if there are any characters that need to be escaped we copy the entire string
    // character by character into straTemp, escaping as we go, then at the end
    // copy all of straTemp over
    STRA  straTemp;

    DBG_ASSERT( pch );

    while ( ch = pch[i] )
    {
        if ( fDontEscapeQueryString &&
             ( ch == '?' ) )
        {
            //
            // we reached query string. Don't escape the rest
            // just copy it over
            //
            fContinueEscaping = FALSE;
        }

        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( fContinueEscaping &&
             (
              ((ch >= 128) ||
              (!fEscapeHighBitCharsOnly &&
               ((ch <= 32) ||
                (ch == '<') ||
                (ch == '>') ||
                (ch == '%') ||
                (ch == '?') ||
                (ch == '#')
               )
              )
             ) &&
             !(ch == '\n' || ch == '\r')  ) )
        {
            if (FALSE == fEscapingDone)
            {
                // first character in the string that needed escaping
                fEscapingDone = TRUE;

                // guess that the size needs to be larger than
                // what we used to have times two
                hr = straTemp.Resize(QueryCCH() * 2);
                if (FAILED(hr))
                {
                    return hr;
                }

                // copy all of the previous buffer into buffTemp
                hr = straTemp.Copy(this->QueryStr(),
                                   i * sizeof(CHAR));
                if (FAILED(hr))
                {
                    return hr;
                }
            }

            // resize the temporary (if needed) with the slop of the entire buffer length
            // this fixes constant reallocation if the entire string needs to be escaped
            fRet = straTemp.m_Buff.Resize( QueryCCH() + 2 * sizeof(CHAR) + 1 * sizeof(CHAR), // current length + two hex + NULL
                                           QueryCCH());  // additional slop to allocate
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
            }

            //
            //  Create the string to append for the current character
            //

            CHAR chHex[3];
            chHex[0] = '%';

            //
            //  Convert the low then the high character to hex
            //

            UINT nLowDigit = (UINT)(ch % 16);
            chHex[2] = HEXDIGIT( nLowDigit );

            ch /= 16;

            UINT nHighDigit = (UINT)(ch % 16);

            chHex[1] = HEXDIGIT( nHighDigit );

            //
            // Actually append the converted character to the end of the temporary
            //
            hr = straTemp.Append(chHex, 3);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            // if no escaping done, no need to copy
            if (fEscapingDone)
            {
                // if ANY escaping done, copy current character into new buffer
                straTemp.Append(&pch[i], 1);
            }
        }

        // inspect the next character in the string
        i++;
    }

    if (fEscapingDone)
    {
        // the escaped string is now in straTemp
        hr = this->Copy(straTemp);
    }

    return hr;

} // STRA::Escape()

/*******************************************************************

    NAME:       STRA::LoadString

    SYNOPSIS:   Loads a string resource from this module's string table
                or from the system string table

    ENTRY:      dwResID - System error or module string ID
                lpszModuleName - name of the module from which to load.
                 If NULL, then load the string from system table.

********************************************************************/

HRESULT STRA::LoadString( IN DWORD   dwResID,
                          IN LPCSTR  lpszModuleName, // Optional
                          IN DWORD   dwLangID        // Optional
                        )
{
    HRESULT hr = FALSE;
    INT     cch;

    //
    //  If lpszModuleName is NULL, load the string from system's string table.
    //

    if ( lpszModuleName == NULL) {

        BYTE * pchBuff = NULL;

        //
        //  Call the appropriate function so we don't have to do the Unicode
        //  conversion
        //

        cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_IGNORE_INSERTS  |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                dwResID,
                                dwLangID,
                                (LPSTR) &pchBuff,
                                1024,
                                NULL );

        if ( cch ) {

            hr = Copy( (LPCSTR) pchBuff, cch );
        }

        //
        //  Free the buffer FormatMessage allocated
        //

        if ( cch )
        {
            ::LocalFree( (VOID*) pchBuff );
        }

    }
    else
    {
        CHAR ach[STR_MAX_RES_SIZE];
        cch = ::LoadStringA( GetModuleHandleA( lpszModuleName),
                             dwResID,
                             (CHAR *) ach,
                             sizeof(ach));
        if ( cch )
        {
            hr =  Copy( (LPSTR) ach, cch );
        }
    }

    return ( hr );

} // STR::LoadString()

HRESULT STRA::LoadString( IN DWORD  dwResID,
                          IN HMODULE hModule
                         )
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( hModule != NULL );

    BOOL fReturn = FALSE;
    INT  cch;
    CHAR ach[STR_MAX_RES_SIZE];

    cch = ::LoadStringA(hModule,
                        dwResID,
                        (CHAR *) ach,
                        sizeof(ach));
    if ( cch ) {
        hr =  Copy( (LPSTR) ach, cch );
    }
    else {
      	hr =  HRESULT_FROM_WIN32( GetLastError() );
    }

    return ( hr );

} // STRA::LoadString()

HRESULT
STRA::FormatString(
    IN DWORD   dwResID,
    IN LPCSTR  apszInsertParams[],
    IN LPCSTR  lpszModuleName,
    IN DWORD   cbMaxMsg
    )
{
    DWORD   cch;
    LPSTR   pchBuff;
    HRESULT hr = E_FAIL;

    cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                            FORMAT_MESSAGE_FROM_HMODULE,
                            GetModuleHandleA( lpszModuleName ),
                            dwResID,
                            0,
                            (LPSTR) &pchBuff,
                            cbMaxMsg * sizeof(WCHAR),
                            (va_list *) apszInsertParams );

    if ( cch )
    {
        hr = Copy( (LPCSTR) pchBuff, cch );

        ::LocalFree( (VOID*) pchBuff );
    }

    return hr;
}


HRESULT
STRA::CopyToBuffer(
    CHAR *         pszBuffer,
    DWORD *        pcb
    ) const
{
    HRESULT         hr = S_OK;

    if ( pcb == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DWORD cbNeeded = QueryCCH() + 1;
    if ( *pcb >= cbNeeded &&
         pszBuffer != NULL )
    {
        //
        // Do the copy
        //
        memcpy(pszBuffer, QueryStr(), cbNeeded);
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }

    *pcb = cbNeeded;

    return hr;
}


HRESULT STRA::HTMLEncode()
{
    CHAR *  pch      = QueryStr();   
    int     i        = 0;
    CHAR    ch;
    HRESULT hr       = S_OK;
    
    // Set to true if any % escaping occurs
    BOOL fEncodingDone = FALSE;

    //
    // if there are any characters that need to be encoded we copy the
    // entire string character by character into strTemp, escaping as
    // we go, then at the end copy all of strTemp over
    //
    STRA  strTemp;

    while ( ch = pch[i] )
    {
        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if (ch == '&' ||
            ch == '"' ||
            ch == '<' ||
            ch == '>' ||
            ch == '{' ||
            ch == '}')
        {
            if (!fEncodingDone)
            {
                // first character in the string that needed escaping
                fEncodingDone = TRUE;

                // copy all of the previous buffer into buffTemp
                hr = strTemp.Copy(this->QueryStr(), 
                                  i);
                if (FAILED(hr))
                {
                    return hr;
                }
            }

            //
            //  Create the string to append for the current character
            //
            
            CHAR *pchHex = NULL;
            DWORD cchToCopy = 0;

            switch (ch)
            {
                case '&':
                    pchHex = "&amp;";
                    cchToCopy = 5;
                    break;

                case '"':
                    pchHex = "&quot;";
                    cchToCopy = 6;
                    break;

                case '<':
                    pchHex = "&lt;";
                    cchToCopy = 4;
                    break;

                case '>':
                    pchHex = "&gt;";
                    cchToCopy = 4;
                    break;

                case '{':
                    pchHex = "&#x7b;";
                    cchToCopy = 6;
                    break;

                case '}':
                    pchHex = "&#x7d;";
                    cchToCopy = 6;
                    break;
            }

            hr = strTemp.Append(pchHex, cchToCopy);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            // if no escaping done, no need to copy
            if (fEncodingDone)
            {
                // if ANY escaping done, copy current character into new buffer
                hr = strTemp.Append(&pch[i], 1);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
        }

        // inspect the next character in the string
        i++;
    }

    if (fEncodingDone)
    {
        // the escaped string is now in strTemp
        hr = this->Copy(strTemp);
    }

    return hr;

} // STRA::HTMLEncode()

HRESULT STRA::CopyBinary( LPVOID pData, DWORD cbData )
{
    LPSTR   pCursor;
    CHAR    szHexChar[4] = {0};
    CHAR    szHexLine[52] = {0};
    CHAR    szPrintableLine[17] = {0};
    CHAR    szCookedLine[78] = {0};
    BYTE    c;
    DWORD   x;
    DWORD   y;
    HRESULT hr = S_OK;

    //
    // If we are passed a NULL buffer, set an empty dump
    //

    if ( cbData == 0 ||
         pData == NULL )
    {
        return Copy( "00000000                         -\r\n" );
    }

    //
    // Size the target buffer so that we know the data
    // will fit.  Each 16 bytes of binary data will result
    // in one 77 char line as follows:
    //
    //   9 chars for the index and space
    //  48 chars for hex codes and a space for each byte
    //   2 chars for the "- " separator between the 1st and last 8 hex codes
    //  16 chars for the actual bytes
    //   2 chars for the CRLF
    //
    // Add one final byte for the NULL terminator
    //
    // The resulting string looks something like this:
    //
    // 00000000 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
    // 00000010 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
    //

    hr = Resize( cbData / 16 * 77 + 1 );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    pCursor = QueryStr();

    for ( x = 0; x < cbData; x += 16 )
    {
        *szHexLine = '\0';
        *szPrintableLine = '\0';

        for ( y = 0; y < 16; y++ )
        {
            if ( x + y < cbData )
            {
                c = (BYTE)*((LPBYTE)pData+x+y);

                wsprintfA( szHexChar,
                          "%02x ",
                          c );

                strcat( szHexLine, szHexChar );

                if ( IS_EXTENDED_ASCII_PRINTABLE( c ) )
                {
                    szPrintableLine[y] = c;
                }
                else
                {
                    szPrintableLine[y] = '.';
                }
            }
            else
            {
                strcat( szHexLine, "   " );
                szPrintableLine[y] = ' ';
            }

            if ( y == 7 )
            {
                strcat( szHexLine, "- " );
            }
        }

        wsprintfA( szCookedLine,
                   "%08x %s%s\r\n",
                   x,
                   szHexLine,
                   szPrintableLine );

        hr = Append( szCookedLine );

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\stringau.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997-1999           **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class for storing 
    and operating on UNICODE and ANSI strings

    FILE HISTORY:
    4/8/97      michth      created

*/

#include "precomp.hxx"
#include "stringau.hxx"
#include "dbgutil.h"



VOID
STRAU::AuxInit( LPCSTR pInit )
{
    BOOL fRet;

    if ( pInit && (*pInit != '\0') )
    {
        INT cbCopy = (::strlen( pInit ) + 1) * sizeof(CHAR);
        fRet = m_bufAnsi.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufAnsi.QueryPtr(), pInit, cbCopy );
            m_cbMultiByteLen = (cbCopy)/sizeof(CHAR) - 1;
            m_bUnicode = FALSE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // STRAU::AuxInit()


VOID
STRAU::AuxInit( LPCWSTR pInit )
{
    BOOL fRet;

    if ( pInit && (*pInit != (WCHAR)'\0'))
    {
        INT cbCopy = (::wcslen( pInit) + 1) * sizeof(WCHAR);
        fRet = m_bufUnicode.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufUnicode.QueryPtr(), pInit, cbCopy );
            m_cchUnicodeLen = (cbCopy)/sizeof(WCHAR) - 1;
            m_bUnicode = TRUE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // STRAU::AuxInit()


/*******************************************************************

    NAME:       STRAU::AuxAppend

    SYNOPSIS:   Appends the string onto this one.

    ENTRY:      Object to append
********************************************************************/


BOOL STRAU::AuxAppend( LPCSTR pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    BOOL bReturn = m_bIsValid;

    if (m_bIsValid) {
        if (!m_bUnicode || (m_cchUnicodeLen == 0)) {
            //
            // Just append the ANSI string
            //
            //
            //  Only resize when we have to.  When we do resize, we tack on
            //  some extra space to avoid extra reallocations.
            //
            //  Note: QuerySize returns the requested size of the string buffer,
            //        *not* the strlen of the buffer
            //

            if ( m_bufAnsi.QuerySize() < ((m_cbMultiByteLen + cbStr + 1) * sizeof(CHAR)) )
            {
                bReturn = m_bufAnsi.Resize( ((m_cbMultiByteLen + cbStr + 1) * sizeof(CHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
            }

            if (bReturn) {
                // copy the exact string and append a null character
                memcpy( (BYTE *) (((LPSTR)m_bufAnsi.QueryPtr()) + m_cbMultiByteLen),
                        pStr,
                        cbStr * sizeof(char));
                m_cbMultiByteLen += cbStr;
                *((CHAR *) m_bufAnsi.QueryPtr() + m_cbMultiByteLen) = '\0';  // append an explicit null char
                m_bUnicode = FALSE;
                m_bInSync = FALSE;
            }
            else {
                m_bIsValid = FALSE;
            }
        }
        else {
            //
            // Currently have a UNICODE string
            // Need to convert to UNICODE and copy
            // Use the ANSI buffer as temporary space
            //
            int iUnicodeLen = ConvertMultiByteToUnicode((LPSTR)pStr, &m_bufAnsi, cbStr);
            if (STR_CONVERSION_SUCCEEDED(iUnicodeLen)) {
                if ( m_bufUnicode.QuerySize() < ((m_cchUnicodeLen + iUnicodeLen + 1) * sizeof(WCHAR)) )
                {
                    bReturn = m_bufUnicode.Resize( ((m_cchUnicodeLen + iUnicodeLen + 1) * sizeof(WCHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
                }

                if (bReturn) {
                    // copy the exact string and append a null character
                    memcpy( (BYTE *) ((LPWSTR)(m_bufUnicode.QueryPtr()) + m_cchUnicodeLen),
                            m_bufAnsi.QueryPtr(),
                            (iUnicodeLen * sizeof(WCHAR)));
                    m_cchUnicodeLen += iUnicodeLen;
                    *((LPWSTR)m_bufUnicode.QueryPtr() + m_cchUnicodeLen) = (WCHAR)'\0';  // append an explicit null char
                    m_bInSync = FALSE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                m_bIsValid = FALSE;
            }
        }
    }
    return bReturn;
} // STRAU::AuxAppend()


BOOL STRAU::AuxAppend( LPCWSTR pStr, UINT cchStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    BOOL bReturn = m_bIsValid;
    int iUnicodeLen;

    if (m_bIsValid) {
        if (!m_bUnicode && !m_bInSync && (m_cbMultiByteLen != 0)) {

            // Currently have an ANSI string
            // Need to convert ANSI string to UNICODE before copy
            //
            iUnicodeLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen);
            if (STR_CONVERSION_SUCCEEDED(iUnicodeLen)) {
                m_cchUnicodeLen = iUnicodeLen;
            }
            else {
                bReturn = FALSE;
                m_bIsValid = FALSE;
            }
        }
        if (bReturn) {
            //
            //  Only resize when we have to.  When we do resize, we tack on
            //  some extra space to avoid extra reallocations.
            //
            //  Note: QuerySize returns the requested size of the string buffer,
            //        *not* the strlen of the buffer
            //
            if ( m_bufUnicode.QuerySize() < ((m_cchUnicodeLen + cchStr + 1) * sizeof(WCHAR)) )
            {
                bReturn = m_bufUnicode.Resize( ((m_cchUnicodeLen + cchStr + 1) * sizeof(WCHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
            }

            if (bReturn) {
                // copy the exact string and append a null character
                memcpy( (BYTE *) (((LPWSTR)m_bufUnicode.QueryPtr()) + m_cchUnicodeLen),
                        pStr,
                        (cchStr * sizeof(WCHAR)));
                m_cchUnicodeLen += cchStr;
                *((LPWSTR)m_bufUnicode.QueryPtr() + m_cchUnicodeLen) = (WCHAR)'\0';  // append an explicit null char
                m_bInSync = FALSE;
                m_bUnicode = TRUE;
            }
            else {
                m_bIsValid = FALSE;
            }
        }
    }
    return bReturn;
} // STRAU::AuxAppend()


BOOL
STRAU::SetLen( IN DWORD cchLen)
{
    BOOL bReturn = FALSE;
    if (cchLen <= QueryCCH()) {
        if (m_bUnicode || m_bInSync) {
            *((LPWSTR)m_bufUnicode.QueryPtr() + cchLen) = (WCHAR)'\0';
            m_cchUnicodeLen = cchLen;
        }
        if (!m_bUnicode || m_bInSync) {
            LPSTR pszTerminateByte = (LPSTR)m_bufAnsi.QueryPtr();
            WORD wPrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());
            if (wPrimaryLangID == LANG_JAPANESE ||
                wPrimaryLangID == LANG_CHINESE  ||
                wPrimaryLangID == LANG_KOREAN)
            {
                char *pszTop = pszTerminateByte;
                for (DWORD i = 0; i < QueryCCH(); i++) {
                    pszTerminateByte = CharNextExA(CP_ACP,
                                                   pszTerminateByte,
                                                   0);
                }
                m_cbMultiByteLen = DIFF(pszTerminateByte - pszTop);
            }
            else
            {
                pszTerminateByte += cchLen;
                m_cbMultiByteLen = cchLen;
            }
            *pszTerminateByte = '\0';
        }
        bReturn = TRUE;
    }

    return bReturn;
}

LPSTR
STRAU::QueryStrA()
{
return (LPSTR)PrivateQueryStr(FALSE);
}

LPWSTR
STRAU::QueryStrW()
{
return PrivateQueryStr(TRUE);
}


LPWSTR
STRAU::PrivateQueryStr(BOOL bUnicode)
{

    //
    // This can fail. Return a null string for either UNICODE or ANSI
    // So that clients expecting a valid pointer actually get one.
    //
    LPTSTR pszReturn = NULL;
    int iNewStrLen;

    if (m_bIsValid) {
        if ((bUnicode != m_bUnicode) && (!m_bInSync)) {
            //
            // Need to Convert First
            //
            if (bUnicode) {
                //
                // Convert current string to UNICODE
                //
                iNewStrLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cchUnicodeLen = iNewStrLen;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                //
                // Convert current string to Ansi
                //
                iNewStrLen = ConvertUnicodeToMultiByte((LPWSTR)m_bufUnicode.QueryPtr(), &m_bufAnsi, m_cchUnicodeLen);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cbMultiByteLen = iNewStrLen;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
        }

        if (m_bIsValid) {
            if (bUnicode) {
                pszReturn = (LPTSTR)m_bufUnicode.QueryPtr();
            }
            else {
                pszReturn = (LPTSTR)m_bufAnsi.QueryPtr();
            }

        }
    }

    return pszReturn;
}


BOOL
STRAU::SafeCopy( LPCSTR pchInit )
{
    BOOL bReturn = TRUE;
    SaveState();
    Reset();
    if (pchInit != NULL) {
        bReturn  = AuxAppend(pchInit, ::strlen( pchInit ), FALSE );
        if (!bReturn) {
            RestoreState();
        }
    }
    return bReturn;
}


BOOL
STRAU::SafeCopy( LPCWSTR pchInit )
{
    BOOL bReturn = TRUE;
    SaveState();
    Reset();
    if (pchInit != NULL) {
        bReturn  = AuxAppend( pchInit, ::wcslen( pchInit ), FALSE );
        if (!bReturn) {
            RestoreState();
        }
    }
    return bReturn;
}




/********************************************************************++
  Functions to handle ANSI/UNICODE  conversions
--********************************************************************/
int
ConvertMultiByteToUnicode(LPCSTR pszSrcAnsiString,
                          BUFFER *pbufDstUnicodeString,
                          DWORD dwStringLen)
{
    DBG_ASSERT(pszSrcAnsiString != NULL);
    int iStrLen = -1;
    BOOL bTemp;

    bTemp = pbufDstUnicodeString->Resize((dwStringLen + 1) * sizeof(WCHAR));
    if (bTemp) {
        iStrLen = MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszSrcAnsiString,
                                      dwStringLen + 1,
                                      (LPWSTR)pbufDstUnicodeString->QueryPtr(),
                                      (int)pbufDstUnicodeString->QuerySize());
        if (iStrLen == 0) {
            DBG_ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
            iStrLen = -1;
        }
        else {
            //
            // Don't count '\0'
            //
            iStrLen--;
        }


    }
    return iStrLen;
}

int
ConvertUnicodeToCodePage(LPCWSTR pszSrcUnicodeString,
                         BUFFER *pbufDstAnsiString,
                         DWORD dwStringLen,
                         UINT uCodePage)
{
    DBG_ASSERT(NULL != pszSrcUnicodeString);
    DBG_ASSERT(NULL != pbufDstAnsiString);

    BOOL bTemp;
    int iStrLen = 0;

    iStrLen = WideCharToMultiByte(uCodePage,
                                  0,
                                  pszSrcUnicodeString,
                                  dwStringLen+1,
                                  (LPSTR)pbufDstAnsiString->QueryPtr(),
                                  (int)pbufDstAnsiString->QuerySize(),
                                  NULL,
                                  NULL);
    if ((iStrLen == 0) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        iStrLen = WideCharToMultiByte(uCodePage,
                                      0,
                                      pszSrcUnicodeString,
                                      dwStringLen+1,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);
        if (iStrLen != 0) {
            // add one just for the extra NULL
            bTemp = pbufDstAnsiString->Resize(iStrLen+1, STR_SLOP);
            if (!bTemp) {
                iStrLen = 0;
            }
            else {
                iStrLen = WideCharToMultiByte(uCodePage,
                                              0,
                                              pszSrcUnicodeString,
                                              dwStringLen+1,
                                              (LPSTR)pbufDstAnsiString->QueryPtr(),
                                              (int)pbufDstAnsiString->QuerySize(),
                                              NULL,
                                              NULL);
            }

        }
    }

    if (0 != iStrLen)
    {
        // insert a terminating NULL into buffer for the dwStringLen+1 in the case that the dwStringLen+1 was not a NULL.
        ((CHAR*)pbufDstAnsiString->QueryPtr())[iStrLen - 1] = '\0';
    }

    
    //
    // Don't count '\0'
    // and convert 0 to -1 for errors
    //
    iStrLen--;
    return iStrLen;
}


int
ConvertUnicodeToMultiByte(LPCWSTR pszSrcUnicodeString,
                          BUFFER *pbufDstAnsiString,
                          DWORD dwStringLen)
{
    return ConvertUnicodeToCodePage(pszSrcUnicodeString,
                                    pbufDstAnsiString,
                                    dwStringLen,
                                    CP_ACP);
}

int
ConvertUnicodeToUTF8(LPCWSTR pszSrcUnicodeString,
                     BUFFER *pbufDstAnsiString,
                     DWORD dwStringLen)
{    
    return ConvertUnicodeToCodePage(pszSrcUnicodeString,
                                    pbufDstAnsiString,
                                    dwStringLen,
                                    CP_UTF8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\sharelok.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//   The include files for supporting classes.
//
//   The include files for supporting classes consists of
//   classes refered to or used in this class.  The structure
//   of each source module is as follows:
//      1. Include files.
//      2. Constants local to the class.
//      3. Data structures local to the class.
//      4. Data initializations.
//      5. Static functions.
//      6. Class functions.
//   Sections that are not required are omitted.
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.hxx"

#define IMPLEMENTATION_EXPORT
#include <Sharelok.h>


//////////////////////////////////////////////////////////////////////
//
//   Class constructor.
//
//   Create a new lock and initialize it.  This call is not
//   thread safe and should only be made in a single thread
//   environment.
//
//////////////////////////////////////////////////////////////////////

CSharelock::CSharelock( SBIT32 lNewMaxSpins, SBIT32 lNewMaxUsers )
{
        //
        //   Set the initial state.
        //
        m_lExclusive = 0;
        m_lTotalUsers = 0;
    m_lWaiting = 0;

        //
        //   Check the configurable values.
        //
        if ( lNewMaxSpins > 0 )
        { 
                m_lMaxSpins = lNewMaxSpins; 
        }
        else
        {
                throw (TEXT("Maximum spins invalid in constructor for CSharelock")); 
        }

        if ( (lNewMaxUsers > 0) && (lNewMaxUsers <= m_MaxShareLockUsers) )
        {
                m_lMaxUsers = lNewMaxUsers; 
        }
        else
        {
                throw (TEXT("Maximum share invalid in constructor for CSharelock")); 
        }

        //
        //   Create a semaphore to sleep on when the spin count exceeds
        //   its maximum.
        //
    if ( (m_hSemaphore = CreateSemaphore( NULL, 0, m_MaxShareLockUsers, NULL )) == NULL)
    {
                throw (TEXT("Create semaphore in constructor for CSharelock")); 
        }

#ifdef _DEBUG

        //
        //   Set the initial state of any debug variables.
        //
    m_lTotalExclusiveLocks = 0;
    m_lTotalShareLocks = 0;
    m_lTotalSleeps = 0;
    m_lTotalSpins = 0;
    m_lTotalTimeouts = 0;
    m_lTotalWaits = 0;
#endif
    }

//////////////////////////////////////////////////////////////////////
//
//   Sleep waiting for the lock.
//
//   We have decided it is time to sleep waiting for the lock
//   to become free.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::SleepWaitingForLock( SBIT32 lSleep )
{
        //
        //   We have been spinning waiting for the lock but it
        //   has not become free.  Hence, it is now time to 
        //   give up and sleep for a while.
        //
        (void) InterlockedIncrement( (LPLONG) & m_lWaiting );

        //
        //   Just before we go to sleep we do one final check
        //   to make sure that the lock is still busy and that
        //   there is someone to wake us up when it becomes free.
        //
        if ( m_lTotalUsers > 0 )
        {
#ifdef _DEBUG
                //
                //   Count the number of times we have slept on this lock.
                //
                (void) InterlockedIncrement( (LPLONG) & m_lTotalSleeps );

#endif
                //
                //   When we sleep we awoken when the lock becomes free
                //   or when we timeout.  If we timeout we simply exit
                //   after decrementing various counters.
                if (WaitForSingleObject( m_hSemaphore, lSleep ) != WAIT_OBJECT_0 )
                { 
#ifdef _DEBUG
                        //
                        //   Count the number of times we have timed out 
                        //   on this lock.
                        //
                        (void) InterlockedIncrement( (LPLONG) & m_lTotalTimeouts );

#endif
                        return FALSE; 
                }
        }
        else
        {
                //
                //   Lucky - the lock was just freed so lets
                //   decrement the sleep count and exit without
                //   sleeping.
                // 
                (void) InterlockedDecrement( (LPLONG) & m_lWaiting );
        }
        
        return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Update the spin limit.
//
//   Update the maximum number of spins while waiting for the lock.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::UpdateMaxSpins( SBIT32 lNewMaxSpins )
{
        if ( lNewMaxSpins > 0 )
        { 
                m_lMaxSpins = lNewMaxSpins; 

                return TRUE;
        }
        else
        { 
                return FALSE; 
        }
}

//////////////////////////////////////////////////////////////////////
//
//   Update the sharing limit.
//
//   Update the maximum number of users that can share the lock.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::UpdateMaxUsers( SBIT32 lNewMaxUsers )
{
        if ( (lNewMaxUsers > 0) && (lNewMaxUsers <= m_MaxShareLockUsers) )
        {
                ClaimExclusiveLock();

                m_lMaxUsers = lNewMaxUsers;
                
                ReleaseExclusiveLock();

                return TRUE;
        }
        else
        { 
                return FALSE; 
        }
}

//////////////////////////////////////////////////////////////////////
//
//   Wait for an exclusive lock.
//
//   Wait for the spinlock to become free and then claim it.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::WaitForExclusiveLock( SBIT32 lSleep )
{
#ifdef _DEBUG
        register SBIT32 lSpins = 0;
        register SBIT32 lWaits = 0;

#endif
        while ( m_lTotalUsers != 1 )
        {
                //
                //   The lock is busy so release it and spin waiting
                //   for it to become free.
                //
                (void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );
    
                //
                //  Find out if we are allowed to spin and sleep if
                //  necessary.
                //
                if ( (lSleep > 0) || (lSleep == INFINITE) )
                {
                        register SBIT32 lCount;

                        //
                        //   Wait by spinning and repeatedly testing the lock.
                        //   We exit when the lock becomes free or the spin limit
                        //   is exceeded.
                        //
                        for (lCount = (NumProcessors() < 2) ? 0 : m_lMaxSpins;
                 (lCount > 0) && (m_lTotalUsers > 0);
                 lCount -- )
                                ;
#ifdef _DEBUG

                        lSpins += (m_lMaxSpins - lCount);
                        lWaits ++;
#endif

                        //
                        //   We have exhusted our spin count so it is time to
                        //   sleep waiting for the lock to clear.
                        //
                        if ( lCount == 0 )
                        {
                                //
                                //   We have decide that we need to sleep but are
                                //   still holding an exclusive lock so lets drop it
                                //   before sleeping.
                                //
                                (void) InterlockedDecrement( (LPLONG) & m_lExclusive );

                                //
                                //   We have decide to go to sleep.  If the sleep time
                                //   is not 'INFINITE' then we must subtract the time
                                //   we sleep from our maximum sleep time.  If the
                                //   sleep time is 'INFINITE' then we can just skip
                                //   this step.
                                //
                                if ( lSleep != INFINITE )
                                {
                                        register DWORD dwStartTime = GetTickCount();

                                        if ( ! SleepWaitingForLock( lSleep ) )
                                        { 
                                                return FALSE; 
                                        }

                                        lSleep -= ((GetTickCount() - dwStartTime) + 1);
                                        lSleep = (lSleep > 0) ? lSleep : 0;
                                }
                                else
                                {
                                        if ( ! SleepWaitingForLock( lSleep ) )
                                        {
                                                return FALSE; 
                                        }
                                }

                                //
                                //   We have woken up again so lets reclaim the
                                //   exclusive lock we had earlier.
                                //
                                (void) InterlockedIncrement( (LPLONG) & m_lExclusive );
                        }
                }
                else
                { 
                        //
                        //   We have decide that we need to exit but are still
                        //   holding an exclusive lock.  so lets drop it and leave.
                        //
                        (void) InterlockedDecrement( (LPLONG) & m_lExclusive );

                        return FALSE; 
                } 

                //
                //   Lets test the lock again.
                //
                InterlockedIncrement( (LPLONG) & m_lTotalUsers );
        }
#ifdef _DEBUG

        (void) InterlockedExchangeAdd( (LPLONG) & m_lTotalSpins, (LONG) lSpins );
        (void) InterlockedExchangeAdd( (LPLONG) & m_lTotalWaits, (LONG) lWaits );
#endif

        return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Wait for a shared lock.
//
//   Wait for the lock to become free and then claim it.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::WaitForShareLock( SBIT32 lSleep )
{
#ifdef _DEBUG
        register SBIT32 lSpins = 0;
        register SBIT32 lWaits = 0;

#endif
        while ( (m_lExclusive > 0) || (m_lTotalUsers > m_lMaxUsers) )
        {
                //
                //   The lock is busy so release it and spin waiting
                //   for it to become free.
                //
                (void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );

                if ( (lSleep > 0) || (lSleep == INFINITE) )
                {
                        register SBIT32 lCount;

                        //
                        //   Wait by spinning and repeatedly testing the lock.
                        //   We exit when the lock becomes free or the spin limit
                        //   is exceeded.
                        //
                        for (lCount = (NumProcessors() < 2) ? 0 : m_lMaxSpins;
                 (lCount > 0) && ((m_lExclusive > 0) || (m_lTotalUsers >= m_lMaxUsers));
                 lCount -- )
                                ;
#ifdef _DEBUG

                        lSpins += (m_lMaxSpins - lCount);
                        lWaits ++;
#endif

                        //
                        //   We have exhusted our spin count so it is time to
                        //   sleep waiting for the lock to clear.
                        //
                        if ( lCount == 0 )
                        { 
                                //
                                //   We have decide to go to sleep.  If the sleep time
                                //   is not 'INFINITE' then we must subtract the time
                                //   we sleep from our maximum sleep time.  If the
                                //   sleep time is 'INFINITE' then we can just skip
                                //   this step.
                                //
                                if ( lSleep != INFINITE )
                                {
                                        register DWORD dwStartTime = GetTickCount();

                                        if ( ! SleepWaitingForLock( lSleep ) )
                                        { 
                                                return FALSE; 
                                        }

                                        lSleep -= ((GetTickCount() - dwStartTime) + 1);
                                        lSleep = (lSleep > 0) ? lSleep : 0;
                                }
                                else
                                {
                                        if ( ! SleepWaitingForLock( lSleep ) )
                                        {
                                                return FALSE; 
                                        }
                                }
                        }
                }
                else
                { 
                        return FALSE; 
                }

                //
                //   Lets test the lock again.
                //
                (void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );
        }
#ifdef _DEBUG


        (void) InterlockedExchangeAdd( (LPLONG) & m_lTotalSpins, (LONG) lSpins );
        (void) InterlockedExchangeAdd( (LPLONG) & m_lTotalWaits, (LONG) lWaits );
#endif

        return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Wake all sleepers.
//
//   Wake all the sleepers who are waiting for the spinlock.
//   All sleepers are woken because this is much more efficent
//   and it is known that the lock latency is short.
//
//////////////////////////////////////////////////////////////////////

void CSharelock::WakeAllSleepers( void )
{
    register LONG lWakeup = InterlockedExchange( (LPLONG) & m_lWaiting, 0 );

    if ( lWakeup > 0 )
    {
        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( m_hSemaphore, lWakeup, NULL ) )
        { 
                        throw (TEXT("Wakeup failed in ReleaseLock()")); 
                }
    }
    else
    {
        //
        //   When multiple threads pass through the critical section rapidly
        //   it is possible for the 'Waiting' count to become negative.
        //   This should be very rare but such a negative value needs to be
        //   preserved. 
        //
        InterlockedExchangeAdd( (LPLONG) & m_lWaiting, lWakeup ); 
    }
}

//////////////////////////////////////////////////////////////////////
//
//   Class destructor.
//
//   Destroy a lock.  This call is not thread safe and should
//   only be made in a single thread environment.
//
//////////////////////////////////////////////////////////////////////

CSharelock::~CSharelock( void )
{
    if ( ! CloseHandle( m_hSemaphore ) )
    { 
                throw (TEXT("Close semaphore in destructor for CSharelock")); 
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\timer.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Wrap-proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Functions Exported:

    InitializeSecondsTimer()
    GetCurrentTimeInSeconds()
    GetCurrentTimeInMilliseconds()

Revision History:
    MuraliK  14-Nov-1995 Made multi thread safe.
    
--*/


#include "precomp.hxx"


//
//  Timer globals
//

CRITICAL_SECTION    g_csTimerWrap;
BOOL                g_fInitCsTimerWrap = FALSE;


BOOL
InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if( !InitializeCriticalSectionAndSpinCount(&g_csTimerWrap,
                                               0x80000000 /* precreate event */ |
                                               IIS_DEFAULT_CS_SPIN_COUNT ) )
    {
        return FALSE;
    }
    g_fInitCsTimerWrap = TRUE;
    return TRUE;
} // InitializeSecondsTimer()

VOID
TerminateSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Terminate DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( g_fInitCsTimerWrap )
    {
        DeleteCriticalSection( &g_csTimerWrap );
        g_fInitCsTimerWrap = FALSE;
    }

} // TerminateSecondsTimer()


DWORD
GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetCurrentTime();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            dwWrapTime += (0xffffffff / 1000);
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (dwCurrentTime / 1000 + dwWrapTime);
}


__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
/*++

Routine Description:

    Get current time in milliseconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetTickCount();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            ++dwWrapTime;
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (((__int64)dwWrapTime)<<32) |  dwCurrentTime;
}


//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\tokenacl.cxx ===
/*++

   Copyright    (c)    1995-2000    Microsoft Corporation

   Module  Name :
        tokenacl.cxx

   Abstract:
        This module contains routines for manipulating token ACL's

   Author:

       Wade A. Hilmo (wadeh)        05-Dec-2000

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

--*/
#include "precomp.hxx"
#include "tokenacl.hxx"
#include "irtltoken.h"

//
// Globals
//

PSID    g_pSidWpg = NULL;           // SID for worker process group
PSID    g_pSidLocalSystem = NULL;   // SID for local system account

PTOKEN_PRIVILEGES   g_pTokenPrivilege = NULL;
LUID                g_BackupPrivilegeValue;

//
// Local functions
//

HRESULT
ExpandAcl(
    PACL paclOld,
    ULONG cbAclOld,
    PACL *ppAclNew,
    PSID psid
    );

HRESULT
AllowedAccessExists(
    PACL pAcl,
    ACCESS_MASK amDesiredAccess,
    PSID psid,
    BOOL * pfFound
    );

HRESULT
AddSidToTokenAcl(
    HANDLE hToken,
    PSID pSid,
    ACCESS_MASK amDesiredAccess
    );

VOID
GetSeBackupPrivilege(
    VOID
    );

//
// Implementations
//

HRESULT
InitializeTokenAcl(
    VOID
    )
/*++

Routine Description:

    Initializes this module by getting the SIDs for the worker
    process group and the local system account.

Arguments:

    None
  
Return Value:

    HRESULT

--*/
{
    SID_IDENTIFIER_AUTHORITY sidWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY sidNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL                     fResult;
    HRESULT                  hr = NO_ERROR;

    DWORD dwSidRequiredSize = 0;
    DWORD cchDomainRequiredSize = 0;
    SID_NAME_USE sidNameUse;
    
    if ( !LookupAccountName( NULL, 
                             L"IIS_WPG", 
                             NULL, // sid buffer
                             &dwSidRequiredSize, 
                             NULL, // domain buffer
                             &cchDomainRequiredSize, 
                             &sidNameUse ) )
    {
        STACK_BUFFER( bufSidWpg, 256 );
        STACK_BUFFER( bufDomain, 256 );

        fResult = bufSidWpg.Resize( dwSidRequiredSize );
        if ( !fResult )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto LExit;
        }
        DBG_ASSERT( bufSidWpg.QuerySize() >= dwSidRequiredSize );

        // cchDomainRequiredSize is returned as a TCHAR count therefore
        // modify dwDomainRequiredSize to be in bytes for allocation
        fResult = bufDomain.Resize( cchDomainRequiredSize * sizeof(WCHAR) );
        if ( !fResult )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto LExit;
        }
        DBG_ASSERT( bufDomain.QuerySize() >= cchDomainRequiredSize * sizeof(WCHAR) );


        // a little paranoia shouldn't hurt here
        DWORD dwSavedSidSize = dwSidRequiredSize;
        
        if ( !LookupAccountName( NULL,
                                 L"IIS_WPG",
                                 bufSidWpg.QueryPtr(),
                                 &dwSidRequiredSize,
                                 (LPWSTR) bufDomain.QueryPtr(),
                                 &cchDomainRequiredSize,
                                 &sidNameUse ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto LExit;
        }

        DBG_ASSERT( dwSavedSidSize == dwSidRequiredSize );
        
        DBG_ASSERT( SidTypeAlias == sidNameUse );
        
        // allocate g_pSidWpg and copy SID into g_pSidWpg
        g_pSidWpg = (PSID) LocalAlloc( LPTR, dwSidRequiredSize );
        if ( NULL == g_pSidWpg )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto LExit;
        }

        memcpy( g_pSidWpg, bufSidWpg.QueryPtr(), dwSidRequiredSize );
 
    }

    //
    // Get the Local System SID
    //

    fResult = AllocateAndInitializeSid(
        &sidNtAuthority,           // pIdentifierAuthority
        1,                         // nSubAuthorityCount
        SECURITY_LOCAL_SYSTEM_RID, // nSubAuthority0
        0,                         // nSubAuthority1
        0,                         // nSubAuthority2
        0,                         // nSubAuthority3
        0,                         // nSubAuthority4
        0,                         // nSubAuthority5
        0,                         // nSubAuthority6
        0,                         // nSubAuthority7
        &g_pSidLocalSystem         // pSid
        );

    if ( !fResult )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto LExit;
    }

    //
    // Initialize token privilege for SSP and Basic impersonation token
    //

    GetSeBackupPrivilege();
    
    
    return NO_ERROR;

LExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( g_pSidWpg )
    {
        LocalFree( g_pSidWpg );
        g_pSidWpg = NULL;
    }

    if ( g_pSidLocalSystem )
    {
        FreeSid( g_pSidLocalSystem );
        g_pSidLocalSystem = NULL;
    }

    return hr;
}

VOID
UninitializeTokenAcl(
    VOID
    )
/*++

Routine Description:

    Uninitializes this module by getting freeing the global SIDs.

Arguments:

    None
  
Return Value:

    HRESULT

--*/
{
    if ( g_pSidWpg )
    {
        LocalFree( g_pSidWpg );
        g_pSidWpg = NULL;
    }

    if ( g_pSidLocalSystem )
    {
        FreeSid( g_pSidLocalSystem );
        g_pSidLocalSystem = NULL;
    }

    if ( g_pTokenPrivilege != NULL )
    {
        LocalFree( g_pTokenPrivilege );
        g_pTokenPrivilege = NULL;
    }
}

HRESULT
WINAPI
GrantWpgAccessToToken(
    HANDLE  hToken
    )
/*++

Routine Description:

    Grant the worker process group access to the specified token.  This
    is particularly necessary for tokens that get duplicated for OOP
    ISAPI calls so that they can do a GetThreadToken call in the remote
    process.

Arguments:

    hToken - The handle to which the WPG should be added
  
Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( g_pSidWpg );
        
    hr = AddSidToTokenAcl(
        hToken,
        g_pSidWpg,
        TOKEN_ALL_ACCESS
        );

    DBG_ASSERT( SUCCEEDED( hr ) );

    return(hr);
}

HRESULT
WINAPI
AddWpgToTokenDefaultDacl(
    HANDLE  hToken
    )
/*++

Routine Description:

    Adds the worker process group and local system to the default
    DACL of the specified token.  This is particularly necessary in
    the case of OOP ISAPI requests, since any objects created in
    the remote process with a default DACL will get an ACL derived
    from this token's default DACL.  It's a good thing when the OOP
    process can access the objects it creates - especially when those
    objects are threads.

    Note that we will also add the local system account to the
    default DACL.

Arguments:

    hToken - The handle to be modified
  
Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;
    DWORD       cbTokenUserBuffer = 0;
    LPVOID      pvTokenUserBuffer = NULL;
    DWORD       cbNewAcl = 0;
    PACL        pNewAcl = NULL;

    DBG_ASSERT( g_pSidWpg );
    DBG_ASSERT( g_pSidLocalSystem );

    do
    {
        BOOL    bRet;

        //
        // Get the User SID from the token
        //

        // Get buffer size
        bRet = GetTokenInformation(  hToken,
                                     TokenUser,
                                     NULL,
                                     0,
                                     &cbTokenUserBuffer
                                     );
        DBG_ASSERT( bRet == FALSE );

        pvTokenUserBuffer = LocalAlloc( LPTR, cbTokenUserBuffer );
        if( !pvTokenUserBuffer )
        {
            DBG_ASSERT( pvTokenUserBuffer );
            hr = E_OUTOFMEMORY;
            break;
        }

        // Get TokenUser
        bRet = GetTokenInformation(  hToken,
                                     TokenUser,
                                     pvTokenUserBuffer,
                                     cbTokenUserBuffer,
                                     &cbTokenUserBuffer
                                     );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        PSID pSidUser = ((TOKEN_USER *)pvTokenUserBuffer)->User.Sid;
        
        DBG_ASSERT( pSidUser );

        //
        // Allocate and init our new ACL
        //
        cbNewAcl = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSidUser) - sizeof(DWORD) +
                   sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(g_pSidLocalSystem) - sizeof(DWORD) +
                   sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(g_pSidWpg) - sizeof(DWORD);

        pNewAcl = (PACL)LocalAlloc( LPTR, cbNewAcl );
        if( !pNewAcl )
        {
            DBG_ASSERT( pNewAcl );
            hr = E_OUTOFMEMORY;
            break;
        }

        bRet = InitializeAcl( pNewAcl, cbNewAcl, ACL_REVISION );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        //
        // Add the aces
        //
        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    pSidUser
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    g_pSidLocalSystem
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    g_pSidWpg
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        // Blast the new DACL into our token
        TOKEN_DEFAULT_DACL tddNew;
        tddNew.DefaultDacl = pNewAcl;

        bRet = SetTokenInformation( hToken,
                                    TokenDefaultDacl,
                                    &tddNew,
                                    cbNewAcl
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

    }while(FALSE);

    if( pvTokenUserBuffer )
    {
        LocalFree( pvTokenUserBuffer );
    }
    if( pNewAcl )
    {
        LocalFree( pNewAcl );
    }

    DBG_ASSERT( SUCCEEDED(hr) );
    return hr;
}

HRESULT
AddSidToTokenAcl(
    HANDLE      hToken,
    PSID        pSid,
    ACCESS_MASK amDesiredAccess
)
/*++

Routine Description:

    Adds the specified SID to the specified TOKEN's ACL

Arguments:

    hToken          - The handle to be modified
    pSid            - The SID to add
    amDesiredAccess - The access mask for the SID
  
Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    DWORD err;
    PSECURITY_DESCRIPTOR psdRelative = NULL;
    SECURITY_DESCRIPTOR sdAbsolute;
    ULONG cbSdPost;
    PACL pDacl = NULL;
    PACL pDaclNew = NULL;
    ULONG cbSD = 0;
    ULONG cbDacl;
    ULONG cbSacl;
    ULONG cbOwner;
    ULONG cbGroup;
    ACL_SIZE_INFORMATION AclSize;
    BOOL fFound;

    //
    // Get the SD of the token.
    // Call this twice; once to get the size, then again to get the info
    //
    GetKernelObjectSecurity(hToken,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            0,
                            &cbSD);

    if ( cbSD == 0 )
    {
        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    psdRelative = (PSECURITY_DESCRIPTOR) new BYTE[cbSD];
    if (psdRelative == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    if (!GetKernelObjectSecurity(hToken,
                                 DACL_SECURITY_INFORMATION,
                                 psdRelative,
                                 cbSD,
                                 &cbSD))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    //
    // Allocate a new Dacl
    //
    pDacl = (PACL) new BYTE[cbSD];
    if (pDacl == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    //
    // Make an absolute SD from the relative SD we have, and get the Dacl at the same time
    //
    cbSdPost = sizeof(sdAbsolute);
    cbDacl = cbSD;
    cbSacl = 0;
    cbOwner = 0;
    cbGroup = 0;
    if (!MakeAbsoluteSD(psdRelative,
                        &sdAbsolute,
                        &cbSdPost,
                        pDacl,
                        &cbDacl,
                        NULL,
                        &cbSacl,
                        NULL,
                        &cbOwner,
                        NULL,
                        &cbGroup))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }


    // discover if the ACE we want to add already exists on this object
    hr = AllowedAccessExists(pDacl, amDesiredAccess, pSid, &fFound);
    if (FAILED(hr))
    {
        goto LExit;
    }

    if (fFound)
    {
        hr = S_OK;
	goto LExit;
    }

    //
    // Copy ACEs over
    //
    hr = ExpandAcl(pDacl, cbSD, &pDaclNew, pSid);
    if (FAILED(hr))
    {
        goto LExit;
    }
    
    //
    // Add ACE to allow access
    //
    if (!AddAccessAllowedAce(pDaclNew, ACL_REVISION, amDesiredAccess, pSid))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    //
    // Set the new DACL in the SD
    //
    if (!SetSecurityDescriptorDacl(&sdAbsolute, TRUE, pDaclNew, FALSE))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    //
    // Set the new SD on the token object
    //
    if (!SetKernelObjectSecurity(hToken, DACL_SECURITY_INFORMATION, &sdAbsolute))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

LExit:
    delete []pDacl;
    delete pDaclNew;
    delete []psdRelative;

    return hr;
}

HRESULT
ExpandAcl(
    PACL    paclOld,
    ULONG   cbAclOld,
    PACL *  ppAclNew,
    PSID    psid
)
/*++

Routine Description:

  Expands ACL so that there is room for an additional ACE

Arguments:

    paclOld  - The old ACL to expand
    cbAclOld - The size of the old ACL
    ppAclNew - The newly expanded ACL
    pSid     - The SID to use
  
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    DWORD                   err;
    PACL                    pAclNew = NULL;
    ACL_SIZE_INFORMATION    asi;
    int                     dwAclSize;
    DWORD                   iAce;
    LPVOID                  pAce;

    DBG_ASSERT(paclOld != NULL);
    DBG_ASSERT(ppAclNew != NULL);
    
    //
    // Create a new ACL to play with
    //
    if (!GetAclInformation (paclOld, (LPVOID) &asi, (DWORD) sizeof (asi), AclSizeInformation))
    {
        goto LExit;
    }

    dwAclSize = cbAclOld + GetLengthSid(psid) + (8 * sizeof(DWORD));

    pAclNew = (PACL) new BYTE[dwAclSize];
    if (pAclNew == NULL)
    {
        return(E_OUTOFMEMORY);
    }
        
    if (!InitializeAcl(pAclNew, dwAclSize, ACL_REVISION))
    {
        goto LExit;
    }

    //
    // Copy all of the ACEs to the new ACL
    //
    for (iAce = 0; iAce < asi.AceCount; iAce++)
    {
        //
        // Get the ACE and header info
        //
        if (!GetAce(paclOld, iAce, &pAce))
        {
            goto LExit;
        }

        //
        // Add the ACE to the new list
        //
        if (!AddAce(pAclNew, ACL_REVISION, iAce, pAce, ((ACE_HEADER *)pAce)->AceSize))
        {
            goto LExit;
        }
    }

    *ppAclNew = pAclNew;
    return(NOERROR);
    
LExit:
    if (pAclNew != NULL)
    {
        delete []pAclNew;
    }
    
    DBG_ASSERT(FALSE);

    err = GetLastError();
    hr = HRESULT_FROM_WIN32(err);
    return hr;
}

BOOL 
DupTokenWithSameImpersonationLevel
( 
    HANDLE     hExistingToken,
    DWORD      dwDesiredAccess,
    TOKEN_TYPE TokenType,
    PHANDLE    phNewToken
)
/*++
Routine Description:

    Duplicate an impersionation token using the same ImpersonationLevel.
    
Arguments:

    hExistingToken - a handle to a valid impersionation token
    dwDesiredAccess - the access level to the new token (see DuplicateTokenEx)
    phNewToken - ptr to the new token handle, client must CloseHandle.

Return Value:

    Return value of DuplicateTokenEx
   
--*/
{
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD                        dwBytesReturned;

    if( !GetTokenInformation( hExistingToken,
                              TokenImpersonationLevel,
                              &ImpersonationLevel,
                              sizeof(ImpersonationLevel),
                              &dwBytesReturned
                              ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetTokenInformation - failed to get TokenImpersonationLevel "
                    "LastError=%d, using SecurityImpersonation\n",
                    GetLastError()
                    ));
        
        ImpersonationLevel = SecurityImpersonation;
    }

    return DuplicateTokenEx( hExistingToken,
                             dwDesiredAccess,
                             NULL,
                             ImpersonationLevel,
                             TokenType,
                             phNewToken
                             );
}

VOID
GetSeBackupPrivilege(
    VOID
    )
/*++
  Description:
    
    Prepare an appropriate token privilege used to adjust the 
    impersonation token privilege in order to work around 
    the problem introduced by using FILE_FLAG_BACKUP_SEMANTICS
    in CreateFileW call in W3_FILE_INFO::OpenFile. 

  Arguments:

    None.

  Returns:    
    
    None.

--*/
{
    g_pTokenPrivilege = ( PTOKEN_PRIVILEGES )LocalAlloc( LMEM_FIXED,
            sizeof( TOKEN_PRIVILEGES ) + sizeof( LUID_AND_ATTRIBUTES ));
    if ( g_pTokenPrivilege != NULL )
    {
        if ( !LookupPrivilegeValue( NULL,
                                    L"SeBackupPrivilege",
                                    &g_BackupPrivilegeValue ) )
        {
            g_pTokenPrivilege->PrivilegeCount = 0;
        }
        else
        {
            //
            // Set attributes to disable SeBackupPrivilege for SSP
            // impersonation token
            //

            g_pTokenPrivilege->PrivilegeCount = 1;

            g_pTokenPrivilege->Privileges[0].Luid = 
                                      g_BackupPrivilegeValue;
            
            g_pTokenPrivilege->Privileges[0].Attributes = 0;
        }
    }
}

VOID
WINAPI
DisableTokenBackupPrivilege(
    HANDLE hToken
    )
/*++
  Description:
    
    Remove the backup privilege from the token

  Arguments:

    hToken - The token to disable the backup privilege for

  Returns:    
    
    None.

--*/
{        
    //
    // Disable SeBackupPrivilege for impersonation token to get rid of the 
    // problem introduced by using FILE_FLAG_BACKUP_SEMANTICS in CreateFileW 
    // call in W3_FILE_INFO::OpenFile.
    //
    if ( g_pTokenPrivilege != NULL )
    {
        AdjustTokenPrivileges( 
                   hToken,
                   FALSE,
                   g_pTokenPrivilege,
                   NULL,
                   NULL,
                   NULL );
    }        
}

HRESULT
AllowedAccessExists(
    PACL pacl,
    ACCESS_MASK amDesiredAccess,
    PSID psid,
    BOOL * pfFound
    )
/*++
  Description:
    Determine if an ACCESS_ALLOWED ACE currently is in the acl for the 
    given psid and amDesiredAccess

  Arguments:
    pacl - the acl to check
    amDesiredAccess - the desired access
    psid - the user sid to check for
    pfFound - TRUE if there is an ACE in the ACL that already allows this 
              type of access for this user

  Returns:
    S_OK / error code.  

--*/
{
  HRESULT hr = S_OK;
  ACL_SIZE_INFORMATION asi;

  DBG_ASSERT(pacl);
  DBG_ASSERT(psid);
  DBG_ASSERT(pfFound);

  *pfFound = FALSE;

  if ( !GetAclInformation(pacl, &asi, sizeof(asi), AclSizeInformation) )
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto LExit;
  }

  for (DWORD i = 0; i < asi.AceCount; i++)
  {
    ACCESS_ALLOWED_ACE * pAce = NULL;

    if ( !GetAce(pacl, i, (LPVOID*)&pAce) )
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      goto LExit;
    }

    DBG_ASSERT( pAce );

    if ( pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE )
    {
      continue;
    }

    if ( pAce->Mask != amDesiredAccess )
    {
      continue;
    }

    if ( EqualSid( psid, (PSID)&pAce->SidStart ) )
    {
      *pfFound = TRUE;
      hr = S_OK;
      goto LExit;
    }
  }
  
  hr = S_OK;
LExit:
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\tracelog.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.cxx

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>
#include <pudebug.h>
#include <tracelog.h>

#define ALLOC_MEM(cb) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)LocalFree( (HLOCAL)(ptr) )



PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )
/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    DBG_ASSERT( LogSize > 0 );
    DBG_ASSERT( EntrySize > 0 );
    DBG_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    DBG_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        RtlZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;
    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/
{
        if ( Log != NULL ) {
        DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

        Log->Signature = TRACE_LOG_SIGNATURE_X;
        FREE_MEM( Log );
    }

}   // DestroyTraceLog


LONG
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )
/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    Index of entry in log.  This is useful for correlating the output
    of !inetdbg.ref to a particular point in the output debug stream

--*/
{

    PUCHAR target;
    ULONG index;

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    DBG_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = ( (ULONG) InterlockedIncrement( &Log->NextEntry ) ) % (ULONG) Log->LogSize;

    DBG_ASSERT( index < (ULONG) Log->LogSize );

    target = Log->LogBuffer + ( index * Log->EntrySize );

    RtlCopyMemory(
        target,
        Entry,
        Log->EntrySize
        );

    return index;
}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )
{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    RtlZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\useracl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2000                **/
/**********************************************************************/

/*
    useracl.cxx

        Declarations for some functions to add permissions to windowstations/
        desktops
*/

#include "precomp.hxx"
#include <useracl.h>

#define WINSTA_DESIRED (WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_READSCREEN | WINSTA_ENUMERATE | STANDARD_RIGHTS_READ | WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS)

#define DESKTOP_DESIRED (DESKTOP_READOBJECTS | DESKTOP_ENUMERATE | STANDARD_RIGHTS_READ | DESKTOP_WRITEOBJECTS | DESKTOP_CREATEWINDOW)


BOOL AddTheAceWindowStation(
    HWINSTA hwinsta,
    PSID psid)
{

    ACL_SIZE_INFORMATION aclSizeInfo;
    BOOL                 bDaclExist;
    BOOL                 bDaclPresent;
    BOOL                 bSuccess  = FALSE; // assume function will
                                            //fail
    DWORD                dwNewAclSize;
    DWORD                dwSidSize = 0;
    DWORD                dwSdSizeNeeded;
    PACL                 pacl;
    PACL                 pNewAcl   = NULL;
    PSECURITY_DESCRIPTOR psd       = NULL;
    PSECURITY_DESCRIPTOR psdNew    = NULL;
    PVOID                pTempAce;
    SECURITY_INFORMATION si        = DACL_SECURITY_INFORMATION;
    unsigned int         i;

    __try
    {
        // 
        // obtain the dacl for the windowstation
        // 
        if (!GetUserObjectSecurity(
                    hwinsta,
                    &si,
                    psd,
                    dwSidSize,
                    &dwSdSizeNeeded
                    ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
                            GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSdSizeNeeded
                            );
                if (psd == NULL)
                {
                    __leave;
                }

                psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
                            GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSdSizeNeeded
                            );
                if (psdNew == NULL)
                {
                    __leave;
                }

                dwSidSize = dwSdSizeNeeded;

                if (!GetUserObjectSecurity(
                        hwinsta,
                        &si,
                        psd,
                        dwSidSize,
                        &dwSdSizeNeeded
                        ))
                {
                    __leave;
                }
            }
            else
            {
               __leave;
            }
        }
        else
        {
            SetLastError ( ERROR_CAN_NOT_COMPLETE );

            // This should not happen, because if it does this means
            // that we were able to get the User Object without any space.
            __leave;
        }

        // 
        // create a new dacl
        // 
        if (!InitializeSecurityDescriptor(
              psdNew,
              SECURITY_DESCRIPTOR_REVISION
              ))
        {
            __leave;
        }

        // 
        // get dacl from the security descriptor
        // 
        if (!GetSecurityDescriptorDacl(
                psd,
                &bDaclPresent,
                &pacl,
                &bDaclExist
                ))
        {
            __leave;
        }

        // 
        // initialize
        // 
        ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
        aclSizeInfo.AclBytesInUse = sizeof(ACL);

        // 
        // call only if the dacl is not NULL
        // 
        if (pacl != NULL)
        {
            // get the file ACL size info
            if (!GetAclInformation(
                    pacl,
                    (LPVOID)&aclSizeInfo,
                    sizeof(ACL_SIZE_INFORMATION),
                    AclSizeInformation
                    ))
            {
                __leave;
            }
        }

        // 
        // compute the size of the new acl
        // 
        dwNewAclSize = aclSizeInfo.AclBytesInUse +
            sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid) - sizeof(DWORD);

        //
        // allocate memory for the new acl
        // 
        pNewAcl = (PACL)HeapAlloc(
                    GetProcessHeap(),
                    HEAP_ZERO_MEMORY,
                    dwNewAclSize
                    );
        if (pNewAcl == NULL)
        {
            __leave;
        }

        // 
        // initialize the new dacl
        // 
        if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
        {
            __leave;
        }

        // 
        // if DACL is present, copy it to a new DACL
        // 
        if (bDaclPresent) // only copy if DACL was present
        {
            // copy the ACEs to our new ACL
            if (aclSizeInfo.AceCount)
            {
                for (i=0; i < aclSizeInfo.AceCount; i++)
                {
                    // get an ACE
                    if (!GetAce(pacl, i, &pTempAce))
                    {
                        __leave;
                    }

                    DBG_ASSERT(pTempAce != NULL);

                    // If it is the SID we are trying to add, no need to
                    // do anything more
                    if (((ACE_HEADER *)pTempAce)->AceType == ACCESS_ALLOWED_ACE_TYPE &&
                        EqualSid(&((ACCESS_ALLOWED_ACE *)pTempAce)->SidStart, psid))
                    {
                        bSuccess = TRUE;
                        __leave;
                    }

                    // add the ACE to the new ACL
                    if (!AddAce(
                            pNewAcl,
                            ACL_REVISION,
                            INFINITE,
                            pTempAce,
                            ((PACE_HEADER)pTempAce)->AceSize
                            ))
                    {
                        __leave;
                    }
                }
            }
        }

        // 
        // add ace to the dacl
        // 
        if (!AddAccessAllowedAce(
                pNewAcl,
                ACL_REVISION,
                WINSTA_DESIRED,
                psid
                ))
        {
            __leave;
        }

        // 
        // set new dacl for the security descriptor
        // 
        if (!SetSecurityDescriptorDacl(
                   psdNew,
                   TRUE,
                   pNewAcl,
                   FALSE
                   ))
        {
            __leave;
        }

        // 
        // set the new security descriptor for the windowstation
        // 
        if (!SetUserObjectSecurity(
                    hwinsta,
                    &si,
                    psdNew))
        {
            __leave;
        }

        // 
        // indicate success
        // 
        bSuccess = TRUE;
    }
    __finally
    {
        // 
        // free the allocated buffers
        // 
        if (pNewAcl != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)pNewAcl);
        }

        if (psd != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psd);
        }

        if (psdNew != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psdNew);
        }
    }

    return bSuccess;
}

BOOL AddTheAceDesktop(
    HDESK hdesk,
    PSID psid)
{

    ACL_SIZE_INFORMATION aclSizeInfo;
    BOOL                 bDaclExist;
    BOOL                 bDaclPresent;
    BOOL                 bSuccess  = FALSE; // assume function will
                                            // fail
    DWORD                dwNewAclSize;
    DWORD                dwSidSize = 0;
    DWORD                dwSdSizeNeeded;
    PACL                 pacl;
    PACL                 pNewAcl   = NULL;
    PSECURITY_DESCRIPTOR psd       = NULL;
    PSECURITY_DESCRIPTOR psdNew    = NULL;
    PVOID                pTempAce;
    SECURITY_INFORMATION si        = DACL_SECURITY_INFORMATION;
    unsigned int         i;

    __try
    {
        // 
        // obtain the security descriptor for the desktop object
        // 
        if (!GetUserObjectSecurity(
                hdesk,
                &si,
                psd,
                dwSidSize,
                &dwSdSizeNeeded
                ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
                            GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSdSizeNeeded
                            );
                if (psd == NULL)
                {
                    __leave;
                }

                psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
                                GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                dwSdSizeNeeded
                                );
                if (psdNew == NULL)
                {
                    __leave;
                }

                dwSidSize = dwSdSizeNeeded;

                if (!GetUserObjectSecurity(
                            hdesk,
                            &si,
                            psd,
                            dwSidSize,
                            &dwSdSizeNeeded
                            ))
                {
                    __leave;
                }
            }
            else
            {
                __leave;
            }
        }
        else
        {
            SetLastError ( ERROR_CAN_NOT_COMPLETE );

            // This should not happen, because if it does this means
            // that we were able to get the User Object without any space.
            __leave;
        }

        // 
        // create a new security descriptor
        // 
        if (!InitializeSecurityDescriptor(
                    psdNew,
                    SECURITY_DESCRIPTOR_REVISION
                    ))
        {
            __leave;
        }

        // 
        // obtain the dacl from the security descriptor
        // 
        if (!GetSecurityDescriptorDacl(
                    psd,
                    &bDaclPresent,
                    &pacl,
                    &bDaclExist
                    ))
        {
            __leave;
        }

        // 
        // initialize
        // 
        ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
        aclSizeInfo.AclBytesInUse = sizeof(ACL);

        // 
        // call only if NULL dacl
        // 
        if (pacl != NULL)
        {
            // 
            // determine the size of the ACL info
            // 
            if (!GetAclInformation(
                    pacl,
                    (LPVOID)&aclSizeInfo,
                    sizeof(ACL_SIZE_INFORMATION),
                    AclSizeInformation
                    ))
            {
                __leave;
            }
        }

        // 
        // compute the size of the new acl
        // 
        dwNewAclSize = aclSizeInfo.AclBytesInUse +
                        sizeof(ACCESS_ALLOWED_ACE) +
                        GetLengthSid(psid) - sizeof(DWORD);

        // 
        // allocate buffer for the new acl
        // 
        pNewAcl = (PACL)HeapAlloc(
                        GetProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        dwNewAclSize
                        );
        if (pNewAcl == NULL)
        {
            __leave;
        }

        // 
        // initialize the new acl
        // 
        if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
        {
            __leave;
        }

        // 
        // if DACL is present, copy it to a new DACL
        // 
        if (bDaclPresent) // only copy if DACL was present
        {
            // copy the ACEs to our new ACL
            if (aclSizeInfo.AceCount)
            {
                for (i=0; i < aclSizeInfo.AceCount; i++)
                {
                     // get an ACE
                    if (!GetAce(pacl, i, &pTempAce))
                    {
                        __leave;
                    }

                    DBG_ASSERT(pTempAce != NULL);

                    // If it is the SID we are trying to add, no need to
                    // do anything more
                    if (((ACE_HEADER *)pTempAce)->AceType == ACCESS_ALLOWED_ACE_TYPE &&
                        EqualSid(&((ACCESS_ALLOWED_ACE *)pTempAce)->SidStart, psid))
                    {
                        bSuccess = TRUE;
                        __leave;
                    }

                    // add the ACE to the new ACL
                    if (!AddAce(
                            pNewAcl,
                            ACL_REVISION,
                            INFINITE,
                            pTempAce,
                            ((PACE_HEADER)pTempAce)->AceSize
                            ))
                    {
                        __leave;
                    }
                }
            }
        }

        // 
        // add ace to the dacl
        // 
        if (!AddAccessAllowedAce(
                pNewAcl,
                ACL_REVISION,
                DESKTOP_DESIRED,
                psid
                ))
        {
            __leave;
        }

        // 
        // set new dacl to the new security descriptor
        // 
        if (!SetSecurityDescriptorDacl(
                    psdNew,
                    TRUE,
                    pNewAcl,
                    FALSE
                    ))
        {
            __leave;
        }

        // 
        // set the new security descriptor for the desktop object
        // 
        if (!SetUserObjectSecurity(hdesk, &si, psdNew))
        {
            __leave;
        }

        // 
        // indicate success
        // 
        bSuccess = TRUE;
    }
    __finally
    {
        // 
        // free buffers
        // 
        if (pNewAcl != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)pNewAcl);
        }

        if (psd != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psd);
        }

        if (psdNew != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psdNew);
        }
    }

    return bSuccess;
} 


HRESULT AlterDesktopForUserSid(PSID psid)
{
    HRESULT hr = S_OK;
    HWINSTA hwinsta = NULL;
    HDESK hdesk = NULL;

    hwinsta = GetProcessWindowStation();
    DBG_ASSERT(hwinsta != NULL);

    // 
    // add the user to the windowstation
    // 
    if (!AddTheAceWindowStation(hwinsta,
                                psid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the IIS_WPG Ace to the Window Station\n"
            ));

        goto Exit;
    }

    //
    // obtain a handle to the desktop
    //
    hdesk = GetThreadDesktop(GetCurrentThreadId());
    DBG_ASSERT(hdesk != NULL);

    // 
    // add user to the desktop
    // 
    if (!AddTheAceDesktop(hdesk,
                          psid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the IIS_WPG Ace to the Desktop\n"
            ));

        goto Exit;
    }

 Exit:
    //
    // close the handles to the windowstation and desktop
    //
    if (hwinsta != NULL)
    {
        CloseWindowStation(hwinsta);
    }

    if (hdesk != NULL)
    {
        CloseDesktop(hdesk);
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Adds the user to the Desktop so that the worker process can startup

Arguments:

    None

Return Value:

    HRESULT
--***************************************************************************/
HRESULT
AlterDesktopForUser(HANDLE hToken)
{
    HRESULT hr = S_OK;
    BUFFER buffSidAndAttributes;
    BUFFER buffWpgSid;
    DWORD cbSid;
    BUFFER buffDomainName;
    DWORD cchDomainName;
    SID_NAME_USE peUse;
    DWORD i;

    //
    // If there is no token, do nothing
    //
    if (hToken == NULL)
    {
        return S_OK;
    }

    //
    // Now figure out if this user is a member of the WPG group and if so,
    // do not add explicit ACL for it
    //

    //
    // obtain the logon sid of the IIS_WPG group
    //
    cbSid = buffWpgSid.QuerySize();
    cchDomainName = buffDomainName.QuerySize() / sizeof(WCHAR);
    while(!LookupAccountName(NULL,
                             L"IIS_WPG",
                             buffWpgSid.QueryPtr(),
                             &cbSid,
                             (LPWSTR)buffDomainName.QueryPtr(),
                             &cchDomainName,
                             &peUse))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not look up the IIS_WPG group sid.\n"
                ));

            return hr;
        }

        if (!buffWpgSid.Resize(cbSid) ||
            !buffDomainName.Resize(cchDomainName * sizeof(WCHAR)))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Failed to allocate appropriate space for the WPG sid\n"
                ));

            return hr;
        }
    }

    cbSid = buffSidAndAttributes.QuerySize();
    while (!GetTokenInformation(hToken,
                                TokenGroups,
                                buffSidAndAttributes.QueryPtr(),
                                cbSid,
                                &cbSid))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Failed to get the size of the groups for the token\n"
                ));

            return hr;
        }

        //
        // Now resize the buffer to be the right size
        //
        if (!buffSidAndAttributes.Resize(cbSid))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Failed to resize the buffer to the correct size\n"
                ));

            return hr;
        }
    }

    //
    // Now go looking in the group list to see if WPG group is present in there
    //
    for (i=0; i<((TOKEN_GROUPS *)(buffSidAndAttributes.QueryPtr()))->GroupCount; i++)
    {
        if (((TOKEN_GROUPS *)(buffSidAndAttributes.QueryPtr()))->Groups[i].Attributes & SE_GROUP_ENABLED &&
            EqualSid(((TOKEN_GROUPS *)(buffSidAndAttributes.QueryPtr()))->Groups[i].Sid,
                     (PSID)buffWpgSid.QueryPtr()))
        {
            return AlterDesktopForUserSid(buffWpgSid.QueryPtr());
        }
    }

    cbSid = buffSidAndAttributes.QuerySize();
    while (!GetTokenInformation(hToken,
                                TokenUser,
                                buffSidAndAttributes.QueryPtr(),
                                cbSid,
                                &cbSid))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to get the size of the sid for the token\n"
                ));

            return hr;
        }

        //
        // Now resize the buffer to be the right size
        //
        if (!buffSidAndAttributes.Resize(cbSid))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to resize the buffer to the correct size\n"
                ));

            return hr;
        }
    }

    return AlterDesktopForUserSid(((TOKEN_USER *)buffSidAndAttributes.QueryPtr())->User.Sid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\_locks.h ===
#define LOCKS_SLEEPTIME         100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\win32obj.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    win32obj.c

Abstract:

    This module contains helper functions for creating debug-specific
    named Win32 objects. Functions are included for named events,
    semaphores, and mutexes.

    Object names created by these routines have the following format:

        filename.ext:line_number member:address PID:pid

    Where:

        filename.ext = The file name where the object was created.

        line_number = The line number within the file.

        member = The member/global variable name where the handle is
            stored. This name is provided by the caller, but is usually
            of the form "g_Global" for globals and "CLASS::m_Member" for
            class members.

        address = An address, used to guarantee uniqueness of the objects
            created. This is provided by the caller. For global variables,
            this is typically the address of the global. For class members,
            this is typically the address of the containing class.

        pid = The current process ID. This ensures uniqueness across all
            processes.

    Here are a couple of examples:

        main.cxx:796 g_hShutdownEvent:683a42bc PID:373

        resource.cxx:136 RTL_RESOURCE::SharedSemaphore:00250970 PID:373

Author:

    Keith Moore (keithmo)        23-Sep-1997

Revision History:

--*/

# include "precomp.hxx"


#define MAX_OBJECT_NAME 256 // chars


LONG g_PuDbgEventsCreated = 0;
LONG g_PuDbgSemaphoresCreated = 0;
LONG g_PuDbgMutexesCreated = 0;



LPSTR
PuDbgpBuildObjectName(
    IN LPSTR ObjectNameBuffer,
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address
    )

/*++

Routine Description:

    Internal routine that builds an appropriate object name based on
    the file name, line number, member name, address, and process ID.

Arguments:

    ObjectNameBuffer - Pointer to the target buffer for the name.

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

Return Value:

    LPSTR - Pointer to ObjectNameBuffer if successful, NULL otherwise.

    N.B. This routine always returns NULL when running under Win9x.

--*/

{

    PLATFORM_TYPE platformType;
    LPSTR fileNamePart;
    LPSTR result;

    //
    // We have no convenient way to dump objects w/ names from
    // Win9x, so we'll only enable this functionality under NT.
    //

    // platformType = IISGetPlatformType();

    //
    // By default IIS-Duct-tape will only run on NT platforms. So
    // do not worry about getting the platform types yet.
    // 
    platformType = PtNtServer;
    result = NULL;

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {

        //
        // Find the filename part of the incoming source file name.
        //

        fileNamePart = strrchr( FileName, '\\' );

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, '/' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, ':' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = FileName;
        } else {
            fileNamePart++;
        }

        //
        // Ensure we don't overwrite our object name buffer.
        //

        if( ( sizeof(":1234567890 :12345678 PID:1234567890") +
              strlen( fileNamePart ) +
              strlen( MemberName ) ) < MAX_OBJECT_NAME ) {

            wsprintfA(
                ObjectNameBuffer,
                "%s:%lu %s:%08lx PID:%lu",
                fileNamePart,
                LineNumber,
                MemberName,
                Address,
                GetCurrentProcessId()
                );

            result = ObjectNameBuffer;

        }

    }

    return result;

}   // PuDbgpBuildObjectName


HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    )

/*++

Routine Description:

    Creates a new event object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    ManualReset - TRUE to create a manual reset event, FALSE to create
        an automatic reset event.

    InitialState - The intitial state of the event object.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateEventA(
                    NULL,                       // lpEventAttributes
                    ManualReset,                // bManualReset
                    InitialState,               // bInitialState
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgEventsCreated );
    }

    return objHandle;

}   // PuDbgCreateEvent


HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    Creates a new semaphore object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialCount - The initial count of the semaphore.

    MaximumCount - The maximum count of the semaphore.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateSemaphoreA(
                    NULL,                       // lpSemaphoreAttributes
                    InitialCount,               // lInitialCount
                    MaximumCount,               // lMaximumCount
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgSemaphoresCreated );
    }

    return objHandle;

}   // PuDbgCreateSemaphore


HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    )

/*++

Routine Description:

    Creates a new mutex object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialOwner - TRUE if the mutex should be created "owned".

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateMutexA(
                    NULL,                       // lpMutexAttributes
                    InitialOwner,               // bInitialOwner,
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgMutexesCreated );
    }

    return objHandle;

}   // PuDbgCreateMutex
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\uuencode.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    uuencode.cxx

Abstract:

    General uuencode and uudecode routine implementation.

Author:

    Ming Lu     (MingLu)      1-Feb-2000

Revision History:

--*/

/************************************************************
 * Include Headers
 ************************************************************/
#include "precomp.hxx"
#include "uuencode.hxx"

/************************************************************
 * Globals
 ************************************************************/

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

/*************************************************************
 *   Function implementations
 *************************************************************/

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\dbgutil\main.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     main.cxx

   Abstract:
     definition of the DEBUG variable

   Author:

       jaroslad         09/11/2002

   Project:

       IIS

--*/
#include "precomp.hxx"

DECLARE_DEBUG_VARIABLE();
DWORD  DEBUG_FLAGS_VAR = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\ulparse.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     ulparse.cxx

   Abstract:
     Rip some useful UL code
     
   Author:
     (RIPPED from UL driver code (HenrySa, PaulMcd)

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

//
// BUGBUG: Turn off optimization on ia64 builds due to a compiler bug
//
#if (defined(_M_IA64) && (_MSC_FULL_VER == 13009286))
#pragma optimize("",off)
#endif

#define LF                  0x0A
#define SP                  0x20
#define HT                  0x09

#define HTTP_CHAR           0x001
#define HTTP_UPCASE         0x002
#define HTTP_LOCASE         0x004
#define HTTP_ALPHA          (HTTP_UPCASE | HTTP_LOCASE)
#define HTTP_DIGIT          0x008
#define HTTP_CTL            0x010
#define HTTP_LWS            0x020
#define HTTP_HEX            0x040
#define HTTP_SEPERATOR      0x080
#define HTTP_TOKEN          0x100

#define URL_LEGAL           0x200
#define URL_TOKEN           (HTTP_ALPHA | HTTP_DIGIT | URL_LEGAL)

#define IS_HTTP_UPCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_LOCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_ALPHA(c)        (HttpChars[(UCHAR)(c)] & HTTP_ALPHA)
#define IS_HTTP_DIGIT(c)        (HttpChars[(UCHAR)(c)] & HTTP_DIGIT)
#define IS_HTTP_HEX(c)          (HttpChars[(UCHAR)(c)] & HTTP_HEX)
#define IS_HTTP_CTL(c)          (HttpChars[(UCHAR)(c)] & HTTP_CTL)
#define IS_HTTP_LWS(c)          (HttpChars[(UCHAR)(c)] & HTTP_LWS)
#define IS_HTTP_SEPERATOR(c)    (HttpChars[(UCHAR)(c)] & HTTP_SEPERATOR)
#define IS_HTTP_TOKEN(c)        (HttpChars[(UCHAR)(c)] & HTTP_TOKEN)
#define IS_URL_TOKEN(c)         (HttpChars[(UCHAR)(c)] & URL_TOKEN)

//
//  Constant Declarations for UTF8 Encoding
//

#define ASCII                 0x007f

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 =2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

#define EMIT_CHAR(ch)                                   \
    do {                                                \
        pDest[0] = (ch);                                \
        pDest += 1;                                     \
        BytesCopied += 2;                               \
    } while (0)

typedef enum _URL_TYPE
{
    UrlTypeUtf8,
    UrlTypeAnsi,
    UrlTypeDbcs
} URL_TYPE;

typedef enum _URL_PART
{
    Scheme,
    HostName,
    AbsPath,
    QueryString

} URL_PART;

#define IS_UTF8_TRAILBYTE(ch)      (((ch) & 0xc0) == 0x80)

//
// These are copied from RTL NLS routines.
//

#define DBCS_TABLE_SIZE 256
extern PUSHORT NlsLeadByteInfo;

#define LeadByteTable (*(PUSHORT *)NlsLeadByteInfo)
#define IS_LEAD_BYTE(c) (IsDBCSLeadByte(c))

ULONG   HttpChars[256];
USHORT  FastPopChars[256];
USHORT  DummyPopChars[256];
WCHAR   FastUpcaseChars[256];
BOOL    g_UlEnableNonUTF8;
BOOL    g_UlEnableDBCS;
BOOL    g_UlFavorDBCS;

NTSTATUS
Unescape(
    IN  PUCHAR pChar,
    OUT PUCHAR pOutChar
    )

{
    UCHAR Result, Digit;

    if (pChar[0] != '%' ||
        SAFEIsXDigit(pChar[1]) == FALSE ||
        SAFEIsXDigit(pChar[2]) == FALSE)
    {
        return STATUS_OBJECT_PATH_SYNTAX_BAD;
    }

    //
    // HexToChar() inlined
    //

    // uppercase #1
    //
    if (isalpha(pChar[1]))
        Digit = (UCHAR) toupper(pChar[1]);
    else
        Digit = pChar[1];

    Result = ((Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0')) << 4;

    // uppercase #2
    //
    if (isalpha(pChar[2]))
        Digit = (UCHAR) toupper(pChar[2]);
    else
        Digit = pChar[2];

    Result |= (Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0');

    *pOutChar = Result;

    return STATUS_SUCCESS;

}   // Unescape

//
// PopChar is used only if the string is not UTF-8, or UrlPart != QueryString,
// or the current character is '%' or its high bit is set.  In all other cases,
// the FastPopChars table is used for fast conversion.
//

__inline
NTSTATUS
FASTCALL
PopChar(
    IN URL_TYPE UrlType,
    IN URL_PART UrlPart,
    IN PUCHAR pChar,
    OUT WCHAR * pUnicodeChar,
    OUT PULONG pCharToSkip
    )
{
    NTSTATUS Status;
    WCHAR   UnicodeChar = L'\0';
    UCHAR   Char;
    UCHAR   Trail1;
    UCHAR   Trail2;
    ULONG   CharToSkip;

    //
    // validate it as a valid url character
    //

    if (UrlPart != QueryString)
    {
        if (IS_URL_TOKEN(pChar[0]) == FALSE)
        {
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }
    }
    else
    {
        //
        // Allow anything but linefeed in the query string.
        //

        if (pChar[0] == LF)
        {
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        UnicodeChar = (USHORT) pChar[0];
        CharToSkip = 1;

        // skip all the decoding stuff
        goto slash;
    }

    //
    // need to unescape ?
    //
    // can't decode the query string.  that would be lossy decodeing
    // as '=' and '&' characters might be encoded, but have meaning
    // to the usermode parser.
    //

    if (pChar[0] == '%')
    {
        Status = Unescape(pChar, &Char);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;
        CharToSkip = 3;
    }
    else
    {
        Char = pChar[0];
        CharToSkip = 1;
    }

    if (UrlType == UrlTypeUtf8)
    {
        //
        // convert to unicode, checking for utf8 .
        //
        // 3 byte runs are the largest we can have.  16 bits in UCS-2 =
        // 3 bytes of (4+4,2+6,2+6) where it's code + char.
        // for a total of 6+6+4 char bits = 16 bits.
        //

        //
        // NOTE: we'll only bother to decode utf if it was escaped
        // thus the (CharToSkip == 3)
        //
        if ((CharToSkip == 3) && ((Char & 0xf0) == 0xe0))
        {
            // 3 byte run
            //

            // Unescape the next 2 trail bytes
            //

            Status = Unescape(pChar+CharToSkip, &Trail1);
            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            CharToSkip += 3; // %xx

            Status = Unescape(pChar+CharToSkip, &Trail2);
            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            CharToSkip += 3; // %xx

            if (IS_UTF8_TRAILBYTE(Trail1) == FALSE ||
                IS_UTF8_TRAILBYTE(Trail2) == FALSE)
            {
                // bad utf!
                //
                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
                goto end;
            }

            // handle three byte case
            // 1110xxxx 10xxxxxx 10xxxxxx

            UnicodeChar = (USHORT) (((Char & 0x0f) << 12) |
                                    ((Trail1 & 0x3f) << 6) |
                                    (Trail2 & 0x3f));

        }
        else if ((CharToSkip == 3) && ((Char & 0xe0) == 0xc0))
        {
            // 2 byte run
            //

            // Unescape the next 1 trail byte
            //

            Status = Unescape(pChar+CharToSkip, &Trail1);
            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            CharToSkip += 3; // %xx

            if (IS_UTF8_TRAILBYTE(Trail1) == FALSE)
            {
                // bad utf!
                //
                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
                goto end;
            }

            // handle two byte case
            // 110xxxxx 10xxxxxx

            UnicodeChar = (USHORT) (((Char & 0x1f) << 6) |
                                    (Trail1 & 0x3f));

        }

        // now this can either be unescaped high-bit (bad)
        // or escaped high-bit.  (also bad)
        //
        // thus not checking CharToSkip
        //

        else if ((Char & 0x80) == 0x80)
        {
            // high bit set !  bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;

        }
        //
        // Normal character (again either escaped or unescaped)
        //
        else
        {
            //
            // Simple conversion to unicode, it's 7-bit ascii.
            //

            UnicodeChar = (USHORT)Char;
        }

    }
    else // UrlType != UrlTypeUtf8
    {
        UCHAR AnsiChar[2];
        ULONG AnsiCharSize;

        //
        // Convert ANSI character to Unicode.
        // If the UrlType is UrlTypeDbcs, then we may have
        // a DBCS lead/trail pair.
        //

        if (UrlType == UrlTypeDbcs && IS_LEAD_BYTE(Char))
        {
            UCHAR SecondByte;
        
            //
            // This is a double-byte character.
            //

            SecondByte = *(pChar+CharToSkip);

            AnsiCharSize = 2;
            AnsiChar[0] = Char;

            if (SecondByte == '%')
            {
                Status = Unescape(pChar+CharToSkip, &AnsiChar[1]);
                if (!NT_SUCCESS(Status))
                {
                    goto end;
                }

                CharToSkip += 3; // %xx
            }
            else
            {
                AnsiChar[1] = SecondByte;
                CharToSkip += 1;
            }

        }
        else
        {
            //
            // This is a single-byte character.
            //

            AnsiCharSize = 1;
            AnsiChar[0] = Char;

        }

        Status = RtlMultiByteToUnicodeN(
                        &UnicodeChar,
                        sizeof(WCHAR),
                        NULL,
                        (PCHAR) &AnsiChar[0],
                        AnsiCharSize
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }


slash:
    //
    // turn backslashes into forward slashes
    //

    if (UrlPart != QueryString && UnicodeChar == L'\\')
    {
        UnicodeChar = L'/';
    }
    else if (UnicodeChar == UNICODE_NULL)
    {
        //
        // we pop'd a NULL.  bad!
        //
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto end;
    }

    *pCharToSkip  = CharToSkip;
    *pUnicodeChar = UnicodeChar;

    Status = STATUS_SUCCESS;

end:
    return Status;

}   // PopChar


//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000

//
// Private globals
//

//
// this table says what to do based on the current state and the current
// character
//
ULONG  pActionTable[16] =
{
    //
    // state 0 = fresh, seen nothing exciting yet
    //
    ACTION_EMIT_CH,         // other = emit it                      state = 0
    ACTION_EMIT_CH,         // "."   = emit it                      state = 0
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_EMIT_CH,         // "/"   = we saw the "/", emit it      state = 1

    //
    // state 1 = we saw a "/" !
    //
    ACTION_EMIT_CH,         // other = emit it,                     state = 0
    ACTION_NOTHING,         // "."   = eat it,                      state = 2
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = extra slash, eat it,         state = 1

    //
    // state 2 = we saw a "/" and ate a "." !
    //
    ACTION_EMIT_DOT_CH,     // other = emit the dot we ate.         state = 0
    ACTION_NOTHING,         // "."   = eat it, a ..                 state = 3
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = we ate a "/./", swallow it   state = 1

    //
    // state 3 = we saw a "/" and ate a ".." !
    //
    ACTION_EMIT_DOT_DOT_CH, // other = emit the "..".               state = 0
    ACTION_EMIT_DOT_DOT_CH, // "."   = 3 dots, emit the ".."        state = 0
    ACTION_BACKUP,          // EOS   = we have a "/..\0", backup!   state = 4
    ACTION_BACKUP           // "/"   = we have a "/../", backup!    state = 1
};

//
// this table says which newstate to be in given the current state and the
// character we saw
//
ULONG  pNextStateTable[16] =
{
    // state 0
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    //  state 1
    0 ,              // other
    2 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 2
    0 ,             // other
    3 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 3
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1               // "\"
};

//
// this says how to index into pNextStateTable given our current state.
//
// since max states = 4, we calculate the index by multiplying with 4.
//
#define IndexFromState( st)   ( (st) * 4)


/***************************************************************************++

Routine Description:

    This function can be told to clean up UTF-8, ANSI, or DBCS URLs.

    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode
    computes the case insensitive hash

Arguments:


Return Value:

    NTSTATUS - Completion status.


--***************************************************************************/
NTSTATUS
UlpCleanAndCopyUrlByType(
    IN      URL_TYPE    UrlType,
    IN      URL_PART    UrlPart,
    IN OUT  PWSTR       pDestination,
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR *     ppQueryString OPTIONAL
    )
{
    NTSTATUS Status;
    PWSTR   pDest;
    PUCHAR  pChar;
    ULONG   CharToSkip;
    UCHAR   Char;
    ULONG   BytesCopied;
    PWSTR   pQueryString;
    ULONG   StateIndex;
    WCHAR   UnicodeChar;
    BOOLEAN MakeCanonical;
    PUSHORT pFastPopChar;

    pDest = pDestination;
    pQueryString = NULL;
    BytesCopied = 0;

    pChar = pSource;
    CharToSkip = 0;

    StateIndex = 0;

    MakeCanonical = (UrlPart == AbsPath) ? TRUE : FALSE;

    if (UrlType == UrlTypeUtf8 && UrlPart != QueryString)
    {
        pFastPopChar = FastPopChars;
    }
    else
    {
        pFastPopChar = DummyPopChars;
    }

    while (SourceLength > 0)
    {
        //
        // advance !  it's at the top of the loop to enable ANSI_NULL to
        // come through ONCE
        //

        pChar += CharToSkip;
        SourceLength -= CharToSkip;

        //
        // well?  have we hit the end?
        //

        if (SourceLength == 0)
        {
            UnicodeChar = UNICODE_NULL;
        }
        else
        {
            //
            // Nope.  Peek briefly to see if we hit the query string
            //

            if (UrlPart == AbsPath && pChar[0] == '?')
            {
                ASSERT(pQueryString == NULL);

                //
                // remember it's location
                //

                pQueryString = pDest;

                //
                // let it fall through ONCE to the canonical
                // in order to handle a trailing "/.." like
                // "http://foobar:80/foo/bar/..?v=1&v2"
                //

                UnicodeChar = L'?';
                CharToSkip = 1;

                //
                // now we are cleaning the query string
                //

                UrlPart = QueryString;

                //
                // cannot use fast path for PopChar anymore
                //

                pFastPopChar = DummyPopChars;
            }
            else
            {
                USHORT NextUnicodeChar = pFastPopChar[*pChar];

                //
                // Grab the next character. Try to be fast for the
                // normal character case. Otherwise call PopChar.
                //

                if (NextUnicodeChar == 0)
                {
                    Status = PopChar(
                                    UrlType,
                                    UrlPart,
                                    pChar,
                                    &UnicodeChar,
                                    &CharToSkip
                                    );

                    if (NT_SUCCESS(Status) == FALSE)
                        goto end;
                }
                else
                {
#if DBG
                    Status = PopChar(
                                    UrlType,
                                    UrlPart,
                                    pChar,
                                    &UnicodeChar,
                                    &CharToSkip
                                    );

                    ASSERT(NT_SUCCESS(Status));
                    ASSERT(UnicodeChar == NextUnicodeChar);
                    ASSERT(CharToSkip == 1);
#endif
                    UnicodeChar = NextUnicodeChar;
                    CharToSkip = 1;
                }
            }
        }

        if (MakeCanonical)
        {
            //
            // now use the state machine to make it canonical .
            //

            //
            // from the old value of StateIndex, figure out our new base StateIndex
            //
            StateIndex = IndexFromState(pNextStateTable[StateIndex]);

            //
            // did we just hit the query string?  this will only happen once
            // that we take this branch after hitting it, as we stop
            // processing after hitting it.
            //

            if (UrlPart == QueryString)
            {
                //
                // treat this just like we hit a NULL, EOS.
                //

                StateIndex += 2;
            }
            else
            {
                //
                // otherwise based the new state off of the char we
                // just popped.
                //

                switch (UnicodeChar)
                {
                case UNICODE_NULL:      StateIndex += 2;    break;
                case L'.':              StateIndex += 1;    break;
                case L'/':              StateIndex += 3;    break;
                default:                StateIndex += 0;    break;
                }
            }

        }
        else
        {
            StateIndex = (UnicodeChar == UNICODE_NULL) ? 2 : 0;
        }

        //
        //  Perform the action associated with the state.
        //

        switch (pActionTable[StateIndex])
        {
        case ACTION_EMIT_DOT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_CH:

            EMIT_CHAR(UnicodeChar);

            // fall through

        case ACTION_NOTHING:
            break;

        case ACTION_BACKUP:

            //
            // pDest currently points 1 past the last '/'.  backup over it and
            // find the preceding '/', set pDest to 1 past that one.
            //

            //
            // backup to the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            ASSERT(pDest[0] == L'/');

            //
            // are we at the start of the string?  that's bad, can't go back!
            //

            if (pDest == pDestination)
            {
                ASSERT(BytesCopied == 0);
                Status = STATUS_OBJECT_PATH_INVALID;
                goto end;
            }

            //
            // back up over the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            ASSERT(pDest > pDestination);

            //
            // now find the previous slash
            //

            while (pDest > pDestination && pDest[0] != L'/')
            {
                pDest       -= 1;
                BytesCopied -= 2;
            }

            //
            // we already have a slash, so don't have to store 1.
            //

            ASSERT(pDest[0] == L'/');

            //
            // simply skip it, as if we had emitted it just now
            //

            pDest       += 1;
            BytesCopied += 2;

            break;

        default:
            ASSERT(!"http!UlpCleanAndCopyUrl: Invalid action code in state table!");
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        //
        // Just hit the query string ?
        //

        if (MakeCanonical && UrlPart == QueryString)
        {
            //
            // Stop canonical processing
            //

            MakeCanonical = FALSE;

            //
            // Need to emit the '?', it wasn't emitted above
            //

            ASSERT(pActionTable[StateIndex] != ACTION_EMIT_CH);

            EMIT_CHAR(L'?');

        }

    }

    //
    // terminate the string, it hasn't been done in the loop
    //

    ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;
    *pBytesCopied = BytesCopied;

    if (ppQueryString != NULL)
    {
        *ppQueryString = pQueryString;
    }

    Status = STATUS_SUCCESS;


end:
    return Status;

}   // UlpCleanAndCopyUrlByType


/***************************************************************************++

Routine Description:


    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode

Arguments:

Return Value:

    HRESULT 


--***************************************************************************/
HRESULT
UlCleanAndCopyUrl(
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR       pDestination,
    OUT     PWSTR *     ppQueryString OPTIONAL
    )
{
    NTSTATUS Status;
    URL_TYPE AnsiUrlType = g_UlEnableDBCS ? UrlTypeDbcs : UrlTypeAnsi;

    if (!g_UlEnableNonUTF8)
    {
        //
        // Only accept UTF-8 URLs.
        //

        Status = UlpCleanAndCopyUrlByType(
                        UrlTypeUtf8,
                        AbsPath,
                        pDestination,
                        pSource,
                        SourceLength,
                        pBytesCopied,
                        ppQueryString
                        );

    }
    else if (!g_UlFavorDBCS)
    {
        //
        // The URL may be either UTF-8 or ANSI. First
        // try UTF-8, and if that fails go for ANSI.
        //

        Status = UlpCleanAndCopyUrlByType(
                        UrlTypeUtf8,
                        AbsPath,
                        pDestination,
                        pSource,
                        SourceLength,
                        pBytesCopied,
                        ppQueryString
                        );

        if (!NT_SUCCESS(Status))
        {
            Status = UlpCleanAndCopyUrlByType(
                            AnsiUrlType,
                            AbsPath,
                            pDestination,
                            pSource,
                            SourceLength,
                            pBytesCopied,
                            ppQueryString
                            );

        }

    }
    else
    {
        //
        // The URL may be either ANSI or UTF-8. First
        // try the ANSI interpretation, and if that fails
        // go for UTF-8.
        //
        Status = UlpCleanAndCopyUrlByType(
                        AnsiUrlType,
                        AbsPath,
                        pDestination,
                        pSource,
                        SourceLength,
                        pBytesCopied,
                        ppQueryString
                        );

        if (!NT_SUCCESS(Status))
        {
            Status = UlpCleanAndCopyUrlByType(
                            UrlTypeUtf8,
                            AbsPath,
                            pDestination,
                            pSource,
                            SourceLength,
                            pBytesCopied,
                            ppQueryString
                            );

        }
    }
    
    //
    // Convert NTSTATUS to HRESULT
    //
    
    if ( Status == STATUS_SUCCESS )            
    {
        return S_OK;
    }
    else
    {
        DWORD dwErr = RtlNtStatusToDosError( Status );
        return HRESULT_FROM_WIN32( dwErr );
    }
    
}

HRESULT
UlInitializeParsing(
    VOID
)
{
    ULONG           i;
    UCHAR           c;
    HKEY            hKey;
    DWORD           dwType;
    DWORD           dwData;
    DWORD           cbData;

    //
    // First read the HTTP registry settings on how to handle URLs
    //
    
    g_UlEnableNonUTF8 = TRUE;
    g_UlEnableDBCS = FALSE;
    g_UlFavorDBCS = FALSE;
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\http\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        if ( RegQueryValueEx( hKey,
                              L"EnableNonUTF8",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            g_UlEnableNonUTF8 = !!dwData;
        }
        
        if ( g_UlEnableNonUTF8 )
        {
            if ( RegQueryValueEx( hKey,
                                  L"EnableDBCS",
                                  NULL,
                                  &dwType,
                                  (LPBYTE) &dwData,
                                  &cbData ) == ERROR_SUCCESS &&
                 dwType == REG_DWORD )
            {
                g_UlEnableDBCS = !!dwData;
            }
        }
        else
        {
            g_UlEnableDBCS = FALSE;
        }
        
        if ( g_UlEnableDBCS )
        {
            if ( RegQueryValueEx( hKey,
                                  L"FavorDBCS",
                                  NULL,
                                  &dwType,
                                  (LPBYTE) &dwData,
                                  &cbData ) == ERROR_SUCCESS &&
                 dwType == REG_DWORD )
            {
                g_UlFavorDBCS = !!dwData;
            }
        }
        else
        {
            g_UlFavorDBCS = FALSE;
        }
        
        RegCloseKey( hKey );
    }
    

    // Initialize the HttpChars array appropriately.

    for (i = 0; i < 128; i++)
    {
        HttpChars[i] = HTTP_CHAR;
    }

    for (i = 'A'; i <= 'Z'; i++)
    {
        HttpChars[i] |= HTTP_UPCASE;
    }

    for (i = 'a'; i <= 'z'; i++)
    {
        HttpChars[i] |= HTTP_LOCASE;
    }

    for (i = '0'; i <= '9'; i++)
    {
        HttpChars[i] |= (HTTP_DIGIT | HTTP_HEX);
    }


    for (i = 0; i <= 31; i++)
    {
        HttpChars[i] |= HTTP_CTL;
    }

    HttpChars[127] |= HTTP_CTL;

    HttpChars[SP] |= HTTP_LWS;
    HttpChars[HT] |= HTTP_LWS;


    for (i = 'A'; i <= 'F'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    for (i = 'a'; i <= 'f'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    HttpChars['('] |= HTTP_SEPERATOR;
    HttpChars[')'] |= HTTP_SEPERATOR;
    HttpChars['<'] |= HTTP_SEPERATOR;
    HttpChars['>'] |= HTTP_SEPERATOR;
    HttpChars['@'] |= HTTP_SEPERATOR;
    HttpChars[','] |= HTTP_SEPERATOR;
    HttpChars[';'] |= HTTP_SEPERATOR;
    HttpChars[':'] |= HTTP_SEPERATOR;
    HttpChars['\\'] |= HTTP_SEPERATOR;
    HttpChars['"'] |= HTTP_SEPERATOR;
    HttpChars['/'] |= HTTP_SEPERATOR;
    HttpChars['['] |= HTTP_SEPERATOR;
    HttpChars[']'] |= HTTP_SEPERATOR;
    HttpChars['?'] |= HTTP_SEPERATOR;
    HttpChars['='] |= HTTP_SEPERATOR;
    HttpChars['{'] |= HTTP_SEPERATOR;
    HttpChars['}'] |= HTTP_SEPERATOR;
    HttpChars[SP] |= HTTP_SEPERATOR;
    HttpChars[HT] |= HTTP_SEPERATOR;


    //
    // URL "reserved" characters (rfc2396)
    //

    HttpChars[';'] |= URL_LEGAL;
    HttpChars['/'] |= URL_LEGAL;
    HttpChars['\\'] |= URL_LEGAL;
    HttpChars['?'] |= URL_LEGAL;
    HttpChars[':'] |= URL_LEGAL;
    HttpChars['@'] |= URL_LEGAL;
    HttpChars['&'] |= URL_LEGAL;
    HttpChars['='] |= URL_LEGAL;
    HttpChars['+'] |= URL_LEGAL;
    HttpChars['$'] |= URL_LEGAL;
    HttpChars[','] |= URL_LEGAL;


    //
    // URL escape character
    //

    HttpChars['%'] |= URL_LEGAL;

    //
    // URL "mark" characters (rfc2396)
    //

    HttpChars['-'] |= URL_LEGAL;
    HttpChars['_'] |= URL_LEGAL;
    HttpChars['.'] |= URL_LEGAL;
    HttpChars['!'] |= URL_LEGAL;
    HttpChars['~'] |= URL_LEGAL;
    HttpChars['*'] |= URL_LEGAL;
    HttpChars['\''] |= URL_LEGAL;
    HttpChars['('] |= URL_LEGAL;
    HttpChars[')'] |= URL_LEGAL;


    //
    // RFC2396 describes these characters as `unwise' "because gateways and
    // other transport agents are known to sometimes modify such characters,
    // or they are used as delimiters". However, for compatibility with
    // IIS 5.0 and DAV, we must allow these unwise characters in URLs.
    //

    HttpChars['{'] |= URL_LEGAL;
    HttpChars['}'] |= URL_LEGAL;
    HttpChars['|'] |= URL_LEGAL;
    HttpChars['^'] |= URL_LEGAL;
    HttpChars['['] |= URL_LEGAL;
    HttpChars[']'] |= URL_LEGAL;
    HttpChars['`'] |= URL_LEGAL;

    //
    // '#', '%', and '"' are not considered URL_LEGAL, according to the RFC.
    // However, IIS 5.0 allowed them, so we should too.
    //
    
    HttpChars['#'] |= URL_LEGAL;
    HttpChars['%'] |= URL_LEGAL;
    HttpChars['"'] |= URL_LEGAL;

    //
    // In DBCS locales we need to explicitly accept lead bytes which
    // we would normally reject.
    //

    if (0)      // BUGBUG
    {
        for (i = 0; i < DBCS_TABLE_SIZE; i++)
        {
            if (IS_LEAD_BYTE((BYTE)i))
            {
                HttpChars[i] |= URL_LEGAL;
            }
        }
    }

    //
    // These US-ASCII characters are "excluded"; i.e. not URL_LEGAL (see RFC):
    //      '<' | '>' | ' ' (0x20)
    // In addition, control characters (0x00-0x1F and 0x7F) and
    // non US-ASCII characters (0x80-0xFF) are not URL_LEGAL.
    //

    for (i = 0; i < 128; i++)
    {
        if (!IS_HTTP_SEPERATOR(i) && !IS_HTTP_CTL(i))
        {
            HttpChars[i] |= HTTP_TOKEN;
        }
    }


    //
    // Fast path for PopChar
    //

    RtlZeroMemory(FastPopChars, 256 * sizeof(USHORT));
    RtlZeroMemory(DummyPopChars, 256 * sizeof(USHORT));

    for (i = 0; i < 256; i++)
    {
        c = (UCHAR)i;

        if (IS_URL_TOKEN(c) && c != '%' && (c & 0x80) != 0x80)
        {
            FastPopChars[i] = (USHORT)c;
        }
    }

    //
    // Turn backslashes into forward slashes
    //

    FastPopChars['\\'] = L'/';


    //
    // Fast path for UpcaseUnicodeChar
    //

    for (i = 0; i < 256; i++)
    {
        FastUpcaseChars[i] = RtlUpcaseUnicodeChar((WCHAR)i);
    }


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\alloc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    Alloc.cpp

Abstract:
    Custom heap allocator

   Author:
       George V. Reilly      (GeorgeRe)     Oct-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/11/1999 - Initial

--*/

#include "precomp.hxx"
#include "alloc.h"
#include <irtldbg.h>


// Private heap for IIS

HANDLE g_hHeap = NULL;

BOOL
WINAPI
IisHeapInitialize()
{
    g_hHeap = ::HeapCreate(0, 0, 0);
    return (g_hHeap != NULL);
}

VOID
WINAPI
IisHeapTerminate()
{
    if (g_hHeap)
    {
        IRTLVERIFY(::HeapDestroy(g_hHeap));
        g_hHeap = NULL;
    }
}

// Private IIS heap
HANDLE
WINAPI 
IisHeap()
{
    IRTLASSERT(g_hHeap != NULL);
    return g_hHeap;
}

// Allocate dwBytes
LPVOID
WINAPI
IisMalloc(
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapAlloc( g_hHeap, 0, dwBytes );
}

// Allocate dwBytes. Memory is zeroed
LPVOID
WINAPI
IisCalloc(
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapAlloc( g_hHeap, HEAP_ZERO_MEMORY, dwBytes );
}

// Reallocate lpMem to dwBytes
LPVOID
WINAPI
IisReAlloc(
    IN LPVOID lpMem,
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapReAlloc( g_hHeap, 0, lpMem, dwBytes);
}

// Free lpMem
BOOL
WINAPI
IisFree(
    IN LPVOID lpMem)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapFree( g_hHeap, 0, lpMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\aucommon.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    aucommon.cxx

    Common routines for ANSI/UNICODE classes.


    FILE HISTORY:
    5/21/97      michth      created

*/
#include "precomp.hxx"
#include "aucommon.hxx"

int
ConvertMultiByteToUnicode(LPSTR pszSrcAnsiString,
                          BUFFER *pbufDstUnicodeString,
                          DWORD dwStringLen)
{
    DBG_ASSERT(pszSrcAnsiString != NULL);
    int iStrLen = -1;
    BOOL bTemp;

    bTemp = pbufDstUnicodeString->Resize((dwStringLen + 1) * sizeof(WCHAR));
    if (bTemp) {
        iStrLen = MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszSrcAnsiString,
                                      dwStringLen + 1,
                                      (LPWSTR)pbufDstUnicodeString->QueryPtr(),
                                      (int)pbufDstUnicodeString->QuerySize());
        if (iStrLen == 0) {
            DBG_ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
            iStrLen = -1;
        }
        else {
            //
            // Don't count '\0'
            //
            iStrLen--;
        }


    }
    return iStrLen;
}

int
ConvertUnicodeToMultiByte(LPWSTR pszSrcUnicodeString,
                          BUFFER *pbufDstAnsiString,
                          DWORD dwStringLen)
{
    DBG_ASSERT(pszSrcUnicodeString != NULL);
    BOOL bTemp;
    int iStrLen = 0;

    iStrLen = WideCharToMultiByte(CP_ACP,
                                  0,
                                  pszSrcUnicodeString,
                                  dwStringLen + 1,
                                  (LPSTR)pbufDstAnsiString->QueryPtr(),
                                  (int)pbufDstAnsiString->QuerySize(),
                                  NULL,
                                  NULL);
    if ((iStrLen == 0) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        iStrLen = WideCharToMultiByte(CP_ACP,
                                      0,
                                      pszSrcUnicodeString,
                                      dwStringLen + 1,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);
        if (iStrLen != 0) {
            bTemp = pbufDstAnsiString->Resize(iStrLen);
            if (!bTemp) {
                iStrLen = 0;
            }
            else {
                iStrLen = WideCharToMultiByte(CP_ACP,
                                              0,
                                              pszSrcUnicodeString,
                                              dwStringLen + 1,
                                              (LPSTR)pbufDstAnsiString->QueryPtr(),
                                              (int)pbufDstAnsiString->QuerySize(),
                                              NULL,
                                              NULL);
            }

        }
    }
    //
    // Don't count '\0'
    // and convert 0 to -1 for errors
    //
    iStrLen--;
    return iStrLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\alloc.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    Alloc.h

Abstract:
    Custom heap allocator

   Author:
       George V. Reilly      (GeorgeRe)     Oct-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/11/1999 - Initial

--*/

#ifndef __ALLOC_H__
#define __ALLOC_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif // !__IRTLMISC_H__

extern HANDLE g_hHeap;

BOOL
WINAPI
IisHeapInitialize();

VOID
WINAPI
IisHeapTerminate();


#endif // __ALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_AUX_COUNTERS_HXX_
# define _IIS_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    CacBufferAllocs = 0,
    CacBufferFrees,
    CacBufferReallocs,

    CacBufferCons,         // constructed buffer class items
    CacBufferDest,         // destructed buffer class items

    CacBufferLT32,         // less than 32 byte allocs
    CacBufferGE32,         // >= 32

    CacCopyLT16,           // less than 16 byte allocs
    CacCopyGE16,           // >= 16

    CacStringCons,
    CacStringDest,

    CacStringCopy,
    CacStringAppend,

    CacMultiszCopy,
    CacMultiszAppend,

    AacSBMaxCounters                // sentinel counter
} ENUM_IIS_AUX_COUNTER;


# define NUM_AUX_COUNTERS    (AacSBMaxCounters)

#ifdef IIS_AUX_COUNTERS

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  InterlockedIncrement( g_SBAuxCounters+(acCounter)) : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  InterlockedDecrement( g_SBAuxCounters+(acCounter)) : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? g_SBAuxCounters[acCounter] : 0)


extern LONG g_SBAuxCounters[];


# else // IIS_AUX_COUNTERS

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter  ( acCounter)       (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\dllmain.cpp ===
// DllMain

#include "precomp.hxx"

#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>
#include <locks.h>
#include <inetinfo.h>

#include "date.hxx"
#include "alloc.h"


/////////////////////////////////////////////////////////////////////////////
// Globals


// NOTE: It is very important to remember that anything that needs to be 
// initialized here also needs to be initialized in the main of iisrtl2!!!
extern CRITICAL_SECTION g_SchedulerCritSec;
extern "C" DWORD g_dwSequenceNumber;

DECLARE_DEBUG_VARIABLE();

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

// HKLM\System\CurrentControlSet\Services\InetInfo\IISRTL\DebugFlags
const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY TEXT("\\IISRTL");


#undef ALWAYS_CLEANUP

// some function declarations

extern "C" bool LKRHashTableInit();
extern "C" void LKRHashTableUninit();
BOOL  SchedulerInitialize( VOID );
VOID  SchedulerTerminate( VOID );
extern "C" {

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

};

/////////////////////////////////////////////////////////////////////////////
// Additional initialization needed.  The shutdown of the scheduler threads
// in DLLMain has caused us some considerable grief.

int              g_cRefs;
CRITICAL_SECTION g_csInit;

BOOL
WINAPI 
InitializeIISRTL()
{
    BOOL fReturn = TRUE;  // ok

    EnterCriticalSection(&g_csInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "InitializeIISRTL, %d %s\n",
                   g_cRefs, (g_cRefs == 0 ? "initializing" : "")));

    if (g_cRefs++ == 0)
    {
        if (SchedulerInitialize())
        {
            DBG_REQUIRE(ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval());
        
            IF_DEBUG(INIT_CLEAN)
                DBGPRINTF((DBG_CONTEXT, "Scheduler Initialized\n"));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "Initializing Scheduler Failed\n"));
            fReturn = FALSE;
        }
    }

    LeaveCriticalSection(&g_csInit);

    return fReturn;
}



/////////////////////////////////////////////////////////////////////////////
// Additional termination needed

void
WINAPI 
TerminateIISRTL()
{
    EnterCriticalSection(&g_csInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "TerminateIISRTL, %d %s\n",
                   g_cRefs, (g_cRefs == 1 ? "Uninitializing" : "")));

    if (--g_cRefs == 0)
    {
        DBG_REQUIRE(ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval());
    
        SchedulerTerminate();
    }

    LeaveCriticalSection(&g_csInit);
}



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
// Note: any changes here probably also need to go into ..\iisrtl2\main.cxx

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        Locks_Initialize();

        g_cRefs = 0;
        INITIALIZE_CRITICAL_SECTION(&g_csInit);

        IisHeapInitialize();

        InitializeStringFunctions();

        IRTL_DEBUG_INIT();

        CREATE_DEBUG_PRINT_OBJECT("iisrtl");

#ifndef _EXEXPRESS
        CREATE_DEBUG_PRINT_OBJECT("iisrtl");
#else
        CREATE_DEBUG_PRINT_OBJECT("kisrtl");
#endif
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

#ifdef _NO_TRACING_
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );
#endif

        IF_DEBUG(INIT_CLEAN)
            DBGPRINTF((DBG_CONTEXT, "IISRTL::DllMain::DLL_PROCESS_ATTACH\n"));

        //
        // Initialize the platform type
        //
        INITIALIZE_PLATFORM_TYPE();
        IRTLASSERT(IISIsValidPlatform());

        InitializeSecondsTimer();
        InitializeDateTime();

        DBG_REQUIRE(ALLOC_CACHE_HANDLER::Initialize());
        IF_DEBUG(INIT_CLEAN) {
            DBGPRINTF((DBG_CONTEXT, "Alloc Cache initialized\n"));
        }

        InitializeCriticalSection(&g_SchedulerCritSec);

        fReturn = LKRHashTableInit();

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifndef ALWAYS_CLEANUP
        if (lpvReserved == NULL)
#endif
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
                DBGPRINTF((DBG_CONTEXT,
                           "IISRTL::DllMain::DLL_PROCESS_DETACH\n"));

            if (g_cRefs != 0)
                DBGPRINTF((DBG_CONTEXT, "iisrtl!g_cRefs = %d\n", g_cRefs));
            LKRHashTableUninit();

            DeleteCriticalSection(&g_SchedulerCritSec);
            
            DBG_REQUIRE(ALLOC_CACHE_HANDLER::Cleanup());

            TerminateDateTime();
            TerminateSecondsTimer();
            
            DELETE_DEBUG_PRINT_OBJECT();

            IRTL_DEBUG_TERM();

            IisHeapTerminate();

            DeleteCriticalSection(&g_csInit);

            Locks_Cleanup();
        }
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\eventlog.cxx ===
/*++

   Copyright    (c)    1996-1997        Microsoft Corporation

   Module Name:
        eventlog.cxx

   Abstract:

        This module defines the generic class for logging events.


   Author:

        Murali R. Krishnan    (MuraliK)    28-Sept-1994

   Depends Upon:
        Internet Services Platform Library (isplat.lib)
        Internet Services Debugging Library (isdebug.lib)

--*/

#include "precomp.hxx"

//
//  Include Headers
//

#define IMPLEMENTATION_EXPORT

# include <dbgutil.h>
# include <eventlog.hxx>
# include <string.hxx>


#define EVENTLOG_KEY  \
            "SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"

#define EVENTLOG_VALUE_KEY      "EventMessageFile"


EVENT_LOG::EVENT_LOG(
    IN LPCTSTR lpszSource
    )
/*++

   Description
     Constructor function for given event log object.
     Initializes event logging services.

   Arguments:

      lpszSource:    Source string for the Event.

   Note:

     This is intended to be executed once only.
     This is not to be used for creating multiple event
      log handles for same given source name.
     But can be used for creating EVENT_LOG objects for
      different source names.

--*/
:
    m_ErrorCode         (NO_ERROR)
{

    (VOID)IISGetPlatformType();

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Initializing Event Log for %s[%p]\n",
                    lpszSource, this));
    }

    //
    //  Register as an event source.
    //

    m_hEventSource = RegisterEventSource( NULL, lpszSource);

    if ( m_hEventSource != NULL ) {

        //
        //  Success!
        //

        IF_DEBUG( ERROR) {
            DBGPRINTF( ( DBG_CONTEXT,
                         " Event Log for %s initialized (hEventSource=%p)\n",
                         lpszSource,
                         m_hEventSource));
        }
    } else {

        //
        // An Error in initializing the event log.
        //

        m_ErrorCode = GetLastError();
        DBGPRINTF( ( DBG_CONTEXT,
                     "Could not register event source (%s) ( Error %lu)\n",
                     lpszSource,
                     m_ErrorCode));
    }

    return;

} // EVENT_LOG::EVENT_LOG()



EVENT_LOG::~EVENT_LOG(
    VOID
    )
/*++

    Description:
        Destructor function for given EVENT_LOG object.
        Terminates event logging functions and closes
         event log handle

--*/
{

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "Terminating events logging[%p]\n",
                        this));
    }


    //
    // If there is a valid Events handle, deregister it
    //

    if ( m_hEventSource != NULL) {

        BOOL fSuccess;

        fSuccess = DeregisterEventSource( m_hEventSource);

        if ( !fSuccess) {

            //
            // An Error in DeRegistering
            //

            m_ErrorCode = GetLastError();

            IF_DEBUG( INIT_CLEAN) {

                DBGPRINTF( ( DBG_CONTEXT,
                             "Termination of EventLog[%p] failed."
                             " error %lu\n",
                             this,
                             m_ErrorCode));
            }
        }

        //
        //  Reset the handle's value. Just as a precaution
        //
        m_hEventSource = NULL;
    }


    IF_DEBUG( API_EXIT) {
        DBGPRINTF( ( DBG_CONTEXT, "Terminated events log[%p]\n",this));
    }

} /* EVENT_LOG::~EVENT_LOG() */



VOID
EVENT_LOG::LogEvent(
        IN DWORD  idMessage,
        IN WORD   nSubStrings,
        IN const CHAR * rgpszSubStrings[],
        IN DWORD  errCode)
/*++

     Description:
        Log an event to the event logger

     Arguments:

       idMessage           Identifies the event message

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       rgpszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{

    WORD wType;                // Type of Event to be logged

    //
    //  Find type of message for the event log
    //

    IF_DEBUG( API_ENTRY)  {

        DWORD i;

        DBGPRINTF( ( DBG_CONTEXT,
                    "reporting event %08lX, Error Code = %lu\n",
                    idMessage,
                    errCode ));

        for( i = 0 ; i < nSubStrings ; i++ ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "    substring[%lu] = %s\n",
                       i,
                       rgpszSubStrings[i] ));
        }
    }

    if ( NT_INFORMATION( idMessage)) {

        wType = EVENTLOG_INFORMATION_TYPE;

    } else {

        if ( NT_WARNING( idMessage)) {

            wType = EVENTLOG_WARNING_TYPE;

        } else {

            wType = EVENTLOG_ERROR_TYPE;

            DBG_ASSERT(NT_ERROR( idMessage));
        }
    }

    //
    //  Log the event
    //

    EVENT_LOG::LogEventPrivate( idMessage,
                              wType,
                              nSubStrings,
                              rgpszSubStrings,
                              errCode);


    return;

} /* EVENT_LOG::LogEvent() */


//
//  Private functions.
//

VOID
EVENT_LOG::LogEventPrivate(
    IN DWORD   idMessage,
    IN WORD    wEventType,
    IN WORD    nSubStrings,
    IN const CHAR  * apszSubStrings[],
    IN DWORD   errCode
    )
/*++

     Description:
        Log an event to the event logger.
        ( Private version, includes EventType)

     Arguments:

       idMessage           Identifies the event message

       wEventType          Specifies the severety of the event
                            (error, warning, or informational).

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       apszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{
    VOID  * pRawData  = NULL;
    DWORD   cbRawData = 0;
    BOOL    fReport;
    DWORD   dwErr;

    if ( m_hEventSource == NULL ) {

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Attempt to log with no event source\n"));
        }
        return;
    }

    ASSERT( (nSubStrings == 0) || (apszSubStrings != NULL));

    if( errCode != 0 ) {
        pRawData  = &errCode;
        cbRawData = sizeof(errCode);
    }

    m_ErrorCode  = NO_ERROR;
    dwErr = GetLastError();

    fReport = ReportEvent(
                       m_hEventSource,                   // hEventSource
                       wEventType,                       // fwEventType
                       0,                                // fwCategory
                       idMessage,                        // IDEvent
                       NULL,                             // pUserSid,
                       nSubStrings,                      // cStrings
                       cbRawData,                        // cbData
                       (LPCTSTR *) apszSubStrings,       // plpszStrings
                       pRawData );                       // lpvData

#ifdef DBG
    
        //
        // Output the event log to the debugger
        //
        
        CHAR buffer[MAX_PATH+1];
        PCHAR pBuffer = buffer;

        ::FormatMessageA(FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           m_hEventSource,
                           idMessage,
                           0,
                           (LPSTR)pBuffer,
                           (DWORD)sizeof(buffer),
                           (va_list*)apszSubStrings
                           );

        DBGPRINTF((DBG_CONTEXT,"Reporting EVENT_LOG Event - %s\n", buffer));

#endif                           

    if ( !fReport ) {

        IF_DEBUG( ERROR) {

            m_ErrorCode = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                        "Cannot report event for %p, error %lu\n",
                        this,
                        m_ErrorCode));
        }
    }
    else {
        SetLastError( dwErr );
    }

}  // EVENT_LOG::LogEventPrivate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\hashtab.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       hashtab.cxx

   Abstract:
       Implements the member functions for Hash table

   Author:

       Murali R. Krishnan    ( MuraliK )     02-Oct-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

# include <hashtab.hxx>



/*++
  Organization of Hash Table

  The hash table consists of a set of hash buckets controlled
  by the number of buckets specified during creation.

  Each bucket consists of a set of bucket chunks. Each bucket
  owns a separate critical section to protect the entries in
  the bucket itself.

  Each bucket chunk consists of an array of MAX_ELEMENTS_PER_BUCKET
   HashTableBucketElement Entries (HTBE_ENTRY).

  Each HTBE_ENTRY maintains a hash value and pointer to the Hash Element.

--*/

/************************************************************
 *    HASH_TABLE_BUCKET
 ************************************************************/

struct HTBE_ENTRY {
    DWORD        m_hashValue;
    HT_ELEMENT * m_phte;

    inline
    BOOL IsMatch( DWORD hashValue, LPCSTR pszKey, DWORD cchKey) const
    { return ((hashValue == m_hashValue) &&
              (NULL != m_phte) &&
              m_phte->IsMatch( pszKey, cchKey)
              );
    }

    inline
    BOOL IsMatch( IN HT_ELEMENT * phte) const
    { return ( phte == m_phte); }

    inline BOOL
    IsEmpty( VOID) const { return ( NULL == m_phte); }

    VOID Print( VOID) const
    { m_phte->Print(); }
};

typedef HTBE_ENTRY * PHTBE_ENTRY;

//
// Chunk size should be carefully (empirically) chosen.
// Small Chunk size => large number of chunks
// Large Chunk size => high cost of search on failures.
// For now we choose the chunk size to be 20 entries.
# define MAX_ELEMENTS_PER_BUCKET    ( 20 )

struct dllexp HTB_ELEMENT {

    HTBE_ENTRY   m_rgElements[MAX_ELEMENTS_PER_BUCKET];
    DWORD        m_nElements;
    LIST_ENTRY   m_ListEntry;

    HTB_ELEMENT(VOID)
        : m_nElements ( 0)
    {
        InitializeListHead( &m_ListEntry);
        ZeroMemory( m_rgElements, sizeof( m_rgElements));
    }

    ~HTB_ELEMENT(VOID)
    { Cleanup(); }

    VOID Cleanup( VOID);

    inline
    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);

    inline
    BOOL Insert( IN DWORD hashVal, IN HT_ELEMENT * phte);

    inline
    BOOL Delete( IN HT_ELEMENT * phte);

    VOID Print( IN DWORD level) const;

    HTBE_ENTRY * FirstElement(VOID) { return ( m_rgElements); }
    HTBE_ENTRY * LastElement(VOID)
    { return ( m_rgElements + MAX_ELEMENTS_PER_BUCKET); }
    VOID NextElement( HTBE_ENTRY * & phtbe)
    { phtbe++; }

    VOID IncrementElements(VOID) { m_nElements++; }
    VOID DecrementElements(VOID) { m_nElements--; }
    DWORD NumElements( VOID) const { return ( m_nElements); }
    BOOL IsSpaceAvailable(VOID) const
    { return ( NumElements() < MAX_ELEMENTS_PER_BUCKET); }

    DWORD FindNextElement( IN OUT LPDWORD pdwPos,
                           OUT HT_ELEMENT ** pphte);

};

typedef HTB_ELEMENT * PHTB_ELEMENT;

class dllexp HASH_TABLE_BUCKET {

public:
    HASH_TABLE_BUCKET(VOID);
    ~HASH_TABLE_BUCKET( VOID);

    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);
    BOOL Insert( IN DWORD       hashVal,
                 IN HT_ELEMENT * phte,
                 IN BOOL        fCheckForDuplicate);

    BOOL Delete( IN HT_ELEMENT * phte);
    VOID Print( IN DWORD level);

    DWORD NumEntries( VOID);

    DWORD  InitializeIterator( IN HT_ITERATOR * phti);

    DWORD  FindNextElement( IN HT_ITERATOR * phti,
                                   OUT HT_ELEMENT ** pphte);
    DWORD  CloseIterator( IN HT_ITERATOR * phti);

private:
    CRITICAL_SECTION   m_csLock;

    LIST_ENTRY         m_lHead;
    DWORD              m_nEntries;

    HTB_ELEMENT        m_htbeFirst; // the first bucket chunk

    VOID Lock(VOID) { EnterCriticalSection( &m_csLock); }
    VOID Unlock( VOID) { LeaveCriticalSection( &m_csLock); }
};




/************************************************************
 *    Member Functions of HTB_ELEMENT
 ************************************************************/

VOID
HTB_ELEMENT::Cleanup( VOID)
{

    if ( m_nElements > 0) {
        PHTBE_ENTRY phtbeEntry;

        // free up all the entries in this bucket.
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( !phtbeEntry->IsEmpty() ) {

                // release the object now.
                DecrementElements();

                // Assert that ref == 1
                DerefAndKillElement( phtbeEntry->m_phte);
                phtbeEntry->m_phte = NULL;
                phtbeEntry->m_hashValue = 0;
            }
        } // for
    }

    DBG_ASSERT( 0 == m_nElements);
    return;
} // HTB_ELEMENT::Cleanup()


inline
HT_ELEMENT *
HTB_ELEMENT::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte = NULL;

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up, return
            //  the corresponding hash table entry object
            //
            if ( phtbeEntry->IsMatch( hashValue, pszKey, cchKey)) {

                // we found the entry. return it.
                phte = phtbeEntry->m_phte;
                DBG_REQUIRE( phte->Reference() > 0);
                break;
            }
        } // for
    }

    return ( phte);
} // HTB_ELEMENT::Lookup()


inline BOOL
HTB_ELEMENT::Insert( IN DWORD hashVal,
                     IN HT_ELEMENT * phte
                     )
{
    if ( m_nElements < MAX_ELEMENTS_PER_BUCKET) {

        // there is some empty space.
        // Find one such a slot and add this new entry

        PHTBE_ENTRY phtbeEntry;

        for (phtbeEntry = FirstElement();
             phtbeEntry < LastElement();
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->IsEmpty() ) {

                DBG_ASSERT( NULL != phte);

                // Assume that the object phte already has non-zero ref count

                // we found a free entry. insert the new element here.
                phtbeEntry->m_hashValue = hashVal;
                phtbeEntry->m_phte = phte;
                IncrementElements();
                return ( TRUE);
            }
        } // for

        // we should not come here. If we do then there is trouble :(
        DBG_ASSERT( FALSE);
    }

    SetLastError( ERROR_INSUFFICIENT_BUFFER);
    return ( FALSE);
} // HTB_ELEMENT::Insert()


DWORD
HTB_ELEMENT::FindNextElement( IN OUT LPDWORD pdwPos, OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    DBG_ASSERT( NULL != pdwPos );
    DBG_ASSERT( NULL != pphte );

    // Find the first valid element to return back.

    //
    // Given that deletion might happen any time, we cannot rely on the
    //   comparison  *pdwPos < m_nElements
    //
    // Do scans with *pdwPos < MAX_ELEMENTS_PER_BUCKET
    //

    if ( *pdwPos < MAX_ELEMENTS_PER_BUCKET ) {

        PHTBE_ENTRY phtbeEntry;

        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = m_rgElements + *pdwPos;
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->m_phte != NULL ) {

                //
                // Store the element pointer and the offset
                // and return after referencing the element
                //
                *pphte = phtbeEntry->m_phte;
                (*pphte)->Reference();
                *pdwPos = ( 1 + DIFF(phtbeEntry - FirstElement()));
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    return ( dwErr);
} // HTB_ELEMENT::FindNextElement()


inline BOOL
HTB_ELEMENT::Delete( IN HT_ELEMENT * phte)
{
    DBG_ASSERT( NULL != phte);

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up,
            //  decrement ref count and kill the element.
            //
            if ( phtbeEntry->IsMatch( phte)) {

                // We found the entry.  Remove it from the table

                phtbeEntry->m_phte = NULL;
                DecrementElements();

                DerefAndKillElement( phte);

                return ( TRUE);
            }
        } // for
    }

    return ( FALSE);
} // HTB_ELEMENT::Delete()


VOID
HTB_ELEMENT::Print(IN DWORD level) const
{
    const HTBE_ENTRY * phtbeEntry;
    CHAR rgchBuffer[MAX_ELEMENTS_PER_BUCKET * 22 + 200];
    DWORD cch;
    DWORD i;

    cch = wsprintf( rgchBuffer,
                    "HTB_ELEMENT(%08x)  # Elements %4d; "
                    "Flink: %08x  Blink: %08x\n"
                    ,
                    this, m_nElements,
                    m_ListEntry.Flink, m_ListEntry.Blink);

    if ( level > 0) {

        // NYI: I need to walk down the entire array.
        // Not just the first few entries
        for( i = 0; i < m_nElements; i++) {

            phtbeEntry = &m_rgElements[i];
            cch += wsprintf( rgchBuffer + cch,
                             "  %08x %08x",
                         phtbeEntry->m_hashValue,
                             phtbeEntry->m_phte
                             );
            if ( i % 4 == 0) {
                rgchBuffer[cch++] = '\n';
                rgchBuffer[cch] = '\0';
            }
        } // for
    }

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));
    return;
} // HTB_ELEMENT::Print()



/************************************************************
 *    Member Functions of HASH_TABLE_BUCKET
 ************************************************************/

HASH_TABLE_BUCKET::HASH_TABLE_BUCKET(VOID)
    : m_nEntries ( 0),
      m_htbeFirst()
{
    InitializeListHead( &m_lHead);
    INITIALIZE_CRITICAL_SECTION( & m_csLock);
} // HASH_TABLE_BUCKET::HASH_TABLE_BUCKET()


HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET( VOID)
{
    PLIST_ENTRY pl;
    PHTB_ELEMENT phtbe;

    // Free up the elements in the list
    Lock();
    while ( !IsListEmpty( &m_lHead)) {
        pl = RemoveHeadList( &m_lHead);
        phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);
        delete phtbe;
    } // while

    m_htbeFirst.Cleanup();
    Unlock();

    DeleteCriticalSection( &m_csLock);
} // HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET()



HT_ELEMENT *
HASH_TABLE_BUCKET::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte;

    Lock();
    // 1. search in the first bucket
    phte = m_htbeFirst.Lookup( hashValue, pszKey, cchKey);

    if ( NULL == phte ) {

        // 2. search in the auxiliary buckets
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (phte == NULL) && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            phte = phtbe->Lookup( hashValue, pszKey, cchKey);
        } // for
    }

    Unlock();

    return (phte);
} // HASH_TABLE_BUCKET::Lookup()


BOOL
HASH_TABLE_BUCKET::Insert( IN DWORD hashValue,
                           IN HT_ELEMENT * phte,
                           IN BOOL fCheckForDuplicate)
{
    BOOL fReturn = FALSE;

    if ( fCheckForDuplicate) {

        Lock();

        // do a lookup and find out if this data exists.
        HT_ELEMENT * phteLookedup = Lookup( hashValue,
                                            phte->QueryKey(),
                                            phte->QueryKeyLen()
                                            );

        if ( NULL != phteLookedup) {
            // the element is already present - return failure

            DerefAndKillElement( phteLookedup);
        }

        Unlock();

        if ( NULL != phteLookedup) {
            SetLastError( ERROR_DUP_NAME);
            return ( FALSE);
        }
    }

    Lock();

    // 1. try inserting in the first bucket chunk, if possible
    if ( m_htbeFirst.IsSpaceAvailable()) {

        fReturn = m_htbeFirst.Insert( hashValue, phte);
    } else {

        // 2. Find the first chunk that has space and insert it there.
        PLIST_ENTRY pl;
        HTB_ELEMENT * phtbe;

        for ( pl = m_lHead.Flink; (pl != &m_lHead);
              pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);

            if ( phtbe->IsSpaceAvailable()) {
                fReturn = phtbe->Insert( hashValue, phte);
                break;
            }
        } // for

        if ( !fReturn ) {

            //
            // We ran out of space.
            // Allocate a new bucket and insert the new element.
            //

            phtbe = new HTB_ELEMENT();
            if ( NULL != phtbe) {

                // add the bucket to the list of buckets and
                // then add the element to the bucket
                InsertTailList( &m_lHead, &phtbe->m_ListEntry);
                fReturn = phtbe->Insert(hashValue, phte);
            } else {

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                                " HTB(%08x)::Insert: Unable to add a chunk\n",
                                this));
                }
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Insert()



BOOL
HASH_TABLE_BUCKET::Delete( IN HT_ELEMENT * phte)
{
    BOOL fReturn = FALSE;


    // We do not know which bucket this element belongs to.
    // So we should try all chunks to delete this element.

    Lock();

    // 1. try deleting the element from first bucket chunk, if possible
    fReturn = m_htbeFirst.Delete( phte);

    if (!fReturn) {

        // it was not on the first bucket chunk.

        // 2. Find the first chunk that might contain this element
        // and delete it.
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink;
              !fReturn && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            fReturn = phtbe->Delete( phte);
        } // for

        // the element should have been in the hash table,
        // otherwise the app is calling with wrong entry
        DBG_ASSERT( fReturn);
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Delete()


DWORD
HASH_TABLE_BUCKET::NumEntries( VOID)
{
    DWORD nEntries;

    Lock();

    nEntries = m_htbeFirst.NumElements();

    PLIST_ENTRY pl;

    for ( pl = m_lHead.Flink;
          (pl != &m_lHead);
          pl = pl->Flink) {

        HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                 m_ListEntry);
        nEntries += phtbe->NumElements();
    } // for

    Unlock();

    return (nEntries);

} // HASH_TABLE_BUCKET::NumEntries()


DWORD
HASH_TABLE_BUCKET::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    //
    // find the first chunk that has a valid element.
    // if we find one, leave the lock on for subsequent accesses.
    // CloseIterator will shut down the lock
    // If we do not find one, we should unlock and return
    //

    phti->nChunkId = NULL;
    phti->nPos = 0;

    Lock();
    if ( m_htbeFirst.NumElements() > 0) {
        phti->nChunkId = (PVOID ) &m_htbeFirst;
        dwErr = NO_ERROR;
    } else {

        // find the first chunk that has an element

        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (pl != &m_lHead); pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nChunkId = (PVOID ) phtbe;
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    // if we did not find any elements, then unlock and return
    // Otherwise leave the unlocking to the CloseIterator()
    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        // get out of this bucket completely.
        Unlock();
    }

    return ( dwErr);

} // HASH_TABLE_BUCKET::InitializeIterator()


DWORD
HASH_TABLE_BUCKET::FindNextElement( IN HT_ITERATOR * phti,
                                    OUT HT_ELEMENT ** pphte)
{
    //  this function should be called only when the bucket is locked.

    DWORD dwErr;
    HTB_ELEMENT * phtbe = (HTB_ELEMENT * )phti->nChunkId;

    //
    // phti contains the <chunk, pos> from which we should start scan for
    //   next element.
    //

    DBG_ASSERT( NULL != phtbe);
    dwErr = phtbe->FindNextElement( &phti->nPos, pphte);

    if ( ERROR_NO_MORE_ITEMS == dwErr ) {

        // scan the rest of the chunks for next element

        PLIST_ENTRY pl = ((phtbe == &m_htbeFirst) ? m_lHead.Flink :
                          phtbe->m_ListEntry.Flink);

        for ( ; (pl != &m_lHead); pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                       m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nPos = 0;
                dwErr = phtbe->FindNextElement( &phti->nPos, pphte);
                DBG_ASSERT( NO_ERROR == dwErr);
                phti->nChunkId = (PVOID ) phtbe;
                break;
            }
        } // for
    }

    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        phti->nChunkId = NULL;
    }

    return ( dwErr);
} // HASH_TABLE_BUCKET::FindNextElement()


DWORD
HASH_TABLE_BUCKET::CloseIterator( IN HT_ITERATOR * phti)
{
    // just unlock the current bucket.
    Unlock();

    return ( NO_ERROR);
} // HASH_TABLE_BUCKET::CloseIterator()


VOID
HASH_TABLE_BUCKET::Print( IN DWORD level)
{
    Lock();
    DBGPRINTF(( DBG_CONTEXT,
                "\n\nHASH_TABLE_BUCKET (%08x): Head.Flink=%08x; Head.Blink=%08x\n"
                " Bucket Chunk # 0:\n"
                ,
                this, m_lHead.Flink, m_lHead.Blink
                ));

    m_htbeFirst.Print( level);

    if ( level > 0) {
        PLIST_ENTRY pl;
        DWORD i;

        for ( pl = m_lHead.Flink, i = 1;
              (pl != &m_lHead);
              pl = pl->Flink, i++) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            DBGPRINTF(( DBG_CONTEXT, "\n Bucket Chunk # %d\n", i));
            phtbe->Print( level);
        } // for
    }

    Unlock();
    return;
} // HASH_TABLE_BUCKET::Print()




/************************************************************
 *    Member Functions of HASH_TABLE
 ************************************************************/

HASH_TABLE::HASH_TABLE( IN DWORD   nBuckets,
                        IN LPCSTR  pszIdentifier,
                        IN DWORD   dwHashTableFlags
                        )
    : m_nBuckets   ( nBuckets),
      m_dwFlags    ( dwHashTableFlags),
      m_nEntries   ( 0),
      m_nLookups   ( 0),
      m_nHits      ( 0),
      m_nInserts   ( 0),
      m_nFlushes   ( 0)
{
    if ( NULL != pszIdentifier) {

        lstrcpynA( m_rgchId, pszIdentifier, sizeof( m_rgchId));
    }

    m_prgBuckets = new HASH_TABLE_BUCKET[nBuckets];

} // HASH_TABLE::HASH_TABLE()



DWORD
HASH_TABLE::CalculateHash( IN LPCSTR pszKey, DWORD cchKey) const
{
    DWORD hash = 0;

    DBG_ASSERT( pszKey != NULL );

    if ( cchKey > 8) {
        //
        // hash the last 8 characters
        //
        pszKey = (pszKey + cchKey - 8);
    }

    while ( *pszKey != '\0') {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        DWORD ch = ((*pszKey++) & ~0x20);

        // NYI: this is a totally pipe-line unfriendly code. Improve this.
        hash <<= 2;
        hash ^= ch;
        hash += ch;
    } // while

    //
    // Multiply by length (to introduce some randomness.  Murali said so.
    //

    return( hash * cchKey);
} // CalculateHash()


VOID
HASH_TABLE::Cleanup(VOID)
{
    if ( NULL != m_prgBuckets ) {

        delete [] m_prgBuckets;
        m_prgBuckets = NULL;
    }

} // HASH_TABLE::Cleanup()



# define INCREMENT_LOOKUPS()  \
       { InterlockedIncrement( (LPLONG ) &m_nLookups); }

# define INCREMENT_HITS( phte)  \
       if ( NULL != phte) { InterlockedIncrement( (LPLONG ) &m_nHits); }

# define INCREMENT_INSERTS()  \
       { InterlockedIncrement( (LPLONG ) &m_nInserts); }

# define INCREMENT_FLUSHES()  \
       { InterlockedIncrement( (LPLONG ) &m_nFlushes); }

# define INCREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedIncrement( (LPLONG ) &m_nEntries); }

# define DECREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedDecrement( (LPLONG ) &m_nEntries); }

HT_ELEMENT *
HASH_TABLE::Lookup( IN LPCSTR pszKey, DWORD cchKey)
{
    // 1. Calculate the hash value for pszKey
    // 2. Find the bucket for the hash value
    // 3. Search for given item in the bucket
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( pszKey, cchKey);
    HT_ELEMENT * phte;

    INCREMENT_LOOKUPS();

    DBG_ASSERT( NULL != m_prgBuckets);
    phte = m_prgBuckets[hashVal % m_nBuckets].Lookup( hashVal, pszKey, cchKey);

    INCREMENT_HITS( phte);

    return ( phte);
} // HASH_TABLE::Lookup()


BOOL
HASH_TABLE::Insert( HT_ELEMENT * phte, IN BOOL fCheckBeforeInsert)
{
    // 1. Calculate the hash value for key of the HT_ELEMENT object
    // 2. Find the bucket for the hash value
    // 3. Check if this item is not already present and insert
    //     it into the hash table.
    //  (the check can be bypassed if fCheck is set to FALSE)
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( phte->QueryKey(),
                                   phte->QueryKeyLen() );
    BOOL  fRet;

    INCREMENT_INSERTS();

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Insert( hashVal,
                                                      phte,
                                                      fCheckBeforeInsert);

    IF_DEBUG( ERROR) {
        if ( !fRet) {
            DBGPRINTF(( DBG_CONTEXT,
                        " Unable to insert %08x into bucket %d."
                        "  Bucket has %d elements. Error = %d\n",
                        phte, hashVal % m_nBuckets,
                        m_prgBuckets[hashVal % m_nBuckets].NumEntries(),
                        GetLastError()
                        ));
        }
    }
    INCREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Insert()



BOOL
HASH_TABLE::Delete( HT_ELEMENT * phte)
{
    BOOL  fRet;
    DWORD hashVal = CalculateHash( phte->QueryKey(), phte->QueryKeyLen());

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Delete( phte);

    DECREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Delete()



VOID
HASH_TABLE::Print( IN DWORD level)
{
    DWORD i;

    DBGPRINTF(( DBG_CONTEXT,
                "HASH_TABLE(%08x) "
                "%s: nBuckets = %d; dwFlags = %d;"
                " nEntries = %d; nLookups = %d; nHits = %d;"
                " nInserts = %d; nFlushes = %d;"
                " m_prgBuckets = %d\n",
                this, m_rgchId, m_nBuckets, m_dwFlags,
                m_nEntries, m_nLookups, m_nHits, m_nInserts,
                m_nFlushes, m_prgBuckets));

    if ( level == 0 ) {

        CHAR rgchBuff[2000];
        DWORD cch;

        cch = wsprintfA( rgchBuff, "\tBucket  NumEntries\n");
        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            cch += wsprintf( rgchBuff + cch, "\t[%4d]  %4d,\n",
                             i, m_prgBuckets[i].NumEntries());
        } // for

        DBGDUMP(( DBG_CONTEXT, rgchBuff));
    } else {

        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            m_prgBuckets[i].Print( level);
        } // for
    }

    return;
} // HASH_TABLE::Print()



DWORD
HASH_TABLE::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    // initialize the iterator
    phti->nBucketNumber = INFINITE;
    phti->nChunkId = NULL;
    phti->nPos = 0;

    if ( m_nEntries > 0) {
        // set the iterator to point to the first bucket with some elements.
        for ( DWORD i = 0; (i < m_nBuckets); i++) {

            dwErr = m_prgBuckets[i].InitializeIterator( phti);
            if ( dwErr == NO_ERROR) {
                phti->nBucketNumber = i;
                break;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::InitializeIterator()


DWORD
HASH_TABLE::FindNextElement( IN HT_ITERATOR * phti,
                             OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);
    DBG_ASSERT( NULL != pphte);

    if ( INFINITE != phti->nBucketNumber) {

        // iterator has some valid state use it.
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);

        dwErr =
            m_prgBuckets[ phti->nBucketNumber].FindNextElement( phti, pphte);

        if ( ERROR_NO_MORE_ITEMS == dwErr) {

            DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                            CloseIterator( phti)
                         == NO_ERROR
                        );

            // hunt for the next bucket with an element.
            for ( DWORD i = (phti->nBucketNumber + 1); (i < m_nBuckets); i++) {

                dwErr = m_prgBuckets[i].InitializeIterator( phti);

                if ( dwErr == NO_ERROR) {
                    phti->nBucketNumber = i;
                    dwErr = m_prgBuckets[ i].FindNextElement( phti, pphte);
                    DBG_ASSERT( dwErr == NO_ERROR);
                    break;
                }
            } // for

            if ( ERROR_NO_MORE_ITEMS == dwErr) {
                // reset the bucket number
                phti->nBucketNumber = INFINITE;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::FindNextElement()


DWORD
HASH_TABLE::CloseIterator( IN HT_ITERATOR * phti)
{
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    if ( INFINITE != phti->nBucketNumber) {
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);
        DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                     CloseIterator( phti)
                     == NO_ERROR
                     );
        phti->nBucketNumber = INFINITE;
    }

    return ( NO_ERROR);
} // HASH_TABLE::CloseIterator()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\ipsupp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      ipsupp.cxx

   Abstract:
      This module defines functions that are generic for Internet servers

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Nov-1995

--*/

#include "precomp.hxx"

#include <inetsvcs.h>
#include <winsock2.h>

#define LOCAL127            0x0100007F  // 127.0.0.1


BOOL
IsIPAddressLocal(
    IN DWORD LocalIP,
    IN DWORD RemoteIP
    )
{
    INT err;
    CHAR nameBuf[MAX_PATH+1];
    PHOSTENT    hostent;
    PIN_ADDR    p;
    CHAR        **list;

    //
    // if local and remote are the same, then this is local
    //

    if ( (LocalIP == RemoteIP)  ||
         (RemoteIP == LOCAL127) ||
         (LocalIP == LOCAL127) ) {

        return(TRUE);
    }

    err = gethostname( nameBuf, sizeof(nameBuf));

    if ( err != 0 ) {
        IIS_PRINTF((buff,"IsIPAddressLocal: Err %d in gethostname\n",
            WSAGetLastError()));
        return(FALSE);
    }

    hostent = gethostbyname( nameBuf );
    if ( hostent == NULL ) {
        IIS_PRINTF((buff,"IsIPAddressLocal: Err %d in gethostbyname\n",
            WSAGetLastError()));
        return(FALSE);
    }

    list = hostent->h_addr_list;

    while ( (p = (PIN_ADDR)*list++) != NULL ) {

        if ( p->s_addr == RemoteIP ) {
            return(TRUE);
        }
    }

    IIS_PRINTF((buff,"Not Local[%x %x]\n", LocalIP, RemoteIP));
    return(FALSE);

} // IsIPAddressLocal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\multisz.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    multisz.cxx

    This module contains a light weight multi-string class


    FILE HISTORY:
        KeithMo     20-Jan-1997 Created from string.cxx

*/

#include "precomp.hxx"


# include <dbgutil.h>
# include <multisz.hxx>
# include <auxctrs.h>

# include <tchar.h>

//
//  Private Definitions
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128


DWORD
MULTISZ::CalcLength( const CHAR * str,
                     LPDWORD pcStrings )
{
    DWORD count = 0;
    DWORD total = 1;
    DWORD len;

    while( *str ) {
        len = ::strlen( str ) + 1;
        total += len;
        str += len;
        count++;
    }

    if( pcStrings != NULL ) {
        *pcStrings = count;
    }

    return total;

}   // MULTISZ::CalcLength


BOOL
MULTISZ::FindString( const CHAR * str )
{

    CHAR * multisz;

    //
    // Sanity check.
    //

    DBG_ASSERT( QueryStr() != NULL );
    DBG_ASSERT( str != NULL );
    DBG_ASSERT( *str != '\0' );

    //
    // Scan it.
    //

    multisz = QueryStr();

    while( *multisz != '\0' ) {

        if( !::strcmp( multisz, str ) ) {

            return TRUE;

        }

        multisz += ::strlen( multisz ) + 1;

    }

    return FALSE;

}   // MULTISZ::FindString


VOID
MULTISZ::AuxInit( const BYTE * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        DWORD cStrings;
        int cbCopy = CalcLength( (const CHAR *)pInit, &cStrings ) * sizeof(CHAR);
        fRet = Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = (cbCopy)/sizeof(CHAR);
            m_cStrings = cStrings;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        Reset();

    }

} // MULTISZ::AuxInit()


/*******************************************************************

    NAME:       MULTISZ::AuxAppend

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZ::AuxAppend( const BYTE * pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 2 );

    if( cbThis == 2 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis--;

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    AcIncrement( CacMultiszAppend);
    if ( QuerySize() < cbThis + cbStr + 1)
    {
        if ( !Resize( cbThis + cbStr + 1 + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);

    *((BYTE *)QueryPtr() + cbThis + cbStr) = '\0';

    m_cchLen = CalcLength( (const CHAR *)QueryPtr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppend()


#if 0

BOOL
MULTISZ::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the UNICODE version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         11-30-94
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

      //
      //  Inquiring the size of buffer alone
      //
      *lpcch = QueryCCH() + 1;    // add one character for terminating null
    } else {

        //
        // Copy after conversion from ANSI to Unicode
        //
        int  iRet;
        iRet = MultiByteToWideChar( CP_ACP,   MB_PRECOMPOSED,
                                    QueryStrA(),  QueryCCH() + 1,
                                    lpszBuffer, (int )*lpcch);

        if ( iRet == 0 || iRet != (int ) *lpcch) {

            //
            // Error in conversion.
            //
            fReturn = FALSE;
        }
    }

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
#endif

BOOL
MULTISZ::CopyToBuffer( CHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the CHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to CHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    register DWORD cch = QueryCCH() + 1;

    if ( *lpcch >= cch) {

        DBG_ASSERT( lpszBuffer);
        CopyMemory( lpszBuffer, QueryStrA(), cch);
    } else {
        DBG_ASSERT( *lpcch < cch);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\mlszau.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class


    FILE HISTORY:
    4/8/97      michth      created

*/


//
// Normal includes only for this module to be active
//

#include "precomp.hxx"
#include "aucommon.hxx"


/*******************************************************************

    NAME:       MLSZAU::STR

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

********************************************************************/

// Inlined in stringau.hxx


VOID
MLSZAU::AuxInit( const LPSTR pInit,
                 DWORD cbLen )
{
    BOOL fRet;

    if ( pInit )
    {
        INT cbCopy;

        if (cbLen != 0) {
            DBG_ASSERT(cbLen >= 2);
            DBG_ASSERT(pInit[cbLen -1] == '\0');
            DBG_ASSERT(pInit[cbLen -2] == '\0');
            cbCopy = cbLen;
        }
        else {
            LPSTR pszIndex;
            for (pszIndex = pInit;
                 *pszIndex != '\0' || *(pszIndex + 1) != '\0';
                 pszIndex++) {
            }
            cbCopy = ((DWORD)(pszIndex - pInit)) + 2;
        }

        fRet = m_bufAnsi.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufAnsi.QueryPtr(), pInit, cbCopy );
            m_cbMultiByteLen = (cbCopy)/sizeof(CHAR);
            m_bUnicode = FALSE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // MLSZAU::AuxInit()


VOID
MLSZAU::AuxInit( const LPWSTR pInit,
                DWORD cchLen )
{
    BOOL fRet;

    if ( pInit )
    {
        INT cbCopy;

        if (cchLen != 0) {
            DBG_ASSERT(cchLen >= 2);
            DBG_ASSERT(pInit[cchLen -1] == (WCHAR)'\0');
            DBG_ASSERT(pInit[cchLen -2] == (WCHAR)'\0');
            cbCopy = cchLen * sizeof(WCHAR);
        }
        else {
            LPWSTR pszIndex;
            for (pszIndex = pInit;
                 *pszIndex != '\0' || *(pszIndex + 1) != '\0';
                 pszIndex++) {
            }
            cbCopy = ((DIFF(pszIndex - pInit)) + 2) * sizeof(WCHAR);
        }

        fRet = m_bufUnicode.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufUnicode.QueryPtr(), pInit, cbCopy );
            m_cchUnicodeLen = (cbCopy)/sizeof(WCHAR);
            m_bUnicode = TRUE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // MLSZAU::AuxInit()



LPTSTR
MLSZAU::QueryStr(BOOL bUnicode)
{

    //
    // This routine can fail.
    // On failure, return a valid UNICODE or ANSI string
    // so clients don't trap.
    //
    LPTSTR pszReturn = NULL;
    int iNewStrLen;

    if (m_bIsValid) {
        if ((bUnicode != m_bUnicode) &&
            (!m_bInSync) &&
            ((m_bUnicode && (m_cchUnicodeLen != 0)) ||
              (!m_bUnicode && (m_cbMultiByteLen != 0)))) {
            //
            // Need to Convert First
            //
            if (bUnicode) {
                //
                // Convert current string to UNICODE
                //
                // Conversion routines assume a real string and
                // add 1 to length for trailing \0 so subtract
                // one from total length.
                //
                iNewStrLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen - 1);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cchUnicodeLen = iNewStrLen+1;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                //
                // Convert current string to Ansi
                //
                iNewStrLen = ConvertUnicodeToMultiByte((LPWSTR)m_bufUnicode.QueryPtr(), &m_bufAnsi, m_cchUnicodeLen - 1);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cbMultiByteLen = iNewStrLen+1;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
        }

        if (m_bIsValid) {
            if (bUnicode) {
                pszReturn = (LPTSTR)m_bufUnicode.QueryPtr();
            }
            else {
                pszReturn = (LPTSTR)m_bufAnsi.QueryPtr();
            }

        }
    }

    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\isutils.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      isutils.cxx

   Abstract:
      This module defines functions that are generic for Internet servers

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Nov-1995

   Environment:
      Win32 - User Mode

   Project:

       Internet Servers Common DLL

   Functions Exported:

       IsLargeIntegerToChar();

   Revision History:

--*/

#include "precomp.hxx"

#include <inetsvcs.h>
#include <mbstring.h>


DWORD
IsLargeIntegerToDecimalChar(
    IN  const LARGE_INTEGER * pliValue,
    OUT LPSTR                pchBuffer
    )
/*++

Routine Description:

    Maps a Large Integer to be a displayable string.

Arguments:

    pliValue -  The LARGE INTEGER to be mapped.
    pchBuffer - pointer to character buffer to store the result
      (This buffer should be at least about 32 bytes long to hold
       entire large integer value as well as null character)

Return Value:

    Win32 Error code. NO_ERROR on success

--*/
{

    PSTR p1;
    PSTR p2;
    BOOL negative;
    LONGLONG Value;

    if ( pchBuffer == NULL || pliValue == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }


    //
    // Handling zero specially makes everything else a bit easier.
    //

    if( pliValue->QuadPart == 0 ) {

        // store the value 0 and return.
        pchBuffer[0] = '0';
        pchBuffer[1] = '\0';

        return (NO_ERROR);
    }

    Value = pliValue->QuadPart;  // cache the value.

    //
    // Remember if the value is negative.
    //

    if( Value < 0 ) {

        negative = TRUE;
        Value = -Value;

    } else {

        negative = FALSE;
    }

    //
    // Pull the least signifigant digits off the value and store them
    // into the buffer. Note that this will store the digits in the
    // reverse order.
    //  p1 is used for storing the digits as they are computed
    //  p2 is used during the reversing stage.
    //

    p1 = p2 = pchBuffer;

    for ( p1 = pchBuffer; Value != 0; ) {

        int digit = (int)( Value % 10 );
        Value = Value / 10;

        *p1++ = '0' + digit;
    } // for

    //
    // Tack on a '-' if necessary.
    //

    if( negative ) {

        *p1++ = '-';

    }

    // terminate the string
    *p1-- = '\0';


    //
    // Reverse the digits in the buffer.
    //

    for( p2 = pchBuffer; ( p1 > p2 ); p1--, p2++)  {

        CHAR ch = *p1;
        *p1 = *p2;
        *p2 = ch;
    } // for

    return ( NO_ERROR);

} // IsLargeIntegerToDecimalChar()



BOOL
ZapRegistryKey(
    IN HKEY   hKey,
    IN LPCSTR pszRegPath
    )
/*++

    Description:

        Zaps the reg key starting from pszRegPath down

    Arguments:

        hkey        - handle for parent
        pszRegPath - Key to zap

    Returns:
        FALSE if there is any error.
        TRUE when the reg key was successfully zapped.

--*/
{
    DWORD   err = NO_ERROR;
    DWORD   i = 0;
    HKEY    hKeyParam;

    if ( hKey == NULL ) {
        hKey = HKEY_LOCAL_MACHINE;
    }

    //
    // Loop through instance keys
    //

    err = RegOpenKeyEx( hKey,
                        pszRegPath,
                        0,
                        KEY_ALL_ACCESS,
                        &hKeyParam );

    if( err != NO_ERROR ) {
        return(TRUE);
    }

    while ( TRUE ) {

        CHAR  szKeyName[MAX_PATH+1];
        DWORD cbKeyName   = sizeof( szKeyName );
        FILETIME ft;
        BOOL fRet;
        DWORD dwInstance;
        CHAR szRegKey[MAX_PATH+1];

        err = RegEnumKeyEx( hKeyParam,
                            i,
                            szKeyName,
                            &cbKeyName,
                            NULL,
                            NULL,
                            NULL,
                            &ft );

        if ( err == ERROR_NO_MORE_ITEMS ) {
            err = NO_ERROR;
            break;
        }

        //
        // Zap this key
        //

        ZapRegistryKey(hKeyParam, szKeyName);
    }

    RegCloseKey(hKeyParam);

    err = RegDeleteKey(
                hKey,
                pszRegPath
                );

    if ( err != NO_ERROR ) {
        return(FALSE);
    }
    return(TRUE);

} // ZapRegistryKey


HKEY
CreateKey(
    IN HKEY   RootKey,
    IN LPCSTR KeyName,
    IN LPCSTR KeyValue
    )
{
    HKEY hKey = NULL;
    DWORD dwDisp;

    if ( RegCreateKeyExA(RootKey,
                    KeyName,
                    NULL,
                    "",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp) != ERROR_SUCCESS ) {

        goto exit;
    }

    if ( KeyValue != NULL ) {
        if (RegSetValueExA(hKey,
                    "",
                    NULL,
                    REG_SZ,
                    (LPBYTE)KeyValue,
                    lstrlen(KeyValue)+1)!=ERROR_SUCCESS) {

            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

exit:
    return hKey;

} // CreateKey


BOOL
IISCreateDirectory(
    IN LPCSTR   DirectoryName,
    IN BOOL     fAllowNetDrive
    )
{

    PCHAR p;
    DWORD len;

    len = strlen(DirectoryName);

    if ( (len < 3) ||
         (DirectoryName[1] != ':') ||
         (DirectoryName[2] != '\\') ) {

        SetLastError(ERROR_INVALID_NAME);
        return(FALSE);
    }

    if ( !fAllowNetDrive ) {

        UINT    driveType;
        CHAR    path[4];

        CopyMemory(path, DirectoryName, 3);
        path[3] = '\0';

        driveType = GetDriveType(path);
        if ( driveType == DRIVE_REMOTE ) {
            DBGPRINTF((DBG_CONTEXT,
                "%s is a remote directory. Not allowed\n", path));

            SetLastError(ERROR_INVALID_NAME);
            return(FALSE);
        }
    }

    p = (PCHAR)DirectoryName+3;

    do {

        p = (PCHAR)_mbschr((PUCHAR)p,'\\');
        if ( p != NULL ) {
            *p = '\0';
        }

        if ( !CreateDirectoryA(DirectoryName,NULL) ) {

            DWORD err = GetLastError();
            if ( err != ERROR_ALREADY_EXISTS ) {
                DBGPRINTF((DBG_CONTEXT,
                    "Error %d in CreateDirectory [%s]\n",
                    err, DirectoryName));

                if ( p != NULL ) {
                    *p = '\\';
                }
                SetLastError(err);
                return(FALSE);
            }
        }

        if ( p != NULL ) {
            *p = '\\';
            p++;
        }

    } while ( p != NULL );

    return(TRUE);

} // IISCreateDirectory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\perfutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.c

   Abstract:

      This file implements the utility routines used for all perfmon 
       interface dlls in the internet services group.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Nov-1995  
          Pulled from  perfmon interface common code.

   Environment:
       User Mode
       
   Project:

       Internet Servies Common Runtime functions

   Functions Exported:

        DWORD GetQueryType();
        BOOL  IsNumberInUnicodeList();
        VOID  MonBuildInstanceDefinition();

   Revision History:

       Sophia Chung (sophiac)  05-Nov-1996
          Added routine to support multiple instances

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <string.h>

#include <winperf.h>
#include <perfutil.h>


/************************************************************
 *     Global Data Definitions
 ************************************************************/

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))


/************************************************************
 *    Functions 
 ************************************************************/



DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}



BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    )
/*++

MonBuildInstanceDefinition  

    Build an instance of an object

Arguments:

    OUT pBuffer         -   pointer to buffer where instance is to
                            be constructed

    OUT pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

    IN  ParentObjectTitleIndex
                        -   Title Index of parent object type; 0 if
                            no parent object

    IN  ParentObjectInstance
                        -   Index into instances of parent object
                            type, starting at 0, for this instances
                            parent object instance

    IN  UniqueID        -   a unique identifier which should be used
                            instead of the Name for identifying
                            this instance

    IN  Name            -   Name of this instance

Return Value:

    None.

--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

#if 0
    // allign on 8 byte boundary for new NT5 requirement
    pBuffer->ByteLength = QWORD_MULTIPLE(pBuffer->ByteLength);
    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
#endif

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    // round up to put next buffer on a QUADWORD boundry
    *pBufferNext = ALIGN_ON_QWORD (*pBufferNext);
    // adjust length value to match new length
    pBuffer->ByteLength = (ULONG)((ULONG_PTR)*pBufferNext - (ULONG_PTR)pBuffer);

    return;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\string.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class


    FILE HISTORY:
        Johnl       15-Aug-1994 Created
        MuraliK     27-Feb-1995 Modified to be a standalone module with buffer.
        MuraliK     2-June-1995 Made into separate library

*/

#include "precomp.hxx"


//
// Normal includes only for this module to be active
//

# include <opt_time.h>

extern "C" {
 # include <nt.h>
 # include <ntrtl.h>
 # include <nturtl.h>
 # include <windows.h>
};

# include "dbgutil.h"
# include <string.hxx>
# include <auxctrs.h>

# include <tchar.h>
# include <mbstring.h>

// declaration for exports in normalize.cxx in iisutil
BOOL IsUTF8URL(CHAR * pszPath);

INT
CanonURL(
    CHAR * pszPath,
    BOOL   fIsDBCSLocale
    );


//
// String globals
//

typedef UCHAR * ( __cdecl * PFNSTRCASE ) ( UCHAR * );
typedef INT ( __cdecl * PFNSTRNICMP ) ( const UCHAR *, const UCHAR *, size_t );
typedef INT ( __cdecl * PFNSTRICMP ) ( const UCHAR *, const UCHAR * );
typedef size_t ( __cdecl * PFNSTRLEN ) ( const UCHAR * );
typedef UCHAR * (__cdecl * PFNSTRRCHR) (const UCHAR *, UINT);

PFNSTRCASE  g_pfnStrupr     = _mbsupr;
PFNSTRCASE  g_pfnStrlwr     = _mbslwr;
PFNSTRNICMP g_pfnStrnicmp   = _mbsnicmp;
PFNSTRICMP  g_pfnStricmp    = _mbsicmp;
PFNSTRLEN   g_pfnStrlen     = _mbslen;
PFNSTRRCHR  g_pfnStrrchr    = _mbsrchr;

extern BOOL        g_fFavorDBCS; //    = FALSE;

#define UTF8_HACK_KEY "System\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define UTF8_HACK_VALUE "FavorDBCS"

//
//  Private Definations
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
    (TCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

//
//  Converts a single hex digit to its decimal equivalent
//
#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')


/*******************************************************************

    NAME:       STR::STR

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

********************************************************************/

// Inlined in string.hxx


VOID
STR::AuxInit( const BYTE * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        INT cbCopy = (::strlen( (const CHAR * ) pInit ) + 1) * sizeof(CHAR);
        fRet = !m_fNoRealloc && Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = (cbCopy)/sizeof(CHAR) - 1;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        *((CHAR *) QueryPtr()) = '\0';
        m_cchLen = 0;
    }

    return;
} // STR::AuxInit()



/*******************************************************************

    NAME:       STR::AuxAppend

    SYNOPSIS:   Appends the string onto this one.

    ENTRY:      Object to append
********************************************************************/

BOOL STR::AuxAppend( const BYTE * pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    AcIncrement( CacStringAppend);
    if ( QuerySize() < cbThis + cbStr + sizeof(CHAR) )
    {
        if ( m_fNoRealloc || !Resize( cbThis + cbStr + (fAddSlop ? STR_SLOP : sizeof(CHAR) )) )
            return FALSE;
    }

    // copy the exact string and append a null character
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);
    m_cchLen += cbStr/sizeof(CHAR);
    *((CHAR *) QueryPtr() + m_cchLen) = '\0';  // append an explicit null char

    return TRUE;
} // STR::AuxAppend()


#if 0
// STR::SetLen() is inlined now
BOOL
STR::SetLen( IN DWORD cchLen)
/*++
  Truncates the length of the string stored in this buffer
   to specified value.

--*/
{
    if ( cchLen >= QuerySize()) {

        // the buffer itself is not sufficient for this length. return error.
        return ( FALSE);
    }

    // null terminate the string at specified location
    *((CHAR *) QueryPtr() + cchLen) = '\0';
    m_cchLen = cchLen;

    return ( TRUE);
} // STR::SetLen()

#endif // 0


/*******************************************************************

    NAME:       STR::LoadString

    SYNOPSIS:   Loads a string resource from this module's string table
                or from the system string table

    ENTRY:      dwResID - System error or module string ID
                lpszModuleName - name of the module from which to load.
                 If NULL, then load the string from system table.

********************************************************************/

BOOL STR::LoadString( IN DWORD dwResID,
                      IN LPCTSTR lpszModuleName, // Optional
                      IN DWORD dwLangID          // Optional
                     )
{
    BOOL fReturn = FALSE;
    INT  cch;

    //
    //  If lpszModuleName is NULL, load the string from system's string table.
    //

    if ( lpszModuleName == NULL) {

        BYTE * pchBuff = NULL;

        //
        //  Call the appropriate function so we don't have to do the Unicode
        //  conversion
        //

        cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_IGNORE_INSERTS  |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                dwResID,
                                dwLangID,
                                (LPSTR) &pchBuff,
                                1024,
                                NULL );

        if ( cch ) {

          fReturn = Copy( (LPCSTR) pchBuff, cch );
        }

        //
        //  Free the buffer FormatMessage allocated
        //

        if ( cch )
        {
            ::LocalFree( (VOID*) pchBuff );
        }

    } else   {

        CHAR ach[STR_MAX_RES_SIZE];
        cch = ::LoadStringA( GetModuleHandle( lpszModuleName),
                             dwResID,
                             (CHAR *) ach,
                             sizeof(ach));
        if ( cch )
          {
            fReturn =  Copy( (LPSTR) ach, cch );
          }
    }

    return ( fReturn);

} // STR::LoadString()




BOOL STR::LoadString( IN DWORD  dwResID,
                      IN HMODULE hModule
                     )
{
    DBG_ASSERT( hModule != NULL );

    BOOL fReturn = FALSE;
    INT  cch;
    CHAR ach[STR_MAX_RES_SIZE];

    cch = ::LoadStringA(hModule,
                        dwResID,
                        (CHAR *) ach,
                        sizeof(ach));
    if ( cch ) {

      fReturn =  Copy( (LPSTR) ach, cch );
    }

    return ( fReturn);

} // STR::LoadString()



BOOL
STR::FormatString(
    IN DWORD   dwResID,
    IN LPCTSTR apszInsertParams[],
    IN LPCTSTR lpszModuleName,
    IN DWORD   cbMaxMsg
    )
{
    DWORD cch;
    LPSTR pchBuff;
    BOOL  fRet = FALSE;

    cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                            FORMAT_MESSAGE_FROM_HMODULE,
                            GetModuleHandle( lpszModuleName ),
                            dwResID,
                            0,
                            (LPSTR) &pchBuff,
                            cbMaxMsg * sizeof(WCHAR),
                            (va_list *) apszInsertParams );

    if ( cch )
    {
        fRet = Copy( (LPCSTR) pchBuff, cch );

        ::LocalFree( (VOID*) pchBuff );
    }

    /* INTRINSA suppress = uninitialized */
    return fRet;
}



/*******************************************************************

    NAME:       STR::Escape

    SYNOPSIS:   Replaces non-ASCII characters with their hex equivalent

    NOTES:

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL STR::Escape( VOID )
{
    CHAR * pch      = QueryStr();
    int     i       = 0;
    CHAR    ch;

    DBG_ASSERT( pch );

    while ( ch = pch[i] )
    {
        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&') ||
              (ch == '#')) &&
             !(ch == '\n' || ch == '\r')  )
        {
            if ( m_fNoRealloc || !Resize( QuerySize() + 2 * sizeof(CHAR) ))
                return FALSE;

            //
            //  Resize can change the base pointer
            //

            pch = QueryStr();

            //
            //  Insert the escape character
            //

            pch[i] = '%';

            //
            //  Insert a space for the two hex digits (memory can overlap)
            //

            /* INTRINSA suppress = uninitialized */

            ::memmove( &pch[i+3],
                       &pch[i+1],
                       (::strlen( &pch[i+1] ) + 1) * sizeof(CHAR));

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            pch[i+2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            pch[i+1] = HEXDIGIT( nDigit );

            i += 3;
        }
        else
            i++;
    }

    m_cchLen = ::strlen( QueryStr());  // to be safe recalc the new length
    return TRUE;
} // STR::Escape()


/*******************************************************************

    NAME:       STR::EscapeSpaces

    SYNOPSIS:   Replaces all spaces with their hex equivalent

    NOTES:

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL STR::EscapeSpaces( VOID )
{
    CHAR * pch      = QueryStr();
    CHAR * pchTmp;
    int    i = 0;

    DBG_ASSERT( pch );

    while ( pchTmp = strchr( pch + i, ' ' ))
    {
        i = DIFF( pchTmp - QueryStr() );

        if ( m_fNoRealloc || !Resize( QuerySize() + 2 * sizeof(CHAR) ))
            return FALSE;

        //
        //  Resize can change the base pointer
        //

        pch = QueryStr();

        //
        //  Insert the escape character
        //

        pch[i] = '%';

        //
        //  Insert a space for the two hex digits (memory can overlap)
        //

        ::memmove( &pch[i+3],
                   &pch[i+1],
                   (::strlen( &pch[i+1] ) + 1) * sizeof(CHAR));

        //
        //  This routine only replaces spaces
        //

        pch[i+1] = '2';
        pch[i+2] = '0';
    }

    //
    //  If i is zero then no spaces were found
    //

    if ( i != 0 )
    {
        m_cchLen = ::strlen( QueryStr());  // to be safe recalc the new length
    }

    return TRUE;

} // STR::EscapeSpaces()



/*******************************************************************

    NAME:       STR::Unescape

    SYNOPSIS:   Replaces hex escapes with the Latin-1 equivalent

    NOTES:      This is a Unicode only method

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL STR::Unescape( VOID )
{
        CHAR    *pScan;
        CHAR    *pDest;
        CHAR    *pNextScan;
        wchar_t wch;
        DWORD   dwLen;
    BOOL        fChanged = FALSE;

        pDest = pScan = strchr( QueryStr(), '%');

        while (pScan)
        {
                if ( (pScan[1] == 'u' || pScan[1] == 'U') &&
                        ::isxdigit( (UCHAR)pScan[2] ) &&
                        ::isxdigit( (UCHAR)pScan[3] ) &&
                        ::isxdigit( (UCHAR)pScan[4] ) &&
                        ::isxdigit( (UCHAR)pScan[5] ) )
                {
                        wch = TOHEX(pScan[2]) * 4096 + TOHEX(pScan[3]) * 256;
                        wch += TOHEX(pScan[4]) * 16 + TOHEX(pScan[5]);

                        dwLen = WideCharToMultiByte( CP_ACP,
                                                                        0,
                                                                        &wch,
                                                                        1,
                                                                        (LPSTR) pDest,
                                                                        2,
                                                                        NULL,
                                                                        NULL );

                        pDest += dwLen;
                        pScan += 6;
                        fChanged = TRUE;
                }
                else if ( ::isxdigit( (UCHAR)pScan[1] ) && // WinSE 4944
                                ::isxdigit( (UCHAR)pScan[2] ))
                {
                        *pDest = TOHEX(pScan[1]) * 16 + TOHEX(pScan[2]);

                        pDest ++;
                        pScan += 3;
                        fChanged = TRUE;
                }
                else   // Not an escaped char, just a '%'
                {
                        if (fChanged)
                                *pDest = *pScan;

                        pDest++;
                        pScan++;
                }

                //
                // Copy all the information between this and the next escaped char
                //
                pNextScan = strchr( pScan, '%');

                if (fChanged)                                   // pScan!=pDest, so we have to copy the char's
                {
                        if (!pNextScan)                         // That was the last '%' in the string
                        {
                                ::memmove( pDest,
                                                        pScan,
                                                        (::strlen( pScan ) + 1) * sizeof(CHAR));  // +1 to copy '\0'
                        }
                        else                                            // There is another '%', and it is not back to back with this one
                                if (dwLen = DIFF(pNextScan - pScan))
                                {
                                        ::memmove( pDest,
                                                                pScan,
                                                                dwLen * sizeof(CHAR));
                                        pDest += dwLen;
                                }
                }

                pScan = pNextScan;
        }

    if ( fChanged )
    {
        m_cchLen = ::strlen( QueryStr());  // for safety recalc the length
    }

    return TRUE;
}



BOOL
STR::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the UNICODE version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         11-30-94
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

      //
      //  Inquiring the size of buffer alone
      //
      *lpcch = QueryCCH() + 1;    // add one character for terminating null
    } else {

        //
        // Copy after conversion from ANSI to Unicode
        //
        int  iRet;
        iRet = MultiByteToWideChar( CP_ACP,   MB_PRECOMPOSED,
                                    QueryStrA(),  QueryCCH() + 1,
                                    lpszBuffer, (int )*lpcch);

        if ( iRet == 0 || iRet != (int ) *lpcch) {

            //
            // Error in conversion.
            //
            fReturn = FALSE;
        }
    }

    return ( fReturn);
} // STR::CopyToBuffer()


BOOL
STR::CopyToBuffer( CHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the CHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to CHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    register DWORD cch = QueryCCH() + 1;

    if ( (*lpcch >= cch) && ( NULL != lpszBuffer)) {

        DBG_ASSERT( lpszBuffer);
        CopyMemory( lpszBuffer, QueryStrA(), cch);
    } else {
        DBG_ASSERT( (NULL == lpszBuffer) || (*lpcch < cch));
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // STR::CopyToBuffer()

BOOL
STR::SafeCopy( const CHAR  * pchInit )
{
    DWORD cchLen = 0;
    char cFirstByte = '\0';
    BOOL bReturn = TRUE;
    if ( QueryPtr() ) {
        cFirstByte = *(QueryStr());
        cchLen = m_cchLen;
        *(QueryStr()) = '\0';
        m_cchLen = 0;
    }
    if (pchInit != NULL) {
        bReturn  = AuxAppend( (const BYTE *) pchInit, ::strlen( pchInit ), FALSE );
        if (!bReturn && QueryPtr()) {
            *(QueryStr()) = cFirstByte;
            m_cchLen = cchLen;
        }
    }
    return bReturn;
}


//*********************************************************************************************
//
// following two routines implement a simple hashing of strings to hide clear text
// passwords sitting in memory from easy detection in memory dumps and pege files.
//
//
//*********************************************************************************************

//
// if the first bit is '1', then XOR will likely turn all printable characters
// into seemingly 'binary' data
//
const UCHAR HashConst = 0xA3;

/*******************************************************************

    NAME:       Hash

    SYNOPSIS:   Hide passwords by converting the in memory string to something
                harder to identify by simply looking at a memory dump or page file.
                Using a cheap operation (XOR). Hashing is done in-place.


    ENTRY:      None.

    RETURNS:    None.

    HISTORY:
        RobSol     20-Sep-2001 Created.

********************************************************************/

VOID
STR::Hash()
{
    PSTR pszStr = QueryStr();
    UCHAR HashVal;

    DBG_ASSERT( pszStr != NULL );

    if (pszStr == NULL || *pszStr == '\0') {
        return;
    }

    for (HashVal = HashConst; *pszStr != '\0'; ) {
        HashVal ^= *pszStr;
        *pszStr++ = HashVal;
    }
}

/*******************************************************************

    NAME:       Unhash

    SYNOPSIS:   Reverse the hash of Hash() in-place.


    ENTRY:      None.

    RETURNS:    None.

    HISTORY:
        RobSol     20-Sep-2001 Created.

********************************************************************/

VOID
STR::Unhash()
{
    PSTR pszStr = QueryStr();
    UCHAR HashVal, NextHashVal;

    DBG_ASSERT( pszStr != NULL );

    if (pszStr == NULL || *pszStr == '\0') {
        return;
    }

    for (HashVal = HashConst; *pszStr != '\0'; HashVal = NextHashVal) {
        NextHashVal = *pszStr;
        *pszStr++ ^= HashVal;
    }
}


/*******************************************************************

    NAME:       ::CollapseWhite

    SYNOPSIS:   Collapses white space starting at the passed pointer.

    RETURNS:    Returns a pointer to the next chunk of white space or the
                end of the string.

    NOTES:      This is a Unicode only method

    HISTORY:
        Johnl   24-Aug-1994     Created

********************************************************************/

WCHAR * CollapseWhite( WCHAR * pch )
{
    LPWSTR pchStart = pch;

    while ( ISWHITE( *pch ) )
        pch++;

    ::memmove( pchStart,
               pch,
               DIFF(pch - pchStart) );

    while ( *pch && !ISWHITE( *pch ))
        pch++;

    return pch;
} // CollapseWhite()



DWORD
InitializeStringFunctions(
    VOID
)
/*++
  Initializes the string function pointers depending on the system code page.
  If the code page doesn't have multi-byte characters, then pointers
  resolve to regular single byte functions.  Otherwise, they resolve to more
  expense multi-byte functions.

  Arguments:
     None

  Returns:
     0 if successful, else Win32 Error

--*/
{
    CPINFO          CodePageInfo;
    BOOL            bRet;
    HKEY            hKey;
    DWORD           dwRet;

    bRet = GetCPInfo( CP_ACP, &CodePageInfo );

    if ( bRet && CodePageInfo.MaxCharSize == 1 )
    {
        g_pfnStrlwr     = (PFNSTRCASE)  _strlwr;
        g_pfnStrupr     = (PFNSTRCASE)  _strupr;
        g_pfnStrnicmp   = (PFNSTRNICMP) _strnicmp;
        g_pfnStricmp    = (PFNSTRICMP)  _stricmp;
        g_pfnStrlen     = (PFNSTRLEN)   strlen;
        g_pfnStrrchr    = (PFNSTRRCHR)  strrchr;
    }

    //
    // Do we need to hack for Korean?
    //

    dwRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          UTF8_HACK_KEY,
                          0,
                          KEY_READ,
                          &hKey );
    if ( dwRet == ERROR_SUCCESS )
    {
        DWORD               dwValue = 0;
        DWORD               cbValue = sizeof( dwValue );

        dwRet = RegQueryValueEx( hKey,
                                 UTF8_HACK_VALUE,
                                 NULL,
                                 NULL,
                                 (LPBYTE) &dwValue,
                                 &cbValue );
        if ( dwRet == ERROR_SUCCESS )
        {
            g_fFavorDBCS = !!dwValue;
        }

        DBG_REQUIRE( RegCloseKey( hKey ) == ERROR_SUCCESS );
    }

    return ERROR_SUCCESS;
}

UCHAR *
IISstrupr(
    UCHAR *             pszString
)
/*++
  Wrapper for strupr() call.

  Arguments:
     pszString - String to uppercase

  Returns:
     Pointer to string uppercased

--*/
{
    DBG_ASSERT( g_pfnStrupr != NULL );

    return g_pfnStrupr( pszString );
}

UCHAR *
IISstrlwr(
    UCHAR *             pszString
)
/*++
  Wrapper for strlwr() call.

  Arguments:
     pszString - String to lowercase

  Returns:
     Pointer to string lowercased

--*/
{
    DBG_ASSERT( g_pfnStrlwr != NULL );

    return g_pfnStrlwr( pszString );
}

size_t
IISstrlen(
    UCHAR *             pszString
)
/*++
  Wrapper for strlen() call.

  Arguments:
     pszString - String to check

  Returns:
     Length of string

--*/
{
    DBG_ASSERT( g_pfnStrlen != NULL );

    return g_pfnStrlen( pszString );
}

INT
IISstrnicmp(
    UCHAR *             pszString1,
    UCHAR *             pszString2,
    size_t              size
)
/*++
  Wrapper for strnicmp() call.

  Arguments:
     pszString1 - String1
     pszString2 - String2
     size - # characters to compare upto

  Returns:
     0 if equal, -1 if pszString1 < pszString2, else 1

--*/
{
    DBG_ASSERT( g_pfnStrnicmp != NULL );

    return g_pfnStrnicmp( pszString1, pszString2, size );
}


INT
IISstricmp(
    UCHAR *             pszString1,
    UCHAR *             pszString2
)
/*++
  Wrapper for stricmp() call.

  Arguments:
     pszString1 - String1
     pszString2 - String2

  Returns:
     0 if equal, -1 if pszString1 < pszString2, else 1

--*/
{
    DBG_ASSERT( g_pfnStricmp != NULL );

    return g_pfnStricmp( pszString1, pszString2 );
}


// like strncpy, but doesn't pad the end of the string with zeroes, which
// is expensive when `source' is short and `count' is large
char *
IISstrncpy(
    char * dest,
    const char * source,
    size_t count)
{
    char *start = dest;

    while (count && (*dest++ = *source++))    /* copy string */
        count--;

    if (count)                              /* append one zero */
        *dest = '\0';

    return(start);
}

UCHAR *
IISstrrchr(
    const UCHAR *       pszString,
    UINT                c
)
/*++
  Wrapper for strrchr() call.

  Arguments:
     pszString - String
     c         - Character to find.

  Returns:
     pointer to the char or NULL.

--*/
{
    DBG_ASSERT( g_pfnStrrchr != NULL );

    return g_pfnStrrchr( pszString, c );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\strings.cpp ===
#include "precomp.hxx"

#define IMPLEMENTATION_EXPORT
#include <irtlmisc.h>


// stristr (stolen from fts.c, wickn)
//
// case-insensitive version of strstr.
// stristr returns a pointer to the first occurrence of
// pszSubString in pszString.  The search does not include
// terminating nul characters.
//
// NOTE: This routine is NOT DBCS-safe?

const char*
stristr(const char* pszString, const char* pszSubString)
{
    const char *cp1 = (const char*) pszString, *cp2, *cp1a;
    char first;

    // get the first char in string to find
    first = pszSubString[0];

    // first char often won't be alpha
    if (isalpha((UCHAR)first))
    {
        first = (char) tolower(first);
        for ( ; *cp1  != '\0'; cp1++)
        {
            if (tolower(*cp1) == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }
    else
    {
        for ( ; *cp1 != '\0' ; cp1++)
        {
            if (*cp1 == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl\rpcutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      rpcutil.c

   Abstract:

      This module defines functions that may help to replace the rpc util
        functions from rpcutil.lib

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Sept-1995

   Environment:
       Win32 User Mode

   Project:

       Common Code for Internet Services

   Functions Exported:

        MIDL_user_allocate()
        MIDL_user_free()
        RpcBindHandleForServer()
        RpcBindHandleFree()

   Revision History:

        Murali R. Krishnan (MuraliK) 21-Dec-1995  Support TcpIp binding & free.
        Murali R. Krishnan (MuraliK) 20-Feb-1996  Support Lpc binding & free.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <rpc.h>

# include "apiutil.h"


#if DBG

#include <stdio.h>
#include <stdlib.h>

#define DBGPRINTF(s)       { CHAR rgchBuff[1024]; \
                             sprintf s ; \
                             OutputDebugStringA( rgchBuff); \
                           }
#define DBG_CONTEXT        ( rgchBuff)


#else // DBG


#define DBGPRINTF(s)     /* nothing */
#define DBG_CONTEXT      /* nothing */

#endif // DBG

#define ISRPC_CLIENT_OVER_TCPIP          0x00000001
#define ISRPC_CLIENT_OVER_NP             0x00000002
#define ISRPC_CLIENT_OVER_SPX            0x00000004
#define ISRPC_CLIENT_OVER_LPC            0x00000008

// # define MAX_COMPUTERNAME_LENGTH    (255)


/************************************************************
 *    Functions
 ************************************************************/


PVOID
MIDL_user_allocate(IN size_t size)
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    PVOID pvBlob;

    pvBlob = LocalAlloc( LPTR, size);

    return( pvBlob );

} // MIDL_user_allocate()




VOID
MIDL_user_free(IN PVOID pvBlob)
/*++

Routine Description:

    MIDL memory free .

Arguments:

    pvBlob : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    LocalFree( pvBlob);

    return;
}  // MIDL_user_free()




RPC_STATUS
RpcBindHandleOverNamedPipe( OUT handle_t * pBindingHandle,
                           IN LPWSTR      pwszServerName,
                           IN LPWSTR      pwszEndpoint,
                           IN LPWSTR      pwszOptions
                          )
/*++
  This function uses the parameters supplied and generates a named pipe
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszEndpoint     pointer to string containing the Named Pipe Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncacn_np",  // prot seq: named pipe
                                         pwszServerName, // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverNamedPipe()

RPC_STATUS
RpcBindHandleOverLpc( OUT handle_t * pBindingHandle,
                      IN LPWSTR      pwszEndpoint,
                      IN LPWSTR      pwszOptions
                     )
/*++
  This function uses the parameters supplied and generates a lpc
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszEndpoint     pointer to string containing the lpc Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncalrpc",   // prot seq: lpc
                                         NULL,         // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverLpc()




#ifndef CHICAGO

//
// If changes are made to the NT version, check out the windows 95
// version located right after this routine and see if the change
// needs to be propagated there too.
//

RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    NT Version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }
    else
        return RPC_S_INVALID_BINDING;

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,               // ObjUuid
                                         L"ncacn_ip_tcp", // tcpip seq
                                         pwszServerName,  // NetworkAddr
                                         NULL,            // Endpoint
                                         L"",             // Options
                                         &pwszBinding);   // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingComposeW(%S, %S) return %S."
                " Error = %ld\n",
                L"ncacn_ip_tcp",
                pwszServerName,
                pwszBinding,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBindingW(%S) return %d."
                    "Binding=%p\n",
                    pwszBinding,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {

        DWORD rpcStatus1 = RpcStringFreeW(&pwszBinding);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()

#else // CHICAGO



RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    Windows 95 version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPSTR     pszBindingA = NULL;
    CHAR    szServerA[MAX_PATH];
    CHAR    szInterfaceA[MAX_PATH];
    int        cch;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }
    else
        return RPC_S_INVALID_BINDING;

    *szServerA = '0';

    if (pwszServerName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszServerName,
                              -1,
                              szServerA,
                              sizeof(szServerA)/sizeof(CHAR),
                              NULL,NULL
                              );

    *szInterfaceA = '0';

    if(pwszInterfaceName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszInterfaceName,
                              -1,
                              szInterfaceA,
                              sizeof(szInterfaceA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingCompose(0,            // ObjUuid
                                         "ncacn_ip_tcp", // tcpip seq
                                         szServerA, // NetworkAddr
                                         NULL, // Endpoint
                                         NULL, //L"",  // Options
                                         &pszBindingA);    // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingCompose(%s, %s) return %s."
                " Error = %ld\n",
                "ncacn_ip_tcp",
                szServerA,
                pszBindingA,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBinding(%s) return %d."
                    "Binding=%p\n",
                    pszBindingA,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfo(*pBindingHandle,
                                 szInterfaceA,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,  // AuthnIdentity
                                 0      // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%s(Interface=%s), %p)"
                    " return %d.\n",
                    pszBindingA,
                    szInterfaceA,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pszBindingA != NULL) {

        DWORD rpcStatus1 = RpcStringFree(&pszBindingA);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()
#endif



#ifndef CHICAGO
DWORD
RpcuFindProtocolToUse( IN LPCWSTR pwszServerName)
/*++
  Given the server name this funciton determines the protocol
  to use for RPC binding.

  The transport used is determined dynamically based on following rules.

  If server name is NULL or 127.0.0.1 or same as local computer name
      then use the LPC.

  If server name starts with a leading "\\" (double slash),
      then attempt RPC binding over NamedPipe.

  If server name does not start with leading "\\",
      then attempt RPC binding over TCPIP.

  If TCPIP binding fails, then this function tries binding over NamedPipe.


  Argument:
    pwszServerName - pointer to string containing the name of the server


  Returns:
    DWORD containing the type of protocol to use.

--*/
{
    static WCHAR g_wchLocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];
    BOOL   fLeadingSlashes;
    DWORD  dwBindProtocol = ISRPC_CLIENT_OVER_NP;
    BOOL   fLocalMachine;

    if ( pwszServerName == NULL ||
         _wcsicmp( L"127.0.0.1", pwszServerName) == 0) {


        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( g_wchLocalMachineName[0] == L'\0') {

        DWORD cchComputerNameLen = MAX_COMPUTERNAME_LENGTH+1;

        //
        // Obtain the local computer name
        //

        if (!GetComputerNameW( g_wchLocalMachineName,
                              &cchComputerNameLen)
            ) {

            *g_wchLocalMachineName = L'\0';
        }
    }

    fLeadingSlashes = ((*pwszServerName == L'\\') &&
                       (*(pwszServerName+1) == L'\\')
                       );


    //
    // Check to see if machine name matches local computer name
    //  if so, use LPC
    //

    fLocalMachine = !_wcsicmp( g_wchLocalMachineName,
                              ((fLeadingSlashes) ?
                               (pwszServerName + 2) : pwszServerName)
                              );

    if ( fLocalMachine) {

        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( !fLeadingSlashes) {

        DWORD  nDots;
        LPCWSTR pszName;

        //
        // Check if the name has dotted decimal name.
        // If so then suggest TCP binding.
        //

        for( nDots = 0, pszName = pwszServerName;
            ((pszName = wcschr( pszName, L'.' )) != NULL);
            nDots++, pszName++)
          ;

        if ( nDots == 3) {

            //
            // if the string has 3 DOTs exactly then this string must represent
            // an IpAddress.
            //

            return(ISRPC_CLIENT_OVER_TCPIP);
        }
    }


    return ( ISRPC_CLIENT_OVER_NP);
} // RpcuFindProtocolToUse()
#endif



RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       )
/*++
  This function uses the parameters supplied and generates a binding
    handle for RPC.


  It is assumed that binding over named pipe uses static end point
      with the interface name and options as provided.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name
   pwszOptions      pointer to string containing any additional options for
                       binding.

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus = RPC_S_SERVER_UNAVAILABLE;
    LPWSTR     pwszBinding = NULL;
    DWORD      dwBindProtocol = 0;


    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }
    else
        return RPC_S_INVALID_BINDING;

#ifndef CHICAGO
    dwBindProtocol = RpcuFindProtocolToUse( pwszServerName);
#else
    dwBindProtocol = ISRPC_CLIENT_OVER_TCPIP;
#endif

    switch ( dwBindProtocol) {

      case ISRPC_CLIENT_OVER_LPC:
        {

            WCHAR  rgchLpc[1024];

            //
            // generate a LPC end point name from the interface name.
            //  the End point =   <InterfaceName>_LPC
            //

            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchLpc)/sizeof(WCHAR) - 6)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcpyW( rgchLpc, pwszInterfaceName);
            lstrcatW( rgchLpc, L"_LPC");

            //
            // Attempt binding over static LPC.
            //

            rpcStatus = RpcBindHandleOverLpc( pBindingHandle,
                                             rgchLpc,
                                             pwszOptions
                                             );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverLpc(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));

            break;
        }

      case ISRPC_CLIENT_OVER_TCPIP:

// # ifdef RPC_BIND_OVER_TCP

        //
        // Attempt binding over TCPIP using Dynamic Endpoint.
        //

        rpcStatus = RpcBindHandleOverTcpIp( pBindingHandle,
                                           pwszServerName,
                                           pwszInterfaceName);

        DBGPRINTF(( DBG_CONTEXT,
                   " RpcBindingOverTcpIp(%S) returns %d. Handle = %p\n",
                   pwszServerName, rpcStatus, *pBindingHandle));

        if ( rpcStatus == RPC_S_OK) {

            break;  // done with RPC binding over TCP
        }

        // Fall Through

// # endif // RPC_BIND_OVER_TCP

      case ISRPC_CLIENT_OVER_NP:
        {
            WCHAR  rgchNp[1024];

            //
            // generate a NamedPipe end point name from the interface name.
            //  the End point =   \PIPE\<InterfaceName>
            //

            lstrcpyW( rgchNp, L"\\PIPE\\");
            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchNp)/sizeof(WCHAR) - 10)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcatW( rgchNp, pwszInterfaceName);

            //
            // Attempt binding over static NamedPipe.
            //

            rpcStatus = RpcBindHandleOverNamedPipe( pBindingHandle,
                                                   pwszServerName,
                                                   rgchNp,
                                                   pwszOptions
                                                   );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverNamedPipe(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));
            break;
        }

      default:
        break;

    } // switch()

    return ( rpcStatus);

} // RpcBindHandleForServer()





RPC_STATUS
RpcBindHandleFree(IN OUT handle_t * pBindingHandle)
/*++

  Description:

    This function frees up the binding handle allocated using
      RpcBindHandleForServer(). It uses RPC Binding Free routing to do this.
    This function acts just as a thunk so that the alloc/free of RPC contexts
      are consolidated within this module.

  Arguments:
    pBindingHandle  pointer to RPC binding handle that needs to be freed.


  Returns:
    RPC_STATUS - containig the RPC status. RPC_S_OK for success.

--*/
{

    return ( RpcBindingFree( pBindingHandle));

} // RpcBindHandleFree()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\alloc.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\alloc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\aucommon.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\aucommon.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\mlszau.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\mlszau.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\eventlog.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\eventlog.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\main.cxx ===
#include "precomp.hxx"
#include <irtldbg.h>
#include "alloc.h"

/////////////////////////////////////////////////////////////////////////////
// Globals

// We always define these variables so that they exist in both free and
// checked versions of iisrtl2.lib
DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT()
DECLARE_PLATFORM_TYPE()

// NOTE: Anything that is initialized in IISRTLs DLLMAIN needs to be done here
// too, the same for terminates.
extern "C" CRITICAL_SECTION g_csGuidList;
extern "C" LIST_ENTRY g_pGuidList;
extern "C" DWORD g_dwSequenceNumber;
extern "C" BOOL InitializeIISUtilProcessAttach(VOID);
extern "C" VOID TerminateIISUtilProcessDetach(VOID);


// NOTE: It is mandatory that any program using the IISRTL2 calls the
// initialize and terminate functions below at program startup and shutdown.
extern "C" void InitializeIISRTL2()
{
    IisHeapInitialize();
    InitializeStringFunctions();
    InitializeIISUtilProcessAttach();
}

extern "C" void TerminateIISRTL2()
{
    TerminateIISUtilProcessDetach();
    IisHeapTerminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff
--*/

#include "precomp.hxx"

#include <inetsvcs.h>


typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }

    //
    // see if this is winnt
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        IIS_PRINTF((buff,"GetVersionEx failed with %d\n",
                    GetLastError()));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibrary("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtInvalid;
    }

    g_PlatformType = pt;
    return(pt);

} // IISGetPlatformType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\multisz.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\multisz.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\common\util\iisrtl2\string.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\string.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\adminmonitor.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    adminmonitor.h

        Declarations for using the IISAdmin Monitor.
*/

#ifndef _ADMINMONITOR_H_
#define _ADMINMONITOR_H_

enum INETINFO_CRASH_ACTION
{
    NotifyAfterInetinfoCrash = 0,
    ShutdownAfterInetinfoCrash,
    RehookAfterInetinfoCrash,
    SystemFailureMonitoringInetinfo
};

typedef VOID (*PFN_IISAdminNotify)(INETINFO_CRASH_ACTION);

HRESULT
StartIISAdminMonitor(
    PFN_IISAdminNotify pfnNotifyIISAdminCrash
    );

VOID
StopIISAdminMonitor(
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ctrstshr\ctrstshr.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ctrstshr.cxx

Abstract:

    This file contains array descriptions of counters
    that are needed for handling worker processes counters.

Author:

    Emily Kruglick (EmilyK)       19-Sept-2000

Revision History:

--*/


#include "iis.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include "http.h"
#include "httpp.h"
#include "wpcounters.h"

//
// Every entry here has a corrosponding entry in the equivalent
// enum and structure in IISCOUNTERS.h
//

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
// Used By WAS and the WP to figure out offset, and sizes as well
// as whether or not to zero a field.
//
HTTP_PROP_DESC aIISWPGlobalDescription[] =
{
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentFileCacheMemoryUsage),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentFileCacheMemoryUsage),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, MaxFileCacheMemoryUsage),
      FIELD_OFFSET(IISWPGlobalCounters, MaxFileCacheMemoryUsage),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentFilesCached),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentFilesCached),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFilesCached),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFilesCached),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, FileCacheHits),
      FIELD_OFFSET(IISWPGlobalCounters, FileCacheHits),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, FileCacheMisses),
      FIELD_OFFSET(IISWPGlobalCounters, FileCacheMisses),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, FileCacheFlushes),
      FIELD_OFFSET(IISWPGlobalCounters, FileCacheFlushes),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, ActiveFlushedFiles),
      FIELD_OFFSET(IISWPGlobalCounters, ActiveFlushedFiles),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFlushedFiles),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFlushedFiles),
      TRUE  },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentUrisCached),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentUrisCached),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalUrisCached),
      FIELD_OFFSET(IISWPGlobalCounters, TotalUrisCached),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, UriCacheHits),
      FIELD_OFFSET(IISWPGlobalCounters, UriCacheHits),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, UriCacheMisses),
      FIELD_OFFSET(IISWPGlobalCounters, UriCacheMisses),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, UriCacheFlushes),
      FIELD_OFFSET(IISWPGlobalCounters, UriCacheFlushes),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFlushedUris),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFlushedUris),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentBlobsCached),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentBlobsCached),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalBlobsCached),
      FIELD_OFFSET(IISWPGlobalCounters, TotalBlobsCached),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, BlobCacheHits),
      FIELD_OFFSET(IISWPGlobalCounters, BlobCacheHits),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, BlobCacheMisses),
      FIELD_OFFSET(IISWPGlobalCounters, BlobCacheMisses),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, BlobCacheFlushes),
      FIELD_OFFSET(IISWPGlobalCounters, BlobCacheFlushes),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFlushedBlobs),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFlushedBlobs),
      TRUE }
};

//
// Used by WAS and WP to navigate the IISWPSiteCounters structure.
//
HTTP_PROP_DESC aIISWPSiteDescription[] =
{
    { RTL_FIELD_SIZE(IISWPSiteCounters, FilesSent),
      FIELD_OFFSET(IISWPSiteCounters, FilesSent),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, FilesReceived),
      FIELD_OFFSET(IISWPSiteCounters, FilesReceived),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, FilesTransferred),
      FIELD_OFFSET(IISWPSiteCounters, FilesTransferred),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, CurrentAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentNonAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, CurrentNonAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, AnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, AnonUsers),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, NonAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, NonAnonUsers),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, MaxAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxNonAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, MaxNonAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, LogonAttempts),
      FIELD_OFFSET(IISWPSiteCounters, LogonAttempts),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, GetReqs),
      FIELD_OFFSET(IISWPSiteCounters, GetReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, OptionsReqs),
      FIELD_OFFSET(IISWPSiteCounters, OptionsReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, PostReqs),
      FIELD_OFFSET(IISWPSiteCounters, PostReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, HeadReqs),
      FIELD_OFFSET(IISWPSiteCounters, HeadReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, PutReqs),
      FIELD_OFFSET(IISWPSiteCounters, PutReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, DeleteReqs),
      FIELD_OFFSET(IISWPSiteCounters, DeleteReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, TraceReqs),
      FIELD_OFFSET(IISWPSiteCounters, TraceReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MoveReqs),
      FIELD_OFFSET(IISWPSiteCounters, MoveReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CopyReqs),
      FIELD_OFFSET(IISWPSiteCounters, CopyReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MkcolReqs),
      FIELD_OFFSET(IISWPSiteCounters, MkcolReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, PropfindReqs),
      FIELD_OFFSET(IISWPSiteCounters, PropfindReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, ProppatchReqs),
      FIELD_OFFSET(IISWPSiteCounters, ProppatchReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, SearchReqs),
      FIELD_OFFSET(IISWPSiteCounters, SearchReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, LockReqs),
      FIELD_OFFSET(IISWPSiteCounters, LockReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, UnlockReqs),
      FIELD_OFFSET(IISWPSiteCounters, UnlockReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, OtherReqs),
      FIELD_OFFSET(IISWPSiteCounters, OtherReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentCgiReqs),
      FIELD_OFFSET(IISWPSiteCounters, CurrentCgiReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CgiReqs),
      FIELD_OFFSET(IISWPSiteCounters, CgiReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxCgiReqs),
      FIELD_OFFSET(IISWPSiteCounters, MaxCgiReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentIsapiExtReqs),
      FIELD_OFFSET(IISWPSiteCounters, CurrentIsapiExtReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, IsapiExtReqs),
      FIELD_OFFSET(IISWPSiteCounters, IsapiExtReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxIsapiExtReqs),
      FIELD_OFFSET(IISWPSiteCounters, MaxIsapiExtReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, NotFoundErrors),
      FIELD_OFFSET(IISWPSiteCounters, NotFoundErrors),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, LockedErrors),
      FIELD_OFFSET(IISWPSiteCounters, LockedErrors),
      TRUE },

};

#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\irtldbg.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define IRTLDBG_RUNNING_AS_SERVICE 1

#include <tchar.h>


// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};  // specialize only for `true'
#define STATIC_ASSERT(expr) static_checker< (expr) >()


# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef _DEBUG
#  define IRTLDEBUG
# endif

# ifdef IRTLDEBUG
#  ifndef USE_DEBUG_CRTS
    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>

    /* workaround for /W4 warnings about 'constant expressions' */
#   define IRTLASSERT(f)                                        \
    ((void) ((f) || (PuDbgAssertFailed(DBG_CONTEXT, #f, NULL), 0) ))

#  elif defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)               IRTLASSERT(f)
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)              (f)
#  endif
#  define IRTLTRACE                   IrtlTrace
#  define IRTLTRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define IRTLTRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define IRTLTRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define IRTLTRACE4(psz, p1, p2, p3, p4) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4)
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4, p5)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !IRTLDEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)          ((void)0)
#  endif
#  define IRTLTRACE               1 ? (void)0 : IrtlTrace
#  define IRTLTRACE0(psz)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE1(psz, p1)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE2(psz, p1, p2) 1 ? (void)0 : IrtlTrace
#  define IRTLTRACE3(psz, p1, p2, p3)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE4(psz, p1, p2, p3, p4)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) 1 ? (void)0 : IrtlTrace
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !IRTLDEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#else
# define IRTLASSERT(f) _ASSERTE(f)

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef IRTLDEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !IRTLDEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !IRTLDEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\irtlmisc.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisUtil.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__

#include <windows.h>

//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisUtil.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# elif defined LIB_IMPLEMENTATION
#  define IRTL_DLLEXP
#  define IRTL_EXPIMP extern
# else
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP



//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// Heap routines
    
// Private IIS heap
HANDLE
WINAPI 
IisHeap();

// Allocate dwBytes
LPVOID
WINAPI
IisMalloc(
    IN SIZE_T dwBytes);

// Allocate dwBytes. Memory is zeroed
LPVOID
WINAPI
IisCalloc(
    IN SIZE_T dwBytes);

// Reallocate lpMem to dwBytes
LPVOID
WINAPI
IisReAlloc(
    IN LPVOID lpMem,
    IN SIZE_T dwBytes);

// Free lpMem
BOOL
WINAPI
IisFree(
    IN LPVOID lpMem);

// additional IISUtil initialization
BOOL
WINAPI 
InitializeIISUtil();

// call before unloading IISUtil
VOID
WINAPI 
TerminateIISUtil();

//
// call only if using static library version of IISUtil
// must be called in DllMain under PROCESS_ATTACH
//
BOOL
WINAPI 
InitializeIISUtilProcessAttach();

//
// call only if using static library version of IISUtil
// must be called in DllMain under PROCESS_DETACH
//

VOID
WINAPI 
TerminateIISUtilProcessDetach();


// case-insensitive strstr
IRTL_DLLEXP const char* stristr(const char* pszString, const char* pszSubString);

// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// Type of processor, 386, 486, etc
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\lstentry.h ===
/*++

   Copyright    (c)    1999-2000    Microsoft Corporation

   Module  Name :
       lstentry.h

   Abstract:
       Declares CListEntry and other intrusive singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <locks.h>
#endif // !__LOCKS_H__

// TODO:
// * Add STL-style iterators: begin(), end(), operator++(), etc
// * Templatize the lists, so that you can avoid the CONTAINING_RECORD goo

//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    CSpinLock   m_lock;
    CSingleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    CSpinLock   m_lock;
    CDoubleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\irtltoken.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtltoken.h

   Abstract:
       IISUtil token goo

   Author:
       Wade A. Hilmo (wadeh)    5-Dec-2000

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

// token acl utilities
HRESULT
WINAPI
GrantWpgAccessToToken(
    HANDLE  hToken
    );

HRESULT
WINAPI
AddWpgToTokenDefaultDacl(
    HANDLE  hToken
    );

// token dup tool
BOOL 
DupTokenWithSameImpersonationLevel
( 
    HANDLE     hExistingToken,
    DWORD      dwDesiredAccess,
    TOKEN_TYPE TokenType,
    PHANDLE    phNewToken
);

// token privilege utility
VOID
WINAPI
DisableTokenBackupPrivilege(
    HANDLE hToken
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\perf_sm.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_sm.h

Abstract:

    Owns all shared memory operations used to 
    support performance counters.

Classes:

    PERF_SM_MANAGER
    PERF_SM_READER  (nested class of the Manager)
    PERF_SM_WRITER  (nested class of the Manager)

Author:

    Emily Kruglick (EmilyK)        6-Sept-2000

Revision History:

--*/


#ifndef _PERF_SM_H_
#define _PERF_SM_H_

#include "string.hxx"

//
// typdefs, structs, enums...
//

//
// Hard coded value used in allocation
// of strings that will contain a shared
// memory file name.
//
#define MAX_FILE_NAME 1024


// 
// Structure of all the global data
// stored at the first piece of the 
// shared memory.
//
typedef struct _COUNTER_GLOBAL_STRUCT
{
    DWORD NumInstances;
    DWORD SizeData;
} COUNTER_GLOBAL_STRUCT;

//
// Structure for controlling each
// set of counters.
//
typedef struct _COUNTER_CONTROL_BLOCK
{
    DWORD Version;
    BOOL  ActivePageIsA;
    WCHAR wszSharedMemName1[MAX_FILE_NAME];
    WCHAR wszSharedMemName2[MAX_FILE_NAME];
} COUNTER_CONTROL_BLOCK;

//
// For every valid counter set you
// must declare an entry in 
// g_CounterSetPrefixNames in the
// shared memory module.
//
typedef enum _COUNTER_SET_ENUM
{
    SITE_COUNTER_SET = 0,
    GLOBAL_COUNTER_SET,

    MAX_COUNTER_SET_DEFINES
} COUNTER_SET_ENUM;

//
// Information stored in the control manager
// about the different counter sets and the 
// counter memory in general.
//
typedef struct _MANAGER_BLOCK
{
    DWORD InitializedCode;
    DWORD WASProcessId;
    WCHAR wszSignalEventName[MAX_FILE_NAME];
    DWORD LastUpdatedTickCount;
    COUNTER_CONTROL_BLOCK ControlArray[MAX_COUNTER_SET_DEFINES];
} MANAGER_BLOCK;


//
// Describes the counters in the form they are passed
// to the client library in.
//
typedef struct _PROP_DISPLAY_DESC
{
    ULONG offset;
    ULONG size;
} PROP_DISPLAY_DESC;


//
// common #defines
//

#define PERF_SM_WRITER_SIGNATURE        CREATE_SIGNATURE( 'SMWC' )
#define PERF_SM_WRITER_SIGNATURE_FREED  CREATE_SIGNATURE( 'smwX' )

#define PERF_SM_READER_SIGNATURE        CREATE_SIGNATURE( 'SMRC' )
#define PERF_SM_READER_SIGNATURE_FREED  CREATE_SIGNATURE( 'smrX' )

#define PERF_SM_MANAGER_SIGNATURE            CREATE_SIGNATURE( 'SMMC' )
#define PERF_SM_MANAGER_SIGNATURE_FREED      CREATE_SIGNATURE( 'smmX' )

#define PERF_COUNTER_INITIALIZED_CODE   CREATE_SIGNATURE( 'IPCI' )
#define PERF_COUNTER_UN_INITIALIZED_CODE   CREATE_SIGNATURE( 'ipcX' )

//
// Maximum length that an instance name can be.
// Issue-09/10/2000-EmilyK MAX_INSTANCE_NAME hard coded.
// 1)  Need to use the ServerComment for the instance name.
// 2)  Need to figure out the appropriate max for the instance name.
// 3)  Need to decide what to do if ServerComment is larger than max.
//
// Issue is on work item list.
//
#define MAX_INSTANCE_NAME  100

//
// Event name used to signal when a refresh of counter
// information is needed.
//
#define COUNTER_EVENT_PREFIX_W L"Global\\WASPerfCount-"
#define COUNTER_EVENT_PREFIX_CCH_LENGTH (sizeof(COUNTER_EVENT_PREFIX_W))/(sizeof(WCHAR))
//
// prototypes
//

//
// Hooks up to the shared memory that exposes
// which file the actual counter values (for each
// set of counters) are stored in.
//
class PERF_SM_MANAGER
{
public:
    
    PERF_SM_MANAGER(
        );

    virtual
    ~PERF_SM_MANAGER(
        );

    DWORD 
    Initialize(
        IN BOOL WriteAccess
        );

    VOID
    StopPublishing(
        );

    DWORD
    CreateNewCounterSet(
        IN COUNTER_SET_ENUM CounterSetId
        );

    HRESULT
    ReallocSharedMemIfNeccessary(
        IN COUNTER_SET_ENUM CounterSetId,
        IN DWORD NumInstances
            );

    VOID
    CopyInstanceInformation(
        IN COUNTER_SET_ENUM CounterSetId,
        IN LPCWSTR              InstanceName,
        IN ULONG                MemoryOffset,
        IN LPVOID               pCounters,
        IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
        IN DWORD                cDisplayPropDesc,
        IN BOOL                 StructChanged,
        OUT ULONG*              pNewMemoryOffset
        );

    VOID
    PublishCounters(
        );

    VOID
    UpdateTotalServiceTime(
        IN DWORD  ServiceUptime
        );


    DWORD 
    GetCounterInfo(
        IN COUNTER_SET_ENUM CounterSetId,
        OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
        OUT LPVOID* ppData
        );

    DWORD 
    GetSNMPCounterInfo(
        OUT LPBYTE*  ppCounterBlock
        );

    VOID 
    PingWASToRefreshCounters(
        );

    VOID
    WaitOnPerfEvent();

    //
    // Functions used by PERF_SM_WRITER and 
    // PERF_SM_READER to make sure they are using the 
    // most current memory.  These functions are not 
    // used by WAS or the Perflib.
    //
    VOID
    GetActiveInformation(
        IN COUNTER_SET_ENUM  CounterSetId,
        OUT DWORD*           pVersion,
        OUT BOOL*            pActivePageIsA,
        OUT STRU*            pstrNameOfPageA,
        OUT STRU*            pstrNameOfPageB
        );
        
    VOID 
    SetActiveInformation(
        IN COUNTER_SET_ENUM CounterSetId,
        IN DWORD           Version,
        IN BOOL            ActivePageIsA,
        IN LPWSTR          pNameA,
        IN LPWSTR          pNameB
        );

    BOOL 
    HasWriteAccess(
        );

    BOOL 
    ReleaseIsNeeded(
        );

    HANDLE
    GetWASProcessHandle(
        );

    BOOL 
    EvaluateIfCountersAreFresh(
        );

    VOID
    SetUpdateNeeded(
        IN COUNTER_SET_ENUM CounterSetId,
        IN BOOL UpdateNeeded
        );

private:

    DWORD
    CreateEventForSignallingGathering(
        );

    DWORD
    GetLastUpdatedTickCount(
        );

    VOID 
    ResetWaitFreshCounterValues(
        );

    //
    // Private definition of the PERF_SM_WRITER for use under
    // the covers in updating the counters from WAS.
    //
    class PERF_SM_WRITER
    {
    public:

        PERF_SM_WRITER( 
            );

        virtual
        ~PERF_SM_WRITER(
            );

        DWORD
        Initialize(
            IN PERF_SM_MANAGER* pSharedManager,
            IN COUNTER_SET_ENUM CounterSetId
            );

        HRESULT
        ReallocSharedMemIfNeccessary(
            IN DWORD NumInstances
            );

        VOID
        CopyInstanceInformation(
            IN LPCWSTR              InstanceName,
            IN ULONG                MemoryOffset,
            IN LPVOID               pCounters,
            IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
            IN DWORD                cDisplayPropDesc,
            IN BOOL                 StructChanged,
            OUT ULONG*              pNewMemoryOffset
            );

        VOID
        AggregateTotal(
            IN LPVOID               pCounters,
            IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
            IN DWORD                cDisplayPropDesc
            );

        VOID
        PublishCounterPage(
            );

        VOID
        UpdateTotalServiceTime(
            IN DWORD  ServiceUptime
            );

        VOID
        SetUpdateNeeded(
            IN BOOL UpdateNeeded
            );

    private:

        HRESULT 
        CreateCounterFile(
            HANDLE* phMemory,
            LPVOID* ppMemory,
            STRU*   pstrFileMapped
            );

        PERF_COUNTER_BLOCK* 
        GetCounterBlockPtr(
            IN ULONG MemoryOffset
            );

        LPVOID 
        GetActiveMemory(
            );

        PERF_INSTANCE_DEFINITION* 
        GetInstanceInformationPtr(
            IN ULONG MemoryOffset
            );

        HRESULT
        MapSetOfCounterFiles(
            );

        DWORD m_Signature;

        DWORD m_Initialized;

        //
        // Pointer to the class that
        // controls the viewing of this
        // memory.
        //
        PERF_SM_MANAGER* m_pSharedManager;

        //
        // Idenitfies the set of counters
        // that this class is supporting.
        //
        COUNTER_SET_ENUM m_CounterSetId;

        //
        // Number of current instances
        // that this memory chunk represents
        //
        DWORD m_NumInstances;

        //
        // Size of all the memory needed
        // to transfer this information to 
        // the performance library
        //
        DWORD m_SizeOfMemory;

        //
        // The version of memory that we
        // are linked to.
        //
        DWORD m_MemoryVersionNumber;

        // 
        // Which page of memory we are 
        // currently writting to.  This
        // is the opposite of what the
        // manager will tell the reader.
        //
        BOOL m_ActiveMemoryIsA;

        //
        // If we have updated the page that
        // we are working on, but not the other
        // page, this is set.  Then when we 
        // switch pieces to update, we copy the
        // old page into this page, so we have
        // a valid memory page to work with.
        //
        BOOL m_UpdateNeeded;

        // 
        // Handles and pointers to the memory
        // pages.  We hold two open copies of the
        // counters page so we can swap what the 
        // user is looking at in a clean manner.
        //
        LPVOID m_pMemoryA;
        LPVOID m_pMemoryB;
        HANDLE m_hMemoryA;
        HANDLE m_hMemoryB;

        STRU  m_strMemoryNameA;
        STRU  m_strMemoryNameB;

    };  // class PERF_SM_WRITER

    //
    // Private PERF_SM_READER definition for use
    // by the PERF_SM_MANAGER in giving out perf
    // counter information.
    //
    // Note: It returns Win32 error codes
    // because that is what the pdh expects
    // from the exported functions.
    //
    class PERF_SM_READER
    {
    public:
        
        PERF_SM_READER(
            );
    
        virtual
        ~PERF_SM_READER(
            );

        DWORD 
        Initialize(
            IN PERF_SM_MANAGER*  pSharedManager,
            IN COUNTER_SET_ENUM  CounterSetId
            );

        DWORD 
        GetCounterInfo(
            OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
            OUT LPVOID* ppData
            );

        DWORD 
        GetSNMPCounterInfo(
            OUT LPBYTE*  ppCounterBlock
            );

    private:
  
        VOID 
        ConnectToActiveMemory(
            );
    
        LPVOID 
        GetActiveMemory(
            );

        DWORD m_Signature;

        DWORD m_Initialized;

        //
        // Controls what piece of memory 
        // the reader should read from.
        //
        PERF_SM_MANAGER* m_pSharedManager;

        //
        // Identifies which set of counters
        // we are looking at.
        //
        COUNTER_SET_ENUM m_CounterSetId;

        //
        // Identifies which memory is active
        // in the eyes of the reader.
        //
        BOOL m_ActiveMemoryIsA;

        //
        // Identifies which version is current
        // in the eyes of the reader.
        //
        DWORD m_MemoryVersionNumber; 

        //
        // Holds the handles and pointers
        // to the data files that represent
        // these counters.
        //
        HANDLE m_hMemoryA;
        LPVOID m_pMemoryA;

        HANDLE m_hMemoryB;
        LPVOID m_pMemoryB;

    };

    //
    // Private member variables of the Manager class 
    //

    DWORD m_Signature;

    BOOL  m_Initialized;

    // 
    // points to the shared memory
    // that controls which piece of
    // shared memory contains valid counters
    // as well as whether the client should
    // release the manager block.
    //
    MANAGER_BLOCK* m_pManagerMemory;

    HANDLE m_hManagerMemory;

    LPVOID m_pSMObjects;

    BOOL m_WriteAccess;

    HANDLE m_hIISSignalCounterRefresh;

    HANDLE m_WASProcessHandle;

    //
    // Used for calculating freshness of counters.
    //
    DWORD m_IIS_MillisecondsCountersAreFresh;

    DWORD m_IIS_MaxNumberTimesToCheckCountersOnRefresh; 

    DWORD m_IIS_MillisecondsToSleepBeforeCheckingForRefresh;

};


#endif  // _PERF_SM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\mb_notify.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    mb_notify.h

Abstract:

    Type definitions for handling metabase change notifications.

Author:

    Taylor Weiss (TaylorW)       26-Jan-1999

Revision History:

--*/

#ifndef _MB_NOTIFY_H_
#define _MB_NOTIFY_H_

/************************************************************
 *  Include Headers
 ************************************************************/


/************************************************************
 *  Type Definitions
 ************************************************************/

/*++

class MB_BASE_NOTIFICATION_SINK

    Base class that implements a COM object that will
    register and listen for metabase change notifications.
    It provides no useful implementation of the IMSAdminBaseSink
    methods.

    Currently the only client of this in the worker process
    is the W3_SERVER.

--*/

class MB_BASE_NOTIFICATION_SINK
    : public IMSAdminBaseSink
{
public:

    // Contruction and Destruction

    dllexp MB_BASE_NOTIFICATION_SINK();

    virtual dllexp
    ~MB_BASE_NOTIFICATION_SINK();

    // IUnknown

    dllexp STDMETHOD_(ULONG, AddRef)();

    dllexp STDMETHOD_(ULONG, Release)();

    dllexp STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);


    // IMSAdminBaseSink

    dllexp STDMETHOD( ShutdownNotify )();

    dllexp STDMETHOD( SinkNotify )(
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        ) ;

    //
    // SynchronizedShutdownNotify() and SynchronizedSinkNotify() are
    // synchronized versions of ShutdownNotify() and SinkNotify().
    //
    // SinkNotify() calls SynchronizedSinkNotify() in critical section
    // SynchronizedSinkNotify() will never be called after StopListening()
    // call returned. StopListening() will also wait till last callback
    // to SynchronizedSinkNotify() completed.
    // Thus caller of StopListening() has guarantee
    // that resources used by SynchronizedSinkNotify()
    // can be freed without worries
    //

    dllexp STDMETHOD( SynchronizedShutdownNotify )();

    // Clients must provide some useful implementation of this
    STDMETHOD( SynchronizedSinkNotify )(
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        ) = 0;


    // Public methods

    dllexp
    HRESULT
    StartListening( IUnknown * pUnkAdminBase );

    dllexp
    HRESULT
    StopListening( IUnknown * pUnkAdminBase );

protected:

    LONG                m_Refs;
    DWORD               m_SinkCookie;
    CRITICAL_SECTION    m_csListener;
    BOOL                m_fInitCsListener;
    BOOL                m_fStartedListening;
};

#endif // _MB_NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\perfcount.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfcount.h

Abstract:

    Counter Block definitions for sets of
    counters that are supported by IIS 6.

    These counter blocks contain the PERF_COUNTER_BLOCK
    object as well as an entry for each counter.

Author:

    Emily Kruglick (EmilyK)  7-Sept-2000

Revision History:

--*/


#ifndef _PERFCOUNT_H_
#define _PERFCOUNT_H_

//
// Used by the perflib to do the offsets for 
// the counters in the counter definitions.
// Used by WAS to put counters work with counters
// stored in the shared memory.
//

//
// Note:  These structures should be 8-byte aligned.
//        so if you add a counter and it throws this
//        of you will need to add another bogus DWORD
//        to make sure it stays aligned.
//

typedef struct _W3_COUNTER_BLOCK {
    PERF_COUNTER_BLOCK  PerfCounterBlock;

    ULONGLONG           BytesSent;
    ULONGLONG           BytesReceived;
    ULONGLONG           BytesTotal;

    DWORD               FilesSent;
    DWORD               FilesReceived;
    DWORD               FilesTotal;

    DWORD               CurrentAnonymous;
    DWORD               CurrentNonAnonymous;
    DWORD               TotalAnonymous;
    DWORD               TotalNonAnonymous;

    DWORD               MaxAnonymous;
    DWORD               MaxNonAnonymous;
    DWORD               CurrentConnections;
    DWORD               MaxConnections;

    DWORD               ConnectionAttempts;
    DWORD               LogonAttempts;
    DWORD               TotalOptions;
    DWORD               TotalGets;

    DWORD               TotalPosts;
    DWORD               TotalHeads;
    DWORD               TotalPuts;
    DWORD               TotalDeletes;

    DWORD               TotalTraces;
    DWORD               TotalMove;
    DWORD               TotalCopy;
    DWORD               TotalMkcol;

    DWORD               TotalPropfind;
    DWORD               TotalProppatch;
    DWORD               TotalSearch;
    DWORD               TotalLock;

    DWORD               TotalUnlock;
    DWORD               TotalOthers;
    DWORD               TotalRequests;
    DWORD               TotalCGIRequests;

    DWORD               TotalBGIRequests;
    DWORD               TotalNotFoundErrors;
    DWORD               TotalLockedErrors;
    DWORD               CurrentCGIRequests;

    DWORD               CurrentBGIRequests;
    DWORD               MaxCGIRequests;
    DWORD               MaxBGIRequests;
    DWORD               CurrentCalAuth;

    DWORD               MaxCalAuth;
    DWORD               TotalFailedCalAuth;
    DWORD               CurrentCalSsl;
    DWORD               MaxCalSsl;

    DWORD               TotalFailedCalSsl;
    DWORD               BlockedRequests;
    DWORD               AllowedRequests;
    DWORD               RejectedRequests;

    DWORD               CurrentBlockedRequests;
    DWORD               MeasuredBandwidth;
    DWORD               TotalBlockedBandwidthBytes;
    DWORD               CurrentBlockedBandwidthBytes;

    DWORD               ServiceUptime;
    DWORD               BogusAlignmentDWORD;

} W3_COUNTER_BLOCK, * PW3_COUNTER_BLOCK;

typedef struct _W3_GLOBAL_COUNTER_BLOCK {
    PERF_COUNTER_BLOCK  PerfCounterBlock;

    DWORD CurrentFilesCached;
    DWORD TotalFilesCached;
    DWORD FileCacheHits;

    ULONGLONG CurrentFileCacheMemoryUsage;
    ULONGLONG MaxFileCacheMemoryUsage;

    DWORD FileCacheMisses;
    DWORD FileCacheHitRatio;
    DWORD FileCacheFlushes;
    DWORD ActiveFlushedFiles;

    DWORD TotalFlushedFiles;
    DWORD CurrentUrisCached;
    DWORD TotalUrisCached;
    DWORD UriCacheHits;

    DWORD UriCacheMisses;
    DWORD UriCacheHitRatio;
    DWORD UriCacheFlushes;
    DWORD TotalFlushedUris;

    DWORD CurrentBlobsCached;
    DWORD TotalBlobsCached;
    DWORD BlobCacheHits;
    DWORD BlobCacheMisses;

    DWORD BlobCacheHitRatio;
    DWORD BlobCacheFlushes;
    DWORD TotalFlushedBlobs;
    DWORD UlCurrentUrisCached;

    DWORD UlTotalUrisCached;
    DWORD UlUriCacheHits; 
    DWORD UlUriCacheMisses; 
    DWORD UlUriCacheHitRatio; 

    DWORD UlUriCacheFlushes;
    DWORD UlTotalFlushedUris;

} W3_GLOBAL_COUNTER_BLOCK, * PW3_GLOBAL_COUNTER_BLOCK;

#endif  // _PERFCOUNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\regconst.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    regconst.h

Abstract:

    Common place to put registry strings and keys.

Author:

    EmilyK 4/4/2001 

Revision History:

--*/


#ifndef _REGCONST_H_
#define _REGCONST_H_

//
// Service names
//
#define WEB_ADMIN_SERVICE_NAME_A    "w3svc"

// Generic registry keys
#define REGISTRY_SERVICES_KEY_A \
    "System\\CurrentControlSet\\Services"

//
// Registry key strings for the different services parameter keys.
//
#define REGISTRY_KEY_W3SVC_PARAMETERS_A                   \
            "System\\CurrentControlSet\\Services\\W3SVC\\Parameters"
#define REGISTRY_KEY_W3SVC_PARAMETERS_W                   \
            L"System\\CurrentControlSet\\Services\\W3SVC\\Parameters"

#define REGISTRY_KEY_IISADMIN_W                   \
            L"System\\CurrentControlSet\\Services\\IISAdmin"

#define REGISTRY_KEY_IISADMIN_PARAMETERS_W                   \
            L"System\\CurrentControlSet\\Services\\IISAdmin\\Parameters"

#define REGISTRY_KEY_INETINFO_PARAMETERS_A                  \
            "System\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define REGISTRY_KEY_INETINFO_PARAMETERS_W                  \
            L"System\\CurrentControlSet\\Services\\InetInfo\\Parameters"

#define REGISTRY_KEY_HTTPFILTER_PARAMETERS_W                   \
            L"System\\CurrentControlSet\\Services\\HTTPFilter\\Parameters"

//
// Registry key strings for the different services performance keys.
//
#define REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_A \
            "System\\CurrentControlSet\\Services\\W3SVC\\Performance"
#define REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_W \
            L"System\\CurrentControlSet\\Services\\W3SVC\\Performance"

//
// W3SVC Performance values 
//
#define REGISTRY_VALUE_W3SVC_PERF_FRESH_TIME_FOR_COUNTERS_W   \
            L"FreshTimeForCounters"

#define REGISTRY_VALUE_W3SVC_PERF_CHECK_COUNTERS_EVERY_N_MS_W   \
            L"CheckCountersEveryNMiliseconds"

#define REGISTRY_VALUE_W3SVC_PERF_NUM_TIMES_TO_CHECK_COUNTERS_W   \
            L"NumberOfTimesToCheckCounters"

#define REGISTRY_VALUE_W3SVC_PERF_EVENT_LOG_DELAY_OVERRIDE_W   \
            L"PerfCounterLoggingDelaySeconds"

//
// IISAdmin values
//
#define REGISTRY_VALUE_IISADMIN_W3CORE_LAUNCH_EVENT_W   \
            L"InetinfoW3CoreLaunchEventName"


//
// IISAdmin Parameter values
//
#define REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_SHUTDOWN_AFTER_INETINFO_CRASH_W   \
            L"MillisecondsToWaitForShutdownAfterCrash"

#define REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_RESTART_AFTER_INETINFO_CRASH_W   \
            L"MillisecondsToWaitForInetinfoRestartAfterCrash"

#define REGISTRY_VALUE_IISADMIN_MS_CHECK_INTERVAL_FOR_INETINFO_TO_RESTART_W   \
            L"MillisecondsCheckIntervalForInetinfoToRestart"

//
// Generic Service Values
//
#define REGISTRY_VALUE_IISSERVICE_DLL_PATH_NAME_A   \
            "IISDllPath"

//
// Inetinfo Parameter values
//

#define REGISTRY_VALUE_INETINFO_DISPATCH_ENTRIES_A   \
            "DispatchEntries"

#define REGISTRY_VALUE_INETINFO_PRELOAD_DLLS_A   \
            "PreloadDlls"

//
// W3SVC Parameter values
//

#define REGISTRY_VALUE_W3SVC_PERF_COUNT_DISABLED_W         \
            L"PerformanceCountersDisabled"

#define REGISTRY_VALUE_W3SVC_BREAK_ON_STARTUP_W           \
            L"BreakOnStartup"

#define REGISTRY_VALUE_W3SVC_BREAK_ON_FAILURE_CAUSING_SHUTDOWN_W \
            L"BreakOnFailureCausingShutdown"

#define REGISTRY_VALUE_W3SVC_BREAK_ON_WP_ERROR \
            L"BreakOnWPError"

#define REGISTRY_VALUE_W3SVC_STARTUP_WAIT_HINT            \
            L"StartupWaitHintInMilliseconds"

#define REGISTRY_VALUE_W3SVC_ALWAYS_LOG_EVENTS_W          \
            L"AlwaysLogEvents"

#define REGISTRY_VALUE_W3SVC_ALLOW_WMS_SPEW               \
            L"AllowWMSSpew"

#define REGISTRY_VALUE_INETINFO_W3WP_IPM_NAME_W   \
            L"IIS5IsolationModeIpmName"

#define REGISTRY_VALUE_W3SVC_USE_SHARED_WP_DESKTOP_W   \
            L"UseSharedWPDesktop"

//
// HTTPFilter Parameter values
//

#define REGISTRY_VALUE_HTTPFILTER_STARTUP_WAIT_HINT            \
            L"StartupWaitHintInMilliseconds"
            
#define REGISTRY_VALUE_HTTPFILTER_STOP_WAIT_HINT            \
            L"StopWaitHintInMilliseconds"

#define REGISTRY_VALUE_CURRENT_MODE                        \
            L"CurrentMode"

#endif  // _REGCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\secfcns_all.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    secfcns.hxx

        Declarations for security helper functions.
*/



#ifndef _SECFCNSALL_H_
#define _SECFCNSALL_H_

#include <secfcns.h>

class dllexp CSecurityDispenser
{
public:

    CSecurityDispenser();
    ~CSecurityDispenser();

    DWORD GetSID(WELL_KNOWN_SID_TYPE sidId, PSID* ppSid);  
    DWORD GetIisWpgSID(PSID* ppSid);

    DWORD AdjustTokenForAdministrators(HANDLE hTokenToAdjust);

private:

    // Commonly used SIDs
    PSID m_pLocalSystemSID;
    PSID m_pLocalServiceSID;
    PSID m_pNetworkServiceSID;
    PSID m_pAdministratorsSID;

    BOOL m_fWpgSidSet;
    BUFFER m_buffWpgSid;

};
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\secfcns.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    secfcns.hxx

        Declarations for security helper functions.
*/



#ifndef _SECFCNS_H_
#define _SECFCNS_H_

#include <Accctrl.h>

#ifndef dllexp
# define dllexp     __declspec( dllexport)
#endif // dllexp

class STRU;

DWORD 
AllocateAndCreateWellKnownSid( 
    WELL_KNOWN_SID_TYPE SidType,
    PSID* ppSid
    );

VOID 
FreeWellKnownSid( 
    PSID* ppSid
    );

DWORD 
AllocateAndCreateWellKnownAcl( 
    WELL_KNOWN_SID_TYPE SidType,
    BOOL  fAccessAllowedAcl,
    PACL* ppAcl,
    DWORD* pcbAcl,
    ACCESS_MASK AccessMask
    );

VOID 
FreeWellKnownAcl( 
    PACL* ppAcl
    );

VOID 
SetExplicitAccessSettings( EXPLICIT_ACCESS* pea,
                           DWORD            dwAccessPermissions,
                           ACCESS_MODE      AccessMode,
                           PSID             pSID
    );

DWORD GetSecurityAttributesForHandle(HANDLE hToken, PSECURITY_ATTRIBUTES* ppSa);
VOID FreeSecurityAttributes(PSECURITY_ATTRIBUTES pSa);

DWORD GenerateNameWithGUID(LPCWSTR pwszPrefix, STRU* pStr);
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\sharelok.h ===
#ifndef __SHARELOCK_H__
#define __SHARELOCK_H__

//////////////////////////////////////////////////////////////////////
//
//   The standard include files.
//
//   The standard include files setup a consistent environment
//   for all of the modules in a program.  The structure of each
//   header file is as follows:
//      1. Standard include files.
//      2. Include files for inherited classes.
//      3. Constants exported from the class.
//      4. Data structures exported from the class.
//      5. Class specification.
//      6. Inline functions.
//   Sections that are not required are omitted.
//
//////////////////////////////////////////////////////////////////////

// #include "Global.h"
// #include "NewEx.h"
// #include "Standard.h"
// #include "System.h"

#include <irtlmisc.h>

typedef int SBIT32;

//////////////////////////////////////////////////////////////////////
//
//   Sharelock and Semaphore locking.
//
//   This class provides a very conservative locking scheme.
//   The assumption behind the code is that locks will be
//   held for a very short time.  A lock can be obtained in
//   either exclusive mode or shared mode.  If the lock is not
//   available the caller waits by spinning or if that fails
//   by sleeping.
//
//////////////////////////////////////////////////////////////////////

class IRTL_DLLEXP CSharelock
{ 
	private:

		// internally used constants

		enum Internal
		{
			//   The Windows NT kernel requires a maximum wakeup count when
			//   creating a semaphore.
			m_MaxShareLockUsers      = 256
		};

        //
        //   Private data.
        //
        volatile LONG                 m_lExclusive;
        volatile LONG                 m_lTotalUsers;

		SBIT32                        m_lMaxSpins;
		SBIT32                        m_lMaxUsers;
        HANDLE                        m_hSemaphore;
        volatile LONG                 m_lWaiting;

#ifdef _DEBUG

        //
        //   Counters for debugging builds.
        //
        volatile LONG                 m_lTotalExclusiveLocks;
        volatile LONG                 m_lTotalShareLocks;
        volatile LONG                 m_lTotalSleeps;
        volatile LONG                 m_lTotalSpins;
        volatile LONG                 m_lTotalTimeouts;
        volatile LONG                 m_lTotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        CSharelock( SBIT32 lNewMaxSpins = 4096, SBIT32 lNewMaxUsers = 256 );

        inline SBIT32 ActiveUsers( void ) { return (SBIT32) m_lTotalUsers; }

        inline void ChangeExclusiveLockToSharedLock( void );

        inline BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimShareLock( SBIT32 lSleep = INFINITE );

        inline void ReleaseExclusiveLock( void );

        inline void ReleaseShareLock( void );

        BOOLEAN UpdateMaxSpins( SBIT32 lNewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 lNewMaxUsers );

        ~CSharelock( void );


	private:
        //
        //   Private functions.
        //
        BOOLEAN SleepWaitingForLock( SBIT32 lSleep );

        BOOLEAN WaitForExclusiveLock( SBIT32 lSleep );

        BOOLEAN WaitForShareLock( SBIT32 lSleep );

        void WakeAllSleepers( void );      

    private:
        //
        //   Disabled operations.
        //
        CSharelock( const CSharelock & Copy );

        void operator=( const CSharelock & Copy );
};

/********************************************************************/
/*                                                                  */
/*   Change an exclusive lock to a shread lock.                     */
/*                                                                  */
/*   Downgrade the existing exclusive lock to a shared lock.        */
/*                                                                  */
/********************************************************************/

inline void CSharelock::ChangeExclusiveLockToSharedLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );
    
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif
}

/********************************************************************/
/*                                                                  */
/*   Change a shared lock to an exclusive lock.                     */
/*                                                                  */
/*   Upgrade the existing shared lock to an exclusive lock.         */
/*                                                                  */
/********************************************************************/

inline BOOLEAN CSharelock::ChangeSharedLockToExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
    
	if ( m_lTotalUsers != 1 )
    {
		if ( ! WaitForExclusiveLock( lSleep ) )
        { return FALSE; }
    }
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//
//   Claim an exclusive lock.
//
//   Claim an exclusive lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( m_lTotalUsers != 1 )
	{
		if ( ! WaitForExclusiveLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Claim a shared lock.
//
//   Claim a shared lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimShareLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( (m_lExclusive > 0) || (m_lTotalUsers > m_lMaxUsers) )
	{
		if ( ! WaitForShareLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Release an exclusive lock.
//
//   Release an exclusive lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseExclusiveLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Release a shared lock.
//
//   Release a shared lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseShareLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

#endif // __SHARELOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\useracl.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2000                **/
/**********************************************************************/

/*
    useracl.hxx

        Declarations for some functions to add permissions to windowstations/
        desktops
*/

#ifndef _USERACL_H_
#define _USERACL_H_

HRESULT AlterDesktopForUser(
    HANDLE hToken
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

LONG
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Domain Name System (DNS) Server

    Wrap-proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#ifndef _TIMER_INCLUDED_
#define _TIMER_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

BOOL
InitializeSecondsTimer(
    VOID
    );


VOID
TerminateSecondsTimer(
    VOID
    );

DWORD
GetCurrentTimeInSeconds(
    VOID
    );


__int64
GetCurrentTimeInMilliseconds(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif  // _TIMER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\wasdbgut.h ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

// DEBUG_WEB_ADMIN_SERVICE turns on all the spew.  While 
// the rest of these can be used if you want to turn on 
// just one section of the spew.  This was done this way 
// because WEB_ADMIN_SERVICE was the original flag and the
// rest were broken out later in an attempt to quite the spew.
#define DEBUG_WEB_ADMIN_SERVICE             0x00010000
#define DEBUG_WEB_ADMIN_SERVICE_GENERAL     0x00030000  // Use 0x00020000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_DUMP        0x00050000  // Use 0x00040000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_REFCOUNT    0x00090000  // Use 0x00080000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_TIMER_QUEUE 0x00110000  // Use 0x00100000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_IPM         0x00210000  // Use 0x00200000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_WP          0x00410000  // Use 0x00400000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_LOW_MEM     0x00810000  // Use 0x00800000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_LOGGING     0x01010000  // Use 0x01000000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_PERFCOUNT   0x02000000  // Use 0x02000000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_CONTROL     0x04010000  // Use 0x04000000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_QOS         0x08000000  // Use 0x08000000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_WMS         0x10000000  // Use 0x10000000 to turn on only

// end_user_modifiable


// begin_user_modifiable

//
// Local debugging definitions
//


// check if we are on the main worker thread
#define ON_MAIN_WORKER_THREAD   \
    ( GetCurrentThreadId() == GetWebAdminService()->GetMainWorkerThreadId() )

// check if we are on the main worker thread
#define ON_CONFIG_WORKER_THREAD   \
    ( GetCurrentThreadId() == GetWebAdminService()->GetConfigWorkerThreadId() )

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\inc\wpif.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    wpif.h

Abstract:

    Defines aspects of the interface to the worker process, needed by the
    web admin service. 

Author:

    Seth Pollack (sethp)        16-Mar-1999

Revision History:

--*/


#ifndef _WPIF_H_
#define _WPIF_H_



//
// The name of the worker process executable.
//

#define WORKER_PROCESS_EXE_NAME L"w3wp.exe"

//
// Event name for signalling the startup of w3core in inetinfo.
//
#define WEB_ADMIN_SERVICE_START_EVENT_W L"Global\\W3SVCStartW3WP-"

//
// The name of the SSL filter channel
//

#define SSL_FILTER_CHANNEL_NAME L"SSLFilterChannel"

//
// Process exit codes for the worker process.
//

// the WAS killed the worker process
#define KILLED_WORKER_PROCESS_EXIT_CODE 0xFFFFFFFD

// the worker process exited ok
#define CLEAN_WORKER_PROCESS_EXIT_CODE  0xFFFFFFFE

// the worker process exited due to a fatal error
#define ERROR_WORKER_PROCESS_EXIT_CODE  0xFFFFFFFF



#endif  // _WPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\prfshmem\perf_sm.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_sm.cxx

Abstract:

    This file contains three classes.  They control
    all aspects of the shared memory that allows counters
    to be transfered from WAS to the performance library.

Author:

    Emily Kruglick (EmilyK)       6-Sept-2000

Revision History:

--*/



#include "iis.h"
#include "winperf.h"
#include "perfcount.h"
#include "iisdef.h"
#include "wasdbgut.h"
#include "perf_sm.h"
#include <Aclapi.h>
#include <limits.h>
#include <buffer.hxx>
#include <secfcns.h>
#include "regconst.h"

// 
// typedefs, structs, enums ...
//

//
// Used to define information about a 
// counter set.  Used below to define
// all the counter sets.
//
typedef struct _COUNTER_SET_DEFINE
{
    LPCWSTR             pFilePrefix;
    DWORD               SizeOfCounterData;
    BOOL                DefineIncludesInstanceData;
} COUNTER_SET_DEFINE;


//
// common #defines.
// 


//
// Issue-09/10/2000-EmilyK  Counter Control Block Name
// Need to make this a "safe" name.  It will be handled
// when I work on securing the shared memory.
//
#define IISCounterControlBlock L"Global\\IISCounterControlBlock-46382a23-095e-4559-8d63-6fdeaf552c23"


//
// Number of tick counts that must have passed to make the data old.
//------------------------------------------------------------------
// You can override this value by senting "FreshTimeForCounters"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
// This value is milliseconds.
//
#define IIS_DEFAULT_MILLISECONDS_COUNTERS_ARE_FRESH 15000  // 15 seconds in milliseconds

//
// How long to Sleep before each check for new counters
//------------------------------------------------------------------
// You can override this value by senting "CheckCountersEveryNMiliseconds"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
// This value is milliseconds.
//
#define IIS_DEFAULT_MILLISECONDS_SLEEP_BEFORE_CHECKING_FOR_NEW_COUNTERS 250 // 1/4 second

//
// Number of times to wait for the time between tickcounts.
//------------------------------------------------------------------
// You can override this value by senting "NumberOfTimesToCheckCounters"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
//
#define IIS_MAX_NUMBER_TIMES_TO_CHECK_IF_COUNTERS_ARE_FRESH 4 

//
// Global Variables
//

//
// Used as a generic instance definition that can be copied
// into the shared memory and altered to represent a specific instance.
//
PERF_INSTANCE_DEFINITION g_PerfInstance = 
{ sizeof(PERF_INSTANCE_DEFINITION) + MAX_INSTANCE_NAME * sizeof(WCHAR)
, 0
, 0
, PERF_NO_UNIQUE_ID
, sizeof(PERF_INSTANCE_DEFINITION)
, 0  // Needs to be reset when initialized.
};


//
// Order must match the COUNTER_SET_ENUM enum in perf_sm.h
// Counter names must be less than ~80 characters.  
// (Based roughly on MAX_FILE_NAME)
//
COUNTER_SET_DEFINE g_CounterSetInfo[] =
{ 
      {
          L"Global\\IISSitesCounters-",        // prefix name of shared memory file
          sizeof(W3_COUNTER_BLOCK),   // size of the counters per display
          TRUE                        // Defines instance data
      },
      {
          L"Global\\IISCacheCounters-",                                              
          sizeof(W3_GLOBAL_COUNTER_BLOCK),
          FALSE
      }
};

//
// Helper function declarations
//

DWORD 
CreateMemoryFile (
     IN LPCWSTR pFileName,
     IN DWORD SizeOfData,
     OUT HANDLE* phFile,
     OUT LPVOID* ppFile
     );

DWORD
OpenMemoryFile (
     IN LPCWSTR pFileName,
     OUT HANDLE* phFile,
     OUT LPVOID* ppFile
     );

//
// Public PERF_SM_MANAGER functions.
// 

/***************************************************************************++

Routine Description:

    PERF_SM_MANAGER constructor

Arguments:

    None

Return Value:

    None

--***************************************************************************/
PERF_SM_MANAGER::PERF_SM_MANAGER(
    )
{
    m_pManagerMemory = NULL;
    m_hManagerMemory = NULL;

    m_WASProcessHandle = NULL;

    m_pSMObjects = NULL;

    m_hIISSignalCounterRefresh = NULL;

    m_IIS_MillisecondsCountersAreFresh = 
            IIS_DEFAULT_MILLISECONDS_COUNTERS_ARE_FRESH;

    m_IIS_MaxNumberTimesToCheckCountersOnRefresh = 
            IIS_MAX_NUMBER_TIMES_TO_CHECK_IF_COUNTERS_ARE_FRESH;

    m_IIS_MillisecondsToSleepBeforeCheckingForRefresh = 
            IIS_DEFAULT_MILLISECONDS_SLEEP_BEFORE_CHECKING_FOR_NEW_COUNTERS;

    m_Initialized = FALSE;

    m_Signature = PERF_SM_MANAGER_SIGNATURE;
}

/***************************************************************************++

Routine Description:

    PERF_SM_MANAGER destructor

Arguments:

    None

Return Value:

    None

--***************************************************************************/
PERF_SM_MANAGER::~PERF_SM_MANAGER(
    )
{
    DBG_ASSERT( m_Signature == PERF_SM_MANAGER_SIGNATURE );

    m_Signature = PERF_SM_MANAGER_SIGNATURE_FREED;

    if ( m_hIISSignalCounterRefresh )
    {
        CloseHandle ( m_hIISSignalCounterRefresh );
        m_hIISSignalCounterRefresh = NULL;
    }

    if ( m_pSMObjects ) 
    {
        if ( HasWriteAccess() )
        {
            delete[] (PERF_SM_MANAGER::PERF_SM_WRITER*) m_pSMObjects;
        }
        else
        {
            delete[] (PERF_SM_MANAGER::PERF_SM_READER*) m_pSMObjects;
        }

        m_pSMObjects = NULL;
    }


    if ( m_pManagerMemory ) 
    {
        UnmapViewOfFile ( (LPVOID) m_pManagerMemory );
        m_pManagerMemory = NULL;
    }

    if ( m_hManagerMemory ) 
    {
        CloseHandle ( m_hManagerMemory );
        m_hManagerMemory = NULL;
    }

            
    if ( m_WASProcessHandle != NULL )
    {
        CloseHandle ( m_WASProcessHandle );
        m_WASProcessHandle = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Initializer for the manager.  This routine will create the control
    manager shared memory.  If the shared memory all ready exists then it will
    error.  
    
    Note:  We choose to error if we can not create the shared memory for 
           perf counters.  Instead of just hooking up to existent memory.  The
           perf library will let go of the memory when the WAS process dies
           so it will not be the perf library holding the memory open.  

           If it is not the perf library holding open the memory then it is
           an illegal process.  They will be able to provide fake counters back
           to the perf library, however they will need to be able to fake out
           the exact structure that we expect instead of just changing
           a value.  They can also just prevent perf counters from running by 
           holding open the memory.

           This should go through Security Review.

Arguments:

    BOOL WriteAccess  -  Tells if we expect to be using this class
                         as a reader or writer of memory.

Return Value:

    DWORD             -  Win32 Error Code

    Note:  The perf library expects a WIN32 Error code so functions being 
           used from the perf library will return DWORDs instead of hresults.

--***************************************************************************/
DWORD
PERF_SM_MANAGER::Initialize(
        BOOL WriteAccess
        )
{
    DBG_ASSERT ( !m_Initialized && !m_hManagerMemory && !m_pManagerMemory );

    DWORD dwErr = ERROR_SUCCESS;

    //
    // Remember the WriteAccess we are initialized to.
    // This will be used to make sure we don't try and 
    // hook a Writer to a Reader Controller and vica versa.
    //
    m_WriteAccess = WriteAccess;

    if ( m_WriteAccess )
    {
        // 
        // Since we are going to own the memory we need to create
        // it and error if we can not create it.
        // 
        // See note in function comments.
        //
        // The memory should be the correct size to contain 
        // one control block for every counter set we know of.
        //
        dwErr = CreateMemoryFile ( IISCounterControlBlock
                           , sizeof(MANAGER_BLOCK)
                           , &m_hManagerMemory
                           , (LPVOID*) &m_pManagerMemory );

        if ( dwErr != ERROR_SUCCESS )
        {
           
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not create the perf counters control block memory\n"
                ));

            goto exit;
        }

        dwErr = CreateEventForSignallingGathering();
        if ( dwErr != ERROR_SUCCESS )
        {
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not create the perf counters signalling event\n"
                ));

            goto exit;
        }

        // 
        // set the process id for the managing process into the memory.
        // this will let the clients monitor the managing process and
        // shutdown if need be.
        //

        m_pManagerMemory->WASProcessId = GetCurrentProcessId();

        //
        // For each counter, establish the default settings.
        //
        for (DWORD i = 0; i < (MAX_COUNTER_SET_DEFINES); i++)
        {
            //
            // Note Version 0 is a warning sign that
            // the memory is not ready for use.
            //
            m_pManagerMemory->ControlArray[i].Version = 0;
            m_pManagerMemory->ControlArray[i].ActivePageIsA = TRUE;
            m_pManagerMemory->ControlArray[i].wszSharedMemName1[0] = L'\0';
            m_pManagerMemory->ControlArray[i].wszSharedMemName2[0] = L'\0';
        }

        DBG_ASSERT ( m_pSMObjects == NULL );

        //
        // Allocate enough new objects to support the different
        // counter sets.  This is done dynamically because we don't
        // know at compile time if this will be a reader or a writer class.
        //
        m_pSMObjects = new PERF_SM_WRITER[MAX_COUNTER_SET_DEFINES];
        if ( ! m_pSMObjects )
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto exit;
        }

        //
        // Lastly set the appropriate initialized code into 
        // the shared memory, so the reader can tell that the 
        // memory has been completely initialized.
        //
        m_pManagerMemory->InitializedCode = PERF_COUNTER_INITIALIZED_CODE;


    }
    else
    {
        //
        // Check the registry to see if we need to reset the counter
        // waiting values.
        //
        ResetWaitFreshCounterValues();

        //
        // We are not a writer, we are a reader so 
        // do not create the memory, just open it.
        //
        dwErr = OpenMemoryFile ( IISCounterControlBlock
                           , &m_hManagerMemory
                           , (LPVOID*) &m_pManagerMemory );
        if ( dwErr != ERROR_SUCCESS )
        {

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not open the perf counters control block memory\n"
                ));

            goto exit;
        }

        //
        // Validate that the initialized code is correct, so we know
        // that this memory has been created for us by the writer.
        //
        if ( m_pManagerMemory->InitializedCode 
                                != PERF_COUNTER_INITIALIZED_CODE )
        {
            //
            // If the perf counter data is not initialized then we do 
            // not want to hold on to this file.
            //

            dwErr = ERROR_NOT_READY;
            goto exit;
        }

        DBG_ASSERT ( m_pSMObjects == NULL );

        //
        // Create enough reader objects to represent the different types
        // of counters that we are supporting.
        //
        m_pSMObjects = new PERF_SM_READER[MAX_COUNTER_SET_DEFINES];
        if ( ! m_pSMObjects )
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto exit;
        }

        if ( wcsncmp( m_pManagerMemory->wszSignalEventName, 
                      COUNTER_EVENT_PREFIX_W,  
                      COUNTER_EVENT_PREFIX_CCH_LENGTH-1 ) != 0 )
        {
            dwErr = ERROR_NOT_READY;
            goto exit;
        }

        //
        // Also open the event that will be used to signal WAS when 
        // counters need to be refreshed.
        //
        m_hIISSignalCounterRefresh = OpenEvent(EVENT_MODIFY_STATE, 
                                               FALSE, 
                                               m_pManagerMemory->wszSignalEventName);
        if ( m_hIISSignalCounterRefresh == NULL )
        {
            dwErr = GetLastError();
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not open an event to request counters from WAS\n"
                ));

            goto exit;
        }

        //
        // Grab hold of the WAS process as well, so we will know
        // when WAS goes away.
        //
        m_WASProcessHandle = OpenProcess ( SYNCHRONIZE,   // security
                                           FALSE,         // not inheritable
                                           m_pManagerMemory->WASProcessId);
        if ( m_WASProcessHandle == NULL )
        {
            dwErr = GetLastError();
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not open the WAS Process to wait on it\n"
                ));
            dwErr = ERROR_NOT_READY;
            goto exit;
        }

    }

exit:

    //
    // Assuming that we made it through here without error then we 
    // can mark this object as initialized.  Otherwise the destructor
    // for this object will handle the cleanup.
    //
    if ( dwErr == ERROR_SUCCESS )
    {
        m_Initialized = TRUE;
    }

    return dwErr;
}

/***************************************************************************++

Routine Description:

    Uninitalize the control block's memory and set all counter set info
    to be uninitalized.  This will let the reader know to drop it's current
    memory pages because WAS does not want them held any more.

    Note:  Only a writer can call this function.

Arguments:

    None

Return Value:

    None.

--***************************************************************************/
VOID
PERF_SM_MANAGER::StopPublishing(
    )
{
    DBG_ASSERT( HasWriteAccess() );

    DBG_ASSERT ( m_pManagerMemory );

    //
    // Mark the managing memory as ready for release.
    //
    m_pManagerMemory->InitializedCode = PERF_COUNTER_UN_INITIALIZED_CODE;

    //
    // Mark all sets of counters as uninitalized.
    //
    for ( DWORD i = 0; i < MAX_COUNTER_SET_DEFINES; i++)
    {
        SetActiveInformation((COUNTER_SET_ENUM) i, 
                                                0, 
                                                TRUE,
                                                L"\0",
                                                L"\0" );
    }
}

/***************************************************************************++

Routine Description:

    GetActiveInformation returns the information it holds about a
    specific counter set.  It can be used by the Reader or Writer.

Arguments:

    COUNTER_SET_ENUM CounterSetId - Identifies the counter set 
    DWORD*           pVersion     - Returns the current version for the counter set
    CHAR*            pActivePage  - Returns the current page identifier
                                    for the counter set.
    STRU*            pstrNameOfPageA - Name of shared memory to connect to.
    STRU*            pstrNameOfPageB - Name of shared memory to connect to.

Return Value:

    None.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::GetActiveInformation(
        IN COUNTER_SET_ENUM  CounterSetId,
        OUT DWORD*           pVersion,
        OUT BOOL*            pActivePageIsA,
        OUT STRU*            pstrNameOfPageA,
        OUT STRU*            pstrNameOfPageB
        )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( m_Initialized );

    DBG_ASSERT( m_pManagerMemory );
    DBG_ASSERT( pstrNameOfPageA );
    DBG_ASSERT( pstrNameOfPageB );

    pstrNameOfPageA->Reset();
    pstrNameOfPageB->Reset();

    *pVersion = m_pManagerMemory->ControlArray[CounterSetId].Version;
    *pActivePageIsA = m_pManagerMemory->ControlArray[CounterSetId].ActivePageIsA;

    hr = pstrNameOfPageA->Copy( m_pManagerMemory->ControlArray[CounterSetId].wszSharedMemName1 );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying in the shared memory name failed, ignoring we will try to open an non-existent memory file\n"
            ));
    }

    hr = pstrNameOfPageB->Copy( m_pManagerMemory->ControlArray[CounterSetId].wszSharedMemName2 );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying in the shared memory name failed, ignoring we will try to open an non-existent memory file\n"
            ));
    }
}


/***************************************************************************++

Routine Description:

    SetActiveInformation will record the information passed to it.  Once
    this function has been called the information will be picked up by the 
    reader and it will start using the new memory.

    Note:  Only a writer can call this function.

Arguments:

    COUNTER_SET_ENUM CounterSetId - Identifies the counter set 
    DWORD            Version      - The current version.
    CHAR             ActivePage   - The current page identifier.
    WCHAR*           pNameA         - Name of the Active Memory to copy in.
    WCHAR*           pNameB         - Name of the Active Memory to copy in.

Return Value:

    None.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::SetActiveInformation(
        IN COUNTER_SET_ENUM CounterSetId,
        IN DWORD           Version,
        IN BOOL            ActivePageIsA,
        IN LPWSTR          pNameA,
        IN LPWSTR          pNameB
        )
{
    DBG_ASSERT( m_Initialized );

    DBG_ASSERT( HasWriteAccess() );
    DBG_ASSERT( pNameA != NULL );
    DBG_ASSERT( pNameB != NULL );

    if ( HasWriteAccess() )
    {
        DBG_ASSERT( m_pManagerMemory );

        if (  m_pManagerMemory->ControlArray[CounterSetId].Version != Version )
        {
            m_pManagerMemory->ControlArray[CounterSetId].Version = Version;

            wcsncpy( m_pManagerMemory->ControlArray[CounterSetId].wszSharedMemName1, 
                     pNameA,
                     MAX_FILE_NAME - 1 );

            m_pManagerMemory->ControlArray[CounterSetId].wszSharedMemName1[MAX_FILE_NAME-1] = L'\0';

            wcsncpy( m_pManagerMemory->ControlArray[CounterSetId].wszSharedMemName2, 
                     pNameB,
                     MAX_FILE_NAME - 1 );

            m_pManagerMemory->ControlArray[CounterSetId].wszSharedMemName2[MAX_FILE_NAME-1] = L'\0';
        }

        m_pManagerMemory->ControlArray[CounterSetId].ActivePageIsA = ActivePageIsA;
    }
}

/***************************************************************************++

Routine Description:

    Creates a new counter set by letting the appropriate counter set
    initialize it's self.

Arguments:

    IN COUNTER_SET_ENUM CounterSetId - counter set to work with

Return Value:

    DWORD.

--***************************************************************************/
DWORD
PERF_SM_MANAGER::CreateNewCounterSet(
    IN COUNTER_SET_ENUM CounterSetId
    )
{
    DBG_ASSERT ( m_pSMObjects );

    if ( HasWriteAccess() )
    {
        return ( reinterpret_cast<PERF_SM_WRITER*>(m_pSMObjects) )
                                [CounterSetId].Initialize(this, CounterSetId);
    }
    else
    {
        return (reinterpret_cast<PERF_SM_READER*>( m_pSMObjects ) )
                                [CounterSetId].Initialize(this, CounterSetId);
    }
    
}

/***************************************************************************++

Routine Description:

    Alters the shared memory chunk if needed

Arguments:

    IN COUNTER_SET_ENUM CounterSetId - counter set to work with
    IN DWORD NumInstances - number of instance expected to be published

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
PERF_SM_MANAGER::ReallocSharedMemIfNeccessary(
    IN COUNTER_SET_ENUM CounterSetId,
    IN DWORD NumInstances
        )
{
    DBG_ASSERT ( HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    return (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects ))
                     [CounterSetId].ReallocSharedMemIfNeccessary(NumInstances);
}

/***************************************************************************++

Routine Description:

    Copies counter information into the shared memory.

Arguments:

    IN COUNTER_SET_ENUM     CounterSetId - counter set working with
    IN LPCWSTR              InstanceName - instance name 
    IN ULONG                MemoryOffset - the memory offset for this instance
    IN LPVOID               pCounters    - any counter values to be published
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc - description of the publishing counters
    IN DWORD                cDisplayPropDesc - count of the publishing counters
    IN BOOL                 StructChanged    - whether the memory has changed
    OUT ULONG*              pNewMemoryOffset - the next instances memory offset

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::CopyInstanceInformation(
    IN COUNTER_SET_ENUM CounterSetId,
    IN LPCWSTR              InstanceName,
    IN ULONG                MemoryOffset,
    IN LPVOID               pCounters,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc,
    IN BOOL                 StructChanged,
    OUT ULONG*              pNewMemoryOffset
    )
{
    DBG_ASSERT ( HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))
                                    [CounterSetId].CopyInstanceInformation(
                                                        InstanceName,
                                                        MemoryOffset,
                                                        pCounters,
                                                        pDisplayPropDesc,
                                                        cDisplayPropDesc,
                                                        StructChanged,
                                                        pNewMemoryOffset);
}

/***************************************************************************++

Routine Description:

    Sets the update flag to let the system know to copy over the meta
    data to the other sheet of shared memory, when neccessary.

Arguments:

    IN BOOL UpdateNeeded - tells if we should turn it on or off.

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::SetUpdateNeeded(
    IN COUNTER_SET_ENUM CounterSetId,
    IN BOOL UpdateNeeded
    )
{
    DBG_ASSERT ( HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))
                                    [CounterSetId].SetUpdateNeeded(
                                                        UpdateNeeded );

}

/***************************************************************************++

Routine Description:

    Updates the control block information so the readers will now pick up
    the counter information from the newly published page.

Arguments:

    None

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::PublishCounters(
    )
{
    DBG_ASSERT ( HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))[SITE_COUNTER_SET].PublishCounterPage();

    (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))[GLOBAL_COUNTER_SET].PublishCounterPage();

    //
    // Now save the system tick count so we know when the data
    // was updated.  Since we collected the counters every five minutes
    // regardless of requests, this tick count will always be in the 
    // current 49.7 days, so we don't need to worry about data that is
    // older than a tick count could relate.
    //
    m_pManagerMemory->LastUpdatedTickCount = GetTickCount();

    IF_DEBUG ( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Updated last update time to = %d \n",
            m_pManagerMemory->LastUpdatedTickCount
            ));
    }

}

/***************************************************************************++

Routine Description:

    Returns the tick count as it was on the last update.

Arguments:

    None

Return Value:

    DWORD.

--***************************************************************************/
DWORD
PERF_SM_MANAGER::GetLastUpdatedTickCount(
    )
{
    DBG_ASSERT ( !HasWriteAccess() );

    DBG_ASSERT ( m_pManagerMemory );

    return m_pManagerMemory->LastUpdatedTickCount;
}


/***************************************************************************++

Routine Description:

    Sets the amount of time the W3SVC has been running into the 
    _Total instances service time.

Arguments:

    IN DWORD  ServiceUptime  - Number of seconds the w3svc has been running.

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::UpdateTotalServiceTime(
    IN DWORD  ServiceUptime
    )
{
    DBG_ASSERT ( HasWriteAccess() );
    DBG_ASSERT ( m_pSMObjects );

    ( reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))
                     [SITE_COUNTER_SET].UpdateTotalServiceTime(ServiceUptime);
}

/***************************************************************************++

Routine Description:

    Retrieves the actual counter information from the reader.

Arguments:

    IN COUNTER_SET_ENUM CounterSetId - which counter set were interested in.
    OUT COUNTER_GLOBAL_STRUCT** ppGlobal - returns the counter set's global info
    OUT LPVOID* ppData - returns the actual counter blob.

Return Value:

    DWORD.

--***************************************************************************/
DWORD 
PERF_SM_MANAGER::GetCounterInfo(
    IN COUNTER_SET_ENUM CounterSetId,
    OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
    OUT LPVOID* ppData
    )
{
    DBG_ASSERT ( ! HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    return (reinterpret_cast<PERF_SM_READER*>( m_pSMObjects))
                              [CounterSetId].GetCounterInfo(ppGlobal, ppData);
}

/***************************************************************************++

Routine Description:

   Function will check the last update of the counters and if needed
   will ask WAS to gather counters before we provide the counters to
   the public.  If this is the case then this function will block for a 
   period of time, until the counters are updated.

Arguments:

    None.

Return Value:

    BOOL - true if we have fresh counters, 
           false if we had to go with stale counters.

--***************************************************************************/
BOOL 
PERF_SM_MANAGER::EvaluateIfCountersAreFresh(
    )
{
    DWORD LastUpdatedTickCount = GetLastUpdatedTickCount();
    DWORD CurrentTickCount = GetTickCount();
    DWORD NumberOfTickCountsPassed = 0;

    if ( CurrentTickCount < LastUpdatedTickCount )
    {
        // We know that we have wrapped around between the tick counts.
        // We must calculate the change appropriately.

        NumberOfTickCountsPassed = ULONG_MAX - LastUpdatedTickCount + CurrentTickCount;
    }
    else
    {
        NumberOfTickCountsPassed = CurrentTickCount - LastUpdatedTickCount;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Evaluating if we need to refresh counters.  \n"
            "NumberOfTickCountsPassed = %d; \n"
            "LastUpdatedTickCount starts = %d \n"
            "MillisecondsCountersAreFresh = %d; \n"
            "MaxNumberTimesToCheckCountersOnRefresh = %d \n"
            "MillisecondsToSleepBeforeCheckingForRefresh = %d \n\n",
            NumberOfTickCountsPassed,
            LastUpdatedTickCount,
            m_IIS_MillisecondsCountersAreFresh,
            m_IIS_MaxNumberTimesToCheckCountersOnRefresh,
            m_IIS_MillisecondsToSleepBeforeCheckingForRefresh
            ));
    }


    if ( NumberOfTickCountsPassed > m_IIS_MillisecondsCountersAreFresh )
    {
        //
        // Ask WAS to refresh the counters.
        //
        PingWASToRefreshCounters();

        DWORD NumberOfWaits = 0;
        while ( NumberOfWaits < m_IIS_MaxNumberTimesToCheckCountersOnRefresh )
        {
            IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Waiting for the %d time  \n"
                    "CurrentTickCount is = %d \n\n",
                    NumberOfWaits,
                    GetTickCount()
                    ));
            }
            
            Sleep ( m_IIS_MillisecondsToSleepBeforeCheckingForRefresh );
            if ( GetLastUpdatedTickCount() != LastUpdatedTickCount)
            {
                IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
                {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "Finished waiting, tick count is now set to %d \n"
                        "CurrentTickCount is = %d \n\n",
                        GetLastUpdatedTickCount(),
                        GetTickCount()
                        ));
                }

                // We have new counter values.  We can continue.
                break;
            }

            NumberOfWaits++;
        }

        if ( NumberOfWaits == m_IIS_MaxNumberTimesToCheckCountersOnRefresh )
        {
            //
            // We had to go with stale counters.
            //
            return FALSE;
        }
    }

    return TRUE;
}


/***************************************************************************++

Routine Description:

    Retrieves the snmp counter information from the reader.

Arguments:

    OUT W3_COUNTER_BLOCK**  ppCounterBlock

Return Value:

    DWORD.

--***************************************************************************/
DWORD 
PERF_SM_MANAGER::GetSNMPCounterInfo(
    OUT LPBYTE*  ppCounterBlock
    )
{
    DBG_ASSERT ( ! HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    return (reinterpret_cast<PERF_SM_READER*>( m_pSMObjects))
                              [SITE_COUNTER_SET].GetSNMPCounterInfo(ppCounterBlock);
}

/***************************************************************************++

Routine Description:

    Creates an event to be used to signal when we should gather counters.

Arguments:

    None

Return Value:

    DWORD

--***************************************************************************/
DWORD
PERF_SM_MANAGER::CreateEventForSignallingGathering(
    )
{
    DWORD   dwErr = ERROR_SUCCESS;
    STRU    strFullName;
    DWORD   iCount = 0;

    PSID psidPowerUser = NULL;
    PSID psidSystemOperator = NULL;
    PSID psidPerfMonUser = NULL;
    PSID psidPerfLogUser = NULL;
    PSID psidLocalSystem = NULL;
    PSID psidAdmin = NULL;
    PACL pACL = NULL;

    EXPLICIT_ACCESS ea[6];   // Setup four explicit access objects

    SECURITY_DESCRIPTOR sd = {0};
    SECURITY_ATTRIBUTES sa = {0};

    // can not use HasWriteAccess because we are not initialized 
    // at this point.
    DBG_ASSERT( m_WriteAccess );
    DBG_ASSERT( m_hIISSignalCounterRefresh == NULL );

    wcsncpy( m_pManagerMemory->wszSignalEventName, L"NOT SET", MAX_FILE_NAME - 1 );
    m_pManagerMemory->wszSignalEventName[MAX_FILE_NAME-1] = L'\0';

    //
    // Handle setting up security for the request perf counter
    // event.  Power Users will be allowed to write to the event
    // so they can Set / Reset the event.  Local System will have
    // full access.
    //

    //
    // Get a sid that represents the Administrators group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinAdministratorsSid,
                                        &psidAdmin );
    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Administrator SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the POWER_USERS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPowerUsersSid,
                                        &psidPowerUser );
    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the SYSTEM_OPERATORS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinSystemOperatorsSid,
                                        &psidSystemOperator );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating System Operators SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the PERF_MON_USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfMonitoringUsersSid,
                                        &psidPerfMonUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating perf mon user SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the PERF_LOG_USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfLoggingUsersSid,
                                        &psidPerfLogUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating perf log user SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents LOCAL_SYSTEM.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinLocalSystemSid,
                                        &psidLocalSystem );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Local System SID failed\n"
            ));

        goto exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    SecureZeroMemory(ea, sizeof(ea));

    //
    // Setup POWER_USERS for read access.
    //
    SetExplicitAccessSettings(  &(ea[0]),
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidPowerUser );

    //
    // Setup Administrators for read access.
    //
    SetExplicitAccessSettings(  &(ea[1]),
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidAdmin );

    //
    // Setup System Operators for read access.
    //
    SetExplicitAccessSettings(  &(ea[2]),
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidSystemOperator );

    //
    // Setup Local System for all access.
    //
    SetExplicitAccessSettings(  &(ea[3]),
                                EVENT_ALL_ACCESS,
                                SET_ACCESS,
                                psidLocalSystem );

    //
    // Setup Perf Mon User for read access.
    //
    SetExplicitAccessSettings(  &(ea[4]),
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidPerfMonUser );

    //
    // Setup Perf Log User for read access.
    //
    SetExplicitAccessSettings(  &(ea[5]),
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidPerfLogUser );
    
    //
    // Create a new ACL that contains the new ACEs.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS), ea, NULL, &pACL);
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
        dwErr = GetLastError();
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    }

    if (!SetSecurityDescriptorDacl(&sd,
            TRUE,     // fDaclPresent flag
            pACL,
            FALSE))   // not a default DACL
    {
        dwErr = GetLastError();
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    do 
    {
        dwErr = GenerateNameWithGUID( COUNTER_EVENT_PREFIX_W,
                                    &strFullName );

        m_hIISSignalCounterRefresh = CreateEvent(&sa, TRUE, FALSE, strFullName.QueryStr());
        if ( m_hIISSignalCounterRefresh == NULL )
        {
            dwErr = GetLastError();
        }
        else
        {
            if ( GetLastError() == ERROR_ALREADY_EXISTS )
            {
                CloseHandle( m_hIISSignalCounterRefresh );
                m_hIISSignalCounterRefresh = NULL;
                dwErr = ERROR_ALREADY_EXISTS;
            }

        }

        // Just counting to make sure we don't loop forever.
        iCount++;

    } while ( m_hIISSignalCounterRefresh == NULL && iCount < 10 );


    if ( m_hIISSignalCounterRefresh == NULL )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to create an event for signalling counters\n"
            ));

        DBG_ASSERT ( dwErr != ERROR_SUCCESS );

        goto exit;
    }

    wcsncpy( m_pManagerMemory->wszSignalEventName, strFullName.QueryStr(), MAX_FILE_NAME - 1 );
    m_pManagerMemory->wszSignalEventName[MAX_FILE_NAME-1] = L'\0';

exit:

    //
    // Clean up the security handles used.
    //

    //
    // Function will only free if the
    // variable is set.  And it will set
    // the variable to NULL once it is done.
    //
    FreeWellKnownSid(&psidPowerUser);
    FreeWellKnownSid(&psidSystemOperator);
    FreeWellKnownSid(&psidPerfMonUser);
    FreeWellKnownSid(&psidPerfLogUser);
    FreeWellKnownSid(&psidLocalSystem);
    FreeWellKnownSid(&psidAdmin);

    if (pACL)
    {
        LocalFree(pACL);
        pACL = NULL;
    }

    return dwErr;

} // end PERF_SM_MANAGER::CreateEventForSignallingGathering

/***************************************************************************++

Routine Description:

    Pings the event that tells WAS to refresh counters.

Arguments:

    None

Return Value:

    VOID.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::PingWASToRefreshCounters(
    )
{
    if ( m_hIISSignalCounterRefresh != NULL )
    {
        SetEvent ( m_hIISSignalCounterRefresh );
    }
}

/***************************************************************************++

Routine Description:

    Waits on the signal to get counters.

Arguments:

    None

Return Value:

    VOID.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::WaitOnPerfEvent(
    )
{
    DBG_ASSERT ( HasWriteAccess() );
    DBG_ASSERT ( m_hIISSignalCounterRefresh != NULL  );

    // Do not care what the wait returns,
    // just know that we did signal so we should
    // either end or start gathering perf counters.
    WaitForSingleObject(m_hIISSignalCounterRefresh, INFINITE);

    IF_DEBUG ( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "PerfCounters signaled CTC = %d \n",
            GetTickCount()
            ));
    }

    // Once we have heard the event reset it.
    if (!ResetEvent(m_hIISSignalCounterRefresh))
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(GetLastError()),
            "Could not reset the perf counter event\n"
            ));
    }
}


/***************************************************************************++

Routine Description:

    Determines if the control block was setup for a writer to work with.

Arguments:

    None

Return Value:

    BOOL.

--***************************************************************************/
BOOL 
PERF_SM_MANAGER::HasWriteAccess(
    )
{ 
    DBG_ASSERT ( m_Initialized );

    return m_WriteAccess; 
}

/***************************************************************************++

Routine Description:

    Determines if we should be releasing memory instead of reading from it.

Arguments:

    None

Return Value:

    BOOL.

--***************************************************************************/
BOOL 
PERF_SM_MANAGER::ReleaseIsNeeded(
    )
{ 
    DBG_ASSERT ( ! HasWriteAccess()  );

    DBG_ASSERT ( m_pManagerMemory  );

    return ( m_pManagerMemory->InitializedCode != 
                                             PERF_COUNTER_INITIALIZED_CODE ) ; 
}


/***************************************************************************++

Routine Description:

    Determines if we have configuration data for how we should wait for
    data to be refreshed before delivering counters.  If we do this will
    set the member variables appropriately

Arguments:

    None

Return Value:

    VOID.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::ResetWaitFreshCounterValues(
    )
{ 

    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;

    DWORD size;
    DWORD type;
    DWORD dwRegSettingValue;


    //
    //  Open the HTTP Server service's Performance key.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_W,
                        0,
                        KEY_QUERY_VALUE,
                        &hkey );

    if( err == NO_ERROR)
    {
     
        //
        // Read in wait limit for counters.
        //

        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               REGISTRY_VALUE_W3SVC_PERF_FRESH_TIME_FOR_COUNTERS_W,
                               NULL,
                               &type,
                               (LPBYTE)&dwRegSettingValue,
                               &size );
        if( err == NO_ERROR && type == REG_DWORD )
        {
            if ( dwRegSettingValue != 0 )
            {
                m_IIS_MillisecondsCountersAreFresh = dwRegSettingValue;
            }
        }

        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               REGISTRY_VALUE_W3SVC_PERF_CHECK_COUNTERS_EVERY_N_MS_W,
                               NULL,
                               &type,
                               (LPBYTE)&dwRegSettingValue,
                               &size );
        if( err == NO_ERROR && type == REG_DWORD )
        {
            if ( dwRegSettingValue != 0 )
            {
                m_IIS_MillisecondsToSleepBeforeCheckingForRefresh
                                                        = dwRegSettingValue;
            }
        }

        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               REGISTRY_VALUE_W3SVC_PERF_NUM_TIMES_TO_CHECK_COUNTERS_W,
                               NULL,
                               &type,
                               (LPBYTE)&dwRegSettingValue,
                               &size );
        if( err == NO_ERROR && type == REG_DWORD )
        {
            if ( dwRegSettingValue != 0 )
            {
                m_IIS_MaxNumberTimesToCheckCountersOnRefresh = dwRegSettingValue;
            }
        }

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }
    }
}  // end of ResetWaitFreshCounterValues


/***************************************************************************++

Routine Description:

    Returns the was process handle so the reader can monitor if the process
    goes away.

Arguments:

    None

Return Value:

    HANDLE.

--***************************************************************************/
HANDLE
PERF_SM_MANAGER::GetWASProcessHandle(
    )
{
    DBG_ASSERT ( ! HasWriteAccess() );

    return m_WASProcessHandle;
}


//
// Public PERF_SM_WRITER functions.
// 

/***************************************************************************++

Routine Description:

    Constructor for the PERF_SM_WRITER class.

Arguments:

    None

Return Value:

    None.

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_WRITER::PERF_SM_WRITER(
    )
{

    m_NumInstances = 0;

    m_SizeOfMemory = 0;

    //
    // Default to an illegal value.
    //
    m_CounterSetId = MAX_COUNTER_SET_DEFINES;

    m_MemoryVersionNumber = 0;

    m_UpdateNeeded = FALSE;

    m_ActiveMemoryIsA = TRUE;

    m_pSharedManager = NULL;

    m_pMemoryA = NULL;
    m_pMemoryB = NULL;
    m_hMemoryA = NULL;
    m_hMemoryB = NULL;

    m_Initialized = FALSE;

    m_Signature = PERF_SM_WRITER_SIGNATURE;

}   // PERF_SM_MANAGER::PERF_SM_WRITER::PERF_SM_WRITER



/***************************************************************************++

Routine Description:

    Destructor for the PERF_SM_WRITER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_WRITER::~PERF_SM_WRITER(
    )
{

    DBG_ASSERT( m_Signature == PERF_SM_WRITER_SIGNATURE );

    m_Signature = PERF_SM_WRITER_SIGNATURE_FREED;

    if ( m_pMemoryA )
    {
        UnmapViewOfFile(m_pMemoryA);
        m_pMemoryA = NULL;
    }

    if (m_hMemoryA != NULL)
    {
        CloseHandle(m_hMemoryA);
        m_hMemoryA = NULL;
    }
    
    if ( m_pMemoryB )
    {
        UnmapViewOfFile(m_pMemoryB);
        m_pMemoryB = NULL;
    }

    if (m_hMemoryB != NULL)
    {
        CloseHandle(m_hMemoryB);
        m_hMemoryB = NULL;
    }

}   // PERF_SM_MANAGER::PERF_SM_WRITER::~PERF_SM_WRITER


/***************************************************************************++

Routine Description:

    Initialize the class to represent a counter set that we
    are going to be updating and supporting.

Arguments:

    IN PERF_SM_MANAGER* pSharedManager - Pointer to the shared memory controller.
    IN COUNTER_SET_ENUM CounterSetId   - The counter set this class will represent.
    

Return Value:

    DWORD - Win32 Status Code

--***************************************************************************/

DWORD
PERF_SM_MANAGER::PERF_SM_WRITER::Initialize(
        IN PERF_SM_MANAGER* pSharedManager,
        IN COUNTER_SET_ENUM CounterSetId
        )
{


    DBG_ASSERT ( m_Initialized == FALSE );

    DBG_ASSERT ( pSharedManager );

    DBG_ASSERT ( pSharedManager->HasWriteAccess() );

    DBG_ASSERT ( CounterSetId < MAX_COUNTER_SET_DEFINES );

    m_CounterSetId = CounterSetId;

    //
    // The shared manager is not a ref counted object, however since
    // only the shared manager will create these objects and only the
    // same shared manager will delete these objects, means that the shared
    // manager should always be valid while we hold this pointer.
    //
    m_pSharedManager = pSharedManager;

    m_Initialized = TRUE;

    return ERROR_SUCCESS;

}   // PERF_SM_MANAGER::PERF_SM_WRITER::Initialize

/***************************************************************************++

Routine Description:

    Update the shared memory to be a larger piece if the size of memory
    that we currently has does not have enough room to handle the new number
    of instances we have been passed.

Arguments:

    IN DWORD NumInstances    - The number of instances the class currently has.
    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_SM_MANAGER::PERF_SM_WRITER::ReallocSharedMemIfNeccessary(
        IN DWORD NumInstances
        )
{

    DBG_ASSERT( m_Initialized );

    HRESULT hr = S_OK;

    // 
    // Verify that the number of instances that we currently
    // have space for is less than the number of instances that
    // we really need space for.  If it is then resize
    // the memory.
    //
    // If we are in the case where there is only one set of counter
    // values (no instances) then we will never resize.  We will go 
    // through this code once on initialization, because the m_NumInstances
    // won't yet be set to PERF_NO_INSTANCES.
    //
    if ( m_NumInstances != PERF_NO_INSTANCES && m_NumInstances < NumInstances )
    {
     
        //
        // Need to caculate the max size for instance definition data.
        // If the counter type does not support multiple instance definitions
        // then there is no space allocated for instance definition.
        //
        DWORD InstanceDefSpace = 0;

        if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
        {
            m_NumInstances = NumInstances;

            //
            // InstanceDefSpace is equal to the size of a instance definition
            // as defined by perf counters, plus the amount of space needed for
            // the instance name (which follows the instance definition).
            //
            InstanceDefSpace = sizeof(PERF_INSTANCE_DEFINITION) 
                                + (sizeof(WCHAR) * MAX_INSTANCE_NAME );
        }
        else
        {
            //
            // Make sure the shared memory ends up showing 
            // that there will be no instances, but still
            // set the NumInstances to 1 so we do make room
            // for a set of counters.
            //

            m_NumInstances = (DWORD) PERF_NO_INSTANCES;
            NumInstances = 1;
        }

        // 
        // Add space for the global information about the counter set.
        // Then for each instance add space for the 
        // size of the instance definition (which includes the size of the
        // instance name) and the actual counter data.
        //
        m_SizeOfMemory =sizeof(COUNTER_GLOBAL_STRUCT)      
                        + (NumInstances 
                            * ( InstanceDefSpace
                                + g_CounterSetInfo[m_CounterSetId].SizeOfCounterData ));

        // 
        // Up the memory version since we are changing the memory.
        // We can also go ahead and work on page A since any client
        // will not be reading the same version that we are working on.
        //
        m_MemoryVersionNumber++; 

        //
        // If it just became zero (wrap around) then we want to skip it and make
        // it at least 1.  Zero is a special case that means we are
        // not ready with any counters.
        //
        if ( m_MemoryVersionNumber == 0 )
        {
            m_MemoryVersionNumber++; 
        }

        //
        // We will only setup the first page, remember that we need
        // to copy the first page to the second when it is time to 
        // update the second page.
        //
        m_UpdateNeeded = TRUE;

        //
        // We will work on page A for now.  Page B will become active
        // when we have finished updating page A.
        //
        m_ActiveMemoryIsA = TRUE;

        //
        // Hook up to the appropriate files.  Note, if files exist
        // this will attempt to up the version and try again, but only
        // to a point.  If it can't create the files it will then fail.
        //
        hr = MapSetOfCounterFiles ();
        if ( FAILED (hr) )
        {
            goto exit;
        }    

        //
        // Since we are initializing we know that the active memory 
        // is the memory pointed to by m_pMemoryA.
        //
        DBG_ASSERT( m_pMemoryA );

        // Set the number of instances and size of data
        //
        ((COUNTER_GLOBAL_STRUCT*) m_pMemoryA)->NumInstances = 
                            m_NumInstances;

        ((COUNTER_GLOBAL_STRUCT*) m_pMemoryA)->SizeData = 
                            m_SizeOfMemory - sizeof(COUNTER_GLOBAL_STRUCT);

    }
exit:

    if ( FAILED ( hr ) )
    {
        // We need to try and re-allocated the memory
        // next time, so just lie about the number of 
        // instances we can support here.
        m_NumInstances = 0;
    }

    return hr;

}   // PERF_SM_MANAGER::PERF_SM_WRITER::ReallocSharedMemIfNeccessary


/***************************************************************************++

Routine Description:

    Routine will increment the total counters for the counter set.

Arguments:

    IN LPVOID               pCounterInstance,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_SM_MANAGER::PERF_SM_WRITER::AggregateTotal(
    IN LPVOID               pCounterInstance,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc
    )
{

    DBG_ASSERT( m_Initialized );

    //
    // If we called AggregateTotal on global's by accident this
    // might happen, and we would want to fix that.
    //
    DBG_ASSERT ( pDisplayPropDesc );

    DBG_ASSERT ( pCounterInstance );

    //
    // Get the CounterBlock pointer for the _Total instance.  This
    // instance is always defined as Offset Zero.
    //
    LPVOID pCounterTotal = GetCounterBlockPtr(0);

    DBG_ASSERT ( pCounterTotal );

    //
    // Now loop through all the counters that will go to the client
    // and add them into the total counter record.
    //
    for (  DWORD  PropDisplayId = 0 ; 
            PropDisplayId < cDisplayPropDesc; 
            PropDisplayId++ )
    {
        //
        // Determine the size of the counter so we know how to 
        // increment it.
        //
        if ( pDisplayPropDesc[PropDisplayId].size == sizeof( DWORD ) )
        {
            DWORD* pDWORDToUpdate = (DWORD*) ( (LPBYTE) pCounterTotal 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            DWORD* pDWORDToUpdateWith =  (DWORD*) ( (LPBYTE) pCounterInstance 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not 
            // happen at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pDWORDToUpdate = *pDWORDToUpdate + *pDWORDToUpdateWith;


        }
        else
        {
            DBG_ASSERT ( pDisplayPropDesc[PropDisplayId].size 
                                                        == sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDToUpdate = (ULONGLONG*) ( (LPBYTE) pCounterTotal 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            ULONGLONG* pQWORDToUpdateWith =  (ULONGLONG*) ( (LPBYTE) pCounterInstance 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not 
            // happen at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pQWORDToUpdate = *pQWORDToUpdate + *pQWORDToUpdateWith;

        }
            
    }
    
}  // end of PERF_SM_MANAGER::PERF_SM_WRITER::AggregateTotal


/***************************************************************************++

Routine Description:

    This routine will alter a generic instance definition to represent
    a specific instance.  This includes adding the name to the space after
    the instance as well as copying in the counter values if they are provided

Arguments:

    IN LPCWSTR              InstanceName - Name of the instance
    IN ULONG                MemoryOffset - The key to find the instance data's memory.
    IN LPVOID               pCounters    - Counter block to copy in for the instance.
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc - Description of the counter block
    IN DWORD                cDisplayPropDesc - Number of counters in the block
    IN BOOL                 StructChanged    - Whether the memory has changed, if 
                                               it has then we need to recopy the
                                               instance definition information.
    OUT ULONG*              pNewMemoryOffset - What the next memory offset is for
                                               the next instance that wants to provide
                                               counters.
    
Return Value:

    VOID

--***************************************************************************/

VOID
PERF_SM_MANAGER::PERF_SM_WRITER::CopyInstanceInformation( 
    IN LPCWSTR              InstanceName,
    IN ULONG                MemoryOffset,
    IN LPVOID               pCounters,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc,
    IN BOOL                 StructChanged,
    OUT ULONG*              pNewMemoryOffset
  )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Only copy in the instance definition parts if the particular counter
    // set supports separate instances of it's counters.
    //
    if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
    {
        //
        // Find the instance information block
        //
        PERF_INSTANCE_DEFINITION* pInstDef = 
                                GetInstanceInformationPtr( MemoryOffset );
    
        DBG_ASSERT( pInstDef );
    
        //
        // If the structre has changed then we will need to copy in a 
        // fresh copy of the generic instance definition block.
        //
        if ( StructChanged )
        {
            //
            // If the structure changed we better have an instance name.
            //

            DBG_ASSERT ( InstanceName );

            //
            // Copy a generic instance object into the space.
            //

            //
            // we should have room becuase we allocated enough space
            // for all the sites counters prior to this path being executed.
            //
            memcpy ( pInstDef, &g_PerfInstance, sizeof(g_PerfInstance) );
        }

        //
        // If we have been passed an instance name then we need to 
        // copy it into place and set the appropriate information 
        // about it into the instance definition.
        //
        if ( InstanceName )
        {
            //
            // The name length will include the null terminator.
            //
            DWORD len = (DWORD) wcslen(InstanceName) + 1;

            //
            // If the instance name is too long, we truncate it.
            // 
            // Issue-09/10/2000-EmilyK  Instance Name
            // IIS 5 did not bound the instance name, nor did it have the
            // extra space that we are always allocating.  Need to figure out
            // if we can do this in a better way?
            //
            // This issue will be handled when we do dynamic name sizing.
            //
            if ( len > MAX_INSTANCE_NAME )
            {
                len = MAX_INSTANCE_NAME;
            }

            //
            // Set any non generic properties:  
            //      NameLength is the only non-generic property.
            //
            // Remember len contains the trailing null now.
            //
            pInstDef->NameLength = len * sizeof(WCHAR);

            // 
            // Increment the pInstDef one definiton length,
            // this will set it directly at the correct spot
            // for writing in the InstanceName.
            //
            pInstDef++;

            //
            // copy in len characters of the instance name, this will prevent 
            // us from over copying.  However if len == MAX_INSTANCE_NAME 
            // then we will need to terminate as well.
            //
            wcsncpy ( (LPWSTR) pInstDef, InstanceName, len );

            if ( len == MAX_INSTANCE_NAME )
            {
                ((LPWSTR)pInstDef)[len-1] = L'\0';
            }
        }

    } // end of instance information


    //
    // Next get the pointer to the place where any counter values
    // should be copied.  If we actually have values, we can copy them
    // otherwise we will simply zero the counter values.
    //
    PERF_COUNTER_BLOCK* pCounterBlock = GetCounterBlockPtr( MemoryOffset );
    DBG_ASSERT( pCounterBlock );

    //
    // If we are dealing with the Total instance then we will not have
    // counter values to copy over.  In this case just clear the memory
    // and setup the ByteLength correctly.
    //
    if ( pCounters != NULL )
    {
        //
        // Put the counters into there place.
        //

        //
        // We should have enough space because the memory was allocated 
        // based on the number of sites.
        //
        memcpy ( pCounterBlock, 
                 pCounters, 
                 g_CounterSetInfo[m_CounterSetId].SizeOfCounterData );

        //
        // Assuming that we have different instances, it means we have a _Total
        // so we will need to aggregate the counters into the total.
        //
        if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
        {
            AggregateTotal ( (LPVOID) pCounterBlock,
                             pDisplayPropDesc,
                             cDisplayPropDesc);
        }
    }
    else
    {
        //
        // If we didn't have counters to copy in (we are dealing with setting 
        // up the _Total record), simply zero out the values and setup the 
        // bytelength field.
        //
        memset ( pCounterBlock, 
                 0, 
                 g_CounterSetInfo[m_CounterSetId].SizeOfCounterData );

        pCounterBlock->ByteLength = 
                  g_CounterSetInfo[m_CounterSetId].SizeOfCounterData;
    }

    //
    // Calculate the start of the next memory reference.
    // The counter block is pointing to the beginning of the counters
    // so all we need to do is add in the size of the counter structure
    // and we know where the next instance should start.
    //

    LPBYTE pStartOfNextInstance = ( LPBYTE ) pCounterBlock 
                         + g_CounterSetInfo[m_CounterSetId].SizeOfCounterData;

    //
    // However we want to return the Offset not the actual memory address, 
    // so we can use it with either file.
    //

    *pNewMemoryOffset = 
             (DWORD) DIFF((LPBYTE) pStartOfNextInstance - (LPBYTE) GetActiveMemory());
    
}

/***************************************************************************++

Routine Description:

    Sets the update flag to let the system know to copy over the meta
    data to the other sheet of shared memory, when neccessary.

Arguments:

    IN BOOL UpdateNeeded - tells if we should turn it on or off.

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::PERF_SM_WRITER::SetUpdateNeeded(
    IN BOOL UpdateNeeded
    )
{
    m_UpdateNeeded = UpdateNeeded;
}

/***************************************************************************++

Routine Description:

    This routine will update the total time the Web Service has been
    running. 

    Note:  It is not exactly usual for the shared manager to know about 
           specific counters, but since it is the only one that should be
           writing to the shared memory directly, it is implemented here.

Arguments:

    None.    

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_SM_MANAGER::PERF_SM_WRITER::UpdateTotalServiceTime(
    IN DWORD  ServiceUptime
    )
{
    DBG_ASSERT( m_Initialized );

    //
    // Offset Zero is the _Total instance when there are instances.
    //

    W3_COUNTER_BLOCK* pCounterBlock = (W3_COUNTER_BLOCK*) GetCounterBlockPtr( 0 );
    DBG_ASSERT( pCounterBlock );

    pCounterBlock->ServiceUptime = ServiceUptime;

}


/***************************************************************************++

Routine Description:

    This routine will update the shared manager to display the new 
    counter data to the world.  It will also fix up it's own member
    variables so it will update the correct memory next time.

Arguments:

    None.    

Return Value:

    HRESULT

--***************************************************************************/
VOID
PERF_SM_MANAGER::PERF_SM_WRITER::PublishCounterPage(
    )
{
    DBG_ASSERT ( m_Initialized );
    DBG_ASSERT ( !m_strMemoryNameA.IsEmpty() );
    DBG_ASSERT ( !m_strMemoryNameB.IsEmpty() );

    //
    // tell the shared manager to update the information.
    // 
    m_pSharedManager->SetActiveInformation(
                              m_CounterSetId
                            , m_MemoryVersionNumber
                            , m_ActiveMemoryIsA
                            , m_strMemoryNameA.QueryStr()
                            , m_strMemoryNameB.QueryStr() );

    // 
    // change (the writers view) of the active page.
    //

    m_ActiveMemoryIsA = !m_ActiveMemoryIsA;

    //
    // if we need to update this page with
    // the structure of the other page then
    // this is the time.  (This only happens
    // after a version change)
    //
    if ( m_UpdateNeeded )
    {
        DBG_ASSERT ( m_pMemoryA && m_pMemoryB );

        // the active memory always has equal sizes.
        if ( m_ActiveMemoryIsA )
        {
            memcpy( m_pMemoryA, m_pMemoryB, m_SizeOfMemory );
        }
        else
        {
            memcpy( m_pMemoryB, m_pMemoryA, m_SizeOfMemory );
        }

        m_UpdateNeeded = FALSE;
    }
}

// 
// Private PERF_SM_WRITER functions
// 

/***************************************************************************++

Routine Description:

    Figures out which page of shared memory is active from 
    the writers point of view.

Arguments:

    None    

Return Value:

    LPVOID

--***************************************************************************/
LPVOID 
PERF_SM_MANAGER::PERF_SM_WRITER::GetActiveMemory()
{
    DBG_ASSERT( m_Initialized );

    //
    // Since this is the writer class it controls
    // which class is set to be "active" in the manager
    // memory.  Thus it can have a member variable that
    // will keep track of the memory that it wants to 
    // work with.  As long as there is only one 
    // writer instance, this works.
    //

    if (m_ActiveMemoryIsA)
        return m_pMemoryA;
    else
        return m_pMemoryB;
}


/***************************************************************************++

Routine Description:

    Looks up a specific instances counter block and 
    returns a pointer to it.

Arguments:

    IN ULONG MemoryOffset  -  Key to find the specific instances
                                 memory chunk to work on.
    

Return Value:

    HRESULT

--***************************************************************************/

PERF_COUNTER_BLOCK* 
PERF_SM_MANAGER::PERF_SM_WRITER::GetCounterBlockPtr(
    IN ULONG MemoryOffset
    )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Where the counter block is, is dependent upon whether or not
    // we have instance information stored.
    //
    if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
    {
        // 
        // This will determine the active memory page
        // and figure out where the instance information starts.
        //
        LPBYTE pMemory = (LPBYTE) GetInstanceInformationPtr(MemoryOffset);

        //
        // The counter block directly follows the instance definition
        // and the instance name.
        //
        pMemory += sizeof(PERF_INSTANCE_DEFINITION);
        pMemory += MAX_INSTANCE_NAME * sizeof(WCHAR);

        return (PERF_COUNTER_BLOCK*) pMemory;

    }
    else
    {
        //
        // In the case where we don't have instance information
        // the shared memory points almost directly to the counter block.
        //
        LPBYTE pMemory = (LPBYTE) GetActiveMemory();
        
        //
        // Just offset it by the information describing the block of memory.
        //
        pMemory += sizeof( COUNTER_GLOBAL_STRUCT );

        return (PERF_COUNTER_BLOCK*) pMemory;
    }

}

/***************************************************************************++

Routine Description:

    Function maps two pieces of shared memory with matching version numbers.

Arguments:

    None.    

Return Value:

    HRESULT

Note:

    CreateMemoryFile will close any open files it is handed before 
    creating the new files.

--***************************************************************************/

HRESULT 
PERF_SM_MANAGER::PERF_SM_WRITER::MapSetOfCounterFiles(
         )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( m_Initialized );

    hr = CreateCounterFile( &m_hMemoryA, &m_pMemoryA, &m_strMemoryNameA );
    if ( FAILED ( hr ) )
    {
        goto exit;
    }

    hr = CreateCounterFile( &m_hMemoryB, &m_pMemoryB, &m_strMemoryNameB );
    if ( FAILED ( hr ) )
    {
        goto exit;
    }

exit:

    // If we have failed then we may have some files mapped and others not.
    // However the destructor for this class will clean up what we have not
    // so don't worry about it hear.

    return hr;

}

/***************************************************************************++

Routine Description:

    Function maps one piece of shared memory.

Arguments:

    None.    

Return Value:

    HRESULT

Note:

    CreateMemoryFile will close any open files it is handed before 
    creating the new files.

--***************************************************************************/

HRESULT 
PERF_SM_MANAGER::PERF_SM_WRITER::CreateCounterFile(
    HANDLE* phMemory,
    LPVOID* ppMemory,
    STRU*   pstrFileMapped
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD iCount = 0;

    DBG_ASSERT ( pstrFileMapped != NULL );

    do 
    {
        dwErr = GenerateNameWithGUID( g_CounterSetInfo[m_CounterSetId].pFilePrefix,
                                    pstrFileMapped );
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        dwErr = CreateMemoryFile ( pstrFileMapped->QueryStr()
                            , m_SizeOfMemory
                            , phMemory
                            , ppMemory );

        // Just counting to make sure we don't loop forever.
        iCount++;

    } while ( dwErr == ERROR_ALREADY_EXISTS && iCount < 10 );

exit:

    return HRESULT_FROM_WIN32( dwErr );
}

/***************************************************************************++

Routine Description:

    Returns the specific instances definition pointer.

Arguments:

    ULONG MemoryOffset  - key to find the instance information from.
    

Return Value:

    HRESULT

--***************************************************************************/

PERF_INSTANCE_DEFINITION* 
PERF_SM_MANAGER::PERF_SM_WRITER::GetInstanceInformationPtr(
    IN ULONG MemoryOffset
    )
{
    DBG_ASSERT( m_Initialized );

    //
    // We should never be looking for instance information on a 
    // counter set that does not expose instances.
    //
    DBG_ASSERT ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData );

    if ( MemoryOffset == 0 ) 
    {
        MemoryOffset = sizeof ( COUNTER_GLOBAL_STRUCT );
    }

    //
    // Make sure we have atleast enough memory left for the 
    // instance that we are attempting to add.
    //
    ULONG SpaceNeeded = ( MemoryOffset +
                              sizeof(PERF_INSTANCE_DEFINITION) +
                              (MAX_INSTANCE_NAME * sizeof(WCHAR)) +
                              g_CounterSetInfo[m_CounterSetId].SizeOfCounterData ) ;

    UNREFERENCED_PARAMETER ( SpaceNeeded );

    // this is an assert, because we have allocated the space before all this,
    // and we should never be asked for space outside what we have.
    DBG_ASSERT ( SpaceNeeded <= m_SizeOfMemory );

    //
    // get the active memory pointer.
    //
    return (PERF_INSTANCE_DEFINITION*) ( ( LPBYTE ) GetActiveMemory() 
                                                   + MemoryOffset );

}


// 
// Public PERF_SM_READER Functions
//

/***************************************************************************++

Routine Description:

    Constructor for the PERF_SM_READER class.

Arguments:
    
    None

Return Value:

    None

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_READER::PERF_SM_READER(
    )
{
    
    m_MemoryVersionNumber = 0;

    m_ActiveMemoryIsA = TRUE;

    m_hMemoryA = NULL;
    m_pMemoryA = NULL;

    m_hMemoryB = NULL;
    m_pMemoryB = NULL;

    m_Initialized = FALSE;

    m_Signature = PERF_SM_READER_SIGNATURE; 

}

//
// Destructor for the PERF_SM_READER Class
//
/***************************************************************************++

Routine Description:

    Destructor for the PERF_SM_READER class.

Arguments:

    None    

Return Value:

    None

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_READER::~PERF_SM_READER()
{
    DBG_ASSERT( m_Signature == PERF_SM_READER_SIGNATURE );

    m_Signature = PERF_SM_READER_SIGNATURE_FREED;

    if ( m_pMemoryA )
    {
        UnmapViewOfFile(m_pMemoryA);
        m_pMemoryA = NULL;
    }

    if (m_hMemoryA != NULL)
    {
        CloseHandle(m_hMemoryA);
        m_hMemoryA = NULL;
    }
    
    if ( m_pMemoryB )
    {
        UnmapViewOfFile(m_pMemoryB);
        m_pMemoryB = NULL;
    }

    if (m_hMemoryB != NULL)
    {
        CloseHandle(m_hMemoryB);
        m_hMemoryB = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Hooks up to the shared memory that contains the data for counters 
    of the specific set that the class is initialized to.

Arguments:

    IN PERF_SM_MANAGER* pSharedManager - Pointer to the controller of memory.
    IN COUNTER_SET_ENUM CounterSetId   - Identifies the counter set this class
                                         will represent.
    

Return Value:

    DWORD  -  Win32 Error Code

--***************************************************************************/

DWORD 
PERF_SM_MANAGER::PERF_SM_READER::Initialize(
    IN PERF_SM_MANAGER* pSharedManager,
    IN COUNTER_SET_ENUM CounterSetId
    )
{

    //
    // Validate that the world looks correctly.
    //
    DBG_ASSERT ( !m_Initialized );
    DBG_ASSERT ( pSharedManager);
    DBG_ASSERT ( !pSharedManager->HasWriteAccess() );
    DBG_ASSERT ( CounterSetId < MAX_COUNTER_SET_DEFINES );

    //
    // Hold on to the shared manager.
    //
    m_pSharedManager = pSharedManager;

    m_CounterSetId = CounterSetId;

    ConnectToActiveMemory();

    m_Initialized = TRUE;

    //
    // For now we do not error from this initializer.
    // This may change in the future.
    //
    return ERROR_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Returns the counter information from the current block
    of shared memory.

    Note:  Do not hold on to this return info for long, the current block
    could change quickly and you don't want stale info.

Arguments:

    OUT COUNTER_GLOBAL_STRUCT** ppGlobal - Pointer to global info about the counters
    OUT LPVOID* ppData                   - Pointer to the counter info.
    

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/

DWORD 
PERF_SM_MANAGER::PERF_SM_READER::GetCounterInfo(
    OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
    OUT LPVOID* ppData
    )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Get ahold of the active memory.
    //
    LPBYTE pMemory = (LPBYTE) GetActiveMemory();

    if ( pMemory )
    {
        //
        // Set the pointers and return
        //
        *ppGlobal = (COUNTER_GLOBAL_STRUCT*) pMemory;
        *ppData = (LPVOID) (pMemory + sizeof(COUNTER_GLOBAL_STRUCT));

        return ERROR_SUCCESS;
    }
    else
    {
        *ppGlobal = NULL;
        *ppData = NULL;

        return ERROR_FILE_NOT_FOUND;
    }

}

/***************************************************************************++

Routine Description:

    Returns the _Total site information in a W3_COUNTER_BLOCK form.

Arguments:

    OUT W3_COUNTER_BLOCK**  ppCounterBlock

    Note:  the memory is still owned by the reader object.  do not free it.
           also do not hold on to it for any amount of time because the reader
           could free it.
    

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/

DWORD 
PERF_SM_MANAGER::PERF_SM_READER::GetSNMPCounterInfo(
    OUT LPBYTE*  ppCounterBlock
    )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Get ahold of the active memory.
    //
    LPVOID pMemory = GetActiveMemory();
    LPBYTE pCounterInstance =  ( LPBYTE ) pMemory + sizeof(COUNTER_GLOBAL_STRUCT);

    if ( pMemory )
    {
        //
        // Verify we have at least one instance.  
        // This should be the case because we are getting site information
        // and we always have a _Total Site, even if we don't have 
        // other sites.
        // 
        DBG_ASSERT ( ((COUNTER_GLOBAL_STRUCT*)pMemory)->NumInstances >= 1 );

        //
        // Set the pointers and return
        //

        pCounterInstance += sizeof(PERF_INSTANCE_DEFINITION);
        pCounterInstance += MAX_INSTANCE_NAME * sizeof(WCHAR);

        *ppCounterBlock =  pCounterInstance;

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_FILE_NOT_FOUND;
    }

}
//
// Private PERF_SM_READER functions
//

/***************************************************************************++

Routine Description:

    Return figures out if the current memory snapshots are still active and 
    if not it will drop the current snapshots and map the new ones..

Arguments:

    None.    

Return Value:

    None.

    Note after this function is run the memory pointers may or may not
    return NULL.  If they do return NULL then we just don't have counters
    at this specific time.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::PERF_SM_READER::ConnectToActiveMemory()
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD Version;
    BOOL  ActivePageIsA;
    STRU  strFileNameA;
    STRU  strFileNameB;

    //
    // We do not check if we are initialized here, because this can happen
    // while we are initializing.
    //

    //
    // Get the active version and page from the controller and map to them.
    //
    m_pSharedManager->GetActiveInformation(m_CounterSetId, 
                                           &Version, 
                                           &ActivePageIsA,
                                           &strFileNameA,
                                           &strFileNameB);

    //
    // If the version is set to zero then no memory is ready for the 
    // counters.  We will not map an memory.
    //
    if ( Version == 0 ||
         strFileNameA.IsEmpty() ||
         strFileNameB.IsEmpty() )
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    //
    // If these don't match then we need to remap.
    //
    if ( Version != m_MemoryVersionNumber )
    {
        //
        // Attempt to open the memory
        //
        dwErr = OpenMemoryFile(strFileNameA.QueryStr(), &m_hMemoryA, &m_pMemoryA);
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        dwErr = OpenMemoryFile(strFileNameB.QueryStr(), &m_hMemoryB, &m_pMemoryB);
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        m_MemoryVersionNumber = Version;
    }

    m_ActiveMemoryIsA = ActivePageIsA;

exit:

    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Could not connect to counter information for counter set %d\n",
            m_CounterSetId
            ));

        //
        // Something is not right, reset all
        // so we are on a clean slate to try again.
        //

        if ( m_pMemoryA )
        {
            UnmapViewOfFile(m_pMemoryA);
            m_pMemoryA = NULL;
        }

        if (m_hMemoryA != NULL)
        {
            CloseHandle(m_hMemoryA);
            m_hMemoryA = NULL;
        }

        if ( m_pMemoryB )
        {
            UnmapViewOfFile(m_pMemoryB);
            m_pMemoryB = NULL;
        }

        if (m_hMemoryB != NULL)
        {
            CloseHandle(m_hMemoryB);
            m_hMemoryB = NULL;
        }

        m_ActiveMemoryIsA = TRUE;

        m_MemoryVersionNumber = 0;

    }

}


/***************************************************************************++

Routine Description:

    Return figures out which block of memory is active and hands back
    a pointer to it's memory.

    Note:  Do not hold on to this return info for long, the current block
    could change quickly and you don't want stale info.

Arguments:

    None.    

Return Value:

    LPVOID - pointer to active memory

    Note:  This routine can and will return NULL when neccessary.

--***************************************************************************/
LPVOID 
PERF_SM_MANAGER::PERF_SM_READER::GetActiveMemory()
{
    DBG_ASSERT( m_Initialized );

    ConnectToActiveMemory();

    if ( m_ActiveMemoryIsA )
    {
        return m_pMemoryA;
    }
    else
    {
        return m_pMemoryB;
    }
}

//
// Generic functions 
//
/***************************************************************************++

Routine Description:

    Creates a Memory Mapped file, open for writting.

Arguments:

     IN LPCWSTR pFileName   - Name of the file to create.
     IN DWORD SizeOfData    - Size of the data the file needs to hold.
     OUT HANDLE* phFile     - Handle to the file
     OUT LPVOID* ppFile     - Pointer to the data in the file

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/
DWORD 
CreateMemoryFile (
     IN LPCWSTR pFileName,
     IN DWORD SizeOfData,
     OUT HANDLE* phFile,
     OUT LPVOID* ppFile
     )
{
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hFile = NULL;
    LPVOID pFile = NULL;

    PSID psidPowerUser = NULL;
    PSID psidPerfMonUser = NULL;
    PSID psidPerfLogUser = NULL;
    PSID psidSystemOperator = NULL;
    PSID psidLocalSystem = NULL;
    PSID psidAdmin = NULL;
    PACL pACL = NULL;


    EXPLICIT_ACCESS ea[6];

    SECURITY_DESCRIPTOR sd = {0};
    SECURITY_ATTRIBUTES sa = {0};


    DBG_ASSERT(ppFile && phFile);

    // 
    // First release any files that these pointers may
    // currently be pointing to.  If we are resizing then
    // it is completely expected that we may have valid
    // pointers sent in that need to be released first.
    // 

    if ( *ppFile != NULL )
    {
        UnmapViewOfFile(*ppFile);
        *ppFile = NULL;
    }

    if ( *phFile != NULL )
    {
        CloseHandle(*phFile);
        *phFile = NULL;
    }


    //
    // Now go ahead and map the file.
    //
    //
    // Prepare the security pieces for the file mapping.
    // These files we allow read access to any Power Users  
    // or administrators and all access to any Local System 
    // processes.
    //
    
    //
    // Get a sid that represents the Administrators group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinAdministratorsSid,
                                        &psidAdmin );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Administrator SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the POWER_USERS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPowerUsersSid,
                                        &psidPowerUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the SYSTEM_OPERATORS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinSystemOperatorsSid, 
                                        &psidSystemOperator );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating System Operators SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the PERF_MON_USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfMonitoringUsersSid,
                                        &psidPerfMonUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating perf mon user SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the PERF_LOG_USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfLoggingUsersSid,
                                        &psidPerfLogUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating perf log user SID failed\n"
            ));

        goto exit;
    }

    
    //
    // Get a sid that represents LOCAL_SYSTEM.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinLocalSystemSid,
                                        &psidLocalSystem );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Local System SID failed\n"
            ));

        goto exit;
    }
    
    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(ea, sizeof(ea));

    //
    // Now setup the access structure to allow POWER_USERS
    // read access.
    //
    //
    // Setup POWER_USERS for read access.
    //
    SetExplicitAccessSettings(  &(ea[0]), 
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidPowerUser );

    //
    // Setup Administrators for read access.
    //
    SetExplicitAccessSettings(  &(ea[1]), 
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidAdmin );

    //
    // Setup System Operators for read access.
    //
    SetExplicitAccessSettings(  &(ea[2]), 
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidSystemOperator );
  
    //
    // Setup Local System for all access.
    //
    SetExplicitAccessSettings(  &(ea[3]), 
                                FILE_MAP_ALL_ACCESS,
                                SET_ACCESS,
                                psidLocalSystem );


    //
    // Setup Perf Mon User for read access.
    //
    SetExplicitAccessSettings(  &(ea[4]),
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidPerfMonUser );

    //
    // Setup Perf Log User for read access.
    //
    SetExplicitAccessSettings(  &(ea[5]),
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidPerfLogUser );
    
    //
    // Create a new ACL that contains the new ACEs.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS), ea, NULL, &pACL);
    if ( dwErr != ERROR_SUCCESS ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    } 

    if (!SetSecurityDescriptorDacl(&sd, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    } 

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    hFile = CreateFileMapping(INVALID_HANDLE_VALUE
                                    , &sa   
                                    , PAGE_READWRITE
                                    , 0
                                    , SizeOfData
                                    , pFileName );

    dwErr = GetLastError();
    if ( dwErr != ERROR_SUCCESS ) 
    {
        goto exit;
    }

    //
    // If we got the file, then we need to map the view of the file.
    //
    pFile = MapViewOfFile(hFile
                        , FILE_MAP_ALL_ACCESS
                        , 0
                        , 0
                        , 0 );

    if ( pFile == NULL )
    {
        dwErr = GetLastError();

        goto exit;
    }
exit:

    //
    // Clean up the security handles used.
    //

    //
    // Function will only free if the 
    // variable is set.  And it will set
    // the variable to NULL once it is done.
    //
    FreeWellKnownSid(&psidPowerUser);
    FreeWellKnownSid(&psidSystemOperator);
    FreeWellKnownSid(&psidLocalSystem);
    FreeWellKnownSid(&psidAdmin);
    FreeWellKnownSid(&psidPerfMonUser);
    FreeWellKnownSid(&psidPerfLogUser);

    if (pACL) 
    {
        LocalFree(pACL);
        pACL = NULL;
    }

    if ( dwErr != ERROR_SUCCESS )
    {
        if (pFile != NULL)
        {
            UnmapViewOfFile(pFile);
            pFile = NULL;
        }

        if (hFile != NULL)
        {
            CloseHandle(hFile);
            hFile = NULL;
        }
    }
    else
    {
        *ppFile = pFile;
        *phFile = hFile;
    }

    return dwErr;
}

/***************************************************************************++

Routine Description:

    Opens a Memory Mapped file, open for reading.

Arguments:

     IN LPCWSTR pFileName   - Name of the file to open.
     OUT HANDLE* phFile     - Handle to the file
     OUT LPVOID* ppFile     - Pointer to the data in the file

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/
DWORD
OpenMemoryFile(
    IN LPCWSTR pFileName,
    OUT HANDLE* phFile,
    OUT LPVOID* ppFile
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hFile = NULL;
    LPVOID pFile = NULL;

    DBG_ASSERT(ppFile && phFile);

    // 
    // First release any files that these pointers may
    // currently be pointing to.  If we are resizing then
    // it is completely expected that we may have valid
    // pointers sent in that need to be released first.
    // 

    if ( *ppFile != NULL )
    {
        UnmapViewOfFile(*ppFile);
        *ppFile = NULL;
    }

    if ( *phFile != NULL )
    {
        CloseHandle(*phFile);
        *phFile = NULL;
    }

    hFile = OpenFileMapping(FILE_MAP_READ
                            , FALSE
                            , pFileName);

    if ( hFile == NULL )
    {
        dwErr = GetLastError();

        goto exit;
    }

    pFile = MapViewOfFile(hFile
                        , FILE_MAP_READ
                        , 0
                        , 0
                        , 0 );

    if ( pFile == NULL )
    {
        dwErr = GetLastError();

        goto exit;
    }
exit:

    if ( dwErr != ERROR_SUCCESS )
    {
        if (pFile != NULL)
        {
            UnmapViewOfFile(pFile);
            pFile = NULL;
        }

        if (hFile != NULL)
        {
            CloseHandle(hFile);
            hFile = NULL;
        }
    }
    else
    {
        *ppFile = pFile;
        *phFile = hFile;
    }

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\dll\main.cxx ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for Http Service on Windows NT.

Created:

  MuraliK   22-Feb-1995

Revision History:
  Murali R. Krishnan (MuraliK)  16-Nov-1995 Removed undoc apis

--*/

/************************************************************
 *   Include Headers
 ************************************************************/

#include "precomp.h"

// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

UINT
W3QueryStatisticsFromSharedMemory(
    LPW3_STATISTICS_1  pHttpStatistics
    );


/************************************************************
 *   Variable Definitions
 ************************************************************/

//
// Definition of the MIB objects
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          HttpServer(3)
//                                              HttpStatistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//

static UINT   sg_rguiPrefix[] =  { 1, 3, 6, 1, 4, 1, 311, 1, 7, 3};
static AsnObjectIdentifier sg_MibOidPrefix =
                      OID_FROM_UINT_ARRAY( sg_rguiPrefix);

# define HTTP_PREFIX_OID_LENGTH    ( GET_OID_LENGTH( sg_MibOidPrefix))

# define HTTP_STATISTICS_OID_SUFFIX            ( 1)


//
// Following is the global description of all MIB Entries ( Mibe s) for
//   Http Service.
// Definition appears as:
//  Mibe( MIB Entry Name, Index in MIB Block, HttpStatisticsField)
//
//   Incidentally, MIB Entry suffix coincides with the entry name in OID Tree
//
//  Any New MIB should be added here. and dont change use of after this defn.
//

# define ALL_MIB_ENTRIES()    \
Mibe( TotalBytesSent_HighWord,     1,    TotalBytesSent.HighPart)       \
Mibe( TotalBytesSent_LowWord,      2,    TotalBytesSent.LowPart)        \
Mibe( TotalBytesReceived_HighWord, 3,    TotalBytesReceived.HighPart)   \
Mibe( TotalBytesReceived_LowWord,  4,    TotalBytesReceived.LowPart)    \
Mibe( TotalFilesSent,              5,    TotalFilesSent)                \
Mibe( TotalFilesReceived,          6,    TotalFilesReceived)            \
Mibe( CurrentAnonymousUsers,       7,    CurrentAnonymousUsers)         \
Mibe( CurrentNonAnonymousUsers,    8,    CurrentNonAnonymousUsers)      \
Mibe( TotalAnonymousUsers,         9,    TotalAnonymousUsers)           \
Mibe( TotalNonAnonymousUsers,      10,   TotalNonAnonymousUsers)        \
Mibe( MaxAnonymousUsers,           11,   MaxAnonymousUsers)             \
Mibe( MaxNonAnonymousUsers,        12,   MaxNonAnonymousUsers)          \
Mibe( CurrentConnections,          13,   CurrentConnections)            \
Mibe( MaxConnections,              14,   MaxConnections)                \
Mibe( ConnectionAttempts,          15,   ConnectionAttempts)            \
Mibe( LogonAttempts,               16,   LogonAttempts)                 \
Mibe( TotalOptions,                17,   TotalOptions)                  \
Mibe( TotalGets,                   18,   TotalGets)                     \
Mibe( TotalPosts,                  19,   TotalPosts)                    \
Mibe( TotalHeads,                  20,   TotalHeads)                    \
Mibe( TotalPuts ,                  21,   TotalPuts)                     \
Mibe( TotalDeletes ,               22,   TotalDeletes)                  \
Mibe( TotalTraces ,                23,   TotalTraces)                   \
Mibe( TotalMove,                   24,   TotalMove)                     \
Mibe( TotalCopy,                   25,   TotalCopy)                     \
Mibe( TotalMkcol,                  26,   TotalMkcol)                    \
Mibe( TotalPropfind,               27,   TotalPropfind)                 \
Mibe( TotalProppatch,              28,   TotalProppatch)                \
Mibe( TotalSearch,                 29,   TotalSearch)                   \
Mibe( TotalLock,                   30,   TotalLock)                     \
Mibe( TotalUnlock,                 31,   TotalUnlock)                   \
Mibe( TotalOthers,                 32,   TotalOthers)                   \
Mibe( CurrentCGIRequests,          33,   CurrentCGIRequests)            \
Mibe( CurrentBGIRequests,          34,   CurrentBGIRequests)            \
Mibe( TotalCGIRequests,            35,   TotalCGIRequests)              \
Mibe( TotalBGIRequests,            36,   TotalBGIRequests)              \
Mibe( MaxCGIRequests,              37,   MaxCGIRequests)                \
Mibe( MaxBGIRequests,              38,   MaxBGIRequests)                \
Mibe( CurrentBlockedRequests,      39,   CurrentBlockedRequests)        \
Mibe( TotalBlockedRequests,        40,   TotalBlockedRequests)          \
Mibe( TotalAllowedRequests,        41,   TotalAllowedRequests)          \
Mibe( TotalRejectedRequests,       42,   TotalRejectedRequests)         \
Mibe( TotalNotFoundErrors,         43,   TotalNotFoundErrors)           \
Mibe( TotalLockedErrors,           44,   TotalLockedErrors)             \
Mibe( MeasuredBandwidth,           45,   MeasuredBw)                    \
Mibe( CurrentCalAuth,              46,   CurrentCalAuth)                \
Mibe( MaxCalAuth,                  47,   MaxCalAuth)                    \
Mibe( TotalFailedCalAuth,          48,   TotalFailedCalAuth)            \
Mibe( CurrentCalSsl,               49,   CurrentCalSsl)                 \
Mibe( MaxCalSsl,                   50,   MaxCalSsl)                     \
Mibe( TotalFailedCalSsl,           51,   TotalFailedCalSsl)


//
// Individual OID Definitions.
//   All Leaf variables should have a zero appended to their OID to indicate
//   that it is the only instance of this variable and that it exists.
//  Declare just the id's starting from next to the prefix given above.
//


//
// Few Convenience Macros for MIB entries addition.
//

# define MIB_VAR_NAME( NameSuffix)       MIB_ ## NameSuffix

# define DEFINE_MIBOID( NameSuffix, uiArray)   \
           UINT MIB_VAR_NAME( NameSuffix)[] = uiArray

# define DEFINE_MIBOID_LEAF( NameSuffix, NodeNumber) \
           UINT MIB_VAR_NAME( NameSuffix)[] = \
                          { HTTP_STATISTICS_OID_SUFFIX, ( NodeNumber), 0 }

//
// Define all the OIDs. First define the higher level node and then leaves.
//
DEFINE_MIBOID( Statistics,     { HTTP_STATISTICS_OID_SUFFIX} );

//
//  Define the Leaf OIDs.
//
# define Mibe( NameSuffix, Index, FieldName)  \
     DEFINE_MIBOID_LEAF( NameSuffix, Index);

//
// Expand the macro ALL_MIB_ENTRIES to obtain definitions of MIB Leafs.
//
ALL_MIB_ENTRIES()

# undef Mibe


//
//  MIB Variable definition
//

//
// Define Mibe()  to be for variable definitions of counters.
//  Note that the comma is appearing before a new counter name. It is used
//   for structure initialization.
//

# define OFFSET_IN_HTTP_STATISTICS( Field)    \
     FIELD_OFFSET( W3_STATISTICS_1,   Field)

# define Mibe( NameSuffix, Index, Field)        \
     , MIB_COUNTER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( NameSuffix)), \
                    OFFSET_IN_HTTP_STATISTICS(Field),              \
                    MibStatisticsWorker)

static MIB_ENTRY  sg_rgHttpMib[] = {

    //
    // Statistics
    //

    MIB_ENTRY_HEADER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( Statistics)))
    ALL_MIB_ENTRIES()
};

# undef Mibe




static MIB_ENTRIES  sg_HttpMibs =
  {
    &sg_MibOidPrefix,
    ( sizeof( sg_rgHttpMib) / sizeof( MIB_ENTRY)),
    sg_rgHttpMib
  };


/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    Http MIB DLL. It initialises local variables and prepares the
    interface for the process to use SNMP Extension Agents for HTTP service.

 Messages            Actions

    ProcessAttach        Initializes winsock and data structures.
                          It fails if winsock has not already been started.

    ProcessDetach        Cleans up local data structures and disconnects from
                         winsock.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  DWORD Success = ERROR_SUCCESS;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH: {

        //
        // Initialize various modules
        //

        CREATE_DEBUG_PRINT_OBJECT( WEB_ADMIN_SERVICE_NAME_A );

        LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_W3SVC_PARAMETERS_A, 0 );

        Success = VALID_DEBUG_PRINT_OBJECT();

        if ( ! Success )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Debug print object is not valid\n"
                ));

            goto exit;
        }


        break;
    } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH: {

       //
       // Only cleanup when we are called because of a FreeLibrary().
       //  i.e., when lpvContext == NULL
       // If we are called because of a process termination, dont free anything
       //   the system will free resources and memory for us.
       //

       if ( lpvContext == NULL) {

           //
           // Code to be executed on successful termination
           //

           DELETE_DEBUG_PRINT_OBJECT();
       }


       break;
   } /* case DLL_PROCESS_DETACH */

   default:
       break;
  }    /* switch */
exit:

  return ( Success );
}  /* DllLibMain() */

/************************************************************
 *  Entry Points of SNMP Extension DLL For Http Service
 ************************************************************/

//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;

BOOL
SnmpExtensionInit(
    IN  DWORD                 dwTimeZeroReference,
    OUT HANDLE              * phPollForTrapEvent,
    OUT AsnObjectIdentifier * pAsnOidSupportedView
    )
/*++
  Description:
     The Extension Agent DLLs provide this entry point SnmpExtensionInit()
     to co-ordinate the initializations of the extension agent and the
     extendible  agent.
     The Extendible agent provides extension agent with a time zero reference.
     The Extension Agent provides Extendible agent with an Event Handle
         for communicating occurences of traps.
     The Extension Agent also provides Extendible agent with an ObjectId
         representing the root of the MIB structure
         that it (extension) supports.

  Arguments:
     dwTimeZeroReference    DWORD containing the Time Zero Reference for sync.
     phPollForTrapEvent     pointer to handle which on successful return
                             may contain an event handle to be polled for
                             traps.
     pAsnOidSupportedView   pointer to ASN ( Abstract Syntax Notation OID)
                             that contains the oid representing root of the
                             MIB structure.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{


    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *pAsnOidSupportedView = sg_MibOidPrefix; // NOTE!  structure copy

    //
    // Though the following is a handle, dont use INVALID_HANDLE_VALUE ( -1)
    //  because that constant is only for few people ( Win32). But all through
    //  NT invalid handle value is NULL ( 0).
    //

    *phPollForTrapEvent = NULL;

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return ( TRUE);

}   // SnmpExtensionInit()


BOOL
SnmpExtensionTrap(
    OUT AsnObjectIdentifier * pAsnOidEnterprise,
    OUT AsnInteger          * pAsniGenericTrap,
    OUT AsnInteger          * pAsniSpecificTrap,
    OUT AsnTimeticks        * pAsnTimeStamp,
    OUT RFC1157VarBindList  * pRfcVariableBindings
    )
/*++
  Description:
     This function is used to communicate traps to the Extendible Agent.
     The Extendible Agent will invoke this entry point when the trap event
      ( supplied at the initialization time) is asserted, which indicates
      that zero or more traps had occured.
     The Extendible agent will repeatedly query this function till this
      function returns FALSE.

  Arguments:
    pAsnOidEnterprise      pointer to ASN OID for Enterprise, indicating
                             original enterprise generating trap.
    pAsniGenericTrap       pointer to ASN Integer which on return will
                             contain the indication of the generic trap.
    pAsniSpecificTrap      pointer to ASN Integer which on return will
                             contain the specific trap generated.
    pAsnTimeStamp          pointer to ASN containing the received Time-Stamp.
    pRfcVariableBindings   pointer to RFC 1157 compliant variable bindings.


  Returns:
    TRUE if success and there are more traps to be queried.
    FALSE if all traps are answered and work done.

--*/
{

    //
    //  We don't support traps (yet).
    //

    return ( FALSE);

}   // SnmpExtensionTrap()


BOOL
SnmpExtensionQuery(
    IN BYTE                     bRequestType,
    IN OUT RFC1157VarBindList * pRfcVariableBindings,
    OUT AsnInteger         *    pAsniErrorStatus,
    OUT AsnInteger         *    pAsniErrorIndex
    )
/*++
  Description:
    This function is called by Extendible Agent to resolve the SNMP requests
    for queries on MIB Variables in the Extension Agent's supported MIB view.
    ( which was supplied at initialization time).
    The Request Type is GET, GETNEXT, and SET.

  Arguments:
    bRequestType    byte containing the type of request.
                    It can be one of
                     ASN_RFC1157_GETREQUEST
                     ASN_RFC1157_GETNEXTREQUEST
                     ASN_RFC1157_SETREQUEST

    pRfcVariableBindings
                   pointer to RFC 1157 compliant variable bindings.

    pAsniErrorStatus
                   pointer to ASN Integer for Error Status

    pAsniErrorIndex
                  pointer to ASN INteger giving the index for error.

  Returns:
    TRUE on success and FALSE on failure.
--*/

{
    W3_STATISTICS_1    HttpStatistics;
    NET_API_STATUS     Status;



    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //
    Status = W3QueryStatisticsFromSharedMemory(
                             &HttpStatistics );

    //
    //  Status Errors not checked for  here!
    //  Reason:
    //    If the verb is GET_NEXT beyond the block we support,
    //           then there is no need to worry about the error at all.
    //    If the verb is GET within the block, it will get NULL value
    //           ( due the memset() done above).
    //

    _try
    {
        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        RFC1157VarBind * pVarBinding;

        for( pVarBinding = pRfcVariableBindings->list;
            pVarBinding < ( pRfcVariableBindings->list +
                            pRfcVariableBindings->len);
            pVarBinding++ ) 
       {

            *pAsniErrorStatus = ResolveVarBinding( pVarBinding,
                                                  bRequestType,
                                                  &HttpStatistics,
                                                  &sg_HttpMibs);

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if(( *pAsniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
               ( bRequestType == MIB_GETNEXT ) ) 
            {


                *pAsniErrorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

                SNMP_oidfree( &pVarBinding->name );
                SNMP_oidcpy( &pVarBinding->name, &sg_MibOidPrefix);
                pVarBinding->name.ids[ HTTP_PREFIX_OID_LENGTH - 1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            *pAsniErrorIndex =
              (( *pAsniErrorStatus != SNMP_ERRORSTATUS_NOERROR ) ?
               (( DIFF(pVarBinding - pRfcVariableBindings->list)) + 1) : 0);

        } // for

    } // try
    _except ( EXCEPTION_EXECUTE_HANDLER   ) 
    {

        //
        //  For now do nothing.
        //


    }



    return ( SNMPAPI_NOERROR);
}   // SnmpExtensionQuery()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\test\main.cpp ===
#include "iis.h"
#include "stdio.h"

#define g_Usage L"Usage\n"
#define g_NotUsage L"NotUsage\n"

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;

    if ( ( argc < 4 ) || ( argc > 5 ) )
    {
        wprintf( g_Usage );
        goto exit;
    }
	else
	{
		wprintf( g_NotUsage );
	}


exit:

    return ( INT ) hr;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\dll\mib.h ===
/*++  BUILD Version: 001   // Increment this if a change has global effects

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.h

   Abstract:

     Generic Macros and Functions for SNMP Extension Agent for
       gathering statistics information for Internet Services on NT.

   Author:

       Murali R. Krishnan    ( MuraliK )    22-Feb-1995

   Environment:

      User Mode -- Win32

   Project:

      HTTP Server SNMP MIB DLL

   Revision History:

--*/

# ifndef _MIB_H_
# define _MIB_H_

/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <snmp.h>

#include <lm.h>
#include <iisinfo.h>


/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
//  MIB function actions.
//

#define MIB_GET         ( ASN_RFC1157_GETREQUEST)
#define MIB_SET         ( ASN_RFC1157_SETREQUEST)
#define MIB_GETNEXT     ( ASN_RFC1157_GETNEXTREQUEST)
#define MIB_GETFIRST    ( ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0 )


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3



/************************************************************
 *   Type Definitions
 ************************************************************/


typedef UINT ( * LPMIBFUNC)(
                            RFC1157VarBind    *  pRfcVarBind,
                            UINT                 Action,
                            struct _MIB_ENTRY *  pMibeCurrent,
                            struct _MIB_ENTRIES* pMibEntries,
                            LPVOID               pStatistics
                            );


typedef struct _MIB_ENTRY  {

    AsnObjectIdentifier   asnOid;       // OID for mib variable
    LONG                  lFieldOffset; // filed offset
    UINT                  uiAccess;     // type of accesss( R, W, R/W, None)
    LPMIBFUNC             pMibFunc;     // ptr to function managing this var.
    BYTE                  bType;        // Type( integer, counter, gauage).

} MIB_ENTRY, FAR * LPMIB_ENTRY;


typedef struct  _MIB_ENTRIES {

    AsnObjectIdentifier  *  pOidPrefix;  // Oid with prefix for MIB ENTRIES
    int                     cMibEntries; // count of MIB_ENTRIES in the array
    LPMIB_ENTRY             prgMibEntry; // ptr to array of MIB_ENTRIES

} MIB_ENTRIES, FAR * LPMIB_ENTRIES;


/************************************************************
 *    Macros convenient for defining above MIB_ENTRY objects
 ************************************************************/

//
// GET_OID_LENGTH( oid)  gets the length of the oid.
//

# define  GET_OID_LENGTH( oid)           ((oid).idLength)

//
//  Macro to determine number of sub-oid's in an array of UINTs.
//

#define OID_SIZEOF( uiArray )      ( sizeof( uiArray) / sizeof(UINT) )

//
// OID_FROM_UINT_ARRAY():  Macro to define OID from an Array of UINTs
//
# define OID_FROM_UINT_ARRAY( uiArray)   { OID_SIZEOF( uiArray), uiArray }


//
// Macros for creating MIB Entries ( as specified in struct _MIB_ENTRY above)
//  MIB_ENTRY_HEADER:  creates a generic MIB_ENTRY for a MIB group header.
//  MIB_ENTRY_ITEM:    creates a generic MIB_ENTRY for a MIB variable.
//  MIB_COUNTER:       creates a counter type MIB_ENTRY
//  MIB_INTEGER:       creates an integer type MIB_ENTRY
//

# define MIB_ENTRY_HEADER( oid)             \
           {   oid,                         \
               -1,                          \
               MIB_NOACCESS,                \
               NULL,                        \
               ASN_RFC1155_OPAQUE,          \
           }

# define MIB_ENTRY_ITEM( oid, offset, access, type, func)  \
           {   oid,            \
               offset,         \
               access,         \
               ( func),        \
               ( type),        \
           }

# define MIB_COUNTER( oid, field, func)    \
     MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_RFC1155_COUNTER, func)

# define MIB_INTEGER( oid, field, func)    \
           MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_INTEGER, func)



/************************************************************
 *    Function Prototypes
 ************************************************************/

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind * pRfcVarBinding,
   IN BYTE                 pduAction,
   IN LPVOID               pStatistics,
   IN LPMIB_ENTRIES        pMibEntries
  );


UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   );



# endif // _MIB_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\dll\mib.cxx ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.cxx

   Abstract:

      This defines Auxiliary functions for defining an SNMP Extension Agent
         for collecting and querying Statistical information.

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Feb-1995
       Emily  B. Kruglick    ( EmilyK)       02-Nov-2000  ( converted for IIS 6 )

   Environment:

       User Mode -- Win32

   Project:

       SNMP Extension DLL for HTTP Service DLL

   Functions Exported:

     UINT  ResolveVarBinding();
     UINT  MibStatisticsWorker();

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.h"

static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  );

static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics
  );


static VOID
PrintAsnObjectIdentifier( IN char * pszOidDescription,
                          IN AsnObjectIdentifier * pAsno)
{

    UINT len = pAsno->idLength;
    UINT i;

    DBG_ASSERT( pAsno != NULL);

    DBGPRINTF( ( DBG_CONTEXT,
                "Printing Oid %s = %08x. Length = %u.\n",
                pszOidDescription,
                pAsno, len));

    for(i = 0; i < len; i++) 
    {
        DBGPRINTF( ( DBG_CONTEXT,
                    "AsnOid[ %u] = %u\n",
                    i, pAsno->ids[i]));
    }

    return;
} // PrintAsnObjectIdentifier()



/************************************************************
 *    Functions
 ************************************************************/

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind   * pRfcVarBinding,
   IN BYTE                   pduAction,
   IN LPVOID                 pStatistics,
   IN LPMIB_ENTRIES          pMibEntries
  )
/*++
  Description:
    This function resolves a single variable binding. Modifies the variable
       on a GET or a GET-NEXT.

  Arguments:
     pRfcVarBinding    pointer to RFC Variable Bindings
     pduAction      Protocol Data Unit Action specified.
     pStatistics    pointer to statisitcs data structure containing
                      values of counter data.
     pMibEntries    pointer to MIB_ENTRIES context information
                      which contains prefix, array of MIB_ENTRIES and
                      count of the entries.
  Returns:
    Standard PDU error codes.

  Note:
--*/
{
    AsnObjectIdentifier  AsnTempOid;
    LPMIB_ENTRY  pMibScan;
    UINT         pduResult = SNMP_ERRORSTATUS_NOERROR;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // Search for the variable binding name in the mib.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT ) 
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding( Var=%08x, Action=%x) called.\n",
                    pRfcVarBinding, pduAction));

        PrintAsnObjectIdentifier( " Variable to Resolve",
                                 &pRfcVarBinding->name);
    }

    for( pMibScan = pMibEntries->prgMibEntry;
        pMibScan < pMibUpperBound;
        pMibScan++) {

        int iCmpResult;

        //
        // Create a fully qualified OID for the current item in the MIB.
        //  and use it for comparing against variable to be resolved.
        //

        SNMP_oidcpy( &AsnTempOid, pMibEntries->pOidPrefix);
        SNMP_oidappend( &AsnTempOid, &pMibScan->asnOid);

        iCmpResult = SNMP_oidcmp( &pRfcVarBinding->name, &AsnTempOid);
        SNMP_oidfree( &AsnTempOid);

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT ) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        " Comparing with suffix Oid  %08x yields %d\n",
                        &pMibScan->asnOid, iCmpResult));
            PrintAsnObjectIdentifier( " StatisticsSuffix",
                                      &pMibScan->asnOid);
        }

        if ( iCmpResult == 0) {

            //
            // Found a match. Stop the search and process.
            //

            break;

        } else
          if ( iCmpResult < 0) 
          {

              //
              // This could be the OID of a leaf ( withoug a trailing 0) or
              //  it could contain an invalid OID ( between valid OIDs).
              //

              if ( pduAction == MIB_GETNEXT) {

                  //
                  // Advance the variable binding to next entry
                  //
                  SNMP_oidfree( &pRfcVarBinding->name);
                  SNMP_oidcpy( &pRfcVarBinding->name,
                                pMibEntries->pOidPrefix);
                  SNMP_oidappend( &pRfcVarBinding->name, &pMibScan->asnOid);

                  if ( ( pMibScan->bType != ASN_RFC1155_OPAQUE) &&
                       ( pMibScan->bType != ASN_SEQUENCE)) 
                  {
                      pduAction = MIB_GET;
                  }

              } else 
              {
                  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              }

              //
              // Stop and process the appropriate entry.
              //

              break;
          } // ( iCmpResult < 0)

    } // for


    if ( pMibScan >= pMibUpperBound) 
    {
        pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) 
    {
        //
        // A match is found or further processing is required.
        //

        DBG_ASSERT( pMibScan < pMibUpperBound);
        if ( pMibScan->pMibFunc == NULL) 
        {
            //
            // This happens only if the match is for Group OID
            //

            pduResult = ( ( pduAction != MIB_GETNEXT) ?
                       SNMP_ERRORSTATUS_NOSUCHNAME:
                         MibGetNextVar( pRfcVarBinding,
                                       pMibScan,
                                       pMibEntries,
                                       pStatistics));
        } 
        else 
        {

            pduResult = ( pMibScan->pMibFunc) ( pRfcVarBinding,
                                               pduAction,
                                               pMibScan,
                                               pMibEntries,
                                               pStatistics);
        }
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT ) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding returns %u.\n",
                    pduResult));
    }

    return ( pduResult);

} // ResolveVarBinding()



UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT   pduResult = SNMP_ERRORSTATUS_NOERROR;
                 // default indicating action to be done at end of switch

    switch( pduAction) 
    {

      case MIB_SET:
      case MIB_GETNEXT:

        // action is performed at the end of switch statement.
        break;


      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  If no statistics do no action.
        //  If this is the header field ( non-leaf) do no action
        //   Otherwise, perform action as if this is the leaf node.
        //

        if ( pStatistics == NULL || pMibeCurrent->lFieldOffset == -1) {

            pduResult = SNMP_ERRORSTATUS_GENERR;
        }

        // Action on this node is performed at the end of the switch statement.
        break;

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch()


    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) 
    {

        //
        // Use the generic leaf function to perform the action specified.
        //
        pduResult = MibLeafFunction( pRfcVarBinding, pduAction, pMibeCurrent,
                                    pMibEntries, pStatistics);
    }

    return ( pduResult);

} // MibStatisticsWorker()


static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics
    and that this is a leaf node of the MIB tree.
  This is a generic function for leaf nodes.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;  // default is error value.

    switch( pduAction ) 
    {
      case MIB_GETNEXT:

        //
        //  Determine if we're within the range and not at the end.
        //  If not within the range the above default pduResult == NOSUCHNAME
        //         is the required error message.
        //

        if ( ( pMibeCurrent >= pMibEntries->prgMibEntry) &&
             ( pMibeCurrent <
              ( pMibEntries->prgMibEntry + pMibEntries->cMibEntries))) 
        {

            pduResult = MibGetNextVar( pRfcVarBinding,
                                      pMibeCurrent,
                                      pMibEntries,
                                      pStatistics);
        }

        break;

      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  Make sure that this variable's ACCESS is GET'able.
        //  If the access prohibits from GETting it, report error as
        //    NOSUCHNAME ( default value of pduResult in initialization above)
        //

        if(( pMibeCurrent->uiAccess == MIB_ACCESS_READ ) ||
           ( pMibeCurrent->uiAccess == MIB_ACCESS_READWRITE ) ) 
        {

            DWORD  dwValue;

            //
            //  Setup pRfcVarBinding's return value.
            //

            DBG_ASSERT( pStatistics != NULL);

            pRfcVarBinding->value.asnType = pMibeCurrent->bType;
            dwValue = *( (LPDWORD )((LPBYTE )pStatistics +
                                    pMibeCurrent->lFieldOffset));

            pduResult = SNMP_ERRORSTATUS_NOERROR;  // we found a value.

            switch( pMibeCurrent->bType)  {

              case ASN_RFC1155_GAUGE:
                pRfcVarBinding->value.asnValue.gauge = (AsnGauge ) dwValue;
                break;

              case ASN_RFC1155_COUNTER:
                pRfcVarBinding->value.asnValue.counter = (AsnCounter ) dwValue;
                break;

              case ASN_INTEGER:
                pRfcVarBinding->value.asnValue.number = (AsnInteger ) dwValue;
                break;

              case ASN_RFC1155_IPADDRESS:
              case ASN_OCTETSTRING:
                //
                //  Not supported for this MIB (yet).
                //  Fall through to indicate generic error.
                //

              default:

                //
                // Sorry! Type in Mibe does not suit our purpose.
                //   Indicate generic error.
                //
                pduResult = SNMP_ERRORSTATUS_GENERR;
                break;
            } // innner switch

        } // if ( valid read access)

        break;

      case MIB_SET:

        //
        //  We don't support settable variables (yet).
        //   Fall through for error.
        //

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch ( pduAction)


    return ( pduResult);

} // MibLeafFunction()

static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics)
/*++
  Description:
     This function sets the binding variable to iterate to the next variable.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.

  Returns:
     PDU Error Codes.
--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // If within the range of MIB ENTRIES process.
    //

    if ( pMibeCurrent >= pMibEntries->prgMibEntry) 
    {

        //
        //  Scan through the remaining MIB Entries
        //

        LPMIB_ENTRY  pMibeScan;

        for( pMibeScan = pMibeCurrent+1;
             pMibeScan < pMibUpperBound;
             pMibeScan++ ) {

            //
            // Setup variable bindings for the next MIB variable
            //

            SNMP_oidfree( &pRfcVarBinding->name);
            SNMP_oidcpy( &pRfcVarBinding->name, pMibEntries->pOidPrefix);
            SNMP_oidappend( &pRfcVarBinding->name, &pMibeScan->asnOid);

            //
            //  If the function pointer is not NULL and the type of the MIB
            //  variable is anything but OPAQUE, then call the function to
            //  process the MIB variable.
            //

            if(( pMibeScan->pMibFunc != NULL ) &&
               ( pMibeScan->bType    != ASN_RFC1155_OPAQUE ) ) 
            {

                pduResult = ( pMibeScan->pMibFunc)( pRfcVarBinding,
                                                   MIB_GETFIRST,
                                                   pMibeScan,
                                                   pMibEntries,
                                                   pStatistics);
                break;
            }

            //
            // On failure in the scan, pduResult will have default value
            //    as initialized above in declaration.
            //

        } // for
    }

    return ( pduResult);

} // MibGetNextVar()

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\dll\shared_mem_mib.cxx ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    2000    Microsoft Corporation

   Module  Name :

      shared_memory_mib.cxx

   Abstract:

      This file defines the shared memory routine that is used to get
      data from IIS 6, and beyond.

   Author:

       Emily B. Kruglick    ( EmilyK )     30-Nov-2000

   Environment:

       User Mode -- Win32

   Project:

       SNMP Extension DLL for HTTP Service DLL

   Functions Exported:

     UINT  W3QueryStatisticsFromSharedMemory();

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "precomp.h"

typedef struct _SNMP_PROP_MAP
{
    DWORD OffsetInW3Block;
    DWORD OffsetInW3_STATISTICS_1Block;
    DWORD Size;
} SNMP_PROP_MAP;

#define SNMP_MAP(w3name, statname) \
    { FIELD_OFFSET( W3_COUNTER_BLOCK, w3name ), \
    FIELD_OFFSET( W3_STATISTICS_1, statname), \
    RTL_FIELD_SIZE(W3_COUNTER_BLOCK, w3name) }


SNMP_PROP_MAP aSNMPPropMap[] =
{
    SNMP_MAP(BytesSent,             TotalBytesSent),
    SNMP_MAP(BytesReceived,         TotalBytesReceived),
    SNMP_MAP(FilesSent,             TotalFilesSent),
    SNMP_MAP(FilesReceived,         TotalFilesReceived),
    SNMP_MAP(CurrentAnonymous,      CurrentAnonymousUsers),
    SNMP_MAP(CurrentNonAnonymous,   CurrentNonAnonymousUsers),
    SNMP_MAP(TotalAnonymous,        TotalAnonymousUsers),
    SNMP_MAP(TotalNonAnonymous,     TotalNonAnonymousUsers),
    SNMP_MAP(MaxAnonymous,          MaxAnonymousUsers),
    SNMP_MAP(MaxNonAnonymous,       MaxNonAnonymousUsers),
    SNMP_MAP(CurrentConnections,    CurrentConnections),
    SNMP_MAP(MaxConnections,        MaxConnections),
    SNMP_MAP(ConnectionAttempts,    ConnectionAttempts),
    SNMP_MAP(LogonAttempts,         LogonAttempts),

    SNMP_MAP(TotalOptions,          TotalOptions),
    SNMP_MAP(TotalGets,             TotalGets),
    SNMP_MAP(TotalPosts,            TotalPosts),
    SNMP_MAP(TotalHeads,            TotalHeads),
    SNMP_MAP(TotalPuts,             TotalPuts),
    SNMP_MAP(TotalDeletes,          TotalDeletes),
    SNMP_MAP(TotalTraces,           TotalTraces),
    SNMP_MAP(TotalMove,             TotalMove),
    SNMP_MAP(TotalCopy,             TotalCopy),
    SNMP_MAP(TotalMkcol,            TotalMkcol),
    SNMP_MAP(TotalPropfind,         TotalPropfind),
    SNMP_MAP(TotalProppatch,        TotalProppatch),
    SNMP_MAP(TotalSearch,           TotalSearch),
    SNMP_MAP(TotalLock,             TotalLock),
    SNMP_MAP(TotalUnlock,           TotalUnlock),
    SNMP_MAP(TotalOthers,           TotalOthers),      
    SNMP_MAP(TotalCGIRequests,      TotalCGIRequests),
    SNMP_MAP(TotalBGIRequests,      TotalBGIRequests),
    SNMP_MAP(TotalNotFoundErrors,   TotalNotFoundErrors),
    SNMP_MAP(TotalLockedErrors,     TotalLockedErrors),

    SNMP_MAP(CurrentCalAuth,        CurrentCalAuth),
    SNMP_MAP(MaxCalAuth,            MaxCalAuth),
    SNMP_MAP(TotalFailedCalAuth,    TotalFailedCalAuth),
    SNMP_MAP(CurrentCalSsl,         CurrentCalSsl),
    SNMP_MAP(MaxCalSsl,             MaxCalSsl),
    SNMP_MAP(TotalFailedCalSsl,     TotalFailedCalSsl),

    SNMP_MAP(CurrentCGIRequests,    CurrentCGIRequests),
    SNMP_MAP(CurrentBGIRequests,    CurrentBGIRequests),
    SNMP_MAP(MaxCGIRequests,        MaxCGIRequests),
    SNMP_MAP(MaxBGIRequests,        MaxBGIRequests),

    SNMP_MAP(MeasuredBandwidth,     MeasuredBw),
    SNMP_MAP(ServiceUptime,         ServiceUptime),

};
DWORD cSNMPPropMap = sizeof (aSNMPPropMap) / sizeof( SNMP_PROP_MAP );

/***************************************************************************++

Routine Description:

   Helper function to hook up to shared memory when we are ready to 
   provide counters.

Arguments:

    None.

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD
HookUpSharedMemory(
    PERF_SM_MANAGER* pManager
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( pManager );


    //
    // Initialize the memory manager for readonly access
    //
    dwErr = pManager->Initialize(FALSE);
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // Initialize a reader to point to the appropriate
    // counter set.
    //
    dwErr = pManager->CreateNewCounterSet( SITE_COUNTER_SET );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }


exit:

    return dwErr;
}


/***************************************************************************++

Routine Description:

    Hooks up to shared memory, and grabs the appropriate counters
    for the snmp counters.  Then returns them to the main processing
    code in the same form that was expected in IIS 5.

Arguments:

    None.

Return Value:

    UINT

--***************************************************************************/
UINT
W3QueryStatisticsFromSharedMemory(
    LPW3_STATISTICS_1  pHttpStatistics
    )
{

    PERF_SM_MANAGER Manager;
    DWORD dwErr = ERROR_SUCCESS;
    LPBYTE pW3Counters = NULL;

    DBG_ASSERT ( pHttpStatistics );

    //
    // Make sure we clear this out, because there are some counters
    // which we no longer support.
    //
    memset ( pHttpStatistics, 0, sizeof( W3_STATISTICS_1 ) );

    // Open up shared memory.

    dwErr = HookUpSharedMemory(&Manager);
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // Delay, if we need to wait for counters to be refreshed.
    // if we eventually have logging in snmp then we should
    // log if we were not able to get fresh counters.
    Manager.EvaluateIfCountersAreFresh();

    // Request the counters.
    dwErr = Manager.GetSNMPCounterInfo( &pW3Counters );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    // Copy out the appropriate values.
    for ( DWORD index = 0; index < cSNMPPropMap ; index ++ )
    {
        LPBYTE Source = pW3Counters + aSNMPPropMap[index].OffsetInW3Block;
        LPBYTE Destination = ( LPBYTE ) pHttpStatistics + aSNMPPropMap[index].OffsetInW3_STATISTICS_1Block;

        if ( aSNMPPropMap[index].Size == sizeof ( DWORD ) )
        {
            * ( DWORD * ) Destination = * ( DWORD * ) Source;
        }
        else
        {
            DBG_ASSERT ( aSNMPPropMap[index].Size == sizeof ( ULONGLONG ) );

            * ( ULONGLONG * ) Destination = * ( ULONGLONG * ) Source;
        }
    }

    Manager.PingWASToRefreshCounters();

exit:

    //
    // Note, when the Manager distructs, we will let go of the shared memory.
    //

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\dll\precomp.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        22-Jul-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include "iis.h"
#include "iis64.h"
#include <winperf.h>  
#include <limits.h>

#include "mib.h"
#include "apiutil.h"

#include "regconst.h"

#include "wasdbgut.h"
#include "perf_sm.h"
#include "perfcount.h" 

#include "inetinfo.h"


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\test\makefile.inc ===
$(O)\snmp.res: snmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\main.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Main entry points for the perf lib dll.

Author:

    Emily Kruglick (EmilyK)   11-Sep-2000

Revision History:

--*/

#include "precomp.h"

//
// global variables
//

// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

extern CRITICAL_SECTION g_IISMemManagerCriticalSection;
extern PERF_SM_MANAGER* g_pIISMemManager;
extern LONG             g_IISNumberInitialized;
extern HANDLE           g_hWASProcessWait;


/***************************************************************************++

Routine Description:

    The dll entry point. Used to set up debug libraries, etc.

Arguments:

    DllHandle - The dll module handle for this dll. Does not need to be
    closed.

    Reason - The dll notification reason.

    pReserved - Reserved, not used.

Return Value:

    BOOL

--***************************************************************************/

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE DllHandle,
    DWORD Reason,
    LPVOID pReserved
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;

    UNREFERENCED_PARAMETER( pReserved );

    switch ( Reason )
    {

    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( WEB_ADMIN_SERVICE_NAME_A );

        LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_W3SVC_PARAMETERS_A, 0 );

        Success = VALID_DEBUG_PRINT_OBJECT();

        if ( ! Success )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Debug print object is not valid\n"
                ));

            goto exit;
        }


        Success = DisableThreadLibraryCalls( DllHandle );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Disabling thread library calls failed\n"
                ));

            goto exit;
        }

        InitializeCriticalSection( &g_IISMemManagerCriticalSection );

        g_IISNumberInitialized = 0;
 
        g_pIISMemManager = NULL;

        g_hWASProcessWait = NULL;

        break;

    case DLL_PROCESS_DETACH:

        if ( g_hWASProcessWait != NULL )
        {
            if ( !UnregisterWait( g_hWASProcessWait ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Could not unregister the old process wait handle \n"
                    ));

            }

            g_hWASProcessWait = NULL;
        }

        // DBG_ASSERT ( g_pIISMemManager == NULL );

        DeleteCriticalSection ( &g_IISMemManagerCriticalSection );

        DELETE_DEBUG_PRINT_OBJECT();

        break;

    default:

        break;

    }


exit:

    return Success;

}   // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\entrypts.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    entrypts.cxx

    This file implements the Extensible Performance Objects for
    the iis counters.

    FILE HISTORY:
        EmilyK      24-Aug-2000 Created, based on w3ctrs code.

*/

#include "precomp.h"

//
//  common defines & globals
//
#define MAX_STRINGIZED_ULONG_CHAR_COUNT 11      // "4294967295", including the terminating null

DWORD g_IIS_SecondsToNotLogFor = 60 * 60 * 12;  // 60 seconds = 1 minute * 60 = 1 hour * 12 = 12 hours

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenW3PerformanceData;
PM_COLLECT_PROC CollectW3PerformanceData;
PM_CLOSE_PROC   CloseW3PerformanceData;

//
// Global object contecting to the site counters memory.
//
CRITICAL_SECTION g_IISMemManagerCriticalSection;
PERF_SM_MANAGER* g_pIISMemManager;
LONG             g_IISNumberInitialized;
HANDLE           g_hWASProcessWait;

// Pointer to the event log class so we can log problems with perf counters.
EVENT_LOG*        g_pEventLog = NULL;

//
// Private Supporting Functions
//

/***************************************************************************++

Routine Description:

   Looks up in the registry all the specific counter values
   that we need to be able to play nice with the other counters
   on the machine.
    
Arguments:

    None

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD EstablishIndexes()
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    PERF_COUNTER_DEFINITION* pDefinition = NULL;

    //
    //  Open the HTTP Server service's Performance key.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_A,
                        0,
                        KEY_QUERY_VALUE,
                        &hkey );

    if( err == NO_ERROR)
    {
    
        //
        //  Read the first counter DWORD.
        //
    
        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               "First Counter",
                               NULL,
                               &type,
                               (LPBYTE)&dwFirstCounter,
                               &size );
        if( err == NO_ERROR && type == REG_DWORD )
        {
            //
            //  Read the first help DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Help",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstHelp,
                                   &size );

            if ( err == NO_ERROR && type == REG_DWORD )
            {
                //
                // First establish all of the W3 Service Counters
                // ==============================================

                //
                //  Update the object & counter name & help indicies.
                //
                W3DataDefinition.W3ObjectType.ObjectNameTitleIndex
                    += dwFirstCounter;
                W3DataDefinition.W3ObjectType.ObjectHelpTitleIndex
                    += dwFirstHelp;

                // 
                // Figure out the first counter definition.  It starts
                // after the PERF_OBJECT_TYPE structure, which is the
                // first iten in the W3DataDefinition.
                //
                pDefinition = (PERF_COUNTER_DEFINITION*) ((LPBYTE) (&W3DataDefinition) 
                                                           + sizeof(PERF_OBJECT_TYPE));

                //
                // Now simply walk through the counters incrementing
                // the pDefinition by on PERF_COUNTER_DEFINITION as you go.
                //
                for (int i = 0; i < NUMBER_OF_W3_COUNTERS; i++, pDefinition++)
                {
                    pDefinition->CounterNameTitleIndex += dwFirstCounter;
                    pDefinition->CounterHelpTitleIndex += dwFirstHelp;
                }

                // 
                // Now do all of the W3 Global Service Counters
                // ============================================

                //
                //  Update the object & counter name & help indicies.
                //
                W3GlobalDataDefinition.W3GlobalObjectType.ObjectNameTitleIndex
                    += dwFirstCounter;
                W3GlobalDataDefinition.W3GlobalObjectType.ObjectHelpTitleIndex
                    += dwFirstHelp;

                // 
                // Figure out the first counter definition.  It starts
                // after the PERF_OBJECT_TYPE structure, which is the
                // first iten in the W3DataDefinition.
                //
                pDefinition =  (PERF_COUNTER_DEFINITION*) 
                                            ((LPBYTE) (&W3GlobalDataDefinition) 
                                                    + sizeof(PERF_OBJECT_TYPE));

                //
                // Now simply walk through the counters incrementing
                // the pDefinition by on PERF_COUNTER_DEFINITION as you go.
                //
                for ( int i = 0; 
                          i < NUMBER_OF_W3_GLOBAL_COUNTERS; 
                          i++, pDefinition++ )
                {
                    pDefinition->CounterNameTitleIndex += dwFirstCounter;
                    pDefinition->CounterHelpTitleIndex += dwFirstHelp;
                }

            }
        }

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }
        
    }

    return err;
}

/***************************************************************************++

Routine Description:

    Routine deletes the shared memory if it is in existence.

Arguments:

    None

Return Value:

    None

  Note:  It should always be called from inside a critical section.

--***************************************************************************/
VOID FreeSharedManager(BOOL HandleCallbackAsWell
    )
{

    //
    // Only clean up the callback handle if we are told
    // to, this is so we don't clean it up if we are 
    // in the middle of a callback call.
    //
    if ( HandleCallbackAsWell && g_hWASProcessWait )
    {
        if ( !UnregisterWait( g_hWASProcessWait ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(GetLastError()),
                "Could not unregister the old process wait handle \n"
                ));

        }

        g_hWASProcessWait = NULL;
    }

    //
    // Now clean up the shared memory object.
    //
    if ( g_pIISMemManager )
    {
        delete g_pIISMemManager;
        g_pIISMemManager = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Routine drops the shared memory if the managing process of the memory
    goes away.

Arguments:

    LPVOID lpParameter - Unused
    BOOL   bUnused     - Unused

Return Value:

    None

--***************************************************************************/
VOID CALLBACK ShutdownMemory(
    PVOID,
    BOOLEAN
    )
{

    EnterCriticalSection ( &g_IISMemManagerCriticalSection );

    FreeSharedManager(FALSE);

    LeaveCriticalSection ( &g_IISMemManagerCriticalSection );

}


/***************************************************************************++

Routine Description:

   Helper function to hook up to shared memory when we are ready to 
   provide counters.

Arguments:

    None.

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD
HookUpSharedMemory()
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD size = 0;
    DWORD type = 0;
    DWORD dwRegSettingValue = 0;
    HKEY  hkey = NULL;

    //
    // If we are not hooked up to the manager than hook up.
    //
    if ( !g_pIISMemManager )
    {
        //
        // Hook up to the manager of the shared memory.
        //
        g_pIISMemManager = new PERF_SM_MANAGER();
        if ( ! g_pIISMemManager )
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto exit;
        }

        //
        // Initialize the memory manager for readonly access
        //
        dwErr = g_pIISMemManager->Initialize(FALSE);
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        // This ( in the Initialize call above ) is when we read 
        // the wait times for the perf counters
        // from the registry so this is when we should set the logging
        // wait time as well.
        //
        dwErr = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                            REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_W,
                            0,
                            KEY_QUERY_VALUE,
                            &hkey );

        if( dwErr == ERROR_SUCCESS)
        {

            size = sizeof(DWORD);

            dwErr = RegQueryValueExW( hkey,
                                   REGISTRY_VALUE_W3SVC_PERF_EVENT_LOG_DELAY_OVERRIDE_W,
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwRegSettingValue,
                                   &size );
            if( dwErr == ERROR_SUCCESS && type == REG_DWORD )
            {
                if ( dwRegSettingValue != 0 )
                {
                    g_IIS_SecondsToNotLogFor = dwRegSettingValue;
                }
            }

            if( hkey != NULL )
            {
                RegCloseKey( hkey );
                hkey = NULL;
            }

        }

        // Press on in the face of errors.
        dwErr = ERROR_SUCCESS;

        //


        //
        // if we re-initialized then we need to setup the
        // wait on the process again.  it is possible that 
        // the previous wait has not been cleaned up (since
        // we can't clean it up in the callback function) so
        // if this is the case we need to clean it up first.
        //
        if ( g_hWASProcessWait != NULL )
        {
            if ( !UnregisterWait( g_hWASProcessWait ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Could not unregister the old process wait handle \n"
                    ));

            }

            g_hWASProcessWait = NULL;
        }
    
        //
        // Register to wait on the managing process,
        // so we release any shared memory if the managing
        // process shutsdown or crashes.
        //
        if ( !RegisterWaitForSingleObject( &g_hWASProcessWait,
                                          g_pIISMemManager->GetWASProcessHandle(),
                                          &ShutdownMemory,
                                          NULL,
                                          INFINITE,
                                          WT_EXECUTEONLYONCE | 
                                          WT_EXECUTEINIOTHREAD ) )
        {
            dwErr = GetLastError();
                        
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not register to wait on the process handle \n"
                ));

            goto exit;

        }

        //
        // Initialize a reader to point to the appropriate
        // counter set.
        //
        dwErr = g_pIISMemManager->CreateNewCounterSet( SITE_COUNTER_SET );
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        //
        // Initialize a reader to point to the appropriate
        // counter set.
        //
        dwErr = g_pIISMemManager->CreateNewCounterSet( GLOBAL_COUNTER_SET );
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }
    }

    //
    // Whether we just hooked up to the memory or not, we still want
    // to do one final check to make sure the memory is still valid.
    // It might have been invalidated in since the last gathering, or
    // it might have been invalidated while we were hooking up the 
    // wait on the process id.  Either way, if it is now not valid,
    // drop it.
    //

    if ( g_pIISMemManager->ReleaseIsNeeded() )
    {
        // 
        // The exit will take care of deleteing
        // the memory manager which will release 
        // the files.
        //
        dwErr = ERROR_NOT_READY;
        goto exit;
    }

exit:

    if ( dwErr != ERROR_SUCCESS )
    {
        FreeSharedManager(TRUE);
    }

    return dwErr;
}


//
//  Public Exported functions.
//

/***************************************************************************++

Routine Description:

   Is called to initialize any memory data structures needed for 
   supporting the performance counter publishing.
    
Arguments:


Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD OpenW3PerformanceData( LPWSTR )
{
    DWORD dwErr = ERROR_SUCCESS;
    static BOOL fInit = FALSE;


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Entering W3CTRS - OpenW3PerformanceData routine \n"
            ));
    }

    //
    // If we are the first one here then we can setup the
    // objects the correct way.  
    //
    // Note:  this is not neccessarily completely safe, but
    //        it really isn't that big of a problem if these
    //        objects get setup twice.
    //
    if ( !fInit )
    {
        //
        // Setup the event log so we can log errors.
        //
        // If this fails then the g_pEventLog will still
        // be null.  We would not fail in this case, and
        // since we do not have the event viewer we really
        // don't have any place to log a message.  We will
        // validate that this has been set before using it
        // throughout the code.
        //
        g_pEventLog = new EVENT_LOG(L"W3CTRS");

        //
        // Establish all machine static information about
        // the counters.
        //
        dwErr = EstablishIndexes();
        if ( dwErr != ERROR_SUCCESS )
        {
            if ( g_pEventLog )
            {
                g_pEventLog->
                    LogEvent(
                        W3_W3SVC_REGISTRATION_MAY_BE_BAD, // message id
                        0,                                // count of strings
                        NULL,                             // array of strings
                        HRESULT_FROM_WIN32(dwErr)         // error code
                        );
            }

            goto exit;
        }

        fInit = TRUE;


    }

exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Exiting W3CTRS - OpenW3PerformanceData routine \n"
            ));
    }

    return dwErr;

}   // OpenW3PerformanceData


/***************************************************************************++

Routine Description:

   Is called to retrieve counters from our library.
    
Arguments:

     LPWSTR    lpValueName      - Name fo the set of counters to retrieve.

     LPVOID  * lppData          - On entry contains a pointer to the buffer to
                                  receive the completed PerfDataBlock & subordinate
                                  structures.  On exit, points to the first bytes
                                  *after* the data structures added by this routine.

     LPDWORD   lpcbTotalBytes  - On entry contains a pointer to the
                                 size (in BYTEs) of the buffer referenced by lppData.
                                 On exit, contains the number of BYTEs added by this
                                 routine.

     LPDWORD   lpNumObjectTypes - Receives the number of objects added
                                  by this routine.

Return Value:

    DWORD             -  Win32 Error Code  (MUST be either NO_ERROR or ERROR_MORE_DATA)

--***************************************************************************/
DWORD CollectW3PerformanceData( 
     LPWSTR    lpValueName,
     LPVOID  * lppData,
     LPDWORD   lpcbTotalBytes,
     LPDWORD   lpNumObjectTypes 
     )
{
    DBG_ASSERT ( lppData );
    DBG_ASSERT ( lpcbTotalBytes );
    DBG_ASSERT ( lpNumObjectTypes );

    static DWORD    s_FirstFailureAt = 0;
    static DWORD    s_NumberOfTimesTookToLong = 0;

    LPVOID                  pData           = *lppData;

    COUNTER_GLOBAL_STRUCT*  pSiteObject     = NULL;
    LPVOID                  pSiteInstance   = NULL;
    COUNTER_GLOBAL_STRUCT*  pGlobalObject   = NULL;
    LPVOID                  pGlobalInstance = NULL;

    DWORD                   dwErr           = ERROR_SUCCESS;

    DWORD                   dwSiteSize      = 0;
    DWORD                   dwGlobalSize    = 0;
    DWORD                   dwTotalSize     = 0;

    DWORD                   dwQueryType     = GetQueryType( lpValueName );

    BOOL                    fGetSites       = TRUE;
    BOOL                    fGetGlobal      = TRUE;

    DWORD                   NumObjects      = 2;


    //
    // Figure out if it is a query type we do not support.
    //
    if (( dwQueryType == QUERY_FOREIGN ) || (dwQueryType == QUERY_COSTLY))
    {
        // We don't do foreign queries
        
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;

        return ERROR_SUCCESS;
    }

    //
    // If it is a query by item, then figure out if we own any of the
    // items it is referring to.
    //
    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        W3DataDefinition.W3ObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            fGetSites = FALSE;
            NumObjects--;

        }

        if( !IsNumberInUnicodeList(
                        W3GlobalDataDefinition.W3GlobalObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            fGetGlobal = FALSE;
            NumObjects--;
       
        }

        if ( NumObjects == 0 ) 
        {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;

            return ERROR_SUCCESS;
        }
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Entering W3CTRS - CollectW3PerformanceData routine \n"
            ));
    }

    // 
    // if we got this far then we know that we want to get something.
    //
    EnterCriticalSection ( &g_IISMemManagerCriticalSection );

    dwErr = HookUpSharedMemory();
    if ( dwErr != ERROR_SUCCESS )
    {
        DWORD dwSizeNeeded = 0; 

        DBG_ASSERT ( fGetSites || fGetGlobal );

        if ( fGetSites )
        {
            dwSizeNeeded += sizeof(W3DataDefinition) +
                            sizeof(PERF_INSTANCE_DEFINITION) +
                            (sizeof(WCHAR) * MAX_INSTANCE_NAME ) +
                            sizeof(W3_COUNTER_BLOCK);
        }

        if ( fGetGlobal )
        {
            dwSizeNeeded += sizeof( W3GlobalDataDefinition )
                            + sizeof( W3_GLOBAL_COUNTER_BLOCK );
        }

        if ( dwSizeNeeded > *lpcbTotalBytes )
        {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            dwErr = ERROR_MORE_DATA;
        }
        else
        {

            if ( fGetSites )
            {
                memcpy (pData, &W3DataDefinition, sizeof(W3DataDefinition));
                ((PERF_OBJECT_TYPE*) pData)->NumInstances = 1;
                ((PERF_OBJECT_TYPE*) pData)->TotalByteLength = sizeof(W3DataDefinition) +
                                                               sizeof(PERF_INSTANCE_DEFINITION) +
                                                               (sizeof(WCHAR) * MAX_INSTANCE_NAME) +
                                                               sizeof(W3_COUNTER_BLOCK);
                pData = (LPBYTE) pData + sizeof(W3DataDefinition);

                // Copy in a _Total instance

                // First Setup the Instance Definition

                ((PERF_INSTANCE_DEFINITION*) pData)->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) + 
                                                                  MAX_INSTANCE_NAME * sizeof(WCHAR);
                ((PERF_INSTANCE_DEFINITION*) pData)->ParentObjectTitleIndex = 0;
                ((PERF_INSTANCE_DEFINITION*) pData)->ParentObjectInstance = 0;
                ((PERF_INSTANCE_DEFINITION*) pData)->UniqueID = PERF_NO_UNIQUE_ID;
                ((PERF_INSTANCE_DEFINITION*) pData)->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
                ((PERF_INSTANCE_DEFINITION*) pData)->NameLength = (DWORD) ((wcslen(L"_Total") + 1) * sizeof(WCHAR));

                pData = (LPBYTE) pData + sizeof(PERF_INSTANCE_DEFINITION);

                // Next copy in the Instance Name including the 
                // NULL, we know we have enough room because of
                // the check above for size.
                wcsncpy ( (LPWSTR) pData, L"_Total", wcslen(L"_Total") + 1 );

                // To avoid suttle differences we use the same MAX_INSTANCE_NAME
                // amount of space even for this faked up _Total Site.
                pData = (LPBYTE) pData + ( MAX_INSTANCE_NAME * sizeof(WCHAR));

                // Lastly copy in a block of zero's for the _Total site data.
                memset ( pData, 0, sizeof(W3_COUNTER_BLOCK) );

                // This is setting the size in the structure, it is the first
                // DWORD in the W3_CONTER_BLOCK.
                *((DWORD*) (pData)) = sizeof(W3_COUNTER_BLOCK);
                pData = (LPBYTE) pData + sizeof(W3_COUNTER_BLOCK);
           
            }

            if ( fGetGlobal )
            {
                memcpy (pData, &W3GlobalDataDefinition, sizeof(W3GlobalDataDefinition));
                ((PERF_OBJECT_TYPE*) pData)->NumInstances = PERF_NO_INSTANCES;
                ((PERF_OBJECT_TYPE*) pData)->TotalByteLength = sizeof(W3GlobalDataDefinition) +
                                                               sizeof(W3_GLOBAL_COUNTER_BLOCK);
                pData = (LPBYTE) pData + sizeof(W3GlobalDataDefinition);

                // Copy in the actual data for global
                memset ( pData, 0, sizeof(W3_GLOBAL_COUNTER_BLOCK) );

                // This is setting the size in the structure, it is the first
                // DWORD in the W3_GLOBAL_CONTER_BLOCK.
                *((DWORD*) (pData)) = sizeof(W3_GLOBAL_COUNTER_BLOCK);
                pData = (LPBYTE) pData + sizeof(W3_GLOBAL_COUNTER_BLOCK);

            }

            // Make sure we didn't lie about the size.
            DBG_ASSERT ( dwSizeNeeded == DIFF((PCHAR) pData - (PCHAR) (*lppData)) );

            *lpcbTotalBytes = dwSizeNeeded;
            *lpNumObjectTypes = NumObjects;
            *lppData = pData;

            dwErr = ERROR_SUCCESS;
        
        }

        goto exit;
    }



    DBG_ASSERT ( g_pIISMemManager );

    //
    // Now check that the memory has been updated recently.  If it has 
    // not been then we need to ping WAS and let them know that we need
    // new data, and wait on that new data.
    //
    if ( ! g_pIISMemManager->EvaluateIfCountersAreFresh() )
    {
        if ( g_pEventLog )
        {
            IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Perf Counters did not refresh in a timely manner: \n"
                    "       CurrentSecondsCount = %d \n"
                    "       FirstFailure was %d \n"
                    "       Time to wait to restart is %d \n"
                    "       NumberFailures = %d \n",
                    GetCurrentTimeInSeconds(),
                    s_FirstFailureAt,
                    g_IIS_SecondsToNotLogFor,
                    s_NumberOfTimesTookToLong 
                    ));
            }

            if ( ( s_FirstFailureAt == 0 ) ||
                 ( ( s_FirstFailureAt + g_IIS_SecondsToNotLogFor ) < GetCurrentTimeInSeconds() ) )
            {
                s_FirstFailureAt = GetCurrentTimeInSeconds();
                s_NumberOfTimesTookToLong = 0;
            }


            s_NumberOfTimesTookToLong++;

            if ( s_NumberOfTimesTookToLong == 1 )
            {
                g_pEventLog->
                    LogEvent(
                        W3_W3SVC_REFRESH_TAKING_TOO_LONG, // message id
                        0,                                // count of strings
                        NULL,                             // array of strings
                        0                                // error code
                        );
            }

            if ( s_NumberOfTimesTookToLong == 2 )
            {
                DWORD Hours = g_IIS_SecondsToNotLogFor / 60 / 60;
                DWORD Minutes = ( g_IIS_SecondsToNotLogFor - ( Hours * 60 * 60 ) ) / 60;
                DWORD Seconds = g_IIS_SecondsToNotLogFor - ( Hours * 60 * 60 ) - ( Minutes * 60 ); 

                const WCHAR * EventLogStrings[1];

                // Format is "DWORD:DWORD:DWORD"  So 3 max dwords plus two colons and a null
                WCHAR StringizedTimeLimit[ (MAX_STRINGIZED_ULONG_CHAR_COUNT * 3) + 3 ];

                _snwprintf( StringizedTimeLimit, 
                            sizeof( StringizedTimeLimit ) / sizeof ( WCHAR ), 
                            L"%lu:%02lu:%02lu", 
                            Hours,
                            Minutes,
                            Seconds);

                EventLogStrings[0] = StringizedTimeLimit;

                g_pEventLog->
                    LogEvent(
                        W3_W3SVC_REFRESH_TAKING_TOO_LONG_STOPPING_LOGGING,                        // message id
                        sizeof( EventLogStrings ) / sizeof( const WCHAR * ),     // count of strings
                        EventLogStrings,                                         // array of strings
                        0                                                        // error code
                        );

                // if s_NumberOfTimesTookToLong is anything else
                // then we don't bother printing anything.
            }
        }
    }

    if ( fGetSites)
    {
        //
        // Get the counter information from shared memory.
        //
        dwErr = g_pIISMemManager->GetCounterInfo(SITE_COUNTER_SET, 
                                                 &pSiteObject, 
                                                 &pSiteInstance);
        if ( dwErr != ERROR_SUCCESS )
        {
            if ( g_pEventLog )
            {
                g_pEventLog->
                    LogEvent(
                        W3_UNABLE_QUERY_W3SVC_DATA,       // message id
                        0,                                // count of strings
                        NULL,                             // array of strings
                        HRESULT_FROM_WIN32(dwErr)         // error code
                        );
            }
       
            // 
            // According to the perf by laws you can only
            // return Success or More Data from here so 
            // we will need to log the error and then return
            // Success, since this does not mean we have more data.
            // 

            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            dwErr = ERROR_SUCCESS;

            goto exit;
        }

        dwSiteSize = sizeof(W3DataDefinition) + pSiteObject->SizeData;

    }


    if ( fGetGlobal )
    {
        //
        // Get the counter information from shared memory.
        //
        dwErr = g_pIISMemManager->GetCounterInfo(GLOBAL_COUNTER_SET, 
                                                 &pGlobalObject, 
                                                 &pGlobalInstance);
        if ( dwErr != ERROR_SUCCESS )
        {
            if ( g_pEventLog )
            {
                g_pEventLog->
                    LogEvent(
                        W3_UNABLE_QUERY_W3SVC_DATA,       // message id
                        0,                                // count of strings
                        NULL,                             // array of strings
                        HRESULT_FROM_WIN32(dwErr)         // error code
                        );
            }

            // 
            // According to the perf by laws you can only
            // return Success or More Data from here so 
            // we will need to log the error and then return
            // Success, since this does not mean we have more data.
            // 

            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            dwErr = ERROR_SUCCESS;

            goto exit;
        }

        dwGlobalSize = sizeof(W3GlobalDataDefinition) + 
                       pGlobalObject->SizeData;

    }

    //
    // Figure out the total size of the memory
    //
    dwTotalSize = dwSiteSize + dwGlobalSize;

    //
    //  If we don't have room tell the counter library.
    //
    if ( dwTotalSize > *lpcbTotalBytes )
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        dwErr = ERROR_MORE_DATA;

        goto exit;

    }

    if ( fGetSites )
    {
        //
        // Copy in the definition of the data for sites.
        //
        memcpy (pData, &W3DataDefinition, sizeof(W3DataDefinition));
        ((PERF_OBJECT_TYPE*) pData)->NumInstances = pSiteObject->NumInstances;
        ((PERF_OBJECT_TYPE*) pData)->TotalByteLength = dwSiteSize;
        pData = (LPBYTE) pData + sizeof(W3DataDefinition);

        // Copy in the actual data for sites
        memcpy ( pData, pSiteInstance, pSiteObject->SizeData );
        pData = (LPBYTE) pData + pSiteObject->SizeData;
    }

    if ( fGetGlobal )
    {
        //
        // Copy in the definition of the data for global
        //
        memcpy (pData, &W3GlobalDataDefinition, sizeof(W3GlobalDataDefinition));
        ((PERF_OBJECT_TYPE*) pData)->NumInstances = pGlobalObject->NumInstances;
        ((PERF_OBJECT_TYPE*) pData)->TotalByteLength = dwGlobalSize;
        pData = (LPBYTE) pData + sizeof(W3GlobalDataDefinition);

        // Copy in the actual data for global
        memcpy ( pData, pGlobalInstance, pGlobalObject->SizeData );
        pData = (LPBYTE) pData + pGlobalObject->SizeData;
    }

    // Make sure we didn't lie about the size.
    DBG_ASSERT ( dwTotalSize == DIFF((PCHAR) pData - (PCHAR) (*lppData)) );

    *lpcbTotalBytes = dwTotalSize;
    *lpNumObjectTypes = NumObjects;
    *lppData = pData;

    //
    // Let WAS know that we need new counters.
    //
    g_pIISMemManager->PingWASToRefreshCounters();

exit:

    LeaveCriticalSection ( &g_IISMemManagerCriticalSection );

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Exiting W3CTRS - CollectW3PerformanceData routine \n"
            ));
    }

    return dwErr;

}   // CollectW3PerformanceData

/***************************************************************************++

Routine Description:

   Terminates the performance counters.
    
Arguments:

    None.

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD CloseW3PerformanceData( VOID )
{
    //
    // On tclose tell the timer queue to stop launching
    // the checking code.
    //
    // Note if someone calls close and then collect again
    // we will have stopped listening to notifications from
    // w3svc and will not know when to drop the memory.
    //
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Entering W3CTRS - CloseW3PerformanceData routine \n"
            ));
    }

    EnterCriticalSection ( &g_IISMemManagerCriticalSection );
    
    FreeSharedManager(TRUE);

    LeaveCriticalSection( &g_IISMemManagerCriticalSection );

    if ( g_pEventLog )
    {
        delete g_pEventLog;

        g_pEventLog = NULL;
    }
    
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Exiting W3CTRS - CloseW3PerformanceData routine \n"
            ));
    }

    return ERROR_SUCCESS;

}   // CloseW3PerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\snmp\test\snmptest.cxx ===
#include "iis.h"
#include "stdio.h"
#include "Mgmtapi.h"

#define g_Usage L"Usage\n"
#define g_NotUsage L"NotUsage\n"

LPSNMP_MGR_SESSION  g_pSess = NULL;

VOID 
OpenCounters()
{

    HRESULT hr = S_OK;

    LPSTR computer = "EMILYK3-IIS";
    CHAR agent[1000];
    struct hostent* phostentry = gethostbyname(computer);
	
    if ( phostentry == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        wprintf(L"Failed to get the host name with hr = %x\n", hr);
        return;
    }

    sprintf(agent,"%u.%u.%u.%u",(BYTE)(phostentry->h_addr)[0],
                                (BYTE)(phostentry->h_addr)[1],
                                (BYTE)(phostentry->h_addr)[2],
                                (BYTE)(phostentry->h_addr)[3]);


    g_pSess = SnmpMgrOpen(agent, "public", 6000, 3);

    if ( !g_pSess )
    {
        wprintf(L"Failed to open the manager\n");
    }
    else
    {
        wprintf(L"Openned the manager\n");

    }

}

VOID 
CloseCounters()
{
    if ( g_pSess )
    {
        SnmpMgrClose(g_pSess);
    };
}

VOID
ProcessCounters(
    RFC1157VarBindList* pvariableBindings
    )
{
	LPSTR string = NULL;
    DWORD chString = 0;

	// Display the resulting variable bindings.
    SnmpMgrOidToStr(&(pvariableBindings->list[0].name), &string);

    wprintf(L"list[0].name = %S \n", string);

    LONG lastResult=(long) (pvariableBindings->list[0].value.asnValue.number);
    
    wprintf(L"Counter Value: %ld\n", lastResult);    
    
	if (string) SNMP_free(string);
}

VOID 
RequestCounters(
    DWORD dwCounter)
{
	RFC1157VarBindList variableBindings;
	AsnObjectIdentifier reqObject;
	AsnInteger errorStatus;
    AsnInteger errorIndex;

    LPSTR ctrStart = ".1.3.6.1.4.1.311.1.7.3.1.";
    LPSTR ctrEnd   = ".0";
    CHAR  fullctr[1000];

    sprintf(fullctr, "%s%d%s", ctrStart, dwCounter, ctrEnd);
    wprintf(L"Counter strings is %S \n", fullctr);
    
    if ( g_pSess )
    {
	    variableBindings.list = NULL;
        variableBindings.len = 0;

	    if (!SnmpMgrStrToOid(fullctr, &reqObject))
		{
            wprintf(L"Failed to get the Oid\n");
        }

        variableBindings.len++;
        if ((variableBindings.list = (RFC1157VarBind *)SNMP_realloc(
				    variableBindings.list, sizeof(RFC1157VarBind) *
                    variableBindings.len)) == NULL)
		{
            wprintf(L"Failed to realloc space \n");
        }

	    variableBindings.list[variableBindings.len - 1].name = reqObject; // NOTE!  structure copy
	    variableBindings.list[variableBindings.len - 1].value.asnType = ASN_NULL;

        if (!SnmpMgrRequest(g_pSess, 
                            ASN_RFC1157_GETREQUEST, 
                            &variableBindings,
                            &errorStatus, 
                            &errorIndex) )
        {
            wprintf(L"Failed to get the counters requested\n");
        }
        else
        {
            if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
            {
                ProcessCounters(&variableBindings);

               	SnmpUtilVarBindListFree(&variableBindings);

            }
            else
            {

                switch (errorStatus)
                {
                    case SNMP_ERRORSTATUS_TOOBIG:
                        wprintf(L"SNMP_ERRORSTATUS_TOOBIG %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_NOSUCHNAME:
                        wprintf(L"SNMP_ERRORSTATUS_NOSUCHNAME %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_BADVALUE:
                        wprintf(L"SNMP_ERRORSTATUS_BADVALUE %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_READONLY:
                        wprintf(L"SNMP_ERRORSTATUS_READONLY %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_GENERR:
                        wprintf(L"SNMP_ERRORSTATUS_GENERR %d\n", errorIndex);

                    break;

                    default:
                        wprintf(L"hum...\n");
                }

                wprintf(L"Error status is %x \n ", errorStatus);
            }
        }
    }
}


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    DWORD dwErr = 0;
    WSADATA WSADATA;
    WORD wVersionRequested;
    wVersionRequested = MAKEWORD( 2, 2 );

    dwErr = WSAStartup(wVersionRequested, &WSADATA);
    if ( dwErr != ERROR_SUCCESS )
        printf("failed WSAStartup\n");

    OpenCounters();

/*
    for ( DWORD i = 1; i < 53; i++ )
    {
        RequestCounters(i);
    }
*/

    RequestCounters(18);

    CloseCounters();

    WSACleanup();

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\makefile.inc ===
MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyini:
    $(MY_BINPLACE) w3ctrs.ini
    $(MY_BINPLACE) w3ctrs.h
    $(MY_BINPLACE) w3ctrs.reg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\precomp.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        22-Jul-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <stdio.h>

#include "iis.h"
#include "winperf.h"
#include "perfcount.h"
#include "iisdef.h"
#include "wasdbgut.h"
#include "perf_sm.h"
#include "regconst.h"
#include "eventlog.hxx"
#include "w3data.h"
#include "iismsg.h"
#include "perfutil.h"
#include "w3ctrsp.h"
#include "timer.h"


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\perfutil.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.cxx

   Abstract:

      This file implements the utility routines for 
      IIS W3 Perf Counters.

   Author:

       Emily Kruglick   ( EmilyK )     28-Sep-2000  
          Ported from IIS 5 tree.

   Environment:
       User Mode
       
   Project:

       Internet Servies Common Runtime functions

   Functions Exported:

        DWORD GetQueryType();
        BOOL  IsNumberInUnicodeList();

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.h"


/************************************************************
 *     Global Data Definitions
 ************************************************************/

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))

/************************************************************
 *    Functions 
 ************************************************************/

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    for( ; ; ) 
    {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Emily Kruglick    ( EmilyK )    28-Sep-2000  
         Ported from IIS 5 tree.

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:


--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) ((((x)+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\w3ctrsp.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3ctrsp.h


    This is a private wrapper file that contains information about the
    w3ctrs.h file that does not need to be exposed to the public.

    Offset definitions for the W3 Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    W3OpenPerformanceData procecedure, they will be added to the
    W3 Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the w3ctrs.DLL code as well as the
    w3ctrs.INI definition file.  w3ctrs.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.

    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        KestutiP    15-May-1999 Added Service Uptime counters
        EmilyK      10-Sept-2000 Altered for IIS 6.0

*/

#include "w3ctrs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\w3data.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1996           **/
/**********************************************************************/

/*
    w3ata.cxx

    Constant data structures for the W3 Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        Bob Watson/MuraliK     03-Oct-1996 - Added rate counters for W3.
        EmilyK      10-Sep-2000 Altered to be cxx as well as other IIS 6 changes

*/

#include "precomp.h"

W3_COUNTER_BLOCK     w3c;
W3_GLOBAL_COUNTER_BLOCK IISGlobal;

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

W3_DATA_DEFINITION W3DataDefinition =
{
    {   // W3ObjectType
        sizeof(W3_DATA_DEFINITION), // + sizeof (W3_COUNTER_BLOCK),
        sizeof(W3_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        W3_COUNTER_OBJECT,
        NULL,
        W3_COUNTER_OBJECT,
        NULL,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_W3_COUNTERS,
        5,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // W3BytesSent
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_SENT_COUNTER,
        NULL,
        W3_BYTES_SENT_COUNTER,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(w3c.BytesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesSent)
    },

    {   // W3BytesSent/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_SENT_PER_SEC,
        NULL,
        W3_BYTES_SENT_PER_SEC,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesSent)
    },

    {   // W3BytesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_RECEIVED_COUNTER,
        NULL,
        W3_BYTES_RECEIVED_COUNTER,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(w3c.BytesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesReceived)
    },


    {   // W3BytesReceived/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_RECEIVED_PER_SEC,
        NULL,
        W3_BYTES_RECEIVED_PER_SEC,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesReceived)
    },

    {   // W3BytesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_TOTAL_COUNTER,
        NULL,
        W3_BYTES_TOTAL_COUNTER,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(w3c.BytesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesTotal)
    },

    {   // W3BytesTotal/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_TOTAL_PER_SEC,
        NULL,
        W3_BYTES_TOTAL_PER_SEC,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesTotal)
    },

    {   // W3FilesSent
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_COUNTER,
        NULL,
        W3_FILES_SENT_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesSent)
    },

    {   // W3FilesSentSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_SEC,
        NULL,
        W3_FILES_SENT_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesSent)
    },

    {   // W3FilesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_COUNTER,
        NULL,
        W3_FILES_RECEIVED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesReceived)
    },

    {   // W3FilesReceivedSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_SEC,
        NULL,
        W3_FILES_RECEIVED_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesReceived)
    },

    {   // W3FilesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_TOTAL_COUNTER,
        NULL,
        W3_FILES_TOTAL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesTotal)
    },

    {   // W3FilesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SEC,
        NULL,
        W3_FILES_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesTotal)
    },

    {   // W3CurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_ANONYMOUS_COUNTER,
        NULL,
        W3_CURRENT_ANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentAnonymous)
    },

    {   // W3CurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_NONANONYMOUS_COUNTER,
        NULL,
        W3_CURRENT_NONANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentNonAnonymous)
    },

    {   // W3TotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_ANONYMOUS_COUNTER,
        NULL,
        W3_TOTAL_ANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalAnonymous)
    },

    {   // W3TotalAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ANONYMOUS_USERS_SEC,
        NULL,
        W3_ANONYMOUS_USERS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalAnonymous)
    },

    {   // W3NonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NONANONYMOUS_COUNTER,
        NULL,
        W3_TOTAL_NONANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNonAnonymous)
    },

    {   // W3NonAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_NON_ANONYMOUS_USERS_SEC,
        NULL,
        W3_NON_ANONYMOUS_USERS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNonAnonymous)
    },

    {   // W3MaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_ANONYMOUS_COUNTER,
        NULL,
        W3_MAX_ANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxAnonymous)
    },

    {   // W3MaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_NONANONYMOUS_COUNTER,
        NULL,
        W3_MAX_NONANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxNonAnonymous)
    },

    {   // W3CurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CONNECTIONS_COUNTER,
        NULL,
        W3_CURRENT_CONNECTIONS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentConnections),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentConnections)
    },

    {   // W3MaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CONNECTIONS_COUNTER,
        NULL,
        W3_MAX_CONNECTIONS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxConnections),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxConnections)
    },

    {   // W3ConnectionAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_COUNTER,
        NULL,
        W3_CONNECTION_ATTEMPTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ConnectionAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, ConnectionAttempts)
    },
    {   // W3ConnectionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_SEC,
        NULL,
        W3_CONNECTION_ATTEMPTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.ConnectionAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, ConnectionAttempts)
    },

    {   // W3LogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_COUNTER,
        NULL,
        W3_LOGON_ATTEMPTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.LogonAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, LogonAttempts)
    },

    {   // W3LogonAttemptsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_SEC,
        NULL,
        W3_LOGON_ATTEMPTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.LogonAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, LogonAttempts)
    },

    {   // W3TotalOptions
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_COUNTER,
        NULL,
        W3_TOTAL_OPTIONS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOptions),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOptions)
    },

    {   // W3TotalOptionsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_SEC,
        NULL,
        W3_TOTAL_OPTIONS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOptions),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOptions)
    },

    {   // W3TotalGets
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_COUNTER,
        NULL,
        W3_TOTAL_GETS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalGets),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalGets)
    },

    {   // W3TotalGetsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_SEC,
        NULL,
        W3_TOTAL_GETS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalGets),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalGets)
    },

    {   // W3TotalPosts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_COUNTER,
        NULL,
        W3_TOTAL_POSTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPosts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPosts)
    },

    {   // W3TotalPostsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_SEC,
        NULL,
        W3_TOTAL_POSTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPosts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPosts)
    },

    {   // W3TotalHeads
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_COUNTER,
        NULL,
        W3_TOTAL_HEADS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalHeads),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalHeads)
    },

    {   // W3TotalHeadsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_SEC,
        NULL,
        W3_TOTAL_HEADS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalHeads),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalHeads)
    },

    {   // W3TotalPuts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_COUNTER,
        NULL,
        W3_TOTAL_PUTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPuts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPuts)
    },

    {   // W3TotalPutsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_SEC,
        NULL,
        W3_TOTAL_PUTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPuts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPuts)
    },

    {   // W3TotalDeletes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_COUNTER,
        NULL,
        W3_TOTAL_DELETES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalDeletes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalDeletes)
    },

    {   // W3TotalDeletesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_SEC,
        NULL,
        W3_TOTAL_DELETES_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalDeletes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalDeletes)
    },

    {   // W3TotalTraces
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_COUNTER,
        NULL,
        W3_TOTAL_TRACES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalTraces),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalTraces)
    },

    {   // W3TotalTracesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_SEC,
        NULL,
        W3_TOTAL_TRACES_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalTraces),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalTraces)
    },

    {   // W3TotalMove
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_COUNTER,
        NULL,
        W3_TOTAL_MOVE_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMove),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMove)
    },

    {   // W3TotalMoveSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_SEC,
        NULL,
        W3_TOTAL_MOVE_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMove),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMove)
    },

    {   // W3TotalCopy
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_COUNTER,
        NULL,
        W3_TOTAL_COPY_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCopy),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCopy)
    },

    {   // W3TotalCopySec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_SEC,
        NULL,
        W3_TOTAL_COPY_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalCopy),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCopy)
    },

    {   // W3TotalMkcol
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_COUNTER,
        NULL,
        W3_TOTAL_MKCOL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMkcol),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMkcol)
    },

    {   // W3TotalMkcolSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_SEC,
        NULL,
        W3_TOTAL_MKCOL_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMkcol),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMkcol)
    },

    {   // W3TotalPropfind
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_COUNTER,
        NULL,
        W3_TOTAL_PROPFIND_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPropfind),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPropfind)
    },

    {   // W3TotalPropfindSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_SEC,
        NULL,
        W3_TOTAL_PROPFIND_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPropfind),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPropfind)
    },

    {   // W3TotalProppatch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_COUNTER,
        NULL,
        W3_TOTAL_PROPPATCH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalProppatch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalProppatch)
    },

    {   // W3TotalProppatchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_SEC,
        NULL,
        W3_TOTAL_PROPPATCH_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalProppatch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalProppatch)
    },

    {   // W3TotalSearch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_COUNTER,
        NULL,
        W3_TOTAL_SEARCH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalSearch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalSearch)
    },

    {   // W3TotalSearchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_SEC,
        NULL,
        W3_TOTAL_SEARCH_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalSearch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalSearch)
    },

    {   // W3TotalLock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_COUNTER,
        NULL,
        W3_TOTAL_LOCK_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLock)
    },

    {   // W3TotalLockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_SEC,
        NULL,
        W3_TOTAL_LOCK_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLock)
    },

    {   // W3TotalUnlock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_COUNTER,
        NULL,
        W3_TOTAL_UNLOCK_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalUnlock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalUnlock)
    },

    {   // W3TotalUnlockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_SEC,
        NULL,
        W3_TOTAL_UNLOCK_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalUnlock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalUnlock)
    },

    {   // W3TotalOthers
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_COUNTER,
        NULL,
        W3_TOTAL_OTHERS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOthers),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOthers)
    },

    {   // W3TotalOthersSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_SEC,
        NULL,
        W3_TOTAL_OTHERS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOthers),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOthers)
    },

    {   // W3TotalRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_COUNTER,
        NULL,
        W3_TOTAL_REQUESTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalRequests)
    },

    {   // W3TotalRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_SEC,
        NULL,
        W3_TOTAL_REQUESTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalRequests)
    },

    {   // W3TotalCGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        NULL,
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCGIRequests)
    },

    {   // W3TotalCGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CGI_REQUESTS_SEC,
        NULL,
        W3_CGI_REQUESTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCGIRequests)
    },

    {   // W3TotalBGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        NULL,
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalBGIRequests)
    },

    {   // W3TotalBGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BGI_REQUESTS_SEC,
        NULL,
        W3_BGI_REQUESTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalBGIRequests)
    },

    {   // W3TotalNotFoundErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        NULL,
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNotFoundErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNotFoundErrors)
    },

    {   // W3TotalNotFoundErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        NULL,
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalNotFoundErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNotFoundErrors)
    },

    {   // W3TotalLockedErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        NULL,
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLockedErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLockedErrors)
    },

    {   // W3TotalLockedErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_SEC,
        NULL,
        W3_TOTAL_LOCKED_ERRORS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLockedErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLockedErrors)
    },

    {   // W3CurrentCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CGI_COUNTER,
        NULL,
        W3_CURRENT_CGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentCGIRequests)
    },

    {   // W3CurrentBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BGI_COUNTER,
        NULL,
        W3_CURRENT_BGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentBGIRequests)
    },

    {   // W3MaxCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CGI_COUNTER,
        NULL,
        W3_MAX_CGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxCGIRequests)
    },

    {   // W3MaxBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_BGI_COUNTER,
        NULL,
        W3_MAX_BGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxBGIRequests)
    },

    {   // W3CurrentCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_AUTH_COUNTER,
        NULL,
        W3_CURRENT_CAL_AUTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalAuth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentCalAuth)
    },

    {   // W3MaxCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_AUTH_COUNTER,
        NULL,
        W3_MAX_CAL_AUTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalAuth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxCalAuth)
    },

    {   // W3TotalFailedCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        NULL,
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalAuth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalFailedCalAuth)
    },

    {   // W3CurrentCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_SSL_COUNTER,
        NULL,
        W3_CURRENT_CAL_SSL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalSsl),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentCalSsl)
    },

    {   // W3MaxCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_SSL_COUNTER,
        NULL,
        W3_MAX_CAL_SSL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalSsl),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxCalSsl)
    },

    {   // W3TotalFailedCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        NULL,
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalSsl),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalFailedCalSsl)
    },

    {   // W3BlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.BlockedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BlockedRequests)
    },
    
    {   // W3AllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.AllowedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, AllowedRequests)
    },
    
    {   // W3RejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.RejectedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, RejectedRequests)
    },
    
    {   // W3CurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBlockedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentBlockedRequests)
    },
   
    {   // W3MeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MEASURED_BANDWIDTH_COUNTER,
        NULL,
        W3_MEASURED_BANDWIDTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MeasuredBandwidth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MeasuredBandwidth)
    },

    {   // W3TotalBlockedBandwidthBytes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        W3_TOTAL_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalBlockedBandwidthBytes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalBlockedBandwidthBytes)
    },

    {   // W3CurrentBlockedBandwidthBytes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        W3_CURRENT_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBlockedBandwidthBytes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentBlockedBandwidthBytes)
    },

    {   // W3ServiceUptime
        sizeof(PERF_COUNTER_DEFINITION),
        W3_SERVICE_UPTIME_COUNTER,
        NULL,
        W3_SERVICE_UPTIME_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ServiceUptime),
        FIELD_OFFSET(W3_COUNTER_BLOCK, ServiceUptime)
    }
};

//
// Global Data Structure.
// 
//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//
W3_GLOBAL_DATA_DEFINITION W3GlobalDataDefinition =
{
    {   // W3GlobalObjectType
        sizeof(W3_GLOBAL_DATA_DEFINITION), // + sizeof (W3_COUNTER_BLOCK),
        sizeof(W3_GLOBAL_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        W3_GLOBAL_COUNTER_OBJECT,
        NULL,
        W3_GLOBAL_COUNTER_OBJECT,
        NULL,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_W3_GLOBAL_COUNTERS,
        2,                              // Default = ???
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // CurrentFilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_FILES_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_FILES_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.CurrentFilesCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentFilesCached)
    },

    {   // TotalFilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FILES_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FILES_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFilesCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFilesCached)
    },

    {   // FileCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.FileCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheHits)
    },
    {   // FileCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.FileCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheMisses)
    },

    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.FileCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheHits)
    },

    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.FileCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheHitRatio)
    },

    {   // FileCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.FileCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheFlushes)
    },
    {   // CurrentFileCacheMemoryUsage
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(IISGlobal.CurrentFileCacheMemoryUsage),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentFileCacheMemoryUsage)
    },
    {   // MaxFileCacheMemoryUsage
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_MAX_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        W3_GLOBAL_MAX_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(IISGlobal.MaxFileCacheMemoryUsage),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, MaxFileCacheMemoryUsage)
    },
    {   // ActiveFlushedFiles
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_ACTIVE_FLUSHED_FILES_COUNTER,
        NULL,
        W3_GLOBAL_ACTIVE_FLUSHED_FILES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.ActiveFlushedFiles),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, ActiveFlushedFiles)
    },
    {   // TotalFlushedFiles
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FLUSHED_FILES_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FLUSHED_FILES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFlushedFiles),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFlushedFiles)
    },
    {   // CurrentUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.CurrentUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentUrisCached)
    },
    {   // TotalUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalUrisCached)
    },
    {   // UriCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheHits)
    },
    {   // UriCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UriCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheMisses)
    },

    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.UriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheHits)
    },

    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.UriCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheHitRatio)
    },

    {   // UriCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UriCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheFlushes)
    },
    {   // TotalFlushedUris
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFlushedUris),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFlushedUris)
    },
    {   // CurrentBlobsCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_METADATA_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_METADATA_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.CurrentBlobsCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentBlobsCached)
    },
    {   // TotalBlobsCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_METADATA_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_METADATA_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalBlobsCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalBlobsCached)
    },
    {   // BlobCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.BlobCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheHits)
    },
    {   // BlobCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.BlobCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheMisses)
    },
    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.BlobCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheHits)
    },
    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.BlobCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheHitRatio)
    },
    {   // BlobCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.BlobCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheFlushes)
    },
    {   // TotalFlushedBlobs
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FLUSHED_METADATA_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FLUSHED_METADATA_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFlushedBlobs),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFlushedBlobs)
    },
    {   // UlCurrentUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlCurrentUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlCurrentUrisCached)
    },
    {   // UlTotalUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlTotalUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlTotalUrisCached)
    },
    {   // UlUriCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlUriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHits)
    },
    {   // UlUriCacheHitsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_PER_SEC,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_PER_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(IISGlobal.UlUriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHits)
    },
    {   // UlUriCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlUriCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheMisses)
    },
    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.UlUriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHits)
    },
    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.UlUriCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHitRatio)
    },
    {   // UlUriCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlUriCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheFlushes)
    },
    {   // UlTotalFlushedUris
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlTotalFlushedUris),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlTotalFlushedUris)
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\w3data.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3data.h

    Extensible object definitions for the W3 Server's counter
    objects & counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        EmilyK      10-Sep-2000 Altered for IIS 6 counters implementation.

*/


#ifndef _W3DATA_H_
#define _W3DATA_H_

#pragma pack(8) 

//
//  The counter structure returned.
//

typedef struct _W3_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            W3ObjectType;
    PERF_COUNTER_DEFINITION     W3BytesSent;
    PERF_COUNTER_DEFINITION     W3BytesSentSec;
    PERF_COUNTER_DEFINITION     W3BytesReceived;
    PERF_COUNTER_DEFINITION     W3BytesReceivedSec;

    PERF_COUNTER_DEFINITION     W3BytesTotal;
    PERF_COUNTER_DEFINITION     W3BytesTotalSec;
    PERF_COUNTER_DEFINITION     W3FilesSent;
    PERF_COUNTER_DEFINITION     W3FilesSentSec;
    PERF_COUNTER_DEFINITION     W3FilesReceived;

    PERF_COUNTER_DEFINITION     W3FilesReceivedSec;
    PERF_COUNTER_DEFINITION     W3FilesTotal;
    PERF_COUNTER_DEFINITION     W3FilesSec;
    PERF_COUNTER_DEFINITION     W3CurrentAnonymous;
    PERF_COUNTER_DEFINITION     W3CurrentNonAnonymous;

    PERF_COUNTER_DEFINITION     W3TotalAnonymous;
    PERF_COUNTER_DEFINITION     W3AnonymousUsersSec;
    PERF_COUNTER_DEFINITION     W3TotalNonAnonymous;
    PERF_COUNTER_DEFINITION     W3NonAnonymousUsersSec;
    PERF_COUNTER_DEFINITION     W3MaxAnonymous;

    PERF_COUNTER_DEFINITION     W3MaxNonAnonymous;
    PERF_COUNTER_DEFINITION     W3CurrentConnections;
    PERF_COUNTER_DEFINITION     W3MaxConnections;
    PERF_COUNTER_DEFINITION     W3ConnectionAttempts;
    PERF_COUNTER_DEFINITION     W3ConnectionAttemptsSec;

    PERF_COUNTER_DEFINITION     W3LogonAttempts;
    PERF_COUNTER_DEFINITION     W3LogonAttemptsSec;
    PERF_COUNTER_DEFINITION     W3TotalOptions;
    PERF_COUNTER_DEFINITION     W3TotalOptionsSec;
    PERF_COUNTER_DEFINITION     W3TotalGets;

    PERF_COUNTER_DEFINITION     W3TotalGetsSec;
    PERF_COUNTER_DEFINITION     W3TotalPosts;
    PERF_COUNTER_DEFINITION     W3TotalPostsSec;
    PERF_COUNTER_DEFINITION     W3TotalHeads;
    PERF_COUNTER_DEFINITION     W3TotalHeadsSec;

    PERF_COUNTER_DEFINITION     W3TotalPuts;
    PERF_COUNTER_DEFINITION     W3TotalPutsSec;
    PERF_COUNTER_DEFINITION     W3TotalDeletes;
    PERF_COUNTER_DEFINITION     W3TotalDeletesSec;
    PERF_COUNTER_DEFINITION     W3TotalTraces;

    PERF_COUNTER_DEFINITION     W3TotalTracesSec;
    PERF_