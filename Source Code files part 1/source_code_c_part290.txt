2;
    ThreadData  *ptd;
};

DWORD InvokeOn16(IIDIDX iidx, DWORD dwMethod, LPVOID pvStack32)
{
    // NOTE: Do not declare local variables in this routine
    // except for debug builds
    INVOKE16RECORD *pir;
    DWORD dwResult;

#if DBG == 1
    ULONG ulInvokeOn16_count = ++InvokeOn16_count;
    if (InvokeOn16_count == InvokeOn16_break)
    {
        DebugBreak();
    }

    thkDebugOut((DEB_ITRACE, "%sInvokeOn16(0x%x, 0x%x, %p)\n",
                 NestingLevelString(), iidx, dwMethod, pvStack32));
#endif

    pir = (INVOKE16RECORD *)STACKALLOC32(sizeof(INVOKE16RECORD));
    if (pir == NULL)
    {
        // This error isn't guaranteed to mean anything for
        // this call.  Not much else we can do, though
        return (DWORD)E_OUTOFMEMORY;
    }

    // pvStack32 is a pointer to an array of arguments from the
    // 32-bit call.  It's always laid out with the first
    // argument low and increasing from there

    pir->ti.s32.pbStart = (BYTE *)pvStack32;
    pir->ti.s32.pbCurrent = pir->ti.s32.pbStart;

    pir->ti.s16.pbStart = (BYTE *)pir->dwStack16;
    pir->ti.s16.pbCurrent = pir->ti.s16.pbStart;

    pir->ti.scResult = S_OK;
    pir->ti.fResultThunked = FALSE;

    pir->ptd = TlsThkGetData();
    if (pir->ptd == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: InvokeOn16: Call refused\n"));

        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return (DWORD)E_FAIL;
    }

    pir->ti.pThkMgr = pir->ptd->pCThkMgr;
    thkAssert(pir->ti.pThkMgr != NULL);

    thkAssert(iidx < THI_COUNT);

    // For each interface there is an array of thop strings, one for
    // each method.  The IUnknown methods don't have thop strings so
    // bias the thop string pointer to account for that

    thkAssert(dwMethod >= SMI_COUNT);

    pir->ppThop = athopiInterfaceThopis[iidx].ppThops-SMI_COUNT;
    pir->uiThop = athopiInterfaceThopis[iidx].uiSize;

    // Methods are cdecl so we need to move upwards in memory to
    // get to the next parameter
    pir->ti.s16.iDir = 1;

    // We need to look up the appropriate method pointer by
    // looking in the 16-bit object's vtable
    GET_STACK32(&pir->ti, pir->ptoThis32, THUNK3216OBJ *);

    thkDebugOut((DEB_INVOKES,
                 "InvokeOn16: ptoThis32 = %08lX\n", pir->ptoThis32 ));

    if ( pir->ptoThis32->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "InvokeOn16: Attempt to call %s::%s"
                     "on cleaned-up proxy %08lX for 16-bit object %08lX\n",
                     inInterfaceNames[iidx].pszInterface,
                     inInterfaceNames[iidx].ppszMethodNames[dwMethod],
                     pir->ptoThis32, pir->ptoThis32->vpvThis16));
        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return (DWORD)E_FAIL;
    }

    // check PROXYFLAG_CLEANEDUP before calling DebugValidateProxy3216.
    // Otherwise we might get asserts on checked OLE.
    DebugValidateProxy3216(pir->ptoThis32);

    pir->ti.dwCallerProxy = (DWORD)pir->ptoThis32;
    pir->vpvThis16 = pir->ptoThis32->vpvThis16;
    pir->pvpvThis16 = (VPVOID UNALIGNED *)
        GetReadPtr16(&pir->ti, pir->vpvThis16, sizeof(VPVOID));
    if (pir->pvpvThis16 == NULL)
    {
        dwResult = pir->ti.scResult;
        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return dwResult;
    }

    pir->vpvVtbl16 = *pir->pvpvThis16;
    pir->pvfnVtbl = (VTBLFN UNALIGNED *)
        GetReadPtr16(&pir->ti, pir->vpvVtbl16, sizeof(VPVOID)*pir->uiThop);

    WOWRELVDMPTR(pir->vpvThis16);

    if (pir->pvfnVtbl == NULL)
    {
        dwResult = pir->ti.scResult;
        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return dwResult;
    }

    // Push the 16-bit this pointer on the stack first
    TO_STACK16(&pir->ti, pir->vpvThis16, VPVOID);

    thkAssert(dwMethod < pir->uiThop);

    pir->pThop = pir->ppThop[dwMethod];

    thkAssert(pir->pThop != NULL);

    pir->ti.pThop = pir->pThop;
    pir->ti.pvfn  = pir->pvfnVtbl[dwMethod];
    pir->ti.iidx  = iidx;
    pir->ti.dwMethod = dwMethod;
    pir->ti.this32   = (IUnknown *)pir->ptoThis32;

    WOWRELVDMPTR(pir->vpvVtbl16);

    thkDebugOut((DEB_INVOKES, "%s#(%04X):InvokeOn16 on %p:%p, %s::%s\n",
                 NestingLevelString(), ulInvokeOn16_count,
                 pir->vpvThis16, pir->ti.pvfn,
                 inInterfaceNames[iidx].pszInterface,
                 inInterfaceNames[iidx].ppszMethodNames[dwMethod]));

    DebugIncrementNestingLevel();

    pir->ti.pThkMgr->SetThkState(THKSTATE_INVOKETHKIN16);

#if DBG == 1
    SStackRecord sr;

    RecordStackState16(&sr);
#endif

#if DBG == 1
    if ((_iInvokeOn16BreakIidx > 0 && _iInvokeOn16BreakIidx == (int)iidx) &&
        (_iInvokeOn16BreakMethod < 0 ||
         _iInvokeOn16BreakMethod == (int)dwMethod))
    {
        DebugBreak();
    }
#endif

    dwResult = EXECUTE_THOP3216(&pir->ti);

#if DBG == 1

    if ( !pir->ti.fResultThunked && FAILED(dwResult) )
    {
        thkDebugOut((DEB_FAILURES,
                     "InvokeOn16 probable failure %s::%s sc = %08lX\n",
                     inInterfaceNames[iidx].pszInterface,
                     inInterfaceNames[iidx].ppszMethodNames[dwMethod],
                     dwResult));
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }

    CheckStackState16(&sr);

#endif

    pir->ti.pThkMgr->SetThkState(THKSTATE_NOCALL);

    DebugDecrementNestingLevel();

    thkDebugOut((DEB_INVOKES,
                 "%s#(%04X):InvokeOn16 on %p:%p, %s::%s returns 0x%08lX\n",
                 NestingLevelString(), ulInvokeOn16_count,
                 pir->vpvThis16, pir->ti.pvfn,
                 inInterfaceNames[iidx].pszInterface,
                 inInterfaceNames[iidx].ppszMethodNames[dwMethod],
                 dwResult));

    STACKFREE32(pir, sizeof(INVOKE16RECORD));

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Call3216, private
//
//  Synopsis:   Sets up stack and transitions to 16-bit
//
//  Arguments:  [pvfn] - Function to call
//              [pbStack] - Stack in 32-bits
//              [cbStack] - Size of stack
//
//  Returns:    Appropriate status code
//
//  History:    04-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------
#if DBG == 1
extern "C" ULONG Call3216_count = 0;
extern "C" ULONG Call3216_break = 0;
#endif

DWORD Call3216(VPVOID pvfn, BYTE *pbStack, UINT cbStack)
{
#if DBG == 1
    ULONG ulCall3216_count = ++Call3216_count;
    if (Call3216_count == Call3216_break)
    {
	DebugBreak();
    }
#endif

    VPVOID vpvStack16;
    DWORD dwResult;
    void *pvStack16;

    dwResult = (DWORD)S_OK;

    if (cbStack <= WCB16_MAX_CBARGS)
    {
        thkDebugOut((DEB_ITRACE, "%sCallbackTo16Ex(%p, %lu, %p) #(%x)\n",
                     NestingLevelString(), pvfn, cbStack, pbStack, 
                     ulCall3216_count));

        // pbStack must have at least WCB16_MAX_CBARGS bytes of valid memory
        // since 16V always copies that many bytes

        // In our case pbStack is from InvokeOn16 which should be large enough
        thkAssert(MAX_PARAMS*sizeof(DWORD) >= WCB16_MAX_CBARGS);

        if (!CallbackTo16Ex(pvfn, WCB16_CDECL, cbStack, pbStack,
                             &dwResult))
        {
            dwResult = (DWORD)E_UNEXPECTED;
        }
    }
    else
    {
        CALLDATA UNALIGNED *pcd;
        UINT cbAlloc;

        cbAlloc = cbStack+sizeof(CALLDATA);

        vpvStack16 = STACKALLOC16(cbAlloc);
        if (vpvStack16 == 0)
        {
            dwResult = (DWORD)E_OUTOFMEMORY;
        }
        else
        {
            pvStack16 = (void *)WOWFIXVDMPTR(vpvStack16, cbAlloc);

            pcd = (CALLDATA UNALIGNED *)((BYTE *)pvStack16+cbStack);
            pcd->vpfn = (DWORD)pvfn;
            pcd->vpvStack16 = vpvStack16;
            pcd->cbStack = cbStack;

            memcpy(pvStack16, pbStack, cbStack);

            WOWRELVDMPTR(vpvStack16);

            thkDebugOut((DEB_ITRACE, "%sCallbackTo16(%p, (%p, %p, %lu)) #(%x)\n",
                         NestingLevelString(), gdata16Data.fnCallStub16, pvfn, 
                         vpvStack16, cbStack, ulCall3216_count));
            dwResult = CallbackTo16(gdata16Data.fnCallStub16,
                                     vpvStack16+cbStack);

            STACKFREE16(vpvStack16, cbAlloc);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkCall3216, public
//
//  Synopsis:   Sets up the 16-bit stack and makes a 32->16 call
//
//  Arguments:  [pti] - Thunk state info
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       DrewB   Created
//              08-Aug-94       AlexT   Add IOleClientSite::OnShowWindow code
//
//----------------------------------------------------------------------------

#if DBG == 1
extern "C" ULONG ThunkCall3216_count = 0;
extern "C" ULONG ThunkCall3216_break = 0;
#endif

DWORD ThunkCall3216(THUNKINFO *pti)
{
    DWORD dwReturn;
    UINT cbStack;
    DWORD dwCallerTID;
    HRESULT hrCaller;
    BOOL fFail = FALSE;

#if DBG == 1
    ULONG ulThunkCall3216_count = ++ThunkCall3216_count;
    thkAssert( (ThunkCall3216_count != ThunkCall3216_break) &&
               "Break Count Hit");
#endif

    thkAssert(*pti->pThop == THOP_END);
    pti->pThop++;
    thkAssert(*pti->pThop == THOP_ROUTINEINDEX);
    pti->pThop++;

    thkDebugOut((DEB_ITRACE, "%sIn ThunkCall3216 #(%x) %p, index %d\n",
                 NestingLevelString(), ulThunkCall3216_count, 
                 pti->pvfn, *pti->pThop));
    DebugIncrementNestingLevel();

    cbStack = (ULONG) (pti->s16.pbCurrent-pti->s16.pbStart);

    // The this pointer should always be on the stack
    thkAssert(cbStack >= sizeof(VPVOID));

    //
    // Hacks for specific interface member functions.
    // The placement of these hacks here is by no means an optimal solution.
    // It just happens to be convienient for now since everything goes through
    // here.  This section is for pre-processing.
    //
    if ( IIDIDX_IS_INDEX(pti->iidx) )
    {
        switch( IIDIDX_INDEX(pti->iidx) )
        {
        case THI_IOleClientSite:
#define METHOD_ONSHOWWINDOW 7
            if ( pti->dwMethod == METHOD_ONSHOWWINDOW )
            {
                //
                // Here we merge the input queues for the sole reason so that
                // we can link the object's window activations into the calling
                // thread's window z-order.
                //

                hrCaller = CoGetCallerTID( &dwCallerTID );

                if ( hrCaller == S_FALSE )
                {
                    AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                       TRUE );
                }
            }
            break;

        case THI_IOleObject:
#define METHOD_DOVERB   11
            if ( pti->dwMethod == METHOD_DOVERB )
            {
                //
                // Here we merge the input queues for the sole reason so
                // that we can link the object's window activations into
                // the calling thread's window z-order.
                //

                hrCaller = CoGetCallerTID( &dwCallerTID );

                if ( hrCaller == S_FALSE )
                {
                    AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                       TRUE );
                }
            }
            break;

        case THI_IRpcStubBuffer:
#define METHOD_DEBUGSERVER_QUERYINTERFACE   8
#define METHOD_DEBUGSERVER_RELEASE          9
            if(pti->dwMethod == METHOD_DEBUGSERVER_QUERYINTERFACE)
            {
                // This is badly designed method in the sense that
                // we do not know how to thunk the OUT interface
                // parameter returned by this method. The interface
                // may have been addrefed and may be not. We also do
                // not know the IID of the interface. At best, we can
                // thunk it as an IUnknown and not call release on the
                // actual interface when building it. We can then release
                // the proxy built above when DebugServerRelease is called
                // later. But, it will lead to an AV if the invoker of this
                // method invokes a non-IUnknown method on the thunked 
                // interface. In view of the above, I am failing the call
                // to this method. This is a more desirable behavior and 
                // Wx86 thunking also would not get affected by it.
                //         GopalK        Aug 18, 97.
                thkDebugOut((DEB_FAILURES, "Call on IRpcStubBuffer::DebugServerQueryInterface\n"));
                dwReturn = E_NOINTERFACE;
                fFail = TRUE;
            }
            else if(pti->dwMethod == METHOD_DEBUGSERVER_RELEASE)
            {
                // See comment for DebugServerQueryInterface
                thkAssert(!"Call on IRpcStubBuffer::DebugServerRelease");
                thkDebugOut((DEB_ERROR, "Call on IRpcStubBuffer::DebugServerRelease\n"));
                dwReturn = S_OK;
                fFail = TRUE;
            }
        
        default:
            break;
        }
    }

    if(!fFail)
    {
        pti->pThkMgr->SetThkState(THKSTATE_NOCALL);

        dwReturn = Call3216((VPVOID)pti->pvfn, pti->s16.pbStart, cbStack);

        pti->pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT16);

        //
        // Hacks for specific interface member functions.
        // Again, the placement of these is by no means an optimal solution.
        // They can be moved as long as they have the same effect for just these
        // interfaces.  This section is for post-processing.
        //
        if ( IIDIDX_IS_INDEX(pti->iidx) )
        {
            switch( IIDIDX_INDEX(pti->iidx) )
            {
            case THI_IOleClientSite:
                if ( pti->dwMethod == METHOD_ONSHOWWINDOW )
                {
                    //
                    // Unmerge the input queues afterward.
                    //
                    if ( hrCaller == S_FALSE )
                    {
                        AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                           FALSE );
                    }
                }
                break;

            case THI_IOleObject:
                if ( pti->dwMethod == METHOD_DOVERB )
                {
                    //
                    // Unmerge the input queues afterward.
                    //
                    if ( hrCaller == S_FALSE )
                    {
                        AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                           FALSE );
                    }
                }

#define METHOD_GETCLIENTSITE    4
                if ( pti->dwMethod == METHOD_GETCLIENTSITE )
                {
                    //
                    // Excel 5.0a needs to perform some special processing
                    // on the way out of a IOleObject::GetClientSite call.
                    //  See CTHKMGR.CXX and APINOT.CXX for more details.
                    //
                    if ( TlsThkGetAppCompatFlags() & OACF_CLIENTSITE_REF )
                    {
                        //
                        // Tell the thkmgr that we are thunking a bad
                        // IOleObject::GetClientSite reference on the way out.
                        //
                        thkDebugOut((DEB_WARN,"TC3216: OACF_CLIENTSITE_REF used: "
                                     "Setting to clientsite thunk state\n"));

                        pti->pThkMgr->SetThkState(
                                THKSTATE_INVOKETHKOUT16_CLIENTSITE);
                    }
                }
                break;

            case THI_IOleInPlaceFrame:
#define METHOD_REMOVEMENUS  11
                //
                // Winword 6.0a didn't call OleSetMenuDescriptor(NULL)
                // during its IOleInPlaceFrame::RemoveMenus.  This leaves
                // OLE's frame filter in place.  The frame filter holds references
                // to some objects so everybody's refcounting gets thrown off
                // Here, when we see a RemoveMenus call completing we force
                // the OleSetMenuDescriptor(NULL) call to occur.  This shuts
                // down the frame filter and corrects the reference counts.
                //
                // There is one other hack necessary: Word unsubclasses the
                // window itself directly rather than going through
                // OleSetMenuDescriptor.  Therefore the frame filter code
                // is patched to only unhook if it detects that it is the
                // current hook
                //
                // See APINOT.CXX for more hack code.
                //
                if (pti->dwMethod == METHOD_REMOVEMENUS)
                {
                    if ( TlsThkGetAppCompatFlags() & OACF_RESETMENU )
                    {
                        HRESULT hr;
                        HWND    hwnd;
                        LPOLEINPLACEFRAME lpoipf;

                        pti->pThkMgr->SetThkState(THKSTATE_NOCALL);

                        lpoipf = (LPOLEINPLACEFRAME)pti->this32;
                        hr = lpoipf->GetWindow( &hwnd );

                        pti->pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT16);

                        if ( FAILED(hr) )
                        {
                            break;
                        }

                        thkDebugOut((DEB_WARN,
                                     "TC3216: OACF_RESETMENU used: "
                                     "Setting menu descriptor "
                                     "to NULL on %p\n", hwnd));

                        OleSetMenuDescriptor(NULL, hwnd, NULL, NULL, NULL);
                    }
                }
                break;

            default:
                break;
            }
        }

        if ( !pti->fResultThunked )
        {
            dwReturn = TransformHRESULT_1632( dwReturn );

#if DBG == 1
            if (FAILED(dwReturn) )
            {
                thkDebugOut((DEB_FAILURES,
                             "Call3216 pvfn = %08lX Probably failed hr = %08lX\n",
                             pti->pvfn, dwReturn));
                if(thkInfoLevel & DEB_DBGFAIL)
                    thkAssert(!"Wish to Debug");
            }
#endif
        }
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_ITRACE, "%sOut ThunkCall3216 #(%x) returns 0x%08lX\n",
                 NestingLevelString(), ulThunkCall3216_count, dwReturn));
    return dwReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetOwnerPublicHMEM16, public
//
//  Synopsis:   Changes the 16-bit memory handle into a public selector, owned
//              by nobody.  This prevents any app from taking it away when it
//              is cleaned up.
//
//  Arguments:  [hmem] - 16-bit memory handle
//
//  Returns:    Appropriate status code
//
//  History:    13-Jul-94       BobDay      Created it
//
//----------------------------------------------------------------------------
void SetOwnerPublicHMEM16( DWORD hmem )
{
    CallbackTo16(gdata16Data.fnSetOwnerPublic16, hmem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\map_kv.h ===
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

//#include <memapi.hxx>

/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);

#ifdef WIN32
DECLARE_HANDLE(HMAPKEY);
#else
DECLARE_HANDLE32(HMAPKEY);
#endif

typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class FAR CMapKeyToValue
{
public:
        CMapKeyToValue(UINT cbValue, UINT cbKey = 0,
                int nBlockSize=10,
                LPFNHASHKEY lpfnHashKey = NULL,
                UINT nHashSize = 17);
        ~CMapKeyToValue();

        // number of elements
        int     GetCount() const { return m_nCount; }
        BOOL    IsEmpty() const { return m_nCount == 0; }

        // Lookup; return FALSE if not found
        BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
        BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
        BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

        // add a new (key, value) pair; return FALSE if out of memory
        BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
        BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

        // removing existing (key, ?) pair; return FALSE if no such key
        BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
        BOOL    RemoveHKey(HMAPKEY hKey);
        void    RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const
                        { return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
        void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey,
                                UINT FAR* pcbKey, LPVOID pValue) const;

        // return HMAPKEY for given key; returns NULL if not currently in map
        HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

        void    AssertValid() const;

private:
        // abstracts, somewhat, variable and fixed sized keys; size is really
        // m_cbKeyInAssoc.
        union CKeyWrap
        {
                BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
                struct
                {
                        LPVOID pKey;
                        UINT cbKey;
                };
        };

        // Association of one key and one value; NOTE: even though in general
        // the size of the key and value varies, for any given map,
        // the size of an assoc is fixed.
        struct CAssoc
        {
                CAssoc  FAR* pNext;
                UINT    nHashValue; // needed for efficient iteration
                CKeyWrap key;           // size is really m_cbKeyInAssoc
                // BYTE rgbValue[m_cbValue];
        };

        UINT    SizeAssoc() const
                { return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
        CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
        void    FreeAssoc(CAssoc FAR* pAssoc);
        BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

        BOOL    SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        void    GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
        void    FreeAssocKey(CAssoc FAR* pAssoc) const;
        void    GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
        void    GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
        void    SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

        BOOL    InitHashTable();

        UINT    m_cbValue;
        UINT    m_cbKey;                        // variable length if 0
        UINT    m_cbKeyInAssoc;         // always non-zero

        CAssoc  FAR* FAR* m_pHashTable;
        UINT    m_nHashTableSize;
        LPFNHASHKEY m_lpfnHashKey;

        int     m_nCount;
        CAssoc  FAR* m_pFreeList;
        struct CPlex FAR* m_pBlocks;
        int     m_nBlockSize;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\mmodel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	mmodel.cxx
//
//  Contents:	CMemoryModel
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

CMemoryModel16 mmodel16Public(TRUE);
CMemoryModel16 mmodel16Owned(FALSE);
CMemoryModel32 mmodel32;

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel16::AllocMemory
//
//  Synopsis:   Allocates memory
//
//  Arguments:  [cb] - Size of block to allocate
//
//  Returns:    New address of block or NULL
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

DWORD CMemoryModel16::AllocMemory(DWORD cb)
{
    VPVOID vpv;
    HMEM16 hmem16;

    thkAssert(cb > 0);

    vpv = WgtAllocLock(GMEM_MOVEABLE, cb, &hmem16);
    if (vpv == 0)
    {
        //
        // Not able to allocate a 16-bit memory block!
        //
        thkDebugOut((DEB_ERROR,
                     "CMemoryModel16::AllocMemory, "
                     "Allocation failed, size %08lX\n",
                     cb));
        return 0;
    }

    if (_fPublic)
    {
        SetOwnerPublicHMEM16(hmem16);
    }

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel16::FreeMemory
//
//  Synopsis:   Deallocates a block of memory previously allocated
//
//  Arguments:  [dwMem] - Address of memory block to free
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

void CMemoryModel16::FreeMemory(DWORD dwMem)
{
    thkAssert(dwMem != 0);
    
    WgtUnlockFree(dwMem);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel16::ResolvePtr
//
//  Synopsis:   Returns a resolved pointer given an abstract pointer
//
//  Arguments:  [dwMem] - Address to get pointer from
//              [cb] - Length, starting at given address, to make valid
//                     pointers for. 
//
//  Returns:    LPVOID - A real pointer equivalent to the abstract pointer.
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//  Notes:      Be careful of alignment issues
//
//----------------------------------------------------------------------------

LPVOID CMemoryModel16::ResolvePtr(DWORD dwMem, DWORD cb)
{
    LPVOID pv;

    thkAssert(dwMem != 0 && cb > 0);

    pv = (LPVOID)WOWFIXVDMPTR(dwMem, cb);
    if (pv == NULL)
    {
        thkDebugOut((DEB_ERROR,
                     "CMemoryModel16::ResolvePtr, "
                     "WOWGetVDMPointer failed on %08lX, size %08lX\n",
                     dwMem, cb));
    }

    return pv;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMemoryModel16::ReleasePtr, public
//
//  Synopsis:	Releases a resolved pointer
//
//  Arguments:	[dwMem] - Abstract pointer to release
//
//  History:	10-Oct-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CMemoryModel16::ReleasePtr(DWORD dwMem)
{
    thkAssert(dwMem != 0);

    WOWRELVDMPTR(dwMem);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel32::AllocMemory
//
//  Synopsis:   Allocates memory
//
//  Arguments:  [cb] - Size of block to allocate
//
//  Returns:    New address of block or NULL
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

DWORD CMemoryModel32::AllocMemory(DWORD cb)
{
    DWORD dwMem;

    thkAssert(cb > 0);
    
    dwMem = (DWORD)CoTaskMemAlloc(cb);
    if (dwMem == 0)
    {
        //
        // Not able to allocate a 32-bit memory block!
        //
        thkDebugOut((DEB_ERROR,
                     "CMemoryModel32::AllocBlock, "
                     "CoTaskMemAlloc failed size %08lX\n",
                     cb));
        return 0;
    }
    
    return dwMem;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel32::FreeMemory
//
//  Synopsis:   Deallocates a block of memory previously allocated
//
//  Arguments:  [dwMem] - Address of memory block to free
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

void CMemoryModel32::FreeMemory(DWORD dwMem)
{
    thkAssert(dwMem != 0);
    
    CoTaskMemFree((LPVOID)dwMem);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel32::ResolvePtr
//
//  Synopsis:   Returns a resolved pointer given an abstract pointer
//
//  Arguments:  [dwMem] - Address to get pointer from
//              [cb] - Length, starting at given address, to make valid
//                     pointers for. 
//
//  Returns:    LPVOID - A real pointer equivalent to the abstract pointer.
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//  Notes:      Be careful of alignment issues
//
//----------------------------------------------------------------------------

LPVOID CMemoryModel32::ResolvePtr(DWORD dwMem, DWORD cb)
{
    thkAssert(dwMem != 0 && cb > 0);
    
    return (LPVOID)dwMem;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMemoryModel32::ReleasePtr, public
//
//  Synopsis:	Releases a resolved pointer
//
//  Arguments:	[dwMem] - Abstract pointer to release
//
//  History:	10-Oct-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CMemoryModel32::ReleasePtr(DWORD dwMem)
{
    thkAssert(dwMem != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\map_dwp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapDwordPtr
{
public:
   // Construction
   CMapDwordPtr(UINT nBlockSize=10)
        : m_mkv(sizeof(void FAR*), sizeof(DWORD), nBlockSize) { }

   // Attributes
   // number of elements
   int     GetCount() const
                        { return m_mkv.GetCount(); }
   BOOL    IsEmpty() const
                        { return GetCount() == 0; }

   // Lookup
   BOOL    Lookup(DWORD key, void FAR* FAR& value) const
                        { return m_mkv.Lookup((LPVOID) &key, sizeof(DWORD), (LPVOID)&value); }

   BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
                        { return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

   BOOL    LookupAdd(DWORD key, void FAR* FAR& value) const
                        { return m_mkv.LookupAdd((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

   // Add/Delete
   // add a new (key, value) pair
   BOOL    SetAt(DWORD key, void FAR* value)
                        { return m_mkv.SetAt((LPVOID) &key, sizeof(DWORD), (LPVOID)&value); }
   BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
                        { return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

   // removing existing (key, ?) pair
   BOOL    RemoveKey(DWORD key)
                        { return m_mkv.RemoveKey((LPVOID) &key, sizeof(DWORD)); }

   BOOL    RemoveHKey(HMAPKEY hKey)
                        { return m_mkv.RemoveHKey(hKey); }

   void    RemoveAll()
                        { m_mkv.RemoveAll(); }


   // iterating all (key, value) pairs
   POSITION GetStartPosition() const
                        { return m_mkv.GetStartPosition(); }

   void    GetNextAssoc(POSITION FAR& rNextPosition, DWORD FAR& rKey, void FAR* FAR& rValue) const
                        { m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

   HMAPKEY GetHKey(DWORD key) const
                        { return m_mkv.GetHKey((LPVOID)&key, sizeof(DWORD)); }

#ifdef _DEBUG
   void    AssertValid() const
                        { m_mkv.AssertValid(); }
#endif

private:
   CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\map_kv.cxx ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////
#include "headers.cxx"
#pragma hdrstop

#include <olecoll.h>
#include "map_kv.h"
#include "plex.h"


/////////////////////////////////////////////////////////////////////////////


//CMapKeyToValue::CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey,
CMapKeyToValue::CMapKeyToValue(UINT cbValue, UINT cbKey,
   int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
   Assert(nBlockSize > 0);

   m_cbValue = cbValue;
   m_cbKey = cbKey;
   m_cbKeyInAssoc = cbKey == 0 ? sizeof(CKeyWrap) : cbKey;

   m_pHashTable = NULL;
   m_nHashTableSize = nHashSize;
   m_lpfnHashKey = lpfnHashKey;

   m_nCount = 0;
   m_pFreeList = NULL;
   m_pBlocks = NULL;
   m_nBlockSize = nBlockSize;
   //if (memctx == MEMCTX_SAME)
   //   memctx = CoMemctxOf(this);
   //m_memctx = memctx;
   //Assert(m_memctx != MEMCTX_UNKNOWN);
}

CMapKeyToValue::~CMapKeyToValue()
{
   ASSERT_VALID(this);
   RemoveAll();
   Assert(m_nCount == 0);
}


// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)pKey;

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}


BOOL CMapKeyToValue::InitHashTable()
{
   ASSERT_VALID(this);
   Assert(m_nHashTableSize  > 0);
   
   if (m_pHashTable != NULL)
        return TRUE;

   Assert(m_nCount == 0);

   if ((m_pHashTable = (CAssoc FAR* FAR*)CoTaskMemAlloc(m_nHashTableSize * sizeof(CAssoc FAR*))) == NULL)
        return FALSE;

   memset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

   ASSERT_VALID(this);

   return TRUE;
}


void CMapKeyToValue::RemoveAll()
{
   ASSERT_VALID(this);

   // free all key values and then hash table
   if (m_pHashTable != NULL)
   {
        // destroy assocs
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
                register CAssoc FAR* pAssoc;
                for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                  pAssoc = pAssoc->pNext)
                        // assoc itself is freed by FreeDataChain below
                        FreeAssocKey(pAssoc);
        }

        // free hash table
        CoTaskMemFree(m_pHashTable);
        m_pHashTable = NULL;
   }

   m_nCount = 0;
   m_pFreeList = NULL;
   m_pBlocks->FreeDataChain();
   m_pBlocks = NULL;

   ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
   if (m_pFreeList == NULL)
   {
        // add another block
        CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, SizeAssoc());

        if (newBlock == NULL)
                return NULL;

        // chain them into free list
        register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
        // free in reverse order to make it easier to debug
        pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
        for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
        {
                ((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
                m_pFreeList = (CAssoc FAR*)pbAssoc;
        }
   }
   Assert(m_pFreeList != NULL); // we must have something

   CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

   // init all fields except pNext while still on free list
   pAssoc->nHashValue = hash;
   if (!SetAssocKey(pAssoc, pKey, cbKey))
        return NULL;

   SetAssocValue(pAssoc, pValue);

   // remove from free list after successfully initializing it (except pNext)
   m_pFreeList = m_pFreeList->pNext;
   m_nCount++;
   Assert(m_nCount > 0);       // make sure we don't overflow

   return pAssoc;
}


// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
   pAssoc->pNext = m_pFreeList;
   m_pFreeList = pAssoc;
   m_nCount--;
   Assert(m_nCount >= 0);      // make sure we don't underflow

   FreeAssocKey(pAssoc);
}


// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
   if (m_lpfnHashKey)
       nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
   else
       nHash = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

   if (m_pHashTable == NULL)
        return NULL;

   // see if it exists
   register CAssoc  FAR* pAssoc;
   for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
   {
        if (CompareAssocKey(pAssoc, pKey, cbKey))
                return pAssoc;
   }
   return NULL;
}


BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
   LPVOID pKey1;
   UINT cbKey1;

   GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
   return cbKey1 == cbKey2 && memcmp(pKey1, pKey2, cbKey1) == 0;
}


BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
   Assert(cbKey == m_cbKey || m_cbKey == 0);

   if (m_cbKey == 0)
   {
        Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

        // alloc, set size and pointer
        if ((pAssoc->key.pKey = CoTaskMemAlloc(cbKey)) == NULL)
                return FALSE;

        pAssoc->key.cbKey = cbKey;
   }

   LPVOID pKeyTo;

   GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

   memcpy(pKeyTo, pKey, cbKey);

   return TRUE;
}


// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
   if (m_cbKey == 0)
   {
        // variable length key; go indirect
        *ppKey = pAssoc->key.pKey;
        *pcbKey = pAssoc->key.cbKey;
   }
   else
   {
        // fixed length key; key in assoc
        *ppKey = (LPVOID)&pAssoc->key;
        *pcbKey = m_cbKey;
   }
}


void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
   if (m_cbKey == 0)
        CoTaskMemFree(pAssoc->key.pKey);
}


void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
   *ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
   LPVOID pValueFrom;
   GetAssocValuePtr(pAssoc, &pValueFrom);
   Assert(pValue != NULL);
   memcpy(pValue, pValueFrom, m_cbValue);
}


void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
   LPVOID pValueTo;
   GetAssocValuePtr(pAssoc, &pValueTo);
   if (pValue == NULL)
        memset(pValueTo, 0, m_cbValue);
   else
        memcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
   UINT nHash;
   HMAPKEY hmapkey = (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
   return LookupHKey(hmapkey, pValue);
   //return LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
}


// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
   // REVIEW: would like some way to verify that hKey is valid
   register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
   if (pAssoc == NULL)
   {
        memset(pValue, 0, m_cbValue);
        return FALSE;       // not in map
   }

   ASSERT_VALID(this);

   GetAssocValue(pAssoc, pValue);
   return TRUE;
}


// lookup and if not found add; returns FALSE only if OOM; if added, 
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
   if (Lookup(pKey, cbKey, pValue))
        return TRUE;

   // value set to zeros since lookup failed

   return ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);
}


// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
   UINT nHash;
   register CAssoc  FAR* pAssoc;

   ASSERT_VALID(this);

   if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
   {
        if (!InitHashTable())
                // out of memory
                return FALSE;

        // it doesn't exist, add a new Association
        if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
                return FALSE;

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;

        ASSERT_VALID(this);
   }
   else
   {
        SetAssocValue(pAssoc, pValue);
   }

   return TRUE;
}


// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
   // REVIEW: would like some way to verify that hKey is valid
   register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
   if (pAssoc == NULL)
        return FALSE;       // not in map

   ASSERT_VALID(this);

   SetAssocValue(pAssoc, pValue);
   return TRUE;
}


// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
   ASSERT_VALID(this);

   if (m_pHashTable == NULL)
        return FALSE;       // nothing in the table

   register CAssoc  FAR* FAR* ppAssocPrev;
   UINT i;
   if (m_lpfnHashKey)
       i = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
   else
       i = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

   ppAssocPrev = &m_pHashTable[i];

   CAssoc  FAR* pAssoc;
   for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
   {
        if (CompareAssocKey(pAssoc, pKey, cbKey))
        {
                // remove it
                *ppAssocPrev = pAssoc->pNext;       // remove from list
                FreeAssoc(pAssoc);
                ASSERT_VALID(this);
                return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
   }
   return FALSE;   // not found
}


// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
   ASSERT_VALID(this);

   if (m_pHashTable == NULL)
        return FALSE;       // nothing in the table

   // REVIEW: would like some way to verify that hKey is valid
   CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
   if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
        // null hkey or bad hash value
        return FALSE;

   register CAssoc  FAR* FAR* ppAssocPrev;
   ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

   while (*ppAssocPrev != NULL)
   {
        if (*ppAssocPrev == pAssoc)
        {
                // remove it
                *ppAssocPrev = pAssoc->pNext;       // remove from list
                FreeAssoc(pAssoc);
                ASSERT_VALID(this);
                return TRUE;
        }
        ppAssocPrev = &(*ppAssocPrev)->pNext;
   }

   return FALSE;   // not found (must have a messed up list or passed 
                                // a key from another list)
}


HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
   UINT nHash;

   ASSERT_VALID(this);

   return (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition, 
        LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
   ASSERT_VALID(this);

   Assert(m_pHashTable != NULL);       // never call on empty map

   register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
   Assert(pAssocRet != NULL);

   if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
   {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
                if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                        break;
        Assert(pAssocRet != NULL);  // must find something
   }

   // find next association
   CAssoc  FAR* pAssocNext;
   if ((pAssocNext = pAssocRet->pNext) == NULL)
   {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
                if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                        break;
   }

   // fill in return data
   *pNextPosition = (POSITION) pAssocNext;

   // fill in key/pointer to key
   LPVOID pKeyFrom;
   UINT cbKey;
   GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
   if (m_cbKey == 0)
        // variable length key; just return pointer to key itself
        *(void FAR* FAR*)pKey = pKeyFrom;
   else
        memcpy(pKey, pKeyFrom, cbKey);

   if (pcbKey != NULL)
        *pcbKey = cbKey;

   // get value
   GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

void CMapKeyToValue::AssertValid() const
{
#ifdef _DEBUG
   Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

   Assert(m_nHashTableSize > 0);
   Assert(m_nCount == 0 || m_pHashTable != NULL);

   if (m_pHashTable != NULL)
        Assert(!IsBadReadPtr(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

   if (m_lpfnHashKey)
       Assert(!IsBadCodePtr((FARPROC)m_lpfnHashKey));

   if (m_pFreeList != NULL)
        Assert(!IsBadReadPtr(m_pFreeList, SizeAssoc()));

   if (m_pBlocks != NULL)
        Assert(!IsBadReadPtr(m_pBlocks, SizeAssoc() * m_nBlockSize));

   // some collections live as global variables in the libraries, but 
   // have their existance in some context.  Also, we can't check shared
   // collections since we might be checking the etask collection
   // which would cause an infinite recursion.
   // REVIEW: Assert(m_memctx == MEMCTX_SHARED || 
   // CoMemctxOf(this) == MEMCTX_UNKNOWN || CoMemctxOf(this) == m_memctx);
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\plex.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include "headers.cxx"
#pragma hdrstop

//#include <ole2int.h>
#include "plex.h"
  
// Collection support

#define CairoleAssert(x) thkAssert(x)

CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, UINT nMax, UINT cbElement)
{
   CairoleAssert(nMax > 0 && cbElement > 0);
   CPlex FAR* p = (CPlex FAR*)CoTaskMemAlloc(sizeof(CPlex) + nMax * cbElement);
   if (p == NULL)
        return NULL;

   p->nMax = nMax;
   p->nCur = 0;
   p->pNext = pHead;
   pHead = p;  // change head (adds in reverse order for simplicity)
   return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
        CoTaskMemFree(pThis);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#ifndef __PLEX_H__
#define __PLEX_H__

#define INTERNAL_(x) x

struct FAR CPlex    // warning variable length structure
{
   CPlex FAR* pNext;
   UINT nMax;
   UINT nCur;
   /* BYTE data[maxNum*elementSize]; */

   INTERNAL_(void FAR*) data() { return this+1; }

   static INTERNAL_(CPlex FAR*) Create(CPlex FAR* FAR& head, UINT nMax, UINT cbElement);

   INTERNAL_(void) FreeDataChain();       // free this one and links
};

#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\stalloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	stalloc.cxx
//
//  Contents:	CStackAllocator
//
//  History:	29-Sep-94	DrewB	Created
//
//  Notes:      Loosely based on BobDay's original PSTACK implementation
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

// Pad a count to the given alignment
// Alignment must be 2^n-1
#define ALIGN_CB(cb, align) \
    (((cb)+(align)) & ~(align))

//+---------------------------------------------------------------------------
//
//  Structure:	SStackBlock (sb)
//
//  Purpose:	Header information for stack blocks
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

struct SStackBlock
{
    DWORD dwNextBlock;
    DWORD dwStackTop;
};

#define BLOCK_OVERHEAD (sizeof(SStackBlock))
#define BLOCK_START(mem) ((mem)+BLOCK_OVERHEAD)
#define BLOCK_AVAILABLE(cb) ((cb)-BLOCK_OVERHEAD)

//+---------------------------------------------------------------------------
//
//  Function:	CStackAllocator::CStackAllocator, public
//
//  Arguments:	[pmm] - Memory model to use
//              [cbBlock] - Size of chunk to allocate when necessary
//              [cbAlignment] - Alignment size, must be 2^N
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

CStackAllocator::CStackAllocator(CMemoryModel *pmm,
                                 DWORD cbBlock,
                                 DWORD cbAlignment)
{
    thkAssert(BLOCK_AVAILABLE(cbBlock) > 0);

    // Ensure that the alignment is a power of two
    thkAssert((cbAlignment & (cbAlignment-1)) == 0);
    // Store alignment - 1 since that's the actual value we need for
    // alignment computations
    _cbAlignment = cbAlignment-1;

    // Ensure that overhead and tracking will not affect alignment
    thkAssert(ALIGN_CB(BLOCK_OVERHEAD, _cbAlignment) == BLOCK_OVERHEAD &&
              ALIGN_CB(sizeof(SStackMemTrace), _cbAlignment) ==
              sizeof(SStackMemTrace));

    _pmm = pmm;
    _cbBlock = cbBlock;
    _dwBlocks = 0;
    _dwCurrent = 0;
    _cbAvailable = 0;

    _psaNext = NULL;
    _fActive = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStackAllocator::~CStackAllocator, public virtual
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

CStackAllocator::~CStackAllocator(void)
{
    Reset();
}

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::Alloc, public
//
//  Synopsis:   Allocates a chunk of memory from the stack
//
//  Arguments:  [cb] - Amount of memory to allocate
//
//  Returns:    Pointer to memory or NULL
//
//  History:    29-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD CStackAllocator::Alloc(DWORD cb)
{
    DWORD dwMem;

    thkAssert(cb > 0);

    // Round size up to maintain alignment of stack
    cb = ALIGN_CB(cb, _cbAlignment);

#if DBG == 1
    // Reserve space to record caller
    cb += sizeof(SStackMemTrace);
#endif

    thkAssert(cb <= BLOCK_AVAILABLE(_cbBlock));

    // Check to see if the current block can hold the new allocation
    if (cb > _cbAvailable)
    {
        DWORD dwBlock;
        SStackBlock UNALIGNED *psb;

        // It's too big, so allocate a new block
        dwBlock = _pmm->AllocMemory(_cbBlock);
        if (dwBlock == 0)
        {
            return 0;
        }

        if (_dwBlocks != 0)
        {
            // Update current top block
            psb = (SStackBlock UNALIGNED *)
                _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
            psb->dwStackTop = _dwCurrent;
            _pmm->ReleasePtr(_dwBlocks);
        }

        // Make the new block the top block
        psb = (SStackBlock UNALIGNED *)
            _pmm->ResolvePtr(dwBlock, sizeof(SStackBlock));
        psb->dwNextBlock = _dwBlocks;
        _dwBlocks = dwBlock;
        _pmm->ReleasePtr(dwBlock);

        _dwCurrent = BLOCK_START(dwBlock);
        _cbAvailable = BLOCK_AVAILABLE(_cbBlock);
    }

    thkAssert(_cbAvailable >= cb);

    dwMem = _dwCurrent;
    _dwCurrent += cb;
    _cbAvailable -= cb;

#if DBG == 1
    void *pvMem;

    // Fill memory to show reuse problems
    pvMem = _pmm->ResolvePtr(dwMem, cb);
    memset(pvMem, 0xED, cb);
    _pmm->ReleasePtr(dwMem);
#endif

#if DBG == 1
    SStackMemTrace UNALIGNED *psmt;

    psmt = (SStackMemTrace UNALIGNED *)
        _pmm->ResolvePtr(_dwCurrent-sizeof(SStackMemTrace),
                         sizeof(SStackMemTrace));
    psmt->cbSize = cb-sizeof(SStackMemTrace);

    //
    // On RISC platforms, psmt points to an unaligned structure.
    // Use a temp variable so we don't get an alignment fault
    // when RtlGetCallersAddress returns the value.
    //
    void *pv;
    void *pvCaller;
    RtlGetCallersAddress(&pvCaller, &pv);
    psmt->pvCaller = pvCaller;

    thkDebugOut((DEB_MEMORY, "Stack: %p alloc 0x%08lX:%3d, avail %d\n",
                 psmt->pvCaller, dwMem, cb, _cbAvailable));

    _pmm->ReleasePtr(_dwCurrent-sizeof(SStackMemTrace));
#endif

    return dwMem;
}

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::Free, public
//
//  Synopsis:   Frees allocated memory
//
//  Arguments:  [dwMem] - Memory
//              [cb] - Amount of memory allocated
//
//  History:    29-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CStackAllocator::Free(DWORD dwMem, DWORD cb)
{
    thkAssert(dwMem != 0);
    thkAssert(cb > 0);

    // Round size up to maintain alignment of stack
    cb = ALIGN_CB(cb, _cbAlignment);

#if DBG == 1
    cb += sizeof(SStackMemTrace);
#endif

    thkAssert(cb <= BLOCK_AVAILABLE(_cbBlock));

#if DBG == 1
    void *pvCaller;

    void *pv;
    RtlGetCallersAddress(&pvCaller, &pv);

    thkDebugOut((DEB_MEMORY, "Stack: %p frees 0x%08lX:%3d, avail %d\n",
                 pvCaller, dwMem, cb, _cbAvailable));
#endif

#if DBG == 1
    if (_dwCurrent-cb != dwMem)
    {
        thkDebugOut((DEB_ERROR, "Free of %d:%d is not TOS (0x%08lX)\n",
                     dwMem, cb, _dwCurrent));

        thkAssert(_dwCurrent-cb == dwMem);
    }
#endif

    _dwCurrent -= cb;
    _cbAvailable += cb;

#if DBG == 1
    void *pvMem;

    // Fill memory to show reuse problems
    pvMem = _pmm->ResolvePtr(dwMem, cb);
    memset(pvMem, 0xDD, cb);
    _pmm->ReleasePtr(dwMem);
#endif

    if (_dwCurrent == BLOCK_START(_dwBlocks))
    {
        SStackBlock UNALIGNED *psb;
        DWORD dwBlock;

        // If we've just freed up an entire block and it's not the
        // only block for the stack, free the block itself and
        // restore stack state from the next block
        // We keep the first block around forever to avoid memory
        // thrashing

        psb = (SStackBlock UNALIGNED *)
            _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
        dwBlock = psb->dwNextBlock;
        _pmm->ReleasePtr(_dwBlocks);

        if (dwBlock != 0)
        {
            _pmm->FreeMemory(_dwBlocks);

            _dwBlocks = dwBlock;
            psb = (SStackBlock UNALIGNED *)
                _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
            _dwCurrent = psb->dwStackTop;
            _cbAvailable = _cbBlock-(_dwCurrent-_dwBlocks);
            _pmm->ReleasePtr(_dwBlocks);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CStackAllocator::Reset, public
//
//  Synopsis:	Releases all memory in the stack
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CStackAllocator::Reset(void)
{
    DWORD dwBlock;
    SStackBlock UNALIGNED *psb;

    while (_dwBlocks != 0)
    {
        psb = (SStackBlock UNALIGNED *)
            _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
        dwBlock = psb->dwNextBlock;
        _pmm->ReleasePtr(_dwBlocks);

        _pmm->FreeMemory(_dwBlocks);

        _dwBlocks = dwBlock;
    }

    _dwCurrent = 0;
    _cbAvailable = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::RecordState, public debug
//
//  Synopsis:   Records the current state of the stack
//
//  Arguments:  [psr] - Storage space for information
//
//  Modifies:   [psr]
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CStackAllocator::RecordState(SStackRecord *psr)
{
    psr->dwStackPointer = _dwCurrent;
    psr->dwThreadId = GetCurrentThreadId();
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::CheckState, public debug
//
//  Synopsis:   Checks recorded information about the stack against its
//              current state
//
//  Arguments:  [psr] - Recorded information
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CStackAllocator::CheckState(SStackRecord *psr)
{
    thkAssert(psr->dwThreadId == GetCurrentThreadId());

    if ((psr->dwStackPointer != 0 && psr->dwStackPointer != _dwCurrent) ||
        (psr->dwStackPointer == 0 &&
         _dwCurrent != 0 && _dwCurrent != BLOCK_START(_dwBlocks)))
    {
        thkDebugOut((DEB_ERROR, "Stack alloc change: 0x%08lX to 0x%08lX\n",
                     psr->dwStackPointer, _dwCurrent));

        if (_dwCurrent > BLOCK_START(_dwBlocks))
        {
            SStackMemTrace UNALIGNED *psmt;

            psmt = (SStackMemTrace UNALIGNED *)
                _pmm->ResolvePtr(_dwCurrent-sizeof(SStackMemTrace),
                                 sizeof(SStackMemTrace));
            thkDebugOut((DEB_ERROR, "Top alloc: %d bytes by %p\n",
                         psmt->cbSize, psmt->pvCaller));
            _pmm->ReleasePtr(_dwCurrent-sizeof(SStackMemTrace));
        }

        thkAssert(!((psr->dwStackPointer != 0 &&
                     psr->dwStackPointer != _dwCurrent) ||
                    (psr->dwStackPointer == 0 &&
                     _dwCurrent != 0 ||
                      _dwCurrent != BLOCK_START(_dwBlocks))));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\olethk32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       olethk32.cxx
//
//  Contents:   Main routines for olethk32.dll
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <thkmgr.hxx>
#include <stdio.h>


DECLARE_INFOLEVEL(thk);
DECLARE_INFOLEVEL(Stack);

// Interop is disabled at load time
DATA16 gdata16Data;
BOOL gfIteropEnabled;

#if DBG == 1
BOOL fSaveProxy = FALSE;        // Used to find apps who call dead proxies
BOOL fStabilizeProxies = TRUE;  // Used to easily disable stabilization
BOOL fZapProxy = FALSE;         // Used to zap entries in freelist

#if defined(__cplusplus)
extern "C"
{
#endif
void CallOutputFunctions(const char *buffer);
#if defined(__cplusplus)
}
#endif

#endif

CLIPFORMAT g_cfLinkSourceDescriptor, g_cfObjectDescriptor;

BYTE g_abLeadTable[256];

//+---------------------------------------------------------------------------
//
//  Function:   DoThreadDetach
//
//  Synopsis:   When a thread is detaching, cleanup for it.
//
//  Effects:    This is called during both DLL_THREAD_DETACH, and
//		DLL_PROCESS_DETACH.
//
//  Arguments:  (none)
//
//  History:    3-18-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
DoThreadDetach()
{
    thkDebugOut((DEB_DLL,"_IN DoThreadDetach\n"));
    //
    // If there is thunk data, clean it up now.
    //
    if (TlsGetValue(dwTlsThkIndex) != NULL)
    {
	thkDebugOut((DEB_DLL,"DoThreadDetach calling ThkMgrUninitialize\n"));
	ThkMgrUninitialize(0, 0, 0);
    }
    thkDebugOut((DEB_DLL,"OUT DoThreadDetach\n"));
}
//+---------------------------------------------------------------------------
//
//  Function:   LibMain, public
//
//  Synopsis:   DLL initialization entry point
//
//  History:    23-Feb-94       DrewB   Created
//
//  Notes:
//
//	(KevinRo 19-Mar-95)
//
//	Caution needs to be exercised during cleanup. OLE32.DLL has
//	a pointer that we pass in during CoInitializeWOW. This pointer
//	is used to call back into OLETHK32 for cleanup purposes, as well as
//	accessing functions exposed by the 16-bit side. It is important that
//	when OLETHK32 unloads, the pointer in OLE32 is marked as invalid.
//	There is a call during the DLL_PROCESS_DETACH below that causes
//	OLE32 to invalidate its pointer.
//
//	In addition, the last thread attached to a DLL will not generate
//	a DLL_THREAD_DETACH. Instead, it generates a DLL_PROCESS_DETACH. This
//	means that DLL_PROCESS_DETACH should perform all the steps that
//	DLL_THREAD_DETACH does in addition to whatever DLL_PROCESS_DETACH work
//	that needs to be done.
//
//	Lastly, OLETHK32.DLL is statically linked to OLE32.DLL. This means
//	that OLETHK32.DLL's DLL_PROCESS_DETACH will be called before OLE32's.
//	That is why it is safe for us to call the OLE32 entry point during
//	DLL_PROCESS_DETACH
//----------------------------------------------------------------------------

extern "C" BOOL __cdecl LibMain(HANDLE hDll,
                                 DWORD dwReason,
                                 LPVOID lpReserved)
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
#if DBG == 1
        char achInfoLevel[80];

        if(thkInfoLevel == (DEB_ERROR | DEB_WARN) &&
           GetProfileStringA("olethk32", "InfoLevel", "3", achInfoLevel,
                             sizeof(achInfoLevel)) > 0)
        {
            thkInfoLevel = strtol (achInfoLevel, NULL, 0);
        }
#endif
	thkDebugOut((DEB_DLL,"_IN DLL_PROCESS_ATTACH\n"));

        //
        // Save a slot in the thread local storage for our PSTACK (pseudo-
        // stack) pointer.
        //

        if (!TlsThkAlloc())
        {
            thkDebugOut((DEB_WARN, "TlsThkAlloc failed\n"));
            return FALSE;
        }
	thkDebugOut((DEB_DLL,"OUT DLL_PROCESS_ATTACH\n"));
        break;

    case DLL_THREAD_ATTACH:
	thkDebugOut((DEB_DLL,"_IN DLL_THREAD_ATTACH\n"));
	TlsSetValue(dwTlsThkIndex, NULL);
	thkDebugOut((DEB_DLL,"OUT DLL_THREAD_ATTACH\n"));
        break;

    case DLL_THREAD_DETACH:
	thkDebugOut((DEB_DLL,"_IN DLL_THREAD_DETACH\n"));

	//
	// Call OLE32.DLL and tell it to cleanup for this thread. This will
	// not mark OLE32's ptr invalid since this is only a thread detach
        // and not a process detach. This is a private API between OLE32 and
        // OLETHK32.
	//
	thkDebugOut((DEB_DLL,"Calling Unload WOW for Thread Detach\n"));

	CoUnloadingWOW(FALSE);

        //
        // When the thread for this task goes away, we need to clean out
	// the thunk manager.
	//

        DoThreadDetach();

	thkDebugOut((DEB_DLL,"OUT DLL_THREAD_DETACH\n"));
        break;

    case DLL_PROCESS_DETACH:
	thkDebugOut((DEB_DLL,
		     "IN DLL_PROCESS_DETACH: %s\n",
		     lpReserved?"Process Exit":"Dll Unload"));

	//
	// The last threads cleanup needs to be done here.
	//
	if (lpReserved == NULL)
	{
	    //
	    // Call OLE32.DLL and tell it to cleanup for this thread, and to
	    // never call us again, since we are going away. This is a private
	    // API between OLE32 and OLETHK32. This call will mark OLE32's
	    // private pointer to us as invalid.
	    //
	    thkDebugOut((DEB_DLL,"Calling Unload WOW\n"));

	    CoUnloadingWOW(TRUE);

	    //
	    // lpReserved being NULL means this cleanup is due to
	    // a FreeLibrary. If it was due to process exit, there
	    // is no way for us to determine the state of the data
	    // structures in the system. Other threads may have been
	    // right smack in the middle of taking apart data structures.
	    //
	    //
	    // Chicago unloads DLL's differently than NT. On Chicago, the
	    // 32-bit side cleans up first, plus resources allocated on
	    // the 32-bit side are released when the 16-bit process goes
	    // away. On NT, the 16-bit process is treated like a thread,
	    // so we have to cleanup.
	    //
	    DoThreadDetach();

	    //
	    // Only cleanup the memory if the process is not going away.
	    // On Windows NT, there are cases when the NTVDM needs to be
	    // blown away. We shouldn't be calling back to the 16-bit
	    // side in this case. Therefore, we explicitly call free here
	    // instead of putting it in the destructor.
	    //
	    flFreeList32.FreeMemoryBlocks();
	    flHolderFreeList.FreeMemoryBlocks();
	    flRequestFreeList.FreeMemoryBlocks();
	}

    TlsThkFree();

	thkDebugOut((DEB_DLL,"OUT DLL_PROCESS_DETACH\n"));
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IntOpInitialize, public
//
//  Synopsis:   Initializes the 32-bit interoperability code
//
//  Arguments:  [lpdata16] - 16-bit call data
//              [dw1] - Ignored
//              [dw2] - Ignored
//
//  Returns:    Appropriate status code
//
//  History:    22-Feb-94       JohannP Created
//
//----------------------------------------------------------------------------

STDAPI IntOpInitialize(LPDATA16 lpdata16, DWORD dw1, DWORD dw2)
{
    int i;

    thkDebugOut((DEB_ITRACE | DEB_THUNKMGR, "_IN IntOpInitialize (%08lX)\n",
                 lpdata16));

    thkAssert((THOP_LASTOP & ~THOP_OPMASK) == 0);

#if DBG == 1
    char achInfoLevel[80];

    if (GetProfileIntA("olethk32", "BreakOnInit", FALSE))
    {
        // DebugBreak's in WOW are fatal unless the exception
        // is handled somehow.  If a debugger is hooked up,
        // it'll get first crack at the break exception
        // If not, our handler will ignore the exception so
        // execution can continue

        __try
        {
            DebugBreak();
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    fSaveProxy = GetProfileIntA("olethk32", "SaveProxy", FALSE);
    fZapProxy = GetProfileIntA("olethk32", "ZapProxy", FALSE);
    fStabilizeProxies = GetProfileIntA("olethk32", "Stabilize", TRUE);
#endif

    // Copy passed parameter from 16-bit world...
    memcpy( (LPVOID)&gdata16Data, (LPVOID)lpdata16, sizeof( DATA16 ) );
    // Enable interop
    gfIteropEnabled = TRUE;

    g_cfObjectDescriptor =
        (CLIPFORMAT) RegisterClipboardFormat(__TEXT("Object Descriptor"));
    g_cfLinkSourceDescriptor =
        (CLIPFORMAT) RegisterClipboardFormat(__TEXT("Link Source Descriptor"));
    if (g_cfObjectDescriptor == 0 || g_cfLinkSourceDescriptor == 0)
    {
        thkDebugOut((DEB_WARN, "IntOpInitialize: "
                     "Unable to register clipboard formats\n"));
        return E_UNEXPECTED;
    }

    // Create a lookup table for lead-byte-ness
    // so we can avoid calling IsDBCSLeadByte on every character
    // during string validation
    for (i = 0; i < 256; i++)
    {
        g_abLeadTable[i] = (BYTE)IsDBCSLeadByte((BYTE)i);
    }

    thkDebugOut((DEB_THUNKMGR | DEB_ITRACE, "OUT IntOpInitialize (%08lX)\n",
                 lpdata16));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:	IntOpUninitialize, public
//
//  Synopsis:	Cleanup initiated by 16-bit DLL unload
//
//  Arguments:	[dw1]
//              [dw2]
//              [dw3]
//
//  History:	29-Nov-94	DrewB	Created
//              10-20-97        Gopalk  Disabled interop as CompObj is no
//                                      longer present after this point
//
//  Notes:	(KevinRo) This routine is only called by compobj.dll. To make
//  things even more interesting, it is only called on Windows/NT. Win95
//  does the flFreeList16.FreeMemoryBlocks during PROCESS_DETACH. Cleanup
//  of the proxies is not neccessary on Win95, since the 16-bit process will
//  clean them up for us.
//
//----------------------------------------------------------------------------

STDAPI IntOpUninitialize(DWORD dw1, DWORD dw2, DWORD dw3)
{
    thkDebugOut((DEB_THUNKMGR | DEB_ITRACE, "_IN IntOpUninitialize\n"));

    // Remove all existing proxies since we're going to free the
    // proxy memory in the next step
    if (TlsThkGetData() != NULL)
    {
        CThkMgr *ptm = TlsThkGetThkMgr();

        if (ptm)
        {
            ptm->RemoveAllProxies();
        }
    }

    // Clean up the 16-bit freelist at this time because we know
    // that 16-bit code is still active and available for callback
    // If we waited for the freelist destructor to be called, 16-bit
    // code would already be cleaned up and the WOWGlobalFree calls
    // would fail
    flFreeList16.FreeMemoryBlocks();

    // Disable interop
    gfIteropEnabled = FALSE;
#if DBG==1
    // In debug builds zero out 16-bit callback function pointer so that
    // we fault in the 32-bit code if we call them hereafter
    memset( (LPVOID)&gdata16Data, 0, sizeof( DATA16 ) );
#endif 

    WgtDump();

    thkDebugOut((DEB_THUNKMGR | DEB_ITRACE, "OUT IntOpUninitialize\n"));
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:	ConvertHr1632Thunk, public
//
//  Synopsis:	Trivial function to allow calling HRESULT conversion
//              functions from 16-bit
//
//  Arguments:	[hr] - HRESULT to convert
//              [dw1]
//              [dw2]
//
//  Returns:	Appropriate status code
//
//  History:	26-Sep-94	DrewB	Created
//
//  Notes:      Required because 16-bit calls to CallProc32W use three
//              arguments
//
//----------------------------------------------------------------------------

STDAPI ConvertHr1632Thunk(HRESULT hr, DWORD dw1, DWORD dw2)
{
    return TransformHRESULT_1632(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:	ConvertHr3216Thunk, public
//
//  Synopsis:	Trivial function to allow calling HRESULT conversion
//              functions from 16-bit
//
//  Arguments:	[hr] - HRESULT to convert
//              [dw1]
//              [dw2]
//
//  Returns:	Appropriate status code
//
//  History:	26-Sep-94	DrewB	Created
//
//  Notes:      Required because 16-bit calls to CallProc32W use three
//              arguments
//
//----------------------------------------------------------------------------

STDAPI ConvertHr3216Thunk(HRESULT hr, DWORD dw1, DWORD dw2)
{
    return TransformHRESULT_3216(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:  	ThkAddAppCompatFlag
//
//  Synopsis: 	Takes the given flag and ORs it into the current app
//		compatibility flag set
//
//  Effects:
//
//  Arguments:	[dwFlag]	-- flag to set
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//     		15-Mar-95 alexgo    author
//
//  Notes:	This function exists so that 16bit thunk dll's may
//		also set app compatibility flags.  olethk32 code typically
//		sets the flags directly via TlsThkSetAppCompatFlags
//
//--------------------------------------------------------------------------

STDAPI_(void) ThkAddAppCompatFlag( DWORD dwFlag )
{
    DWORD dw;

    dw = TlsThkGetAppCompatFlags();

    dw |= dwFlag;

    TlsThkSetAppCompatFlags(dw);
}


#if DBG == 1
static LONG _wgtAllocated = 0;

//+---------------------------------------------------------------------------
//
//  Function:	WgtAllocLock, public debug
//
//  Synopsis:	Tracking for WOWGlobalAllocLock16
//
//  History:	29-Nov-94	DrewB	Created
//
//----------------------------------------------------------------------------

VPVOID WgtAllocLock(WORD wFlags, DWORD cb, HMEM16 *ph)
{
    HMEM16 h;
    VPVOID vpv;

    vpv = WOWGlobalAllocLock16(wFlags, cb, &h);
    if (vpv != 0)
    {
#ifdef WGT_TRACK
        if (WOWGlobalLockSize16(h, &cb) != 0)
        {
            _wgtAllocated += cb;
            WOWGlobalUnlock16(h);
        }
        else
        {
            thkDebugOut((DEB_WARN,
                         "Unable to get size of allocated block 0x%04lX\n",
                         h));

            // This is a guess at how big a block Win16 will allocate
            _wgtAllocated += (cb+31) & 31;
        }
#endif

        if (ph != NULL)
        {
            *ph = h;
        }
    }
    else
    {
        thkDebugOut((DEB_WARN,
                     "Unable to allocate %d bytes of 16-bit memory\n",
                     cb));
    }

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Function:	WgtUnlockFree, public
//
//  Synopsis:	Tracking for WOWGlobalUnlockFree16
//
//  History:	29-Nov-94	DrewB	Created
//
//----------------------------------------------------------------------------

void WgtUnlockFree(VPVOID vpv)
{
    HMEM16 h;
    DWORD cb;

    if (vpv == 0)
    {
        thkDebugOut((DEB_WARN, "Attempt to free NULL\n"));
    }
    else
    {
#ifdef WGT_TRACK
        // Total hack, incorrect
        h = (HMEM16)(vpv >> 16);

        if (WOWGlobalLockSize16(h, &cb) != 0)
        {
            _wgtAllocated -= cb;
            WOWGlobalUnlock16(h);
        }
        else
        {
            thkDebugOut((DEB_WARN,
                         "Unable to get size of allocated block 0x%04lX\n",
                         h));
        }
#endif

        WOWGlobalUnlockFree16(vpv);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	WgtDump, public
//
//  Synopsis:	Dumps global tracking information
//
//  History:	29-Nov-94	DrewB	Created
//
//----------------------------------------------------------------------------

void WgtDump(void)
{
    if (_wgtAllocated != 0)
    {
        thkDebugOut((DEB_WARN,
                     "%d bytes of 16-bit memory currently allocated\n",
                     _wgtAllocated));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	ThkCallOutputFunctions, public
//
//  Synopsis:	thunked pass-thru to Ole32 CallOutputFunctions for 16-bit land
//
//  History:	23-Jan-95	murthys	Created
//
//----------------------------------------------------------------------------

void ThkCallOutputFunctions(const char * buffer, PVOID dummy1, PVOID dummy2)
{
    CallOutputFunctions(buffer);
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\tc1632.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       tc1632.cxx
//
//  Notes:      This file is automatically generated
//      Do not modify by hand
//
//  History:    Fri May 27 10:39:02 1994        Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#if DBG == 1
extern "C" ULONG ThunkCall1632_count = 0;
extern "C" ULONG ThunkCall1632_break = 0;
#endif

DWORD ThunkCall1632(THUNKINFO *pti)
{
    DWORD dwReturn;

#if DBG == 1
    ULONG ulThunkCall1632_count = ++ThunkCall1632_count;
    thkAssert( (ThunkCall1632_count != ThunkCall1632_break) &&
               "Break Count Hit");
#endif

    thkAssert(pti->pvfn != NULL);
    thkAssert(*pti->pThop == THOP_END);
    pti->pThop++;
    thkAssert(*pti->pThop == THOP_ROUTINEINDEX);
    pti->pThop++;
    
    thkDebugOut((DEB_ITRACE, "%sIn ThunkCall1632 #(%x) %p, index %d\n",
                 NestingLevelString(), ulThunkCall1632_count, 
                 pti->pvfn, *pti->pThop));
    DebugIncrementNestingLevel();

    if (FAILED(pti->scResult))
    {
        DebugDecrementNestingLevel();
        thkDebugOut((DEB_ITRACE, "%sOut ThunkCall1632 #(%x) returns 0x%08lX\n",
                     NestingLevelString(), ulThunkCall1632_count, pti->scResult));
        return (DWORD)pti->scResult;
    }
    pti->pThkMgr->SetThkState(THKSTATE_NOCALL);
    switch(*pti->pThop)
    {
    case 0:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8)
            );
        break;
    case 1:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0)
            );
        break;
    case 2:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12)
            );
        break;
    case 3:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4)
            );
        break;
    case 4:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24)
            );
        break;
    case 5:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16)
            );
        break;
    case 6:
        dwReturn = (*(DWORD (__stdcall *)())pti->pvfn)(
            );
        break;
    case 7:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 8:
        dwReturn = (*(DWORD (__stdcall *)(
                WORD,
                WORD,
                DWORD))pti->pvfn)(
            *(WORD *)(pti->s32.pbStart+0),
            *(WORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8)
            );
        break;
    case 9:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 10:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4)
            );
        break;
    case 11:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER,
                ULARGE_INTEGER,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 12:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16)
            );
        break;
    case 13:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                ULARGE_INTEGER,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 14:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24),
            *(DWORD *)(pti->s32.pbStart+28),
            *(DWORD *)(pti->s32.pbStart+32),
            *(DWORD *)(pti->s32.pbStart+36),
            *(DWORD *)(pti->s32.pbStart+40)
            );
        break;
    case 15:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                SIZEL,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(SIZEL *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 16:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                SIZEL,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(SIZEL *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+16)
            );
        break;
    case 17:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                WORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(WORD *)(pti->s32.pbStart+8)
            );
        break;
    case 18:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                SIZEL))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(SIZEL *)(pti->s32.pbStart+4)
            );
        break;
    case 19:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                WORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(WORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8)
            );
        break;
    case 20:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24),
            *(DWORD *)(pti->s32.pbStart+28)
            );
        break;
    case 21:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                WORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(WORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24)
            );
        break;
    }

#if DBG == 1
    if ( !pti->fResultThunked && FAILED(dwReturn) )
    {
        thkDebugOut((DEB_FAILURES,
                     "ThunkCall1632 pvfn = %08lX Probably failed hr = %08lX\n",
                     pti->pvfn, dwReturn));
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }
#endif

    pti->pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT32);
    
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_ITRACE, "%sOut ThunkCall1632 #(%x) returns 0x%08lX\n",
                 NestingLevelString(), ulThunkCall1632_count, dwReturn));
    return dwReturn;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thopiint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thopiint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "thopsint.cxx"
#include "thtblint.cxx"
#include "vtblifn.cxx"
#include "vtblint.cxx"
#include "fntomthd.cxx"

THOPI CONST athopiInterfaceThopis[] =
{
    apthopsIUnknown, 3, tfnIUnknown, NULL
,    apthopsIClassFactory, 5, tfnIClassFactory, ftmIClassFactory
,    apthopsIMarshal, 9, tfnIMarshal, ftmIMarshal
,    apthopsIStdMarshalInfo, 4, tfnIStdMarshalInfo, ftmIStdMarshalInfo
,    apthopsIMessageFilter, 6, tfnIMessageFilter, ftmIMessageFilter
,    apthopsIExternalConnection, 5, tfnIExternalConnection, ftmIExternalConnection
,    apthopsIEnumString, 7, tfnIEnumString, ftmIEnumString
,    apthopsIEnumUnknown, 7, tfnIEnumUnknown, ftmIEnumUnknown
,    apthopsIEnumSTATSTG, 7, tfnIEnumSTATSTG, ftmIEnumSTATSTG
,    apthopsILockBytes, 10, tfnILockBytes, ftmILockBytes
,    apthopsIStream, 14, tfnIStream, ftmIStream
,    apthopsIStorage, 18, tfnIStorage, ftmIStorage
,    apthopsIRootStorage, 4, tfnIRootStorage, ftmIRootStorage
,    apthopsIEnumFORMATETC, 7, tfnIEnumFORMATETC, ftmIEnumFORMATETC
,    apthopsIEnumSTATDATA, 7, tfnIEnumSTATDATA, ftmIEnumSTATDATA
,    apthopsIDataObject, 12, tfnIDataObject, ftmIDataObject
,    apthopsIViewObject, 9, tfnIViewObject, ftmIViewObject
,    apthopsIViewObject2, 10, tfnIViewObject2, ftmIViewObject2
,    apthopsIAdviseSink, 8, tfnIAdviseSink, ftmIAdviseSink
,    apthopsIAdviseSink2, 9, tfnIAdviseSink2, ftmIAdviseSink2
,    apthopsIDataAdviseHolder, 7, tfnIDataAdviseHolder, ftmIDataAdviseHolder
,    apthopsIOleCache, 8, tfnIOleCache, ftmIOleCache
,    apthopsIOleCache2, 10, tfnIOleCache2, ftmIOleCache2
,    apthopsIOleCacheControl, 5, tfnIOleCacheControl, ftmIOleCacheControl
,    apthopsIDropTarget, 7, tfnIDropTarget, ftmIDropTarget
,    apthopsIDropSource, 5, tfnIDropSource, ftmIDropSource
,    apthopsIPersist, 4, tfnIPersist, ftmIPersist
,    apthopsIPersistStorage, 10, tfnIPersistStorage, ftmIPersistStorage
,    apthopsIPersistStream, 8, tfnIPersistStream, ftmIPersistStream
,    apthopsIPersistFile, 9, tfnIPersistFile, ftmIPersistFile
,    apthopsIBindCtx, 13, tfnIBindCtx, ftmIBindCtx
,    apthopsIMoniker, 23, tfnIMoniker, ftmIMoniker
,    apthopsIRunningObjectTable, 10, tfnIRunningObjectTable, ftmIRunningObjectTable
,    apthopsIEnumMoniker, 7, tfnIEnumMoniker, ftmIEnumMoniker
,    apthopsIEnumOLEVERB, 7, tfnIEnumOLEVERB, ftmIEnumOLEVERB
,    apthopsIOleObject, 24, tfnIOleObject, ftmIOleObject
,    apthopsIOleClientSite, 9, tfnIOleClientSite, ftmIOleClientSite
,    apthopsIRunnableObject, 8, tfnIRunnableObject, ftmIRunnableObject
,    apthopsIParseDisplayName, 4, tfnIParseDisplayName, ftmIParseDisplayName
,    apthopsIOleContainer, 6, tfnIOleContainer, ftmIOleContainer
,    apthopsIOleItemContainer, 9, tfnIOleItemContainer, ftmIOleItemContainer
,    apthopsIOleAdviseHolder, 9, tfnIOleAdviseHolder, ftmIOleAdviseHolder
,    apthopsIOleLink, 14, tfnIOleLink, ftmIOleLink
,    apthopsIOleWindow, 5, tfnIOleWindow, ftmIOleWindow
,    apthopsIOleInPlaceObject, 9, tfnIOleInPlaceObject, ftmIOleInPlaceObject
,    apthopsIOleInPlaceActiveObject, 10, tfnIOleInPlaceActiveObject, ftmIOleInPlaceActiveObject
,    apthopsIOleInPlaceUIWindow, 9, tfnIOleInPlaceUIWindow, ftmIOleInPlaceUIWindow
,    apthopsIOleInPlaceFrame, 15, tfnIOleInPlaceFrame, ftmIOleInPlaceFrame
,    apthopsIOleInPlaceSite, 15, tfnIOleInPlaceSite, ftmIOleInPlaceSite
,    apthopsIRpcChannelBuffer, 8, tfnIRpcChannelBuffer, ftmIRpcChannelBuffer
,    apthopsIRpcProxyBuffer, 5, tfnIRpcProxyBuffer, ftmIRpcProxyBuffer
,    apthopsIRpcStubBuffer, 10, tfnIRpcStubBuffer, ftmIRpcStubBuffer
,    apthopsIPSFactoryBuffer, 5, tfnIPSFactoryBuffer, ftmIPSFactoryBuffer
,    apthopsIRpcChannel, 7, tfnIRpcChannel, ftmIRpcChannel
,    apthopsIRpcProxy, 5, tfnIRpcProxy, ftmIRpcProxy
,    apthopsIRpcStub, 8, tfnIRpcStub, ftmIRpcStub
,    apthopsIPSFactory, 5, tfnIPSFactory, ftmIPSFactory
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thkmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thkmgr.cxx
//
//  Contents:   Thunk manager initialization
//              IUnknown transition functions
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   ThkMgrInitialize
//
//  Synopsis:   Creates a new thunkmanager and set it for given thread
//
//  Arguments:  [dw1]
//              [dw2]
//              [dw3]
//
//  Returns:    HRESULT
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//  Notes:      Called from CoInitialize
//
//----------------------------------------------------------------------------
STDAPI ThkMgrInitialize(DWORD dw1, DWORD dw2, DWORD dw3)
{
    CThkMgr *pcthkmgr = NULL;

    thkDebugOut((DEB_THUNKMGR, "In  ThkMgrInitialize()\n"));

    //
    // If we are already initialized, do nothing.
    //
    if (TlsGetValue(dwTlsThkIndex) != NULL)
    {
	thkDebugOut((DEB_THUNKMGR, "OUT ThkMgrInitialize() Already Init\n"));
	return(NOERROR);
    }

    //
    // initialize the Tls storage
    //
    if ( NOERROR != TlsThkInitialize())
    {
	thkDebugOut((DEB_ERROR, "TlsThkInitialize failed"));

	return E_OUTOFMEMORY;
    }

    thkAssert(TlsThkGetThkMgr() == NULL);

    pcthkmgr = CThkMgr::Create();
    TlsThkSetThkMgr(pcthkmgr);

    thkDebugOut((DEB_THUNKMGR, "Out ThkMgrInitialize() => %p\n",
                 pcthkmgr));

    return (pcthkmgr == NULL) ? E_OUTOFMEMORY : NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThkMgrUninitialize
//
//  Synopsis:   deletes the thunkmanager and removes it from thread data
//              tls data are removed as well
//
//  Arguments:  [dw1]
//              [dw2]
//              [dw3]
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//  Notes:      Called during CoUninitialize
//
//----------------------------------------------------------------------------
STDAPI_(void) ThkMgrUninitialize(DWORD dw1, DWORD dw2, DWORD dw3)
{
    thkDebugOut((DEB_THUNKMGR, "In ThkMgrUninitialize()\n"));

    thkAssert(TlsGetValue(dwTlsThkIndex) != NULL);

    CThkMgr *pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();
    if (pcthkmgr != NULL)
    {
        // Note: the thunkmanger gets removed from tlsthk
        delete pcthkmgr;
    }

    // If we weren't called from 16-bit code then it's not safe to reset
    // the 16-bit stack allocator here because we may be doing this
    // in thread cleanup and it may not be safe to call back into
    // 16-bit code

    TlsThkGetStack32()->Reset();

    // uninitialize the tls data for this apartment
    TlsThkUninitialize();

    thkDebugOut((DEB_THUNKMGR, "Out ThkMgrUninitialize()\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   IUnknownObj32
//
//  Synopsis:   Entry point from 16bit for IUnknown methods
//
//  Arguments:  [vpvThis16] -- Proxy object
//              [wMethod] -- IUnknown method
//              [vpvData] -- Call data
//
//  Returns:    Call result, pdata contains out data for particular call
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) IUnknownObj32(VPVOID vpvThis16, DWORD wMethod, VPVOID vpvData)
{
    DWORD dwRet;
    LONG vpvInterface;
    IID iid;

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: IUnknownObj32 call refused\n"));

        if (wMethod == SMI_QUERYINTERFACE)
        {
            return (DWORD)E_FAIL;
        }
        else
        {
            return 0;
        }
    }

    // Note: at this point we should always get a thunkmanager
    CThkMgr *pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    thkAssert(vpvThis16 != 0 && "IUnknownObj32: invalid pointer." );
    thkAssert(wMethod < SMI_COUNT);

    switch (wMethod)
    {
    case SMI_QUERYINTERFACE:
        thkAssert(vpvData != NULL &&
                  "IUnknownObj32.QueryInterface without IID");

        // Copy the 16-bit IID into 32-bit memory for the real call
        iid = *FIXVDMPTR(vpvData, IID);
        RELVDMPTR(vpvData);

        thkDebugOut((DEB_UNKNOWN,
                     "%sIn  QueryInterface1632(%p, %s)\n",
                     NestingLevelString(), vpvThis16,
                     IidOrInterfaceString(&iid)));

        dwRet = pcthkmgr->QueryInterfaceProxy1632(vpvThis16, iid,
                                                  (void **)&vpvInterface);

        // Translate the 32-bit HRESULT to a 16-bit HRESULT
        dwRet = (DWORD)TransformHRESULT_3216((HRESULT)dwRet);

        // Pass the return interface pointer back through the IID
        // memory.  We re-resolve the data pointer since nested
        // calls may have occurred
        (FIXVDMPTR(vpvData, IID))->Data1 = vpvInterface;
        RELVDMPTR(vpvData);

        thkDebugOut((DEB_UNKNOWN,
                     "%sOut QueryInterface1632(%p) => %p, 0x%08lX\n",
                     NestingLevelString(), vpvThis16, vpvInterface, dwRet));
        break;

    case SMI_ADDREF:
        thkDebugOut((DEB_UNKNOWN, "%sIn  AddRef1632(%p)\n",
                     NestingLevelString(), vpvThis16));

        dwRet = pcthkmgr->AddRefProxy1632(vpvThis16);

        thkDebugOut((DEB_UNKNOWN, "%sOut AddRef1632(%p) => %d\n",
                     NestingLevelString(), vpvThis16, dwRet));
        break;

    case SMI_RELEASE:
        thkDebugOut((DEB_UNKNOWN, "%sIn  Release1632(%p)\n",
                     NestingLevelString(), vpvThis16));

        dwRet = pcthkmgr->ReleaseProxy1632(vpvThis16);

        thkDebugOut((DEB_UNKNOWN, "%sOut Release1632(%p) => %d\n",
                     NestingLevelString(), vpvThis16, dwRet));
        break;
    }

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryInterfaceProxy3216
//
//  Synopsis:   call QueryInterface on a 32 bit proxy
//
//  Arguments:  [pto] -- This pointer (a 32->16 proxy)
//              [refiid] -- Interface queried for
//              [ppv] -- Interface return
//
//  Returns:    HRESULT
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
SCODE QueryInterfaceProxy3216(THUNK3216OBJ *pto, REFIID refiid, LPVOID *ppv)
{
    HRESULT hrRet;

    thkDebugOut((DEB_UNKNOWN, "%sIn  QueryInterface3216(%p, %s)\n",
                 NestingLevelString(), pto,
                 IidOrInterfaceString(&refiid)));
    DebugIncrementNestingLevel();

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: QIProxy3216 call refused\n"));

        return E_FAIL;
    }

    CThkMgr *pcthkmgr = TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    if ( pto->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "QueryInterfaceProxy3216: Attempt to QI "
                     "on cleaned-up proxy %08lX for 16-bit object %08lX %s\n",
                     pto, pto->vpvThis16,
                     IidIdxString(IID_IIDIDX(&refiid)) ));
        *ppv = NULL;
        return E_FAIL;
    }

    hrRet = pcthkmgr->QueryInterfaceProxy3216(pto, refiid, ppv);

    //
    // If the QI for IUnknown failed, then return the current this
    // pointer as the IUnknown. Watermark 1.02 appears to not support
    // IUnknown in its IOleInPlaceActiveObject interface, which causes
    // CoMarshalInterface to fail. The reason it used to work is the
    // original 16-bit DLL's would just use the provided pointer as
    // the punk if IUnknown wasn't supported. The following lines of
    // code emulate that behaviour.
    //
    if ((hrRet == E_NOINTERFACE) && IsEqualIID(refiid,IID_IUnknown))
    {
	thkDebugOut((DEB_UNKNOWN,
                 "%s Object %p didn't support QI(IID_IUnknown): Faking it\n",
                 NestingLevelString(), pto));
	((IUnknown *)pto)->AddRef();
	*ppv = pto;
	hrRet = S_OK;
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_UNKNOWN,
                 "%sOut QueryInterface3216(%p) => %p, ret:0x%08lX\n",
                 NestingLevelString(), pto, *ppv, hrRet));
    return hrRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefProxy3216
//
//  Synopsis:   call addref on an 16 bit object
//
//  Arguments:  [pto] -- This pointer (a 32->16 proxy)
//
//  Returns:    New refcount
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
DWORD AddRefProxy3216(THUNK3216OBJ *pto)
{
    DWORD   dwRet;

    thkDebugOut((DEB_UNKNOWN, "%sIn  AddRef3216(%p)\n",
                 NestingLevelString(), pto));
    DebugIncrementNestingLevel();

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: AddRefProxy3216 call refused\n"));

        return 0;
    }

    CThkMgr *pcthkmgr = TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    if ( pto->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "AddRefProxy3216: Attempt to AddRef "
                     "on cleaned-up proxy %08lX for 16-bit object %08lX\n",
                     pto, pto->vpvThis16));
        return 0;
    }

    dwRet = pcthkmgr->AddRefProxy3216(pto);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_UNKNOWN, "%sOut AddRef3216(%p) => %ld\n",
                 NestingLevelString(), pto, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseProxy3216
//
//  Synopsis:   Release implementation for 32->16 proxies
//
//  Arguments:  [pto] -- This pointer (a 32->16 proxy)
//
//  Returns:    New refcount
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
DWORD ReleaseProxy3216(THUNK3216OBJ *pto)
{
    DWORD   dwRet;

    thkDebugOut((DEB_UNKNOWN, "%sIn  Release3216(%p)\n",
                 NestingLevelString(), pto));
    DebugIncrementNestingLevel();

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: ReleaseProxy3216 call refused\n"));

        return 0;
    }

    CThkMgr *pcthkmgr = TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    if ( pto->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "ReleaseProxy3216: Attempt to Release "
                     "on cleaned-up proxy %08lX for 16-bit object %08lX\n",
                     pto, pto->vpvThis16));
        return 0;
    }

    dwRet = pcthkmgr->ReleaseProxy3216(pto);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_UNKNOWN, "%sOut Release3216(%p) => %ld\n",
                 NestingLevelString(), pto, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryInterfaceOnObj16
//
//  Synopsis:   call QueryInterface on an 16 bit object
//
//  Arguments:  [vpvThis16] -- 16-bit this pointer
//              [refiid] -- IID
//              [ppv] -- Interface return
//
//  Returns:    HRESULT
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

struct QIARGS
{
    IID iid;
    void *pvObject;
};

HRESULT QueryInterfaceOnObj16(VPVOID vpvThis16, REFIID refiid, LPVOID *ppv)
{
    HRESULT hrRet;
    VPVOID vpvArgs;
    QIARGS UNALIGNED *pqa;
    BYTE bArgs32[WCB16_MAX_CBARGS];

    thkDebugOut((DEB_THUNKMGR, "%sIn  QueryInterfaceOnObj16(%p, %s)\n",
                 NestingLevelString(), vpvThis16,
                 IidOrInterfaceString(&refiid)));
    DebugIncrementNestingLevel();

    thkAssert(WCB16_MAX_CBARGS >= 3*sizeof(DWORD));
    thkAssert(vpvThis16 != 0 && "QueryInterfaceOnObj16: invalid pointer.");

    // Allocate space for the sixteen bit arguments memory
    vpvArgs = STACKALLOC16(sizeof(QIARGS));
    if (vpvArgs == 0)
    {
        return E_OUTOFMEMORY;
    }

    // Fill in the in-param memory
    pqa = FIXVDMPTR(vpvArgs, QIARGS);
    pqa->iid = refiid;

    // Set up the 16-bit stack in pascal order
    *(VPVOID *)(bArgs32+0*sizeof(VPVOID)) = vpvArgs+
        FIELD_OFFSET(QIARGS, pvObject);
    *(VPVOID *)(bArgs32+1*sizeof(VPVOID)) = vpvArgs;
    *(VPVOID *)(bArgs32+2*sizeof(VPVOID)) = vpvThis16;

    RELVDMPTR(vpvArgs);

    // Call to 16-bit stub
    if (!CallbackTo16Ex(gdata16Data.fnQueryInterface16, WCB16_PASCAL,
                         3*sizeof(DWORD), bArgs32, (DWORD *)&hrRet))
    {
        hrRet = E_UNEXPECTED;
    }

    // Transform the 16-bit HRESULT to a 32-bit HRESULT
    hrRet = TransformHRESULT_1632(hrRet);

    // Copy back out-param memory
    pqa = FIXVDMPTR(vpvArgs, QIARGS);
    *ppv = pqa->pvObject;
    RELVDMPTR(vpvArgs);

    STACKFREE16(vpvArgs, sizeof(QIARGS));

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR,
                 "%sOut QueryInterfaceOnObj16(%p) => %p, ret:0x%08lX\n",
                 NestingLevelString(), vpvThis16, *ppv, hrRet));

    return hrRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefOnObj16
//
//  Synopsis:   calls addref on an 16 bit object
//
//  Arguments:  [vpvThis16] -- 16-bit this pointer
//
//  Returns:    New ref count
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#if DBG == 1
DWORD AddRefOnObj16(VPVOID vpvThis16)
{
    DWORD dwRet;

    thkDebugOut((DEB_THUNKMGR, "%sIn  AddRefOnObj16(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    dwRet = CallbackTo16(gdata16Data.fnAddRef16, vpvThis16);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut AddRefOnObj16(%p) => %ld\n",
                 NestingLevelString(), vpvThis16, dwRet));

    return dwRet;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseOnObj16
//
//  Synopsis:   Release a 16-bit object
//
//  Arguments:  [vpvThis16] -- 16-bit this pointer
//
//  Returns:    New ref count
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#if DBG == 1
DWORD ReleaseOnObj16(VPVOID vpvThis16)
{
    DWORD dwRet;

    thkDebugOut((DEB_THUNKMGR, "%sIn  ReleaseOnObj16(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    dwRet = CallbackTo16(gdata16Data.fnRelease16, vpvThis16);

#if DBG==1
    if(dwRet==0 && TlsThkGetThkMgr()->GetThkState()==THKSTATE_VERIFY16INPARAM) {
        thkDebugOut((DEB_WARN, "WARINING: 16-bit 0x%x IN parameter with zero "
                               "ref count\n", vpvThis16));
     
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }
#endif

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut ReleaseOnObj16(%p) => %ld\n",
                 NestingLevelString(), vpvThis16, dwRet));

    return dwRet;
}
#endif

#if DBG == 1
void DebugDump()
{
    CThkMgr *pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");
    pcthkmgr->DebugDump3216();
    pcthkmgr->DebugDump1632();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thop32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thop32.cxx
//
//  Contents:   Thop implementations for 32->16
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2.h>
#include <string.h>
#include <valid.h>
#include "olethk32.hxx"
#include "struct16.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   EXECUTE_THOP3216, public
//
//  Synopsis:   Debugging version of thop dispatch routine
//
//  Arguments:  [pti] - Thunking info
//
//  Returns:    Appropriate status
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
DWORD EXECUTE_THOP3216(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExThop3216: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 ThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();
    
    // Local variable
    DWORD dwRet;

    // Sanity check
    thkAssert((*pti->pThop & THOP_OPMASK) < THOP_LASTOP);
    dwRet = (*aThopFunctions3216[*((pti)->pThop) & THOP_OPMASK])(pti);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExThop3216\n", NestingLevelString()));
    return(dwRet);
}
#endif

#if DBG == 1
DWORD EXECUTE_ENUMTHOP3216(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExEnumThop3216: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 EnumThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();

    // Local variable
    DWORD dwRet;
    dwRet = (*aThopEnumFunctions3216[*(pti)->pThop])(pti);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExEnumThop3216\n", NestingLevelString()));
    return(dwRet);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   FixedThopHandler, public
//
//  Synopsis:   Generic function which handles the high-level details
//              of thop execution for thops that operate on known-size
//              data
//
//  Arguments:  [pti] - Thunking state information
//              [thop] - Thop being executed
//              [cb16] - 16-bit size
//              [pfn1632] - 16->32 conversion routine
//              [cb32] - 32-bit size
//              [pfn3216] - 32->16 conversion routine
//
//  Returns:    Appropriate status code
//
//  History:    05-Apr-94       DrewB   Created
//
//  Notes:      Automatically increments pThop
//
//----------------------------------------------------------------------------

DWORD FixedThopHandler3216(THUNKINFO *pti,
                           THOP thop,
                           UINT cb16,
                           FIXEDHANDLERROUTINE pfn1632,
                           UINT cb32,
                           FIXEDHANDLERROUTINE pfn3216)
{
    DWORD   dwResult;
    VPVOID  vp16;
    BYTE    *pb16;
    BYTE    *pb32;

    if ((thop & (THOP_IN | THOP_OUT)) != 0)
    {
        vp16 = 0;

        GET_STACK32(pti, pb32, BYTE *);
        if ( pb32 != 0 )
        {
            if ((thop & THOP_IN) != 0)
            {
                if (IsBadReadPtr(pb32, cb32))
                {
                    return (DWORD)E_INVALIDARG;
                }
            }
            if ((thop & THOP_OUT) != 0)
            {
                if (IsBadWritePtr(pb32, cb32))
                {
                    return (DWORD)E_INVALIDARG;
                }
            }

            vp16 = STACKALLOC16(cb16);
            if (vp16 == 0)
            {
                return (DWORD)E_OUTOFMEMORY;
            }
            else if ((thop & THOP_IN) != 0)
            {
                pb16 = (BYTE *)WOWFIXVDMPTR(vp16, cb16);
                (pfn3216)(pb32, pb16, cb32, cb16);
                WOWRELVDMPTR(vp16);
            }
        }

        TO_STACK16(pti, vp16, VPVOID);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);

        if ((thop & THOP_OUT) != 0 && pb32 != NULL)
        {
            if (SUCCEEDED(dwResult))
            {
                pb16 = (BYTE *)WOWFIXVDMPTR(vp16, cb16);
                (pfn1632)(pb16, pb32, cb16, cb32);
                WOWRELVDMPTR(vp16);
            }
            else if ((thop & THOP_IN) == 0)
            {
                // Zero out-only parameters on failure
                memset(pb32, 0, cb32);
            }
        }

        if (vp16 != 0)
        {
            STACKFREE16(vp16, cb16);
        }
    }
    else
    {
        (pfn3216)(PTR_STACK32(&pti->s32), PTR_STACK16(&pti->s16, cb16),
                  cb32, cb16);

        SKIP_STACK16(&pti->s16, cb16);
        SKIP_STACK32(&pti->s32, cb32);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);
    }

    return dwResult;
}

//-----------------------------------------------------------------------------
//
// Handler-based thunks
//
// These thunks use the fixed-size generic thop handler to do their work
//
//-----------------------------------------------------------------------------

// Handle straight copy
DWORD Thop_Copy_3216(THUNKINFO *pti)
{
    THOP thopSize;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_COPY);

    thopSize = *++pti->pThop;
    return FixedThopHandler3216(pti,
                                *(pti->pThop-1),
                                thopSize, FhCopyMemory,
                                thopSize, FhCopyMemory);
}

DWORD Thop_ShortToLong_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SHORTLONG);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(SHORT), FhShortToLong,
                                sizeof(LONG), FhLongToShort);
}

DWORD Thop_WordToDword_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_WORDDWORD);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(WORD), FhWordToDword,
                                sizeof(DWORD), FhDwordToWord);
}

DWORD Thop_GdiHandle_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HGDI);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhGdiHandle1632,
                                sizeof(HANDLE), FhGdiHandle3216);
}

DWORD Thop_UserHandle_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HUSER);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhUserHandle1632,
                                sizeof(HANDLE), FhUserHandle3216);
}

DWORD Thop_HACCEL_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HACCEL);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHaccel1632,
                                sizeof(HANDLE), FhHaccel3216);
}

DWORD Thop_HTASK_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HTASK);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHtask1632,
                                sizeof(HANDLE), FhHtask3216);
}

DWORD Thop_HRESULT_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HRESULT);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HRESULT), FhHresult1632,
                                sizeof(HRESULT), FhHresult3216);
}

DWORD Thop_NULL_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_NULL);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(void *), FhNull,
                                sizeof(void *), FhNull);
}

DWORD Thop_RECT_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RECT);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(RECT16), FhRect1632,
                                sizeof(RECT), FhRect3216);
}

DWORD Thop_BINDOPTS_3216( THUNKINFO *pti )
{
    LPBIND_OPTS pbo;
    UINT cb;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BINDOPTS);

    PEEK_STACK32(pti, pbo, LPBIND_OPTS);
    if (!IsBadReadPtr(pbo, sizeof(LPBIND_OPTS)))
    {
        cb = pbo->cbStruct;
    }
    else
    {
        return (DWORD)E_INVALIDARG;
    }

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                cb, FhCopyMemory,
                                cb, FhCopyMemory);
}

DWORD Thop_SIZE_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZE);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(SIZE16), FhSize1632,
                                sizeof(SIZE), FhSize3216);
}

DWORD Thop_MSG_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_MSG);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(MSG16), FhMsg1632,
                                sizeof(MSG), FhMsg3216);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ERROR_3216, public
//
//  Synopsis:   Any Thop type which should just fail with an error
//              should go be directed here.
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_ERROR_3216 ( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ERROR);

    thkAssert( FALSE && "Hey we hit an ERROR Thop in 32->16" );

    return (DWORD)E_UNEXPECTED;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInString3216, public
//
//  Synopsis:   Converts an in param string or filename
//
//  Arguments:  [pti] - Thunk state information
//              [fFile] - Filename or plain string
//              [cchMax] - Maximum length allowed or zero
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkInString3216(THUNKINFO *pti,
                        BOOL fFile,
                        UINT cchMax)
{
    DWORD       dwResult;
    LPOLESTR    lpstr32;
    VPSTR       vpstr16;
    UINT        uiSize;
    LPOLESTR    lpstrConv;
    LPOLESTR    lpstrShort;

    dwResult = (DWORD)S_OK;

    lpstrShort = NULL;

    GET_STACK32(pti, lpstr32, LPOLESTR);
    lpstrConv = lpstr32;

    vpstr16 = 0;
    if (lpstr32 != NULL)
    {
        if (IsBadStringPtrW(lpstr32, CCHMAXSTRING))
        {
            return (DWORD)E_INVALIDARG;
        }

        if (fFile)
        {
            DWORD cchNeeded, cchShort;

            // Special case zero-length paths since the length returns from
            // GetShortPathName become ambiguous when zero characters are
            // processed
            cchNeeded = lstrlenW(lpstr32);
            if (cchNeeded > 0)
            {
                cchNeeded = GetShortPathName(lpstr32, NULL, 0);
            }

            // If we can't convert, simply pass through the name we're given
            if (cchNeeded > 0)
            {
                lpstrShort = (LPOLESTR)CoTaskMemAlloc(cchNeeded*sizeof(WCHAR));
                if (lpstrShort == NULL)
                {
                    return (DWORD)E_OUTOFMEMORY;
                }

                cchShort = GetShortPathName(lpstr32, lpstrShort,
                                            cchNeeded);
                if (cchShort == 0 || cchShort > cchNeeded)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
                else
                {
                    lpstrConv = lpstrShort;
                }
            }
        }

        if (SUCCEEDED(dwResult))
        {
            uiSize = lstrlenW( lpstrConv ) + 1;

            vpstr16 = STACKALLOC16(uiSize*2);
            if (vpstr16 == 0)
            {
                dwResult = (DWORD)E_OUTOFMEMORY;
            }
            else
            {
                char *psz;

                dwResult = Convert_LPOLESTR_to_VPSTR(lpstrConv, vpstr16,
                                                     uiSize, uiSize*2);

                // If a maximum length was given, truncate the converted
                // string if necessary
                if (SUCCEEDED(dwResult) && cchMax > 0 && cchMax < uiSize)
                {
                    psz = (char *)WOWFIXVDMPTR(vpstr16, 0);
                    psz[cchMax] = 0;
                    WOWRELVDMPTR(vpstr16);
                }
            }
        }
    }

    if (SUCCEEDED(dwResult))
    {
#if DBG == 1
        thkDebugOut((DEB_ARGS, "%sIn3216  LPSTR %p -> %p '%s'\n",
                     NestingLevelString(), lpstr32, vpstr16,
                     vpstr16 != 0 ? WOWFIXVDMPTR(vpstr16, 0) : "<null>"));
        if (vpstr16 != 0)
        {
            WOWRELVDMPTR(vpstr16);
        }
#endif

        TO_STACK16(pti, vpstr16, VPSTR);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);
    }

    if (vpstr16 != 0)
    {
        STACKFREE16(vpstr16, uiSize*2);
    }

    if (lpstrShort != NULL)
    {
        CoTaskMemFree(lpstrShort);
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPSTR_3216, public
//
//  Synopsis:   Converts 32-bit LPOLESTR to 16-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LPSTR_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPSTR);
    //
    // We have only input LPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "LPSTR must be input only!" );

    return ThunkInString3216(pti, FALSE, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertTaskString1632, public
//
//  Synopsis:   Converts a task-memory string
//
//  Arguments:  [pti] - Thunk info
//              [vpstr16] - String
//              [posPreAlloc] - Preallocated string or NULL
//              [cchPreAlloc] - Preallocated size or zero
//              [ppos32] - String
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pti]
//              [ppos32]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Frees preallocation if successful and:
//                  Name is too large or
//                  Name is NULL
//
//              Always frees source string if non-zero
//
//----------------------------------------------------------------------------

SCODE ConvertTaskString1632(THUNKINFO *pti,
                            VPSTR vpstr16,
                            LPOLESTR posPreAlloc,
                            UINT cchPreAlloc,
                            LPOLESTR *ppos32)
{
    LPOLESTR pos32;

    if (vpstr16 == 0)
    {
        pos32 = NULL;
    }
    else
    {
        pos32 = Convert_VPSTR_to_LPOLESTR(pti, vpstr16, posPreAlloc,
                                          cchPreAlloc);

        TaskFree16(vpstr16);

        if (pos32 == NULL)
        {
            return pti->scResult;
        }
    }

    // If there was a preallocated string we didn't use,
    // free it
    if (posPreAlloc != NULL && posPreAlloc != pos32)
    {
        TaskFree32(posPreAlloc);
    }

    *ppos32 = pos32;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkOutString3216, public
//
//  Synopsis:   Converts an out param string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkOutString3216(THUNKINFO *pti)
{
    DWORD           dwResult;
    LPOLESTR        *lplpstr32;
    VPVOID          vpvpstr16;
    VPSTR UNALIGNED *lpvpstr16;
    LPOLESTR        lpstr32;

    GET_STACK32(pti, lplpstr32, LPOLESTR FAR *);

    if ( lplpstr32 == NULL )
    {
        vpvpstr16 = 0;
    }
    else
    {
        if (IsBadWritePtr(lplpstr32, sizeof(LPOLESTR)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpvpstr16 = STACKALLOC16(sizeof(VPSTR));
        if (vpvpstr16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        lpvpstr16 = FIXVDMPTR(vpvpstr16, VPSTR);
        *lpvpstr16 = 0;
        RELVDMPTR(vpvpstr16);

        lpstr32 = (LPOLESTR)TaskMalloc32(CBSTRINGPREALLOC);
        if (lpstr32 == NULL)
        {
            STACKFREE16(vpvpstr16, sizeof(VPSTR));
            return (DWORD)E_OUTOFMEMORY;
        }
    }

    TO_STACK16(pti, vpvpstr16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (lplpstr32 != NULL)
    {
        if (SUCCEEDED(dwResult))
        {
            lpvpstr16 = FIXVDMPTR(vpvpstr16, VPSTR);
            if (lpvpstr16 == NULL)
            {
                dwResult = (DWORD)E_INVALIDARG;
            }
            else
            {
                SCODE sc;

                sc = ConvertTaskString1632(pti, *lpvpstr16, lpstr32,
                                           CWCSTRINGPREALLOC, &lpstr32);
                if (FAILED(sc))
                {
                    dwResult = sc;
                }

                RELVDMPTR(vpvpstr16);
            }
        }

        if (FAILED(dwResult))
        {
            TaskFree32(lpstr32);

            *lplpstr32 = NULL;
        }
        else
        {
            *lplpstr32 = lpstr32;
        }

        thkDebugOut((DEB_ARGS, "Out3216 LPLPSTR: %p -> %p, '%ws'\n",
                     *lpvpstr16, lpstr32, lpstr32));
    }
    else
    {
        thkDebugOut((DEB_ARGS, "Out3216 LPLPSTR NULL\n"));
    }

    if (vpvpstr16 != 0)
    {
        STACKFREE16(vpvpstr16, sizeof(VPSTR));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPLPSTR_3216, public
//
//  Synopsis:   Converts 16-bit LPSTR to 32-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    26-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_LPLPSTR_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPLPSTR);
    //
    // We don't have anything but unmodified LPLPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "LPLPSTR must be unmodified only!" );

    return ThunkOutString3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_BUFFER_3216, public
//
//  Synopsis:   Converts 32-bit block of memory to 16-bit block of memory
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       BobDay  Created
//
//  Notes:      WARNING! WARNING! WARNING! For an out parameter this expects
//              three parameters on the stack in the following format and order:
//                  VOID *  pointer to buffer
//                  DWORD   count of bytes in buffer
//                  DWORD * count of bytes returned in the buffer
//
//----------------------------------------------------------------------------

#define WATCH_VALUE 0xfef1f0

DWORD Thop_BUFFER_3216( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    LPVOID      lp32;
    VPVOID      vp16;
    LPVOID      lp16;
    DWORD       dwCount;
    VPVOID      vp16CountOut;
    LPVOID      pvCountOut32;
    DWORD *     pdwCountOut32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BUFFER);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // Buffers can only be in or out
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "BUFFER must be in or out only!" );

    GET_STACK32(pti, lp32, LPVOID);
    GET_STACK32(pti, dwCount, DWORD);

    if (fThopOutput)
    {
        GET_STACK32(pti, pvCountOut32, LPVOID);
        pdwCountOut32 = (DWORD *) pvCountOut32;
    }

    if ( lp32 == NULL )
    {
        vp16 = 0;
    }
    else if (dwCount == 0)
    {
        // If the count is zero then we can pass any valid 16-bit
        // pointer

#if DBG == 1
        // In debug, make sure that no data is written back to the
        // memory we pass on
        vp16 = STACKALLOC16(sizeof(DWORD));

        if ( vp16 == 0 )
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        *FIXVDMPTR(vp16, DWORD) = WATCH_VALUE;
        RELVDMPTR(vp16);
#else
        vp16 = gdata16Data.atfnProxy1632Vtbl;
#endif
    }
    else
    {
        if ((fThopInput && IsBadReadPtr(lp32, dwCount)) ||
            (fThopOutput && IsBadWritePtr(lp32, dwCount)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vp16 = (VPVOID)WgtAllocLock( GMEM_MOVEABLE, dwCount, NULL );
        if ( vp16 == 0 )
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if ( fThopInput )
        {
            lp16 = (LPVOID)WOWFIXVDMPTR(vp16, dwCount);
            memcpy( lp16, lp32, dwCount );
            WOWRELVDMPTR(vp16);
        }
    }

    if (fThopOutput)
    {
        // We always allocate storage so we can guarantee that we
        // only copy the correct number of bytes.
        vp16CountOut = STACKALLOC16(sizeof(DWORD));

        if (vp16CountOut == 0)
        {
            return (DWORD) E_OUTOFMEMORY;
        }
    }

    thkDebugOut((DEB_ARGS, "3216    BUFFER: %p -> %p, %u\n",
                 lp32, vp16, dwCount));

    TO_STACK16(pti, vp16, VPVOID );
    TO_STACK16(pti, dwCount, DWORD );

    if (fThopOutput)
    {
        TO_STACK16(pti, vp16CountOut, VPVOID );
    }

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if ( SUCCEEDED(dwResult) && fThopOutput )
    {
        // Count of bytes to copy into the output buffer
        DWORD dwCountOut;

        // Get the output data count
        DWORD UNALIGNED *pdw16 = (DWORD UNALIGNED *)
            WOWFIXVDMPTR(vp16CountOut, sizeof(DWORD));

        // Save count to return to 32 bit caller.
        dwCountOut = *pdw16;
        if (pdwCountOut32)
        {
            // Note: this parameter can be a NULL pointer
            *pdwCountOut32 = dwCountOut;
        }

        WOWRELVDMPTR(vp16CountOut);

        // Copy data into output buffer if necessary.
        if (dwCountOut > 0)
        {
            lp16 = (LPVOID) WOWFIXVDMPTR( vp16, dwCountOut );
            memcpy( lp32, lp16, dwCountOut );
            WOWRELVDMPTR(vp16);
        }
    }

#if DBG == 1
    if (vp16 != 0 && dwCount == 0)
    {
        thkAssert(*FIXVDMPTR(vp16, DWORD) == WATCH_VALUE &&
                  (RELVDMPTR(vp16), TRUE));
        STACKFREE16(vp16, sizeof(DWORD));
    }
#endif

    //
    // Now free the buffers
    //
    if ( vp16 != 0 && dwCount > 0 )
    {
        WgtUnlockFree( vp16 );
    }

    if (fThopOutput && (vp16CountOut != 0))
    {
        STACKFREE16(vp16CountOut, sizeof(DWORD));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SNB_3216, public
//
//  Synopsis:   Converts 32-bit SNB to 16-bit SNB pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_SNB_3216( THUNKINFO *pti )
{
    DWORD           dwResult;
    BOOL            fThopInput;
    BOOL            fThopOutput;

    SNB             snbSrc32;             // Ptr to 32 bit Source SNB.
    LPOLESTR FAR    *lplpsTabSrc32;       // Ptr into 32 bit Source ptr table.
    LPOLESTR        lpstr32;              // Ptr into a Source Unicode data block.

    VPVOID          snbDest16s;           // Seg:Ptr to 16 bit Destination SNB.
    VPSTR UNALIGNED FAR *lpvpsTabDest16f; // Flat Ptr into 16 bit Dest ptr table.
    char UNALIGNED  *lpstrDest16f;        // Flat Ptr into 16 bit Dest data block.
    VPVOID          lpstrDest16s;         // Seg:Ptr  into 16 bit Dest data block.

    UINT            cPointers;      // Count of number of string pointers.
    UINT            cbStrings;      // Count of number of bytes in data table.
    UINT            cLength;
    UINT            cChars;
    UINT            cbAlloc;
    UINT            i;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SNB);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We don't have anything but unmodified SNBs
    //
    thkAssert( !fThopInput && !fThopOutput && "SNB must be unmodified only!" );

    GET_STACK32(pti, snbSrc32, LPOLESTR FAR *);

    if ( snbSrc32 == NULL )
    {
        snbDest16s = 0;
    }
    else
    {
        //
        // Count the strings in the 32-bit snb
        //
        lplpsTabSrc32 = snbSrc32;

        cPointers = 0;
        cbStrings = 0;
        do
        {
            cPointers++;
            if (IsBadReadPtr(lplpsTabSrc32, sizeof(LPOLESTR)))
            {
                return (DWORD)E_INVALIDARG;
            }

            lpstr32 = *lplpsTabSrc32++;

            if ( lpstr32 == NULL )
            {
                break;
            }

            if (IsBadStringPtrW(lpstr32, CCHMAXSTRING))
            {
                return (DWORD)E_INVALIDARG;
            }

            cbStrings += lstrlenW(lpstr32)+1;
        }
        while ( TRUE );

        //
        // Allocate a table for the 16-bit snb
        //   cPointers is a count of pointers plus the NULL pointer at the end.
        //
        cbAlloc = cPointers*sizeof(VPSTR)+cbStrings;
        snbDest16s = (VPVOID)STACKALLOC16(cbAlloc);
        if (snbDest16s == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        //
        // Set up the pointers to the destination table and string block.
        //   This gets a flat pointer to the pointer table, a both flat and
        //   segmented pointers to the data block.
        //
        lpvpsTabDest16f = (VPSTR UNALIGNED FAR *)WOWFIXVDMPTR( snbDest16s, cbAlloc );
        lpstrDest16f = (char UNALIGNED *)
                ((BYTE UNALIGNED *)lpvpsTabDest16f+cPointers*sizeof(VPSTR));
        lpstrDest16s = (VPVOID)((DWORD)snbDest16s+cPointers*sizeof(VPSTR));

        //
        // Now convert the strings
        //
        cPointers -= 1;
        lplpsTabSrc32 = snbSrc32;
        for(i=0; i<cPointers; i++)
        {
            lpstr32 = *lplpsTabSrc32++;

            thkAssert( lpstr32 != NULL && "Loop is processing end of snb\n" );

            cLength = lstrlenW( lpstr32 ) + 1;

            cChars = WideCharToMultiByte( AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                          0, lpstr32, cLength,
                                          lpstrDest16f, cbStrings, NULL, NULL );

            if ( cChars == 0 && cLength != 0 )
            {
                WOWRELVDMPTR(snbDest16s);
                STACKFREE16(snbDest16s, cbAlloc);
                return (DWORD)E_UNEXPECTED;
            }

            //
            // Assign the Segmented pointer into the pointer table.
            //
            *lpvpsTabDest16f++ = lpstrDest16s;

            //
            // Advance both the flat and segmented data pointers.
            //
            lpstrDest16f += cChars;
            lpstrDest16s = (VPVOID)((DWORD)lpstrDest16s + cChars);

            //
            // As we advance the Dest pointer the size of the remaining
            // space in the buffer decreases.
            //
            cbStrings -= cChars;
        }

        // Terminate SNB
        *lpvpsTabDest16f = NULL;

        thkAssert( *lplpsTabSrc32 == NULL &&
                   "Loop is out of sync with count\n" );

        WOWRELVDMPTR(snbDest16s);
    }

    thkDebugOut((DEB_ARGS, "In3216  SNB: %p -> %p\n", snbSrc32, snbDest16s));

    TO_STACK16(pti, snbDest16s, VPVOID );

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    //
    // Free SNB data if necessary
    //
    if ( snbDest16s != 0 )
    {
        STACKFREE16( snbDest16s, cbAlloc );
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInterface3216, private
//
//  Synopsis:   Handles 32->16 interface thunking for THOP_IFACE and
//              THOP_IFACEGEN
//
//  Arguments:  [pti]      - Thunking state information
//              [iidx]     - Interface IID or index
//              [thop]     - Thop being executed
//              [vpvOuter] - Controlling unknown passed to the 16-bit world
//
//  Returns:    Status code
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes:      Assumes pti->pThop is adjusted by caller
//----------------------------------------------------------------------------

DWORD ThunkInterface3216(THUNKINFO *pti, IIDIDX iidx, THOP thop, VPVOID vpvOuter)
{
    // Local variables
    DWORD dwResult, dwStatus;
    void *pv;
    VPVOID vpvOutParam;
    VPVOID vpvThis16In, vpvThis16Out;
    IUnknown *punkOut;
    IUnknown *punkIn;
    THUNK3216OBJ *ptoPreAlloc = NULL;
    PROXYHOLDER *pph = NULL;
    PROXYHOLDER *pAggHolder = NULL;
    SAggHolder aggHolderNode;
    BOOL        bUnlinkAggHolder = FALSE;

    // Validate the IID of the interface
    thkAssert(IIDIDX_IS_IID(iidx) ||
              (IIDIDX_INDEX(iidx) >= 0 &&  IIDIDX_INDEX(iidx) < THI_COUNT));

    // Initialize
    dwResult = (DWORD) S_OK;
    vpvOutParam = NULL;
    vpvThis16In = NULL;

    // Retrieve interface pointer
    GET_STACK32(pti, pv, void *);

    // Check for valid OUT parameter. It also verifies IN-OUT case as well
    if((thop & THOP_OUT) && pv) {
        if(IsBadReadPtr(pv, sizeof(void *)) || IsBadWritePtr(pv, sizeof(void *))) {
            thkDebugOut((DEB_WARN, "WARNING: failing - bad pointer %p\n", pv));
            return (DWORD) E_INVALIDARG;
        }
        
        // Check if the interface needs to be thunked IN as well.
        // In other words, IN-OUT paramenter case
        if(thop & THOP_IN)
            punkIn = *(IUnknown **)pv;
        else
            punkIn = NULL;
    }
    else {
        // It must be IN parameter or a NULL OUT parameter
        punkIn = (IUnknown *)pv;
    }

    // Check if interface needs to be thunked IN
    if(thop & THOP_IN) {
        if(punkIn) {
            // Validate the interface
            if(IsValidInterface(punkIn)) {
                if((thop & THOP_OPMASK) == THOP_UNKOUTER) {                        
                    // Aggregation being carried out
                    // Assert that it is only being thunked IN
                    thkAssert(!(thop & THOP_OUT));
                    thkAssert(iidx == THI_IUnknown);

                    // Either find the actual 16-bit identity or generate a
                    // new 16-bit proxy identity for the 32-bit identity
                    vpvThis16In = pti->pThkMgr->CreateOuter16(punkIn,  &pAggHolder, &dwStatus);
                    aggHolderNode.pph = pAggHolder;
                    TlsThkLinkAggHolder(&aggHolderNode);
                    bUnlinkAggHolder = TRUE;

                    // We use this pAggHolder for proxies of inner unk(s). Since
                    // we cannot put it in the proxy table (as it is private
                    // and we do not want other thunk calls to use it), we put
                    // it in a linked list in the TLS. The holder gets used by
                    // calls to FindAggregate() when the pUnkInner is being
                    // thunked out. The holder is revoked from the list when
                    // the ThunkInterface call for the pUnkOuter unwinds.
                    
                }
                else {
                    // Find/Generate the proxy for the 32-bit interface 
                    // to be thunked IN
                    vpvThis16In = pti->pThkMgr->FindProxy1632(NULL, punkIn, NULL, 
                                                              iidx, &dwStatus);
                }
                
                if(vpvThis16In) {
                    thkAssert(!((thop & THOP_OPMASK) == THOP_UNKOUTER) ||
                              (dwStatus == FST_CREATED_NEW) || 
                              (dwStatus == FST_SHORTCUT));
                }
                else {
                    thkDebugOut((DEB_WARN, "WARNING: failing - Can't create proxy for %p\n",
                                 punkIn));
                    return (DWORD) E_OUTOFMEMORY;
                }
            }
            else {
                thkDebugOut((DEB_WARN, "WARNING: failing - invalid interface %p\n", 
                             punkIn));
                return (DWORD) E_INVALIDARG;
            }
        }
        else {
            // No interface to be thunked IN
            vpvThis16In = NULL;
        }

        thkDebugOut((DEB_ARGS, "%sIn3216  %s %p -> %p\n",
                     NestingLevelString(), IidIdxString(iidx), 
                     punkIn, vpvThis16In));
    }

    // Check if interface needs to be thunked OUT
    if((thop & THOP_OUT) && pv) {
        // Preallocate a proxy for the out parameter
        ptoPreAlloc = pti->pThkMgr->CanGetNewProxy3216(iidx);
        if(ptoPreAlloc) {
            // Allocate space for OUT parameter from the 16-bit heap
            vpvOutParam = STACKALLOC16(sizeof(VPVOID));
            if(vpvOutParam)  {
                // Assert that no interface is being thunked IN for
                // pure OUT parameter case
                thkAssert((thop & THOP_IN) || !vpvThis16In);

                // Assign the interface being thunked IN 
                *FIXVDMPTR(vpvOutParam, VPVOID) = vpvThis16In;
                RELVDMPTR(vpvOutParam);

                // Push the OUT/IN-OUT parameter onto the stack
                TO_STACK16(pti, vpvOutParam, VPVOID);
            }
            else {
                thkDebugOut((DEB_WARN, "WARNING: failing - Allocation on 16-bit heap failed\n"));
                dwResult = (DWORD)E_OUTOFMEMORY;
            }
        }
        else {
            thkDebugOut((DEB_WARN, "WARNING: failing - Cannot allocate proxy\n"));
            dwResult = (DWORD) E_OUTOFMEMORY;
        }
    }
    else {
        // Assert invariant
        thkAssert((pv && vpvThis16In) || (!pv && !vpvThis16In));

        // Push the IN parameter onto the stack
        TO_STACK16(pti, vpvThis16In, VPVOID);
    }

    if(SUCCEEDED((SCODE)dwResult)) {
        // Execute the next THOP operation
        dwResult = EXECUTE_THOP3216(pti);
    }

    if((thop & THOP_OUT) && pv) {
        punkOut = NULL;

        if(SUCCEEDED((SCODE)dwResult)) {
            // Obtain the 16-bit interface to be thunked OUT
            vpvThis16Out = *FIXVDMPTR(vpvOutParam, VPVOID);
            RELVDMPTR(vpvOutParam);

            // Check if a 16-bit interface was returned
            if(vpvThis16Out) {
                // Obtain 32-bit proxy for the 16-bit interface
                if(vpvOuter) {
                    //Get the holder that was linked into TLS when the pUnkOuter
                    //was being thunked in.
                    pAggHolder = (TlsThkGetAggHolder())->pph;
                    punkOut = pti->pThkMgr->FindAggregate3216(ptoPreAlloc, vpvOuter, 
                                                           vpvThis16Out, iidx, pAggHolder, 
                                                           &dwStatus);
                }
                else {
                    punkOut = pti->pThkMgr->FindProxy3216(ptoPreAlloc, vpvThis16Out, 
                                                       NULL, iidx, FALSE, &dwStatus);
                }
                
                if(punkOut) {
                    if((thop & THOP_OPMASK) == THOP_UNKINNER) {
                        if (dwStatus != FST_SHORTCUT) {
                            // Obtain the holder
                            pph = ((THUNK3216OBJ *)punkOut)->pphHolder ;

                            // Assert invariants in debug builds
                            thkAssert(pph->dwFlags & PH_AGGREGATEE);
                            thkAssert(dwStatus == FST_CREATED_NEW);

                            // Mark the proxy as representing inner unknown
                            ((THUNK3216OBJ *)punkOut)->grfFlags = PROXYFLAG_PUNKINNER;
                        }
                    }

                    // Either the preallocated proxy was used and freed
                    ptoPreAlloc = NULL;
                }
                else {
                    dwResult = (DWORD)E_OUTOFMEMORY;
                }

                // Release the actual 16-bit interface. If a proxy to the 
                // 16-bit interface could not be created above, this could 
                // be the last release on the 16-bit interface
                ReleaseOnObj16(vpvThis16Out);
            }
        }

        // Set the OUT parameter
        *(void **)pv = (void *)punkOut;

        thkDebugOut((DEB_ARGS, "%sOut3216 %s %p -> %p\n",
                     NestingLevelString(), IidIdxString(iidx),
                     vpvThis16Out, punkOut));
    }

    if(vpvThis16In) {
        if((thop & THOP_INOUT) == THOP_INOUT) {
            // IN-OUT parameter.
            thkAssert(punkIn);

            // Release the 32-bit side interface
            punkIn->Release();
        }
        else {
            // Just an IN parameter
            thkAssert(thop & THOP_IN);

#if DBG==1
            // Ensure that the following is not the last release
            // on the IN parameter
            THKSTATE thkstate;

            // Remember the current thunk state
            thkstate = pti->pThkMgr->GetThkState();

            // Set the thunk state to THKSTATE_VERIFYINPARAM
            pti->pThkMgr->SetThkState(THKSTATE_VERIFY32INPARAM);
#endif
            // Release the 16-bit side interface
            ReleaseOnObj16(vpvThis16In);
#if DBG==1
            // Restore previous thunk state
            pti->pThkMgr->SetThkState(thkstate);
#endif
        }

        // We should never receive a call IRpcStubBuffer::DebugServerRelease
        Win4Assert((thop & THOP_OPMASK) != THOP_IFACECLEAN);
    }
    
    // Cleanup
    if(ptoPreAlloc) {
        // Free preallocated proxy as it was not used
        pti->pThkMgr->FreeNewProxy3216(ptoPreAlloc, iidx);
    }
    if(vpvOutParam) {
        // Free the space created on the 16-bit for the OUT parameter
        STACKFREE16(vpvOutParam, sizeof(VPVOID));
    }

    if (bUnlinkAggHolder) {
        TlsThkUnlinkAggHolder();
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACEGEN_3216, public
//
//  Synopsis:   Thunks riid,ppv pairs from 16->32
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACEGEN_3216(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    VPVOID vpvOuter;
    IID const *piid;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(thopOp == THOP_IFACEGEN ||
              thopOp == THOP_IFACEGENOWNER);

    // The current thop byte indicates how many bytes to look
    // back in the stack to find the IID which identifies the
    // interface being returned
    INDEX_STACK32(pti, piid, IID const *, *pti->pThop);

#if DBG == 1
    if (!IsValidIid(*piid))
    {
        return (DWORD)E_INVALIDARG;
    }
#endif

    pti->pThop++;

    iidx = IidToIidIdx(*piid);
    vpvOuter = 0;
    if (thopOp == THOP_IFACEGENOWNER)
    {
        // Obtain the outer unknown that is being passed to the 16 bit world
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK16(pti, vpvOuter, VPVOID, thopWeakOffset, sizeof(DWORD));
        if(vpvOuter) {
            // Aggregation across 32-16 boundary
            // Assert that the IID requested is IID_IUnknown
            thkAssert(iidx == THI_IUnknown ||
                      (pti->iidx==THI_IPSFactoryBuffer && pti->dwMethod==3));
            // Change thop to indicate that inner unknown is being thunked
            if(iidx == THI_IUnknown)
                thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface3216(pti, iidx, thop, vpvOuter);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_OIFI_3216, public
//
//  Synopsis:   Convert OLEINPLACEFRAMEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    26-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_OIFI_3216( THUNKINFO *pti )
{
    DWORD dwResult;
    VPVOID vpoifi16;
    OIFI16 UNALIGNED *poifi16;
    OLEINPLACEFRAMEINFO *poifi32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_OIFI);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_OUT);

    // OIFIs are out-only parameters for their contents
    // However, cb is in/out, so we need to copy cb on the way in
    // Furthermore, cb may not be set to a valid value, in which
    // case the documentation mentions that it should be assumed
    // that this is an OLE 2.0 OIFI
    // This thop simply ignores cb on the way in and always sets
    // it to the OLE 2.0 size
    // Since we're out-only, this always works since the number of
    // fields we thunk is the size of the structure that we give out
    // If OLEINPLACEFRAMEINFO is extended, this thop will break

    // Assert that OLEINPLACEFRAMEINFO is what we expect it to be
    thkAssert(sizeof(OLEINPLACEFRAMEINFO) == 20);

    GET_STACK32(pti, poifi32, OLEINPLACEFRAMEINFO *);

    vpoifi16 = 0;
    if (poifi32 != NULL)
    {
        if (IsBadWritePtr(poifi32, sizeof(OLEINPLACEFRAMEINFO)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpoifi16 = STACKALLOC16(sizeof(OIFI16));
        if (vpoifi16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        // OIFI's may be an out only parameters but if the "cb" field is
        // "in" RPC doesn't slice up structs, so the whole thing is "in"
        // as well.  We are Thoping here but if we want this to match
        // the RPC sematics then we need to copy all the fields.

        poifi16 = FIXVDMPTR(vpoifi16, OIFI16);

        poifi16->cb            = sizeof(OIFI16);
        poifi16->fMDIApp       = (WORD)poifi32->fMDIApp;
        poifi16->hwndFrame     = HWND_16(poifi32->hwndFrame);
        poifi16->cAccelEntries =
            ClampULongToUShort(poifi32->cAccelEntries);

        if (poifi32->haccel == NULL)
        {
            poifi16->haccel = NULL;
        }
        else
        {
            // WOW will clean up any dangling accelerator tables when
            // tasks die
            poifi16->haccel = HACCEL_16(poifi32->haccel);
            if (poifi16->haccel == NULL)
            {
                dwResult = (DWORD)E_UNEXPECTED;
            }
        }

        RELVDMPTR(vpoifi16);
    }

    TO_STACK16(pti, vpoifi16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (vpoifi16 != NULL)
    {
        poifi16 = FIXVDMPTR(vpoifi16, OIFI16);

        if (SUCCEEDED(dwResult))
        {
            poifi32->cb            = sizeof(OLEINPLACEFRAMEINFO);
            poifi32->fMDIApp       = (BOOL)poifi16->fMDIApp;
            poifi32->hwndFrame     = HWND_32(poifi16->hwndFrame);
            poifi32->cAccelEntries = (UINT)poifi16->cAccelEntries;

            if (poifi16->haccel == NULL)
            {
                poifi32->haccel = NULL;
            }
            else
            {
                // WOW will clean up any dangling accelerator tables when
                // tasks die

                // Check that the haccel is valid.   We don't need to lock
                // the pointer.  We just want some means of validating it.
                // HACCEL_32 faults in krnl386 if the handle is bad.

                if(NULL != WOWGlobalLock16(poifi16->haccel))
                {
                    poifi32->haccel = HACCEL_32(poifi16->haccel);
                    WOWGlobalUnlock16(poifi16->haccel);
                }
                else
                {
                    poifi32->haccel = NULL;
                }

                if (poifi32->haccel == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
            }

#if DBG == 1
            if (SUCCEEDED(dwResult))
            {
                thkDebugOut((DEB_ARGS, "Out3216 OIFI: "
                             "%p {%d, %d, 0x%04X, 0x%04X, %d} -> "
                             "%p {%d, %d, 0x%p, 0x%p, %d}\n",
                             vpoifi16, poifi16->cb, (BOOL)poifi16->fMDIApp,
                             (DWORD)poifi16->hwndFrame, (DWORD)poifi16->haccel,
                             poifi16->cAccelEntries,
                             poifi32, poifi32->cb, poifi32->fMDIApp,
                             poifi32->hwndFrame, poifi32->haccel,
                             poifi32->cAccelEntries));
            }
#endif
        }

        RELVDMPTR(vpoifi16);

        if (FAILED(dwResult))
        {
            memset(poifi32, 0, sizeof(OLEINPLACEFRAMEINFO));
        }

        STACKFREE16(vpoifi16, sizeof(OIFI16));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STGMEDIUM_3216, public
//
//  Synopsis:   Converts 32-bit STGMEDIUM to 16-bit STGMEDIUM returned
//              structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_STGMEDIUM_3216(THUNKINFO *pti)
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      vpstgmedium16;
    STGMEDIUM   *lpstgmedium32;
    DWORD       dwSize;
    SCODE       sc;
    BOOL        fReleaseParam;
    BOOL        fTransferOwnership;
    FORMATETC   *pfe;
    THOP        thopFeOffset;
    DWORD       vpIStream = 0;
    STGMEDIUM UNALIGNED *psm16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STGMEDIUM);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We currently don't have any unmodified or inout thops for STGMEDIUMs
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "STGMEDIUM must be input or output only" );

    // +2 thop byte indicates whether there's a FORMATETC to look at
    // or not
    // We need to reference this now before the stack is modified
    // by argument recovery
    thopFeOffset = *(pti->pThop+2);
    if (thopFeOffset > 0)
    {
        INDEX_STACK32(pti, pfe, FORMATETC *, thopFeOffset);
    }
    else
    {
        pfe = NULL;
    }

    GET_STACK32(pti, lpstgmedium32, STGMEDIUM FAR *);

    // Next thop byte indicates whether there's an ownership transfer
    // argument or not
    pti->pThop++;
    fReleaseParam = (BOOL)*pti->pThop++;

    if (fReleaseParam)
    {
        GET_STACK32(pti, fTransferOwnership, BOOL);
    }
    else
    {
        fTransferOwnership = FALSE;
    }

    // Skip FORMATETC offset thop
    pti->pThop++;

    vpstgmedium16 = 0;

    if ( lpstgmedium32 != NULL )
    {
        if ((fThopInput && IsBadReadPtr(lpstgmedium32, sizeof(STGMEDIUM))) ||
            (fThopOutput && IsBadWritePtr(lpstgmedium32, sizeof(STGMEDIUM))))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpstgmedium16 = STACKALLOC16(sizeof(STGMEDIUM));
        if (vpstgmedium16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if ( fThopInput )
        {
            sc = ConvertStgMed3216(pti, lpstgmedium32, vpstgmedium16,
                                   pfe, fTransferOwnership, &dwSize);
            if (SUCCEEDED(sc))
            {
                // Apparently if you pass TYMED_NULL into GetDataHere
                // it's supposed to work like GetData, so switch input-only
                // TYMED_NULLs to output
                if (lpstgmedium32->tymed == TYMED_NULL &&
                    !fTransferOwnership)
                {
                    fThopInput = FALSE;
                    fThopOutput = TRUE;
                }
                else if (lpstgmedium32->tymed == TYMED_ISTREAM)
                {
                    //
                    // Excel has a bug in its Clipboard data object that when
                    // GetDataHere is done providing a IStream interface, it
                    // will create its own stream and pounce on the pointer
                    // being passed in. So, if the thing is input, and the
                    // TYMED is ISTREAM we need to stash away the original
                    // 16-bit stream pointer for use later.
                    //
                    psm16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                    vpIStream = (DWORD)psm16->pstm;
                    RELVDMPTR(vpstgmedium16);
                }
            }
            else
            {
                STACKFREE16(vpstgmedium16, sizeof(STGMEDIUM));
                return (DWORD)sc;
            }

        }
        else
        {
            if( !((TlsThkGetAppCompatFlags() & OACF_CORELTRASHMEM) &&
                lpstgmedium32->tymed == 0x66666666 ))
            {

                // Even though this is an out parameter, some apps
                // (Graph 5 is one) check its values and depend on it
                // being zeroed out

                // However, if we are in CorelDraw *and* we're being
                // called by wGetMonikerAndClassFromObject (tymed set to
                // all 6's), then we do not want to set the tymed to zero.
                // Corel5 relies on the memory being trashed in order to
                // prevent paste-link-to-yourself.

                memset(FIXVDMPTR(vpstgmedium16, STGMEDIUM), 0,
                    sizeof(STGMEDIUM));
                RELVDMPTR(vpstgmedium16);
            }

        }
    }

    TO_STACK16(pti, vpstgmedium16, VPVOID);

    if (fReleaseParam)
    {
        TO_STACK16(pti, (SHORT)fTransferOwnership, SHORT);
    }

    dwResult = EXECUTE_THOP3216(pti);

    if (lpstgmedium32 != NULL)
    {
        if (fThopInput)
        {

            if (SUCCEEDED(dwResult) &&
                (lpstgmedium32->tymed == TYMED_ISTREAM) &&
                (vpIStream != 0))
            {
                //
                // To continue our Excel Clipboard GetDataHere hack, if the
                // TYMED was ISTREAM, and the medium was input (as it is now)
                // then we need to detect the case where the IStream pointer
                // changed. If it did change, then we have a special function
                // in the 16-bit world that will copy the contents of the
                // 'new' stream into 'our' stream, and release the 'new'
                // stream. This should make the clipboard work properly.
                //
                psm16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                if( (psm16->tymed == TYMED_ISTREAM) &&
                    (vpIStream != (DWORD)psm16->pstm))
                {
                    BYTE b32Args[WCB16_MAX_CBARGS];
                    *(DWORD *)&b32Args[0] = vpIStream;
                    *(DWORD *)&b32Args[sizeof(DWORD)] = (DWORD)psm16->pstm;

                    RELVDMPTR(vpstgmedium16);

                    if( !CallbackTo16Ex(
                            (DWORD)gdata16Data.fnStgMediumStreamHandler16,
                            WCB16_PASCAL,
                            2*sizeof(DWORD),
                            b32Args,
                            &dwResult) )
                    {
                        dwResult = (DWORD)E_UNEXPECTED;
                    }

                }
                else
                {
                    //
                    // Two possibilites
                    // The stream pointers are the same. Good news
                    // The tymed was changed. Bad news. There isn't anything
                    // we can safely do with the different tymed, so ignore
                    // the whole thing.
                    //

                    RELVDMPTR(vpstgmedium16);
                }
            }


            if (!fTransferOwnership || FAILED(dwResult))
            {
                sc = CleanStgMed16(pti, vpstgmedium16, lpstgmedium32,
                                   dwSize, TRUE, pfe);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                }
            }
            else if (SUCCEEDED(dwResult))
            {

                if (lpstgmedium32->pUnkForRelease == NULL)
                {
                    sc = CleanStgMed32(pti, lpstgmedium32, vpstgmedium16,
                                       0, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
            }
        }
        else
        {
            thkAssert(fThopOutput);

            if (SUCCEEDED(dwResult))
            {
                sc = ConvertStgMed1632(pti, vpstgmedium16, lpstgmedium32,
                                       pfe, FALSE, &dwSize);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                    CallbackTo16(gdata16Data.fnReleaseStgMedium16,
                                  vpstgmedium16);
                }
                else if (lpstgmedium32->pUnkForRelease == NULL)
                {
                    sc = CleanStgMed16(pti, vpstgmedium16, lpstgmedium32,
                                       dwSize, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
            }

            if (FAILED(dwResult))
            {
                memset(lpstgmedium32, 0, sizeof(STGMEDIUM));
            }
        }
    }

    if (vpstgmedium16 != 0)
    {
        STACKFREE16(vpstgmedium16, sizeof(STGMEDIUM));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStatStg1632, public
//
//  Synopsis:   Converts a STATSTG
//
//  Arguments:  [pti] - Thunk info
//              [vpss16] - STATSTG
//              [pss32] - STATSTG
//              [posPreAlloc] - Preallocated string memory or NULL
//              [cchPreAlloc] - Amount preallocated
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pss32]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Assumes input STATSTG memory is valid
//              Assumes task memory for the string
//
//----------------------------------------------------------------------------

SCODE ConvertStatStg1632(THUNKINFO *pti,
                         VPVOID vpss16,
                         STATSTG *pss32,
                         LPOLESTR posPreAlloc,
                         UINT cchPreAlloc)
{
    STATSTG UNALIGNED *pss16;
    SCODE sc;
    LPOLESTR pos32;
    VPSTR vpstr;

    pss16 = FIXVDMPTR(vpss16, STATSTG);
    vpstr = (VPSTR)pss16->pwcsName;
    RELVDMPTR(vpss16);

    sc = ConvertTaskString1632(pti, vpstr,
                               posPreAlloc, cchPreAlloc,
                               &pos32);

    if (SUCCEEDED(sc))
    {
        pss16 = FIXVDMPTR(vpss16, STATSTG);
        memcpy(pss32, pss16, sizeof(STATSTG));
        pss32->pwcsName = pos32;
        RELVDMPTR(vpss16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STATSTG_3216, public
//
//  Synopsis:   Converts 32-bit STATSTG to 16-bit STATSTG returned structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_STATSTG_3216( THUNKINFO *pti )
{
    DWORD       dwResult;
    STATSTG     *lpstatstg32;
    VPVOID      vpstatstg16;
    LPOLESTR    lpstr32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STATSTG);

    //
    // We currently don't have any input thops for STATSTGs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_OUT &&
               "STATSTG must be output only" );

    GET_STACK32(pti, lpstatstg32, STATSTG FAR *);

    if (IsBadWritePtr(lpstatstg32, sizeof(STATSTG)))
    {
        return (DWORD)E_INVALIDARG;
    }

    vpstatstg16 = STACKALLOC16(sizeof(STATSTG));
    if (vpstatstg16 == 0)
    {
        return (DWORD)E_OUTOFMEMORY;
    }

    lpstr32 = (LPOLESTR)TaskMalloc32(CBSTRINGPREALLOC);
    if (lpstr32 == NULL)
    {
        STACKFREE16(vpstatstg16, sizeof(STATSTG));
        return (DWORD)E_OUTOFMEMORY;
    }

    TO_STACK16(pti, vpstatstg16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (SUCCEEDED(dwResult))
    {
        SCODE sc;

        sc = ConvertStatStg1632(pti, vpstatstg16, lpstatstg32,
                                lpstr32, CWCSTRINGPREALLOC);
        if (FAILED(sc))
        {
            dwResult = sc;
        }
    }

    if (FAILED(dwResult))
    {
        TaskFree32(lpstr32);

        memset(lpstatstg32, 0, sizeof(STATSTG));
    }

    STACKFREE16(vpstatstg16, sizeof(STATSTG));

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_DVTARGETDEVICE_3216, public
//
//  Synopsis:   Converts 16-bit DVTARGETDEVICE to 32-bit DVTARGETDEVICE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_DVTARGETDEVICE_3216( THUNKINFO *pti )
{
    DWORD               dwResult;
    UINT                uiSize;
    DVTARGETDEVICE FAR  *lpdv32;
    VPVOID              vpdv16;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_DVTARGETDEVICE);

    //
    // We currently don't have any output thops for DVTARGETDEVICEs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "DVTARGETDEVICE must be input only" );

    //
    // Processing for a DVTARGETDEVICE FAR * as input
    //
    GET_STACK32(pti, lpdv32, DVTARGETDEVICE FAR *);

    vpdv16 = 0;

    if ( lpdv32 != NULL )
    {
        sc = ConvertDvtd3216(pti, lpdv32, ArStack16, FrStack16, &vpdv16,
                             &uiSize);
        if (FAILED(sc))
        {
            return (DWORD)sc;
        }
    }

    TO_STACK16(pti, vpdv16, VPVOID);
    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if ( lpdv32 != NULL )
    {
        FrStack16((void *)vpdv16, uiSize);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FORMATETC_3216, public
//
//  Synopsis:   Converts 16-bit FORMATETC to 32-bit FORMATETC and back
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_FORMATETC_3216( THUNKINFO *pti )
{
    DWORD               dwResult;
    BOOL                fThopInput;
    BOOL                fThopOutput;
    VPVOID              vpformatetc16;
    FORMATETC16 UNALIGNED *lpformatetc16;
    LPFORMATETC         lpformatetc32;
    VPVOID              vpdv16;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FORMATETC);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    vpdv16 = 0;

    //
    // We have only input or output thops
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "formatetc must be input or output only" );

    GET_STACK32(pti, lpformatetc32, LPFORMATETC);

    if ( lpformatetc32 == NULL )
    {
        vpformatetc16 = 0;
    }
    else
    {
        if ((fThopInput && IsBadReadPtr(lpformatetc32, sizeof(LPFORMATETC))) ||
            (fThopOutput && IsBadWritePtr(lpformatetc32, sizeof(LPFORMATETC))))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpformatetc16 = STACKALLOC16(sizeof(FORMATETC16));
        if (vpformatetc16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if ( fThopInput )
        {
            sc = ConvertFetc3216(pti, lpformatetc32, vpformatetc16, FALSE);
            if (FAILED(sc))
            {
                STACKFREE16(vpformatetc16, sizeof(FORMATETC16));
                return (DWORD)sc;
            }
        }
        else
        {
            thkAssert( fThopOutput );

            //
            // The below memset is needed at least for the DATA_S_SAMEFORMATETC
            // case.  This allows it to be cleaned up because all its pointers
            // will be null.
            //
            lpformatetc16 = FIXVDMPTR(vpformatetc16, FORMATETC16);
            memset(lpformatetc16, 0, sizeof(FORMATETC16) );
            RELVDMPTR(vpformatetc16);
        }
    }

    TO_STACK16(pti, vpformatetc16, VPVOID);
    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (fThopInput && vpformatetc16 != 0)
    {
        VPVOID vptd;

        lpformatetc16 = FIXVDMPTR(vpformatetc16, FORMATETC16);
        vptd = (VPVOID)lpformatetc16->ptd;
        RELVDMPTR(vpformatetc16);

        if (vptd != 0)
        {
            TaskFree16(vptd);
        }
    }

    if ( fThopOutput && lpformatetc32 != NULL)
    {
        if (SUCCEEDED(dwResult))
        {
            sc = ConvertFetc1632(pti, vpformatetc16, lpformatetc32, TRUE);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            memset(lpformatetc32, 0, sizeof(FORMATETC));
        }
    }

    if (vpformatetc16 != 0)
    {
        STACKFREE16(vpformatetc16, sizeof(FORMATETC16));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LOGPALETTE_3216, public
//
//  Synopsis:   Converts 16-bit LOGPALLETE to 32-bit LOGPALETTE
//              and converts 32-bit LOGPALETTE returned to 16-bit structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LOGPALETTE_3216 ( THUNKINFO *pti )
{
    DWORD             dwResult;
    UINT              uiSize;
    LPLOGPALETTE      lplogpal32;
    VPVOID            vplogpal16;
    LOGPALETTE UNALIGNED *lplogpal16;
    LPLOGPALETTE      *lplplogpal32;
    VPVOID            vpvplogpal16;
    VPVOID UNALIGNED *lpvplogpal16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LOGPALETTE);

    //
    // It must be either an input or output LOGPALETTE
    //
    thkAssert( ((*pti->pThop & THOP_IOMASK) == THOP_IN ||
                (*pti->pThop & THOP_IOMASK) == THOP_OUT) &&
               "Hey, LOGPALETTE can't be input and output!" );

    if ( (*pti->pThop & THOP_IN) != 0 )
    {
        //
        // Processing for a LPLOGPALETTE as input
        //
        GET_STACK32(pti, lplogpal32, LPLOGPALETTE);

        if ( lplogpal32 == NULL )
        {
            vplogpal16 = 0;
        }
        else
        {
            if (IsBadReadPtr(lplogpal32, sizeof(LOGPALETTE)))
            {
                return (DWORD)E_INVALIDARG;
            }

            uiSize = CBPALETTE(lplogpal32->palNumEntries);

            if (IsBadReadPtr(lplogpal32, uiSize))
            {
                return (DWORD)E_INVALIDARG;
            }

            vplogpal16 = STACKALLOC16(uiSize);
            if (vplogpal16 == 0)
            {
                return (DWORD)E_OUTOFMEMORY;
            }

            lplogpal16 = (LOGPALETTE UNALIGNED *)
                WOWFIXVDMPTR( vplogpal16, uiSize );

            memcpy( lplogpal16, lplogpal32, uiSize );

            WOWRELVDMPTR(vplogpal16);
        }

        TO_STACK16(pti, vplogpal16, VPVOID);
        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);

        if ( vplogpal16 != 0 )
        {
            STACKFREE16(vplogpal16, uiSize);
        }
    }
    else
    {
        //
        // Processing for LPLPLOGPALETTE as output
        //
        thkAssert((*pti->pThop & THOP_OUT) != 0);

        GET_STACK32(pti, lplplogpal32, LPLOGPALETTE FAR *);
        if (IsBadWritePtr(lplplogpal32, sizeof(LPLOGPALETTE)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpvplogpal16 = (VPVOID)STACKALLOC16(sizeof(LPLOGPALETTE));
        if (vpvplogpal16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        lplogpal32 = (LPLOGPALETTE)TaskMalloc32(CBPALETTE(NPALETTEPREALLOC));
        if (lplogpal32 == NULL)
        {
            STACKFREE16(vpvplogpal16, sizeof(LPLOGPALETTE));
            return (DWORD)E_OUTOFMEMORY;
        }

        //
        // We DO need to zero out the pointer on the way in.
        //
        *FIXVDMPTR(vpvplogpal16, LPLOGPALETTE) = 0;
        RELVDMPTR(vpvplogpal16);

        TO_STACK16(pti, vpvplogpal16, VPVOID);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);

        if (SUCCEEDED(dwResult))
        {
            lpvplogpal16 = FIXVDMPTR( vpvplogpal16, VPVOID);
            vplogpal16 = *lpvplogpal16;
            RELVDMPTR(vpvplogpal16);

            if ( vplogpal16 == 0 )
            {
                TaskFree32(lplogpal32);
                lplogpal32 = NULL;
            }
            else
            {
                lplogpal16 = FIXVDMPTR( vplogpal16, LOGPALETTE );

                //
                // Copy the returned LOGPALETTE into 16-bit memory
                //
                uiSize = CBPALETTE(lplogpal16->palNumEntries);
                if (uiSize > CBPALETTE(NPALETTEPREALLOC))
                {
                    TaskFree32(lplogpal32);

                    lplogpal32 = (LPLOGPALETTE)TaskMalloc32(uiSize);
                    if ( lplogpal32 == NULL )
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                }

                if (lplogpal32 != NULL)
                {
                    memcpy( lplogpal32, lplogpal16, uiSize );
                }

                RELVDMPTR(vplogpal16);

                TaskFree16( vplogpal16 );
            }
        }
        else
        {
            TaskFree32(lplogpal32);
            lplogpal32 = NULL;
        }

        //
        // Update the value pointed to by the parameter on the 16-bit stack
        //
        *lplplogpal32 = lplogpal32;

        if (vpvplogpal16 != 0)
        {
            STACKFREE16(vpvplogpal16, sizeof(LPLOGPALETTE));
        }
    }
    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CRGIID_3216, public
//
//  Synopsis:   Converts 32-bit CRGIID to 16-bit CRGIID structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_CRGIID_3216( THUNKINFO *pti )
{
    DWORD       dwResult;
    DWORD       dwCount;
    VPVOID      vpiid16;
    IID UNALIGNED *lpiid16;
    IID         *lpiid32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CRGIID);

    //
    // We currently don't have any output thops for CRGIIDs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "CRGIID must be unmodified only" );

    GET_STACK32(pti, dwCount, DWORD);
    GET_STACK32(pti, lpiid32, IID FAR *);

    if ( lpiid32 == NULL )
    {
        vpiid16 = 0;
    }
    else
    {
        if (IsBadReadPtr(lpiid32, dwCount*sizeof(IID)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpiid16 = STACKALLOC16( dwCount * sizeof(IID) );
        if (vpiid16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        lpiid16 = (IID UNALIGNED *)
            WOWFIXVDMPTR( vpiid16, dwCount*sizeof(IID) );

        memcpy( lpiid16, lpiid32, dwCount*sizeof(IID) );

        WOWRELVDMPTR(vpiid16);
    }

    TO_STACK16(pti, dwCount, DWORD);
    TO_STACK16(pti, vpiid16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if ( vpiid16 != 0 )
    {
        STACKFREE16( vpiid16, dwCount * sizeof(IID) );
    }
    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_INTERFACEINFO_3216, public
//
//  Synopsis:   Converts an INTERFACEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    19-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_INTERFACEINFO_3216(THUNKINFO *pti)
{
    INTERFACEINFO *pii32;
    INTERFACEINFO16 UNALIGNED *pii16;
    VPVOID vpii16;
    DWORD dwResult;
    VPVOID vpunk16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_INTERFACEINFO);
    thkAssert((*pti->pThop & THOP_INOUT) == THOP_IN);

    vpunk16 = 0;

    GET_STACK32(pti, pii32, INTERFACEINFO *);
    if (pii32 == NULL)
    {
        vpii16 = 0;
    }
    else
    {
        if (IsBadReadPtr(pii32, sizeof(INTERFACEINFO)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpii16 = STACKALLOC16(sizeof(INTERFACEINFO16));
        if (vpii16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if (pii32->pUnk != NULL)
        {
            vpunk16 = pti->pThkMgr->FindProxy1632(NULL, pii32->pUnk, NULL,
                                                  INDEX_IIDIDX(THI_IUnknown),
                                                  NULL);
            if (vpunk16 == 0)
            {
                STACKFREE16(vpii16, sizeof(INTERFACEINFO16));
                return (DWORD)E_OUTOFMEMORY;
            }
        }

        pii16 = FIXVDMPTR(vpii16, INTERFACEINFO16);
        pii16->pUnk = vpunk16;
        pii16->iid = pii32->iid;
        pii16->wMethod = pii32->wMethod;

        thkDebugOut((DEB_ARGS,
                     "In3216  INTERFACEINFO: %p -> %p {%p (%p), %s, %u}\n",
                     pii32, vpii16, pii16->pUnk, pii32->pUnk,
                     IidOrInterfaceString(&pii16->iid), pii16->wMethod));

        RELVDMPTR(vpii16);
    }

    TO_STACK16(pti, vpii16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (vpunk16 != 0)
    {
        // Release the 16-bit interface as it is an IN parameter
        ReleaseOnObj16(vpunk16);
    }

    if (vpii16 != 0)
    {
        STACKFREE16(vpii16, sizeof(INTERFACEINFO16));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RETURNTYPE_3216, public
//
//  Synopsis:   Thunks the return value of a call
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//  Notes:      This thunk assumes that the return value will always fit
//              in 32 bits and that the thops for it are only one thop
//              long.  This fits the existing APIs and methods
//
//----------------------------------------------------------------------------

DWORD Thop_RETURNTYPE_3216(THUNKINFO *pti)
{
    THOP thops[2];
    DWORD dwResult;
    THUNK3216OBJ *ptoPreAlloc = NULL;
    IIDIDX iidx;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RETURNTYPE);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->fResultThunked = TRUE;

    pti->pThop++;

    // Remember return type thop
    thops[0] = *pti->pThop++;
    if ((thops[0] & THOP_OPMASK) == THOP_COPY ||
        (thops[0] & THOP_OPMASK) == THOP_IFACE ||
        (thops[0] & THOP_OPMASK) == THOP_ALIAS32)
    {
        thops[1] = *pti->pThop++;
    }

    // Preallocate any necessary resources
    switch(thops[0])
    {
    case THOP_IFACE | THOP_IN:
        iidx = INDEX_IIDIDX(thops[1]);
        if ((ptoPreAlloc = pti->pThkMgr->CanGetNewProxy3216(iidx)) == NULL)
        {
            return (DWORD)E_OUTOFMEMORY;
        }
        break;
    }

    dwResult = EXECUTE_THOP3216(pti);

    // Now that we have the return value thunk it from 16->32

    switch(thops[0])
    {
    case THOP_COPY:
        // Only handle DWORD copies
        thkAssert(thops[1] == sizeof(DWORD));
        break;

    case THOP_SHORTLONG:
        // For boolean results, not necessary to clamp
        dwResult = (DWORD)(LONG)*(SHORT *)&dwResult;
        break;

    case THOP_IFACE | THOP_IN:
        // Thunking an interface as a return value is completly broken
        // First, such an interface needs to be thunked as an OUT parameter
        // which I am fixing below. Second, the IID of the interface being
        // thunked needs to be in the THOP string for proper thunking of
        // interface. The only known case where an interface is returned
        // is IRpcStubBuffer::IsIIDSupported() and the interface returned
        // is of type IRpcStubBuffer, not IUnknown. As this method is not
        // used in the curremt COM code, I am not changing THOP strings
        // to reflect the IID of the interface being thunked
        //            Gopalk     Mar 27, 97
        if (dwResult != 0)
        {
            // BUGBUG - What if another thop failed and returned an HRESULT?
            // This will break
            VPVOID vpvUnk = (VPVOID) dwResult;
            dwResult =
                (DWORD)pti->pThkMgr->FindProxy3216(ptoPreAlloc, dwResult, NULL,
                                                   iidx, FALSE, NULL);
            
            // Release actual interface as it is an OUT parameter
            // This could be the last release on the interface if the
            // above call failed;
            ReleaseOnObj16(vpvUnk);
            thkAssert(dwResult);

            thkDebugOut((DEB_ARGS, "Ret3216 %s %p\n",
                         inInterfaceNames[thops[1]].pszInterface,
                         dwResult));
        }
        else
        {
            pti->pThkMgr->FreeNewProxy3216(ptoPreAlloc, iidx);
        }
        break;

    default:
        thkAssert(!"Unhandled 3216 return type");
        break;
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACE_3216, public
//
//  Synopsis:   Thunks a known interface pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACE_3216(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    VPVOID vpvOuter;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(   thopOp == THOP_IFACE
              || thopOp == THOP_IFACEOWNER
              || thopOp == THOP_IFACECLEAN
              || thopOp == THOP_UNKOUTER);

    iidx = INDEX_IIDIDX(*pti->pThop++);
    // There's a bit of a special case here in that IMalloc is
    // not thunked so it doesn't have a real index but it's used
    // in thop strings so it has a fake index to function as a placeholder
    // The fake index is THI_COUNT so allow that in the assert
    thkAssert(IIDIDX_INDEX(iidx) >= 0 && IIDIDX_INDEX(iidx) <= THI_COUNT);
    thkAssert(thopOp != THOP_UNKOUTER || iidx == THI_IUnknown);

    vpvOuter = 0;
    if (thopOp == THOP_IFACEOWNER)
    {
        // Obtain the outer unknown that is being passed to the 16 bit world
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK16(pti, vpvOuter, VPVOID, thopWeakOffset, sizeof(DWORD));
        if(vpvOuter) {
            // Aggregation across 32-16 boundary
            // Assert invariants
            thkAssert(iidx == THI_IRpcProxyBuffer || iidx == THI_IRpcProxy);
            // Change thop to indicate that inner unknown is being thunked
            thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface3216(pti, iidx, thop, vpvOuter);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ALIAS32_3216, public
//
//  Synopsis:   Handles 16-bit aliases to 32-bit quantities
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    27-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_ALIAS32_3216(THUNKINFO *pti)
{
    ALIAS alias;
    DWORD dwValue;
    THOP thopAction;
    BOOL fTemporary = FALSE;
    DWORD dwResult;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ALIAS32);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->pThop++;

    GET_STACK32(pti, dwValue, DWORD);

    // Second byte indicates how the alias should be handled
    thopAction = *pti->pThop++;

    if (dwValue != 0)
    {
        switch(thopAction)
        {
        case ALIAS_RESOLVE:
            alias = gAliases32.ValueAlias(dwValue);

            // There may be cases where there is no existing alias
            // for a value (for example, remoted SetMenu calls where
            // the HOLEMENU is a temporary RPC object)
            // so create a temporary one
            if (alias == INVALID_ALIAS)
            {
                alias = gAliases32.AddValue(dwValue);
                if (alias == INVALID_ALIAS)
                {
                    return (DWORD)E_OUTOFMEMORY;
                }

                fTemporary = TRUE;
            }
            break;

        default:
            thkAssert(!"Default hit in Thop_ALIAS32_3216");
			alias = 0;
            break;
        }
    }
    else
    {
        alias = 0;
    }

    thkDebugOut((DEB_ARGS, "In3216  ALIAS32: 0x%08lX -> 0x%04X\n",
                 dwValue, alias));

    TO_STACK16(pti, alias, ALIAS);

    dwResult = EXECUTE_THOP3216(pti);

    if (fTemporary)
    {
        gAliases32.RemoveAlias(alias);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RPCOLEMESSAGE_3216, public
//
//  Synopsis:   Converts 32-bit RPCOLEMESSAGE to 16-bit RPCOLEMESSAGE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       JohannP  Created
//
//----------------------------------------------------------------------------
DWORD Thop_RPCOLEMESSAGE_3216( THUNKINFO *pti )
{
    DWORD           dwResult;
    PRPCOLEMESSAGE  prom32;
    VPVOID          vprom16;
    RPCOLEMESSAGE UNALIGNED *prom16;
    VPVOID          vpvBuffer16;
    LPVOID          lp16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RPCOLEMESSAGE);

    //
    // We currently have only IN/OUT RPCOLEMESSAGE
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == (THOP_IN | THOP_OUT) &&
               "RPCOLEMESSAGE must be input/output only" );

    vprom16 = 0;
    vpvBuffer16 = 0;

    //
    // Processing for a RPCOLEMESSAGE FAR * as input/output
    //
    GET_STACK32(pti, prom32, RPCOLEMESSAGE *);
    if ( prom32 != 0 )
    {
        // Copy over the input RPCOLEMESSAGE structure

        vprom16 = STACKALLOC16(sizeof(RPCOLEMESSAGE));
        if (vprom16 == NULL)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        prom16 = FIXVDMPTR(vprom16, RPCOLEMESSAGE);
        *prom16 = *prom32;
        ROM_THUNK_FIELD(prom16) = (void *)prom32;
        RELVDMPTR(vprom16);

        // If there's a buffer, copy it
        if (prom32->cbBuffer != 0)
        {
            vpvBuffer16 = TaskMalloc16(prom32->cbBuffer);
            if (vpvBuffer16 == NULL)
            {
                STACKFREE16(vprom16, sizeof(RPCOLEMESSAGE));
                return (DWORD)E_OUTOFMEMORY;
            }

            prom16 = FIXVDMPTR(vprom16, RPCOLEMESSAGE);
            prom16->Buffer = (LPVOID) vpvBuffer16;
            lp16 = (LPVOID)WOWFIXVDMPTR(vpvBuffer16, prom32->cbBuffer);
            memcpy( lp16, prom32->Buffer, prom32->cbBuffer );
            WOWRELVDMPTR(vpvBuffer16);
            RELVDMPTR(vprom16);
        }
    }

    TO_STACK16(pti, vprom16, VPVOID);
    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    prom16 = (PRPCOLEMESSAGE)FIXVDMPTR(vprom16, RPCOLEMESSAGE);
    if (prom16 == NULL)
    {
        dwResult = (DWORD)E_UNEXPECTED;
    }
    else
    {
        VPVOID vpvBuffer;

        vpvBuffer = (VPVOID)prom16->Buffer;
        RELVDMPTR(vprom16);

        if (SUCCEEDED(dwResult))
        {
            if ( prom32->Buffer != NULL )
            {
                lp16 = (LPVOID)WOWFIXVDMPTR(vpvBuffer, prom16->cbBuffer);
                if (lp16 == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
                else
                {
                    memcpy( prom32->Buffer, lp16, prom16->cbBuffer );

                    WOWRELVDMPTR(vpvBuffer);
                }
            }
        }

        if ( vpvBuffer16 != 0 )
        {
            // We'd better have a buffer at this point
            thkAssert( vpvBuffer != 0);

            // Free up the buffer that we've been dealing with
            TaskFree16(vpvBuffer);
        }
    }

    if ( vprom16 != 0 )
    {
        STACKFREE16(vprom16, sizeof(RPCOLEMESSAGE));
    }

    return dwResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   Thop_ENUM_3216, public
//
//  Synopsis:   Thunks Enum::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is the start of a 2-byte thop.  The next thop
//              byte references a function in the enumerator table, rather
//              than the standard thop table.
//
//----------------------------------------------------------------------------

DWORD Thop_ENUM_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ENUM);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    //
    // Get then next thop byte and execute it as a Enum thop
    //
    pti->pThop++;
    return EXECUTE_ENUMTHOP3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallbackProcessing_3216, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
typedef struct tagCallbackControl
{
    DWORD   dwContinue;
    LPVOID  lpfn32;
} CALLBACKCONTROL;


STDAPI_(BOOL) CallbackProcessing_3216( DWORD dwContinue, DWORD dw1, DWORD dw2 )
{
    BOOL            fResult;
    CALLBACKCONTROL *lpcbc;
    BOOL            (*lpfn32)(DWORD);

    lpcbc = (CALLBACKCONTROL *)dwContinue;

    lpfn32 = (BOOL (*)(DWORD))lpcbc->lpfn32;

    fResult = (*lpfn32)(lpcbc->dwContinue);

    if ( fResult )      // This maps DWORD sized BOOLs into WORD sized BOOLs
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CALLBACK_3216, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_CALLBACK_3216(THUNKINFO *pti)
{
    LPVOID              lpfn32;
    DWORD               dwContinue;
    CALLBACKCONTROL     cbc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CALLBACK);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    GET_STACK32(pti, lpfn32, LPVOID);
    GET_STACK32(pti, dwContinue, DWORD);

    if ( lpfn32 == 0 )
    {
        TO_STACK16(pti, NULL, VPVOID);
        TO_STACK16(pti, dwContinue, DWORD);
    }
    else
    {
        cbc.lpfn32     = lpfn32;
        cbc.dwContinue = dwContinue;

        TO_STACK16(pti, gdata16Data.fnCallbackHandler, DWORD);
        TO_STACK16(pti, (DWORD)&cbc, DWORD);
    }

    pti->pThop++;
    return EXECUTE_THOP3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CLSCONTEXT_3216, public
//
//  Synopsis:   Converts a class context flags DWORD
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_CLSCONTEXT_3216(THUNKINFO *pti)
{
    DWORD dwClsContext;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CLSCONTEXT);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    // When passing a 32-bit class context to 16-bits nothing
    // nothing special needs to be done

    GET_STACK32(pti, dwClsContext, DWORD);
    TO_STACK16(pti, dwClsContext, DWORD);

    pti->pThop++;
    return EXECUTE_THOP3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FILENAME_3216, public
//
//  Synopsis:   Converts a filename string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_FILENAME_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FILENAME);

    // Can be in or out only
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN ||
              (*pti->pThop & THOP_IOMASK) == THOP_OUT);

    if ((*pti->pThop & THOP_IN) != 0)
    {
        // Convert filenames going from 32->16 to short filenames
        // to avoid any possible problems with non-8.3 names.

        return ThunkInString3216(pti, TRUE, 0);
    }
    else
    {
        thkAssert((*pti->pThop & THOP_OUT) != 0);

        // No special processing is necessary for filenames going
        // from 16->32 since it isn't possible for 16-bit code to
        // generate a filename which can't be handled in 32-bits

        return ThunkOutString3216(pti);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SIZEDSTRING_3216, public
//
//  Synopsis:   Converts strings which cannot exceed a given length
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    02-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_SIZEDSTRING_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZEDSTRING);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN);

    // Advance once to account for the length byte
    // ThunkInString will advance again
    pti->pThop++;
    return ThunkInString3216(pti, FALSE, *pti->pThop);
}

#define THOP_FN(x)  Thop_ ## x ## _3216

DWORD (* CONST aThopFunctions3216[])(THUNKINFO *) =
{

                                // x = Implemented
                                // ? = Mysteriously not needed
                                //   = Left to do
                                //
                                // ^
                                // |
                                // +===+
                                //     |
                                //     v
                                //
    ThunkCall3216,                  // x Terminating THOP
    Thop_ShortToLong_3216,          // x SHORTLONG
    Thop_WordToDword_3216,          // x WORDDWORD
    Thop_Copy_3216,                 // x COPY
    THOP_FN(LPSTR),                 // x LPSTR
    THOP_FN(LPLPSTR),               // x LPLPSTR
    THOP_FN(BUFFER),                // x BUFFER
    Thop_UserHandle_3216,           // x HUSER
    Thop_GdiHandle_3216,            // x HGDI
    THOP_FN(SIZE),                  // x SIZE
    THOP_FN(RECT),                  // x RECT
    THOP_FN(MSG),                   // x MSG
    THOP_FN(HRESULT),               // x HRESULT
    THOP_FN(STATSTG),               // x STATSTG
    THOP_FN(DVTARGETDEVICE),        // x DVTARGETDEVICE
    THOP_FN(STGMEDIUM),             // x STGMEDIUM
    THOP_FN(FORMATETC),             // x FORMATETC
    THOP_FN(HACCEL),                // x HACCEL
    THOP_FN(OIFI),                  // x OLEINPLACEFRAMEINFO
    THOP_FN(BINDOPTS),              // x BIND_OPTS
    THOP_FN(LOGPALETTE),            // x LOGPALETTE
    THOP_FN(SNB),                   // x SNB
    THOP_FN(CRGIID),                // x CRGIID
    Thop_ERROR_3216,                // x OLESTREAM  (only 16-bit)
    THOP_FN(HTASK),                 // x HTASK
    THOP_FN(INTERFACEINFO),         // x INTERFACEINFO
    THOP_FN(IFACE),                 // x IFACE
    THOP_FN(IFACE),                 // x IFACEOWNER
    THOP_FN(IFACE),                 // x IFACENOADDREF
    THOP_FN(IFACE),                 // x IFACECLEAN
    THOP_FN(IFACEGEN),              // x IFACEGEN
    THOP_FN(IFACEGEN),              // x IFACEGENOWNER
    THOP_FN(IFACE),                 // x UNKOUTER
    Thop_ERROR_3216,                // x UNKINNER
    Thop_ERROR_3216,                // x ROUTINE_INDEX
    THOP_FN(RETURNTYPE),            // x RETURN_TYPE
    THOP_FN(NULL),                  // x NULL
    Thop_ERROR_3216,                // x ERROR
    THOP_FN(ENUM),                  // x ENUM
    THOP_FN(CALLBACK),              // x CALLBACK
    THOP_FN(RPCOLEMESSAGE),         // x RPCOLEMESSAGE
    THOP_FN(ALIAS32),               // x ALIAS32
    THOP_FN(CLSCONTEXT),            // x CLSCONTEXT
    THOP_FN(FILENAME),              // x FILENAME
    THOP_FN(SIZEDSTRING),           // x SIZEDSTRING
};

//+---------------------------------------------------------------------------
//
//  Function:   General_Enum_3216, private
//
//  Synopsis:   Thunking for standard OLE enumerator interface ::Next member
//              function.
//
//  Arguments:  [pti] - Thunk state information
//              [uiSize32] - 32-bit information size
//              [uiSize16] - 16-bit information size
//              [pfnCallback] - Data thunking callback
//              [pfnCleanup] - Thunking cleanup
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This handler is called from many IXXXEnum::Next handlers thop
//              thunks to do the standard sorts of "buffer of structures"
//              processing.
//
//----------------------------------------------------------------------------
#define MAX_ALLOCA_STRUCT   5       // 16-bit stacks are precious

DWORD General_Enum_3216(
    THUNKINFO   *pti,
    UINT        uiSize32,
    UINT        uiSize16,
    SCODE       (*pfnCallback)( THUNKINFO *, LPVOID, VPVOID),
    void        (*pfnCleanup)( THUNKINFO *, LPVOID, VPVOID)   )
{
    DWORD       dwResult;
    ULONG       ulCount;
    VPVOID      vpstruct16;
    VPVOID      vpfetched16;
    LPVOID      lpstruct32;
    LPVOID      lpstruct32Iterate;
    VPVOID      vpstruct16Iterate;
    ULONG       *lpfetched32;
    ULONG UNALIGNED *lpfetched16;
    ULONG       ulFetched16 = 0;
    ULONG       ulIterate;
    BOOL        fError;
    SCODE       sc;
    LPVOID      pvArg32;

    dwResult = (DWORD)S_OK;

    GET_STACK32(pti, ulCount, ULONG );
    GET_STACK32(pti, lpstruct32, LPVOID );
    GET_STACK32(pti, lpfetched32, ULONG FAR *);

    vpfetched16 = STACKALLOC16(sizeof(ULONG));
    if (vpfetched16 == 0)
    {
        dwResult = (DWORD)E_OUTOFMEMORY;
    }
    else
    {
        // Zero this out so that we don't have a random value sitting
        // underneath
        // when bad apps like 16-bit MsWorks don't return the number of items
        // in the returned enumeration.

        lpfetched16  = FIXVDMPTR(vpfetched16, ULONG);
        *lpfetched16 = 0;
        RELVDMPTR(vpfetched16);
    }

    pvArg32 = NULL;
    vpstruct16 = 0;

    if ( lpstruct32 != NULL )
    {
        if ( ulCount == 0 )
        {
            dwResult = (DWORD)E_INVALIDARG;
        }
        else
        {
            if (IsBadWritePtr(lpstruct32, ulCount*uiSize32))
            {
                dwResult = (DWORD)E_INVALIDARG;
            }
            else
            {
                pvArg32 = lpstruct32;

                if ( ulCount > MAX_ALLOCA_STRUCT )
                {
                    vpstruct16 = WgtAllocLock( GMEM_MOVEABLE,
                                               ulCount * uiSize16,
                                               NULL );
                }
                else
                {
                    vpstruct16 = STACKALLOC16( ulCount * uiSize16 );
                }

                if (vpstruct16 == 0)
                {
                    dwResult = (DWORD)E_OUTOFMEMORY;
                }
            }
        }
    }

    if (SUCCEEDED(dwResult))
    {
        TO_STACK16(pti, ulCount, ULONG);
        TO_STACK16(pti, vpstruct16, VPVOID);
        TO_STACK16(pti, vpfetched16, VPVOID);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);
    }

    if ( SUCCEEDED(dwResult) )
    {
        lpfetched16 = FIXVDMPTR( vpfetched16, ULONG);
        ulFetched16 = *lpfetched16;
        RELVDMPTR(vpfetched16);

        if ( lpstruct32 != NULL )
        {
            // Some apps (MsWorks3 is one) return S_FALSE and do not return
            // the number of elements retrieved.  The only thing we can
            // do is ignore the enumeration since we don't know how many
            // were actually set.  Of course, we can't ignore all enumerations
            // when the return is S_FALSE so we only handle the case
            // where S_FALSE was returned on a enumeration of one element,
            // in which we can be sure there isn't any valid data
            if (dwResult == (DWORD)S_FALSE && ulCount == 1)
            {
                ulFetched16 = 0;
            }

            //
            // Iterate through all of the structures, converting them
            // into 16-bit
            //
            fError = FALSE;
            ulIterate = 0;
            vpstruct16Iterate = vpstruct16;
            lpstruct32Iterate = lpstruct32;

            while ( ulIterate < ulFetched16 )
            {
                //
                // Callback to the callback function to do any specific
                // processing
                //
                sc = (*pfnCallback)( pti, lpstruct32Iterate,
                                     vpstruct16Iterate );

                if ( FAILED(sc) )
                {
                    fError = TRUE;
                    dwResult = sc;
                }

                vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                             uiSize16);
                lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                             uiSize32);

                ulIterate++;
            }

            if ( fError )
            {
                //
                // Cleanup all these guys
                //
                ulIterate = 0;
                vpstruct16Iterate = vpstruct16;
                lpstruct32Iterate = lpstruct32;

                while ( ulIterate <= ulFetched16 )
                {
                    (*pfnCleanup)( pti, lpstruct32Iterate, vpstruct16Iterate );
                    vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                                 uiSize16);
                    lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                                 uiSize32);

                    ulIterate++;
                }
            }
        }
    }

    if (FAILED(dwResult) && pvArg32 != NULL)
    {
        memset(pvArg32, 0, ulCount*uiSize32);
    }

    if ( lpfetched32 != NULL )
    {
        *lpfetched32 = ulFetched16;
    }

    //
    // Free up any space we've allocated
    //
    if (vpstruct16 != 0)
    {
        if ( ulCount > MAX_ALLOCA_STRUCT )
        {
            WgtUnlockFree( vpstruct16 );
        }
        else
        {
            STACKFREE16( vpstruct16, ulCount * uiSize16 );
        }
    }

    if (vpfetched16 != 0)
    {
        STACKFREE16(vpfetched16, sizeof(ULONG));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STRING_3216, public
//
//  Synopsis:   Prepares the LPOLESTR for the copy back into 16-bit address
//              space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STRING_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPSTR vpstr;

    *(LPOLESTR *)lp32 = NULL;
    vpstr = *FIXVDMPTR(vp16, VPSTR);
    RELVDMPTR(vp16);
    return ConvertTaskString1632(pti, vpstr, NULL, 0, (LPOLESTR *)lp32);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STRING_3216, public
//
//  Synopsis:   Cleans up the any STRINGs returned (either to 16-bit or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STRING_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPOLESTR lpstr32;

    lpstr32 = *(LPOLESTR *)lp32;
    if ( lpstr32 != NULL )
    {
        TaskFree32( lpstr32 );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STRING_3216, public
//
//  Synopsis:   Thunks IEnumSTRING::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STRING_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(LPOLESTR),
                             sizeof(VPSTR),
                             Callback_STRING_3216,
                             Cleanup_STRING_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_UNKNOWN_3216, public
//
//  Synopsis:   Prepares the UNKNOWN structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_UNKNOWN_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE           sc = S_OK;
    VPVOID          vpunknown16;
    IUnknown        *punkThis32;

    vpunknown16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);

    punkThis32 = pti->pThkMgr->FindProxy3216(NULL, vpunknown16, NULL,
                                             INDEX_IIDIDX(THI_IUnknown),
                                             FALSE, NULL);
    
    // Release the actual 16-bit IUnknown as it is an OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    ReleaseOnObj16(vpunknown16);

    if(!punkThis32) {
        sc = E_OUTOFMEMORY;
    }

    *(LPUNKNOWN *)lp32 = (LPUNKNOWN)punkThis32;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_UNKNOWN_3216, public
//
//  Synopsis:   Cleans up the any UNKNOWNs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_UNKNOWN_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPUNKNOWN lpunknown32;
    VPVOID vpv;

    lpunknown32 = *(LPUNKNOWN *)lp32;
    if(lpunknown32) {
        // Release the proxy to 16-bit interface
        ReleaseProxy3216((THUNK3216OBJ *) lpunknown32);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_UNKNOWN_3216, public
//
//  Synopsis:   Thunks IEnumUNKNOWN::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_UNKNOWN_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(LPUNKNOWN),
                             sizeof(LPUNKNOWN),
                             Callback_UNKNOWN_3216,
                             Cleanup_UNKNOWN_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATSTG_3216, public
//
//  Synopsis:   Prepares the STATSTG structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STATSTG_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    ((STATSTG *)lp32)->pwcsName = NULL;
    return ConvertStatStg1632(pti, vp16, (STATSTG *)lp32,
                              NULL, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATSTG_3216, public
//
//  Synopsis:   Cleans up the any STATSTGs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATSTG_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATSTG FAR     *lpstatstg32;

    lpstatstg32 = (STATSTG FAR *)lp32;

    if ( lpstatstg32->pwcsName != NULL )
    {
        TaskFree32( lpstatstg32->pwcsName );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATSTG_3216, public
//
//  Synopsis:   Thunks IEnumSTATSTG::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATSTG_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(STATSTG),
                             sizeof(STATSTG),
                             Callback_STATSTG_3216,
                             Cleanup_STATSTG_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_FORMATETC_3216, public
//
//  Synopsis:   Prepares the FORMATETC structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_FORMATETC_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    ((FORMATETC *)lp32)->ptd = NULL;
    return ConvertFetc1632(pti, vp16, (FORMATETC *)lp32, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_FORMATETC_3216, public
//
//  Synopsis:   Cleans up the any FORMATETCs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_FORMATETC_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    FORMATETC FAR   *lpformatetc32;

    lpformatetc32 = (FORMATETC FAR *)lp32;

    if ( lpformatetc32->ptd != NULL )
    {
        TaskFree32( lpformatetc32->ptd );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_FORMATETC_3216, public
//
//  Synopsis:   Thunks IEnumFORMATETC::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_FORMATETC_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(FORMATETC),
                             sizeof(FORMATETC16),
                             Callback_FORMATETC_3216,
                             Cleanup_FORMATETC_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATDATA_3216, public
//
//  Synopsis:   Prepares the STATDATA structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
SCODE Callback_STATDATA_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE               sc;
    LPSTATDATA          lpstatdata32;
    STATDATA16 UNALIGNED *lpstatdata16;
    LPADVISESINK        lpadv32;
    VPVOID              vpadv16;
    IUnknown            *punkThis32;

    sc = S_OK;

    lpstatdata32 = (LPSTATDATA)lp32;

    lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
    vpadv16 = lpstatdata16->pAdvSink;
    RELVDMPTR(vp16);

    if ( vpadv16 != 0)
    {
        // We don't know whether it's an AdviseSink or
        // an AdviseSink2, so pass AdviseSink2 since it's
        // a superset of AdviseSink and will work for both

        punkThis32 =
            pti->pThkMgr->FindProxy3216(NULL, vpadv16, NULL,
                                        INDEX_IIDIDX(THI_IAdviseSink2),
                                        FALSE, NULL);
        
        // Release the actual 16-bit IAdviseSink as it is an OUT parameter
        // This could be the last release on the interface if the
        // above call failed;
        ReleaseOnObj16(vpadv16);
        
        if(!punkThis32) {
            sc = E_OUTOFMEMORY;
        }

        lpadv32 = (LPADVISESINK)punkThis32;
    }
    else
    {
        lpadv32 = NULL;
    }

    lpstatdata32->formatetc.ptd = NULL;
    if (SUCCEEDED(sc))
    {
        // If this fails the AdviseSink proxy will be cleaned up in
        // the cleanup function later

        sc = ConvertFetc1632(pti,
                             vp16+FIELD_OFFSET(STATDATA16, formatetc),
                             &lpstatdata32->formatetc, TRUE);
    }

    if (SUCCEEDED(sc))
    {
        lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
        lpstatdata32->advf = lpstatdata16->advf;
        lpstatdata32->pAdvSink = lpadv32;
        lpstatdata32->dwConnection = lpstatdata16->dwConnection;
        RELVDMPTR(vp16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATDATA_3216, public
//
//  Synopsis:   Cleans up the any STATDATAs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATDATA_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATDATA FAR    *lpstatdata32;
    VPVOID vpvSink;

    lpstatdata32 = (STATDATA FAR *)lp32;

    if ( lpstatdata32->formatetc.ptd != NULL )
    {
        TaskFree32( lpstatdata32->formatetc.ptd );
    }

    if(lpstatdata32->pAdvSink) {
        // Release the proxy to 16-bit interface
        ReleaseProxy3216((THUNK3216OBJ *) (lpstatdata32->pAdvSink));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATDATA_3216, public
//
//  Synopsis:   Thunks IEnumSTATDATA::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATDATA_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(STATDATA),
                             sizeof(STATDATA16),
                             Callback_STATDATA_3216,
                             Cleanup_STATDATA_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_MONIKER_3216, public
//
//  Synopsis:   Prepares the MONIKER structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_MONIKER_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPVOID          vpmoniker16;
    IUnknown        *punkThis32;
    SCODE           sc = S_OK;

    vpmoniker16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);

    punkThis32 = pti->pThkMgr->FindProxy3216(NULL, vpmoniker16, NULL,
                                             INDEX_IIDIDX(THI_IMoniker),
                                             FALSE, NULL);
    
    // Release the actual 16-bit IMoniker as it is an OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    ReleaseOnObj16(vpmoniker16);
    
    if(!punkThis32) {
        sc = E_OUTOFMEMORY;
    }

    *(LPMONIKER *)lp32 = (LPMONIKER)punkThis32;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_MONIKER_3216, public
//
//  Synopsis:   Cleans up the any MONIKERs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_MONIKER_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPMONIKER       lpmoniker32;
    VPVOID vpv;

    lpmoniker32 = *(LPMONIKER *)lp32;
    if(lpmoniker32) {
        // Release the proxy to 16-bit interface
        ReleaseProxy3216((THUNK3216OBJ *) lpmoniker32);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_MONIKER_3216, public
//
//  Synopsis:   Thunks IEnumMONIKER::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_MONIKER_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(LPMONIKER),
                             sizeof(LPMONIKER),
                             Callback_MONIKER_3216,
                             Cleanup_MONIKER_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_OLEVERB_3216, public
//
//  Synopsis:   Prepares the OLEVERB structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_OLEVERB_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE       sc;
    OLEVERB *lpoleverb32;
    OLEVERB UNALIGNED *lpoleverb16;
    VPSTR vpstr;

    lpoleverb32 = (LPOLEVERB)lp32;

    lpoleverb16 = FIXVDMPTR(vp16, OLEVERB);
    vpstr = (VPSTR)lpoleverb16->lpszVerbName;
    RELVDMPTR(vp16);

    lpoleverb32->lpszVerbName = NULL;
    sc = ConvertTaskString1632(pti, vpstr, NULL, 0,
                               &lpoleverb32->lpszVerbName);
    if (SUCCEEDED(sc))
    {
        lpoleverb16 = FIXVDMPTR(vp16, OLEVERB);
        lpoleverb32->lVerb        = lpoleverb16->lVerb;
        lpoleverb32->fuFlags      = lpoleverb16->fuFlags;
        lpoleverb32->grfAttribs   = lpoleverb16->grfAttribs;
        RELVDMPTR(vp16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_OLEVERB_3216, public
//
//  Synopsis:   Cleans up the any OLEVERBs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_OLEVERB_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    OLEVERB FAR     *lpoleverb32;

    lpoleverb32 = (LPOLEVERB)lp32;

    if ( lpoleverb32->lpszVerbName != NULL )
    {
        TaskFree32( lpoleverb32->lpszVerbName );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_OLEVERB_3216, public
//
//  Synopsis:   Thunks IEnumOLEVERB::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_OLEVERB_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(OLEVERB),
                             sizeof(OLEVERB),
                             Callback_OLEVERB_3216,
                             Cleanup_OLEVERB_3216 );
}

#define THOP_EFN(x)  Thop_Enum_ ## x ## _3216

DWORD (*CONST aThopEnumFunctions3216[])(THUNKINFO *) =
{
    THOP_EFN(STRING),               // STRING
    THOP_EFN(UNKNOWN),              // UNKNOWN
    THOP_EFN(STATSTG),              // STATSTG
    THOP_EFN(FORMATETC),            // FORMATETC
    THOP_EFN(STATDATA),             // STATDATA
    THOP_EFN(MONIKER),              // MONIKER
    THOP_EFN(OLEVERB),              // OLEVERB
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thop16.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thop16.cxx
//
//  Contents:   Thop implementations for 16->32
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2.h>
#include <valid.h>
#include <string.h>

#include "struct16.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   EXECUTE_THOP1632, public
//
//  Synopsis:   Debugging version of thop dispatch routine
//
//  Arguments:  [pti] - Thunking info
//
//  Returns:    Appropriate status
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
DWORD EXECUTE_THOP1632(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExThop1632: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 ThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();
    
    // Local variable
    DWORD dwRet;

    // Sanity check
    thkAssert((*pti->pThop & THOP_OPMASK) < THOP_LASTOP);
    dwRet = (*aThopFunctions1632[*((pti)->pThop) & THOP_OPMASK])(pti);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExThop1632\n", NestingLevelString()));
    return(dwRet);
}
#endif

#if DBG == 1
DWORD EXECUTE_ENUMTHOP1632(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExEnumThop1632: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 EnumThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();

    // Local variable
    DWORD dwRet;
    
    dwRet = (*aThopEnumFunctions1632[*(pti)->pThop])(pti);
    
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExEnumThop1632\n", NestingLevelString()));
    return(dwRet);
}
#endif

// Generated by the tool, in tc1632.cxx
DWORD ThunkCall1632( THUNKINFO * );

//+---------------------------------------------------------------------------
//
//  Function:   FixedThopHandler, public
//
//  Synopsis:   Generic function which handles the high-level details
//              of thop execution for thops that operate on known-size
//              data
//
//  Arguments:  [pti] - Thunking state information
//              [thop] - Thop being executed
//              [cb16] - 16-bit size
//              [pfn1632] - 16->32 conversion routine
//              [cb32] - 32-bit size
//              [pfn3216] - 32->16 conversion routine
//
//  Returns:    Appropriate status code
//
//  History:    05-Apr-94       DrewB   Created
//
//  Notes:      Automatically increments pThop
//
//----------------------------------------------------------------------------

DWORD FixedThopHandler1632(THUNKINFO *pti,
                           THOP thop,
                           UINT cb16,
                           FIXEDHANDLERROUTINE pfn1632,
                           UINT cb32,
                           FIXEDHANDLERROUTINE pfn3216)
{
    DWORD   dwResult;
    VPVOID  vp16;
    BYTE    *pb16;
    BYTE    *pb32;

    if ((thop & (THOP_IN | THOP_OUT)) != 0)
    {
        pb32 = NULL;

        GET_STACK16(pti, vp16, VPVOID);
        if ( vp16 != 0 )
        {
            pb16 = (BYTE *)ValidatePtr16(pti, vp16, cb16, thop);
            if (pb16 != NULL)
            {
                pb32 = (BYTE *)STACKALLOC32(cb32);
                if (pb32 == NULL)
                {
                    pti->scResult = E_OUTOFMEMORY;
                }
                else if ((thop & THOP_IN) != 0)
                {
                    (pfn1632)(pb16, pb32, cb16, cb32);
                }

                WOWRELVDMPTR(vp16);
            }
        }

        TO_STACK32(pti, pb32, BYTE *);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);

        if ((thop & THOP_OUT) != 0 && vp16 != 0)
        {
            pb16 = (BYTE *)WOWFIXVDMPTR(vp16, cb16);

            if (SUCCEEDED(dwResult))
            {
                (pfn3216)(pb32, pb16, cb32, cb16);
            }
            else if ((thop & THOP_IN) == 0)
            {
                // Zero out-only parameters on failure
                memset(pb16, 0, cb16);
            }

            WOWRELVDMPTR(vp16);
        }

        if (pb32 != NULL)
        {
            STACKFREE32(pb32, cb32);
        }
    }
    else
    {
        (pfn1632)(PTR_STACK16(&pti->s16, cb16), PTR_STACK32(&pti->s32),
                  cb16, cb32);
        SKIP_STACK16(&pti->s16, cb16);
        SKIP_STACK32(&pti->s32, cb32);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);
    }

    return dwResult;
}

//-----------------------------------------------------------------------------
//
// Handler-based thunks
//
// These thunks use the fixed-size generic thop handler to do their work
//
//-----------------------------------------------------------------------------

// Handle straight copy
DWORD Thop_Copy_1632(THUNKINFO *pti)
{
    THOP thopSize;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_COPY);

    thopSize = *++pti->pThop;
    return FixedThopHandler1632(pti,
                                *(pti->pThop-1),
                                thopSize, FhCopyMemory,
                                thopSize, FhCopyMemory);
}

DWORD Thop_ShortToLong_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SHORTLONG);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(SHORT), FhShortToLong,
                                sizeof(LONG), FhLongToShort);
}

DWORD Thop_WordToDword_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_WORDDWORD);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(WORD), FhWordToDword,
                                sizeof(DWORD), FhDwordToWord);
}

DWORD Thop_GdiHandle_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HGDI);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhGdiHandle1632,
                                sizeof(HANDLE), FhGdiHandle3216);
}

DWORD Thop_UserHandle_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HUSER);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhUserHandle1632,
                                sizeof(HANDLE), FhUserHandle3216);
}

DWORD Thop_HACCEL_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HACCEL);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHaccel1632,
                                sizeof(HANDLE), FhHaccel3216);
}

DWORD Thop_HTASK_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HTASK);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHtask1632,
                                sizeof(HANDLE), FhHtask3216);
}

DWORD Thop_HRESULT_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HRESULT);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HRESULT), FhHresult1632,
                                sizeof(HRESULT), FhHresult3216);
}

DWORD Thop_NULL_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_NULL);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(void *), FhNull,
                                sizeof(void *), FhNull);
}

DWORD Thop_RECT_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RECT);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(RECT16), FhRect1632,
                                sizeof(RECT), FhRect3216);
}

DWORD Thop_BINDOPTS_1632( THUNKINFO *pti )
{
    VPVOID vpbo16;
    BIND_OPTS UNALIGNED *pbo;
    UINT cb;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BINDOPTS);

    PEEK_STACK16(pti, vpbo16, VPVOID);
    pbo = (BIND_OPTS UNALIGNED *)GetReadPtr16(pti, vpbo16, sizeof(BIND_OPTS));
    if (pbo != NULL)
    {
        cb = pbo->cbStruct;
        WOWRELVDMPTR(vpbo16);
    }
    else
    {
        // Doesn't really matter, since pti->scResult was set to error
        // by GetReadPtr16
        cb = sizeof(BIND_OPTS);
    }

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                cb, FhCopyMemory,
                                cb, FhCopyMemory);
}

DWORD Thop_SIZE_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZE);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(SIZE16), FhSize1632,
                                sizeof(SIZE), FhSize3216);
}

DWORD Thop_MSG_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_MSG);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(MSG16), FhMsg1632,
                                sizeof(MSG), FhMsg3216);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ERROR_1632, public
//
//  Synopsis:   Any Thop type which should just fail with an error
//              should go be directed here.
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_ERROR_1632 ( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ERROR);

    thkAssert( FALSE && "Hey we hit an ERROR Thop in 16->32" );

    return (DWORD)E_UNEXPECTED;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInString1632, public
//
//  Synopsis:   Converts an in-parameter string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkInString1632(THUNKINFO *pti)
{
    DWORD   dwResult;
    VPSTR   vpstr;
    LPOLESTR lpstrDest;
    OLECHAR *ptcStackText;

    dwResult = (DWORD)S_OK;
    ptcStackText = NULL;

    GET_STACK16(pti, vpstr, VPSTR);

    if (vpstr == 0)
    {
        lpstrDest = NULL;
    }
    else
    {
        ptcStackText = (OLECHAR *)STACKALLOC32(CWCSTRINGPREALLOC*
                                               sizeof(OLECHAR));
        if (ptcStackText == NULL)
        {
            pti->scResult = E_OUTOFMEMORY;
        }
        else
        {
            lpstrDest = Convert_VPSTR_to_LPOLESTR( pti, vpstr, ptcStackText,
                                                   CWCSTRINGPREALLOC );
        }
    }

    thkDebugOut((DEB_ARGS, "In1632  LPSTR: %p -> %p '%ws'\n",
                 vpstr, lpstrDest, lpstrDest));

    TO_STACK32(pti, lpstrDest, LPOLESTR );

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (lpstrDest != NULL)
    {
        Convert_VPSTR_to_LPOLESTR_free( ptcStackText, lpstrDest );
    }

    if (ptcStackText != NULL)
    {
        STACKFREE32(ptcStackText, CWCSTRINGPREALLOC*sizeof(OLECHAR));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPSTR_1632, public
//
//  Synopsis:   Converts 16-bit LPSTR to 32-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LPSTR_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPSTR);
    //
    // We have only input LPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "LPSTR must be input only!" );

    return ThunkInString1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertTaskString3216, public
//
//  Synopsis:   Converts a task-memory string
//
//  Arguments:  [pti] - Thunk info
//              [pos32] - String
//              [vpstrPreAlloc] - Preallocated string or NULL
//              [cchPreAlloc] - Preallocated size or zero
//              [pvpstr16] - String
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pti]
//              [pvpstr16]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Frees preallocation if successful and:
//                  Name is too large or
//                  Name is NULL
//
//              Always frees source string if non-zero and valid
//
//----------------------------------------------------------------------------

SCODE ConvertTaskString3216(THUNKINFO *pti,
                            LPOLESTR pos32,
                            VPSTR vpstrPreAlloc,
                            UINT cchPreAlloc,
                            VPSTR UNALIGNED *pvpstr16)
{
    VPVOID vpstr16;
    UINT cch;
    SCODE sc;

    sc = S_OK;

    if (pos32 == NULL)
    {
        vpstr16 = 0;
    }
    else
    {
        if (IsBadStringPtrW(pos32, CCHMAXSTRING))
        {
            sc = E_INVALIDARG;
        }
        else
        {
            cch = lstrlenW(pos32)+1;

            if (cch > cchPreAlloc)
            {
                // Our prealloc buffer is too small, so try and get a
                // new one

                // Allow for each Unicode character to take two
                // bytes in case of multibyte expansion
                vpstr16 = (VPSTR)TaskMalloc16( cch*2 );
                if (vpstr16 == 0)
                {
                    sc = E_OUTOFMEMORY;
                }
            }
            else
            {
                vpstr16 = vpstrPreAlloc;
            }

            if (SUCCEEDED(sc))
            {
                sc = Convert_LPOLESTR_to_VPSTR(pos32, vpstr16, cch, cch*2);
                if (FAILED(sc) && vpstr16 != vpstrPreAlloc)
                {
                    TaskFree16(vpstr16);
                }
            }

            TaskFree32(pos32);
        }
    }

    if (SUCCEEDED(sc))
    {
        // If there was a preallocated string we didn't use,
        // free it
        if (vpstrPreAlloc != 0 && vpstrPreAlloc != vpstr16)
        {
            TaskFree16(vpstrPreAlloc);
        }

        *pvpstr16 = vpstr16;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkOutString1632, public
//
//  Synopsis:   Converts an out param string or filename
//
//  Arguments:  [pti] - Thunk state information
//              [fFile] - Filename or plain string
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkOutString1632(THUNKINFO *pti,
                         BOOL fFile)
{
    DWORD           dwResult;
    VPVOID          vpvpstr16;
    VPSTR           vpstr16;
    VPSTR UNALIGNED *lpvpstr16;
    LPOLESTR        *lplpstr32;
    LPOLESTR        lpstr = NULL;

    GET_STACK16(pti, vpvpstr16, VPSTR);

    lplpstr32 = NULL;
    if ( vpvpstr16 != 0 )
    {
        lpvpstr16 = (VPSTR UNALIGNED *)GetWritePtr16(pti, vpvpstr16,
                                                     sizeof(VPSTR));
        if ( lpvpstr16 != NULL )
        {
            WOWRELVDMPTR(vpvpstr16);

            lplpstr32 = &lpstr;

            vpstr16 = (VPSTR)TaskMalloc16(CBSTRINGPREALLOC);
            if (vpstr16 == 0)
            {
                pti->scResult = E_OUTOFMEMORY;
            }
        }
    }

    TO_STACK32(pti, lplpstr32, LPOLESTR FAR *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( lplpstr32 != NULL )
    {
        if ( SUCCEEDED(dwResult) )
        {
            SCODE sc;

            if (fFile)
            {
                UINT cch;

                // The string pointed to by lpstr is ours so we
                // can do the long->short conversion in place
                // without worrying about trashing the memory
                // The short path name should always be able
                // to fit in the long path name's buffer since
                // the file names that we are thunking are always
                // absolute paths

                cch = lstrlenW(lpstr)+1;

                // Ignore failures; if we can't convert the name
                // then we simply pass on what we were given
                GetShortPathName(lpstr, lpstr, cch);
            }

            sc = ConvertTaskString3216(pti, lpstr, vpstr16,
                                       CWCSTRINGPREALLOC, &vpstr16);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            TaskFree16(vpstr16);
            vpstr16 = 0;
        }

        lpvpstr16 = FIXVDMPTR( vpvpstr16, VPSTR );
        *lpvpstr16 = vpstr16;

#if DBG==1
        thkDebugOut((DEB_ARGS, "%sOut1632 LPLPSTR: %p -> %p '%s'\n",
                     NestingLevelString(), lpstr, vpstr16,
                     vpstr16 != 0 ? WOWFIXVDMPTR(vpstr16, 0) : "<null>"));
        if (vpstr16 != 0)
        {
            WOWRELVDMPTR(vpstr16);
        }
#endif

        RELVDMPTR( vpvpstr16 );
    }
    else
    {
        thkDebugOut((DEB_ARGS, "Out1632 LPLPSTR NULL\n"));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPLPSTR_1632, public
//
//  Synopsis:   Converts 32-bit LPSTR to 16-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_LPLPSTR_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPLPSTR);
    //
    // We don't have anything but unmodified LPLPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "LPLPSTR must be unmodified only!" );

    return ThunkOutString1632(pti, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_BUFFER_1632, public
//
//  Synopsis:   Converts 16-bit block of memory to 32-bit block of memory
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       BobDay  Created
//              14-Mar-95       KentCe  Buffer copy not required for Win95.
//
//  Notes:      WARNING! WARNING! WARNING! For an out parameter this expects
//              three parameters on the stack in the following format and order:
//                  VOID *  pointer to buffer
//                  DWORD   count of bytes in buffer
//                  DWORD * count of bytes returned in the buffer
//
//----------------------------------------------------------------------------

#define WATCH_VALUE 0xfef1f0

DWORD Thop_BUFFER_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      vp16;
    LPVOID      lp16;
    LPVOID      lp32;
    DWORD       dwCount;
    VPVOID      vp16CountOut;
    DWORD       dwCountOut32 = 0;
    DWORD *     pdwCountOut32 = &dwCountOut32;
#if DBG == 1
    DWORD       dwWatch;
#endif

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BUFFER);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We only have in and out BUFFER thops
    //
    thkAssert((fThopInput || fThopOutput)
         && (fThopInput != fThopOutput)
         && "BUFFER must be in or out only!" );

    GET_STACK16(pti, vp16, VPVOID);
    GET_STACK16(pti, dwCount, DWORD);

    if (fThopOutput)
    {
        // Get the pointer to the returned value off the stack
        GET_STACK16(pti, vp16CountOut, VPVOID);
    }

    lp32 = NULL;

    if (vp16 == 0)
    {
        // lp32 is already NULL
    }
    else if (dwCount == 0)
    {
        // If the count is zero then we can pass any valid 32-bit
        // pointer

#if DBG == 1
        // In debug, make sure that no data is written back to the
        // memory we pass on
        dwWatch = WATCH_VALUE;
        lp32 = &dwWatch;
#else
        lp32 = &dwResult;
#endif
    }
    else
    {
        lp16 = ValidatePtr16(pti, vp16, dwCount, *pti->pThop);

        if ( lp16 != NULL )
        {
            lp32 = (LPVOID)CoTaskMemAlloc( dwCount );
            if ( lp32 == NULL )
            {
                pti->scResult = E_OUTOFMEMORY;
            }
            else
            {
                if ( fThopInput )
                {
                    memcpy( lp32, lp16, dwCount );
                }
            }

            WOWRELVDMPTR(vp16);
        }
    }

    thkDebugOut((DEB_ARGS, "1632    BUFFER: %p -> %p, %u\n",
                 vp16, lp32, dwCount));

    TO_STACK32(pti, lp32, LPVOID );
    TO_STACK32(pti, dwCount, DWORD );

    if (fThopOutput)
    {
        TO_STACK32(pti, pdwCountOut32, LPVOID );
    }

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (fThopOutput)
    {
        // If the pointer in sixteen bit land is non-null then return the
        // count of bytes written to the buffer.
        DWORD UNALIGNED *lpdw16 = (DWORD UNALIGNED *)
               ValidatePtr16(pti, vp16CountOut, sizeof(DWORD), *pti->pThop);

        if (lpdw16 != NULL)
        {
            *lpdw16 = dwCountOut32;
            WOWRELVDMPTR(vp16CountOut);
        }

        if ( SUCCEEDED(dwResult) )
        {
            if (dwCountOut32 > 0 && vp16 != 0)
            {
                lp16 = (LPVOID)WOWFIXVDMPTR( vp16, dwCountOut32 );

                memcpy( lp16, lp32, dwCountOut32 );

                WOWRELVDMPTR(vp16);
            }
        }
    }

#if DBG == 1
    if (lp32 != NULL && dwCount == 0)
    {
        thkAssert(dwWatch == WATCH_VALUE);
    }
#endif

    //
    // Now free the buffer
    //
    if ( lp32 != NULL && dwCount > 0 )
    {
        CoTaskMemFree( lp32 );
    }


    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SNB_1632, public
//
//  Synopsis:   Converts 16-bit SNB to 32-bit SNB pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_SNB_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      snb16;
    VPSTR       *lpvpstr;
    VPSTR UNALIGNED *lpvpstrTemp;
    VPSTR       vpstr;
    SNB         snb32;
    UINT        cStr;
    UINT        cStrTemp;
    LPOLESTR    *lplpstr;
    UINT        cbStrings;
    OLECHAR     *pocStr;
    LPSTR       lpstr16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SNB);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We don't have anything but unmodified SNBs
    //
    thkAssert( !fThopInput && !fThopOutput && "SNB must be unmodified only!" );

    GET_STACK16(pti, snb16, VPVOID);

    snb32 = NULL;
    if ( snb16 != 0 )
    {
        //
        // Count the strings in the 16-bit snb
        //
        lpvpstr = (VPSTR FAR *)GetReadPtr16( pti, snb16, sizeof(VPSTR) );
        if ( lpvpstr != 0 )
        {
            lpvpstrTemp = lpvpstr;
            cStr = 0;
            cbStrings = 0;
            do
            {
                cStr++;
                vpstr = *lpvpstrTemp++;

                if ( vpstr == 0 )
                {
                    break;
                }

                lpstr16 = GetStringPtr16(pti, vpstr, CCHMAXSTRING,
                                         &cStrTemp);
                if ( lpstr16 == 0 )
                {
                    WOWRELVDMPTR(snb16);
                    lpvpstr = NULL;
                    break;      // Leave with snb32 still NULL
                }

                WOWRELVDMPTR(vpstr);

                cbStrings += cStrTemp;
            }
            while ( TRUE );
        }

        if ( lpvpstr != NULL )
        {
            thkDebugOut((DEB_ARGS, "In1632  SNB: %d strings\n", cStr));

            //
            // Allocate space for the 32-bit snb
            //
            snb32 = (LPOLESTR FAR *)CoTaskMemAlloc( cStr*sizeof(LPOLESTR) +
                                                    cbStrings*sizeof(WCHAR));
            if (snb32 == NULL)
            {
                pti->scResult = E_OUTOFMEMORY;
            }
            else
            {
                pocStr = (OLECHAR *)((BYTE *)snb32+cStr*sizeof(LPOLESTR));

                //
                // Now convert the strings
                //
                lpvpstrTemp = lpvpstr;
                lplpstr = snb32;
                cStrTemp = cStr - 1;

                while ( cStrTemp > 0 )
                {
                    --cStrTemp;

                    vpstr = *lpvpstrTemp++;

                    thkAssert( vpstr != 0 &&
                               "Loop is processing end of snb\n" );

                    // Guaranteed to use pocStr as storage since cbStrings is
                    // large enough to contain all the strings
                    *lplpstr = Convert_VPSTR_to_LPOLESTR( pti, vpstr,
                                                          pocStr, cbStrings );

                    if (*lplpstr == NULL)
                    {
                        CoTaskMemFree(snb32);
                        snb32 = NULL;
                        break;
                    }

#if DBG == 1
                    thkDebugOut((DEB_ARGS, "In1632  SNB: %p '%s' -> "
                                 "%p '%ws'\n",
                                 vpstr, WOWFIXVDMPTR(vpstr, 0),
                                 *lplpstr, *lplpstr));
                    WOWRELVDMPTR(vpstr);
#endif

                    pocStr += lstrlenW(pocStr)+1;
                    lplpstr++;
                }

                // Terminate SNB
                *lplpstr = NULL;

                thkAssert(*lpvpstrTemp == 0);

                WOWRELVDMPTR(snb16);
            }
        }
    }

    thkDebugOut((DEB_ARGS, "In1632  SNB: %p -> %p\n", snb16, snb32));

    TO_STACK32(pti, snb32, SNB );

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    //
    // Free SNB memory if necessary
    //
    if ( snb32 != 0 )
    {
        CoTaskMemFree(snb32);
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInterface1632, private
//
//  Synopsis:   Handles interface thunking for THOP_IFACE and
//              THOP_IFACEGEN
//
//  Arguments:  [pti]       - Thunking state information
//              [iidx]      - Interface index or IID
//              [thop]      - Thop being executed
//              [punkOuter] - Controlling IUnknown or NULL
//
//  Returns:    status code
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes:      Assumes caller has already adjusted pti->pThop
//----------------------------------------------------------------------------

DWORD ThunkInterface1632(THUNKINFO *pti, IIDIDX iidx, THOP thop, IUnknown *punkOuter)
{
    // Local variables
    VPVOID vpv;
    DWORD dwResult, dwStatus;
    IUnknown *punkThis32In;
    IUnknown *punkThis32Out;
    VPVOID vpvOut;
    VPVOID vpvIn;
    VPVOID UNALIGNED *pvpvOut;
    VPVOID vpvPreAlloc = NULL;
    THUNK1632OBJ UNALIGNED *pto;
    PROXYHOLDER *pph;
    PROXYHOLDER *pAggHolder = NULL;
    SAggHolder aggHolderNode;
    BOOL      bUnlinkAggHolder = FALSE;
    BOOL      bExtraAddRef;

    // Validate the IID of the interface
    thkAssert(IIDIDX_IS_IID(iidx) ||
              (IIDIDX_INDEX(iidx) >= 0 &&  IIDIDX_INDEX(iidx) <= THI_COUNT));

    // Initialize
    dwResult = (DWORD) S_OK;
    punkThis32In = NULL;
    pph = NULL;

    // Retrieve interface pointer
    GET_STACK16(pti, vpv, VPVOID);

    // Assert invariant
    thkAssert(iidx!=THI_COUNT || vpv==NULL);

    // Check for valid OUT parameter. It also verifies IN-OUT case as well
    if((thop & THOP_OUT) && vpv) {
        pvpvOut = (VPVOID UNALIGNED *)GetWritePtr16(pti, vpv, sizeof(VPVOID));
        if(!pvpvOut) {
            thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - bad pointer %p\n",
                         vpv));
            pti->scResult = E_INVALIDARG;
            return (DWORD) E_INVALIDARG;
        }

        // Check if the interface needs to be thunked IN as well.
        // In other words, IN-OUT paramenter case
        if(thop & THOP_IN)
            vpvIn = *pvpvOut;
        else
            vpvIn = NULL;

        // Release the VMD pointer
        WOWRELVDMPTR(vpv);
    }
    else {
        // It must be IN parameter or a NULL OUT parameter
        vpvIn = vpv;
    }

    // Check if interface needs to be thunked IN
    if(thop & THOP_IN) {
        if (vpvIn) {
            // Validate the interface
            if(IsValidInterface16(pti, vpvIn)) {
                if((thop & THOP_OPMASK) == THOP_IFACENOADDREF) {
                    // vpvIn represents an interface that is used by the
                    // 32-bit side without addrefing it.
                    // Classic example: IOleCacheControl::OnRun
                    // Aggregate it with the identity of the interface on which
                    // the current call is being made to ensure that lifetime of proxy
                    // is controlled by it.
                    VPVOID vpvThis16;

                    // Obtain the 16-bit interface on which the current call is
                    // being made
                    thkAssert(punkOuter);
                    vpvThis16 = pti->pThkMgr->LookupProxy1632(punkOuter);
                    thkAssert(vpvThis16);

                    // Obtain its holder
                    pto = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
                    pph = pto->pphHolder;
                    thkAssert(pto->punkThis32 ==  punkOuter);
                    RELVDMPTR(vpvThis16);

                    // Assert that holder exists
                    thkAssert(pph);
                }
                else {
                    thkAssert(pph == NULL);
                }

                if((thop & THOP_OPMASK) == THOP_UNKOUTER) {                        
                    // Aggregation is being carried out
                    // Assert that interface is only being thunked IN
                    thkAssert(!(thop & THOP_OUT));
                    thkAssert(iidx == THI_IUnknown);

                    // Either find the actual 32-bit identity or generate a
                    // new 32-bit proxy identity for the 16-bit identity
                    punkThis32In = pti->pThkMgr->CreateOuter32(vpvIn, &pAggHolder, &dwStatus);
                    aggHolderNode.pph = pAggHolder;
                    bUnlinkAggHolder = TRUE;
                    TlsThkLinkAggHolder(&aggHolderNode);
                    // We use this pAggHolder for proxies of inner unk(s). Since
                    // we cannot put it in the proxy table (as it is private
                    // and we do not want other thunk calls to use it), we put
                    // it in a linked list in the TLS. The holder gets used by
                    // calls to FindAggregate() when the pUnkInner is being
                    // thunked out. The holder is revoked from the list when
                    // the ThunkInterface call for the pUnkOuter unwinds.
                    
                }
                else {
                    // Find/Generate the proxy for the 16-bit interface to be thunked IN
                    bExtraAddRef = FALSE;
                    if (
                        (
                        (pti->pvfn == (VTBLFN) OleIsCurrentClipboard) &&
                        (TlsThkGetAppCompatFlags() & OACF_WORKSCLIPOBJ) 
                        )
                        || 
                        (
                        (TlsThkGetAppCompatFlags() & OACF_TEXTARTDOBJ) &&
                        (pti->iidx == THI_IDataAdviseHolder) && 
                        (iidx == THI_IDataObject) && (pti->dwMethod == 3)
                        )
                       ){
                        bExtraAddRef = TRUE;
                    }

                    punkThis32In = pti->pThkMgr->FindProxy3216(NULL, vpvIn, pph, 
                                                iidx, bExtraAddRef, &dwStatus);
                }
                
                if(punkThis32In) {
                    thkAssert(!((thop & THOP_OPMASK) == THOP_UNKOUTER) ||
                              (dwStatus == FST_CREATED_NEW) || 
                              (dwStatus == FST_SHORTCUT));
                }
                else {
                    thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - Can't create proxy for %p\n",
                                 vpvIn));                    
					pti->scResult = E_OUTOFMEMORY;
					return (DWORD) E_OUTOFMEMORY;
                }
            }
            else {
                thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - invalid interface %p\n", 
                             vpvIn));
                pti->scResult = E_INVALIDARG;
                return (DWORD) E_INVALIDARG;
            }
        }
        else {
            // No interface to be thunked IN
            punkThis32In = NULL;
        }

        thkDebugOut((DEB_ARGS, "%sIn1632  %s %p -> %p\n", 
                     NestingLevelString(), IidIdxString(iidx),
                     vpvIn, punkThis32In));
    }

    // Check if interface needs to be thunked OUT
    if((thop & THOP_OUT) && vpv) {
        // Preallocate a proxy for the out parameter
        vpvPreAlloc = pti->pThkMgr->CanGetNewProxy1632(iidx);
        if(vpvPreAlloc) {
            // Assert that no interface is being thunked IN for
            // pure OUT parameter case
            thkAssert((thop & THOP_IN) || !punkThis32In);

            // Use a local variable for OUT parameter
            punkThis32Out = punkThis32In;

            // Push the OUT/IN-OUT parameter onto the stack
            TO_STACK32(pti, &punkThis32Out, IUnknown **);
            
            // Corel Draw 5.0 HACK
            // Some apps seem to call through the OUT parameter in the 
            // nested calls before the following call returns

            // Set the temporary proxy's this pointer to point to 
            // 32-bit out pointer pushed onto the satck
            pto = FIXVDMPTR(vpvPreAlloc, THUNK1632OBJ);
            pto->punkThis32 = (IUnknown *)&punkThis32Out;
            RELVDMPTR(vpvPreAlloc);

            // Set the 16-bit OUT parameter to the preallocated proxy
            *FIXVDMPTR(vpv, VPVOID) = vpvPreAlloc;
            RELVDMPTR(vpv);
        }
        else {
			thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - Cannot preallocate proxy\n"));
			pti->scResult = E_OUTOFMEMORY;
			dwResult = (DWORD) E_OUTOFMEMORY;
        }

    }
    else
    {
        // Assert invariant
        thkAssert((vpv && punkThis32In) || (!vpv && !punkThis32In));

        TO_STACK32(pti, punkThis32In, IUnknown *);
    }

    if(SUCCEEDED((SCODE)dwResult)) {
        // Execute the next THOP operation
        dwResult = EXECUTE_THOP1632(pti);
    }

    if((thop & THOP_OUT) && vpv) {
        vpvOut = 0;

        if(SUCCEEDED((SCODE)dwResult) && punkThis32Out) {
            // Obtain 16-bit proxy for the 32-bit interface
            if(punkOuter) {
                //Get the holder that was linked into TLS when the pUnkOuter
                //was being thunked in.
                pAggHolder = (TlsThkGetAggHolder())->pph;
                vpvOut = pti->pThkMgr->FindAggregate1632(vpvPreAlloc, punkOuter,
                                                         punkThis32Out, iidx, pAggHolder,
                                                         &dwStatus);
            }
            else {
                vpvOut = pti->pThkMgr->FindProxy1632(vpvPreAlloc, punkThis32Out,
                                                     NULL, iidx, &dwStatus);
            }

            if(vpvOut) {

                if((thop & THOP_OPMASK) == THOP_UNKINNER) {
                    if (dwStatus != FST_SHORTCUT) {
                        THUNK1632OBJ UNALIGNED *pProxy1632;
                        // Obtain the holder
                        pProxy1632 = FIXVDMPTR(vpvOut, THUNK1632OBJ);
                        pph = pProxy1632->pphHolder;

                        // Assert invariants in debug builds
                        thkAssert(pph->dwFlags & PH_AGGREGATEE);
                        thkAssert(dwStatus == FST_CREATED_NEW);

                        // Mark the proxy as representing inner unknown
                        pProxy1632->grfFlags = PROXYFLAG_PUNKINNER;
                    }
                }

                // Either the preallocated proxy was used and freed
                vpvPreAlloc = NULL;
            }
            else {
                pti->scResult = E_OUTOFMEMORY;
                dwResult = (DWORD)E_OUTOFMEMORY;
            }
            
            // Release the actual 32-bit interface. If a proxy to the 
            // 32-bit interface could not be created above, this could 
            // be the last release on the 32-bit interface
            punkThis32Out->Release();
        }

        // Set the OUT parameter
        pvpvOut = FIXVDMPTR(vpv, VPVOID);
        *pvpvOut = vpvOut;
        RELVDMPTR(vpv);

        thkDebugOut((DEB_ARGS, "%sOut1632 %s %p -> %p\n",
                     NestingLevelString(), IidIdxString(iidx), 
                     punkThis32Out, vpvOut));
    }
    
    if(punkThis32In) {
        if((thop & THOP_INOUT) == THOP_INOUT) {
            // IN-OUT parameter.
            thkAssert(vpvIn);

            // Release the 16-bit side interface
            ReleaseOnObj16(vpvIn);
        }
        else {
            // Just an IN parameter
            thkAssert(thop & THOP_IN);

#if DBG==1
            // Ensure that the following is not the last release
            // on the IN parameter
            THKSTATE thkstate;

            // Remember the current thunk state
            thkstate = pti->pThkMgr->GetThkState();

            // Set the thunk state to THKSTATE_VERIFYINPARAM
            pti->pThkMgr->SetThkState(THKSTATE_VERIFY16INPARAM);
#endif
            // Release the 32-bit side interface
            punkThis32In->Release();
#if DBG==1
            // Restore previous thunk state
            pti->pThkMgr->SetThkState(thkstate);
#endif
        }
    }

    // Cleanup
    if(vpvPreAlloc) {
        // Free preallocated proxy as it was not used
        pti->pThkMgr->FreeNewProxy1632(vpvPreAlloc, iidx);
    }

    if (bUnlinkAggHolder)
        TlsThkUnlinkAggHolder();

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACEGEN_1632, public
//
//  Synopsis:   Thunks interfaces out through ppvs from 16->32
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACEGEN_1632(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    VPVOID vpvIid;
    IUnknown *punkOuter;
    IID UNALIGNED const *piid;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(thopOp == THOP_IFACEGEN ||
              thopOp == THOP_IFACEGENOWNER);

    // The current thop byte indicates how many bytes to look
    // back in the stack to find the IID which identifies the
    // interface being returned
    INDEX_STACK16(pti, vpvIid, VPVOID, *pti->pThop, sizeof(VPVOID));
    pti->pThop++;

    piid = (IID const *)GetReadPtr16(pti, vpvIid, sizeof(IID const));
    if (piid == NULL)
    {
        pti->scResult = E_INVALIDARG;
    }
    else
    {
#if DBG == 1
        if (!IsValidIid(*piid))
        {
            pti->scResult = E_INVALIDARG;
        }
        else
#endif
        {
            iidx = IidToIidIdx(*piid);
        }

        WOWRELVDMPTR(vpvIid);
    }

	if (FAILED(pti->scResult))
		return pti->scResult;

    punkOuter = NULL;
    if (thopOp == THOP_IFACEGENOWNER)
    {
        // Obtain the outer unknown that is being passed to the 32 bit world
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK32(pti, punkOuter, IUnknown *, thopWeakOffset);
        if(punkOuter) {
            // Aggregation across 16-32 boundary
            // Assert that the IID requested is IID_IUnknown
            thkAssert(iidx == THI_IUnknown || 
                      (pti->iidx==THI_IPSFactoryBuffer && pti->dwMethod==3));
            // Change thop to indicate that inner unknown is being thunked
            if(iidx == THI_IUnknown)
                thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface1632(pti, iidx, thop, punkOuter);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_OIFI_1632, public
//
//  Synopsis:   Convert OLEINPLACEFRAMEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    26-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_OIFI_1632( THUNKINFO *pti )
{
    DWORD dwResult;
    VPVOID vpoifi16;
    OIFI16 UNALIGNED *poifi16;
    OLEINPLACEFRAMEINFO oifi32;
    OLEINPLACEFRAMEINFO *poifi32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_OIFI);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_OUT);

    // OIFIs are out-only parameters for their contents
    // However, cb is in/out, so we need to copy cb on the way in
    // Furthermore, cb may not be set to a valid value, in which
    // case the documentation mentions that it should be assumed
    // that this is an OLE 2.0 OIFI
    // This thop simply ignores cb on the way in and always sets
    // it to the OLE 2.0 size
    // Since we're out-only, this always works since the number of
    // fields we thunk is the size of the structure that we give out
    // If OLEINPLACEFRAMEINFO is extended, this thop will break

    // Assert that OLEINPLACEFRAMEINFO is what we expect it to be
    thkAssert(sizeof(OLEINPLACEFRAMEINFO) == 20);

    GET_STACK16(pti, vpoifi16, VPVOID);

    poifi32 = NULL;
    if (vpoifi16 != 0)
    {
        poifi16 = (OIFI16 UNALIGNED *) GetWritePtr16(pti, vpoifi16, sizeof(OIFI16));
        if (NULL != poifi16)
        {
            poifi32 = &oifi32;

            // OIFI's may be an out only parameters but if the "cb" field is
            // "in" RPC doesn't slice up structs, so the whole thing is "in"
            // as well.  We are Thoping here but if we want this to match
            // the RPC sematics then we need to copy all the fields.

            poifi32 = &oifi32;
            poifi32->cb            = sizeof(OLEINPLACEFRAMEINFO);
            poifi32->fMDIApp       = (BOOL)poifi16->fMDIApp;
            poifi32->hwndFrame     = HWND_32(poifi16->hwndFrame);
            poifi32->cAccelEntries = (UINT)poifi16->cAccelEntries;

            if (poifi16->haccel == NULL)
            {
                poifi32->haccel = NULL;
            }
            else
            {
                // WOW will clean up any dangling accelerator tables when
                // tasks die
                poifi32->haccel = HACCEL_32(poifi16->haccel);
                if (poifi32->haccel == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
            }

            WOWRELVDMPTR(vpoifi16);
        }
    }

    TO_STACK32(pti, poifi32, OLEINPLACEFRAMEINFO *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (poifi32 != NULL)
    {
        poifi16 = FIXVDMPTR(vpoifi16, OIFI16);

        if (SUCCEEDED(dwResult))
        {
            poifi16->cb            = sizeof(OIFI16);
            poifi16->fMDIApp       = (WORD)poifi32->fMDIApp;
            poifi16->hwndFrame     = HWND_16(poifi32->hwndFrame);
            poifi16->cAccelEntries =
                ClampULongToUShort(poifi32->cAccelEntries);

            if (poifi32->haccel == NULL)
            {
                poifi16->haccel = NULL;
            }
            else
            {
                // WOW will clean up any dangling accelerator tables when
                // tasks die
                poifi16->haccel = HACCEL_16(poifi32->haccel);
                if (poifi16->haccel == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
            }

#if DBG == 1
            if (SUCCEEDED(dwResult))
            {
                thkDebugOut((DEB_ARGS, "Out1632 OIFI: "
                             "%p {%d, %d, 0x%p, 0x%p, %d} -> "
                             "%p {%d, %d, 0x%04X, 0x%04X, %d}\n",
                             poifi32, poifi32->cb, poifi32->fMDIApp,
                             poifi32->hwndFrame, poifi32->haccel,
                             poifi32->cAccelEntries,
                             vpoifi16, poifi16->cb, (BOOL)poifi16->fMDIApp,
                             (DWORD)poifi16->hwndFrame, (DWORD)poifi16->haccel,
                             poifi16->cAccelEntries));
            }
#endif
        }

        if (FAILED(dwResult))
        {
            memset(poifi16, 0, sizeof(OIFI16));
        }

        RELVDMPTR(vpoifi16);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STGMEDIUM_1632, public
//
//  Synopsis:   Converts 32-bit STGMEDIUM to 16-bit STGMEDIUM returned
//              structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_STGMEDIUM_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      vpstgmedium16;
    STGMEDIUM   UNALIGNED *lpstgmedium16;
    STGMEDIUM   *lpstgmedium32;
    STGMEDIUM   stgmedium32;
    DWORD       dwSize;
    SCODE       sc;
    BOOL        fReleaseParam;
    SHORT       fTransferOwnership;
    FORMATETC   *pfe;
    THOP        thopFeOffset;
    BOOL        fReversedTYMED_NULL = FALSE;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STGMEDIUM);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We currently don't have any unmodified or inout thops for STGMEDIUMs
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "STGMEDIUM must be input or output only" );

    // +2 thop byte indicates whether there's a FORMATETC to look at
    // or not
    // We need to reference this now before the stack is modified
    // by argument recovery
    thopFeOffset = *(pti->pThop+2);
    if (thopFeOffset > 0)
    {
        INDEX_STACK32(pti, pfe, FORMATETC *, thopFeOffset);
    }
    else
    {
        pfe = NULL;
    }

    GET_STACK16(pti, vpstgmedium16, VPVOID);

    // Next thop byte indicates whether there's an ownership transfer
    // argument or not
    pti->pThop++;
    fReleaseParam = (BOOL)*pti->pThop++;

    if (fReleaseParam)
    {
        GET_STACK16(pti, fTransferOwnership, SHORT);
    }
    else
    {
        fTransferOwnership = FALSE;
    }

    // Skip FORMATETC offset thop
    pti->pThop++;

    lpstgmedium32 = NULL;

    if ( vpstgmedium16 != 0 )
    {
        if ( fThopInput )
        {
            // This code supports GetDataHere() passing TYMED_NULL.  It then
            // behaves like GetData().  This is not per the OLE spec.
            // According to every OLE spec TYMED_NULL is an invalid type in
            // GetDataHere().   But AlexGo says that 16bit inproc servers
            // did support this, especially the Default Handler / Clipboard.

            lpstgmedium16 = (STGMEDIUM FAR *)GetReadPtr16(pti, vpstgmedium16,
                                                           sizeof(STGMEDIUM));

			thkAssert(lpstgmedium16);
			// To fix a prefix bug... vpstgmedium should never be invalid, but
			// if it is, we'll get back NULL, so we'll return E_UNEXPECTED.
			if (lpstgmedium16)
			{
				if (lpstgmedium16->tymed == TYMED_NULL &&
					!fTransferOwnership)
				{
					WOWRELVDMPTR(vpstgmedium16);
					
					memset(&stgmedium32, 0, sizeof(stgmedium32));
					thkAssert( TYMED_NULL == 0 );   // Don't need to set tymed to 0
					
					fThopInput = FALSE;
					fThopOutput = TRUE;
					fReversedTYMED_NULL = TRUE;
				}
				else
				{
					WOWRELVDMPTR(vpstgmedium16);
					
					sc = ConvertStgMed1632(pti, vpstgmedium16, &stgmedium32,
										   pfe, fTransferOwnership, &dwSize);
					if (SUCCEEDED(sc))
					{
						lpstgmedium32 = &stgmedium32;
					}
				}
			} 
			else 
			{
				return E_UNEXPECTED;
			}
        }

        if ( fThopOutput )
        {
            thkAssert( fThopOutput );

            lpstgmedium16 = (STGMEDIUM FAR *)GetWritePtr16(pti, vpstgmedium16,
                                                           sizeof(STGMEDIUM));
            if ( lpstgmedium16 != NULL )
            {
                lpstgmedium32 = &stgmedium32;
                WOWRELVDMPTR(vpstgmedium16);
            }

            // 32->16 sets tymed to TYMED_NULL before passing
            // on the STGMEDIUM because some apps incorrectly check for this
            // I'm assuming this isn't necessary for 16->32 because 32-bit
            // apps can't rely on tymed being NULL since nothing in the 32-bit
            // code sets it that way for out parameters
            // DrewB 5/30
        }
    }

    TO_STACK32(pti, lpstgmedium32, STGMEDIUM FAR *);

    if (fReleaseParam)
    {
        TO_STACK32(pti, (BOOL)fTransferOwnership, BOOL);
    }

    dwResult = EXECUTE_THOP1632(pti);

    if ( lpstgmedium32 != NULL)
    {
        if ( fThopInput )
        {
            if (!fTransferOwnership || FAILED(dwResult))
            {
                sc = CleanStgMed32(pti, lpstgmedium32, vpstgmedium16,
                                   dwSize, TRUE, pfe);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                }
            }
            else if (SUCCEEDED(dwResult))
            {
                lpstgmedium16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                if (lpstgmedium16->pUnkForRelease == NULL)
                {
                    RELVDMPTR(vpstgmedium16);
                    sc = CleanStgMed16(pti, vpstgmedium16, lpstgmedium32,
                                       0, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
                else
                {
                    RELVDMPTR(vpstgmedium16);
                }
            }
        }
        else
        {
            thkAssert( fThopOutput );

            if (SUCCEEDED(dwResult))
            {
                sc = ConvertStgMed3216(pti, lpstgmedium32, vpstgmedium16,
                                       pfe, FALSE, &dwSize);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                    ReleaseStgMedium(lpstgmedium32);
                }
                else if (lpstgmedium32->pUnkForRelease == NULL)
                {
                    sc = CleanStgMed32(pti, lpstgmedium32, vpstgmedium16,
                                       dwSize, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
            }

            // Clear the [out] parameters if the call failed.
            // Unless it had previously been an [in] parameter.
            // We don't want to erase the caller's [in] argument.

            if (FAILED(dwResult) && !fReversedTYMED_NULL)
            {
                lpstgmedium16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                memset(lpstgmedium16, 0, sizeof(STGMEDIUM));
                RELVDMPTR(vpstgmedium16);
            }
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStatStg3216, public
//
//  Synopsis:   Converts a STATSTG
//
//  Arguments:  [pti] - Thunk info
//              [pss32] - STATSTG
//              [vpss16] - STATSTG
//              [vpstrPreAlloc] - Preallocated string memory or NULL
//              [cchPreAlloc] - Amount preallocated
//
//  Returns:    Appropriate status code
//
//  Modifies:   [vpss16]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Assumes input STATSTG memory is valid
//              Assumes task memory for the string
//
//----------------------------------------------------------------------------

SCODE ConvertStatStg3216(THUNKINFO *pti,
                         STATSTG *pss32,
                         VPVOID vpss16,
                         VPSTR vpstrPreAlloc,
                         UINT cchPreAlloc)
{
    STATSTG UNALIGNED *pss16;
    SCODE sc;
    VPSTR vpstr16;

    sc = ConvertTaskString3216(pti, pss32->pwcsName,
                               vpstrPreAlloc, cchPreAlloc,
                               &vpstr16);
    if (SUCCEEDED(sc))
    {
        pss16 = FIXVDMPTR(vpss16, STATSTG);
        memcpy(pss16, pss32, sizeof(STATSTG));
        pss16->pwcsName = (LPOLESTR)vpstr16;
        RELVDMPTR(vpss16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STATSTG_1632, public
//
//  Synopsis:   Converts 32-bit STATSTG to 16-bit STATSTG returned structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_STATSTG_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    VPVOID      vpstatstg16;
    STATSTG UNALIGNED *lpstatstg16;
    VPSTR       vpstr;
    STATSTG     statstg32;
    STATSTG     *lpstatstg32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STATSTG);

    //
    // We currently don't have any input thops for STATSTGs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_OUT &&
               "STATSTG must be output only" );

    GET_STACK16(pti, vpstatstg16, VPVOID);

    lpstatstg32 = NULL;

    lpstatstg16 = (STATSTG FAR *)GetWritePtr16( pti, vpstatstg16,
                                                sizeof(STATSTG) );
    if ( lpstatstg16 != NULL )
    {
        statstg32.pwcsName = NULL;
        lpstatstg32 = &statstg32;

        vpstr = (VPSTR)TaskMalloc16(CBSTRINGPREALLOC);
        if (vpstr == 0)
        {
            pti->scResult = E_OUTOFMEMORY;
        }

        WOWRELVDMPTR(vpstatstg16);
    }

    TO_STACK32(pti, lpstatstg32, STATSTG FAR *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( lpstatstg32 != NULL )
    {
        if ( SUCCEEDED(dwResult) )
        {
            SCODE sc;

            sc = ConvertStatStg3216(pti, &statstg32, vpstatstg16,
                                    vpstr, CWCSTRINGPREALLOC);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            TaskFree16(vpstr);

            lpstatstg16 = FIXVDMPTR(vpstatstg16, STATSTG);
            memset(lpstatstg16, 0, sizeof(STATSTG));
            RELVDMPTR(vpstatstg16);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_DVTARGETDEVICE_1632, public
//
//  Synopsis:   Converts 16-bit DVTARGETDEVICE to 32-bit DVTARGETDEVICE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_DVTARGETDEVICE_1632( THUNKINFO *pti )
{
    DWORD               dwResult;
    UINT                uiSize;
    DVTARGETDEVICE      *lpdv32;
    VPVOID              vpdv16;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_DVTARGETDEVICE);

    //
    // We currently don't have any output thops for DVTARGETDEVICEs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "DVTARGETDEVICE must be input only" );

    //
    // Processing for a DVTARGETDEVICE FAR * as input
    //
    GET_STACK16(pti, vpdv16, VPVOID);

    lpdv32 = NULL;

    if ( vpdv16 != 0 )
    {
        sc = ConvertDvtd1632(pti, vpdv16, ArStack32, FrStack32, &lpdv32,
                             &uiSize);
        if (FAILED(sc))
        {
            pti->scResult = sc;
        }
    }

    TO_STACK32(pti, lpdv32, DVTARGETDEVICE FAR *);
    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (lpdv32 != NULL)
    {
        FrStack32(lpdv32, uiSize);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FORMATETC_1632, public
//
//  Synopsis:   Converts 16-bit FORMATETC to 32-bit FORMATETC and back
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_FORMATETC_1632( THUNKINFO *pti )
{
    DWORD               dwResult;
    BOOL                fThopInput;
    BOOL                fThopOutput;
    VPVOID              vpformatetc16;
    FORMATETC16 UNALIGNED *lpformatetc16;
    LPFORMATETC         lpformatetc32;
    FORMATETC           formatetc32;
    DVTARGETDEVICE      *lpdv32;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FORMATETC);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We have only input and output thops, not both, or neither
    //
    thkAssert( (fThopInput || fThopOutput) &&
            (fThopInput != fThopOutput) &&
               "formatetc must be input or output only" );

    lpdv32 = NULL;

    GET_STACK16(pti, vpformatetc16, VPVOID);

    if ( vpformatetc16 == 0 )
    {
        lpformatetc32 = NULL;
    }
    else
    {
        lpformatetc32 = &formatetc32;

        if ( fThopInput )
        {
            sc = ConvertFetc1632(pti, vpformatetc16, lpformatetc32, FALSE);
            if (FAILED(sc))
            {
                pti->scResult = sc;
            }
        }
        else
        {
            thkAssert( fThopOutput );
            //
            // The below memset is needed at least for the DATA_S_SAMEFORMATETC
            // case.  This allows it to be cleaned up because all its pointers
            // will be null.
            //
            memset( &formatetc32, 0, sizeof(formatetc32) );
            lpformatetc16 = (LPFORMATETC16)GetWritePtr16(pti, vpformatetc16,
                                                         sizeof(FORMATETC16));
            WOWRELVDMPTR(vpformatetc16);
        }
    }

    TO_STACK32(pti, lpformatetc32, LPFORMATETC);
    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( fThopInput )
    {
        if (lpformatetc32 != NULL && lpformatetc32->ptd != NULL)
        {
            TaskFree32(lpformatetc32->ptd);
        }
    }

    if ( fThopOutput && vpformatetc16 != NULL)
    {
        if (SUCCEEDED(dwResult))
        {
            sc = ConvertFetc3216(pti, lpformatetc32, vpformatetc16, TRUE);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            lpformatetc16 = FIXVDMPTR(vpformatetc16, FORMATETC16);
            memset(lpformatetc16, 0, sizeof(FORMATETC16));
            RELVDMPTR(vpformatetc16);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LOGPALETTE_1632, public
//
//  Synopsis:   Converts 16-bit LOGPALLETE to 32-bit LOGPALETTE
//              and converts 32-bit LOGPALETTE returned to 16-bit structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LOGPALETTE_1632 ( THUNKINFO *pti )
{
    DWORD         dwResult;
    UINT          uiSize;
    LPLOGPALETTE  lplogpal32;
    VPVOID        vplogpal16;
    LOGPALETTE UNALIGNED *lplogpal16;
    VPVOID        vp16;
    LPVOID UNALIGNED *lp16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LOGPALETTE);

    //
    // It must be either an input or output LOGPALETTE
    //
    thkAssert( ((*pti->pThop & THOP_IOMASK) == THOP_IN ||
                (*pti->pThop & THOP_IOMASK) == THOP_OUT) &&
               "Hey, LOGPALETTE can't be input and output!" );

    lplogpal32 = NULL;

    if ( (*pti->pThop & THOP_IN) != 0 )
    {
        //
        // Processing for a LPLOGPALETTE as input
        //
        GET_STACK16(pti, vplogpal16, VPVOID);

        if ( vplogpal16 != 0 )
        {
            // Copy over the input LOGPALETTE structure
            lplogpal16 = (LPLOGPALETTE)GetReadPtr16( pti, vplogpal16,
                                                     sizeof(LOGPALETTE) );

            if ( lplogpal16 != NULL )
            {
                uiSize = CBPALETTE(lplogpal16->palNumEntries);

                WOWRELVDMPTR(vplogpal16);

                lplogpal16 = (LPLOGPALETTE)GetReadPtr16(pti, vplogpal16,
                                                        uiSize);
                if ( lplogpal16 != NULL )
                {
                    lplogpal32 = (LPLOGPALETTE)CoTaskMemAlloc(uiSize);
                    if ( lplogpal32 == NULL )
                    {
                        pti->scResult = E_OUTOFMEMORY;
                    }
                    else
                    {
                        memcpy( lplogpal32, lplogpal16, uiSize );
                    }

                    WOWRELVDMPTR(vplogpal16);
                }
            }
        }

        TO_STACK32(pti, lplogpal32, LPLOGPALETTE);
        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);

        if ( lplogpal32 )
        {
            CoTaskMemFree( lplogpal32 );
        }
    }
    else
    {
        //
        // Processing for LPLPLOGPALETTE as output
        //

        thkAssert((*pti->pThop & THOP_OUT) != 0);

        GET_STACK16(pti, vp16, VPVOID);

        vplogpal16 = (VPVOID)TaskMalloc16(CBPALETTE(NPALETTEPREALLOC));
        if (vplogpal16 == 0)
        {
            pti->scResult = E_OUTOFMEMORY;
        }

        TO_STACK32(pti, &lplogpal32, LPLOGPALETTE *);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);

        if ( SUCCEEDED(dwResult) && lplogpal32 != NULL )
        {
            //
            // Copy the returned LOGPALETTE into 16-bit memory
            //
            uiSize = CBPALETTE(lplogpal32->palNumEntries);
            if (uiSize > CBPALETTE(NPALETTEPREALLOC))
            {
                TaskFree16(vplogpal16);
                vplogpal16 = (VPVOID)TaskMalloc16(uiSize);
                if ( vplogpal16 == 0 )
                {
                    dwResult = (DWORD)E_OUTOFMEMORY;
                }
            }

            if (vplogpal16 != 0)
            {
                lplogpal16 = (LPLOGPALETTE)WOWFIXVDMPTR(vplogpal16, uiSize);
                if ( lplogpal16 == NULL )
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                    vplogpal16 = 0;
                }
                else
                {
                    memcpy( lplogpal16, lplogpal32, uiSize );

                    WOWRELVDMPTR(vplogpal16);
                }
            }

            TaskFree32( lplogpal32 );
        }
        else
        {
            TaskFree16(vplogpal16);
            vplogpal16 = 0;
        }

        //
        // Update the value pointed to by the parameter on the 16-bit stack
        //
        lp16 = FIXVDMPTR(vp16, LPVOID);
        if ( lp16 == NULL )
        {
            dwResult = (DWORD)E_UNEXPECTED;
        }
        else
        {
            *lp16 = (LPVOID)vplogpal16;
            RELVDMPTR(vp16);
        }
    }
    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CRGIID_1632, public
//
//  Synopsis:   Converts 16-bit CRGIID to 32-bit CRGIID structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_CRGIID_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    DWORD       dwCount;
    VPVOID      vpiid16;
    IID UNALIGNED *lpiid16;
    IID         *lpiid32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CRGIID);

    //
    // We currently don't have any output thops for CRGIIDs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "CRGIID must be unmodified only" );

    GET_STACK16(pti, dwCount, DWORD);
    GET_STACK16(pti, vpiid16, VPVOID);

    lpiid32 = NULL;

    if ( vpiid16 != 0 )
    {
        lpiid16 = (IID UNALIGNED *)GetReadPtr16( pti, vpiid16,
                                                 dwCount*sizeof(IID) );
        if ( lpiid16 != NULL )
        {
            lpiid32 = (IID FAR *)CoTaskMemAlloc( dwCount * sizeof(IID) );
            if ( lpiid32 == NULL )
            {
                pti->scResult = E_OUTOFMEMORY;
            }
            else
            {
                memcpy( lpiid32, lpiid16, dwCount*sizeof(IID) );
            }

            WOWRELVDMPTR(vpiid16);
        }
    }

    TO_STACK32(pti, dwCount, DWORD);
    TO_STACK32(pti, lpiid32, IID FAR *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( lpiid32 != NULL )
    {
        CoTaskMemFree( lpiid32 );
    }
    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_INTERFACEINFO_1632, public
//
//  Synopsis:   Converts an INTERFACEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    19-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_INTERFACEINFO_1632(THUNKINFO *pti)
{
    INTERFACEINFO *pii32;
    INTERFACEINFO ii32;
    INTERFACEINFO16 UNALIGNED *pii16;
    VPVOID vpii16;
    DWORD dwResult;
    IUnknown *punk32;
    VPVOID vpvUnk16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_INTERFACEINFO);
    thkAssert((*pti->pThop & THOP_INOUT) == THOP_IN);

    pii32 = NULL;
    punk32 = NULL;

    GET_STACK16(pti, vpii16, VPVOID);
    if (vpii16 != 0)
    {
        pii16 = (INTERFACEINFO16 UNALIGNED *)
            GetReadPtr16(pti, vpii16, sizeof(INTERFACEINFO16));
        if (pii16 != NULL)
        {
            if (pii16->pUnk != NULL)
            {
                vpvUnk16 = pii16->pUnk;

                WOWRELVDMPTR(vpii16);

                punk32 =
                    pti->pThkMgr->FindProxy3216(NULL, vpvUnk16, NULL,
                                                INDEX_IIDIDX(THI_IUnknown),
                                                FALSE, NULL);
                if (punk32 == NULL)
                {
                    pti->scResult = E_OUTOFMEMORY;
                }

                pii16 = FIXVDMPTR(vpii16, INTERFACEINFO16);
            }

            pii32 = &ii32;
            pii32->pUnk = punk32;
            pii32->iid = pii16->iid;
            pii32->wMethod = pii16->wMethod;

            WOWRELVDMPTR(vpii16);

            thkDebugOut((DEB_ARGS,
                         "In1632  INTERFACEINFO: %p -> %p {%p (%p), %s, %u}\n",
                         vpii16, pii32, pii32->pUnk, pii16->pUnk,
                         IidOrInterfaceString(&pii32->iid), pii32->wMethod));
        }
    }

    TO_STACK32(pti, pii32, INTERFACEINFO *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if(punk32) {        
        // Release the 32-bit interface as it is an IN parameter
        punk32->Release();
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RETURNTYPE_1632, public
//
//  Synopsis:   Thunks the return value of a call
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//  Notes:      This thunk assumes that the return value will always fit
//              in 32 bits and that the thops for it are only one thop
//              long.  This fits the existing APIs and methods
//
//----------------------------------------------------------------------------

DWORD Thop_RETURNTYPE_1632(THUNKINFO *pti)
{
    THOP thops[2];
    DWORD dwResult;
    ALIAS alias;
    VPVOID vpvPreAlloc = NULL;
    IIDIDX iidx;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RETURNTYPE);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->fResultThunked = TRUE;

    pti->pThop++;

    // Remember return type thop
    thops[0] = *pti->pThop++;
    if ((thops[0] & THOP_OPMASK) == THOP_COPY ||
        (thops[0] & THOP_OPMASK) == THOP_IFACE ||
        (thops[0] & THOP_OPMASK) == THOP_ALIAS32)
    {
        thops[1] = *pti->pThop++;
    }

    // Preallocate any necessary resources
    switch(thops[0])
    {
    case THOP_IFACE | THOP_IN:
        iidx = INDEX_IIDIDX(thops[1]);
        if ((vpvPreAlloc =
             pti->pThkMgr->CanGetNewProxy1632(iidx)) == NULL)
        {
            pti->scResult = E_OUTOFMEMORY;
        }
        break;

    case THOP_ALIAS32:
        thkAssert(thops[1] == ALIAS_CREATE);

        // The value used for preallocation doesn't really matter
        // as long as it's unique and not INVALID_VALUE
        // In our case we know that we won't have to deal with nested
        // preallocations so uniqueness is not as much of an issue
        // By using INVALID_HANDLE_VALUE, we can be sure that there
        // won't already be an entry with that value already in the
        // alias table since we're aliasing handles
        alias = gAliases32.AddValue((DWORD)INVALID_HANDLE_VALUE);
        if (alias == INVALID_ALIAS)
        {
            pti->scResult = E_OUTOFMEMORY;
        }
        break;
    }

    dwResult = EXECUTE_THOP1632(pti);

    // Now that we have the return value thunk it from 32->16
    // We must use pti->scResult to check for failure rather than
    // dwResult because dwResult may not be an SCODE

    switch(thops[0])
    {
    case THOP_COPY:
        // Only handle DWORD copies
        thkAssert(thops[1] == sizeof(DWORD));
        break;

    case THOP_SHORTLONG:
        // For boolean results, not necessary to clamp
        dwResult = (DWORD)(SHORT)*(LONG *)&dwResult;
        break;

    case THOP_IFACE | THOP_IN:
        // Thunking an interface as a return value is completly broken
        // First, such an interface needs to be thunked as an OUT parameter
        // which I am fixing below. Second, the IID of the interface being
        // thunked needs to be in the THOP string for proper thunking of
        // interface. The only known case where an interface is returned
        // is IRpcStubBuffer::IsIIDSupported() and the interface returned
        // is of type IRpcStubBuffer, not IUnknown. As this method is not
        // used in the curremt COM code, I am not changing THOP strings
        // to reflect the IID of the interface being thunked
        //            Gopalk     Mar 27, 97
        if (dwResult != 0)
        {
            if (FAILED(pti->scResult))
            {
                dwResult = 0;
            }
            else
            {
                IUnknown *punk = (IUnknown *) dwResult;
                dwResult =
                    (DWORD)pti->pThkMgr->FindProxy1632(vpvPreAlloc,
                                                       (IUnknown *)dwResult, NULL,
                                                       iidx, NULL);
                
                // Release actual interface as it is an OUT parameter
                // This could be the last release on the interface if the
                // above call failed;
                punk->Release();
                thkAssert(dwResult);

                thkDebugOut((DEB_ARGS, "Ret1632 %s %p\n",
                             inInterfaceNames[thops[1]].pszInterface,
                             dwResult));
            }
        }
        else
        {
            pti->pThkMgr->FreeNewProxy1632(vpvPreAlloc, iidx);
        }
        break;

    case THOP_ALIAS32:
        if (dwResult != 0)
        {
            if (FAILED(pti->scResult))
            {
                dwResult = 0;
            }
            else
            {
                gAliases32.SetValue(alias, dwResult);

                thkDebugOut((DEB_ARGS, "Ret1632 ALIAS32: 0x%08lX -> 0x%04lX\n",
                             dwResult, alias));

                dwResult = (DWORD)alias;
            }
        }
        break;

    default:
        thkAssert(!"Unhandled 1632 return type");
        break;
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACE_1632, public
//
//  Synopsis:   Thunks a known interface pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACE_1632(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    IUnknown *punkOuter;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(   thopOp == THOP_IFACE
              || thopOp == THOP_IFACEOWNER
              || thopOp == THOP_IFACENOADDREF
              || thopOp == THOP_UNKOUTER);

    iidx = INDEX_IIDIDX(*pti->pThop++);

    // There's a bit of a special case here in that IMalloc is
    // not thunked so it doesn't have a real index but it's used
    // in thop strings so it has a fake index to function as a placeholder
    // The fake index is THI_COUNT so allow that in the assert
    thkAssert(IIDIDX_INDEX(iidx) >= 0 && IIDIDX_INDEX(iidx) <= THI_COUNT);
    thkAssert(thopOp != THOP_UNKOUTER || iidx == THI_IUnknown);

    punkOuter = NULL;
    if (   thopOp == THOP_IFACEOWNER
        || thopOp == THOP_IFACENOADDREF)
    {
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK32(pti, punkOuter, IUnknown *, thopWeakOffset);
        if(punkOuter && (thopOp==THOP_IFACEOWNER)) {
            // Aggregation across 16-32 boundary
            // Assert invariants
            thkAssert(iidx == THI_IRpcProxyBuffer || iidx == THI_IRpcProxy);
            // Change thop to indicate that inner unknown is being thunked
            thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface1632(pti, iidx, thop, punkOuter);
}

typedef struct tagOLESTREAMOBJECT
{
    OLESTREAM   os;
    VPVOID      vpolestream16;
} OLESTREAMOBJECT, FAR * LPOLESTREAMOBJECT;

#define OLESTREAM_GET 0
#define OLESTREAM_PUT 1


//+---------------------------------------------------------------------------
//
//  Function:   OLESTREAM_Callback, private
//
//  Synopsis:   Handles callbacks into 16-bit world for OLESTREAM methods
//
//  Arguments:  [dwMethod] - Index of method to invoke
//              [lposo]    - Pointer to 32 LPOLESTREAM
//              [lpv]      - Pointer to 32 bit buffer
//              [dwCount]  - Size of 32 bit buffer
//
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//              29-May-94   TerryRu Converted to call WOWCallBackEx directly.
//
//----------------------------------------------------------------------------

DWORD OLESTREAM_Callback( DWORD dwMethod,
                          LPOLESTREAM lpos,
                          LPVOID lpv,
                          DWORD dwCount )
{
    const DWORD             cbStack     = sizeof( DWORD ) +
        sizeof( VPVOID ) + sizeof( VPVOID );

    BYTE                    b32Args[cbStack];
    DWORD                   dwResult;

    VPVOID                  vpvVtbl16;
    VTBLFN                  vpfn16;

    VPVOID                  vpolestream16;
    LPOLESTREAMOBJECT       lposo;

    VPVOID                  vp16;
    LPVOID                  lp16;


    lposo = (LPOLESTREAMOBJECT)lpos;
    vpolestream16 = lposo->vpolestream16;

    // Get pointer to 16 bit this pointer

    vpvVtbl16 =  (VPVOID)*FIXVDMPTR( vpolestream16,  VPVOID );
    RELVDMPTR(vpolestream16);
    vpfn16    =  (VTBLFN)*FIXVDMPTR( vpvVtbl16+dwMethod*sizeof(VPVOID),
                                     VPVOID );
    RELVDMPTR(vpvVtbl16+dwMethod*sizeof(VPVOID));

    //
    // now thop the  IN 32 bit-block of memory to 16 bit block
    //

    vp16 = WgtAllocLock( GMEM_MOVEABLE, dwCount, NULL );
    if ( vp16 == NULL )
    {
        return (DWORD) E_OUTOFMEMORY;
    }

    if ( dwMethod == OLESTREAM_PUT )
    {
        lp16 = WOWFIXVDMPTR( vp16, dwCount );
        memcpy( lp16, lpv, dwCount );
        WOWRELVDMPTR(vp16);
    }

    // setup 32 bit arguements.
    *(DWORD *)(b32Args)             = dwCount;
    *(VPVOID *)(b32Args+4)          = vp16;
    *(VPVOID *)(b32Args+8)          = vpolestream16;

    if ( !CallbackTo16Ex( (DWORD)vpfn16, WCB16_PASCAL, cbStack, b32Args,
                         &dwResult) )
    {
        dwResult = (DWORD)E_UNEXPECTED;
    }

    if ( dwMethod == OLESTREAM_GET )
    {

        lp16 = WOWFIXVDMPTR( vp16, dwCount );
        memcpy( (LPVOID) lpv, lp16, dwCount );
        WOWRELVDMPTR(vp16);

    }

    WgtUnlockFree(vp16);

    thkDebugOut((DEB_INVOKES, "OLESTREAM_Callback returns 0x%08lX\n",
                 dwResult));

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESTREAM_Get_Proxy, private
//
//  Synopsis:   Handles callbacks into 16-bit world for OLESTREAM::Get
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//              29-May-94   TerryRu Now calls OLESTREAM::Get using Pascal
//                                  calling conventions.
//
//----------------------------------------------------------------------------

DWORD OLESTREAM_Get_Proxy(
    LPOLESTREAM lpos,
    void FAR *  lpv,
    DWORD       dwCount
)
{
    return OLESTREAM_Callback( OLESTREAM_GET, lpos, lpv, dwCount );
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESTREAM_Put_Proxy, private
//
//  Synopsis:   Handles callbacks into 16-bit world for OLESTREAM::Put
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//              29-May-94   TerryRu Now call OLESTREAM::Put using pascal
//              calling conventions.
//
//----------------------------------------------------------------------------

DWORD OLESTREAM_Put_Proxy(
    LPOLESTREAM lpos,
    const void FAR* lpv,
    DWORD       dwCount
)
{
    return OLESTREAM_Callback( OLESTREAM_PUT, lpos,(LPVOID) lpv, dwCount );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_OLESTREAM_1632, public
//
//  Synopsis:   Thunks an OLESTREAM parameter from 16-bit to 32-bit
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    14-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

_OLESTREAMVTBL osVtbl =
{
    OLESTREAM_Get_Proxy,
    OLESTREAM_Put_Proxy
};

DWORD Thop_OLESTREAM_1632(THUNKINFO *pti)
{
    OLESTREAMOBJECT osObject;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_OLESTREAM);

    //
    // Ignore the THOP_INPUT/THOP_OUTPUT, it is always just an interface
    //

    osObject.os.lpstbl = &osVtbl;
    GET_STACK16(pti, osObject.vpolestream16, VPVOID);

    TO_STACK32(pti, &osObject, LPOLESTREAMOBJECT );

    pti->pThop++;
    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RPCOLEMESSAGE_1632, public
//
//  Synopsis:   Converts 16-bit RPCOLEMESSAGE to 32-bit RPCOLEMESSAGE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//      28-May-94       JohannP Rewritten
//      13-Aug-94       Rickhi  made it work for GetBuffer when the
//                              buffer size grows, commented better
//
//  CODEWORK:   this routine is inefficient. since it cant tell why it was
//      called (GetBuffer/SendReceive/Invoke/FreeBuffer) it always
//      copies the data, when it only really needs to in Invoke and
//      in SendReceive.
//
//  Context: This routine will "Thop" a client side RPCOLEMESSGE (aka "rom")
//      three times.  The first time for the "getbuffer" call, the second
//      time for the "SendRecieve", and the third time for the "freebuffer".
//      This make it confusing, some calls allocate a buffer but don't
//      free it.  Other calls free a buffer they didn't allocate.  A good
//      way to see what is happening is to step through several calls to
//      this routine with a debugger and note the pointer values.
//
//----------------------------------------------------------------------------
DWORD Thop_RPCOLEMESSAGE_1632( THUNKINFO *pti )
{
    DWORD           dwResult;
    PRPCOLEMESSAGE  prom32;
    VPVOID          vprom16;
    RPCOLEMESSAGE UNALIGNED *prom16;
    LPVOID          lp16;
    RPCOLEMESSAGE   rom32;
    BOOL            fAllocNew = FALSE;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RPCOLEMESSAGE);

    //
    // We currently have only INOUT RPCOLEMESSAGE
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == (THOP_IN | THOP_OUT) &&
               "RPCOLEMESSAGE must be input/output only" );

    //
    // Processing for a RPCOLEMESSAGE FAR * as input/output
    //
    GET_STACK16(pti, vprom16, VPVOID);

    prom32 = NULL;
    if ( vprom16 != 0 )
    {
        // Copy over the input RPCOLEMESSAGE structure
        prom16 = (RPCOLEMESSAGE UNALIGNED *)
            GetReadWritePtr16( pti, vprom16, sizeof(RPCOLEMESSAGE) );
        if ( prom16 != NULL )
        {
            // Note: ROM_THUNK_FIELD(prom) holds the pointer to the 32 bit rom
            //        in case the buffer is not NULL

            // Note: this assert is not valid when a fault happens on the
            //        server side. In that case, the return buffer is NULLed
            //        by the 16bit stub but the THUNK_FIELD is non-null.

            //thkAssert((prom16->Buffer == NULL &&
            //           ROM_THUNK_FIELD(prom16) == NULL) ||
            //          (prom16->Buffer != NULL &&
            //           ROM_THUNK_FIELD(prom16) != NULL));

            if (prom16->Buffer != NULL)
            {
                prom32 = (RPCOLEMESSAGE *)ROM_THUNK_FIELD(prom16);

                if ( prom32->Buffer != NULL )
                {
                    // we use the min size of the two buffers because when
                    // the stub (server side) calls GetBuffer he is supplying
                    // the old pBuffer with the new (and potentially larger)
                    // cbBuffer

                    DWORD cbSizeMin = (prom16->cbBuffer <= prom32->cbBuffer) ?
                        prom16->cbBuffer :  prom32->cbBuffer;

                    lp16 = (LPVOID)GetReadPtr16(pti,
                                                (VPVOID)prom16->Buffer,
                                                cbSizeMin);
                    if (lp16 == NULL)
                    {
                        prom32 = NULL;
                    }
                    else
                    {
                        memcpy( prom32->Buffer, lp16, prom32->cbBuffer );
                        WOWRELVDMPTR((VPVOID)prom16->Buffer);
                    }
                }

				if (prom32)
				{
					// the stub might be asking for a larger buffer for output
					// parameters than it was given for input parameters. We have
					// to figure that out here by comparing the 16bit size with
					// the 32bit size.

					fAllocNew = (prom32->cbBuffer < prom16->cbBuffer);
					prom32->cbBuffer = prom16->cbBuffer;
				}
				else
				{
					fAllocNew = FALSE;
				}
            }
            else
            {
                rom32 = *prom16;
                prom32 = &rom32;
            }

            WOWRELVDMPTR(vprom16);
        }
    }

    TO_STACK32(pti, prom32, PRPCOLEMESSAGE);
    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( prom32 != NULL )
    {
        prom16 = (RPCOLEMESSAGE UNALIGNED *)
            GetReadWritePtr16( pti, vprom16, sizeof(RPCOLEMESSAGE) );
        if ( prom16 == NULL )
        {
            dwResult = (DWORD)E_UNEXPECTED;
        }
        else
        {
            if (SUCCEEDED(dwResult))
            {
                if (prom32->Buffer == NULL)
                {
                    //  RELEASE THE BUFFER AND ROM:
                    // Free the 16 bit buffer, copy the 32 bit rom into
                    // the 16 bit rom and free the 32bit rom, if it was
                    // allocated
                    //
                    if (prom16->Buffer != 0)
                    {
                        TaskFree16((VPVOID)prom16->Buffer);
                    }

                    *prom16 = *prom32;

                    if (prom32 != &rom32)
                    {
                        TaskFree32(prom32);
                        prom32 = NULL;
                    }
                    ROM_THUNK_FIELD(prom16) = NULL;
                }
                else
                {
                    // ALLOCATE AND/OR COPYBACK THE BUFFER AND ROM:
                    RPCOLEMESSAGE *pr32;
                    LPVOID pBuffer;

                    // Create a message to save the 32-bit message in
                    // Use the existing one in the thunk field if we can
                    if (ROM_THUNK_FIELD(prom16) == NULL)
                    {
                        pr32 = (RPCOLEMESSAGE *)
                            TaskMalloc32(sizeof(RPCOLEMESSAGE));
                    }
                    else
                    {
                        pr32 = (RPCOLEMESSAGE *)ROM_THUNK_FIELD(prom16);
                    }
                    *pr32 = *prom32;

                    //
                    // Allocate an output buffer and copy the buffer back
                    //
                    if (   (prom16->Buffer == NULL)
                        || (prom16->cbBuffer < prom32->cbBuffer)
                        || fAllocNew)
                    {
                        if (prom16->Buffer != NULL)
                        {
                            TaskFree16((VPVOID) prom16->Buffer);
                        }

                        pBuffer = (LPVOID)TaskMalloc16(prom32->cbBuffer );
                    }
                    else
                    {
                        pBuffer = prom16->Buffer;
                    }

                    *prom16 = *prom32;
                    prom16->Buffer = pBuffer;
                    ROM_THUNK_FIELD(prom16) = pr32;

                    if (prom16->Buffer == NULL)
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                    else
                    {
                        lp16 = (LPVOID)GetReadPtr16(pti,
                                                    (VPVOID)prom16->Buffer,
                                                    prom16->cbBuffer);
                        if ( lp16 == NULL )
                        {
                            dwResult = (DWORD)E_UNEXPECTED;
                        }
                        else
                        {
                            memcpy( lp16, prom32->Buffer,
                                    prom32->cbBuffer );
                            WOWRELVDMPTR((VPVOID)prom16->Buffer);
                        }
                    }
                }
            }

            WOWRELVDMPTR(vprom16);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ALIAS32_1632, public
//
//  Synopsis:   Handles 16-bit aliases to 32-bit quantities
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    27-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_ALIAS32_1632(THUNKINFO *pti)
{
    ALIAS alias;
    DWORD dwValue;
    THOP thopAction;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ALIAS32);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->pThop++;

    GET_STACK16(pti, alias, ALIAS);

    // Second byte indicates how the alias should be handled
    thopAction = *pti->pThop++;

    if (alias != 0)
    {
        switch(thopAction)
        {
        case ALIAS_RESOLVE:
            dwValue = gAliases32.AliasValue(alias);
            break;

        case ALIAS_REMOVE:
            dwValue = gAliases32.AliasValue(alias);
            gAliases32.RemoveAlias(alias);
            break;

        default:
            thkAssert(!"Default hit in Thop_ALIAS32_1632");
			dwValue = 0;
            break;
        }
    }
    else
    {
        dwValue = 0;
    }

    thkDebugOut((DEB_ARGS, "In1632  ALIAS32: 0x%04X -> 0x%08lX\n",
                 alias, dwValue));

    TO_STACK32(pti, dwValue, DWORD);

    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ENUM_1632, public
//
//  Synopsis:   Thunks Enum::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is the start of a 2-byte thop.  The next thop
//              byte references a function in the enumerator table, rather
//              than the standard thop table.
//
//----------------------------------------------------------------------------

DWORD Thop_ENUM_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ENUM);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    //
    // Get then next thop byte and execute it as a Enum thop
    //
    pti->pThop++;
    return EXECUTE_ENUMTHOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallbackProcessing_1632, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
typedef struct tagCallbackControl
{
    DWORD   dwContinue;
    VPVOID  vpfn16;
} CALLBACKCONTROL;

BOOL CallbackProcessing_1632( DWORD dwContinue )
{
    DWORD           dwResult;
    CALLBACKCONTROL *lpcbc;

    lpcbc = (CALLBACKCONTROL *)dwContinue;

    // The callback function must be FAR PASCAL
    // It's declared CALLBACK in the methods so this is ensured
    dwResult = CallbackTo16( lpcbc->vpfn16, lpcbc->dwContinue );

    return (BOOL)((WORD)dwResult);  // Ignore HIWORD
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CALLBACK_1632, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_CALLBACK_1632(THUNKINFO *pti)
{
    VPVOID          vpfn16;
    DWORD           dwContinue;
    CALLBACKCONTROL cbc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CALLBACK);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    GET_STACK16(pti, vpfn16, VPVOID);
    GET_STACK16(pti, dwContinue, DWORD);

    if ( vpfn16 == 0 )
    {
        TO_STACK32(pti, NULL, LPVOID);
        TO_STACK32(pti, dwContinue, DWORD);
    }
    else
    {
        cbc.vpfn16     = vpfn16;
        cbc.dwContinue = dwContinue;

        TO_STACK32(pti, CallbackProcessing_1632, LPVOID);
        TO_STACK32(pti, (DWORD)&cbc, DWORD);
    }

    pti->pThop++;
    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CLSCONTEXT_1632, public
//
//  Synopsis:   Converts a class context flags DWORD
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_CLSCONTEXT_1632(THUNKINFO *pti)
{
    DWORD dwClsContext;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CLSCONTEXT);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    GET_STACK16(pti, dwClsContext, DWORD);

    // When passing a 16-bit class context on to 32-bits,
    // add on a flag to indicate that this is a 16-bit request
    // in the inproc server case

    if (dwClsContext & CLSCTX_INPROC_SERVER)
    {
        dwClsContext |= CLSCTX_INPROC_SERVER16;
    }

    TO_STACK32(pti, dwClsContext, DWORD);

    pti->pThop++;
    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FILENAME_1632, public
//
//  Synopsis:   Converts a filename string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_FILENAME_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FILENAME);

    // Can be in or out only
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN ||
              (*pti->pThop & THOP_IOMASK) == THOP_OUT);

    if ((*pti->pThop & THOP_IN) != 0)
    {
        // No special processing is necessary for filenames going
        // from 16->32 since it isn't possible for 16-bit code to
        // generate a filename which can't be handled in 32-bits

        return ThunkInString1632(pti);
    }
    else
    {
        thkAssert((*pti->pThop & THOP_OUT) != 0);

        // Convert filenames going from 32->16 to short filenames
        // to avoid any possible problems with non-8.3 names.

        return ThunkOutString1632(pti, TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SIZEDSTRING_1632, public
//
//  Synopsis:   Converts strings which cannot exceed a given length
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    02-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_SIZEDSTRING_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZEDSTRING);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN);

    // For 16->32, there are no limits on string length so
    // thunk the string normally

    // Advance once to account for the length byte
    // ThunkInString will advance again

    pti->pThop++;
    return ThunkInString1632(pti);
}

#define THOP_FN(x)  Thop_ ## x ## _1632

DWORD (*CONST aThopFunctions1632[])(THUNKINFO *) =
{

                                // x = Implemented
                                // ? = Mysteriously not needed
                                //   = Left to do
                                //
                                // ^
                                // |
                                // +===+
                                //     |
                                //     v
                                //
    ThunkCall1632,                  // x Terminating THOP
    Thop_ShortToLong_1632,          // x SHORTLONG
    Thop_WordToDword_1632,          // x WORDDWORD
    Thop_Copy_1632,                 // x COPY
    THOP_FN(LPSTR),                 // x LPSTR
    THOP_FN(LPLPSTR),               // x LPLPSTR
    THOP_FN(BUFFER),                // x BUFFER
    Thop_UserHandle_1632,           // x HUSER
    Thop_GdiHandle_1632,            // x HGDI
    THOP_FN(SIZE),                  // x SIZE
    THOP_FN(RECT),                  // x RECT
    THOP_FN(MSG),                   // x MSG
    THOP_FN(HRESULT),               // x HRESULT
    THOP_FN(STATSTG),               // x STATSTG
    THOP_FN(DVTARGETDEVICE),        // x DVTARGETDEVICE
    THOP_FN(STGMEDIUM),             // x STGMEDIUM
    THOP_FN(FORMATETC),             // x FORMATETC
    THOP_FN(HACCEL),                // x HACCEL
    THOP_FN(OIFI),                  // x OLEINPLACEFRAMEINFO
    THOP_FN(BINDOPTS),              // x BIND_OPTS
    THOP_FN(LOGPALETTE),            // x LOGPALETTE
    THOP_FN(SNB),                   // x SNB
    THOP_FN(CRGIID),                // x CRGIID
    THOP_FN(OLESTREAM),             // x OLESTREAM
    THOP_FN(HTASK),                 // x HTASK
    THOP_FN(INTERFACEINFO),         // x INTERFACEINFO
    THOP_FN(IFACE),                 // x IFACE
    THOP_FN(IFACE),                 // x IFACEOWNER
    THOP_FN(IFACE),                 // x IFACENOADDREF
    Thop_ERROR_1632,                // x IFACECLEAN
    THOP_FN(IFACEGEN),              // x IFACEGEN
    THOP_FN(IFACEGEN),              // x IFACEGENOWNER
    THOP_FN(IFACE),                 // x UNKOUTER
    Thop_ERROR_1632,                // x UNKINNER
    Thop_ERROR_1632,                // x ROUTINE_INDEX
    THOP_FN(RETURNTYPE),            // x RETURN_TYPE
    THOP_FN(NULL),                  // x NULL
    Thop_ERROR_1632,                // x ERROR
    THOP_FN(ENUM),                  // x ENUM
    THOP_FN(CALLBACK),              // x CALLBACK
    THOP_FN(RPCOLEMESSAGE),         // x RPCOLEMESSAGE
    THOP_FN(ALIAS32),               // x ALIAS32
    THOP_FN(CLSCONTEXT),            // x CLSCONTEXT
    THOP_FN(FILENAME),              // x FILENAME
    THOP_FN(SIZEDSTRING),           // x SIZEDSTRING
};

//+---------------------------------------------------------------------------
//
//  Function:   General_Enum_1632, private
//
//  Synopsis:   Thunking for standard OLE enumerator interface ::Next member
//              function.
//
//  Arguments:  [pti] - Thunk state information
//              [uiSize32] - 32-bit information size
//              [uiSize16] - 16-bit information size
//              [pfnCallback] - Data thunking callback
//              [pfnCleanup] - Thunking cleanup
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This handler is called from many IXXXEnum::Next handlers thop
//              thunks to do the standard sorts of "buffer of structures"
//              processing.
//
//----------------------------------------------------------------------------
#define MAX_ALLOCA_STRUCT   10

DWORD General_Enum_1632(
    THUNKINFO   *pti,
    UINT        uiSize32,
    UINT        uiSize16,
    SCODE       (*pfnCallback)( THUNKINFO *, LPVOID, VPVOID),
    void        (*pfnCleanup)( THUNKINFO *, LPVOID, VPVOID)   )
{
    DWORD       dwResult;
    ULONG       ulCount;
    VPVOID      vpstruct16;
    VPVOID      vpfetched16;
    LPVOID      lpstruct32;
    LPVOID      lpstruct32Iterate;
    VPVOID      vpstruct16Iterate;
    ULONG       ulFetched32;
    ULONG       *lpfetched32;
    ULONG UNALIGNED *lpfetched16;
    ULONG       ulIterate;
    LPVOID      lp16;
    BOOL        fError;
    SCODE       sc;

    dwResult = (DWORD)S_OK;

    GET_STACK16(pti, ulCount, ULONG );
    GET_STACK16(pti, vpstruct16, VPVOID );
    GET_STACK16(pti, vpfetched16, VPVOID );

    //
    // THIS ROUTINE CAN DEAL WITH dwResult RATHER THAN pti->scResult BECAUSE
    // WE KNOW THIS IS THE ONLY THOP FOR THIS FUNCTION!  NO OTHER CLEANUP
    // WILL HAVE TO BE DONE!
    //
    ulFetched32 = 0;
    lpfetched32 = &ulFetched32;
    lp16 = NULL;
    lpstruct32 = NULL;

    if ( vpstruct16 != 0 )
    {
        if ( ulCount == 0 )
        {
            dwResult = (DWORD)E_INVALIDARG;
        }
        else
        {
            //
            // Verify we have write access to the 16-bit memory.
            //
            lp16 = GetWritePtr16(pti, vpstruct16, uiSize16*ulCount);
            if ( lp16 == NULL )
            {
                dwResult = (DWORD)E_INVALIDARG;
            }
            else
            {
                if ( ulCount > MAX_ALLOCA_STRUCT )
                {
                    lpstruct32 = (LPVOID)CoTaskMemAlloc( ulCount * uiSize32 );
                    if (lpstruct32 == NULL)
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                }
                else
                {
                    lpstruct32 = (LPVOID)STACKALLOC32( ulCount * uiSize32 );
                    if (lpstruct32 == NULL)
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                }

                WOWRELVDMPTR(vpstruct16);
            }
        }
    }

    if (SUCCEEDED(dwResult))
    {
        TO_STACK32(pti, ulCount, ULONG);
        TO_STACK32(pti, lpstruct32, LPVOID);
        TO_STACK32(pti, lpfetched32, ULONG FAR *);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);
    }

    if ( SUCCEEDED(dwResult) )
    {
        if ( vpstruct16 != 0 )
        {
            // Some apps (MsWorks3 is one) return S_FALSE and do not return
            // the number of elements retrieved.  The only thing we can
            // do is ignore the enumeration since we don't know how many
            // were actually set.  Of course, we can't ignore all enumerations
            // when the return is S_FALSE so we only handle the case
            // where S_FALSE was returned on a enumeration of one element,
            // in which we can be sure there isn't any valid data
            if (dwResult == (DWORD)S_FALSE && ulCount == 1)
            {
                ulFetched32 = 0;
            }

            //
            // Iterate through all of the structures, converting them
            // into 16-bit
            //
            fError = FALSE;
            ulIterate = 0;
            vpstruct16Iterate = vpstruct16;
            lpstruct32Iterate = lpstruct32;

            while ( ulIterate < ulFetched32 )
            {
                //
                // Callback to the callback function to do any specific
                // processing
                //
                sc = (*pfnCallback)( pti, lpstruct32Iterate,
                                     vpstruct16Iterate );

                if ( FAILED(sc) )
                {
                    fError = TRUE;
                    dwResult = sc;
                }

                vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                             uiSize16);
                lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                             uiSize32);

                ulIterate++;
            }

            if ( fError )
            {
                //
                // Cleanup all these guys
                //
                ulIterate = 0;
                vpstruct16Iterate = vpstruct16;
                lpstruct32Iterate = lpstruct32;

                while ( ulIterate <= ulFetched32 )
                {
                    (*pfnCleanup)( pti, lpstruct32Iterate, vpstruct16Iterate );
                    vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                                 uiSize16);
                    lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                                 uiSize32);

                    ulIterate++;
                }
            }
        }
    }

    if (FAILED(dwResult) && lp16 != NULL)
    {
        memset(lp16, 0, ulCount*uiSize16);
    }

    //
    // Free up any space we've allocated
    //
    if (lpstruct32 != NULL)
    {
        if ( ulCount > MAX_ALLOCA_STRUCT )
        {
            CoTaskMemFree( lpstruct32 );
        }
        else
        {
            STACKFREE32(lpstruct32, ulCount*uiSize32);
        }
    }

    if ( vpfetched16 != 0 )
    {
        lpfetched16 = FIXVDMPTR( vpfetched16, ULONG);
        *lpfetched16 = ulFetched32;
        RELVDMPTR(vpfetched16);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STRING_1632, public
//
//  Synopsis:   Prepares the LPOLESTR for the copy back into 16-bit address
//              space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STRING_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPSTR vpstr;
    VPSTR UNALIGNED *pvpstr16;
    SCODE sc;

    vpstr = 0;
    sc = ConvertTaskString3216(pti, *(LPOLESTR *)lp32, NULL, 0,
                               &vpstr);

    pvpstr16 = FIXVDMPTR(vp16, VPSTR);
    *pvpstr16 = vpstr;
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STRING_1632, public
//
//  Synopsis:   Cleans up the any STRINGs returned (either to 16-bit or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STRING_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPSTR UNALIGNED *lpvpstr16;
    VPSTR           vpstr16;

    lpvpstr16 = FIXVDMPTR( vp16, VPSTR );
    vpstr16 = *lpvpstr16;
    RELVDMPTR(vp16);

    if ( vpstr16 != 0 )
    {
        TaskFree16( vpstr16 );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STRING_1632, public
//
//  Synopsis:   Thunks IEnumSTRING::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STRING_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(LPOLESTR),
                             sizeof(VPSTR),
                             Callback_STRING_1632,
                             Cleanup_STRING_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_UNKNOWN_1632, public
//
//  Synopsis:   Prepares the UNKNOWN structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_UNKNOWN_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPVOID          vpunknown16;
    SCODE           sc = S_OK;

    vpunknown16 =
        pti->pThkMgr->FindProxy1632(NULL, *(LPUNKNOWN *)lp32, NULL,
                                    INDEX_IIDIDX(THI_IUnknown), NULL);
    
    // Release the actual 32-bit IUnknown as it is a OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    (*((LPUNKNOWN *) lp32))->Release();
    
    if(!vpunknown16) {
        sc = E_OUTOFMEMORY;
    }

    *FIXVDMPTR( vp16, VPVOID ) = vpunknown16;
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_UNKNOWN_1632, public
//
//  Synopsis:   Cleans up the any UNKNOWNs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_UNKNOWN_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPUNKNOWN        lpunknown32;
    VPVOID           vpunknown16;

    vpunknown16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);
    lpunknown32 = *(LPUNKNOWN *)lp32;

    if(vpunknown16) {
        // Release the proxy to 32-bit interface
        pti->pThkMgr->ReleaseProxy1632(vpunknown16);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_UNKNOWN_1632, public
//
//  Synopsis:   Thunks IEnumUNKNOWN::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_UNKNOWN_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(LPUNKNOWN),
                             sizeof(LPUNKNOWN),
                             Callback_UNKNOWN_1632,
                             Cleanup_UNKNOWN_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATSTG_1632, public
//
//  Synopsis:   Prepares the STATSTG structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STATSTG_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    (FIXVDMPTR(vp16, STATSTG))->pwcsName = NULL;
    RELVDMPTR(vp16);
    return ConvertStatStg3216(pti, (STATSTG *)lp32, vp16,
                              NULL, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATSTG_1632, public
//
//  Synopsis:   Cleans up the any STATSTGs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATSTG_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATSTG UNALIGNED *lpstatstg16;
    VPVOID vpstr;

    lpstatstg16 = FIXVDMPTR( vp16, STATSTG );
    vpstr = (VPVOID)lpstatstg16->pwcsName;
    RELVDMPTR(vp16);

    if ( vpstr != 0)
    {
        TaskFree16( vpstr );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATSTG_1632, public
//
//  Synopsis:   Thunks IEnumSTATSTG::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATSTG_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(STATSTG),
                             sizeof(STATSTG),
                             Callback_STATSTG_1632,
                             Cleanup_STATSTG_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_FORMATETC_1632, public
//
//  Synopsis:   Prepares the FORMATETC structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_FORMATETC_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    (FIXVDMPTR(vp16, FORMATETC16))->ptd = NULL;
    RELVDMPTR(vp16);
    return ConvertFetc3216(pti, (FORMATETC *)lp32, vp16, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_FORMATETC_1632, public
//
//  Synopsis:   Cleans up the any FORMATETCs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_FORMATETC_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    FORMATETC16 UNALIGNED *lpformatetc16;
    VPVOID vptd;

    lpformatetc16 = FIXVDMPTR( vp16, FORMATETC16 );
    vptd = lpformatetc16->ptd;
    RELVDMPTR(vp16);

    if (vptd != 0)
    {
        TaskFree16(vptd);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_FORMATETC_1632, public
//
//  Synopsis:   Thunks IEnumFORMATETC::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_FORMATETC_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(FORMATETC),
                             sizeof(FORMATETC16),
                             Callback_FORMATETC_1632,
                             Cleanup_FORMATETC_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATDATA_1632, public
//
//  Synopsis:   Prepares the STATDATA structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
SCODE Callback_STATDATA_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE               sc;
    LPSTATDATA          lpstatdata32;
    STATDATA16 UNALIGNED *lpstatdata16;
    VPVOID              vpadv16;

    sc = S_OK;

    lpstatdata32 = (LPSTATDATA)lp32;

    if (lpstatdata32->pAdvSink != NULL)
    {
        // We don't know whether it's an AdviseSink or
        // an AdviseSink2, so pass AdviseSink2 since it's
        // a superset of AdviseSink and will work for both

        vpadv16 = pti->pThkMgr->FindProxy1632(NULL, lpstatdata32->pAdvSink, NULL,
                                              INDEX_IIDIDX(THI_IAdviseSink2),
                                              NULL);

        // Release the actual 32-bit IAdviseSink as it is a OUT parameter
        // This could be the last release on the interface if the
        // above call failed;
        lpstatdata32->pAdvSink->Release();

        if(!vpadv16) {
            sc = E_OUTOFMEMORY;
        }
    }
    else
    {
        vpadv16 = 0;
    }

    lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
    lpstatdata16->formatetc.ptd = NULL;
    if (SUCCEEDED(sc))
    {
        // If this fails the AdviseSink proxy will be cleaned up in
        // the cleanup function later

        sc = ConvertFetc3216(pti,
                             &lpstatdata32->formatetc,
                             vp16+FIELD_OFFSET(STATDATA16, formatetc), TRUE);
    }

    if (SUCCEEDED(sc))
    {
        lpstatdata16->advf = lpstatdata32->advf;
        lpstatdata16->pAdvSink = vpadv16;
        lpstatdata16->dwConnection = lpstatdata32->dwConnection;
    }

    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATDATA_1632, public
//
//  Synopsis:   Cleans up the any STATDATAs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATDATA_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATDATA *lpstatdata32;
    STATDATA16 UNALIGNED *lpstatdata16;
    LPADVISESINK lpadv32;
    VPVOID vptd;

    lpstatdata32 = (STATDATA FAR *)lp32;
    lpadv32 = lpstatdata32->pAdvSink;

    lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
    vptd = lpstatdata16->formatetc.ptd;
    RELVDMPTR(vp16);

    if(lpstatdata16->pAdvSink) {
        // Release the proxy to 32-bit interface
        pti->pThkMgr->ReleaseProxy1632((VPVOID) lpstatdata32->pAdvSink);
    }

    if (vptd != 0)
    {
        TaskFree16(vptd);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATDATA_1632, public
//
//  Synopsis:   Thunks IEnumSTATDATA::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATDATA_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(STATDATA),
                             sizeof(STATDATA16),
                             Callback_STATDATA_1632,
                             Cleanup_STATDATA_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_MONIKER_1632, public
//
//  Synopsis:   Prepares the MONIKER structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_MONIKER_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPVOID        vpmoniker16;
    SCODE         sc = S_OK;

    vpmoniker16 = pti->pThkMgr->FindProxy1632(NULL, *(LPMONIKER *)lp32, NULL,
                                              INDEX_IIDIDX(THI_IMoniker),
                                              NULL);
    
    // Release the actual 32-bit IMoniker as it is a OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    (*(LPMONIKER *)lp32)->Release();

    if(!vpmoniker16) {
        sc = E_OUTOFMEMORY;
    }

    *FIXVDMPTR(vp16, VPVOID) = vpmoniker16;
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_MONIKER_1632, public
//
//  Synopsis:   Cleans up the any MONIKERs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_MONIKER_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPMONIKER       lpmoniker32;
    VPVOID          vpmoniker16;

    vpmoniker16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);
    lpmoniker32 = *(LPMONIKER *)lp32;

    if(vpmoniker16) {
        pti->pThkMgr->ReleaseProxy1632(vpmoniker16);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_MONIKER_1632, public
//
//  Synopsis:   Thunks IEnumMONIKER::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_MONIKER_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(LPMONIKER),
                             sizeof(LPMONIKER),
                             Callback_MONIKER_1632,
                             Cleanup_MONIKER_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_OLEVERB_1632, public
//
//  Synopsis:   Prepares the OLEVERB structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_OLEVERB_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE       sc;
    OLEVERB     *lpoleverb32;
    OLEVERB UNALIGNED *lpoleverb16;
    VPSTR vpstr;

    lpoleverb32 = (LPOLEVERB)lp32;
    vpstr = 0;
    sc = ConvertTaskString3216(pti, lpoleverb32->lpszVerbName, NULL, 0,
                               &vpstr);
    lpoleverb16 = FIXVDMPTR(vp16, OLEVERB);
    lpoleverb16->lpszVerbName = (LPOLESTR)vpstr;
    if (SUCCEEDED(sc))
    {
        lpoleverb16->lVerb        = lpoleverb32->lVerb;
        lpoleverb16->fuFlags      = lpoleverb32->fuFlags;
        lpoleverb16->grfAttribs   = lpoleverb32->grfAttribs;
    }
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_OLEVERB_1632, public
//
//  Synopsis:   Cleans up the any OLEVERBs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_OLEVERB_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    OLEVERB UNALIGNED *lpoleverb16;
    VPVOID vpstr;

    lpoleverb16 = FIXVDMPTR( vp16, OLEVERB );
    vpstr = (VPVOID)lpoleverb16->lpszVerbName;
    RELVDMPTR(vp16);

    if ( vpstr != 0 )
    {
        TaskFree16( vpstr );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_OLEVERB_1632, public
//
//  Synopsis:   Thunks IEnumOLEVERB::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_OLEVERB_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(OLEVERB),
                             sizeof(OLEVERB),
                             Callback_OLEVERB_1632,
                             Cleanup_OLEVERB_1632 );
}

#define THOP_EFN(x)  Thop_Enum_ ## x ## _1632

DWORD (*CONST aThopEnumFunctions1632[])(THUNKINFO *) =
{
    THOP_EFN(STRING),               // STRING
    THOP_EFN(UNKNOWN),              // UNKNOWN
    THOP_EFN(STATSTG),              // STATSTG
    THOP_EFN(FORMATETC),            // FORMATETC
    THOP_EFN(STATDATA),             // STATDATA
    THOP_EFN(MONIKER),              // MONIKER
    THOP_EFN(OLEVERB),              // OLEVERB
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thoputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thoputil.cxx
//
//  Contents:   Utility routines for thunking
//
//  History:    01-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <stdio.h>
#include <limits.h>

#include <vdmdbg.h>
#include <valid.h>

extern "C" DECLSPEC_IMPORT VDMLDT_ENTRY *ExpLdt;

#include "struct16.hxx"

#define CF_INVALID ((CLIPFORMAT)0)

#define OBJDESC_CF(cf) \
    ((cf) == g_cfObjectDescriptor || (cf) == g_cfLinkSourceDescriptor)

// Alias manager for THOP_ALIAS32
CAliases gAliases32;

//+---------------------------------------------------------------------------
//
//  Function:   IidToIidIdx, public
//
//  Synopsis:   Looks up an interface index by IID
//              If it's not found, it returns the IID pointer
//
//  Arguments:  [riid] - IID
//
//  Returns:    Index or IID
//
//  History:    23-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

IIDIDX IidToIidIdx(REFIID riid)
{
    int idx;

    for (idx = 0; idx < THI_COUNT; idx++)
    {
        if (IsEqualIID(riid, *aittIidToThi[idx].piid))
        {
            return INDEX_IIDIDX(aittIidToThi[idx].iThi);
        }
    }

    return IID_IIDIDX(&riid);
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskMalloc32, public
//
//  Synopsis:   Task allocation for 32-bits
//
//  History:    01-Mar-94       DrewB   Created
//
//  Notes:      Temporary until CoTaskMemAlloc is hooked up
//
//----------------------------------------------------------------------------

#ifndef COTASK_DEFINED
LPVOID TaskMalloc32(SIZE_T cb)
{
    IMalloc *pm;
    LPVOID pv;

    if (FAILED(GetScode(CoGetMalloc(MEMCTX_TASK, &pm))))
    {
        return NULL;
    }
    else
    {
        pv = pm->Alloc(cb);
        pm->Release();
    }
    return pv;
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskFree32, public
//
//  Synopsis:   Task free for 32-bits
//
//  History:    01-Mar-94       DrewB   Created
//
//  Notes:      Temporary until CoTaskMemAlloc is hooked up
//
//----------------------------------------------------------------------------

void TaskFree32(LPVOID pv)
{
    IMalloc *pm;

    if (FAILED(GetScode(CoGetMalloc(MEMCTX_TASK, &pm))))
    {
        thkAssert(!"CoGetMalloc failed");
    }
    else
    {
        pm->Free(pv);
        pm->Release();
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   TaskMalloc16, public
//
//  Synopsis:   Allocates 16-bit task memory
//
//  Arguments:  [uiSize] - Amount of memory to allocate
//
//  Returns:    VPVOID for memory allocated
//
//  History:    01-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD TaskMalloc16( UINT uiSize )
{
    return CallbackTo16(gdata16Data.fnTaskAlloc, uiSize);
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskFree16, public
//
//  Synopsis:   Frees 16-bit task memory
//
//  Arguments:  [vpvoid] - VPVOID of allocated memory
//
//  History:    01-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

void TaskFree16( DWORD vpvoid )
{
    CallbackTo16(gdata16Data.fnTaskFree, vpvoid);
}

// List of 16/32 HRESULT mappings for mapping functions
struct SHrMapping
{
    HRESULT hr16;
    HRESULT hr32;
};

// Since we're including 32-bit headers in this code we can use
// the defines for the 32-bit values but we must specify the
// 16-bit values explicitly
static SHrMapping hmMappings[] =
{
    0x80000001, E_NOTIMPL,
    0x80000002, E_OUTOFMEMORY,
    0x80000003, E_INVALIDARG,
    0x80000004, E_NOINTERFACE,
    0x80000005, E_POINTER,
    0x80000006, E_HANDLE,
    0x80000007, E_ABORT,
    0x80000008, E_FAIL,
    0x80000009, E_ACCESSDENIED
};
#define NMAPPINGS (sizeof(hmMappings)/sizeof(hmMappings[0]))

#define HR16_ERROR 0x80000000
#define HR16_MAP_FIRST 1
#define HR16_MAP_LAST 9

//+---------------------------------------------------------------------------
//
//  Function:   TransformHRESULT_1632, public
//
//  Synopsis:   Translates a 16-bit hresult into a 32-bit hresult
//
//  Arguments:  [hresult] - 16-bit hresult to transform
//
//  History:    15-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) TransformHRESULT_1632( DWORD hresult )
{
    ULONG ulIndex;

    // We only map error codes
    if (hresult & HR16_ERROR)
    {
        // The 16-bit HRESULTs to be mapped are known quantities
        // whose values are sequential, so we can map directly from
        // the value to an array index

        ulIndex = hresult & ~HR16_ERROR;
        if (ulIndex >= HR16_MAP_FIRST && ulIndex <= HR16_MAP_LAST)
        {
            // Known value, index array to find 32-bit HRESULT
            return hmMappings[ulIndex-HR16_MAP_FIRST].hr32;
        }
    }

    // No mapping found, so return the original
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   TransformHRESULT_3216, public
//
//  Synopsis:   Translates a 32-bit hresult into a 16-bit hresult
//
//  Arguments:  [hresult] - 32-bit hresult to transform
//
//  History:    15-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) TransformHRESULT_3216( DWORD hresult )
{
    int i;
    SHrMapping *phm;

    // We don't know the true values of 32-bit HRESULTs since we're
    // using the defines and they may change, so we have to look up
    // the hard way

    phm = hmMappings;
    for (i = 0; i < NMAPPINGS; i++)
    {
        if (phm->hr32 == (HRESULT)hresult)
        {
            return phm->hr16;
        }

        phm++;
    }

    // No mapping found, so return the original
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   RecordStackState, public debug
//
//  Synopsis:   Records the current state of the stack
//
//  Arguments:  [psr] - Storage space for information
//
//  Modifies:   [psr]
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void RecordStackState16(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack16();
    psa->RecordState(psr);
}

void RecordStackState32(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack32();
    psa->RecordState(psr);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CheckStackState, public debug
//
//  Synopsis:   Checks recorded information about the stack against its
//              current state
//
//  Arguments:  [psr] - Recorded information
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CheckStackState16(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack16();
    psa->CheckState(psr);
}

void CheckStackState32(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack32();
    psa->CheckState(psr);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Convert_VPSTR_to_LPOLESTR
//
//  Synopsis:   Converts 16-bit VPSTR to 32-bit LPOLESTR pointer
//
//  Arguments:  [vpstr] - VPSTR
//              [lpOleStr] - OLESTR
//              [uiSizeInPlace] - Amount of data available in [lpOleStr]
//                      for in-place conversion (in characters, not bytes)
//                      including nul
//
//  Returns:    Pointer to LPOLESTR with data
//
//  History:    24-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

LPOLESTR Convert_VPSTR_to_LPOLESTR(
    THUNKINFO   *pti,
    VPSTR       vpstr,
    LPOLESTR    lpOleStr,
    UINT        uiSizeInPlace
)
{
    LPSTR       lpstr;
    UINT        uiSize;
    LPOLESTR    lpOleStrResult;
    UINT        cChars;

    // We shouldn't be calling here for null strings
    thkAssert( vpstr != NULL );

    lpstr = GetStringPtr16(pti, vpstr, CCHMAXSTRING, &uiSize);
    if ( lpstr == NULL )
    {
        //
        // GetStringPtr will have filled in the pti->scResult
        //
        return( NULL );
    }

    // The string has to have at least one character in it
    // because it must be null-terminated to be valid
    thkAssert(uiSize > 0);

    lpOleStrResult = lpOleStr;

    if ( uiSize > uiSizeInPlace )
    {
        lpOleStrResult = (LPOLESTR)TaskMalloc32(uiSize*sizeof(OLECHAR));
        if (lpOleStrResult == NULL)
        {
            pti->scResult = E_OUTOFMEMORY;
            return NULL;
        }
    }

    cChars = MultiByteToWideChar( AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                  0,
                                  lpstr,
                                  uiSize,
                                  lpOleStrResult,
                                  uiSize );

    WOWRELVDMPTR(vpstr);

    if ( cChars == 0 )
    {
        if (lpOleStrResult != lpOleStr)
        {
            TaskFree32(lpOleStrResult);
        }

        pti->scResult = E_UNEXPECTED;
        return( NULL );
    }
    else
    {
        return( lpOleStrResult );
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   Convert_LPOLESTR_to_VPSTR
//
//  Synopsis:   Converts 32-bit LPOLESTR to 16-bit VPSTR pointer
//
//  Arguments:  [lpOleStr] - OLESTR
//              [vpstr] - VPSTR
//              [uiSize32] - Length of OLESTR in characters (not bytes)
//                      including nul
//              [uiSize16] - Byte length of buffer referred to by VPSTR
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       BobDay  Created
//
//  Notes:      Always converts in place
//
//----------------------------------------------------------------------------

SCODE Convert_LPOLESTR_to_VPSTR(
    LPCOLESTR    lpOleStr,
    VPSTR       vpstr,
    UINT        uiSize32,
    UINT        uiSize16
)
{
    LPSTR       lpstr;
    UINT        cChars;
    SCODE       sc;

    sc = S_OK;

    lpstr = (LPSTR)WOWFIXVDMPTR(vpstr, uiSize16);

    cChars = WideCharToMultiByte( AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                  0,
                                  lpOleStr,
                                  uiSize32,
                                  lpstr,
                                  uiSize16,
                                  NULL,
                                  NULL );

    if ( cChars == 0 && uiSize32 != 0 )
    {
        sc = E_UNEXPECTED;
    }

    WOWRELVDMPTR(vpstr);

    return sc;
}

// Selector bit constants
#define SEL_TI          0x0004
#define SEL_RPL         0x0003
#define SEL_INDEX       0xfff8

#define IS_LDT_SELECTOR(sel) (((sel) & SEL_TI) == SEL_TI)

// LDT bit constants
#define LTYPE_APP       0x0010
#define LTYPE_CODE      0x0008
#define LTYPE_CREAD     0x0002
#define LTYPE_DDOWN     0x0004
#define LTYPE_DWRITE    0x0002

// Pointer access types, or'able
// Defined to be the same as thop in/out so that no translation
// is necessary for checks on thop memory access
#define PACC_READ       THOP_IN
#define PACC_WRITE      THOP_OUT
#define PACC_CODE       1           // Special for CODE PTRs

// Information about a VDM pointer
typedef struct _VPTRDESC
{
    BYTE *pbFlat;
    DWORD dwLengthLeft;
} VPTRDESC;

DWORD dwBaseVDMMemory = 0xFFFFFFFF;

// Extended success returns from GetPtr16Description
#define S_GDTENTRY      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)
#define S_SYSLDTENTRY   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 2)

//+---------------------------------------------------------------------------
//
//  Function:   GetPtr16Description, public
//
//  Synopsis:   Validates access for a VDM pointer and returns
//              information about it
//              Also forces not-present segments into memory by
//              touching them
//
//  Arguments:  [vp] - VDM pointer
//              [grfAccess] - Desired access
//              [dwSize] - Desired size of access, must be >= 1
//              [pvpd] - VPTRDESC out
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pvpd]
//
//  History:    26-Apr-94       DrewB   Created
//
//  Notes:      Returns fixed memory
//
//----------------------------------------------------------------------------

SCODE GetPtr16Description(VPVOID vp,
                          WORD grfAccess,
                          DWORD dwSize,
                          VPTRDESC *pvpd)
{
    VDMLDT_ENTRY *vle;
    WORD wSel;
    WORD wOff;
    DWORD dwLength;

    thkAssert(vp != 0);
    thkAssert(dwSize > 0);
    thkAssert(grfAccess != 0);

    wSel = (WORD)(vp >> 16);
    wOff = (WORD)(vp & 0xffff);

    pvpd->dwLengthLeft = 0xffff-wOff+1;     // Default length remaining

    if (!IS_LDT_SELECTOR(wSel))
    {
        // According to the WOW developers, the only GDT selector
        // is for the BIOS data area so we should never see one

        thkDebugOut((DEB_ERROR, "GDT selector: 0x%04X\n", wSel));

        // Handle it just in case
        pvpd->pbFlat = (BYTE *)WOWFIXVDMPTR(vp, dwSize);

        return S_GDTENTRY;
    }

    vle = (VDMLDT_ENTRY *)((BYTE *)(ExpLdt)+(wSel & SEL_INDEX));

    if ((vle->HighWord.Bits.Type & LTYPE_APP) == 0)
    {
        // According to the WOW developers, they don't use
        // system segments so we should never see one

        thkDebugOut((DEB_ERROR, "System descriptor: 0x%04X\n", wSel));

        // Handle it just in case
        pvpd->pbFlat = (BYTE *)WOWFIXVDMPTR(vp, dwSize);

        return S_SYSLDTENTRY;
    }

    // Do as much up-front validation as possible
    // Since the segment may not be present, we are restricted to
    // only checking the access permissions

    if (vle->HighWord.Bits.Type & LTYPE_CODE)
    {
        // Validate access for code segments
        // Code segments are never writable

        if (((grfAccess & PACC_READ) &&
             (vle->HighWord.Bits.Type & LTYPE_CREAD) == 0) ||
            (grfAccess & PACC_WRITE))
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        // Validate access for data segments
        // Data segments are always readable never executable

        if (((grfAccess & PACC_WRITE) &&
             (vle->HighWord.Bits.Type & LTYPE_DWRITE) == 0) ||
             (grfAccess & PACC_CODE))
        {
            return E_INVALIDARG;
        }
    }

    // Bring in segment if it's not present
    if (!vle->HighWord.Bits.Pres)
    {
        // We've validated access permissions and segments must
        // always be at least one byte long so it's safe to
        // touch the first byte to bring it in

        // On Win95, this will call GlobalFix on the pointer
        // to ensure that it stays in memory
        WOWCallback16(gdata16Data.fnTouchPointer16, vp);

        thkAssert(vle->HighWord.Bits.Pres);
    }


    dwLength = ((DWORD)vle->LimitLow |
                ((DWORD)vle->HighWord.Bits.LimitHi << 16))+1;
    if (vle->HighWord.Bits.Granularity)
    {
        // 4K granularity
        dwLength <<= 12;
    }

    if ((vle->HighWord.Bits.Type & LTYPE_CODE) ||
        (vle->HighWord.Bits.Type & LTYPE_DDOWN) == 0)
    {
        // Validate length for code and normal data segments

        if (wOff+dwSize > dwLength)
        {
            WOWRELVDMPTR(vp);
            return E_INVALIDARG;
        }

        pvpd->dwLengthLeft = dwLength-wOff;
    }
    else
    {
        // Expand-down segment

        if (wOff < dwLength)
        {
            WOWRELVDMPTR(vp);
            return E_INVALIDARG;
        }

        // Check for wraparound

        if (vle->HighWord.Bits.Granularity)
        {
            // Compiler - This should be +1, but
            // the compiler generates a warning about an overflow
            // in constant arithmetic
            pvpd->dwLengthLeft = 0xffffffff-wOff;
        }

        if (dwSize > pvpd->dwLengthLeft)
        {
            WOWRELVDMPTR(vp);
            return E_INVALIDARG;
        }
    }

    if ( dwBaseVDMMemory == 0xFFFFFFFF )
    {
        dwBaseVDMMemory = (DWORD)WOWGetVDMPointer(0, 0, FALSE);
    }

    // Translate the pointer even on Win95 because forcing the segment
    // present may have changed its address
    pvpd->pbFlat = (BYTE *)(dwBaseVDMMemory +
                            wOff +
                            (  (DWORD)vle->BaseLow |
                             ( (DWORD)vle->HighWord.Bytes.BaseMid << 16) |
                             ( (DWORD)vle->HighWord.Bytes.BaseHi  << 24) ) );

#if DBG == 1
    if (pvpd->pbFlat != WOWGetVDMPointer(vp, dwSize, TRUE))
    {
        thkDebugOut((DEB_ERROR, "GetPtr16Description: "
                     "%p computed, %p system\n",
                     pvpd->pbFlat, WOWGetVDMPointer(vp, dwSize, TRUE)));
    }
#endif

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetReadPtr16
//
//  Synopsis:   Validates a 16-bit pointer for reading and converts it into
//              a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetReadPtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_READ, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetWritePtr16
//
//  Synopsis:   Validates a 16-bit pointer for writing and converts it into
//              a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetWritePtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_WRITE, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCodePtr16
//
//  Synopsis:   Validates a 16-bit pointer for execution and converts it
//              into a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Jul-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetCodePtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_CODE, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetReadWritePtr16
//
//  Synopsis:   Validates a 16-bit pointer for reading and writing and
//              converts it into a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetReadWritePtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_READ | PACC_WRITE, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStringPtr16
//
//  Synopsis:   Validates a 16-bit pointer to a string for reading and
//              converts it (the pointer) into a flat 32 pointer. It also
//              returns the length, since it has to compute it anyway.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [cchMax] - Maximum legal length
//              [lpSize] - Place to return length
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

CHAR  *
GetStringPtr16(
    THUNKINFO   *pti,
    VPSTR       vp,
    UINT        cchMax,
    PUINT       lpSize )
{
    VPTRDESC vpd;
    SCODE sc;

    // Check the first byte to ensure read access to the segment
    sc = GetPtr16Description(vp, PACC_READ, 1, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        UINT cchLen;
        BYTE *pb;
        BOOL fMbLead;

        pb = vpd.pbFlat;

        if (pb == NULL)
        {
            goto Exit;
        }


        // Restrict zero-termination search to cchMax characters
        // or valid remaining memory
        // Since we specified one in GetPtr16Description, dwLengthLeft
        // is one off here
        cchMax = min(cchMax, vpd.dwLengthLeft+1);

        cchLen = 0;
        fMbLead = FALSE;
        while (cchMax > 0)
        {
            cchLen++;

            if (*pb == 0 && !fMbLead)
            {
                break;
            }
            else
            {
                fMbLead = (BOOL)g_abLeadTable[*pb++];
                cchMax--;
            }
        }

        if (cchMax > 0)
        {
            *lpSize = cchLen;
            return (LPSTR)vpd.pbFlat;
        }

Exit:
        {
            pti->scResult = E_INVALIDARG;
            WOWRELVDMPTR(vp);
            return NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidatePtr16, public
//
//  Synopsis:   Calls an appropriate validation routine for 16-bit
//              memory based on in/out status
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [vp16] - 16-bit pointer
//              [dwSize] - Size
//              [thopInOut] - In/out type
//
//  Returns:    Pointer or NULL
//
//  Modifies:   [pti]->scResult for errors
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      0 - No validation
//              THOP_IN - Read validation
//              THOP_OUT - Write validation
//              THOP_INOUT - Read/write validation
//
//----------------------------------------------------------------------------

VOID  *
ValidatePtr16(THUNKINFO *pti,
                     VPVOID vp16,
                     DWORD dwSize,
                     THOP thopInOut)
{
    VPTRDESC vpd;
    SCODE sc;

    thopInOut &= THOP_INOUT;
    if (thopInOut != 0)
    {
        sc = GetPtr16Description(vp16, thopInOut, dwSize, &vpd);
        if (FAILED(sc))
        {
            pti->scResult = sc;
            return NULL;
        }
        else
        {
            return vpd.pbFlat;
        }
    }
    else
    {
        return WOWFIXVDMPTR(vp16, dwSize);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidInterface16, public
//
//  Synopsis:   Validates that a provided 16-bit interface is really valid
//              (uses the same validation technique as 16-bit OLE 2.01)
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [vp16] - 16-bit pointer
//
//  Returns:    BOOL - true for valid, false for invalid
//
//  Modifies:   [pti]->scResult for errors
//
//  History:    22-Jul-92       BobDay      Created
//
//----------------------------------------------------------------------------

BOOL IsValidInterface16( THUNKINFO *pti, VPVOID vp )
{
    VPVOID UNALIGNED *pvpv;
    VPVOID  vpvtbl;
    VPVOID  vpfn;
    LPVOID  lpfn;

    //
    // Make sure we can read the vtbl pointer from the object.
    //
    pvpv = (VPVOID FAR *)GetReadPtr16(pti, vp, sizeof(VPVOID));
    if ( pvpv == NULL )
    {
        thkDebugOut((DEB_WARN, "IsValidInterface16: "
                     "Interface ptr invalid %p\n", vp));
        return FALSE;
    }

    vpvtbl = *pvpv;     // Read the vtbl ptr

    WOWRELVDMPTR(vp);

    // Make sure we can read the first entry from the vtbl (QI)

    pvpv = (VPVOID FAR *)GetReadPtr16(pti, vpvtbl, sizeof(VPVOID));
    if ( pvpv == NULL )
    {
        thkDebugOut((DEB_WARN, "Vtbl ptr invalid %p:%p\n", vp, vpvtbl));
        return FALSE;
    }

    vpfn = *pvpv;           // Get the QI Function

    WOWRELVDMPTR(vpvtbl);

    if ( vpfn == 0 )
    {
        thkDebugOut((DEB_WARN, "QI function NULL %p:%p\n", vp, vpvtbl));
        pti->scResult = E_INVALIDARG;
        return FALSE;
    }

    // Why it has to be 9 bytes long, I have no idea.
    // This check was taken from valid.cpp in
    // \src\ole2\dll\src\debug the 16-bit ole2.01
    // sources...
    lpfn = (LPVOID)GetCodePtr16(pti, vpfn, 9);

    WOWRELVDMPTR(vpfn);

    if ( lpfn == NULL )
    {
        thkDebugOut((DEB_WARN, "QI function ptr invalid %p:%p:%p\n",
                     vp,vpvtbl,vpfn));
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GuidString, debug public
//
//  Synopsis:   Converts a guid to a string
//
//  Arguments:  [pguid] - GUID
//
//  Returns:    Pointer to string
//
//  History:    08-Mar-94       DrewB   Created
//
//  Notes:      Uses a static buffer
//
//----------------------------------------------------------------------------

#if DBG == 1

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidString(GUID const *pguid)
{
    static char ach[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    wsprintfA(ach, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return ach;
}

#endif

#if DBG == 1
 char *apszThopNames[] =
{
    "THOP_END",
    "THOP_SHORTLONG",
    "THOP_WORDDWORD",
    "THOP_COPY",
    "THOP_LPSTR",
    "THOP_LPLPSTR",
    "THOP_BUFFER",
    "THOP_HUSER",
    "THOP_HGDI",
    "THOP_SIZE",
    "THOP_RECT",
    "THOP_MSG",
    "THOP_HRESULT",
    "THOP_STATSTG",
    "THOP_DVTARGETDEVICE",
    "THOP_STGMEDIUM",
    "THOP_FORMATETC",
    "THOP_HACCEL",
    "THOP_OIFI",
    "THOP_BINDOPTS",
    "THOP_LOGPALETTE",
    "THOP_SNB",
    "THOP_CRGIID",
    "THOP_OLESTREAM",
    "THOP_HTASK",
    "THOP_INTERFACEINFO",
    "THOP_IFACE",
    "THOP_IFACEOWNER",
    "THOP_IFACENOADDREF",
    "THOP_IFACECLEAN",
    "THOP_IFACEGEN",
    "THOP_IFACEGENOWNER",
    "THOP_UNKOUTER",
    "THOP_UNKINNER",
    "THOP_ROUTINEINDEX",
    "THOP_RETURNTYPE",
    "THOP_NULL",
    "THOP_ERROR",
    "THOP_ENUM",
    "THOP_CALLBACK",
    "THOP_RPCOLEMESSAGE",
    "THOP_ALIAS32",
    "THOP_CLSCONTEXT",
    "THOP_FILENAME",
    "THOP_SIZEDSTRING"
};
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ThopName, debug public
//
//  Synopsis:   Returns the string name of a thop
//
//  Arguments:  [thop] - Thop
//
//  Returns:    Pointer to string
//
//  History:    11-Mar-94       DrewB   Created
//
//  Notes:      Uses a static buffer
//
//----------------------------------------------------------------------------

#if DBG == 1
char *ThopName(THOP thop)
{
    static char achString[80];
    char *psz;

    thkAssert((thop & THOP_OPMASK) < THOP_LASTOP);
    thkAssert(THOP_LASTOP ==
              (sizeof(apszThopNames)/sizeof(apszThopNames[0])));

    strcpy(achString, apszThopNames[thop & THOP_OPMASK]);

    psz = achString+strlen(achString);
    if (thop & THOP_IN)
    {
        strcpy(psz, " | THOP_IN");
        psz += strlen(psz);
    }
    if (thop & THOP_OUT)
    {
        strcpy(psz, " | THOP_OUT");
    }

    return achString;
}
#endif

#if DBG == 1
 char *apszEnumThopNames[] =
{
    "STRING",
    "UNKNOWN",
    "STATSTG",
    "FORMATETC",
    "STATDATA",
    "MONIKER",
    "OLEVERB"
};
#endif

//+---------------------------------------------------------------------------
//
//  Function:   EnumThopName, debug public
//
//  Synopsis:   Returns the string name of an enum thop
//
//  Arguments:  [thopEnum] - Thop
//
//  Returns:    Pointer to string
//
//  History:    11-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
char *EnumThopName(THOP thopEnum)
{
    thkAssert(thopEnum <
              (sizeof(apszEnumThopNames)/sizeof(apszEnumThopNames[0])));
    return apszEnumThopNames[thopEnum];
}
#endif

#if DBG == 1
// Maintain current thunking invocation nesting level
int _iThunkNestingLevel = 1;
#endif

//+---------------------------------------------------------------------------
//
//  Function:   NestingSpaces, debug public
//
//  Synopsis:   Spaces for each nesting level
//
//  History:    22-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1

#define NESTING_SPACES 32
#define SPACES_PER_LEVEL 2

static char achSpaces[NESTING_SPACES+1] = "                                ";

void NestingSpaces(char *psz)
{
    int iSpaces, i;

    iSpaces = _iThunkNestingLevel*SPACES_PER_LEVEL;

    while (iSpaces > 0)
    {
        i = min(iSpaces, NESTING_SPACES);
        memcpy(psz, achSpaces, i);
        psz += i;
        *psz = 0;
        iSpaces -= i;
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   NestingLevelString, debug public
//
//  Synopsis:   Provides a string describing the nesting level
//
//  History:    22-Mar-94       DrewB   Created
//
//  Notes:      Uses a static buffer
//
//----------------------------------------------------------------------------

#if DBG == 1
char *NestingLevelString(void)
{
    static char ach[256];
    char *psz;

    if ((thkInfoLevel & DEB_NESTING) == 0)
    {
        return "";
    }

    wsprintfA(ach, "%2d:", _iThunkNestingLevel);
    psz = ach+strlen(ach);

    if (sizeof(ach)/SPACES_PER_LEVEL <= _iThunkNestingLevel)
    {
        strcpy(psz, "...");
    }
    else
    {
        NestingSpaces(psz);
    }
    return ach;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   IidOrInterfaceString, debug public
//
//  Synopsis:   Returns the interface name for known interfaces or
//              the IID string itself
//
//  Arguments:  [piid] - IID
//
//  Returns:    char *
//
//  History:    18-Jun-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
char *IidOrInterfaceString(IID const *piid)
{
    return IidIdxString(IidToIidIdx(*piid));
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   IidIdxString, debug public
//
//  Synopsis:   Returns the interface name for known interfaces or
//              the IID string itself
//
//  Arguments:  [iidx] - IID or index
//
//  Returns:    char *
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
char *IidIdxString(IIDIDX iidx)
{
    if (IIDIDX_IS_IID(iidx))
    {
        return GuidString(IIDIDX_IID(iidx));
    }
    else if (IIDIDX_INDEX(iidx) == THI_COUNT)
    {
        // Special case here because of IMalloc's unusual unthunked-
        // but-indexed existence
        return "IMalloc";
    }
    else
    {
        return inInterfaceNames[IIDIDX_INDEX(iidx)].pszInterface;
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Handler routines, public
//
//  Synopsis:   Generic conversion routines for the generic thop handler
//
//  Arguments:  [pbFrom] - Data to convert from
//              [pbTo] - Buffer to convert into
//              [cbFrom] - Size of source data
//              [cbTo] - Size of destination data
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   FhCopyMemory, public
//
//  Synopsis:   Handler routine for memory copies
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhCopyMemory(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == cbTo);

    memcpy(pbTo, pbFrom, cbFrom);

#if DBG == 1
    if (cbFrom == sizeof(DWORD))
    {
        thkDebugOut((DEB_ARGS, "Arg     DWORD: 0x%08lX\n",
                *(DWORD UNALIGNED *)pbFrom));
    }
    else if (cbFrom == sizeof(LARGE_INTEGER))
    {
        thkDebugOut((DEB_ARGS, "Arg     8 byte: 0x%08lX:%08lX\n",
                     *(DWORD UNALIGNED *)(pbFrom+1*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+0*sizeof(DWORD))));
    }
    else if (cbFrom == sizeof(GUID))
    {
        thkDebugOut((DEB_ARGS, "Arg     16 byte: 0x%08lX:%08lX:%08lX:%08lX\n",
                     *(DWORD UNALIGNED *)(pbFrom+3*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+2*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+1*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+0*sizeof(DWORD))));
    }
    else
    {
        thkDebugOut((DEB_ARGS, "Arg     %d byte copy\n", cbFrom));
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   FhShortToLong, FhLongToShort, public
//
//  Synopsis:   Signed int conversion
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhShortToLong(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(SHORT));
    thkAssert(cbTo == sizeof(LONG));

    *(LONG UNALIGNED *)pbTo = (LONG)*(SHORT UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "ShToLo  %d -> %d\n",
                 *(SHORT UNALIGNED *)pbFrom, *(LONG UNALIGNED *)pbTo));
}

void FhLongToShort(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(LONG));
    thkAssert(cbTo == sizeof(SHORT));

    // Not used in situations where clamping is meaningful
    *(SHORT UNALIGNED *)pbTo = (SHORT)*(LONG UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "LoToSh  %d -> %d\n",
                 *(LONG UNALIGNED *)pbFrom, *(SHORT UNALIGNED *)pbTo));
}

//+---------------------------------------------------------------------------
//
//  Function:   FhWordToDword, FhDwordToWord, public
//
//  Synopsis:   Handler routine for memory copies
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhWordToDword(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(WORD));
    thkAssert(cbTo == sizeof(DWORD));

    *(DWORD UNALIGNED *)pbTo = (DWORD)*(WORD UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "WoToDw  0x%04lX -> 0x%08lX\n",
                 *(WORD UNALIGNED *)pbFrom, *(DWORD UNALIGNED *)pbTo));
}

void FhDwordToWord(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(DWORD));
    thkAssert(cbTo == sizeof(WORD));

    // Not used in situations where clamping is meaningful
    *(WORD UNALIGNED *)pbTo = (WORD)*(DWORD UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "DwToWo  0x%08lX -> 0x%04lX\n",
                 *(DWORD UNALIGNED *)pbFrom, *(WORD UNALIGNED *)pbTo));
}

//+---------------------------------------------------------------------------
//
//  Function:   Handle routines, public
//
//  Synopsis:   Handler routine for Windows handles
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhGdiHandle1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    *(HBITMAP *)pbTo = HBITMAP_32(*(HBITMAP16 UNALIGNED *)pbFrom);

    thkDebugOut((DEB_ARGS, "1632    HGdi: 0x%04lX -> 0x%p\n",
                 *(HAND16 UNALIGNED *)pbFrom, *(HANDLE *)pbTo));
}

void FhGdiHandle3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    *(HAND16 UNALIGNED *)pbTo = HBITMAP_16(*(HANDLE *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HGdi: 0x%p -> 0x%04lX\n",
                 *(HANDLE *)pbFrom, *(HAND16 UNALIGNED *)pbTo));
}

void FhUserHandle1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    // Even though the constant is WOW_TYPE_FULLHWND, it
    // works for any user handle

    *(HANDLE *)pbTo = WOWHandle32(*(HAND16 UNALIGNED *)pbFrom,
                                  WOW_TYPE_FULLHWND);

    thkDebugOut((DEB_ARGS, "1632    HUser: 0x%04lX -> 0x%p\n",
                 *(HAND16 UNALIGNED *)pbFrom, *(HANDLE *)pbTo));
}

void FhUserHandle3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    *(HAND16 UNALIGNED *)pbTo = HWND_16(*(HANDLE *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HUser: 0x%p -> 0x%04lX\n",
                 *(HANDLE *)pbFrom, *(HAND16 UNALIGNED *)pbTo));
}

void FhHaccel1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    *(HANDLE *)pbTo = HACCEL_32(*(HAND16 UNALIGNED *)pbFrom);

    thkDebugOut((DEB_ARGS, "1632    HACCEL: 0x%04lX -> 0x%p\n",
                 *(HAND16 UNALIGNED *)pbFrom, *(HANDLE *)pbTo));
}

void FhHaccel3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    *(HAND16 UNALIGNED *)pbTo = HACCEL_16(*(HANDLE *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HACCEL: 0x%p -> 0x%04lX\n",
                 *(HANDLE *)pbFrom, *(HAND16 UNALIGNED *)pbTo));
}

void FhHtask1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    HAND16  h16;
    DWORD   h32;
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    h16 = *(HAND16 UNALIGNED *)pbFrom;
    if ( h16 == 0 )
    {
        h32 = 0;
    }
    else
    {
        h32 = HTASK_32(h16);
    }
    *(DWORD *)pbTo = h32;

    thkDebugOut((DEB_ARGS, "1632    HTASK: 0x%04lX -> 0x%p\n", h16, h32));
}

void FhHtask3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    HAND16  h16;
    HANDLE  h32;

    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    h32 = *(HANDLE *)pbFrom;
    if ( h32 == NULL )
    {
        h16 = 0;
    }
    else
    {
        h16 = HTASK_16(h32);
    }
    *(HAND16 UNALIGNED *)pbTo = h16;

    thkDebugOut((DEB_ARGS, "3216    HTASK: 0x%p -> 0x%04lX\n",h32, h16));
}

//+---------------------------------------------------------------------------
//
//  Function:   HRESULT routines, public
//
//  Synopsis:   Handler routine for HRESULTs
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhHresult1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HRESULT));
    thkAssert(cbTo == sizeof(HRESULT));

    *(HRESULT *)pbTo = TransformHRESULT_1632(*(HRESULT UNALIGNED *)pbFrom);

    thkDebugOut((DEB_ARGS, "1632    HRESULT: 0x%08lX -> 0x%08lX\n",
                 *(HRESULT UNALIGNED *)pbFrom, *(HRESULT *)pbTo));
}

void FhHresult3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HRESULT));
    thkAssert(cbTo == sizeof(HRESULT));

    *(HRESULT UNALIGNED *)pbTo = TransformHRESULT_3216(*(HRESULT *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HRESULT: 0x%08lX -> 0x%08lX\n",
                 *(HRESULT *)pbFrom, *(HRESULT UNALIGNED *)pbTo));
}

//+---------------------------------------------------------------------------
//
//  Function:   NULL routines, public
//
//  Synopsis:   Handler routine for NULL
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhNull(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(void *));
    thkAssert(cbTo == sizeof(void *));

    thkDebugOut((DEB_WARN, "FhNull: %p NULL value not NULL\n", pbFrom));
    *(void UNALIGNED **)pbTo = NULL;

    thkDebugOut((DEB_ARGS, "Arg     NULL\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   Rect routines, public
//
//  Synopsis:   Handler routines for RECT
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhRect1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    RECT *pr32;
    RECT16 UNALIGNED * pr16;

    thkAssert(cbFrom == sizeof(RECT16));
    thkAssert(cbTo == sizeof(RECT));

    pr16 = (RECT16 UNALIGNED *)pbFrom;
    pr32 = (RECT *)pbTo;

    pr32->left   = (LONG)pr16->left;   // Sign extend
    pr32->top    = (LONG)pr16->top;    // Sign extend
    pr32->right  = (LONG)pr16->right;  // Sign extend
    pr32->bottom = (LONG)pr16->bottom; // Sign extend

    thkDebugOut((DEB_ARGS, "1632    RECT: {%d, %d, %d, %d}\n",
                 pr32->left, pr32->top, pr32->right, pr32->bottom));
}

void FhRect3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    RECT *pr32;
    RECT16 UNALIGNED *pr16;

    thkAssert(cbFrom == sizeof(RECT));
    thkAssert(cbTo == sizeof(RECT16));

    pr32 = (RECT *)pbFrom;
    pr16 = (RECT16 UNALIGNED *)pbTo;

    pr16->left   = ClampLongToShort(pr32->left);
    pr16->top    = ClampLongToShort(pr32->top);
    pr16->right  = ClampLongToShort(pr32->right);
    pr16->bottom = ClampLongToShort(pr32->bottom);

    thkDebugOut((DEB_ARGS, "3216    RECT: {%d, %d, %d, %d}\n",
                 pr32->left, pr32->top, pr32->right, pr32->bottom));
}

//+---------------------------------------------------------------------------
//
//  Function:   Size routines, public
//
//  Synopsis:   Handler routines for SIZE
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhSize1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    SIZE16 UNALIGNED *psize16;
    SIZE *psize32;

    thkAssert(cbFrom == sizeof(SIZE16));
    thkAssert(cbTo == sizeof(SIZE));

    psize16 = (SIZE16 UNALIGNED *)pbFrom;
    psize32 = (SIZE *)pbTo;

    psize32->cx = (LONG)psize16->cx;
    psize32->cy = (LONG)psize16->cy;

    thkDebugOut((DEB_ARGS, "1632    SIZE: {%d, %d}\n",
                 psize32->cx, psize32->cy));
}

void FhSize3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    SIZE16 UNALIGNED *psize16;
    SIZE *psize32;

    thkAssert(cbFrom == sizeof(SIZE));
    thkAssert(cbTo == sizeof(SIZE16));

    psize32 = (SIZE *)pbFrom;
    psize16 = (SIZE16 UNALIGNED *)pbTo;

    psize16->cx = ClampLongToShort(psize32->cx);
    psize16->cy = ClampLongToShort(psize32->cy);

    thkDebugOut((DEB_ARGS, "3216    SIZE: {%d, %d}\n",
                 psize32->cx, psize32->cy));
}

//+---------------------------------------------------------------------------
//
//  Function:   Message routines, public
//
//  Synopsis:   Handler routines for MSG
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhMsg1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    MSG16 UNALIGNED *pmsg16;
    MSG *pmsg32;

    thkAssert(cbFrom == sizeof(MSG16));
    thkAssert(cbTo == sizeof(MSG));

    pmsg16 = (MSG16 UNALIGNED *)pbFrom;
    pmsg32 = (MSG *)pbTo;

    pmsg32->hwnd    = HWND_32(pmsg16->hwnd);
    pmsg32->message = (UINT)pmsg16->message;
    pmsg32->wParam  = (WPARAM)pmsg16->wParam; // Should we sign extend?
    pmsg32->lParam  = (LPARAM)pmsg16->lParam;
    pmsg32->time    = pmsg16->time;
    pmsg32->pt.x    = (LONG)(SHORT)LOWORD(pmsg16->pt);   // Sign extend
    pmsg32->pt.y    = (LONG)(SHORT)HIWORD(pmsg16->pt);   // Sign extend

    thkDebugOut((DEB_ARGS, "1632    MSG: {0x%p, %d, 0x%08lX, 0x%08lX, "
                 "0x%08lX, {%d, %d}}\n",
                 pmsg32->hwnd, pmsg32->message, pmsg32->wParam,
                 pmsg32->lParam, pmsg32->time, pmsg32->pt.x,
                 pmsg32->pt.y));
}

void FhMsg3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    MSG16 UNALIGNED *pmsg16;
    MSG *pmsg32;

    thkAssert(cbFrom == sizeof(MSG));
    thkAssert(cbTo == sizeof(MSG16));

    pmsg32 = (MSG *)pbFrom;
    pmsg16 = (MSG16 UNALIGNED *)pbTo;

    pmsg16->hwnd    = HWND_16(pmsg32->hwnd);
    pmsg16->message = (WORD)pmsg32->message;
    pmsg16->wParam  = (WORD)pmsg32->wParam;           // Sign truncate
    pmsg16->lParam  = (LONG)pmsg32->lParam;
    pmsg16->time    = pmsg32->time;
    pmsg16->pt      = MAKELONG(ClampLongToShort(pmsg32->pt.x),
                               ClampLongToShort(pmsg32->pt.y));

    thkDebugOut((DEB_ARGS, "3216    MSG: {0x%p, %d, 0x%08lX, 0x%08lX, "
                 "0x%08lX, {%d, %d}}\n",
                 pmsg32->hwnd, pmsg32->message, pmsg32->wParam,
                 pmsg32->lParam, pmsg32->time, pmsg32->pt.x,
                 pmsg32->pt.y));
}

//+---------------------------------------------------------------------------
//
//  Function:   ALLOCROUTINE, public
//
//  Synopsis:   A routine which allocates memory
//
//  Arguments:  [cb] - Amount to allocate
//
//  Returns:    Pointer to memory
//
//  History:    19-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   FREEROUTINE, public
//
//  Synopsis:   A routine which frees memory
//
//  Arguments:  [pv] - Memory to free
//              [cb] - Size of memory to free
//
//  History:    19-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void *ArTask16(UINT cb)
{
    return (void *)TaskMalloc16(cb);
}

void FrTask16(void *pv, UINT cb)
{
    TaskFree16((VPVOID)pv);
}

void *ArTask32(UINT cb)
{
    return TaskMalloc32(cb);
}

void FrTask32(void *pv, UINT cb)
{
    TaskFree32(pv);
}

void *ArStack16(UINT cb)
{
    return (void *)STACKALLOC16(cb);
}

void FrStack16(void *pv, UINT cb)
{
    STACKFREE16((VPVOID)pv, cb);
}

void *ArStack32(UINT cb)
{
    // Can't use STACKALLOC32 on NT since it may be _alloca which wouldn't
    // live beyond this routine
    return (void *)LocalAlloc(LMEM_FIXED, cb);
}

void FrStack32(void *pv, UINT cb)
{
    LocalFree(pv);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertDvtd1632, private
//
//  Synopsis:   Converts a DVTARGETDEVICE from 16 to 32-bits
//
//  Arguments:  [pti] - Thunking state information
//              [vpdvtd16] - Source
//              [pfnAlloc] - ALLOCROUTINE
//              [pfnFree] - FREEROUTINE
//              [ppdvtd32] - Destination
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdvtd32]
//              [pcbSize]
//
//  History:    18-Apr-94       DrewB   Created
//
//  Notes:      [pfnAlloc/Free] must deal with 32-bit memory
//
//----------------------------------------------------------------------------

SCODE ConvertDvtd1632(THUNKINFO *pti,
                      VPVOID vpdvtd16,
                      ALLOCROUTINE pfnAlloc,
                      FREEROUTINE pfnFree,
                      DVTARGETDEVICE **ppdvtd32,
                      UINT *pcbSize)
{
    DVTARGETDEVICE UNALIGNED *pdvtd16;
    DVTARGETDEVICE *pdvtd32;
    DVTDINFO dvtdi;

    pdvtd16 = (DVTARGETDEVICE UNALIGNED *)GetReadPtr16(pti, vpdvtd16,
                                                       sizeof(DVTARGETDEVICE));
    if (pdvtd16 == NULL)
    {
        return pti->scResult;
    }

    pdvtd16 = (DVTARGETDEVICE UNALIGNED *)GetReadPtr16(pti, vpdvtd16,
                                                       pdvtd16->tdSize);

    WOWRELVDMPTR(vpdvtd16);

    if (pdvtd16 == NULL)
    {
        return pti->scResult;
    }

    pti->scResult = UtGetDvtd16Info( pdvtd16, &dvtdi );

    if ( FAILED(pti->scResult) )
    {
        WOWRELVDMPTR(vpdvtd16);
        return pti->scResult;
    }

    pdvtd32 = (DVTARGETDEVICE *)pfnAlloc(dvtdi.cbConvertSize);
    if (pdvtd32 == NULL)
    {
        WOWRELVDMPTR(vpdvtd16);
        return E_OUTOFMEMORY;
    }

    pti->scResult = UtConvertDvtd16toDvtd32( pdvtd16, &dvtdi, pdvtd32 );

    WOWRELVDMPTR(vpdvtd16);

    if ( FAILED(pti->scResult) )
    {
        pfnFree(pdvtd32, dvtdi.cbConvertSize);
        return pti->scResult;
    }

    *ppdvtd32 = pdvtd32;
    *pcbSize = dvtdi.cbConvertSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertDvtd3216, private
//
//  Synopsis:   Converts a DVTARGETDEVICE from 32 to 16-bits
//
//  Arguments:  [pti] - Thunking state information
//              [pdvtd32] - Source
//              [pfnAlloc] - Allocator
//              [pfnFree] - Freer
//              [ppvdvtd16] - Destination
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvdvtd16]
//              [pcbSize]
//
//  History:    18-Apr-94       DrewB   Created
//
//  Notes:      [pfnAlloc/Free] must deal with 16-bit memory
//
//----------------------------------------------------------------------------

SCODE ConvertDvtd3216(THUNKINFO *pti,
                      DVTARGETDEVICE *pdvtd32,
                      ALLOCROUTINE pfnAlloc,
                      FREEROUTINE pfnFree,
                      VPVOID *ppvdvtd16,
                      UINT *pcbSize)
{
    DVTARGETDEVICE UNALIGNED *pdvtd16;
    VPVOID vpdvtd16;
    DVTDINFO dvtdi;

    if (IsBadReadPtr(pdvtd32, sizeof(DVTARGETDEVICE)) ||
        IsBadReadPtr(pdvtd32, pdvtd32->tdSize))
    {
        return E_INVALIDARG;
    }

    pti->scResult = UtGetDvtd32Info( pdvtd32, &dvtdi );

    if ( FAILED(pti->scResult) )
    {
        return pti->scResult;
    }

    vpdvtd16 = (VPVOID)pfnAlloc(dvtdi.cbConvertSize);
    if (vpdvtd16 == 0)
    {
        return E_OUTOFMEMORY;
    }

    pdvtd16 = (DVTARGETDEVICE UNALIGNED *)WOWFIXVDMPTR(vpdvtd16,
                                                       dvtdi.cbConvertSize);

    pti->scResult = UtConvertDvtd32toDvtd16( pdvtd32, &dvtdi, pdvtd16 );

    WOWRELVDMPTR(vpdvtd16);

    if ( FAILED(pti->scResult) )
    {
        pfnFree((void *)vpdvtd16, dvtdi.cbConvertSize);
        return pti->scResult;
    }

    *ppvdvtd16 = vpdvtd16;
    *pcbSize = dvtdi.cbConvertSize;

    return S_OK;
}

SCODE ConvertHDrop1632(HMEM16 hg16, HGLOBAL* phg32)
{
    SCODE sc = S_OK;

    *phg32 = CopyDropFilesFrom16(hg16);
    if (!*phg32)
        sc = E_INVALIDARG;

    return sc;
}


SCODE ConvertHDrop3216(HGLOBAL hg32, HMEM16* phg16)
{
    SCODE sc = S_OK;

    *phg16 = CopyDropFilesFrom32(hg32);
    if (!*phg16)
        sc = E_INVALIDARG;

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Function:   ConvertHGlobal1632, public
//
//  Synopsis:   Creates a 32-bit HGLOBAL for a 16-bit HGLOBAL
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [hg16] - 16-bit HGLOBAL
//              [thopInOut] - Validation type
//              [phg32] - 32-bit HGLOBAL in/out
//              [pdwSize] - Size in/out
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg32]
//              [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      If [phg32] is non-NULL on entry, [pdwSize] must be set
//              appropriately also
//
//----------------------------------------------------------------------------

SCODE ConvertHGlobal1632(THUNKINFO *pti,
                         HMEM16 hg16,
                         THOP thopInOut,
                         HGLOBAL *phg32,
                         DWORD *pdwSize)
{
    SCODE sc;
    VPVOID vpdata16;
    LPVOID lpdata16;
    LPVOID lpdata32;
    HGLOBAL hg32;
    DWORD dwSize;
    BOOL fOwn;

    sc = S_OK;

    vpdata16 = WOWGlobalLockSize16( hg16, &dwSize );
    if ( vpdata16 == 0 )
    {
        sc = E_INVALIDARG;
    }
    else
    {
        if (*phg32 != 0 && *pdwSize == dwSize)
        {
            hg32 = *phg32;
            fOwn = FALSE;
        }
        else
        {
            hg32 = GlobalAlloc( GMEM_MOVEABLE, dwSize );
            fOwn = TRUE;
        }

        if ( hg32 == 0 )
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            lpdata32 = GlobalLock( hg32 );

            lpdata16 = (LPVOID)ValidatePtr16(pti, vpdata16, dwSize, thopInOut);
            if ( lpdata16 != NULL )
            {
                memcpy( lpdata32, lpdata16, dwSize );
                WOWRELVDMPTR(vpdata16);
            }
            else
            {
                sc = pti->scResult;
            }

            GlobalUnlock(hg32);

            if (FAILED(sc) && fOwn)
            {
                GlobalFree(hg32);
            }
        }

        WOWGlobalUnlock16( hg16 );
    }

    if (SUCCEEDED(sc))
    {
        if (*phg32 != 0 && hg32 != *phg32)
        {
            GlobalFree(*phg32);
        }

        *phg32 = hg32;
        *pdwSize = dwSize;

        thkDebugOut((DEB_ARGS, "1632    HGLOBAL: 0x%04X -> 0x%p, %u\n",
                     hg16, hg32, dwSize));
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertHGlobal3216, public
//
//  Synopsis:   Creates a 16-bit HGLOBAL for a 32-bit HGLOBAL
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [hg32] - 32-bit HGLOBAL
//              [thopInOut] - Validation type
//              [phg16] - 16-bit HGLOBAL in/out
//              [pdwSize] - Size in/out
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg16]
//              [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      If [phg16] is non-NULL on entry, [pdwSize] must be set
//              appropriately also
//
//----------------------------------------------------------------------------

SCODE ConvertHGlobal3216(THUNKINFO *pti,
                         HGLOBAL hg32,
                         THOP thopInOut,
                         HMEM16 *phg16,
                         DWORD *pdwSize)
{
    SCODE sc;
    VPVOID vpdata16;
    LPVOID lpdata16;
    LPVOID lpdata32;
    HMEM16 hg16;
    DWORD dwSize;
    BOOL fOwn;

    sc = S_OK;

    dwSize = (DWORD) GlobalSize(hg32);
    if (dwSize == 0)
    {
        sc = E_INVALIDARG;
    }
    else
    {
        lpdata32 = GlobalLock(hg32);

        if (*phg16 != 0 && *pdwSize == dwSize)
        {
            hg16 = *phg16;
            vpdata16 = WOWGlobalLock16(hg16);
            fOwn = FALSE;
        }
        else
        {
            vpdata16 = WOWGlobalAllocLock16(GMEM_MOVEABLE | GMEM_DDESHARE,
                                            dwSize, &hg16);
            fOwn = TRUE;
        }

        if (vpdata16 == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            lpdata16 = (LPVOID)WOWFIXVDMPTR( vpdata16, dwSize );
            if ( lpdata16 == NULL )
            {
                sc = E_UNEXPECTED;
            }
            else
            {
                memcpy( lpdata16, lpdata32, dwSize );

                WOWRELVDMPTR(vpdata16);
            }

            WOWGlobalUnlock16( hg16 );

            if (FAILED(sc) && fOwn)
            {
                WOWGlobalFree16(hg16);
            }
        }

        GlobalUnlock(hg32);
    }

    if (SUCCEEDED(sc))
    {
        if (*phg16 != 0 && hg16 != *phg16)
        {
            WOWGlobalFree16(*phg16);
        }

        *phg16 = hg16;
        *pdwSize = dwSize;

        thkDebugOut((DEB_ARGS, "3216    HGLOBAL: 0x%p -> 0x%04X, %u\n",
                     hg32, hg16, dwSize));
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertMfPict1632, public
//
//  Synopsis:   Converts a 16-bit METAFILEPICT to 32-bit
//
//  Arguments:  [pti] - Thunk info
//              [hg16] - 16-bit HGLOBAL containing METAFILEPICT
//              [phg32] - 32-bit HGLOBAL return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg32]
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

 SCODE ConvertMfPict1632(THUNKINFO *pti,
                               HMEM16 hg16,
                               HGLOBAL *phg32)
{
    SCODE sc;
    VPVOID vpmfp16;
    METAFILEPICT16 UNALIGNED *pmfp16;
    METAFILEPICT *pmfp32;
    HGLOBAL hg32;
    DWORD dwSize;
#if DBG == 1
    BOOL fSaveToFile = FALSE;
#endif

    thkDebugOut((DEB_ITRACE, "In  ConvertMfPict1632(%p, 0x%04X, %p)\n",
                 pti, hg16, phg32));

    *phg32 = 0;
    sc = S_OK;

    vpmfp16 = WOWGlobalLockSize16( hg16, &dwSize );
    if ( vpmfp16 == 0 || dwSize < sizeof(METAFILEPICT16))
    {
        sc = E_INVALIDARG;
    }
    else
    {
        hg32 = GlobalAlloc( GMEM_MOVEABLE, sizeof(METAFILEPICT) );
        if ( hg32 == 0 )
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            pmfp32 = (METAFILEPICT *)GlobalLock( hg32 );

            pmfp16 = (METAFILEPICT16 UNALIGNED *)GetReadPtr16(pti, vpmfp16,
                                                              dwSize);
            if ( pmfp16 != NULL )
            {
                pmfp32->mm = (LONG)pmfp16->mm;
                pmfp32->xExt = (LONG)pmfp16->xExt;
                pmfp32->yExt = (LONG)pmfp16->yExt;

                pmfp32->hMF = HMETAFILE_32(pmfp16->hMF);

                thkDebugOut((DEB_ARGS, "1632    METAFILEPICT: "
                         "{%d, %d, %d, 0x%p} -> {%d, %d, %d, 0x%4x}\n",
                         pmfp16->mm, pmfp16->xExt, pmfp16->yExt, pmfp16->hMF,
                         pmfp32->mm, pmfp32->xExt, pmfp32->yExt, pmfp32->hMF));

                WOWRELVDMPTR(vpmfp16);

#if DBG == 1
                if (fSaveToFile)
                {
                    HMETAFILE hmf;

                    hmf = CopyMetaFile(pmfp32->hMF, __TEXT("thkmf.wmf"));
                    if (hmf != NULL)
                    {
                        DeleteMetaFile(hmf);
                    }
                }
#endif
            }
            else
            {
                sc = pti->scResult;
            }

            GlobalUnlock(hg32);

            if (FAILED(sc))
            {
                GlobalFree(hg32);
            }
        }

        WOWGlobalUnlock16( hg16 );
    }

    if (SUCCEEDED(sc))
    {
        *phg32 = hg32;
    }

    thkDebugOut((DEB_ITRACE, "Out ConvertMfPict1632 => 0x%08lX, 0x%p\n",
                 sc, *phg32));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertMfPict3216, public
//
//  Synopsis:   Converts a 32-bit METAFILEPICT to 16-bit
//
//  Arguments:  [pti] - Thunk info
//              [hg32] - 32-bit HGLOBAL containing METAFILEPICT
//              [phg16] - 16-bit HGLOBAL return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg16]
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

 SCODE ConvertMfPict3216(THUNKINFO *pti,
                               HGLOBAL hg32,
                               HMEM16 *phg16)
{
    SCODE sc;
    VPVOID vpmfp16;
    METAFILEPICT16 UNALIGNED *pmfp16;
    METAFILEPICT *pmfp32;
    DWORD dwSize;
    HMEM16 hg16;
#if DBG == 1
    BOOL fSaveToFile = FALSE;
#endif

    thkDebugOut((DEB_ITRACE, "In  ConvertMfPict3216(%p, 0x%p, %p)\n",
                 pti, hg32, phg16));

    *phg16 = 0;
    sc = S_OK;

    dwSize = (DWORD) GlobalSize(hg32);
    pmfp32 = (METAFILEPICT *)GlobalLock(hg32);
    if (dwSize == 0 || dwSize < sizeof(METAFILEPICT) || pmfp32 == NULL)
    {
        sc = E_INVALIDARG;
    }
    else
    {
        vpmfp16 = WOWGlobalAllocLock16(GMEM_MOVEABLE | GMEM_DDESHARE,
                                       sizeof(METAFILEPICT16), &hg16);
        if (vpmfp16 == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            pmfp16 = FIXVDMPTR(vpmfp16, METAFILEPICT16);
            if ( pmfp16 != NULL )
            {
                pmfp16->mm = (SHORT)pmfp32->mm;
                pmfp16->xExt = ClampLongToShort(pmfp32->xExt);
                pmfp16->yExt = ClampLongToShort(pmfp32->yExt);
                pmfp16->hMF = HMETAFILE_16(pmfp32->hMF);

                thkDebugOut((DEB_ARGS, "3216    METAFILEPICT: "
                         "{%d, %d, %d, 0x%p} -> {%d, %d, %d, 0x%4x}\n",
                         pmfp32->mm, pmfp32->xExt, pmfp32->yExt, pmfp32->hMF,
                         pmfp16->mm, pmfp16->xExt, pmfp16->yExt, pmfp16->hMF));

                RELVDMPTR(vpmfp16);

#if DBG == 1
                if (fSaveToFile)
                {
                    HMETAFILE hmf;

                    hmf = CopyMetaFile(pmfp32->hMF, __TEXT("thkmf.wmf"));
                    if (hmf != NULL)
                    {
                        DeleteMetaFile(hmf);
                    }
                }
#endif
            }
            else
            {
                sc = E_UNEXPECTED;
            }

            WOWGlobalUnlock16(hg16);

            if (FAILED(sc))
            {
                WOWGlobalFree16(hg16);
            }
        }

        GlobalUnlock(hg32);
    }

    if (SUCCEEDED(sc))
    {
        *phg16 = hg16;
    }

    thkDebugOut((DEB_ITRACE, "Out ConvertMfPict3216 => 0x%08lX, 0x%04X\n",
                 sc, *phg16));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertObjDesc1632, public
//
//  Synopsis:   Converts an OBJECTDESCRIPTOR structure
//
//  Arguments:  [pti] - THUNKINFO
//              [hg16] - HGLOBAL containing structure
//              [phg32] - Output HGLOBAL
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg32]
//
//  History:    04-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE ConvertObjDesc1632(THUNKINFO *pti,
                         HMEM16 hg16,
                         HGLOBAL *phg32)
{
    SCODE sc;
    VPVOID vp16;
    HGLOBAL hg32;
    DWORD dwSize;
    OBJECTDESCRIPTOR UNALIGNED *pod16;
    OBJECTDESCRIPTOR *pod32;
    char *pszFutn, *pszSoc;
    UINT cchFutn, cchSoc;
    UINT cbOffset;

    sc = S_OK;

	*phg32 = NULL;

    vp16 = WOWGlobalLock16(hg16);
    if ( vp16 == 0 )
    {
        return E_INVALIDARG;
    }

    pszFutn = NULL;
    pszSoc = NULL;

    pod16 = (OBJECTDESCRIPTOR UNALIGNED *)
        GetReadPtr16(pti, vp16, sizeof(OBJECTDESCRIPTOR));
    if (pod16 == NULL)
    {
        sc = pti->scResult;
        goto EH_Unlock;
    }

    dwSize = sizeof(OBJECTDESCRIPTOR);

    if (pod16->dwFullUserTypeName > 0)
    {
        pszFutn = (char *)GetStringPtr16(pti, vp16+pod16->dwFullUserTypeName,
                                         CCHMAXSTRING, &cchFutn);
        if (pszFutn == NULL)
        {
            sc = pti->scResult;
            goto EH_Unlock;
        }

        dwSize += cchFutn*sizeof(WCHAR);
    }

    if (pod16->dwSrcOfCopy > 0)
    {
        pszSoc = (char *)GetStringPtr16(pti, vp16+pod16->dwSrcOfCopy,
                                        CCHMAXSTRING, &cchSoc);
        if (pszSoc == NULL)
        {
            sc = pti->scResult;
            goto EH_Unlock;
        }

        dwSize += cchSoc*sizeof(WCHAR);
    }

    hg32 = GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if ( hg32 == 0 )
    {
        sc = E_OUTOFMEMORY;
        goto EH_Unlock;
    }

    pod32 = (OBJECTDESCRIPTOR *)GlobalLock(hg32);
    memcpy(pod32, pod16, sizeof(OBJECTDESCRIPTOR));
    pod32->cbSize = dwSize;

    cbOffset = sizeof(OBJECTDESCRIPTOR);

    if (pod16->dwFullUserTypeName > 0)
    {
        if (MultiByteToWideChar(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pszFutn, cchFutn,
                                (WCHAR *)((BYTE *)pod32+cbOffset),
                                cchFutn) == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod32->dwFullUserTypeName = cbOffset;
        cbOffset += cchFutn*sizeof(WCHAR);
    }

    if (pod16->dwSrcOfCopy > 0)
    {
        if (MultiByteToWideChar(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pszSoc, cchSoc,
                                (WCHAR *)((BYTE *)pod32+cbOffset),
                                cchSoc)  == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod32->dwSrcOfCopy = cbOffset;
        cbOffset += cchFutn*sizeof(WCHAR);
    }

#if DBG == 1
    WCHAR *pwcsFutn, *pwcsSoc;
    if (pod32->dwFullUserTypeName > 0)
    {
        pwcsFutn = (WCHAR *)((BYTE *)pod32+pod32->dwFullUserTypeName);
    }
    else
    {
        pwcsFutn = NULL;
    }
    if (pod32->dwSrcOfCopy > 0)
    {
        pwcsSoc = (WCHAR *)((BYTE *)pod32+pod32->dwSrcOfCopy);
    }
    else
    {
        pwcsSoc = NULL;
    }
    thkDebugOut((DEB_ARGS, "1632    OBJECTDESCRIPTOR: "
                 "{%d, ..., \"%ws\" (%s), \"%ws\" (%s)} %p -> %p\n",
                 pod32->cbSize, pwcsFutn, pszFutn, pwcsSoc, pszSoc,
                 vp16, pod32));
#endif

    GlobalUnlock(hg32);

    *phg32 = hg32;

 EH_Unlock:
    if (pszFutn != NULL)
    {
        WOWRELVDMPTR(vp16+pod16->dwFullUserTypeName);
    }
    if (pszSoc != NULL)
    {
        WOWRELVDMPTR(vp16+pod16->dwSrcOfCopy);
    }
    if (pod16 != NULL)
    {
        WOWRELVDMPTR(vp16);
    }

    WOWGlobalUnlock16(hg16);

    return sc;

 EH_Free:
    GlobalUnlock(hg32);
    GlobalFree(hg32);
    goto EH_Unlock;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertObjDesc3216, public
//
//  Synopsis:   Converts an OBJECTDESCRIPTOR structure
//
//  Arguments:  [pti] - THUNKINFO
//              [hg32] - HGLOBAL containing structure
//              [phg16] - Output HGLOBAL
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg16]
//
//  History:    04-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE ConvertObjDesc3216(THUNKINFO *pti,
                         HGLOBAL hg32,
                         HMEM16 *phg16)
{
    SCODE sc;
    VPVOID vp16;
    HMEM16 hg16;
    DWORD dwSize;
    OBJECTDESCRIPTOR UNALIGNED *pod16;
    OBJECTDESCRIPTOR *pod32;
    WCHAR *pwcsFutn, *pwcsSoc;
    UINT cchFutn, cchSoc;
    UINT cbOffset;

    sc = S_OK;

    pod32 = (OBJECTDESCRIPTOR *)GlobalLock(hg32);
    if ( pod32 == 0 )
    {
        return E_INVALIDARG;
    }

    if (IsBadReadPtr(pod32, sizeof(OBJECTDESCRIPTOR)))
    {
        sc = E_INVALIDARG;
        goto EH_Unlock;
    }

    dwSize = sizeof(OBJECTDESCRIPTOR);

    pwcsFutn = NULL;
    if (pod32->dwFullUserTypeName > 0)
    {
        pwcsFutn = (WCHAR *)((BYTE *)pod32+pod32->dwFullUserTypeName);
        if (IsBadStringPtrW(pwcsFutn, CCHMAXSTRING))
        {
            sc = E_INVALIDARG;
            goto EH_Unlock;
        }

        cchFutn = lstrlenW(pwcsFutn)+1;
        dwSize += cchFutn*2;
    }

    pwcsSoc = NULL;
    if (pod32->dwSrcOfCopy > 0)
    {
        pwcsSoc = (WCHAR *)((BYTE *)pod32+pod32->dwSrcOfCopy);
        if (IsBadStringPtrW(pwcsSoc, CCHMAXSTRING))
        {
            sc = E_INVALIDARG;
            goto EH_Unlock;
        }

        cchSoc = lstrlenW(pwcsSoc)+1;
        dwSize += cchSoc*2;
    }

    vp16 = WOWGlobalAllocLock16(GMEM_MOVEABLE, dwSize, &hg16);
    if ( vp16 == 0 )
    {
        sc = E_OUTOFMEMORY;
        goto EH_Unlock;
    }

    pod16 = FIXVDMPTR(vp16, OBJECTDESCRIPTOR);
    memcpy(pod16, pod32, sizeof(OBJECTDESCRIPTOR));
    pod16->cbSize = dwSize;

    cbOffset = sizeof(OBJECTDESCRIPTOR);

    if (pod32->dwFullUserTypeName > 0)
    {
        if (WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pwcsFutn, cchFutn,
                                (char *)pod16+cbOffset, 2 * cchFutn,
                                NULL, NULL) == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod16->dwFullUserTypeName = cbOffset;
        cbOffset += cchFutn*2;
    }

    if (pod32->dwSrcOfCopy > 0)
    {
        if (WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pwcsSoc, cchSoc,
                                (char *)pod16+cbOffset, 2 * cchSoc,
                                NULL, NULL) == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod16->dwSrcOfCopy = cbOffset;
        cbOffset += cchFutn*2;
    }

#if DBG == 1
    char *pszFutn, *pszSoc;
    if (pod16->dwFullUserTypeName > 0)
    {
        pszFutn = (char *)((BYTE *)pod16+pod16->dwFullUserTypeName);
    }
    else
    {
        pszFutn = NULL;
    }
    if (pod16->dwSrcOfCopy > 0)
    {
        pszSoc = (char *)((BYTE *)pod16+pod16->dwSrcOfCopy);
    }
    else
    {
        pszSoc = NULL;
    }
    thkDebugOut((DEB_ARGS, "3216    OBJECTDESCRIPTOR: "
                 "{%d, ..., \"%s\" (%ws), \"%s\" (%ws)} %p -> %p\n",
                 pod16->cbSize, pszFutn, pwcsFutn, pszSoc, pwcsSoc,
                 pod32, vp16));
#endif

    RELVDMPTR(vp16);

    WOWGlobalUnlock16(hg16);

    *phg16 = hg16;

 EH_Unlock:
    GlobalUnlock(hg32);

    return sc;

 EH_Free:
    WOWGlobalUnlockFree16(vp16);
    goto EH_Unlock;
}

//+---------------------------------------------------------------------------
//
//  Class:      CSm32ReleaseHandler (srh)
//
//  Purpose:    Provides punkForRelease for 16->32 STGMEDIUM conversion
//
//  Interface:  IUnknown
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

class CSm32ReleaseHandler : public IUnknown
{
public:
    CSm32ReleaseHandler(void)
    {
        _vpvForRelease = NULL;
    }
    ~CSm32ReleaseHandler(void)
    {
    }

    void Init(CThkMgr *pThkMgr,
              STGMEDIUM UNALIGNED *psm16,
              STGMEDIUM *psm32,
              VPVOID vpvForRelease,
              CLIPFORMAT cfFormat)
    {
        // Unfortunately, the MIPS compiler is not smart enough
        // to do the right thing if we just declare psm16 as UNALIGNED -- it
        // doesn't recognize that each member of the structure is also
        // unaligned when it does the structure copy.  So...to make
        // sure we don't generate an alignment fault, we just copy each
        // member of the structure directly.

        _sm16.tymed          = psm16->tymed;
        switch(_sm16.tymed) {
        case TYMED_HGLOBAL:
            _sm16.hGlobal = psm16->hGlobal;
        case TYMED_FILE:
            _sm16.lpszFileName = psm16->lpszFileName;
        case TYMED_ISTREAM:
            _sm16.pstm = psm16->pstm;
        case TYMED_ISTORAGE:
            _sm16.pstg = psm16->pstg;
        }
        _sm16.pUnkForRelease = psm16->pUnkForRelease;
        _sm32 = *psm32;
        _vpvForRelease = vpvForRelease;
        _cReferences = 1;
        _cfFormat = cfFormat;
        _pThkMgr = pThkMgr;
    }

    STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
    {
        if ( IsEqualIID(riid,IID_IUnknown) )
        {
            *ppv = this;
            AddRef();
            return NOERROR;
        }
        else
        {
            thkDebugOut((DEB_WARN, "Not a QI for IUnknown\n"));
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHOD_(ULONG, AddRef)(void)
    {
        return InterlockedIncrement(&_cReferences);
    }
    STDMETHOD_(ULONG, Release)(void);

    void CallFailed() {
        _vpvForRelease = NULL;
    }

private:
    STGMEDIUM _sm16;
    STGMEDIUM _sm32;
    VPVOID _vpvForRelease;
    CLIPFORMAT _cfFormat;
    CThkMgr *_pThkMgr;
    LONG _cReferences;
};

//+---------------------------------------------------------------------------
//
//  Member:     CSm32ReleaseHandler::Release, public
//
//  Synopsis:   Frees resources for the 32-bit copy and then
//              passes the ReleaseStgMedium on to 16-bits
//
//  Returns:    Ref count
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSm32ReleaseHandler::Release(void)
{
    STGMEDIUM UNALIGNED *psm16;
    VPVOID vpvunk;
    STGMEDIUM *psm32;
    LONG lRet;
    SCODE sc;
    BOOL fCopy;
    DWORD dwSize;

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet != 0) {
        return lRet;
    }
    
    if(_vpvForRelease) {
        // This is the last release on ReleaseHandler
        // Cleanup 32-bit STGMEDIUM after copying it to 
        // 16-bit STGMEDIUM.
        fCopy = TRUE;
    }
    else {
        // The current call failed.
        // As the fields in the 16-bit STGMEDIUM are not longer valid,
        // cleanup the 32-bit STGMEDIUM without copying it to
        // 16-bit STGMEDIUM
        fCopy = FALSE;
    }

    psm16 = &_sm16;
    psm32 = &_sm32;

    switch(psm32->tymed)
    {
    case TYMED_HGLOBAL:
        // Assumption that OBJECTDESCRIPTOR does not need copyback
        if (fCopy && !OBJDESC_CF(_cfFormat))
        {
            // Do we ever need to do this?
            // Is it valid to rely on the contents of the HGLOBAL
            // at release time?

            // Is this the right time to copy back?

            Assert(NULL != psm32->hGlobal);

            WOWGlobalLockSize16((HMEM16)psm16->hGlobal, &dwSize);
            WOWGlobalUnlock16((HMEM16)psm16->hGlobal);

            sc = ConvertHGlobal3216(NULL, psm32->hGlobal, 0,
                                    (HMEM16 *)&psm16->hGlobal, &dwSize);
            // What happens on errors?
            thkAssert(SUCCEEDED(sc));
        }

        GlobalFree(psm32->hGlobal);
        psm32->hGlobal = NULL;
        break;

    case TYMED_MFPICT:
        //  Chicago uses the same GDI handles for both 32bit and 16bit worlds.
        //  Don't delete the handle after a copy since Chicago doesn't actually
        //  copy the handle.
        METAFILEPICT *pmfp32;

        pmfp32 = (METAFILEPICT *)GlobalLock(psm32->hGlobal);
        DeleteMetaFile(pmfp32->hMF);
        GlobalUnlock(psm32->hGlobal);
        GlobalFree(psm32->hGlobal);
        break;

    case TYMED_FILE:
        // 32-bit handled by ReleaseStgMedium
        // Clean up 16-bit ourselves
#ifdef SM_FREE_16BIT_FILENAME
        if(fCopy) {
            // 16-bit OLE did not free the filename, so we can't
            // either.  This may lead to memory leaks, but there's not
            // really anything we can do about it
            TaskFree16((VPVOID)psm16->lpszFileName);
        }
#endif
        break;

    case TYMED_ISTREAM:
        if(fCopy) {
            // The proxy to the 16-bit stream interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 16-bit stream interface
            ReleaseOnObj16((VPVOID) psm16->pstm);
        }
        break;

    case TYMED_ISTORAGE:
        if(fCopy) {
            // The proxy to the 16-bit storage interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 16-bit storage interface
            ReleaseOnObj16((VPVOID) psm16->pstg);
        }
        break;

    case TYMED_GDI:
    case TYMED_NULL:
        // Nothing to release
        break;

    default:
        thkAssert(!"Unknown tymed in CSm32ReleaseHandler::Release");
        break;
    }

    // Call Release on the 16-bit vpvForRelease
    if(_vpvForRelease) {
        ReleaseOnObj16(_vpvForRelease);
        _vpvForRelease = NULL;
    }

    // Clean up this
    delete this;

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSm16ReleaseHandler::Init, public
//
//  Synopsis:   Initialize class
//
//  Arguments:  [psm32] - 32-bit STGMEDIUM
//              [psm16] - 16-bit STGMEDIUM
//              [vpvUnkForRelease] - Object for punkForRelease
//              [cfFormat] - Clipboard format associated with STGMEDIUM
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CSm16ReleaseHandler::Init(IUnknown *pThkMgr,
                               STGMEDIUM *psm32,
                               STGMEDIUM UNALIGNED *psm16,
                               IUnknown *punkForRelease,
                               CLIPFORMAT cfFormat)
{
    _avpfnVtbl = gdata16Data.avpfnSm16ReleaseHandlerVtbl;
    _sm32 = *psm32;

    // Unfortunately, the MIPS compiler is not smart enough
    // to do the right thing if we just (ony) declare psm16 as UNALIGNED,
    // it doesn't recognize that each member of the structure is also
    // unaligned when it does the structure copy.  So...to make
    // sure we don't generate an alignment fault, we just copy each
    // member of the structure directly.

    _sm16.tymed          = psm16->tymed;
    _sm16.hGlobal        = psm16->hGlobal;
    _sm16.pstm           = psm16->pstm;
    _sm16.pstg           = psm16->pstg;
    _sm16.pUnkForRelease = psm16->pUnkForRelease;

    _punkForRelease = punkForRelease;
    _cReferences = 1;
    _cfFormat = cfFormat;
    _pUnkThkMgr = pThkMgr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSm16ReleaseHandler_Release32, public
//
//  Synopsis:   Handles 32-bit portion of cleaning up STGMEDIUMs for
//              punkForRelease
//
//  Arguments:  [psrh] - this
//              [dw1]
//              [dw2]
//
//  Returns:    punkForRelease->Release()
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) CSm16ReleaseHandler_Release32(CSm16ReleaseHandler *psrh,
                                             DWORD dw1,
                                             DWORD dw2)
{
    STGMEDIUM UNALIGNED *psm16;
    STGMEDIUM *psm32;
    DWORD dwSize;
    SCODE sc;
    BOOL fCopy;

    if(psrh->_punkForRelease) {
        // This is the last release on ReleaseHandler
        // Cleanup 16-bit STGMEDIUM after copying it to 
        // 32-bit STGMEDIUM.
        fCopy = TRUE;
    }
    else {
        // The current call failed.
        // As the fields in the 32-bit STGMEDIUM are not longer valid,
        // cleanup the 16-bit STGMEDIUM without copying it to
        // 32-bit STGMEDIUM
        fCopy = FALSE;
    }

    psm16 = &psrh->_sm16;
    psm32 = &psrh->_sm32;
    switch(psm32->tymed)
    {
    case TYMED_FILE:
        // 16-bit code cleaned up the 16-bit name,
        // now clean up the 32-bit name
        if (fCopy) {
            TaskFree32(psm32->lpszFileName);
        }
        break;

    case TYMED_HGLOBAL:
        //  Assumption that OBJECTDESCRIPTOR does not need copyback
        if(fCopy && !OBJDESC_CF(psrh->_cfFormat))
        {
            // Do we ever need to do this?
            // Copy data back and free global memory

            dwSize = (DWORD) GlobalSize(psm32->hGlobal);

            sc = ConvertHGlobal1632(NULL, (HMEM16)psm16->hGlobal, 0,
                                    &psm32->hGlobal, &dwSize);
            // What happens on errors?
            thkAssert(SUCCEEDED(sc));
        }

        WOWGlobalFree16((HMEM16)psm16->hGlobal);
        break;

    case TYMED_MFPICT:
        // Untouched in this case
        break;

    case TYMED_ISTREAM:
        if(fCopy) {
            // The proxy to the 32-bit stream interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 32-bit stream interface
            psm32->pstm->Release();
        }
        break;

    case TYMED_ISTORAGE:
        if(fCopy) {
            // The proxy to the 32-bit stream interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 32-bit stream interface
            psm32->pstg->Release();
        }
        break;

    case TYMED_GDI:
    case TYMED_NULL:
        // Nothing to release
        break;

    default:
        thkAssert(!"Unknown tymed in ReleaseStgMedium32");
        break;
    }

    // Call Release on the 32-bit punkForRelease
    if(fCopy) {
        psrh->_punkForRelease->Release();
        psrh->_punkForRelease = NULL;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStgMed1632, public
//
//  Synopsis:   Converts a 16-bit STGMEDIUM to 32-bits
//
//  Arguments:  [pti] - Thunk info
//              [vpsm16] - VDM pointer to 16-bit STGMEDIUM
//              [psm32] - 32-bit STGMEDIUM to fill in
//              [pfe] - FORMATETC paired with STGMEDIUM or NULL
//              [pdwSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      [pdwSize] is only set for TYMED_HGLOBAL
//
//----------------------------------------------------------------------------

SCODE ConvertStgMed1632(THUNKINFO *pti,
                        VPVOID vpsm16,
                        STGMEDIUM *psm32,
                        FORMATETC *pfe,
                        BOOL fPassingOwnershipIn,
                        DWORD *pdwSize)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    CSm32ReleaseHandler *psrh;
    IUnknown *punkForRelease;
    VPVOID vpvUnk, vpvForRelease;
    HMEM16 hmem16;
    HGDIOBJ hGDI = NULL;
    THKSTATE thkstateSaved;

    psm16 = (STGMEDIUM UNALIGNED *)
        GetReadPtr16(pti, vpsm16, sizeof(STGMEDIUM));
    if (psm16 == NULL)
    {
        return pti->scResult;
    }

    sc = S_OK;

    psm32->tymed = psm16->tymed;

    vpvForRelease = (VPVOID)psm16->pUnkForRelease;
    WOWRELVDMPTR(vpsm16);

    if(vpvForRelease) {
        // Create the 32-bit punkForRelease
        thkDebugOut((DEB_WARN, "pUnkForRelease present in StgMedium1632\n"));
        psrh = new CSm32ReleaseHandler;
        if(psrh == NULL)
            return E_OUTOFMEMORY;
    }
    else {
        psrh = NULL;
    }
    psm32->pUnkForRelease = psrh;

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);

    // Word 6 insists on treating BITMAPs as HGLOBALS, which is bogus.
    // If this is the case, just patch the tymed to the correct value

    if (pfe != NULL)
    {
        if( (pfe->cfFormat == CF_BITMAP || pfe->cfFormat == CF_PALETTE ) &&
            psm16->tymed == TYMED_HGLOBAL )
        {
            DWORD dw = TlsThkGetAppCompatFlags();

            // if we are in Word 6, then hack the tymed so we thunk the
            // bitmaps as GDI objects

            if( (dw & OACF_USEGDI ) )
            {
                DWORD dwType;

                hGDI = HBITMAP_32((HBITMAP16)psm16->hBitmap);

                // make sure HGDI is either a bitmap or palette

                dwType = GetObjectType(hGDI);
                if( (pfe->cfFormat == CF_BITMAP && dwType == OBJ_BITMAP) ||
                    (pfe->cfFormat == CF_PALETTE && dwType == OBJ_PAL) )
                {
                    psm16->tymed = TYMED_GDI;
                }
                else
                {
                    thkDebugOut((DEB_WARN,
                        "WARNING! invalid bitmap or palette!\n"));
                    hGDI = NULL;
                }
            }
            else
            {
                thkDebugOut((DEB_WARN, "WARNING!  App trying to transfer a "
                    "bitmap or palette on an HGLOBAL\n"));
            }
        }
    }

    switch( psm16->tymed )
    {
    case TYMED_HGLOBAL:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        if (pfe && OBJDESC_CF(pfe->cfFormat))
        {
            sc = ConvertObjDesc1632(pti, hmem16, &psm32->hGlobal);
        }
        else if (pfe && pfe->cfFormat == CF_HDROP)
        {
            // fix for mapi forms
            // thunk CF_HDROP passed as HGLOBAL format
            sc = ConvertHDrop1632(hmem16, &psm32->hGlobal);
        }
        else
        {
            psm32->hGlobal = 0;
            sc = ConvertHGlobal1632(pti, hmem16, THOP_INOUT,
                                    &psm32->hGlobal, pdwSize);
        }
        break;

    case TYMED_MFPICT:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        sc = ConvertMfPict1632(pti, hmem16, &psm32->hGlobal);
        break;

    case TYMED_FILE:
        psm32->lpszFileName =
            Convert_VPSTR_to_LPOLESTR( pti,
                                       (VPVOID)psm16->lpszFileName,
                                       NULL, 0 );
        if (psm32->lpszFileName == NULL)
        {
            sc = pti->scResult;
        }
        else
        {
#if DBG == 1
            thkDebugOut((DEB_ARGS, "1632    TYMED_FILE: '%ws' (%s)\n",
                         psm32->lpszFileName,
                         WOWFIXVDMPTR((VPVOID)psm16->lpszFileName, 0)));
            WOWRELVDMPTR((VPVOID)psm16->lpszFileName);
#endif
        }
        RELVDMPTR(vpsm16);
        break;

    case TYMED_ISTREAM:
        vpvUnk = (VPVOID)psm16->pstm;
        RELVDMPTR(vpsm16);

        psm32->pstm =
            (LPSTREAM)pti->pThkMgr->FindProxy3216(NULL, vpvUnk, NULL,
                                                  INDEX_IIDIDX(THI_IStream), 
                                                  FALSE, NULL);
        if(psm32->pstm) {
            thkDebugOut((DEB_ARGS, "1632    TYMED_ISTREAM: %p -> %p\n",
                         vpvUnk, psm32->pstm));
        }
        else {
            sc = E_OUTOFMEMORY;
        }

        break;

    case TYMED_ISTORAGE:
        vpvUnk = (VPVOID)psm16->pstg;
        RELVDMPTR(vpsm16);

        psm32->pstg =
            (LPSTORAGE)pti->pThkMgr->FindProxy3216(NULL, vpvUnk, NULL,
                                                   INDEX_IIDIDX(THI_IStorage),
                                                   FALSE, NULL);
        if(psm32->pstg) {
            thkDebugOut((DEB_ARGS, "1632    TYMED_ISTORAGE: %p -> %p\n",
                         vpvUnk, psm32->pstg));
        }
        else {
            sc = E_OUTOFMEMORY;
        }

        break;

    case TYMED_GDI:
        // if we're in Word6, then we may have already converted the bitmap
        // or palette handle
        if( hGDI == NULL )
        {
            psm32->hBitmap = HBITMAP_32((HBITMAP16)psm16->hBitmap);
        }
        else
        {
            psm32->hBitmap = (HBITMAP)hGDI;
        }

        thkDebugOut((DEB_ARGS, "1632    TYMED_GDI: 0x%04X -> 0x%p\n",
                     psm16->hBitmap, psm32->hBitmap));
        RELVDMPTR(vpsm16);
        break;

    case TYMED_NULL:
        RELVDMPTR(vpsm16);
        break;

    default:
        RELVDMPTR(vpsm16);
        sc = E_INVALIDARG;
        break;
    }

    if (FAILED(sc))
    {
        delete psrh;
    }
    else
    {
        if (psrh)
        {
            CLIPFORMAT cf;

            if (pfe)
            {
                cf = pfe->cfFormat;
            }
            else
            {
                cf = CF_INVALID;
            }
            thkAssert(vpvForRelease);
            psrh->Init(pti->pThkMgr, FIXVDMPTR(vpsm16, STGMEDIUM), psm32,
                       vpvForRelease, cf);
            RELVDMPTR(vpsm16);
        }

#if DBG == 1
        if (pfe)
        {
            thkDebugOut((DEB_ARGS, "1632    STGMEDIUM FORMATETC %p {%d}\n",
                         pfe, pfe->cfFormat));
        }
        thkDebugOut((DEB_ARGS, "1632    STGMEDIUM: %p {%d, %p, ...} -> "
                     "%p {%d, %p, ...}\n", vpsm16, psm16->tymed,
                     psm16->pUnkForRelease, psm32, psm32->tymed,
                     psm32->pUnkForRelease));
#endif
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanStgMed32, public
//
//  Synopsis:   Cleans up a 32-bit STGMEDIUM
//
//  Arguments:  [pti] - Thunk info
//              [psm32] - STGMEDIUM to clean
//              [vpsm16] - Source STGMEDIUM if thunk
//              [dwSize] - Source size if thunk
//              [fIsThunk] - STGMEDIUM was generated by thunking
//              [pfe] - FORMATETC or NULL
//
//  Returns:    Appropriate status code
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CleanStgMed32(THUNKINFO *pti,
                    STGMEDIUM *psm32,
                    VPVOID vpsm16,
                    DWORD dwSize,
                    BOOL fIsThunk,
                    FORMATETC *pfe)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    HMEM16 hmem16;
    VPVOID vpvUnk;
    BOOL fCleanup = TRUE;

    thkDebugOut((DEB_ITRACE, "In  CleanStgMed32(%p, %p, %p, %u, %d, %p)\n",
                 pti, psm32, vpsm16, dwSize, fIsThunk, pfe));

    sc = S_OK;

    if(fIsThunk && psm32->pUnkForRelease) {
        // This means that the current call failed
        // Inform the 32-bit punkForRelease created during thunking
        // so that it would cleanup 32-bit STGMEDIUM
        ((CSm32ReleaseHandler *) (psm32->pUnkForRelease))->CallFailed();
        fCleanup = FALSE;
    }

    switch( psm32->tymed )
    {
    case TYMED_HGLOBAL:
        if (fIsThunk &&
            (pfe == NULL || !OBJDESC_CF(pfe->cfFormat)))
        {
            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            hmem16 = (HMEM16)psm16->hGlobal;
            RELVDMPTR(vpsm16);

            Assert(NULL != psm32->hGlobal);

            sc = ConvertHGlobal3216(pti, psm32->hGlobal, 0,
                                    &hmem16, &dwSize);
            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            psm16->hGlobal = (HGLOBAL)hmem16;
            RELVDMPTR(vpsm16);
        }

        if(fCleanup) {
            GlobalFree( psm32->hGlobal );
            psm32->hGlobal = NULL;
        }
        break;

    case TYMED_MFPICT:
        //  Chicago uses the same GDI handles for both 32bit and 16bit worlds.
        //  Don't delete the handle after a copy since Chicago doesn't actually
        //  copy the handle.
        if(fCleanup) {
            // Can't modify an MFPICT
            METAFILEPICT *pmfp32;

            pmfp32 = (METAFILEPICT *)GlobalLock(psm32->hGlobal);
            DeleteMetaFile(pmfp32->hMF);
            GlobalUnlock(psm32->hGlobal);
            GlobalFree(psm32->hGlobal);
        }
        break;

    case TYMED_FILE:
        Convert_VPSTR_to_LPOLESTR_free( NULL, psm32->lpszFileName );
#ifdef SM_FREE_16BIT_FILENAME
        if(fCleanup) {
            // 16-bit OLE did not free the filename, so we can't
            // either.  This may lead to memory leaks, but there's not
            // really anything we can do about it
            TaskFree16((VPVOID)psm16->lpszFileName);
        }
#endif
        break;

    case TYMED_ISTREAM:
        if(fIsThunk) {
            // Release the 32-bit stream interface
            psm32->pstm->Release();
        }
        break;

    case TYMED_ISTORAGE:
        if(fIsThunk) {
            // Release the 32-bit storage interface
            psm32->pstg->Release();
        }
        break;

    case TYMED_GDI:
        //
        // No unthunking needed
        //
        break;

    case TYMED_NULL:
        break;

    default:
        // Ignore, this case is handled on input
        thkAssert(!"STGMEDIUM with invalid tymed");
        break;
    }

    if(fIsThunk && psm32->pUnkForRelease) {
        // Release the 32-bit STGMEDIUM pUnkForRelease.
        // 32-bit STGMEDIUM would be cleaned up after the last release
        psm32->pUnkForRelease->Release();
    }

    thkDebugOut((DEB_ITRACE, "Out CleanStgMed32 => 0x%08lX\n", sc));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStgMed3216, public
//
//  Synopsis:   Converts a 32-bit STGMEDIUM to 16-bits
//
//  Arguments:  [pti] - Thunk info
//              [psm32] - 32-bit STGMEDIUM
//              [vpsm16] - VDM pointer to 16-bit STGMEDIUM
//              [pfe] - FORMATETC paired with STGMEDIUM or NULL
//              [pdwSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      [pdwSize] is only set for TYMED_HGLOBAL
//
//----------------------------------------------------------------------------

SCODE ConvertStgMed3216(THUNKINFO *pti,
                        STGMEDIUM *psm32,
                        VPVOID vpsm16,
                        FORMATETC *pfe,
                        BOOL fPassingOwnershipIn,
                        DWORD *pdwSize)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    VPVOID vpsrh;
    VPSTR vpstr;
    UINT uiSize;
    VPVOID vpvUnkForRelease;
    VPVOID vpvUnk;
    HMEM16 hmem16;
    THKSTATE thkstateSaved;

    sc = S_OK;

    if(psm32->pUnkForRelease) {
        thkDebugOut((DEB_WARN, "pUnkForRelease present in StgMedium3216\n"));
        vpsrh = WOWGlobalAllocLock16(GMEM_MOVEABLE, sizeof(CSm16ReleaseHandler),
                                     NULL);
        if(vpsrh == 0)
            return E_OUTOFMEMORY;
    }
    else {
        vpsrh = 0;
    }

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
    psm16->tymed = psm32->tymed;
    psm16->pUnkForRelease = (IUnknown *)vpsrh;
    RELVDMPTR(vpsm16);

    switch( psm32->tymed )
    {
    case TYMED_HGLOBAL:
        if (pfe && OBJDESC_CF(pfe->cfFormat))
        {
            sc = ConvertObjDesc3216(pti, psm32->hGlobal, &hmem16);
        }
        else if (pfe && pfe->cfFormat == CF_HDROP)
        {
            // fix for mapi forms
            sc = ConvertHDrop3216(psm32->hGlobal, &hmem16);
        }
        else
        {
            hmem16 = 0;
            sc = ConvertHGlobal3216(pti, psm32->hGlobal, THOP_INOUT,
                                    &hmem16, pdwSize);
        }

        psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
        psm16->hGlobal = (HGLOBAL)hmem16;
        RELVDMPTR(vpsm16);
        break;

    case TYMED_MFPICT:
        sc = ConvertMfPict3216(pti, psm32->hGlobal, &hmem16);

        psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
        psm16->hGlobal = (HGLOBAL)hmem16;
        RELVDMPTR(vpsm16);
        break;

    case TYMED_FILE:
        uiSize = lstrlenW(psm32->lpszFileName) + 1;
        vpstr = TaskMalloc16( uiSize*2 );
        if ( vpstr == NULL )
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            sc = Convert_LPOLESTR_to_VPSTR( psm32->lpszFileName,
                                            vpstr, uiSize, uiSize*2 );
            if (FAILED(sc))
            {
                TaskFree16(vpstr);
            }
            else
            {
                psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
                psm16->lpszFileName = (LPOLESTR)vpstr;
                RELVDMPTR(vpsm16);

#if DBG == 1
                thkDebugOut((DEB_ARGS, "3216    TYMED_FILE: '%s' (%ws)\n",
                             WOWFIXVDMPTR(vpstr, 0),
                             psm32->lpszFileName));
                WOWRELVDMPTR(vpstr);
#endif
            }
        }
        break;

    case TYMED_ISTREAM:
        vpvUnk = pti->pThkMgr->FindProxy1632(NULL, psm32->pstm, NULL,
                                             INDEX_IIDIDX(THI_IStream),
                                             NULL);
        if (vpvUnk == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            thkDebugOut((DEB_ARGS, "3216    TYMED_ISTREAM: %p -> %p\n",
                         psm32->pstm, vpvUnk));

            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            psm16->pstm = (IStream *)vpvUnk;
            RELVDMPTR(vpsm16);
        }
        break;

    case TYMED_ISTORAGE:
        vpvUnk = pti->pThkMgr->FindProxy1632(NULL, psm32->pstg, NULL,
                                             INDEX_IIDIDX(THI_IStorage),
                                             NULL);
        if (vpvUnk == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            thkDebugOut((DEB_ARGS, "3216    TYMED_ISTORAGE: %p -> %p\n",
                         psm32->pstg, vpvUnk));

            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            psm16->pstg = (IStorage *)vpvUnk;
            RELVDMPTR(vpsm16);
        }
        break;

    case TYMED_GDI:
        psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
        psm16->hBitmap = (HBITMAP)HBITMAP_16(psm32->hBitmap);
        thkDebugOut((DEB_ARGS, "3216    TYMED_GDI: 0x%p -> 0x%04X\n",
                     psm32->hBitmap, psm16->hBitmap));
        RELVDMPTR(vpsm16);
        break;

    case TYMED_NULL:
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    if (FAILED(sc))
    {
        if (vpsrh != 0)
        {
            WOWGlobalUnlockFree16(vpsrh);
        }
    }
    else
    {
        if (vpsrh != 0)
        {
            CSm16ReleaseHandler UNALIGNED *psrh;
            CLIPFORMAT cf;

            if (pfe)
            {
                cf = pfe->cfFormat;
            }
            else
            {
                cf = CF_INVALID;
            }
            thkAssert(psm32->pUnkForRelease);
            psrh = FIXVDMPTR(vpsrh, CSm16ReleaseHandler);
            psrh->Init(pti->pThkMgr, psm32, FIXVDMPTR(vpsm16, STGMEDIUM),
                       psm32->pUnkForRelease, cf);
            RELVDMPTR(vpsrh);
            RELVDMPTR(vpsm16);
        }

#if DBG == 1
        if (pfe)
        {
            thkDebugOut((DEB_ARGS, "3216    STGMEDIUM FORMATETC %p {%d}\n",
                         pfe, pfe->cfFormat));
        }
        thkDebugOut((DEB_ARGS, "3216    STGMEDIUM: %p {%d, %p, ...} -> "
                     "%p {%d, %p, ...}\n", psm32, psm32->tymed,
                     psm32->pUnkForRelease, vpsm16, psm16->tymed,
                     psm16->pUnkForRelease));
#endif
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanStgMed16, public
//
//  Synopsis:   Frees up resources in a 16-bit STGMEDIUM
//
//  Arguments:  [pti] - Thunk info
//              [vpsm16] - STGMEDIUM to clean
//              [psm32] - Source STGMEDIUM if thunk
//              [dwSize] - Source size for thunked HGLOBAL
//              [fIsThunk] - If the STGMEDIUM is a result of thunking
//              [pfe] - FORMATETC or NULL
//
//  Returns:    Appropriate status code
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CleanStgMed16(THUNKINFO *pti,
                    VPVOID vpsm16,
                    STGMEDIUM *psm32,
                    DWORD dwSize,
                    BOOL fIsThunk,
                    FORMATETC *pfe)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    VPVOID vpvUnk, vpv;
    HMEM16 hmem16;
    BOOL fCleanup = TRUE;

    thkDebugOut((DEB_ITRACE, "In  CleanStgMed16(%p, %p, %p, %u, %d, %p)\n",
                 pti, vpsm16, psm32, dwSize, fIsThunk, pfe));

    sc = S_OK;

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
    vpvUnk = (VPVOID)psm16->pUnkForRelease;
    RELVDMPTR(vpsm16);

    if (fIsThunk && vpvUnk)
    {
        // This means that the current call failed
        // Inform the 32-bit punkForRelease created during thunking
        // so that it would cleanup 32-bit STGMEDIUM
        CSm16ReleaseHandler UNALIGNED *psrh;

        psrh = FIXVDMPTR(vpvUnk, CSm16ReleaseHandler);
        psrh->CallFailed();
        RELVDMPTR(vpvUnk);
        fCleanup = FALSE;
    }

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
    switch( psm16->tymed )
    {
    case TYMED_HGLOBAL:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        if (fIsThunk &&
            (pfe == NULL || !OBJDESC_CF(pfe->cfFormat)))
        {
            sc = ConvertHGlobal1632(pti, hmem16, 0,
                                    &psm32->hGlobal, &dwSize);
        }

        if(fCleanup)
            WOWGlobalFree16(hmem16);

        break;

    case TYMED_MFPICT:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        //  Chicago uses the same GDI handles for both 32bit and 16bit worlds.
        //  Don't delete the handle after a copy since Chicago doesn't actually
        //  copy the handle.
        if(fCleanup) {
            VPVOID vpvmfp16;
            METAFILEPICT16 *pmfp16;
            HMEM16 hmf16;

            vpvmfp16 = WOWGlobalLock16(hmem16);
            pmfp16 = FIXVDMPTR(vpvmfp16, METAFILEPICT16);
            hmf16 = pmfp16->hMF;
            RELVDMPTR(vpvmfp16);

            // Relies on the fact that a 16-bit metafile is an HGLOBAL
            WOWGlobalFree16(hmf16);

            WOWGlobalUnlockFree16(vpvmfp16);
        }
        break;

    case TYMED_FILE:
        vpv = (VPVOID)psm16->lpszFileName;
        RELVDMPTR(vpsm16);

        if(fCleanup)
            TaskFree16(vpv);
        break;

    case TYMED_ISTREAM:
        vpv = (VPVOID) psm16->pstm;
        RELVDMPTR(vpsm16);

        if(fIsThunk) {
            // Release the 16-bit stream interface
            ReleaseOnObj16(vpv);
        }
        break;

    case TYMED_ISTORAGE:
        vpv = (VPVOID) psm16->pstg;
        RELVDMPTR(vpsm16);

        if(fIsThunk) {
            // Release the 16-bit storage interface
            ReleaseOnObj16(vpv);
        }
        break;

    case TYMED_GDI:
        RELVDMPTR(vpsm16);

        //
        // No unthunking needed
        //
        break;

    case TYMED_NULL:
        RELVDMPTR(vpsm16);

        break;

    default:
        // Ignore, this case is handled on input
        thkAssert(!"CleanStgMed16 with invalid tymed");
        break;
    }

    if(fIsThunk && vpvUnk) {
        // Release the 16-bit STGMEDIUM vpvForRelease.
        // 16-bit STGMEDIUM would be cleaned up after the last release
        ReleaseOnObj16(vpvUnk);
    }

    thkDebugOut((DEB_ITRACE, "Out CleanStgMed16 => 0x%08lX\n", sc));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertFetc1632, public
//
//  Synopsis:   Converts a FORMATETC
//
//  Arguments:  [pti] - Thunk info
//              [vpfe16] - FORMATETC
//              [pfe32] - FORMATETC
//              [fFree] - Free resources as converting
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pfe32]
//
//  History:    14-May-94       DrewB   Created
//				11-Dec-00		DickD	initialize pdv32 (prefix bug 22397)
//
//----------------------------------------------------------------------------

SCODE ConvertFetc1632(THUNKINFO *pti,
                      VPVOID vpfe16,
                      FORMATETC *pfe32,
                      BOOL fFree)
{
    FORMATETC16 UNALIGNED *pfe16;
    VPVOID vpdv16;
    DVTARGETDEVICE *pdv32 = NULL;
    UINT cbSize;
    SCODE sc;

    pfe16 = FIXVDMPTR(vpfe16, FORMATETC16);
    vpdv16 = (VPVOID)pfe16->ptd;
    RELVDMPTR(vpfe16);

    if ( vpdv16 == 0 )
    {
        pdv32 = NULL;
    }
    else
    {
        sc = ConvertDvtd1632(pti, vpdv16, ArTask32, FrTask32,
                             &pdv32, &cbSize);

        if (fFree)
        {
            TaskFree16(vpdv16);
        }

        if (FAILED(sc))
        {
            return sc;
        }
    }

    pfe16 = FIXVDMPTR(vpfe16, FORMATETC16);
    pfe32->cfFormat = pfe16->cfFormat;
    pfe32->ptd      = pdv32;
    pfe32->dwAspect = pfe16->dwAspect;
    pfe32->lindex   = pfe16->lindex;
    pfe32->tymed    = pfe16->tymed;

    thkDebugOut((DEB_ARGS, "1632    FORMATETC: "
                 "%p -> %p {%d, %p (%p), %u, %u, 0x%X}\n",
                 vpfe16, pfe32,
                 pfe32->cfFormat,
                 pfe32->ptd, vpdv16,
                 pfe32->dwAspect,
                 pfe32->lindex,
                 pfe32->tymed));

    RELVDMPTR(vpfe16);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertFetc3216, public
//
//  Synopsis:   Converts a FORMATETC
//
//  Arguments:  [pti] - Thunk info
//              [pfe32] - FORMATETC
//              [vpfe16] - FORMATETC
//              [fFree] - Free resources as converting
//
//  Returns:    Appropriate status code
//
//  Modifies:   [vpfe16]
//
//  History:    14-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE ConvertFetc3216(THUNKINFO *pti,
                      FORMATETC *pfe32,
                      VPVOID vpfe16,
                      BOOL fFree)
{
    FORMATETC16 UNALIGNED *pfe16;
    DVTARGETDEVICE *pdv32;
    SCODE sc;
    VPVOID vpdv16;
    UINT cbSize;

    pdv32 = pfe32->ptd;
    if (pdv32 != NULL)
    {
        sc = ConvertDvtd3216(pti, pdv32, ArTask16, FrTask16,
                             &vpdv16, &cbSize);

        if (fFree)
        {
            TaskFree32(pdv32);
        }

        if (FAILED(sc))
        {
            return sc;
        }
    }
    else
    {
        vpdv16 = 0;
    }

    pfe16 = FIXVDMPTR(vpfe16, FORMATETC16);
    pfe16->cfFormat = pfe32->cfFormat;
    pfe16->ptd      = vpdv16;
    pfe16->dwAspect = pfe32->dwAspect;
    pfe16->lindex   = pfe32->lindex;
    pfe16->tymed    = pfe32->tymed;

    thkDebugOut((DEB_ARGS, "3216    FORMATETC: "
                 "%p -> %p {%d, %p (%p), %u, %u, 0x%X}\n",
                 pfe32, vpfe16,
                 pfe16->cfFormat,
                 vpdv16, pdv32,
                 pfe16->dwAspect,
                 pfe16->lindex,
                 pfe16->tymed));

    RELVDMPTR(vpfe16);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DebugValidateProxy1632, debug public
//
//  Synopsis:   Validates a 16->32 proxy pointer and its memory
//
//  Arguments:  [vpvProxy] - Proxy
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void DebugValidateProxy1632(VPVOID vpvProxy)
{
    THUNK1632OBJ UNALIGNED *pto;
    THUNKINFO ti;

    thkAssert(vpvProxy != 0 && "Invalid proxy pointer");

    pto = (THUNK1632OBJ UNALIGNED *)
        GetReadWritePtr16(&ti, vpvProxy, sizeof(THUNK1632OBJ));
    thkAssert(pto != NULL && "Invalid proxy pointer");

    thkAssert(pto->dwSignature == PSIG1632 && "Dead or invalid proxy!");

    thkAssert(pto->cRefLocal>=0 && "Invalid proxy refcount");
    thkAssert(pto->cRefLocal>=pto->cRef && "Invalid proxy refcount");
    thkAssert((pto->cRefLocal>0 && pto->cRef>0) || (pto->cRef==0 && pto->cRefLocal==0));
    thkAssert(pto->pphHolder && "Proxy without a holder");

    if (!IsValidInterface(pto->punkThis32))
    {
        thkDebugOut((DEB_ERROR, "1632 %p: Invalid proxied object %p\n",
                     vpvProxy, pto->punkThis32));
    }

    WOWRELVDMPTR(vpvProxy);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DebugValidateProxy3216, debug public
//
//  Synopsis:   Validates a 32->16 proxy pointer and its memory
//
//  Arguments:  [pto] - Proxy
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void DebugValidateProxy3216(THUNK3216OBJ *pto)
{
    THUNKINFO ti;

    thkAssert(pto != 0 && "Invalid proxy pointer");

    thkAssert(!IsBadReadPtr(pto, sizeof(THUNK3216OBJ)) &&
              !IsBadWritePtr(pto, sizeof(THUNK3216OBJ)) &&
              "Invalid proxy pointer");

    thkAssert(pto->dwSignature == PSIG3216 && "Dead or invalid proxy!");

    thkAssert(pto->cRefLocal>=0 && "Invalid proxy refcount");
    thkAssert(pto->cRefLocal>=pto->cRef && "Invalid proxy refcount");
    thkAssert((pto->cRefLocal>0 && pto->cRef>0) || (pto->cRef==0 && pto->cRefLocal==0));
    thkAssert(pto->pphHolder && "Proxy without a holder");

    if (!IsValidInterface16(&ti, pto->vpvThis16))
    {
        thkDebugOut((DEB_ERROR, "3216 %p: Invalid proxied object %p\n",
                     pto, pto->vpvThis16));
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ClampLongToShort, public
//
//  Synopsis:   Restricts a long value to a short value by clamping
//
//  Arguments:  [l] - Long
//
//  Returns:    Short
//
//  History:    16-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

SHORT ClampLongToShort(LONG l)
{
    SHORT s;

    if (l < SHRT_MIN)
    {
        s = SHRT_MIN;
        thkDebugOut((DEB_WARN, "ClampLongToShort: %ld -> %d\n", l, s));
    }
    else if (l > SHRT_MAX)
    {
        s = SHRT_MAX;
        thkDebugOut((DEB_WARN, "ClampLongToShort: %ld -> %d\n", l, s));
    }
    else
    {
        s = (SHORT)l;
    }

    return s;
}

//+---------------------------------------------------------------------------
//
//  Function:   ClampULongToUShort, public
//
//  Synopsis:   Restricts an unsigned long value to an unsigned short value
//              by clamping
//
//  Arguments:  [ul] - Long
//
//  Returns:    UShort
//
//  History:    16-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

USHORT ClampULongToUShort(ULONG ul)
{
    USHORT us;

    if (ul > USHRT_MAX)
    {
        us = USHRT_MAX;
        thkDebugOut((DEB_WARN, "ClampULongToUShort: %ld -> %d\n", ul, us));
    }
    else
    {
        us = (USHORT)ul;
    }

    return us;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertObjDescriptor
//
//  Synopsis:   Exported API called by WOW to convert ObjectDescriptors to
//              the indicated format.
//
//
//  Arguments:  [hMem] --  Handle to the ObjectDescriptor to convert.
//              [flag] --  Flag indicating which direction the convertion
//              should take place.  Valid values are:
//                          CFOLE_UNICODE_TO_ANSI.
//                          CFOLE_ANSI_TO_UNICODE.
//
//  Returns:    HGLOBAL to the converted ObjectDescriptor,
//              or NULL on failure.
//
//  History:    8-16-94   terryru   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(HGLOBAL) ConvertObjDescriptor( HANDLE hMem, UINT flag )
{

   const UINT CFOLE_UNICODE_TO_ANSI = 0;
   const UINT CFOLE_ANSI_TO_UNICODE = 1;

   THUNKINFO ti;
   HGLOBAL hMem32;
   HMEM16  hMem16;

    switch ( flag )
    {
    case CFOLE_UNICODE_TO_ANSI:
        if( FAILED( ConvertObjDesc3216( &ti, (HGLOBAL) hMem, &hMem16 )))
        {
            return (HGLOBAL) NULL;
        }
        else
        {
            return (HGLOBAL)  hMem16;
        }
        break;

    case CFOLE_ANSI_TO_UNICODE:
        if( FAILED( ConvertObjDesc1632( &ti, (HMEM16) hMem, &hMem32 )))
        {
            return (HGLOBAL) NULL;
        }
        else
        {
            return (HGLOBAL) hMem32;
        }
        break;

    default:
        thkAssert(!"ConvertObjDescriptor, Invalid flag");
        break;
    }
    return (HGLOBAL) NULL;
}

#define UnicodeToAnsi(sz,pwsz,cb) WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz, cb, NULL, NULL)


#if DBG==1
int AnsiToUnicode(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;

    ret = MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, sz, -1, pwsz, cb);

    thkAssert(ret != 0 && "Lost characters in thk Ansi->Unicode conversion");
    if (ret == 0)
    {
        DebugBreak();
    }

    return ret;
}
#else
#define AnsiToUnicode(pwsz,sz,cb) MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, sz, -1, pwsz, cb)
#endif



extern "C"
DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszFullPath,
    LPWSTR  lpszShortPath,
    DWORD   cchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetShortPathName\n");
    #endif

    CHAR  szFullPath[MAX_PATH];
    CHAR  szShortBuffer[MAX_PATH];
    DWORD ret;


    UnicodeToAnsi(szFullPath, lpszFullPath, sizeof(szFullPath));

    if (lpszShortPath == NULL)
    {
        ret = GetShortPathNameA(szFullPath, NULL, cchBuffer);
    }
    else
    {
        ret = GetShortPathNameA(szFullPath, szShortBuffer,
                                sizeof(szShortBuffer));

        thkAssert(ret != cchBuffer &&
                  "GetShortPathName - Output buffer too short");
        //
        // Don't convert the buffer if the
        // call to GetShortPathNameA() failed.
        //
        if(0 != ret)
        {
            //
            //  Only convert the actual data, not the whole buffer.
            //
            if (cchBuffer > ret + 1)
                cchBuffer = ret + 1;

            AnsiToUnicode(lpszShortPath, szShortBuffer, cchBuffer);
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thopsapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thopsapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

THOP CONST thopsCoInitialize[] =
{
    THOP_IFACE | THOP_IN, THI_IMalloc, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoUninitialize[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsCoGetClassObject[] =
{
    THOP_COPY | THOP_IN, 16, THOP_CLSCONTEXT, THOP_NULL | THOP_IN, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsCoRegisterClassObject[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_CLSCONTEXT, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsCoRevokeClassObject[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoMarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsCoUnmarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCoReleaseMarshalData[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoDisconnectObject[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoLockObjectExternal[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCoGetStandardMarshal[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IMarshal, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsCoIsHandlerConnected[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoFreeAllLibraries[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsCoFreeUnusedLibraries[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsCoCreateInstance[] =
{
    THOP_COPY | THOP_IN, 16, THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_CLSCONTEXT, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 12, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsCLSIDFromString[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoIsOle1Class[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsProgIDFromCLSID[] =
{
    THOP_COPY | THOP_IN, 16, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCLSIDFromProgID[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoCreateGuid[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoFileTimeToDosDateTime[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_COPY | THOP_IN, 8, THOP_WORDDWORD | THOP_OUT, THOP_WORDDWORD | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCoDosDateTimeToFileTime[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_WORDDWORD, THOP_WORDDWORD, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 8
};
THOP CONST thopsCoFileTimeNow[] =
{
    THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoRegisterMessageFilter[] =
{
    THOP_IFACE | THOP_IN, THI_IMessageFilter, THOP_IFACE | THOP_OUT, THI_IMessageFilter, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoGetTreatAsClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoTreatAsClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsDllGetClassObject[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsStgCreateDocfile[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsStgCreateDocfileOnILockBytes[] =
{
    THOP_IFACE | THOP_IN, THI_ILockBytes, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsStgOpenStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY, 4, THOP_SNB, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsStgOpenStorageOnILockBytes[] =
{
    THOP_IFACE | THOP_IN, THI_ILockBytes, THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY, 4, THOP_SNB, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsStgIsStorageFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsStgIsStorageILockBytes[] =
{
    THOP_IFACE | THOP_IN, THI_ILockBytes, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsStgSetTimes[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsCreateDataAdviseHolder[] =
{
    THOP_IFACE | THOP_OUT, THI_IDataAdviseHolder, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCreateDataCache[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 12, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsBindMoniker[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY, 4, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsMkParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsMonikerRelativePathTo[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsMonikerCommonPrefixWith[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCreateBindCtx[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCreateGenericComposite[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsGetClassFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCreateFileMoniker[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCreateItemMoniker[] =
{
    THOP_LPSTR | THOP_IN, THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCreateAntiMoniker[] =
{
    THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCreatePointerMoniker[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsGetRunningObjectTable[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IRunningObjectTable, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsReadClassStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsWriteClassStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsReadClassStm[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsWriteClassStm[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsWriteFmtUserTypeStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 19
};
THOP CONST thopsReadFmtUserTypeStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD | THOP_OUT, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleInitialize[] =
{
    THOP_IFACE | THOP_IN, THI_IMalloc, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleUninitialize[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsOleQueryLinkFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleQueryCreateFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleCreate[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateLinkFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateStaticFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateLink[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateLinkToFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateFromFile[] =
{
    THOP_COPY | THOP_IN, 16, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END,
    THOP_ROUTINEINDEX, 20
};
THOP CONST thopsOleLoad[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACEGEN | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleSave[] =
{
    THOP_IFACE | THOP_IN, THI_IPersistStorage, THOP_IFACE | THOP_IN, THI_IStorage, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleLoadFromStream[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleSaveToStream[] =
{
    THOP_IFACE | THOP_IN, THI_IPersistStream, THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleSetContainedObject[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleNoteObjectVisible[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsRegisterDragDrop[] =
{
    THOP_HUSER, THOP_IFACE | THOP_IN, THI_IDropTarget, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsRevokeDragDrop[] =
{
    THOP_HUSER, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsDoDragDrop[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_IFACE | THOP_IN, THI_IDropSource, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleSetClipboard[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleGetClipboard[] =
{
    THOP_IFACE | THOP_OUT, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleFlushClipboard[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsOleIsCurrentClipboard[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleCreateMenuDescriptor[] =
{
    THOP_RETURNTYPE, THOP_ALIAS32, ALIAS_CREATE, THOP_HUSER, THOP_COPY | THOP_IN, 24, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleSetMenuDescriptor[] =
{
    THOP_ALIAS32, ALIAS_RESOLVE, THOP_HUSER, THOP_HUSER, THOP_IFACE | THOP_IN, THI_IOleInPlaceFrame, THOP_IFACE | THOP_IN, THI_IOleInPlaceActiveObject, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsOleDestroyMenuDescriptor[] =
{
    THOP_ALIAS32, ALIAS_REMOVE, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleDraw[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_HGDI, THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleRun[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleIsRunning[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_IFACE | THOP_IN, THI_IOleObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleLockRunning[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCreateOleAdviseHolder[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleAdviseHolder, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleCreateDefaultHandler[] =
{
    THOP_COPY | THOP_IN, 16, THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleCreateEmbeddingHelper[] =
{
    THOP_COPY | THOP_IN, 16, THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IClassFactory, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 16, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsOleRegGetUserType[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleRegGetMiscStatus[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleRegEnumFormatEtc[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleRegEnumVerbs[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_OUT, THI_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleConvertIStorageToOLESTREAM[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_OLESTREAM | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleConvertOLESTREAMToIStorage[] =
{
    THOP_OLESTREAM | THOP_INOUT, THOP_IFACE | THOP_IN, THI_IStorage, THOP_DVTARGETDEVICE | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleConvertIStorageToOLESTREAMEx[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_STGMEDIUM | THOP_IN, 0, 0, THOP_OLESTREAM | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 21
};
THOP CONST thopsOleConvertOLESTREAMToIStorageEx[] =
{
    THOP_OLESTREAM | THOP_INOUT, THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD | THOP_OUT, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_STGMEDIUM | THOP_IN, 0, 0, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleDoAutoConvert[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleGetAutoConvert[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleSetAutoConvert[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsGetConvertStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsSetConvertStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsReadOleStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsWriteOleStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACE | THOP_IN, THI_IOleObject, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 2
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thtblapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thtblapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "thopsapi.cxx"

THOP CONST * CONST apthopsApiThops[] =
{
    thopsCoInitialize
,    thopsCoUninitialize
,    thopsCoGetClassObject
,    thopsCoRegisterClassObject
,    thopsCoRevokeClassObject
,    thopsCoMarshalInterface
,    thopsCoUnmarshalInterface
,    thopsCoReleaseMarshalData
,    thopsCoDisconnectObject
,    thopsCoLockObjectExternal
,    thopsCoGetStandardMarshal
,    thopsCoIsHandlerConnected
,    thopsCoFreeAllLibraries
,    thopsCoFreeUnusedLibraries
,    thopsCoCreateInstance
,    thopsCLSIDFromString
,    thopsCoIsOle1Class
,    thopsProgIDFromCLSID
,    thopsCLSIDFromProgID
,    thopsCoCreateGuid
,    thopsCoFileTimeToDosDateTime
,    thopsCoDosDateTimeToFileTime
,    thopsCoFileTimeNow
,    thopsCoRegisterMessageFilter
,    thopsCoGetTreatAsClass
,    thopsCoTreatAsClass
,    thopsDllGetClassObject
,    thopsStgCreateDocfile
,    thopsStgCreateDocfileOnILockBytes
,    thopsStgOpenStorage
,    thopsStgOpenStorageOnILockBytes
,    thopsStgIsStorageFile
,    thopsStgIsStorageILockBytes
,    thopsStgSetTimes
,    thopsCreateDataAdviseHolder
,    thopsCreateDataCache
,    thopsBindMoniker
,    thopsMkParseDisplayName
,    thopsMonikerRelativePathTo
,    thopsMonikerCommonPrefixWith
,    thopsCreateBindCtx
,    thopsCreateGenericComposite
,    thopsGetClassFile
,    thopsCreateFileMoniker
,    thopsCreateItemMoniker
,    thopsCreateAntiMoniker
,    thopsCreatePointerMoniker
,    thopsGetRunningObjectTable
,    thopsReadClassStg
,    thopsWriteClassStg
,    thopsReadClassStm
,    thopsWriteClassStm
,    thopsWriteFmtUserTypeStg
,    thopsReadFmtUserTypeStg
,    thopsOleInitialize
,    thopsOleUninitialize
,    thopsOleQueryLinkFromData
,    thopsOleQueryCreateFromData
,    thopsOleCreate
,    thopsOleCreateFromData
,    thopsOleCreateLinkFromData
,    thopsOleCreateStaticFromData
,    thopsOleCreateLink
,    thopsOleCreateLinkToFile
,    thopsOleCreateFromFile
,    thopsOleLoad
,    thopsOleSave
,    thopsOleLoadFromStream
,    thopsOleSaveToStream
,    thopsOleSetContainedObject
,    thopsOleNoteObjectVisible
,    thopsRegisterDragDrop
,    thopsRevokeDragDrop
,    thopsDoDragDrop
,    thopsOleSetClipboard
,    thopsOleGetClipboard
,    thopsOleFlushClipboard
,    thopsOleIsCurrentClipboard
,    thopsOleCreateMenuDescriptor
,    thopsOleSetMenuDescriptor
,    thopsOleDestroyMenuDescriptor
,    thopsOleDraw
,    thopsOleRun
,    thopsOleIsRunning
,    thopsOleLockRunning
,    thopsCreateOleAdviseHolder
,    thopsOleCreateDefaultHandler
,    thopsOleCreateEmbeddingHelper
,    thopsOleRegGetUserType
,    thopsOleRegGetMiscStatus
,    thopsOleRegEnumFormatEtc
,    thopsOleRegEnumVerbs
,    thopsOleConvertIStorageToOLESTREAM
,    thopsOleConvertOLESTREAMToIStorage
,    thopsOleConvertIStorageToOLESTREAMEx
,    thopsOleConvertOLESTREAMToIStorageEx
,    thopsOleDoAutoConvert
,    thopsOleGetAutoConvert
,    thopsOleSetAutoConvert
,    thopsGetConvertStg
,    thopsSetConvertStg
,    thopsReadOleStg
,    thopsWriteOleStg
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\clspsht.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       clspsht.cpp
//
//  Contents:   Implements class CClsidPropertySheet
//
//  Classes:
//
//  Methods:    CClsidPropertySheet::CClsidPropertySheet
//              CClsidPropertySheet::~CClsidPropertySheet
//              CClsidPropertySheet::InitData
//              CClsidPropertySheet::OnNcCreate
//              CClsidPropertySheet::ValidateAndUpdate
//              CClsidPropertySheet::OnCommand
//              CClsidPropertySheet::LookAtCLSIDs
//              CClsidPropertySheet::ChangeCLSIDInfo
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"
#include "clspsht.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "newsrvr.h"

#if !defined(STANDALONE_BUILD)
    extern "C"
    {
    #include <sedapi.h>
    #include <ntlsa.h>
    }
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CClsidPropertySheet

IMPLEMENT_DYNAMIC(CClsidPropertySheet, CPropertySheet)

CClsidPropertySheet::CClsidPropertySheet(CWnd* pParentWnd)
         : CPropertySheet(IDS_PROPSHT_CAPTION1, pParentWnd)
{
}

CClsidPropertySheet::~CClsidPropertySheet()
{
}

BEGIN_MESSAGE_MAP(CClsidPropertySheet, CPropertySheet)
        //{{AFX_MSG_MAP(CClsidPropertySheet)
        ON_WM_NCCREATE()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CClsidPropertySheet::InitData(
        CString szAppName,
        HKEY hkAppID,
        HKEY * rghkCLSID,
        unsigned cCLSIDs)
{
    m_szAppName = szAppName;
    m_hkAppID = hkAppID;
    m_rghkCLSID = rghkCLSID;
    m_cCLSIDs = cCLSIDs;

    // Save the appid key, the table of clsid keys and the application
    // title globally so the property pages can access them
    // it
    g_hAppid = hkAppID;
    g_rghkCLSID = rghkCLSID;
    g_cCLSIDs = cCLSIDs;
    g_szAppTitle = (TCHAR *) LPCTSTR(szAppName);

    m_Page2.m_fRemote = FALSE;
    m_Page4.m_fService = FALSE;
    m_Page2.m_fCanBeLocal = FALSE;
    m_Page2.m_fLocal = FALSE;
    m_Page1.m_fSurrogate = FALSE;

    if (!LookAtCLSIDs())
    {
        return FALSE;
    }

    TCHAR szBuffer[MAX_PATH];
    DWORD dwSize;
    long lErr;

    dwSize = sizeof(szBuffer);
    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("LocalService"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        m_Page1.m_szServerPath = szBuffer;
        m_Page4.m_fService = TRUE;
        m_Page2.m_fCanBeLocal = TRUE;
        m_Page2.m_fLocal = TRUE;
    }
    else
    {
        dwSize = sizeof(szBuffer);
        lErr = RegQueryValueEx(
                m_hkAppID,
                TEXT("_LocalService"),
                NULL,
                NULL,
                (BYTE *)szBuffer,
                &dwSize);
        if (lErr == ERROR_SUCCESS)
        {
            m_Page1.m_szServerPath = szBuffer;
            m_Page4.m_fService = TRUE;
            m_Page2.m_fCanBeLocal = TRUE;
        }
    }

    dwSize = sizeof(szBuffer);

    if (!m_Page2.m_fLocal)
    {
        lErr = RegQueryValueEx(
                m_hkAppID,
                TEXT("DllSurrogate"),
                NULL,
                NULL,
                (BYTE *)szBuffer,
                &dwSize);
        if (lErr == ERROR_SUCCESS)
        {
            if (szBuffer[0])
                m_Page1.m_szServerPath = szBuffer;
            else
                m_Page1.m_szServerPath.LoadString(IDS_DEFAULT);
            m_Page1.m_fSurrogate = TRUE;
        }

    }
    dwSize = sizeof(szBuffer);

    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("RemoteServerName"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        m_Page1.m_szComputerName = szBuffer;
        m_Page2.m_szComputerName = szBuffer;
        m_Page2.m_fRemote = TRUE;
    }

    m_Page2.m_fAtStorage = FALSE;
    dwSize = sizeof(szBuffer);
    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("ActivateAtStorage"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        if (szBuffer[0] ==  L'Y' || szBuffer[0] == L'y')
        {
//                      m_Page2.m_fRemote = TRUE;
            m_Page2.m_fAtStorage = TRUE;
        }
    }

    dwSize = sizeof(szBuffer);
    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("RunAs"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        // If the RunAs name is empty, jam in something
        if (szBuffer[0] == TEXT('\0'))
        {
            _tcscpy(szBuffer, TEXT("<domain>\\<user>"));
        }

        if (0 == _tcsicmp(szBuffer, TEXT("Interactive User")))
        {
            m_Page4.m_iIdentity = 0;
        }
        else
        {
            m_Page4.m_iIdentity = 2;
            m_Page4.m_szUserName = szBuffer;

            // Extract password from the Lsa private database
            g_util.RetrieveUserPassword(g_szAppid , m_Page4.m_szPassword);
            m_Page4.m_szConfirmPassword = m_Page4.m_szPassword;
        }
    }
    else
    {
        if (m_Page4.m_fService)
        {
            m_Page4.m_iIdentity = 3;
        }
        else
        {
            m_Page4.m_iIdentity = 1;
        }
    }

    m_Page1.m_szServerName = m_szAppName;

    if (!m_Page1.m_fSurrogate)
    {
        if (m_Page2.m_fCanBeLocal)
        {
            if (m_Page4.m_fService)
                m_Page1.m_iServerType = SERVICE;
            else
                m_Page1.m_iServerType = LOCALEXE;
            if (m_Page2.m_fRemote)
                m_Page1.m_iServerType += 3;
        }
        else
            m_Page1.m_iServerType = PURE_REMOTE;
    }
    else
    {
        m_Page1.m_iServerType = SURROGATE;
    }


    // Set the title
    SetTitle((const TCHAR *) m_szAppName, PSH_PROPTITLE);
    m_Page1.m_szServerName = m_szAppName;

    // TODO: If there are running instances, then make IDC_RUNNING,
    // IDC_LIST2, IDC_BUTTON1, IDC_BUTTON2, and IDC_BUTTON3 visible
    // and fill in IDC_LIST2 on page 1.

    m_Page2.m_pPage1 = &m_Page1;


    // Fetch RunAs key, LaunchPermission, AccessPermission and
    // ConfigurationPermission
    int   err;
    DWORD dwType;
    BYTE  bValue[16];
    BYTE *pbValue = NULL;
    ULONG ulSize = 1;

    m_Page3.m_iAccess = 0;
    m_Page3.m_iLaunch = 0;
    m_Page3.m_iConfig = 0;

    // "AccessPermission"
    // Note: We always expect to get ERROR_MORE_DATA
    err = RegQueryValueEx(g_hAppid, TEXT("AccessPermission"), 0,
                          &dwType, bValue, &ulSize);
    if (err == ERROR_MORE_DATA)
    {
        pbValue = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue == NULL)
        {
            return FALSE;
        }
        err = RegQueryValueEx(g_hAppid, TEXT("AccessPermission"), 0,
                              &dwType, pbValue, &ulSize);
    }

    if (err == ERROR_SUCCESS && g_util.CheckForValidSD((SECURITY_DESCRIPTOR *)pbValue))
    {
        m_Page3.m_iAccess = 1;
        g_virtreg.NewRegSingleACL(g_hAppid,
                                  NULL,
                                  TEXT("AccessPermission"),
                                  (SECURITY_DESCRIPTOR *) pbValue,
                                  TRUE,    // Already in self-relative form
                                  &m_Page3.m_iAccessIndex);
        CDataPacket *pCdb = g_virtreg.GetAt(m_Page3.m_iAccessIndex);
        pCdb->SetModified(FALSE);
    }
    GlobalFree(pbValue);
    pbValue = NULL;

    // "LaunchPermission"
    // Note: We always expect to get ERROR_MORE_DATA
    ulSize = 1;
    pbValue = NULL;
    err = RegQueryValueEx(g_hAppid, TEXT("LaunchPermission"), 0,
                          &dwType, bValue, &ulSize);
    if (err == ERROR_MORE_DATA)
    {
        pbValue = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue == NULL)
        {
            return FALSE;
        }
        err = RegQueryValueEx(g_hAppid, TEXT("LaunchPermission"), 0,
                              &dwType, pbValue, &ulSize);
    }

    if (err == ERROR_SUCCESS && g_util.CheckForValidSD((SECURITY_DESCRIPTOR *)pbValue))
    {
        m_Page3.m_iLaunch = 1;
        g_virtreg.NewRegSingleACL(g_hAppid,
                                  NULL,
                                  TEXT("LaunchPermission"),
                                  (SECURITY_DESCRIPTOR *) pbValue,
                                  TRUE,    // Already in self-relative form
                                  &m_Page3.m_iLaunchIndex);
        CDataPacket * pCdb = g_virtreg.GetAt(m_Page3.m_iLaunchIndex);
        pCdb->SetModified(FALSE);
    }
    GlobalFree(pbValue);
    pbValue = NULL;


    // "ConfigurationPermission"

    // Fetch the security descriptor on this AppID
    // Note: We always expect to get ERROR_INSUFFICIENT_BUFFER
    ulSize = 1;
    err = RegGetKeySecurity(g_hAppid,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue,
                            &ulSize);
    if (err == ERROR_INSUFFICIENT_BUFFER)
    {
        pbValue = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue == NULL)
        {
            return FALSE;
        }
        err = RegGetKeySecurity(g_hAppid,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue,
                            &ulSize);
    }

    // Fetch the current security descriptor on HKEY_CLASSES_ROOT
    // Note: We always expect to get ERROR_INSUFFICIENT_BUFFER
    BYTE *pbValue2 = NULL;

    ulSize = 1;
    pbValue2 = NULL;
    err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue2,
                            &ulSize);
    if (err == ERROR_INSUFFICIENT_BUFFER)
    {
        pbValue2 = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue2 == NULL)
        {
            return FALSE;
        }
        err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                pbValue2,
                                &ulSize);
    }

    // Now compare them.  If they differ then this AppId uses custom
    // configuration permissions

    if (err == ERROR_SUCCESS && g_util.CheckForValidSD((SECURITY_DESCRIPTOR *)pbValue))
    {
        if (!g_util.CompareSDs((PSrSecurityDescriptor) pbValue,
                               (PSrSecurityDescriptor) pbValue2))
        {
            err = g_virtreg.NewRegKeyACL(g_hAppid,
                                         rghkCLSID,
                                         cCLSIDs,
                                         g_szAppTitle,
                                         (SECURITY_DESCRIPTOR *) pbValue,
                                         (SECURITY_DESCRIPTOR *) pbValue,
                                         TRUE,
                                         &m_Page3.m_iConfigurationIndex);
            CDataPacket * pCdb = g_virtreg.GetAt(m_Page3.m_iConfigurationIndex);
            pCdb->SetModified(FALSE);
            m_Page3.m_iConfig = 1;
        }
    }
    GlobalFree(pbValue);
    GlobalFree(pbValue2);


    // Add all of the property pages here.  Note that
    // the order that they appear in here will be
    // the order they appear in on screen.  By default,
    // the first page of the set is the active one.
    // One way to make a different property page the
    // active one is to call SetActivePage().

    AddPage(&m_Page1);
    if (m_Page1.m_iServerType != SURROGATE)
    {
        AddPage(&m_Page2);
    }
    if (m_Page2.m_fCanBeLocal || m_Page1.m_fSurrogate)
    {
        AddPage(&m_Page3);
        AddPage(&m_Page4);
    }
    // add the property page for endpoint options
    AddPage(&m_Page5);
    m_Page5.InitData(szAppName, hkAppID);


    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CClsidPropertySheet message handlers


BOOL CClsidPropertySheet::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
        if (!CPropertySheet::OnNcCreate(lpCreateStruct))
                return FALSE;

        ModifyStyleEx(0, WS_EX_CONTEXTHELP);

        return TRUE;
}

BOOL CClsidPropertySheet::ValidateAndUpdate(void)
{
    // Call update data on all initialized pages
    // to make sure that their private member variables are correct.
    long lErr;

    BOOL fReturn = UpdateData(TRUE);
    if (fReturn && m_Page1.m_hWnd)
        fReturn = m_Page1.ValidateChanges();
    if (fReturn && m_Page2.m_hWnd)
        fReturn = m_Page2.ValidateChanges();
    if (fReturn && m_Page3.m_hWnd)
        fReturn = m_Page3.ValidateChanges();
    if (fReturn && m_Page4.m_hWnd)
        fReturn = m_Page4.ValidateChanges();

    if (fReturn && m_Page5.m_hWnd)
        fReturn = m_Page5.ValidateChanges();

    if (!fReturn)
        return FALSE;

    m_Page1.UpdateChanges(m_hkAppID);
    m_Page2.UpdateChanges(m_hkAppID);
    m_Page3.UpdateChanges(m_hkAppID);
    m_Page4.UpdateChanges(m_hkAppID);
    m_Page5.UpdateChanges(m_hkAppID);

    ////////////////////////////////////////////////////////////////////
    // Persist cross page data

    if (m_Page4.m_fService)
    {
        if (m_Page2.m_fLocal)
        {
            BOOL fOk;

            // Write the LocalService value to the registry
            lErr = RegSetValueEx(
                    m_hkAppID,
                    TEXT("LocalService"),
                    0,
                    REG_SZ,
                    (BYTE *)(LPCTSTR)m_Page1.m_szServerPath,
                    (1 + m_Page1.m_szServerPath.GetLength()) * sizeof (TCHAR));
            lErr = RegDeleteValue(
                    m_hkAppID,
                    TEXT("_LocalService"));

            // Persist information to the service manager database
            if (m_Page4.m_iIdentity == 3)
            {
                fOk = g_util.ChangeService((LPCTSTR) m_Page1.m_szServerPath,
                                           TEXT("LocalSystem"),
                                           TEXT(""),
                                           (LPCTSTR) m_Page1.m_szServerName);
            }
            else
            {
                fOk = g_util.ChangeService((LPCTSTR) m_Page1.m_szServerPath,
                                           (LPCTSTR) m_Page4.m_szUserName,
                                           (LPCTSTR) m_Page4.m_szPassword,
                                           (LPCTSTR) m_Page1.m_szServerName);
            }
            if (!fOk)
            {
                return FALSE;
            }
        }
        else
        {
            lErr = RegSetValueEx(
                    m_hkAppID,
                    TEXT("_LocalService"),
                    0,
                    REG_SZ,
                    (BYTE *)(LPCTSTR)m_Page1.m_szServerPath,
                    (1 + m_Page1.m_szServerPath.GetLength()) * sizeof (TCHAR));
            lErr = RegDeleteValue(
                    m_hkAppID,
                    TEXT("LocalService"));
        }
    }

    return ChangeCLSIDInfo(m_Page2.m_fLocal);
}

BOOL CClsidPropertySheet::OnCommand(WPARAM wParam, LPARAM lParam)
{
        switch (LOWORD(wParam))
        {
        case IDOK:
        case ID_APPLY_NOW:
            if (!ValidateAndUpdate())
                return TRUE;
                break;
        }
        return CPropertySheet::OnCommand(wParam, lParam);
}

BOOL CClsidPropertySheet::LookAtCLSIDs(void)
{
    BOOL fFoundLocalServer = FALSE;
    TCHAR szBuffer[MAX_PATH];
    DWORD dwSize;
    HKEY hKey;
    long lErr;

    unsigned n = 0;
    while (n < m_cCLSIDs && !fFoundLocalServer)
    {
        lErr = RegOpenKeyEx(
                m_rghkCLSID[n],
                TEXT("LocalServer32"),
                0,
                KEY_ALL_ACCESS,
                &hKey);
        if (lErr == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuffer);
            lErr = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    NULL,
                    (BYTE *)szBuffer,
                    &dwSize);
            if (lErr == ERROR_SUCCESS)
            {
                m_Page1.m_szServerPath = szBuffer;
                m_Page2.m_fLocal = TRUE;
                m_Page2.m_fCanBeLocal = TRUE;
                fFoundLocalServer = TRUE;
            }
            RegCloseKey(hKey);
        }


        if (!fFoundLocalServer)
        {
            lErr = RegOpenKeyEx(
                    m_rghkCLSID[n],
                    TEXT("LocalServer"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey);
            if (lErr == ERROR_SUCCESS)
            {
                dwSize = sizeof(szBuffer);
                lErr = RegQueryValueEx(
                        hKey,
                        TEXT(""),
                        NULL,
                        NULL,
                        (BYTE *)szBuffer,
                        &dwSize);
                if (lErr == ERROR_SUCCESS)
                {
                    m_Page1.m_szServerPath = szBuffer;
                    m_Page2.m_fLocal = TRUE;
                    m_Page2.m_fCanBeLocal = TRUE;
                    fFoundLocalServer = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        if (!fFoundLocalServer)
        {
            lErr = RegOpenKeyEx(
                    m_rghkCLSID[n],
                    TEXT("_LocalServer32"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey);
            if (lErr == ERROR_SUCCESS)
            {
                dwSize = sizeof(szBuffer);
                lErr = RegQueryValueEx(
                        hKey,
                        TEXT(""),
                        NULL,
                        NULL,
                        (BYTE *)szBuffer,
                        &dwSize);
                if (lErr == ERROR_SUCCESS)
                {
                    m_Page1.m_szServerPath = szBuffer;
                    m_Page2.m_fCanBeLocal = TRUE;
                    fFoundLocalServer = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        if (!fFoundLocalServer)
        {
            lErr = RegOpenKeyEx(
                    m_rghkCLSID[n],
                    TEXT("_LocalServer"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey);
            if (lErr == ERROR_SUCCESS)
            {
                dwSize = sizeof(szBuffer);
                lErr = RegQueryValueEx(
                        hKey,
                        TEXT(""),
                        NULL,
                        NULL,
                        (BYTE *)szBuffer,
                        &dwSize);
                if (lErr == ERROR_SUCCESS)
                {
                    m_Page1.m_szServerPath = szBuffer;
                    m_Page2.m_fCanBeLocal = TRUE;
                    fFoundLocalServer = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        n++;
    }
    return TRUE;
}




BOOL    CClsidPropertySheet::ChangeCLSIDInfo(BOOL fLocal)
{
    TCHAR szBuffer[MAX_PATH];
    CString szOld;
    CString szNew;
    CString szOld16;
    CString szNew16;
    DWORD dwSize;
    HKEY hKey;
    long lErr;

    if (fLocal)
    {
        szOld = TEXT("_LocalServer32");
        szNew = TEXT("LocalServer32");
        szOld16 = TEXT("_LocalServer");
        szNew16 = TEXT("LocalServer");
    }
    else
    {
        szOld = TEXT("LocalServer32");
        szNew = TEXT("_LocalServer32");
        szOld16 = TEXT("LocalServer");
        szNew16 = TEXT("_LocalServer");
    }

    unsigned n = 0;
    while (n < m_cCLSIDs)
    {
        // First do 32 servers
        lErr = RegOpenKeyEx(
                m_rghkCLSID[n],
                szOld,
                0,
                KEY_ALL_ACCESS,
                &hKey);
        if (lErr == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuffer);
            lErr = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    NULL,
                    (BYTE *)szBuffer,
                    &dwSize);
            if (lErr == ERROR_SUCCESS)
            {
                HKEY hKeyNew;
                DWORD dwDisp;

                lErr = RegCreateKeyEx(
                        m_rghkCLSID[n],
                        szNew,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKeyNew,
                        &dwDisp);
                if (lErr == ERROR_SUCCESS)
                {
                    lErr = RegSetValueEx(
                            hKeyNew,
                            TEXT(""),
                            NULL,
                            REG_SZ,
                            (BYTE *)szBuffer,
                            dwSize);
                    RegCloseKey(hKeyNew);
                }
            }
            RegCloseKey(hKey);
            lErr = RegDeleteKey(m_rghkCLSID[n], szOld);
        }


        // Then do 16 servers
        lErr = RegOpenKeyEx(
                m_rghkCLSID[n],
                szOld16,
                0,
                KEY_ALL_ACCESS,
                &hKey);
        if (lErr == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuffer);
            lErr = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    NULL,
                    (BYTE *)szBuffer,
                    &dwSize);
            if (lErr == ERROR_SUCCESS)
            {
                HKEY hKeyNew;
                DWORD dwDisp;

                lErr = RegCreateKeyEx(
                        m_rghkCLSID[n],
                        szNew16,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKeyNew,
                        &dwDisp);
                if (lErr == ERROR_SUCCESS)
                {
                    lErr = RegSetValueEx(
                            hKeyNew,
                            TEXT(""),
                            NULL,
                            REG_SZ,
                            (BYTE *)szBuffer,
                            dwSize);
                    RegCloseKey(hKeyNew);
                }
            }
            RegCloseKey(hKey);
            lErr = RegDeleteKey(m_rghkCLSID[n], szOld16);
        }

        n++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\vtblapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	vtblapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

VTBLFN CONST apfnApiFunctions[] =
{
    (VTBLFN)CoInitializeNot
,    (VTBLFN)CoUninitialize
,    (VTBLFN)CoGetClassObject
,    (VTBLFN)CoRegisterClassObjectNot
,    (VTBLFN)CoRevokeClassObjectNot
,    (VTBLFN)CoMarshalInterface
,    (VTBLFN)CoUnmarshalInterface
,    (VTBLFN)CoReleaseMarshalData
,    (VTBLFN)CoDisconnectObject
,    (VTBLFN)CoLockObjectExternal
,    (VTBLFN)CoGetStandardMarshal
,    (VTBLFN)CoIsHandlerConnected
,    (VTBLFN)CoFreeAllLibraries
,    (VTBLFN)CoFreeUnusedLibraries
,    (VTBLFN)CoCreateInstance
,    (VTBLFN)CLSIDFromString
,    (VTBLFN)CoIsOle1Class
,    (VTBLFN)ProgIDFromCLSID
,    (VTBLFN)CLSIDFromProgID
,    (VTBLFN)CoCreateGuid
,    (VTBLFN)CoFileTimeToDosDateTime
,    (VTBLFN)CoDosDateTimeToFileTime
,    (VTBLFN)CoFileTimeNow
,    (VTBLFN)CoRegisterMessageFilter
,    (VTBLFN)CoGetTreatAsClass
,    (VTBLFN)CoTreatAsClass
,    (VTBLFN)DllGetClassObjectWOW
,    (VTBLFN)StgCreateDocfile
,    (VTBLFN)StgCreateDocfileOnILockBytes
,    (VTBLFN)StgOpenStorage
,    (VTBLFN)StgOpenStorageOnILockBytes
,    (VTBLFN)StgIsStorageFile
,    (VTBLFN)StgIsStorageILockBytes
,    (VTBLFN)StgSetTimes
,    (VTBLFN)CreateDataAdviseHolder
,    (VTBLFN)CreateDataCache
,    (VTBLFN)BindMoniker
,    (VTBLFN)MkParseDisplayName
,    (VTBLFN)MonikerRelativePathTo
,    (VTBLFN)MonikerCommonPrefixWith
,    (VTBLFN)CreateBindCtx
,    (VTBLFN)CreateGenericComposite
,    (VTBLFN)GetClassFile
,    (VTBLFN)CreateFileMoniker
,    (VTBLFN)CreateItemMoniker
,    (VTBLFN)CreateAntiMoniker
,    (VTBLFN)CreatePointerMoniker
,    (VTBLFN)GetRunningObjectTable
,    (VTBLFN)ReadClassStg
,    (VTBLFN)WriteClassStg
,    (VTBLFN)ReadClassStm
,    (VTBLFN)WriteClassStm
,    (VTBLFN)WriteFmtUserTypeStg
,    (VTBLFN)ReadFmtUserTypeStg
,    (VTBLFN)OleInitializeNot
,    (VTBLFN)OleUninitialize
,    (VTBLFN)OleQueryLinkFromData
,    (VTBLFN)OleQueryCreateFromData
,    (VTBLFN)OleCreate
,    (VTBLFN)OleCreateFromData
,    (VTBLFN)OleCreateLinkFromData
,    (VTBLFN)OleCreateStaticFromData
,    (VTBLFN)OleCreateLink
,    (VTBLFN)OleCreateLinkToFile
,    (VTBLFN)OleCreateFromFile
,    (VTBLFN)OleLoad
,    (VTBLFN)OleSave
,    (VTBLFN)OleLoadFromStream
,    (VTBLFN)OleSaveToStream
,    (VTBLFN)OleSetContainedObject
,    (VTBLFN)OleNoteObjectVisible
,    (VTBLFN)RegisterDragDrop
,    (VTBLFN)RevokeDragDrop
,    (VTBLFN)DoDragDrop
,    (VTBLFN)OleSetClipboard
,    (VTBLFN)OleGetClipboard
,    (VTBLFN)OleFlushClipboard
,    (VTBLFN)OleIsCurrentClipboard
,    (VTBLFN)OleCreateMenuDescriptor
,    (VTBLFN)OleSetMenuDescriptor
,    (VTBLFN)OleDestroyMenuDescriptor
,    (VTBLFN)OleDraw
,    (VTBLFN)OleRun
,    (VTBLFN)OleIsRunning
,    (VTBLFN)OleLockRunning
,    (VTBLFN)CreateOleAdviseHolder
,    (VTBLFN)OleCreateDefaultHandler
,    (VTBLFN)OleCreateEmbeddingHelper
,    (VTBLFN)OleRegGetUserTypeNot
,    (VTBLFN)OleRegGetMiscStatus
,    (VTBLFN)OleRegEnumFormatEtc
,    (VTBLFN)OleRegEnumVerbs
,    (VTBLFN)OleConvertIStorageToOLESTREAM
,    (VTBLFN)OleConvertOLESTREAMToIStorage
,    (VTBLFN)OleConvertIStorageToOLESTREAMEx
,    (VTBLFN)OleConvertOLESTREAMToIStorageEx
,    (VTBLFN)OleDoAutoConvert
,    (VTBLFN)OleGetAutoConvert
,    (VTBLFN)OleSetAutoConvert
,    (VTBLFN)GetConvertStg
,    (VTBLFN)SetConvertStg
,    (VTBLFN)ReadOleStg
,    (VTBLFN)WriteOleStg
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\tlsthk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       tlsthk.cxx
//
//  Contents:   Utility routines for logical thread data
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include "headers.cxx"
#pragma hdrstop

#define UNINITIALIZED_INDEX (0xffffffff)

DWORD dwTlsThkIndex = UNINITIALIZED_INDEX;

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkGetData
//
//  Synopsis:   returns pointer to thread data
//
//  Returns:    pointer to threaddata
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
PThreadData TlsThkGetData(void)
{
    if (dwTlsThkIndex == UNINITIALIZED_INDEX)
    {
        thkDebugOut((DEB_WARN, "WARNING: TLS slot used when uninitialized\n"));
    }

    PThreadData pThreaddata = (PThreadData) TlsGetValue(dwTlsThkIndex);

    return pThreaddata;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkAlloc
//
//  Synopsis:   allocates a slot for thread data
//
//  Returns:    BOOL
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
BOOL TlsThkAlloc(void)
{
    thkDebugOut((DEB_THUNKMGR, "In TlsThkAlloc\n"));

    // We must be uninitialized to call this routine
    thkAssert(dwTlsThkIndex == UNINITIALIZED_INDEX);

    dwTlsThkIndex = TlsAlloc();
    if (dwTlsThkIndex == UNINITIALIZED_INDEX)
    {
        return FALSE;
    }

    thkDebugOut((DEB_THUNKMGR, "Out TlsThkAlloc\n"));
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:  	GetTaskName
//
//  Synopsis: 	Obtain the 16-bit task name
//
//  Author:     July 14,97     Gopalk     Created
//
//--------------------------------------------------------------------------

// these 2 from com\inc\ole2int.h
#define IncLpch(sz)          ((sz)=CharNext ((sz)))
#define DecLpch(szStart, sz) ((sz)=CharPrev ((szStart),(sz)))

// Helper function for IsTaskName
inline BOOL IsPathSeparator( WCHAR ch )
{
    return (ch == TCHAR('\\') || ch == TCHAR('/') || ch == TCHAR(':'));
}

FARINTERNAL_(BOOL) IsTaskName(LPCTSTR lpszIn)
{
    TCHAR atszImagePath[MAX_PATH+1] = _T("");
    BOOL retval = FALSE;

	int cChars = GetModuleFileName(NULL, atszImagePath, sizeof(atszImagePath)/sizeof(atszImagePath[0]));

	atszImagePath[sizeof(atszImagePath)/sizeof(atszImagePath[0])-1] = _T('\0');

    if (cChars != 0 && cChars != MAX_PATH)
    {
        TCHAR * pch;
        LONG len=0;         // length of exe name after last separator
        LONG N;             // length of lpszIn

        // Get last component of path

        //
        // Find the end of the string and determine the string length.
        //
        for (pch=atszImagePath; *pch; pch++);

        DecLpch (atszImagePath, pch);   // pch now points to the last real char

        while (!IsPathSeparator(*pch)) {
           DecLpch (atszImagePath, pch);
           len++;
        }

        // we're at the last separator. 
        // we want to do an lstrNcmpi (found cases where there was a non-null
        // char at the end of the exe name eg. "WINWORD.EXE>#")

        N = lstrlen(lpszIn);
        if (len > N) {      // simulate lstrNcmpi (don't have one available)
            //pch+1 is the 0th char after the separator
            TCHAR saveChar = *(pch+1+N);    // save N+1 th char
            *(pch+1+N) = 0;         
            if (!lstrcmpi(pch+1, lpszIn))
                retval = TRUE;
            *(pch+1+N) = saveChar;          // restore N+1 th char
        }
        else if (!lstrcmpi(pch+1, lpszIn)) {
            retval = TRUE;
        }
    }

    return retval;
}


//+---------------------------------------------------------------------------
//
//  Function:   TlsThkInitialize
//
//  Synopsis:   allocates thread data and initialize slot
//
//  Returns:    Appropriate status code
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//              7-14-97   Gopalk                   Added compatiblity flags 
//                                                 based on the image name
//
//----------------------------------------------------------------------------
HRESULT TlsThkInitialize(void)
{
    PThreadData pThreaddata;
    TCHAR *pch;

    thkDebugOut((DEB_THUNKMGR, "In TlsThkInitialize\n"));

    thkAssert(dwTlsThkIndex != UNINITIALIZED_INDEX &&
              "Tls slot not allocated.");

    // We must be uninitialized to call this routine
    thkAssert(TlsGetValue(dwTlsThkIndex) == 0);

    pThreaddata = (PThreadData) LocalAlloc(LPTR, sizeof (ThreadData));
    if(pThreaddata != NULL)
    {
        // Force construction since we allocated with LocalAlloc
        pThreaddata->sa16.CStackAllocator::
            CStackAllocator(&mmodel16Owned, 1024, 2);
        pThreaddata->sa32.CStackAllocator::
            CStackAllocator(&mmodel32, 8192, 8);

        pThreaddata->pCThkMgr = 0;
        pThreaddata->dwAppCompatFlags = 0;
        pThreaddata->pAggHolderList = 0;

        if (IsTaskName(TEXT("WINWORD.EXE")) || 
            IsTaskName(TEXT("MSWORKS.EXE")) || 
            IsTaskName(TEXT("WPWIN61.EXE")) ||
            IsTaskName(TEXT("QPW.EXE"))     ||
            IsTaskName(TEXT("PDOXWIN.EXE")) )
        {
            thkDebugOut((DEB_WARN, "OleIsCurrentClipBoard hack enabled\n"));
            pThreaddata->dwAppCompatFlags |= OACF_WORKSCLIPOBJ;
        }
        else if (IsTaskName(TEXT("CORELPNT.EXE")))
        {
            thkDebugOut((DEB_WARN, "CorelPaint 5.0 hack enabled\n"));
            pThreaddata->dwAppCompatFlags |= OACF_CRLPNTPERSIST;
        }
        else if (IsTaskName(TEXT("TEXTART.EXE")))
        {
            thkDebugOut((DEB_WARN, "TextArt DAHolder::DAdvise hack enabled\n"));
            pThreaddata->dwAppCompatFlags |= OACF_TEXTARTDOBJ;
        }

        TlsSetValue(dwTlsThkIndex, pThreaddata);
    }

    thkDebugOut((DEB_THUNKMGR, "Out TlsThkInitialize\n"));

    return (pThreaddata != NULL) ? NOERROR : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkUninitialize
//
//  Synopsis:   frees thread data and set it to NULL
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void TlsThkUninitialize(void)
{
    thkDebugOut((DEB_TLSTHK, "In TlsThkUninitialize\n"));

    // Asserts if data is NULL
    PThreadData pThreaddata = TlsThkGetData();

    // We should assert that the things in the ThreadData
    // are freed up

    if (pThreaddata != NULL)
    {
        // Stack allocators are cleaned up elsewhere
        // because they require special treatment

	if (pThreaddata->pDelayedRegs != NULL)
	{
	    delete pThreaddata->pDelayedRegs;
	}
	LocalFree(pThreaddata);
    }

    TlsSetValue(dwTlsThkIndex, NULL);

    thkDebugOut((DEB_TLSTHK, "Out TlsThkUninitialize\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkFree
//
//  Synopsis:   frees slot
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void TlsThkFree(void)
{
    thkAssert(dwTlsThkIndex != UNINITIALIZED_INDEX);

    TlsFree( dwTlsThkIndex );

    // We must set this to an invalid value so any further uses of the
    // TLS slot will return NULL
    dwTlsThkIndex = UNINITIALIZED_INDEX;
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkLinkAggHolder
//
//  Synopsis:   Links ProxyHolder node into a list in TLS (used in Aggregation)
//
//  History:    2-11-98   MPrabhu   Created
//
//----------------------------------------------------------------------------
void TlsThkLinkAggHolder(SAggHolder *pNode)
{
    SAggHolder *head = TlsThkGetAggHolderList();
    pNode->next = head;
    TlsThkSetAggHolderList(pNode);
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkGetAggHolder
//
//  Synopsis:   Gets the last ProxyHolder node that was linked into TLS list
//
//  History:    2-11-98   MPrabhu   Created
//
//----------------------------------------------------------------------------
SAggHolder* TlsThkGetAggHolder(void)
{
    SAggHolder *head = TlsThkGetAggHolderList();
    thkAssert(head);
    return head;
}


//+---------------------------------------------------------------------------
//
//  Function:   TlsThkGetAggHolder
//
//  Synopsis:   Unlinks the last ProxyHolder node that was linked into TLS list
//
//  History:    2-11-98   MPrabhu   Created
//
//----------------------------------------------------------------------------
void TlsThkUnlinkAggHolder(void)
{
    SAggHolder *head = TlsThkGetAggHolderList();
    thkAssert(head);
    TlsThkSetAggHolderList(head->next);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thtblint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thtblint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

THOP CONST * CONST apthopsIUnknown[] =
{
    NULL
};
THOP CONST * CONST apthopsIClassFactory[] =
{
    thopsIClassFactory_CreateInstance
,    thopsIClassFactory_LockServer
};
THOP CONST * CONST apthopsIMarshal[] =
{
    thopsIMarshal_GetUnmarshalClass
,    thopsIMarshal_GetMarshalSizeMax
,    thopsIMarshal_MarshalInterface
,    thopsIMarshal_UnmarshalInterface
,    thopsIMarshal_ReleaseMarshalData
,    thopsIMarshal_DisconnectObject
};
THOP CONST * CONST apthopsIStdMarshalInfo[] =
{
    thopsIStdMarshalInfo_GetClassForHandler
};
THOP CONST * CONST apthopsIMessageFilter[] =
{
    thopsIMessageFilter_HandleInComingCall
,    thopsIMessageFilter_RetryRejectedCall
,    thopsIMessageFilter_MessagePending
};
THOP CONST * CONST apthopsIExternalConnection[] =
{
    thopsIExternalConnection_AddConnection
,    thopsIExternalConnection_ReleaseConnection
};
THOP CONST * CONST apthopsIEnumString[] =
{
    thopsIEnumString_Next
,    thopsIEnumString_Skip
,    thopsIEnumString_Reset
,    thopsIEnumString_Clone
};
THOP CONST * CONST apthopsIEnumUnknown[] =
{
    thopsIEnumUnknown_Next
,    thopsIEnumUnknown_Skip
,    thopsIEnumUnknown_Reset
,    thopsIEnumUnknown_Clone
};
THOP CONST * CONST apthopsIEnumSTATSTG[] =
{
    thopsIEnumSTATSTG_Next
,    thopsIEnumSTATSTG_Skip
,    thopsIEnumSTATSTG_Reset
,    thopsIEnumSTATSTG_Clone
};
THOP CONST * CONST apthopsILockBytes[] =
{
    thopsILockBytes_ReadAt
,    thopsILockBytes_WriteAt
,    thopsILockBytes_Flush
,    thopsILockBytes_SetSize
,    thopsILockBytes_LockRegion
,    thopsILockBytes_UnlockRegion
,    thopsILockBytes_Stat
};
THOP CONST * CONST apthopsIStream[] =
{
    thopsIStream_Read
,    thopsIStream_Write
,    thopsIStream_Seek
,    thopsIStream_SetSize
,    thopsIStream_CopyTo
,    thopsIStream_Commit
,    thopsIStream_Revert
,    thopsIStream_LockRegion
,    thopsIStream_UnlockRegion
,    thopsIStream_Stat
,    thopsIStream_Clone
};
THOP CONST * CONST apthopsIStorage[] =
{
    thopsIStorage_CreateStream
,    thopsIStorage_OpenStream
,    thopsIStorage_CreateStorage
,    thopsIStorage_OpenStorage
,    thopsIStorage_CopyTo
,    thopsIStorage_MoveElementTo
,    thopsIStorage_Commit
,    thopsIStorage_Revert
,    thopsIStorage_EnumElements
,    thopsIStorage_DestroyElement
,    thopsIStorage_RenameElement
,    thopsIStorage_SetElementTimes
,    thopsIStorage_SetClass
,    thopsIStorage_SetStateBits
,    thopsIStorage_Stat
};
THOP CONST * CONST apthopsIRootStorage[] =
{
    thopsIRootStorage_SwitchToFile
};
THOP CONST * CONST apthopsIEnumFORMATETC[] =
{
    thopsIEnumFORMATETC_Next
,    thopsIEnumFORMATETC_Skip
,    thopsIEnumFORMATETC_Reset
,    thopsIEnumFORMATETC_Clone
};
THOP CONST * CONST apthopsIEnumSTATDATA[] =
{
    thopsIEnumSTATDATA_Next
,    thopsIEnumSTATDATA_Skip
,    thopsIEnumSTATDATA_Reset
,    thopsIEnumSTATDATA_Clone
};
THOP CONST * CONST apthopsIDataObject[] =
{
    thopsIDataObject_GetData
,    thopsIDataObject_GetDataHere
,    thopsIDataObject_QueryGetData
,    thopsIDataObject_GetCanonicalFormatEtc
,    thopsIDataObject_SetData
,    thopsIDataObject_EnumFormatEtc
,    thopsIDataObject_DAdvise
,    thopsIDataObject_DUnadvise
,    thopsIDataObject_EnumDAdvise
};
THOP CONST * CONST apthopsIViewObject[] =
{
    thopsIViewObject_Draw
,    thopsIViewObject_GetColorSet
,    thopsIViewObject_Freeze
,    thopsIViewObject_Unfreeze
,    thopsIViewObject_SetAdvise
,    thopsIViewObject_GetAdvise
};
THOP CONST * CONST apthopsIViewObject2[] =
{
    thopsIViewObject2_Draw
,    thopsIViewObject2_GetColorSet
,    thopsIViewObject2_Freeze
,    thopsIViewObject2_Unfreeze
,    thopsIViewObject2_SetAdvise
,    thopsIViewObject2_GetAdvise
,    thopsIViewObject2_GetExtent
};
THOP CONST * CONST apthopsIAdviseSink[] =
{
    thopsIAdviseSink_OnDataChange
,    thopsIAdviseSink_OnViewChange
,    thopsIAdviseSink_OnRename
,    thopsIAdviseSink_OnSave
,    thopsIAdviseSink_OnClose
};
THOP CONST * CONST apthopsIAdviseSink2[] =
{
    thopsIAdviseSink2_OnDataChange
,    thopsIAdviseSink2_OnViewChange
,    thopsIAdviseSink2_OnRename
,    thopsIAdviseSink2_OnSave
,    thopsIAdviseSink2_OnClose
,    thopsIAdviseSink2_OnLinkSrcChange
};
THOP CONST * CONST apthopsIDataAdviseHolder[] =
{
    thopsIDataAdviseHolder_Advise
,    thopsIDataAdviseHolder_Unadvise
,    thopsIDataAdviseHolder_EnumAdvise
,    thopsIDataAdviseHolder_SendOnDataChange
};
THOP CONST * CONST apthopsIOleCache[] =
{
    thopsIOleCache_Cache
,    thopsIOleCache_Uncache
,    thopsIOleCache_EnumCache
,    thopsIOleCache_InitCache
,    thopsIOleCache_SetData
};
THOP CONST * CONST apthopsIOleCache2[] =
{
    thopsIOleCache2_Cache
,    thopsIOleCache2_Uncache
,    thopsIOleCache2_EnumCache
,    thopsIOleCache2_InitCache
,    thopsIOleCache2_SetData
,    thopsIOleCache2_UpdateCache
,    thopsIOleCache2_DiscardCache
};
THOP CONST * CONST apthopsIOleCacheControl[] =
{
    thopsIOleCacheControl_OnRun
,    thopsIOleCacheControl_OnStop
};
THOP CONST * CONST apthopsIDropTarget[] =
{
    thopsIDropTarget_DragEnter
,    thopsIDropTarget_DragOver
,    thopsIDropTarget_DragLeave
,    thopsIDropTarget_Drop
};
THOP CONST * CONST apthopsIDropSource[] =
{
    thopsIDropSource_QueryContinueDrag
,    thopsIDropSource_GiveFeedback
};
THOP CONST * CONST apthopsIPersist[] =
{
    thopsIPersist_GetClassID
};
THOP CONST * CONST apthopsIPersistStorage[] =
{
    thopsIPersistStorage_GetClassID
,    thopsIPersistStorage_IsDirty
,    thopsIPersistStorage_InitNew
,    thopsIPersistStorage_Load
,    thopsIPersistStorage_Save
,    thopsIPersistStorage_SaveCompleted
,    thopsIPersistStorage_HandsOffStorage
};
THOP CONST * CONST apthopsIPersistStream[] =
{
    thopsIPersistStream_GetClassID
,    thopsIPersistStream_IsDirty
,    thopsIPersistStream_Load
,    thopsIPersistStream_Save
,    thopsIPersistStream_GetSizeMax
};
THOP CONST * CONST apthopsIPersistFile[] =
{
    thopsIPersistFile_GetClassID
,    thopsIPersistFile_IsDirty
,    thopsIPersistFile_Load
,    thopsIPersistFile_Save
,    thopsIPersistFile_SaveCompleted
,    thopsIPersistFile_GetCurFile
};
THOP CONST * CONST apthopsIBindCtx[] =
{
    thopsIBindCtx_RegisterObjectBound
,    thopsIBindCtx_RevokeObjectBound
,    thopsIBindCtx_ReleaseBoundObjects
,    thopsIBindCtx_SetBindOptions
,    thopsIBindCtx_GetBindOptions
,    thopsIBindCtx_GetRunningObjectTable
,    thopsIBindCtx_RegisterObjectParam
,    thopsIBindCtx_GetObjectParam
,    thopsIBindCtx_EnumObjectParam
,    thopsIBindCtx_RevokeObjectParam
};
THOP CONST * CONST apthopsIMoniker[] =
{
    thopsIMoniker_GetClassID
,    thopsIMoniker_IsDirty
,    thopsIMoniker_Load
,    thopsIMoniker_Save
,    thopsIMoniker_GetSizeMax
,    thopsIMoniker_BindToObject
,    thopsIMoniker_BindToStorage
,    thopsIMoniker_Reduce
,    thopsIMoniker_ComposeWith
,    thopsIMoniker_Enum
,    thopsIMoniker_IsEqual
,    thopsIMoniker_Hash
,    thopsIMoniker_IsRunning
,    thopsIMoniker_GetTimeOfLastChange
,    thopsIMoniker_Inverse
,    thopsIMoniker_CommonPrefixWith
,    thopsIMoniker_RelativePathTo
,    thopsIMoniker_GetDisplayName
,    thopsIMoniker_ParseDisplayName
,    thopsIMoniker_IsSystemMoniker
};
THOP CONST * CONST apthopsIRunningObjectTable[] =
{
    thopsIRunningObjectTable_Register
,    thopsIRunningObjectTable_Revoke
,    thopsIRunningObjectTable_IsRunning
,    thopsIRunningObjectTable_GetObject
,    thopsIRunningObjectTable_NoteChangeTime
,    thopsIRunningObjectTable_GetTimeOfLastChange
,    thopsIRunningObjectTable_EnumRunning
};
THOP CONST * CONST apthopsIEnumMoniker[] =
{
    thopsIEnumMoniker_Next
,    thopsIEnumMoniker_Skip
,    thopsIEnumMoniker_Reset
,    thopsIEnumMoniker_Clone
};
THOP CONST * CONST apthopsIEnumOLEVERB[] =
{
    thopsIEnumOLEVERB_Next
,    thopsIEnumOLEVERB_Skip
,    thopsIEnumOLEVERB_Reset
,    thopsIEnumOLEVERB_Clone
};
THOP CONST * CONST apthopsIOleObject[] =
{
    thopsIOleObject_SetClientSite
,    thopsIOleObject_GetClientSite
,    thopsIOleObject_SetHostNames
,    thopsIOleObject_Close
,    thopsIOleObject_SetMoniker
,    thopsIOleObject_GetMoniker
,    thopsIOleObject_InitFromData
,    thopsIOleObject_GetClipboardData
,    thopsIOleObject_DoVerb
,    thopsIOleObject_EnumVerbs
,    thopsIOleObject_Update
,    thopsIOleObject_IsUpToDate
,    thopsIOleObject_GetUserClassID
,    thopsIOleObject_GetUserType
,    thopsIOleObject_SetExtent
,    thopsIOleObject_GetExtent
,    thopsIOleObject_Advise
,    thopsIOleObject_Unadvise
,    thopsIOleObject_EnumAdvise
,    thopsIOleObject_GetMiscStatus
,    thopsIOleObject_SetColorScheme
};
THOP CONST * CONST apthopsIOleClientSite[] =
{
    thopsIOleClientSite_SaveObject
,    thopsIOleClientSite_GetMoniker
,    thopsIOleClientSite_GetContainer
,    thopsIOleClientSite_ShowObject
,    thopsIOleClientSite_OnShowWindow
,    thopsIOleClientSite_RequestNewObjectLayout
};
THOP CONST * CONST apthopsIRunnableObject[] =
{
    thopsIRunnableObject_GetRunningClass
,    thopsIRunnableObject_Run
,    thopsIRunnableObject_IsRunning
,    thopsIRunnableObject_LockRunning
,    thopsIRunnableObject_SetContainedObject
};
THOP CONST * CONST apthopsIParseDisplayName[] =
{
    thopsIParseDisplayName_ParseDisplayName
};
THOP CONST * CONST apthopsIOleContainer[] =
{
    thopsIOleContainer_ParseDisplayName
,    thopsIOleContainer_EnumObjects
,    thopsIOleContainer_LockContainer
};
THOP CONST * CONST apthopsIOleItemContainer[] =
{
    thopsIOleItemContainer_ParseDisplayName
,    thopsIOleItemContainer_EnumObjects
,    thopsIOleItemContainer_LockContainer
,    thopsIOleItemContainer_GetObject
,    thopsIOleItemContainer_GetObjectStorage
,    thopsIOleItemContainer_IsRunning
};
THOP CONST * CONST apthopsIOleAdviseHolder[] =
{
    thopsIOleAdviseHolder_Advise
,    thopsIOleAdviseHolder_Unadvise
,    thopsIOleAdviseHolder_EnumAdvise
,    thopsIOleAdviseHolder_SendOnRename
,    thopsIOleAdviseHolder_SendOnSave
,    thopsIOleAdviseHolder_SendOnClose
};
THOP CONST * CONST apthopsIOleLink[] =
{
    thopsIOleLink_SetUpdateOptions
,    thopsIOleLink_GetUpdateOptions
,    thopsIOleLink_SetSourceMoniker
,    thopsIOleLink_GetSourceMoniker
,    thopsIOleLink_SetSourceDisplayName
,    thopsIOleLink_GetSourceDisplayName
,    thopsIOleLink_BindToSource
,    thopsIOleLink_BindIfRunning
,    thopsIOleLink_GetBoundSource
,    thopsIOleLink_UnbindSource
,    thopsIOleLink_Update
};
THOP CONST * CONST apthopsIOleWindow[] =
{
    thopsIOleWindow_GetWindow
,    thopsIOleWindow_ContextSensitiveHelp
};
THOP CONST * CONST apthopsIOleInPlaceObject[] =
{
    thopsIOleInPlaceObject_GetWindow
,    thopsIOleInPlaceObject_ContextSensitiveHelp
,    thopsIOleInPlaceObject_InPlaceDeactivate
,    thopsIOleInPlaceObject_UIDeactivate
,    thopsIOleInPlaceObject_SetObjectRects
,    thopsIOleInPlaceObject_ReactivateAndUndo
};
THOP CONST * CONST apthopsIOleInPlaceActiveObject[] =
{
    thopsIOleInPlaceActiveObject_GetWindow
,    thopsIOleInPlaceActiveObject_ContextSensitiveHelp
,    thopsIOleInPlaceActiveObject_TranslateAccelerator
,    thopsIOleInPlaceActiveObject_OnFrameWindowActivate
,    thopsIOleInPlaceActiveObject_OnDocWindowActivate
,    thopsIOleInPlaceActiveObject_ResizeBorder
,    thopsIOleInPlaceActiveObject_EnableModeless
};
THOP CONST * CONST apthopsIOleInPlaceUIWindow[] =
{
    thopsIOleInPlaceUIWindow_GetWindow
,    thopsIOleInPlaceUIWindow_ContextSensitiveHelp
,    thopsIOleInPlaceUIWindow_GetBorder
,    thopsIOleInPlaceUIWindow_RequestBorderSpace
,    thopsIOleInPlaceUIWindow_SetBorderSpace
,    thopsIOleInPlaceUIWindow_SetActiveObject
};
THOP CONST * CONST apthopsIOleInPlaceFrame[] =
{
    thopsIOleInPlaceFrame_GetWindow
,    thopsIOleInPlaceFrame_ContextSensitiveHelp
,    thopsIOleInPlaceFrame_GetBorder
,    thopsIOleInPlaceFrame_RequestBorderSpace
,    thopsIOleInPlaceFrame_SetBorderSpace
,    thopsIOleInPlaceFrame_SetActiveObject
,    thopsIOleInPlaceFrame_InsertMenus
,    thopsIOleInPlaceFrame_SetMenu
,    thopsIOleInPlaceFrame_RemoveMenus
,    thopsIOleInPlaceFrame_SetStatusText
,    thopsIOleInPlaceFrame_EnableModeless
,    thopsIOleInPlaceFrame_TranslateAccelerator
};
THOP CONST * CONST apthopsIOleInPlaceSite[] =
{
    thopsIOleInPlaceSite_GetWindow
,    thopsIOleInPlaceSite_ContextSensitiveHelp
,    thopsIOleInPlaceSite_CanInPlaceActivate
,    thopsIOleInPlaceSite_OnInPlaceActivate
,    thopsIOleInPlaceSite_OnUIActivate
,    thopsIOleInPlaceSite_GetWindowContext
,    thopsIOleInPlaceSite_Scroll
,    thopsIOleInPlaceSite_OnUIDeactivate
,    thopsIOleInPlaceSite_OnInPlaceDeactivate
,    thopsIOleInPlaceSite_DiscardUndoState
,    thopsIOleInPlaceSite_DeactivateAndUndo
,    thopsIOleInPlaceSite_OnPosRectChange
};
THOP CONST * CONST apthopsIRpcChannelBuffer[] =
{
    thopsIRpcChannelBuffer_GetBuffer
,    thopsIRpcChannelBuffer_SendReceive
,    thopsIRpcChannelBuffer_FreeBuffer
,    thopsIRpcChannelBuffer_GetDestCtx
,    thopsIRpcChannelBuffer_IsConnected
};
THOP CONST * CONST apthopsIRpcProxyBuffer[] =
{
    thopsIRpcProxyBuffer_Connect
,    thopsIRpcProxyBuffer_Disconnect
};
THOP CONST * CONST apthopsIRpcStubBuffer[] =
{
    thopsIRpcStubBuffer_Connect
,    thopsIRpcStubBuffer_Disconnect
,    thopsIRpcStubBuffer_Invoke
,    thopsIRpcStubBuffer_IsIIDSupported
,    thopsIRpcStubBuffer_CountRefs
,    thopsIRpcStubBuffer_DebugServerQueryInterface
,    thopsIRpcStubBuffer_DebugServerRelease
};
THOP CONST * CONST apthopsIPSFactoryBuffer[] =
{
    thopsIPSFactoryBuffer_CreateProxy
,    thopsIPSFactoryBuffer_CreateStub
};
THOP CONST * CONST apthopsIRpcChannel[] =
{
    thopsIRpcChannel_GetStream
,    thopsIRpcChannel_Call
,    thopsIRpcChannel_GetDestCtx
,    thopsIRpcChannel_IsConnected
};
THOP CONST * CONST apthopsIRpcProxy[] =
{
    thopsIRpcProxy_Connect
,    thopsIRpcProxy_Disconnect
};
THOP CONST * CONST apthopsIRpcStub[] =
{
    thopsIRpcStub_Connect
,    thopsIRpcStub_Disconnect
,    thopsIRpcStub_Invoke
,    thopsIRpcStub_IsIIDSupported
,    thopsIRpcStub_CountRefs
};
THOP CONST * CONST apthopsIPSFactory[] =
{
    thopsIPSFactory_CreateProxy
,    thopsIPSFactory_CreateStub
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\vtblifn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	vtblifn.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

DWORD ThunkMethod3216_48(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[48];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_47(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[47];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_46(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[46];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_45(
    THUNK3216OBJ *ptoThis32,
    SIZEL Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(SIZEL *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[45];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_44(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    WORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(WORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[44];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_43(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[43];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_42(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[42];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_41(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[41];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_40(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[40];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_39(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[39];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_38(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[38];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_37(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[37];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_36(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[36];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_35(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[35];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_34(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[34];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_33(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    SIZEL Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(SIZEL *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[33];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_32(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    SIZEL Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(SIZEL *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[32];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_31(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    SIZEL Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(SIZEL *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[31];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_30(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[30];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_29(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[29];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_28(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6,
    DWORD Arg7,
    DWORD Arg8,
    DWORD Arg9,
    DWORD Arg10
    )
{
    DWORD dwMethod;
    BYTE bArgs[44];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    *(DWORD *)(bArgs+28) = Arg7;
    *(DWORD *)(bArgs+32) = Arg8;
    *(DWORD *)(bArgs+36) = Arg9;
    *(DWORD *)(bArgs+40) = Arg10;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[28];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_27(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[27];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_26(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[26];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_25(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[25];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_24(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[24];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_23(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[23];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_22(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[22];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_21(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[21];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_20(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[20];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_19(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[19];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_18(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    ULARGE_INTEGER Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[18];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_17(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[17];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_16(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    ULARGE_INTEGER Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+20) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[16];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_15(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    ULARGE_INTEGER Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+20) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[15];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_14(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[14];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_13(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[13];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_12(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[12];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_11(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[11];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_10(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[10];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_9(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6
    )
{
    DWORD dwMethod;
    BYTE bArgs[28];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[9];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_8(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6
    )
{
    DWORD dwMethod;
    BYTE bArgs[28];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[8];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_7(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6
    )
{
    DWORD dwMethod;
    BYTE bArgs[28];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[7];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_6(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[6];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_5(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[5];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_4(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[4];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_3(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[3];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_2(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[2];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_1(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[1];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_0(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[0];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\thopsint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thopsint.cxx
//
//  Notes:      This file is automatically generated
//              Do not modify by hand
//
//  History:    Fri May 27 10:39:02 1994        Generated
//
//----------------------------------------------------------------------------

THOP CONST thopsIClassFactory_CreateInstance[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIClassFactory_LockServer[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMarshal_GetUnmarshalClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIMarshal_GetMarshalSizeMax[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIMarshal_MarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIMarshal_UnmarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMarshal_ReleaseMarshalData[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMarshal_DisconnectObject[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStdMarshalInfo_GetClassForHandler[] =
{
    THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMessageFilter_HandleInComingCall[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_COPY, 4, THOP_HTASK, THOP_COPY, 4, THOP_INTERFACEINFO | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMessageFilter_RetryRejectedCall[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_HTASK, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMessageFilter_MessagePending[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_HTASK, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIExternalConnection_AddConnection[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIExternalConnection_ReleaseConnection[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumString_Next[] =
{
    THOP_ENUM, THE_IEnumString, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumString_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumString_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumString_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumString, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumUnknown_Next[] =
{
    THOP_ENUM, THE_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumUnknown_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumUnknown_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumUnknown_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATSTG_Next[] =
{
    THOP_ENUM, THE_IEnumSTATSTG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumSTATSTG_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATSTG_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumSTATSTG_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATSTG, THOP_END, THOP_ROUTINEINDEX, 3
};

// Note:    THOP_BUFFER | THOP_OUT takes care of the size of the input buffer
//          and the size of the output buffer.
THOP CONST thopsILockBytes_ReadAt[] =
{
    THOP_COPY, 8, THOP_BUFFER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 9
};
THOP CONST thopsILockBytes_WriteAt[] =
{
    THOP_COPY, 8, THOP_BUFFER | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 9
};
THOP CONST thopsILockBytes_Flush[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsILockBytes_SetSize[] =
{
    THOP_COPY, 8, THOP_END, THOP_ROUTINEINDEX, 10
};
THOP CONST thopsILockBytes_LockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsILockBytes_UnlockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsILockBytes_Stat[] =
{
    THOP_STATSTG | THOP_OUT, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};

// Note:    THOP_BUFFER | THOP_OUT takes care of the size of the input buffer
//          and the size of the output buffer.
THOP CONST thopsIStream_Read[] =
{
    THOP_BUFFER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 2
};

THOP CONST thopsIStream_Write[] =
{
    THOP_BUFFER | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIStream_Seek[] =
{
    THOP_COPY, 8, THOP_COPY, 4, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 12
};
THOP CONST thopsIStream_SetSize[] =
{
    THOP_COPY, 8, THOP_END, THOP_ROUTINEINDEX, 10
};
THOP CONST thopsIStream_CopyTo[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY, 8, THOP_COPY | THOP_OUT, 8, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 13
};
THOP CONST thopsIStream_Commit[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStream_Revert[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIStream_LockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsIStream_UnlockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsIStream_Stat[] =
{
    THOP_STATSTG | THOP_OUT, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIStream_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_CreateStream[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIStorage_OpenStream[] =
{
    THOP_LPSTR | THOP_IN, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIStorage_CreateStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIStorage_OpenStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY, 4, THOP_SNB, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIStorage_CopyTo[] =
{
    THOP_CRGIID, THOP_SNB, THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_MoveElementTo[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IStorage, THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_Commit[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_Revert[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIStorage_EnumElements[] =
{
    THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumSTATSTG, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_DestroyElement[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_RenameElement[] =
{
    THOP_LPSTR | THOP_IN, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIStorage_SetElementTimes[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_SetClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_SetStateBits[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIStorage_Stat[] =
{
    THOP_STATSTG | THOP_OUT, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRootStorage_SwitchToFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumFORMATETC_Next[] =
{
    THOP_ENUM, THE_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumFORMATETC_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumFORMATETC_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumFORMATETC_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATDATA_Next[] =
{
    THOP_ENUM, THE_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumSTATDATA_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATDATA_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumSTATDATA_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataObject_GetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_OUT, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_GetDataHere[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_QueryGetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataObject_GetCanonicalFormatEtc[] =
{
    THOP_FORMATETC | THOP_IN, THOP_FORMATETC | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_SetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 1, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIDataObject_EnumFormatEtc[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_DAdvise[] =
{
    THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIDataObject_DUnadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataObject_EnumDAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIViewObject_Draw[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_HGDI, THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_CALLBACK, THOP_END, THOP_ROUTINEINDEX, 14
};
THOP CONST thopsIViewObject_GetColorSet[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_LOGPALETTE | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIViewObject_Freeze[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIViewObject_Unfreeze[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIViewObject_SetAdvise[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject_GetAdvise[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject2_Draw[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_HGDI, THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_CALLBACK, THOP_END, THOP_ROUTINEINDEX, 14
};
THOP CONST thopsIViewObject2_GetColorSet[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_LOGPALETTE | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIViewObject2_Freeze[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIViewObject2_Unfreeze[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIViewObject2_SetAdvise[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject2_GetAdvise[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject2_GetExtent[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_DVTARGETDEVICE | THOP_IN, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIAdviseSink_OnDataChange[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink_OnViewChange[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink_OnRename[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIAdviseSink_OnSave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink_OnClose[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink2_OnDataChange[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink2_OnViewChange[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink2_OnRename[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIAdviseSink2_OnSave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink2_OnClose[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink2_OnLinkSrcChange[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataAdviseHolder_Advise[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIDataAdviseHolder_Unadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataAdviseHolder_EnumAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataAdviseHolder_SendOnDataChange[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache_Cache[] =
{
    THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache_Uncache[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache_EnumCache[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache_InitCache[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache_SetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 1, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_Cache[] =
{
    THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_Uncache[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache2_EnumCache[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache2_InitCache[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache2_SetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 1, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_UpdateCache[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_DiscardCache[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCacheControl_OnRun[] =
{
    THOP_IFACENOADDREF | THOP_IN, THI_IDataObject, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCacheControl_OnStop[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIDropTarget_DragEnter[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_COPY, 8, THOP_COPY | THOP_INOUT, 4, THOP_END, THOP_ROUTINEINDEX, 15
};
THOP CONST thopsIDropTarget_DragOver[] =
{
    THOP_COPY, 4, THOP_COPY, 8, THOP_COPY | THOP_INOUT, 4, THOP_END, THOP_ROUTINEINDEX, 16
};
THOP CONST thopsIDropTarget_DragLeave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIDropTarget_Drop[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_COPY, 8, THOP_COPY | THOP_INOUT, 4, THOP_END, THOP_ROUTINEINDEX, 15
};
THOP CONST thopsIDropSource_QueryContinueDrag[] =
{
    THOP_SHORTLONG, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDropSource_GiveFeedback[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersist_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistStorage_InitNew[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_Load[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_Save[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistStorage_SaveCompleted[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_HandsOffStorage[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistStream_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStream_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistStream_Load[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStream_Save[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistStream_GetSizeMax[] =
{
    THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistFile_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistFile_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistFile_Load[] =
{
    THOP_FILENAME | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistFile_Save[] =
{
    THOP_FILENAME | THOP_IN, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistFile_SaveCompleted[] =
{
    THOP_FILENAME | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistFile_GetCurFile[] =
{
    THOP_FILENAME | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RegisterObjectBound[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RevokeObjectBound[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_ReleaseBoundObjects[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIBindCtx_SetBindOptions[] =
{
    THOP_BINDOPTS | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_GetBindOptions[] =
{
    THOP_BINDOPTS | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_GetRunningObjectTable[] =
{
    THOP_IFACE | THOP_OUT, THI_IRunningObjectTable, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RegisterObjectParam[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIBindCtx_GetObjectParam[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIBindCtx_EnumObjectParam[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumString, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RevokeObjectParam[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIMoniker_Load[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_Save[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_GetSizeMax[] =
{
    THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_BindToObject[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMoniker_BindToStorage[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMoniker_Reduce[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_COPY, 4, THOP_IFACE | THOP_INOUT, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMoniker_ComposeWith[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_SHORTLONG, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_Enum[] =
{
    THOP_SHORTLONG, THOP_IFACE | THOP_OUT, THI_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_IsEqual[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_Hash[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_IsRunning[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_GetTimeOfLastChange[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_Inverse[] =
{
    THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_CommonPrefixWith[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_RelativePathTo[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_GetDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIMoniker_IsSystemMoniker[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunningObjectTable_Register[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIRunningObjectTable_Revoke[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunningObjectTable_IsRunning[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunningObjectTable_GetObject[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunningObjectTable_NoteChangeTime[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunningObjectTable_GetTimeOfLastChange[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunningObjectTable_EnumRunning[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumMoniker_Next[] =
{
    THOP_ENUM, THE_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumMoniker_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumMoniker_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumMoniker_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumOLEVERB_Next[] =
{
    THOP_ENUM, THE_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumOLEVERB_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumOLEVERB_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumOLEVERB_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_SetClientSite[] =
{
    THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_GetClientSite[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleClientSite, THOP_END, THOP_ROUTINEINDEX, 3
};
/*
  The eighty character limit was arrived at by trial and error
  with ClipArt Gallery.  It faults at 90 characters.
  */
THOP CONST thopsIOleObject_SetHostNames[] =
{
    THOP_LPSTR | THOP_IN, THOP_SIZEDSTRING | THOP_IN, 80, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_Close[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_SetMoniker[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_GetMoniker[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleObject_InitFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_SHORTLONG, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleObject_GetClipboardData[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_DoVerb[] =
{
    THOP_COPY, 4, THOP_MSG | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_COPY, 4, THOP_HUSER, THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIOleObject_EnumVerbs[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_Update[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleObject_IsUpToDate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleObject_GetUserClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_GetUserType[] =
{
    THOP_COPY, 4, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_SetExtent[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_GetExtent[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_Advise[] =
{
    THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_Unadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_EnumAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_GetMiscStatus[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_SetColorScheme[] =
{
    THOP_LOGPALETTE | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleClientSite_SaveObject[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleClientSite_GetMoniker[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleClientSite_GetContainer[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleContainer, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleClientSite_ShowObject[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleClientSite_OnShowWindow[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleClientSite_RequestNewObjectLayout[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRunnableObject_GetRunningClass[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunnableObject_Run[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunnableObject_IsRunning[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRunnableObject_LockRunning[] =
{
    THOP_SHORTLONG, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunnableObject_SetContainedObject[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIParseDisplayName_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleContainer_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleContainer_EnumObjects[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleContainer_LockContainer[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleItemContainer_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleItemContainer_EnumObjects[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleItemContainer_LockContainer[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleItemContainer_GetObject[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIOleItemContainer_GetObjectStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleItemContainer_IsRunning[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_Advise[] =
{
    THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleAdviseHolder_Unadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_EnumAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_SendOnRename[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_SendOnSave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleAdviseHolder_SendOnClose[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleLink_SetUpdateOptions[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_GetUpdateOptions[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_SetSourceMoniker[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleLink_GetSourceMoniker[] =
{
    THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_SetSourceDisplayName[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_GetSourceDisplayName[] =
{
    THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_BindToSource[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleLink_BindIfRunning[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleLink_GetBoundSource[] =
{
    THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_UnbindSource[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleLink_Update[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleWindow_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleWindow_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceObject_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceObject_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceObject_InPlaceDeactivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceObject_UIDeactivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceObject_SetObjectRects[] =
{
    THOP_RECT | THOP_IN, THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceObject_ReactivateAndUndo[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceActiveObject_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_TranslateAccelerator[] =
{
    THOP_MSG | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_OnFrameWindowActivate[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_OnDocWindowActivate[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_ResizeBorder[] =
{
    THOP_RECT | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleInPlaceFrame, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleInPlaceActiveObject_EnableModeless[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_GetBorder[] =
{
    THOP_RECT | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_RequestBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_SetBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_SetActiveObject[] =
{
    THOP_IFACE | THOP_IN, THI_IOleInPlaceActiveObject, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceFrame_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_GetBorder[] =
{
    THOP_RECT | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_RequestBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_SetBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_SetActiveObject[] =
{
    THOP_IFACE | THOP_IN, THI_IOleInPlaceActiveObject, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceFrame_InsertMenus[] =
{
    THOP_HUSER, THOP_COPY | THOP_INOUT, 24, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceFrame_SetMenu[] =
{
    THOP_HUSER, THOP_ALIAS32, ALIAS_RESOLVE, THOP_HUSER, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleInPlaceFrame_RemoveMenus[] =
{
    THOP_HUSER, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_SetStatusText[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_EnableModeless[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_TranslateAccelerator[] =
{
    THOP_MSG | THOP_IN, THOP_WORDDWORD, THOP_END, THOP_ROUTINEINDEX, 17
};
THOP CONST thopsIOleInPlaceSite_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceSite_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceSite_CanInPlaceActivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_OnInPlaceActivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_OnUIActivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_GetWindowContext[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleInPlaceFrame, THOP_IFACE | THOP_OUT, THI_IOleInPlaceUIWindow, THOP_RECT | THOP_OUT, THOP_RECT | THOP_OUT, THOP_OIFI | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIOleInPlaceSite_Scroll[] =
{
    THOP_SIZE, THOP_END, THOP_ROUTINEINDEX, 18
};
THOP CONST thopsIOleInPlaceSite_OnUIDeactivate[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceSite_OnInPlaceDeactivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_DiscardUndoState[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_DeactivateAndUndo[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_OnPosRectChange[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcChannelBuffer_GetBuffer[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannelBuffer_SendReceive[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannelBuffer_FreeBuffer[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcChannelBuffer_GetDestCtx[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_NULL | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannelBuffer_IsConnected[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcProxyBuffer_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IRpcChannelBuffer, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcProxyBuffer_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStubBuffer_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStubBuffer_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStubBuffer_Invoke[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_IFACE | THOP_IN, THI_IRpcChannelBuffer, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcStubBuffer_IsIIDSupported[] =
{
    THOP_RETURNTYPE, THOP_IFACE | THOP_IN, THI_IRpcStubBuffer, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStubBuffer_CountRefs[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStubBuffer_DebugServerQueryInterface[] =
{
    THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStubBuffer_DebugServerRelease[] =
{
    THOP_IFACECLEAN | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPSFactoryBuffer_CreateProxy[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_IFACEOWNER | THOP_OUT, THI_IRpcProxyBuffer, 8, THOP_IFACEGENOWNER | THOP_OUT, 8, 12, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIPSFactoryBuffer_CreateStub[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_OUT, THI_IRpcStubBuffer, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIRpcChannel_GetStream[] =
{
    THOP_COPY | THOP_IN, 16, THOP_SHORTLONG, THOP_SHORTLONG, THOP_SHORTLONG, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIRpcChannel_Call[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcChannel_GetDestCtx[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_NULL | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannel_IsConnected[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcProxy_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IRpcChannel, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcProxy_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStub_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStub_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStub_Invoke[] =
{
    THOP_COPY | THOP_IN, 16, THOP_SHORTLONG, THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIRpcStub_IsIIDSupported[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStub_CountRefs[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPSFactory_CreateProxy[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16,  THOP_IFACEOWNER | THOP_OUT, THI_IRpcProxy, 8, THOP_IFACEGENOWNER | THOP_OUT, 8, 12, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIPSFactory_CreateStub[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_OUT, THI_IRpcStub, THOP_END, THOP_ROUTINEINDEX, 2
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\vtblint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	vtblint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

THUNK3216FN CONST tfnIUnknown[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
};
THUNK3216FN CONST tfnIClassFactory[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_1
};
THUNK3216FN CONST tfnIMarshal[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_7
,    (THUNK3216FN)ThunkMethod3216_8
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIStdMarshalInfo[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_0
};
THUNK3216FN CONST tfnIMessageFilter[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_10
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_11
};
THUNK3216FN CONST tfnIExternalConnection[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_11
};
THUNK3216FN CONST tfnIEnumString[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIEnumUnknown[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIEnumSTATSTG[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnILockBytes[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_12
,    (THUNK3216FN)ThunkMethod3216_13
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_14
,    (THUNK3216FN)ThunkMethod3216_15
,    (THUNK3216FN)ThunkMethod3216_16
,    (THUNK3216FN)ThunkMethod3216_2
};
THUNK3216FN CONST tfnIStream[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_17
,    (THUNK3216FN)ThunkMethod3216_14
,    (THUNK3216FN)ThunkMethod3216_18
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_16
,    (THUNK3216FN)ThunkMethod3216_15
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIStorage[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_19
,    (THUNK3216FN)ThunkMethod3216_20
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_10
,    (THUNK3216FN)ThunkMethod3216_22
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_23
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_26
};
THUNK3216FN CONST tfnIRootStorage[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
};
THUNK3216FN CONST tfnIEnumFORMATETC[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIEnumSTATDATA[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIDataObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIViewObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_28
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
};
THUNK3216FN CONST tfnIViewObject2[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_28
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_23
};
THUNK3216FN CONST tfnIAdviseSink[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_29
};
THUNK3216FN CONST tfnIAdviseSink2[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIDataAdviseHolder[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_11
};
THUNK3216FN CONST tfnIOleCache[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_0
};
THUNK3216FN CONST tfnIOleCache2[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_30
,    (THUNK3216FN)ThunkMethod3216_1
};
THUNK3216FN CONST tfnIOleCacheControl[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
};
THUNK3216FN CONST tfnIDropTarget[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_31
,    (THUNK3216FN)ThunkMethod3216_32
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_33
};
THUNK3216FN CONST tfnIDropSource[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_5
};
THUNK3216FN CONST tfnIPersist[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
};
THUNK3216FN CONST tfnIPersistStorage[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_6
};
THUNK3216FN CONST tfnIPersistStream[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIPersistFile[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIBindCtx[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_36
};
THUNK3216FN CONST tfnIMoniker[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_23
,    (THUNK3216FN)ThunkMethod3216_22
,    (THUNK3216FN)ThunkMethod3216_30
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_1
};
THUNK3216FN CONST tfnIRunningObjectTable[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_34
};
THUNK3216FN CONST tfnIEnumMoniker[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_35
};
THUNK3216FN CONST tfnIEnumOLEVERB[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_35
};
THUNK3216FN CONST tfnIOleObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_30
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_38
,    (THUNK3216FN)ThunkMethod3216_39
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
};
THUNK3216FN CONST tfnIOleClientSite[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
};
THUNK3216FN CONST tfnIRunnableObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_35
};
THUNK3216FN CONST tfnIParseDisplayName[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
};
THUNK3216FN CONST tfnIOleContainer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
};
THUNK3216FN CONST tfnIOleItemContainer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_23
,    (THUNK3216FN)ThunkMethod3216_36
};
THUNK3216FN CONST tfnIOleAdviseHolder[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_29
};
THUNK3216FN CONST tfnIOleLink[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIOleWindow[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
};
THUNK3216FN CONST tfnIOleInPlaceObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_6
};
THUNK3216FN CONST tfnIOleInPlaceActiveObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIOleInPlaceUIWindow[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_41
};
THUNK3216FN CONST tfnIOleInPlaceFrame[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_44
};
THUNK3216FN CONST tfnIOleInPlaceSite[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_45
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_46
,    (THUNK3216FN)ThunkMethod3216_47
,    (THUNK3216FN)ThunkMethod3216_48
,    (THUNK3216FN)ThunkMethod3216_34
};
THUNK3216FN CONST tfnIRpcChannelBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_39
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcProxyBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcStubBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_47
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
};
THUNK3216FN CONST tfnIPSFactoryBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_37
};
THUNK3216FN CONST tfnIRpcChannel[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcProxy[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcStub[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_47
};
THUNK3216FN CONST tfnIPSFactory[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_37
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\clspsht.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       ClsPSht.h
//
//  Contents:   
//
//  Classes:    
//
//  Methods:    
//
//  History:    
//
//----------------------------------------------------------------------

// This class defines custom modal property sheet
// CClsidPropertySheet.

#ifndef __CLSPSHT_H__
#define __CLSPSHT_H__

#include "LocPPg.h"
#include "epoptppg.h"

#define INPROC 0
#define LOCALEXE 1
#define SERVICE 2
#define PURE_REMOTE 3
#define REMOTE_LOCALEXE 4
#define REMOTE_SERVICE 5
#define SURROGATE 6

/////////////////////////////////////////////////////////////////////////////
// CClsidPropertySheet

class CClsidPropertySheet : public CPropertySheet
{
        DECLARE_DYNAMIC(CClsidPropertySheet)

// Construction
public:
        CClsidPropertySheet(CWnd* pParentWnd = NULL);
        BOOL InitData(
                CString szAppName,
                HKEY hkAppID,
                HKEY * rghkCLSID,
                unsigned cCLSIDs);

// Attributes
public:
        CGeneralPropertyPage  m_Page1;
        CLocationPropertyPage m_Page2;
        CSecurityPropertyPage m_Page3;
        CIdentityPropertyPage m_Page4;
        CRpcOptionsPropertyPage m_Page5;

// Operations
public:

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CClsidPropertySheet)
        protected:
        virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
public:
        CString m_szAppName;
        HKEY    m_hkAppID;
        HKEY *  m_rghkCLSID;
        unsigned m_cCLSIDs;

        BOOL    ValidateAndUpdate(void);
        BOOL    ChangeCLSIDInfo(BOOL fLocal);
        BOOL    LookAtCLSIDs(void);

        virtual ~CClsidPropertySheet();

// Generated message map functions
protected:
        //{{AFX_MSG(CClsidPropertySheet)
        afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif  // __CLSPSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\cnfgdlg.h ===
// CnfgDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COlecnfgDlg dialog

class COlecnfgDlg : public CDialog
{
// Construction
public:
    void OnProperties();
    COlecnfgDlg(CWnd* pParent = NULL);  // standard constructor

// Dialog Data
    //{{AFX_DATA(COlecnfgDlg)
    enum { IDD = IDD_OLECNFG_DIALOG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COlecnfgDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(COlecnfgDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\creg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       creg.h
//
//  Contents:   Defines class CRegistry to wrap registry access
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------

typedef enum {_LOCALSERVER, LOCALSERVER, _LOCALSERVER32, LOCALSERVER32,
              LOCALSERVICE, REMOTESERVER} SRVTYPE;


// Wraps registry access

class CRegistry
{
 public:

            CRegistry(void);

           ~CRegistry(void);

    BOOL    Init(void);

    BOOL    InitGetItem(void);

    SItem  *GetNextItem(void); 

    SItem  *GetItem(DWORD dwItem);

    SItem  *FindItem(TCHAR *szItem);

    SItem  *FindAppid(TCHAR *szAppid);

    void    AppendIndex(SItem *pItem, DWORD dwIndex);

    DWORD   GetNumItems(void);

 private:

    CStrings m_applications;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\cstrings.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cstrings.cpp
//
//  Contents:   Implements the class CStrings to manage a dynamically
//              expandable array of string pairs which may be enumerated
//
//  Classes:
//
//  Methods:    CStrings::CStrings
//              CStrings::~CStrings
//              CStrings::PutItem
//              CStrings::FindItem
//              CStrings::FindAppid
//              CStrings::AddClsid
//              CStrings::InitGetNext
//              CStrings::GetNextItem
//              CStrings::GetItem
//              CStrings::GetNumItems
//              CStrings::RemoveItem
//              CStrings::RemoveAll
//
//  History:    23-Apr-96   BruceMa     Created.
//
//----------------------------------------------------------------------
#include "stdafx.h"
#include "types.h"
#include "cstrings.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CStrings::CStrings(void)
{
    m_nCount = 0;
}

CStrings::~CStrings(void)
{
    RemoveAll();
}


// Store a string pair, expanding the array if necessary
SItem *CStrings::PutItem(TCHAR *szString, TCHAR *szTitle, TCHAR *szAppid)
{
    SItem *psTemp = new SItem(szString, szTitle, szAppid);

    if (psTemp )
        arrSItems.Add(psTemp);

    return psTemp;
}



SItem *CStrings::FindItem(TCHAR *szItem)
{
    for (int wItem = 0; wItem < arrSItems.GetSize(); wItem++)
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(wItem);
        if (pTmp -> szItem .CompareNoCase(szItem) == 0)
            return pTmp;
    }

    return NULL;
}



SItem *CStrings::FindAppid(TCHAR *szAppid)
{
    for (int wItem = 0; wItem < arrSItems.GetSize(); wItem++)
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(wItem);
        if (!(pTmp -> szItem.IsEmpty())  &&
            (pTmp -> szAppid.CompareNoCase(szAppid) == 0))
        {
            return pTmp;
        }
    }

    return NULL;
}

BOOL CStrings::AddClsid(SItem *pItem, TCHAR *szClsid)
{
    // Create or expand the clsid table if necessary
    if (pItem->ulClsids == pItem->ulClsidTbl)
    {
        TCHAR **ppTmp = new TCHAR *[pItem->ulClsidTbl + 8];
        if (ppTmp == NULL)
        {
            return FALSE;
        }
        if (pItem->ppszClsids)
        {
            memcpy(ppTmp,
                   pItem->ppszClsids,
                   pItem->ulClsids * sizeof(TCHAR *));
            delete pItem->ppszClsids;
        }
        pItem->ppszClsids = ppTmp;
        pItem->ulClsidTbl += 8;
    }

    // Add the new clsid
    TCHAR *pszTmp = new TCHAR[GUIDSTR_MAX + 1];
    if (pszTmp == NULL)
    {
        return FALSE;
    }
        _tcscpy(pszTmp, szClsid);
    pItem->ppszClsids[pItem->ulClsids++] = pszTmp;

    return TRUE;
}

// Prepare to enumerate the array
DWORD CStrings::InitGetNext(void)
{
    m_nCount = 0;
    return (DWORD)arrSItems.GetSize();
}




// Return the first string in the next eumerated item
SItem *CStrings::GetNextItem(void)
{
    if (m_nCount < arrSItems.GetSize())
    {
        return (SItem*)(arrSItems[m_nCount++]);
    }
    else
    {
        m_nCount = 0;
        return NULL;
    }
}

// Return the first string in the next eumerated item
SItem *CStrings::GetItem(DWORD dwItem)
{
    if (((int)dwItem) < arrSItems.GetSize())
    {
        return (SItem*)(arrSItems[dwItem]);
    }
    else
    {
        m_nCount = 0;
        return NULL;
    }
}




// Return the total number of items
DWORD CStrings::GetNumItems(void)
{
    return (DWORD)arrSItems.GetSize();
}

// Given an item index, remove it
BOOL CStrings::RemoveItem(DWORD dwItem)
{
    if (((int)dwItem) < arrSItems.GetSize())
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(dwItem);

        if (pTmp)
        {
            arrSItems.RemoveAt(dwItem);
            delete pTmp;
            return TRUE;
        }
    }

    return FALSE;
}

// Remove the array of items
BOOL CStrings::RemoveAll(void)
{
    int nItems = (int)arrSItems.GetSize();

    for (int nItem = 0; nItem < nItems; nItem++)
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(nItem);
        delete pTmp;
    }

    arrSItems.RemoveAll();

    return TRUE;
}

SItem::SItem(LPCTSTR sItem, LPCTSTR sTitle, LPCTSTR sAppid)
: szItem(sItem), szTitle(sTitle), szAppid(sAppid)
{
    fMarked = FALSE;
    fChecked = FALSE;
    fHasAppid = FALSE;
    fDontDisplay = FALSE;
    ulClsids = 0;
    ulClsidTbl = 0;
    ppszClsids = 0;
}

SItem::~SItem()
{
    for (UINT k = 0; k < ulClsids; k++)
    {
        delete ppszClsids[k];
    }
    ulClsids = 0;
    ulClsidTbl = 0;
    delete ppszClsids;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\cnfgpsht.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cnfgpsht.cpp
//
//  Contents:   Implements class COlecnfgPropertySheet
//
//  Classes:
//
//  Methods:    COlecnfgPropertySheet::COlecnfgPropertySheet
//              COlecnfgPropertySheet::~COlecnfgPropertySheet
//              COlecnfgPropertySheet::DoModal
//              COlecnfgPropertySheet::Create
//              COlecnfgPropertySheet::OnNcCreate
//              COlecnfgPropertySheet::OnCommand
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "resource.h"
#include "cstrings.h"
#include "creg.h"
#include "types.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
    extern "C"
    {
    #include <getuser.h>
    }
#endif

#include "util.h"
#include "virtreg.h"
#include "CnfgPSht.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COlecnfgPropertySheet

IMPLEMENT_DYNAMIC(COlecnfgPropertySheet, CPropertySheet)

COlecnfgPropertySheet::COlecnfgPropertySheet(CWnd* pWndParent)
: CPropertySheet(IDS_PROPSHT_CAPTION, pWndParent)
{
    // Set the title
    CString sTitle;
    sTitle.LoadString(IDS_PSMAIN_TITLE);
    SetTitle(sTitle, PSH_PROPTITLE);
    
    // Add all of the property pages here.  Note that
    // the order that they appear in here will be
    // the order they appear in on screen.  By default,
    // the first page of the set is the active one.
    // One way to make a different property page the
    // active one is to call SetActivePage().
    
    // Disable property sheet help button
    m_psh.dwFlags &= ~PSH_HASHELP;
    m_Page1.m_psp.dwFlags &= ~PSH_HASHELP;
    m_Page2.m_psp.dwFlags &= ~PSH_HASHELP;
    m_Page3.m_psp.dwFlags &= ~PSH_HASHELP;
    m_Page4.m_psp.dwFlags &= ~PSH_HASHELP;

    AddPage(&m_Page1);
    AddPage(&m_Page2);
    AddPage(&m_Page3);
    AddPage(&m_Page4);
}

COlecnfgPropertySheet::~COlecnfgPropertySheet()
{
}


BEGIN_MESSAGE_MAP(COlecnfgPropertySheet, CPropertySheet)
//{{AFX_MSG_MAP(COlecnfgPropertySheet)
ON_WM_NCCREATE()
ON_WM_DESTROY()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// COlecnfgPropertySheet message handlers



INT_PTR COlecnfgPropertySheet::DoModal()
{
    return CPropertySheet::DoModal();
}

BOOL COlecnfgPropertySheet::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
    return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

BOOL COlecnfgPropertySheet::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (!CPropertySheet::OnNcCreate(lpCreateStruct))
        return FALSE;

    // Enable context help
    ModifyStyleEx(0, WS_EX_CONTEXTHELP);

    return TRUE;
}

BOOL COlecnfgPropertySheet::OnCommand(WPARAM wParam, LPARAM lParam)
{
    // TODO: Add your specialized code here and/or call the base class
    switch (LOWORD(wParam))
    {
    case IDOK:
    case ID_APPLY_NOW:
        g_virtreg.ApplyAll();

        
        // Check whether the user changed something that requires a notification to DCOM
        if (g_fReboot)
        {
            g_util.UpdateDCOMInfo();

            // With the above interface to the SCM we don't have to ask the
            // user whether to reboot.  However, I'll keep the code for
            // posterity.
/*
            CString sCaption;
            CString sMessage;

            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            sMessage.LoadString(IDS_REBOOT);
            if (MessageBox(sMessage, sCaption, MB_YESNO) == IDYES)
            {
                if (g_util.AdjustPrivilege(SE_SHUTDOWN_NAME))
                {
                    // Now reboot
                    ExitWindowsEx(EWX_REBOOT, 0);
                }
            }
*/
        }

        break;

    }
    return CPropertySheet::OnCommand(wParam, lParam);
}


void COlecnfgPropertySheet::OnDestroy()
{
    CPropertySheet::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\cnfgpsht.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cnfgpsht.h
//
//  Contents:   Defines class COlecnfgPropertySheet
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------

 
#ifndef __CNFGPSHT_H__
#define __CNFGPSHT_H__

#include "SrvPPg.h"
#include "defprot.h"

/////////////////////////////////////////////////////////////////////////////
// COlecnfgPropertySheet

class COlecnfgPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(COlecnfgPropertySheet)

// Construction
public:
    COlecnfgPropertySheet(CWnd* pParentWnd = NULL);

// Attributes
public:
    CServersPropertyPage m_Page1;
    CMachinePropertyPage m_Page2;  
    CDefaultSecurityPropertyPage m_Page3;
    CDefaultProtocols    m_Page4;


// Operations
public:

    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COlecnfgPropertySheet)
    public:
    virtual INT_PTR DoModal();
    virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
    protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

    // Implementation
public:
    virtual ~COlecnfgPropertySheet();

    // Generated message map functions
protected:
    //{{AFX_MSG(COlecnfgPropertySheet)
    afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif  // __CNFGPSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\creg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       creg.cpp
//
//  Contents:   Implements class CRegistry to wrap registry access
//
//  Classes:
//
//  Methods:    CRegistry::CRegistry
//              CRegistry::~CRegistry
//              CRegistry::Init
//              CRegistry::InitGetItem
//              CRegistry::GetNextItem
//              CRegistry::GetItem
//              CRegistry::FindItem
//              CRegistry::FindAppid
//              CRegistry::AppendIndex
//              CRegistry::GetNumItems
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------



#include "stdafx.h"
#include "resource.h"
#include "types.h"
#include "cstrings.h"
#include "creg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CRegistry::CRegistry(void)
{
    m_applications.RemoveAll();
}


CRegistry::~CRegistry(void)
{
}




// Access and store all application names and associated appid's
BOOL CRegistry::Init(void)
{
    int    err;
    HKEY   hKey;
    DWORD  dwSubKey;
    TCHAR  szTitle[MAX_PATH];
    TCHAR  szAppid[MAX_PATH];
    TCHAR  szCLSID[MAX_PATH];
    TCHAR  szBuffer[MAX_PATH];
    LONG   lSize;
    DWORD  dwType;
    DWORD  dwDisposition;

    // Cleanup any previous run
    m_applications.RemoveAll();


    // First enumerate HKEY_CLASSES_ROOT\CLSID picking up all .exe

    // Open HKEY_CLASSES_ROOT\CLSID
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_READ |  KEY_WRITE,
                     &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Enumerate the CLSID subkeys
    dwSubKey = 0;
    while (RegEnumKey(hKey, dwSubKey, szCLSID, sizeof(szCLSID) / sizeof(TCHAR))
           == ERROR_SUCCESS)
    {
        TCHAR  szPath[MAX_PATH];
        HKEY    hKey2;
        SRVTYPE srvType;

        // Prepare for next key
        dwSubKey++;

        // Open this key
        if (RegOpenKeyEx(hKey, szCLSID, 0, KEY_READ |  KEY_WRITE,
                         &hKey2) == ERROR_SUCCESS)
        {
            // Check for subkeys "LocalServer32", "_LocalServer32",
            // "LocalServer", and "_LocalServer"
            lSize = MAX_PATH * sizeof(TCHAR);
            err = RegQueryValue(hKey2, TEXT("LocalServer32"), szPath,
                                &lSize);
            srvType = LOCALSERVER32;

            if (err != ERROR_SUCCESS)
            {
                lSize = MAX_PATH * sizeof(TCHAR);
                err = RegQueryValue(hKey2, TEXT("_LocalServer32"), szPath,
                                    &lSize);
                srvType = _LOCALSERVER32;
            }

            if (err != ERROR_SUCCESS)
            {
                lSize = MAX_PATH * sizeof(TCHAR);
                err = RegQueryValue(hKey2, TEXT("LocalServer"), szPath,
                                    &lSize);
                srvType = LOCALSERVER;
            }

            if (err != ERROR_SUCCESS)
            {
                lSize = MAX_PATH * sizeof(TCHAR);
                err = RegQueryValue(hKey2, TEXT("_LocalServer"), szPath,
                                    &lSize);
                srvType = _LOCALSERVER;
            }

            if (err != ERROR_SUCCESS)
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Strip off any command line parameters -
            // it's the executale path that determines an item.  Because
            // of quotes, embedded spaces, etc. we scan for ".exe"
            int k = 0;

            // szPath is executable path
            while (szPath[k])
            {
                if (szPath[k]     == TEXT('.')      &&
                    szPath[k + 1]  &&  (szPath[k + 1] == TEXT('e')  ||
                                        szPath[k + 1] == TEXT('E'))    &&
                    szPath[k + 2]  &&  (szPath[k + 2] == TEXT('x')  ||
                                        szPath[k + 2] == TEXT('X'))    &&
                    szPath[k + 3]  &&  (szPath[k + 3] == TEXT('e')  ||
                                        szPath[k + 3] == TEXT('E')))
                {
                    break;
                }

                k++;
            }

            // Just continue if we don't have an .exe path
            if (!szPath[k])
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Increment to the nominal end of the path
            k += 4;

            // In case the entire path is surrounded by quotes
            if (szPath[k] == TEXT('"'))
            {
                k++;
            }
            szPath[k] = TEXT('\0');

            // Read the AppID for this clsid (if any)
            BOOL fUseThisClsid = FALSE;

            lSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hKey2, TEXT("AppID"), NULL, &dwType,
                                (UCHAR *) szAppid, (ULONG *) &lSize)
                != ERROR_SUCCESS)
            {
                // Use this clsid as the appid
                fUseThisClsid = TRUE;
            }

            // If this is a 16-bit server without an existing AppId
            // named value then skip it
            if ((srvType == LOCALSERVER  ||  srvType == _LOCALSERVER)  &&
                fUseThisClsid == TRUE)
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Read the title for the item
            BOOL fNoTitle = FALSE;

            lSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hKey2, NULL, NULL, &dwType,
                                (UCHAR *) szTitle, (ULONG *) &lSize)
                != ERROR_SUCCESS)
            {
                fNoTitle = TRUE;
            }
            else if (szTitle[0] == TEXT('\0'))
            {
                fNoTitle = TRUE;
            }

            // If both the item (the executable path) and the title
            // (the unnamed value on the CLSID) are empty, then skip
            // this entry
            if (szPath[0] == TEXT('\0')  &&
                (fNoTitle  ||  szTitle[0] == TEXT('\0')))
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Check whether we already have this item in the table - we
            // search differently depending on whether this clsid already
            // has an associated appid
            SItem *pItem;

            if (fUseThisClsid)
            {
                // check if application is in list
                pItem = FindItem(szPath);
            }
            else
            {
                pItem = FindAppid(szAppid);
            }

            if (pItem == NULL)
            {
                // Create a new item
                // szPath is path, szCLSID is CLSID
                pItem = m_applications.PutItem(szPath[0] ? szPath : szCLSID,
                                               fNoTitle ? szCLSID : szTitle,
                                          fUseThisClsid ? szCLSID : szAppid);
                if (pItem == NULL)
                {
                    RegCloseKey(hKey2);
                    RegCloseKey(hKey);
                    return FALSE;
                }

                // Note whether the clsid had an appid named value
                pItem->fHasAppid = !fUseThisClsid;
            }

            // Write the AppId for this class if it doesn't exist
            lSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hKey2, TEXT("AppID"), 0, &dwType,
                                (BYTE *) szBuffer, (ULONG *) &lSize)
                != ERROR_SUCCESS)
            {
                if (RegSetValueEx(hKey2, TEXT("AppID"), 0, REG_SZ,
                                  (const BYTE *) (LPCTSTR)pItem->szAppid,
                                 (pItem->szAppid.GetLength() + 1) * sizeof(TCHAR))
                    != ERROR_SUCCESS)
                {
                    RegCloseKey(hKey2);
                    RegCloseKey(hKey);
                    return FALSE;
                }
            }

            // Now add this clsid to the table of clsid's for this .exe
            if (!m_applications.AddClsid(pItem, szCLSID))
            {
                RegCloseKey(hKey2);
                RegCloseKey(hKey);
                return FALSE;
            }

            // Close the key
            RegCloseKey(hKey2);
        }
    } // End of the enumeration over HKEY_CLASSES_ROOT\CLSID

    // Close the key on HKEY_CLASSES_ROOT\CLSID
    RegCloseKey(hKey);



    // Create or open the key "HKEY_CLASSES_ROOT\AppID"
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT, TEXT("AppID"), 0, NULL,
                       REG_OPTION_NON_VOLATILE, KEY_READ |  KEY_WRITE, NULL, &hKey,
                       &dwDisposition) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Enumerate keys under HKEY_CLASSES_ROOT\AppID
    dwSubKey = 0;
    while (RegEnumKey(hKey, dwSubKey, szCLSID, sizeof(szCLSID) / sizeof(TCHAR)) == ERROR_SUCCESS)
    {
        // Prepare for next key
        dwSubKey++;

        // Only look at entries having an AppId format
        if (!(szCLSID[0] == TEXT('{')          &&
              _tcslen(szCLSID) == GUIDSTR_MAX  &&
              szCLSID[37] == TEXT('}')))
        {
            continue;
        }

        // Check if this appid is already in the table
        SItem *pItem = FindAppid(szCLSID);

        // read title
        TCHAR szTitle[MAX_PATH];
        long  lSize = MAX_PATH * sizeof(TCHAR);

        // Read its unnamed value as the title
        szTitle[0] = TEXT('\0');
        err = RegQueryValue(hKey, szCLSID, szTitle, &lSize);

        // If not create an item entry so it can be displayed in the UI
        if (pItem == NULL)
        {
            // Store this item
            pItem = m_applications.PutItem(NULL,
                                           szTitle[0] ? szTitle : szCLSID,
                                           szCLSID);
            if (pItem == NULL)
                return FALSE;
        }
        else
        {
            // ronans - bugfix for raided bug
            // change existing item title to AppID title if there is one
            if ((err == ERROR_SUCCESS) && szTitle[0])
            {
                pItem -> szTitle = (LPCTSTR)szTitle;
            }
        }

        // Mark it so we don't rewrite it to HKEY_CLASSES_ROOT\AppID
        pItem->fMarked = TRUE;
    } // End enumeration of HKEY_CLASSES_ROOT\AppID



    // Enumerate through the table of items, writing to HKEY_CLASSES_ROOT\AppID
    // any items that are not marked
    SItem *pItem;

    m_applications.InitGetNext();
    for (pItem = GetNextItem(); pItem; pItem = GetNextItem())
    {
        HKEY hKey2;

        // If this item has an AppID but is unmarked, then ask the user
        // whether he really wants to create the AppID
        if (!pItem->fMarked  &&  pItem->fHasAppid)
        {
            CString szMessage;
            CString szDCOM_;
            CString szNULL;
            TCHAR   szText[MAX_PATH*2];
            TCHAR  *szParms[3];

            szMessage.LoadString(IDS_CLSID_);
            szDCOM_.LoadString(IDS_DCOM_Configuration_Warning);
            szNULL.LoadString(IDS_NULL);

            szParms[0] = pItem->ppszClsids[0];
            szParms[1] = !pItem->szItem.IsEmpty() ? (TCHAR *) ((LPCTSTR)pItem->szItem)
                : (TCHAR *) ((LPCTSTR) szNULL);
            szParms[2] = !pItem->szTitle.IsEmpty() ? (TCHAR *) ((LPCTSTR)pItem->szTitle)
                : (TCHAR *) ((LPCTSTR) szNULL);

            FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          (TCHAR *) ((LPCTSTR) szMessage),
                          0,
                          0,
                          szText,
                          sizeof(szText)/sizeof(*szText),
                          (va_list *) szParms);

            if (MessageBox(GetForegroundWindow(),
                           szText,
                           (TCHAR *) ((LPCTSTR) szDCOM_),
                           MB_YESNO) == IDNO)
            {
                pItem->fMarked = TRUE;
                pItem->fDontDisplay = TRUE;
            }
        }

        // If this item is not marked then, then create an appid key for
        // it under HKEY_CLASSES_ROOT\AppID and, separately, write the
        // .exe name under HKEY_CLASSES_ROOT\AppID
        if (!pItem->fMarked)
        {
            if (RegCreateKeyEx(hKey, pItem->szAppid, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_READ |  KEY_WRITE, NULL, &hKey2,
                               &dwDisposition) == ERROR_SUCCESS)
            {
                // Write the item title as the unnamed value
                if (!pItem->szTitle.IsEmpty())
                {
                    RegSetValueEx(hKey2, NULL, 0, REG_SZ,(BYTE *) (LPCTSTR) pItem->szTitle,
                                  (pItem->szTitle.GetLength() + 1) * sizeof(TCHAR));
                }

                // Close it
                RegCloseKey(hKey2);


                // Write the .exe name if it's not empty
                if (!(pItem->szItem.IsEmpty()))
                {
                    // Extract the .exe name
                    int k = pItem->szItem.ReverseFind(TEXT('\\'));
                    CString szExe = pItem->szItem.Mid((k != -1) ? k+1 : 0);

                    // remove trailing quotes on executable name if necessary
                    k = szExe.GetLength();
                    if (k && (szExe.GetAt(k-1) == TEXT('\"')))
                        szExe = szExe.Left(k-1);

                    // Write the .exe name as a key
                    if (RegCreateKeyEx(hKey, (LPCTSTR)szExe, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_READ |  KEY_WRITE, NULL, &hKey2,
                               &dwDisposition) == ERROR_SUCCESS)
                    {
                    // Now write the associated AppId as a named value
                    RegSetValueEx(hKey2, TEXT("AppId"), 0, REG_SZ,
                                  (BYTE *)(LPCTSTR) pItem->szAppid,
                                  (pItem->szAppid.GetLength() + 1) * sizeof(TCHAR));

                    RegCloseKey(hKey2);
                    }
                }
            }
            else // dont continue on failure
                break;
        }
    }

    // Close the key on HKEY_CLASSES_ROOT\AppID
    RegCloseKey(hKey);


    // We display applications by their titles (e.g. "Microsoft Word 6.0")
    // which have to be unique because we're going to uniquely associate
    // an entry in the list box with the index of its associated SItem
    // structure.  So here we make sure all the titles are unique.
    DWORD  cbItems = m_applications.GetNumItems();

    // Compare all non-empty titles of the same length.  If they are
    // not unique, then append "(<index>)" to make them unique
    for (DWORD k = 0; k < cbItems; k++)
    {
        DWORD dwIndex = 1;
        SItem *pItem = m_applications.GetItem(k);

        if (!(pItem->szTitle.IsEmpty())  &&  !pItem->fChecked)
        {
            for (DWORD j = k + 1; j < cbItems; j++)
            {
                SItem *pItem2 = m_applications.GetItem(j);

                if (!pItem2->fChecked  &&
                    (pItem->szTitle == pItem2->szTitle))
                {
                    if (dwIndex == 1)
                    {
                        AppendIndex(pItem, 1);
                        dwIndex++;
                    }
                    AppendIndex(pItem2, dwIndex++);
                    pItem2->fChecked = TRUE;
                }
            }
        }
    }


    // Prepare for the UI enumerating item entries
    m_applications.InitGetNext();

    return TRUE;
}





BOOL CRegistry::InitGetItem(void)
{
    return m_applications.InitGetNext();
}




// Enumerate the next application name
SItem *CRegistry::GetNextItem(void)
{
    return m_applications.GetNextItem();
}




// Get a specific item
SItem *CRegistry::GetItem(DWORD dwItem)
{
    return m_applications.GetItem(dwItem);
}



SItem *CRegistry::FindItem(TCHAR *szPath)
{
    return m_applications.FindItem(szPath);
}



SItem *CRegistry::FindAppid(TCHAR *szAppid)
{
    return m_applications.FindAppid(szAppid);
}




void CRegistry::AppendIndex(SItem *pItem, DWORD dwIndex)
{
    CString szTmp;
    szTmp.Format(TEXT(" (%d)"),dwIndex);

    pItem->szTitle += szTmp;
}



DWORD CRegistry::GetNumItems(void)
{
    return m_applications.GetNumItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\dcomcnfg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       dcomcnfg.cpp
//
//  Contents:   Simply wraps the true top level source program olecnfg.cpp
//
//  Classes:    
//
//  Functions:  
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------

#include "stdafx.h"

#include "olecnfg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\cstrings.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cstrings.h
//
//  Contents:   Defines the class CStrings to manage a dynamically
//              expandable array of string pairs which may be enumerated
//
//  Classes:  
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


const DWORD INCREMENT_SIZE = 1024;


class SItem : public CObject
{
public:

    SItem(LPCTSTR sItem, LPCTSTR sTitle, LPCTSTR sAppid);
    ~SItem();

// data members
    CString szItem;
    CString szTitle;
    CString szAppid;
    ULONG   fMarked:1;
    ULONG   fChecked:1;
    ULONG   fHasAppid:1;
    ULONG   fDontDisplay:1;
    UINT    ulClsids;
    UINT    ulClsidTbl;
    TCHAR **ppszClsids;
};


class CStrings
{
 public:

           CStrings(void);
          ~CStrings(void);

   SItem  *PutItem(TCHAR *szString, TCHAR *szTitle, TCHAR *szAppid);
   SItem  *FindItem(TCHAR *szItem);
   SItem  *FindAppid(TCHAR *szAppid);
   BOOL    AddClsid(SItem *pItem, TCHAR *szClsid);
   DWORD   InitGetNext(void);
   SItem  *GetNextItem(void);
   SItem  *GetItem(DWORD dwItem);
   DWORD   GetNumItems(void);
   BOOL    RemoveItem(DWORD dwItem);
   BOOL    RemoveAll(void);


 private:

   CObArray arrSItems;
   int  m_nCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\defprot.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       defprot.cpp
//
//  Contents:   Implementation of Default protocols property page
//
//  Classes:    CDefaultProtocols
//
//  Methods:
//
//  History:    ??-oct-97   RonanS    Created.
//
//----------------------------------------------------------------------
#include "stdafx.h"
#include "olecnfg.h"

#include "afxtempl.h"
#include "CStrings.h"
#include "CReg.h"
#include "types.h"
#include "datapkt.h"
#include "util.h"
#include "virtreg.h"

#include "defprot.h"
#include "epprops.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDefaultProtocols property page

IMPLEMENT_DYNCREATE(CDefaultProtocols, CPropertyPage)

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::constructor
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
CDefaultProtocols::CDefaultProtocols() : CPropertyPage(CDefaultProtocols::IDD)
{
    //{{AFX_DATA_INIT(CDefaultProtocols)
    //}}AFX_DATA_INIT
    m_nSelected = -1;
    m_bChanged = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::destructor
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
CDefaultProtocols::~CDefaultProtocols()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::DoDataExchange
//
//  Synopsis:   Called to update data automatically to / from controls
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDefaultProtocols)
    DDX_Control(pDX, IDC_CMDUPDATE, m_btnProperties);
    DDX_Control(pDX, IDC_CMDREMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_CMDMOVEUP, m_btnMoveUp);
    DDX_Control(pDX, IDC_CMDMOVEDOWN, m_btnMoveDown);
    DDX_Control(pDX, IDC_CMDADD, m_btnAdd);
    DDX_Control(pDX, IDC_LSTPROTSEQ, m_lstProtocols);
    //}}AFX_DATA_MAP

    if (pDX -> m_bSaveAndValidate && m_bChanged)
    {
        // update selection
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt(m_nDefaultProtocolsIndex);
        CStringArray& rProtocols = pCdp -> Values();

        rProtocols.RemoveAll();

        // copy protocols
        int nIndex;
        for (nIndex = 0; nIndex < m_arrProtocols.GetSize(); nIndex++)
        {
            CEndpointData *pED = (CEndpointData *)m_arrProtocols.GetAt(nIndex);
            rProtocols.Add((LPCTSTR)pED -> m_szProtseq);
        }
        pCdp -> SetModified(TRUE);
    }
}


BEGIN_MESSAGE_MAP(CDefaultProtocols, CPropertyPage)
    //{{AFX_MSG_MAP(CDefaultProtocols)
    ON_BN_CLICKED(IDC_CMDADD, OnAddProtocol)
    ON_BN_CLICKED(IDC_CMDMOVEDOWN, OnMoveProtocolDown)
    ON_BN_CLICKED(IDC_CMDMOVEUP, OnMoveProtocolUp)
    ON_BN_CLICKED(IDC_CMDREMOVE, OnRemoveProtocol)
    ON_WM_KILLFOCUS()
    ON_NOTIFY(NM_CLICK, IDC_LSTPROTSEQ, OnSelectProtocol)
    ON_BN_CLICKED(IDC_CMDUPDATE, OnProperties)
    ON_NOTIFY(NM_DBLCLK, IDC_LSTPROTSEQ, OnPropertiesClick)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDefaultProtocols message handlers

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnInitDialog
//
//  Synopsis:   Called to initialize dialog before showing
//              (in response to WM_INITDIALOG)
//
//  Arguments:
//
//  Returns:    BOOL - TRUE to set focus to Dialog, FALSE if
//              focus will be set to another control or window
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CDefaultProtocols::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // setup image list control for dialog (for use with listview)
    m_imgNetwork.Create( IDB_IMGNETWORK, 16, 0, RGB(255,255,255));
    m_lstProtocols.SetImageList(&m_imgNetwork, LVSIL_SMALL);
    ASSERT(m_imgNetwork.GetImageCount() == 2);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\RPC\DCOM Protocols
    int err;

    err = g_virtreg.ReadRegMultiSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC"),
                                        TEXT("DCOM Protocols"),
                                        &m_nDefaultProtocolsIndex);
    if (err == ERROR_SUCCESS)
    {
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt(m_nDefaultProtocolsIndex);

        CStringArray& rProtocols = pCdp -> Values();

        // copy protocols
        int nIndex;
        for (nIndex = 0; nIndex < rProtocols.GetSize(); nIndex++)
        {
            CEndpointData *pED = new CEndpointData(rProtocols.GetAt(nIndex));
            m_arrProtocols.Add(pED);
        }

        // set selection to first item
        if (nIndex > 0)
            m_nSelected = 0;
        else
            m_nSelected = -1;

        RefreshProtocolList();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    SetModified(m_bChanged = FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::UpdateSelection
//
//  Synopsis:   Called to update UI after protocol selection
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::UpdateSelection()
{
    BOOL bAllowGlobalProperties = FALSE;
     // get the corresponding endpoint data object

    if (m_nSelected != (-1))
    {
        CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(m_nSelected);
        bAllowGlobalProperties = pEPD -> AllowGlobalProperties();
    }

    m_btnAdd.EnableWindow(TRUE);
    m_btnRemove.EnableWindow(m_nSelected !=  -1);
    m_btnProperties.EnableWindow(bAllowGlobalProperties);

    m_btnMoveUp.EnableWindow(m_nSelected > 0);
    m_btnMoveDown.EnableWindow((m_nSelected < m_arrProtocols.GetUpperBound()) && (m_nSelected >=0));

    // set up initial selection
    if (m_nSelected != (-1))
    {
        m_lstProtocols.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        m_lstProtocols.Update(m_nSelected);
    }

    UpdateData(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::RefreshProtocolList
//
//  Synopsis:   Called to refresh protocol list into dialog
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::RefreshProtocolList()
{
    int nIndex;

    // clear the list controls current contents
    m_lstProtocols.DeleteAllItems();

    for (nIndex = 0; (nIndex < m_arrProtocols.GetSize()); nIndex++)
        {
        CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(nIndex);

        if (pEPD )
            {
            CString sTmp;
            pEPD -> GetDescription(sTmp);

            // insert item and store pointer to its associated CEndpointData
            m_lstProtocols.InsertItem(nIndex, sTmp, 0);
            m_lstProtocols.SetItemData(0, (DWORD_PTR)pEPD);
            }
        }

    UpdateSelection();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnAddProtocol
//
//  Synopsis:   Called when user selects AddProtocol button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnAddProtocol()
{
    CAddProtocolDlg capd;

    if (capd.DoModal() == IDOK)
    {
        // create new endpoint
        CEndpointData *pNewProtocol = new CEndpointData();
        ASSERT(pNewProtocol);

        pNewProtocol = capd.GetEndpointData(pNewProtocol);
        ASSERT(pNewProtocol);

        // check if protocol is already in collection
        int nIndex;

        for (nIndex = 0; nIndex < m_arrProtocols.GetSize(); nIndex++)
            {
            CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(nIndex);
            if (pEPD -> m_pProtocol == pNewProtocol -> m_pProtocol)
                {
                delete pNewProtocol;
                pNewProtocol = NULL;
                AfxMessageBox((UINT)IDS_DUPLICATE_PROTSEQ);
                break;
                }
            }

        // only add the endpoint if its not already in collection
        if (pNewProtocol)
        {
            // reset old hilited item
            if (m_nSelected != -1)
            {
                m_lstProtocols.SetItemState(m_nSelected, 0, LVIS_SELECTED | LVIS_FOCUSED);
                m_lstProtocols.Update(m_nSelected);
            }

            // add new endpoint
            int nNewIndex = (int)m_arrProtocols.Add((CObject*)pNewProtocol);

            // set new item in list control
            CString sTmp;

            pNewProtocol -> GetDescription(sTmp);

            // insert item and store pointer to its associated CEndpointData
            m_nSelected = m_lstProtocols.InsertItem(nNewIndex, sTmp, 0);
            if (m_nSelected != -1)
            {
                m_lstProtocols.SetItemData(m_nSelected, (DWORD_PTR)pNewProtocol);
                UpdateSelection();

                // set modified flag to enable apply button
                SetModified(m_bChanged = TRUE);

                // This is a reboot event
                g_fReboot = TRUE;

                UpdateData(TRUE);
            }
        }
    }
    SetFocus();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnMoveProtocolDown
//
//  Synopsis:   Called when user clicks MoveDown button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnMoveProtocolDown()
{
    if ((m_nSelected != -1) && (m_nSelected < m_arrProtocols.GetUpperBound()))
    {
        CEndpointData * p1, *p2;
        p1 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected);
        p2 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected + 1);
        m_arrProtocols.SetAt(m_nSelected,(CObject*)p2);
        m_arrProtocols.SetAt(m_nSelected+1,(CObject*)p1);

        m_nSelected = m_nSelected+1;

        // set modified flag to enable apply button
        SetModified(m_bChanged = TRUE);
        UpdateData(TRUE);

        // This is a reboot event
        g_fReboot = TRUE;

        RefreshProtocolList();
        SetFocus();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnMoveProtocolUp
//
//  Synopsis:   Called when user clicks MoveUp button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnMoveProtocolUp()
{
    if ((m_nSelected != -1) && (m_nSelected > 0))
    {
        CEndpointData * p1, *p2;
        p1 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected);
        p2 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected - 1);
        m_arrProtocols.SetAt(m_nSelected,(CObject*)p2);
        m_arrProtocols.SetAt(m_nSelected - 1 ,(CObject*)p1);

        m_nSelected = m_nSelected - 1;

        // set modified flag to enable apply button
        SetModified(m_bChanged = TRUE);
        UpdateData(TRUE);

        // This is a reboot event
        g_fReboot = TRUE;

        RefreshProtocolList();
        SetFocus();
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnRemoveProtocol
//
//  Synopsis:   Called when user clicks Remove button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnRemoveProtocol()
{
    if (m_nSelected != -1)
    {
        CEndpointData * p1;
        p1 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected);
        m_arrProtocols.RemoveAt(m_nSelected);
        delete p1;

        if (!m_arrProtocols.GetSize())
            m_nSelected  = -1;
        else if (m_nSelected > m_arrProtocols.GetUpperBound())
            m_nSelected = (int)m_arrProtocols.GetUpperBound();

        // set modified flag to enable apply button
        SetModified(m_bChanged = TRUE);
        UpdateData(TRUE);

        // This is a reboot event
        g_fReboot = TRUE;

        RefreshProtocolList();
        SetFocus();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnKillActive
//
//  Synopsis:   Called when Default protocols is no longer active pane
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CDefaultProtocols::OnKillActive()
{
    return CPropertyPage::OnKillActive();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnSetActive
//
//  Synopsis:   Called when Default protocols becomes active pane
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CDefaultProtocols::OnSetActive()
{
    BOOL bRetval = CPropertyPage::OnSetActive();

    // force focus to be set for page
    PostMessage(WM_SETFOCUS);
    return bRetval;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnKillFocus
//
//  Synopsis:   Called when Default protocols pane loses focus
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnKillFocus(CWnd* pNewWnd)
{
    CPropertyPage::OnKillFocus(pNewWnd);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnSetFocus
//
//  Synopsis:   Called when Default protocols pane gains focus
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnSetFocus(CWnd* pOldWnd)
{
    CPropertyPage::OnSetFocus(pOldWnd);
    m_lstProtocols.SetFocus();

    if (m_nSelected != (-1))
    {
        m_lstProtocols.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        m_lstProtocols.Update(m_nSelected);
    }
    else
    {
        TRACE(TEXT("Invalid state"));
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnSelectProtocol
//
//  Synopsis:   Called when users selects protocol from list
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnSelectProtocol(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_nSelected = m_lstProtocols.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);

    UpdateSelection();
    *pResult = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnProperties
//
//  Synopsis:   Called when user clicks Properties button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnProperties()
{
    if (m_nSelected != (-1))
    {
        CPortRangesDlg cprd;
        cprd.DoModal();
        SetFocus();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnPropertiesClick
//
//  Synopsis:   Called when user double clicks protocol in list
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnPropertiesClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_nSelected = m_lstProtocols.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);


    if (m_nSelected != (-1))
    {
        CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(m_nSelected);
        BOOL bAllowGlobalProperties = pEPD -> AllowGlobalProperties();
        if (bAllowGlobalProperties)
            OnProperties();
    }

    UpdateSelection();

    *pResult = 0;
}

BOOL CDefaultProtocols::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CDefaultProtocols::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\datapkt.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       datapkt.h
//
//  Contents:   Defines the class CDataPacket to manages diverse data
//              packets needing to be written to various databases
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef _DATAPKT_H_
#define _DATAPKT_H_

typedef enum tagPACKETTYPE {
    Empty, 
    NamedValueSz, 
    NamedValueDword, 
    SingleACL,
    RegKeyACL, 
    Password, 
    ServiceIdentity, 
    NamedValueMultiSz, 
    RegistryNode
} PACKETTYPE;

typedef struct
{
    TCHAR *szValue;
} SNamedValueSz, *PNamedValueSz;

typedef struct
{
  int Dummy;
} SNamedValueMultiSz;

typedef struct
{
    DWORD  dwValue;
} SNamedValueDword, *PNamedValueDword;

typedef struct
{
    SECURITY_DESCRIPTOR *pSec;
} SSingleACL, *PSingleACL;


typedef struct
{
    HKEY                *phClsids;
    unsigned             cClsids;
    TCHAR               *szTitle;
    SECURITY_DESCRIPTOR *pSec;
    SECURITY_DESCRIPTOR *pSecOrig;
} SRegKeyACL, *PRegKeyACL;


typedef struct
{
    TCHAR *szPassword;
    CLSID  appid;
} SPassword, *PPassword;


typedef struct
{
    TCHAR *szServiceName;
    TCHAR *szIdentity;
} SServiceIdentity, *PServiceIdentity;


class CDataPacket
{
public:

    CDataPacket(void);

    CDataPacket(HKEY   hRoot,
                TCHAR *szKeyPath,
                TCHAR *szValueName,
                DWORD  dwValue);

    CDataPacket(HKEY   hRoot,
                TCHAR *szKeyPath,
                TCHAR *szValueName,
                SECURITY_DESCRIPTOR *pSec,
                BOOL   fSelfRelative);

    CDataPacket(HKEY     hKey,
                HKEY    *phClsids,
                unsigned cClsids,
                TCHAR   *szTitle,
                SECURITY_DESCRIPTOR *pSecOrig,
                SECURITY_DESCRIPTOR *pSec,
                BOOL   fSelfRelative);

    CDataPacket(TCHAR *szPassword, CLSID apid);

    CDataPacket(TCHAR *szServiceName, TCHAR *szIdentity);

    CDataPacket(PACKETTYPE pktType,
                HKEY       hRoot,
                TCHAR     *szKeyPath,
                TCHAR     *szValueName);

    CDataPacket(const CDataPacket& rDataPacket);
    virtual ~CDataPacket();


    void ChgDwordValue(DWORD dwValue);

    void ChgACL(SECURITY_DESCRIPTOR *pSec, BOOL fSelfRelative);

    void ChgPassword(TCHAR *szPassword);

    void ChgSrvIdentity(TCHAR *szIdentity);

    void MarkForDeletion(BOOL);
    void MarkHiveForDeletion(BOOL bDelete);

    void SetModified(BOOL fDirty);
    BOOL IsDeleted();
    BOOL IsModified();

    virtual int Apply();

    virtual long Read(HKEY hKey);
    virtual int Remove();
    virtual int Update();

    DWORD GetDwordValue();
    

    virtual BOOL IsIdentifiedBy(HKEY hRoot,TCHAR *, TCHAR*);

    PACKETTYPE m_tagType;
    BOOL       m_fModified;
    BOOL       m_fDelete;
    BOOL       m_fDeleteHive;
    HKEY       m_hRoot;
    CString    m_szKeyPath;
    CString    m_szValueName;

    union
    {
        SNamedValueSz    nvsz;
        SNamedValueDword nvdw;
        SSingleACL       acl;
        SRegKeyACL       racl;
        SPassword        pw;
        SServiceIdentity si;
        SNamedValueMultiSz nvmsz;
    } pkt;

private:

    void ReportOutOfMemAndTerminate();

};

inline void CDataPacket::SetModified(BOOL fDirty)
{
    m_fModified = fDirty;
}

inline BOOL CDataPacket::IsModified()
{
    return m_fModified;
}


inline BOOL CDataPacket::IsDeleted()
{
    return m_fDelete;
}

inline DWORD CDataPacket::GetDwordValue()
{
    return pkt.nvdw.dwValue;
}
                     
class CRegSzNamedValueDp : public CDataPacket
{
public:
    CRegSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName, TCHAR *szValue);
    CRegSzNamedValueDp(const CRegSzNamedValueDp&);

    virtual BOOL IsIdentifiedBy(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName);
    virtual int Update();
    virtual long Read(HKEY hkey);

    CString Value();
    void ChgSzValue(TCHAR *szValue);

private:
    CString m_szValue;
};

class CRegMultiSzNamedValueDp : public CDataPacket  
{
public:
    CRegMultiSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName);
    virtual ~CRegMultiSzNamedValueDp();

    virtual long Read(HKEY hKey);
    virtual int Update();
    virtual BOOL IsIdentifiedBy(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName);
    void Clear();

    CStringArray& Values() { return m_strValues; }
private:
    CStringArray m_strValues;
};

#endif // _DATAPKT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\datapkt.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       datapkt.cpp
//
//  Contents:   Implements the class CDataPacket to manages diverse data
//              packets needing to be written to various databases
//
//  Classes:
//
//  Methods:    CDataPacket::CDataPacket (x 7)
//              CDataPacket::~CDataPacket
//              CDataPacket::ChgSzValue
//              CDataPacket::ChgDwordValue
//              CDataPacket::ChgACL
//              CDataPacket::ChgPassword
//              CDataPacket::ChgSrvIdentity
//
//  History:    23-Apr-96   BruceMa    Created.
//              12-Dec-96   RonanS      Added copy constructor to CDataPacket
//                                      to get around bugs when copying CDataPacket.
//                                      Fixed memory leaks in destructor.
//                                      Simplified constructor code.
//              09-Jan-97   SteveBl     Modified to support IAccessControl.
//
//----------------------------------------------------------------------



#include "stdafx.h"
#include "assert.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"

static TCHAR *  TStrDup(const TCHAR  *lpszString)
{
    TCHAR * lpszTmp = NULL;
    int nStrlen = 0;

    if (lpszString )
        {
        lpszTmp = new TCHAR[_tcslen(lpszString) + 1];
        ASSERT(lpszTmp);

        _tcscpy(lpszTmp, lpszString);
        }

    return lpszTmp;
}

CDataPacket::CDataPacket(void)
{
    m_tagType = Empty;
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
    m_hRoot = 0;
    SetModified(TRUE);
}

CDataPacket::CDataPacket(HKEY   hRoot,
                         TCHAR *szKeyPath,
                         TCHAR *szValueName,
                         DWORD dwValue)
:m_szKeyPath(szKeyPath), m_szValueName(szValueName)
{
    m_tagType = NamedValueDword;
    m_hRoot = hRoot;
    pkt.nvdw.dwValue = dwValue;
    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(HKEY   hRoot,
                         TCHAR *szKeyPath,
                         TCHAR *szValueName,
                         SECURITY_DESCRIPTOR *pSec,
                         BOOL   fSelfRelative)
:m_szKeyPath(szKeyPath), m_szValueName(szValueName)
{
    int                  err;
    ULONG                cbLen;
    SECURITY_DESCRIPTOR *pSD;

    m_tagType = SingleACL;
    m_hRoot = hRoot;

    // Get the security descriptor into self relative form so we
    // can cache it

    // Force first call to fail so we can get the real size needed
    if (!fSelfRelative)
    {
        cbLen = 0;
        if (!MakeSelfRelativeSD(pSec, NULL, &cbLen))
        {
            err = GetLastError();
        }

        // Now really do it
        pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
        if (!pSD) 
        {   
            ReportOutOfMemAndTerminate();
            // will never get here
            return;
        }
        if (!MakeSelfRelativeSD(pSec, pSD, &cbLen))
        {
            err = GetLastError();
        }
        pkt.acl.pSec   = pSD;
    }
    else
    {
        // The security descriptor is aready in self relative form
        // as it was read directly from the registry.  However, we still
        // have to copy the it.
        g_util.CopySD(pSec, &pkt.acl.pSec);
    }

    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(HKEY     hKey,
                         HKEY    *phClsids,
                         unsigned cClsids,
                         TCHAR   *szTitle,
                         SECURITY_DESCRIPTOR *pSecOrig,
                         SECURITY_DESCRIPTOR *pSec,
                         BOOL   fSelfRelative)
{
    ULONG                cbLen;
    SECURITY_DESCRIPTOR *pSD;

    m_tagType = RegKeyACL;
    m_hRoot = hKey;

    pkt.racl.phClsids = phClsids;
    pkt.racl.cClsids = cClsids;
    pkt.racl.szTitle = TStrDup(szTitle);

    // Get the new security descriptor into self relative form so we
    // can cache it (if we have to)
    if (!fSelfRelative)
    {
        // Force first call to fail so we can get the real size needed
        cbLen = 0;
        MakeSelfRelativeSD(pSec, NULL, &cbLen);

        // Now really do it
        pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
        if (!pSD) 
        {   
            ReportOutOfMemAndTerminate();
            // will never get here
            return;
        }
        MakeSelfRelativeSD(pSec, pSD, &cbLen);
        pkt.racl.pSec   = pSD;
    }
    else
    {
        g_util.CopySD(pSec, &pkt.racl.pSec);
    }

    // The original security descriptor is aready in self relative form
    // as it was read directly from the registry.  (The edited SD from the
    // ACL editor is in absolute form.)  However, we still have to copy the
    // original SD.
    g_util.CopySD(pSecOrig, &pkt.racl.pSecOrig);

    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(TCHAR *szPassword,
                         CLSID appid)
{
    m_tagType = Password;
    pkt.pw.szPassword = TStrDup(szPassword);
    pkt.pw.appid      = appid;
    SetModified(TRUE);
    m_fDelete = FALSE;
    m_hRoot = 0;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(TCHAR *szServiceName,
                         TCHAR *szIdentity)
{
    m_hRoot = 0;
    m_tagType = ServiceIdentity;
    pkt.si.szServiceName = TStrDup(szServiceName);
    pkt.si.szIdentity = TStrDup(szIdentity);
    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}

CRegSzNamedValueDp::CRegSzNamedValueDp(const CRegSzNamedValueDp& rDataPacket)
: CDataPacket((const CDataPacket & ) rDataPacket)
{
    m_szValue = rDataPacket.m_szValue;
}

CDataPacket::CDataPacket( const CDataPacket & rDataPacket)
:m_szKeyPath (rDataPacket.m_szKeyPath), m_szValueName(rDataPacket.m_szValueName)
{
    m_tagType = rDataPacket.m_tagType;
    m_fModified = rDataPacket.m_fModified;
    m_fDelete = rDataPacket.m_fDelete;
    m_hRoot = rDataPacket.m_hRoot;

    switch (m_tagType)
    {
    case NamedValueSz:
        // handled by derived class
        break;
        
    case NamedValueDword:
        pkt.nvdw.dwValue = rDataPacket.pkt.nvdw.dwValue;
        break;

    case SingleACL:
        // Get the security descriptor into self relative form so we
        g_util.CopySD(rDataPacket.pkt.acl.pSec, &pkt.acl.pSec);
        break;

    case RegKeyACL:
        pkt.racl.phClsids = rDataPacket.pkt.racl.phClsids;
        pkt.racl.cClsids = rDataPacket.pkt.racl.cClsids;
        pkt.racl.szTitle = TStrDup(rDataPacket.pkt.racl.szTitle);
        g_util.CopySD(rDataPacket.pkt.racl.pSec, &pkt.racl.pSec);
        g_util.CopySD(rDataPacket.pkt.racl.pSecOrig, &pkt.racl.pSecOrig);
        break;

    case Password:
        pkt.pw.szPassword = TStrDup(rDataPacket.pkt.pw.szPassword);
        pkt.pw.appid = rDataPacket.pkt.pw.appid;
        break;

    case ServiceIdentity:
        pkt.si.szServiceName = TStrDup(rDataPacket.pkt.si.szServiceName);
        pkt.si.szIdentity = TStrDup(rDataPacket.pkt.si.szIdentity);
        break;

    case Empty:
        break;
    }
}



CDataPacket::~CDataPacket()
{

    switch (m_tagType)
    {
    case NamedValueSz:
        // handled by derived class
        break;

    case NamedValueDword:
        break;

    case SingleACL:
        if (pkt.acl.pSec)
            GlobalFree(pkt.acl.pSec);
        break;

    case RegKeyACL:
        if (pkt.racl.szTitle)
            delete pkt.racl.szTitle;
        if (pkt.racl.pSec)
            GlobalFree(pkt.racl.pSec);
        if (pkt.racl.pSecOrig)
            GlobalFree(pkt.racl.pSecOrig);
        break;

    case Password:
        if (pkt.pw.szPassword)
            delete pkt.pw.szPassword;
        break;

    case ServiceIdentity:
        if (pkt.si.szServiceName)
            delete pkt.si.szServiceName;
        if (pkt.si.szIdentity)
            delete pkt.si.szIdentity;
        break;
    }
}


void CRegSzNamedValueDp::ChgSzValue(TCHAR *szValue)
{
    assert(m_tagType == NamedValueSz);
    m_szValue = szValue;
    SetModified(TRUE);
}


void CDataPacket::ChgDwordValue(DWORD dwValue)
{
    assert(m_tagType == NamedValueDword);
    pkt.nvdw.dwValue = dwValue;
    SetModified(TRUE);
}



void CDataPacket::ChgACL(SECURITY_DESCRIPTOR *pSec, BOOL fSelfRelative)
{
    ULONG                cbLen;
    SECURITY_DESCRIPTOR *pSD;

    assert(m_tagType == SingleACL  ||  m_tagType == RegKeyACL);

    // Remove the previous security descriptor
    if (m_tagType == SingleACL)
    {
        GlobalFree(pkt.acl.pSec);
        pkt.acl.pSec = NULL;
    }
    else
    {
        GlobalFree(pkt.racl.pSec);
        pkt.racl.pSec = NULL;
    }

    // Put into self relative form (if necessary)
    if (!fSelfRelative)
    {
        cbLen = 0;
        MakeSelfRelativeSD(pSec, NULL, &cbLen);

        // Now really do it
        pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
        if (!pSD) 
        {   
            ReportOutOfMemAndTerminate();
            // will never get here
            return;
        }
        MakeSelfRelativeSD(pSec, pSD, &cbLen);

        // Store it
        if (m_tagType == SingleACL)
        {
            pkt.acl.pSec = pSD;
        }
        else
        {
            pkt.racl.pSec = pSD;
        }
    }
    else
    {
        if (m_tagType == SingleACL)
        {
            g_util.CopySD(pSec, &pkt.acl.pSec);
        }
        else
        {
            g_util.CopySD(pSec, &pkt.racl.pSec);
        }
    }
    SetModified(TRUE);
}



void CDataPacket::ChgPassword(TCHAR *szPassword)
{
    if (m_tagType != Password)
        return;
    if (pkt.pw.szPassword)
        delete pkt.pw.szPassword;
    pkt.pw.szPassword = TStrDup(szPassword);
    SetModified(TRUE);
}



void CDataPacket::ChgSrvIdentity(TCHAR *szIdentity)
{
    assert(m_tagType == ServiceIdentity);
    if (pkt.si.szIdentity)
        delete pkt.si.szIdentity;
    pkt.si.szIdentity =  TStrDup(szIdentity);
    SetModified(TRUE);
}


void CDataPacket::MarkForDeletion(BOOL bDelete)
{
    m_fDelete = bDelete;
    SetModified(TRUE);
}

void CDataPacket::MarkHiveForDeletion(BOOL bDelete)
{
    m_fDelete = bDelete;
    m_fDeleteHive = bDelete;
    SetModified(TRUE);
}

int CDataPacket::Apply()
{
    int err = ERROR_SUCCESS;

    if (m_fModified)
    {
        if (m_fDelete)
            err = Remove();
        else
            err = Update();
    }

    // Cleanup work
    if (err == ERROR_SUCCESS)
    {
        m_fModified = FALSE;
    }
    else
    {
        if (err == ERROR_ACCESS_DENIED)
        {
            g_util.CkForAccessDenied(ERROR_ACCESS_DENIED);
        }
        else
        {
            g_util.PostErrorMessage();
        }
    }

    return err;

}

int CDataPacket::Update()
{
    int err = ERROR_SUCCESS;

    ASSERT(m_fModified);
    switch (m_tagType)
    {
    case Empty:
        break;

    case NamedValueSz:
        ASSERT(FALSE); // we should never reach here
        break;

    case NamedValueDword:
        {
            err = g_util.WriteRegDwordNamedValue(m_hRoot,
                                                 (LPCTSTR)m_szKeyPath,
                                                 (LPCTSTR)m_szValueName,
                                                 pkt.nvdw.dwValue);
        }
        break;

    case SingleACL:
        {
            err = g_util.WriteRegSingleACL(m_hRoot,
                                           (LPCTSTR)m_szKeyPath,
                                           (LPCTSTR)m_szValueName,
                                           pkt.acl.pSec);
        }
        break;

    case RegKeyACL:
        err = g_util.WriteRegKeyACL(m_hRoot,
                                    pkt.racl.phClsids,
                                    pkt.racl.cClsids,
                                    pkt.racl.pSec,
                                    pkt.racl.pSecOrig);
        break;

    case Password:
        err = g_util.WriteLsaPassword(pkt.pw.appid,
                                      pkt.pw.szPassword);
        break;

    case ServiceIdentity:
        err = g_util.WriteSrvIdentity(pkt.si.szServiceName,
                                      pkt.si.szIdentity);
        break;
    }

    return err;
}


long CDataPacket::Read(HKEY hKey)
{
    return 0;
}

int CDataPacket::Remove()
{
    int err = ERROR_SUCCESS;

    if (m_fModified && m_fDelete)
    {
        switch (m_tagType)
        {
        case Empty:
            break;

        case SingleACL:
        case NamedValueDword:
        case NamedValueSz:
        case NamedValueMultiSz:
            if (m_fDeleteHive)
                g_util.DeleteRegKey(m_hRoot,(LPCTSTR)m_szKeyPath);
            else
                g_util.DeleteRegValue(m_hRoot,
                                      (LPCTSTR)m_szKeyPath,
                                      (LPCTSTR)m_szValueName);
            break;

        case RegKeyACL:
            err = g_util.WriteRegKeyACL(m_hRoot,
                                        pkt.racl.phClsids,
                                        pkt.racl.cClsids,
                                        pkt.racl.pSec,
                                        pkt.racl.pSecOrig);
            break;

        case Password:
            err = g_util.WriteLsaPassword(pkt.pw.appid,
                                          pkt.pw.szPassword);
            break;

        case ServiceIdentity:
            err = g_util.WriteSrvIdentity(pkt.si.szServiceName,
                                          pkt.si.szIdentity);
            break;
        }
    }

    return err;
}

//
//  ReportOutOfMemAndTerminate
//
//  Dcomcnfg was not coded very well to handle out-of-memory
//  errors in certain spots.   Rather than rip out and replace
//  lots of code to fix this properly, I am simply going to report
//  an error and terminate the process when this occurs.  Dcomnfg
//  as of now only ships in the reskit, not in the os.
//
void CDataPacket::ReportOutOfMemAndTerminate()
{
    CString sTitle;
    CString sMessage;

    if (sTitle.LoadString(IDS_FATALOUTOFMEMORYTITLE))
    {
        if (sMessage.LoadString(IDS_FATALOUTOFMEMORY))
        {
            MessageBoxW(NULL, sMessage, sTitle, MB_ICONWARNING | MB_OK | MB_TASKMODAL);
        }
    }

    TerminateProcess(GetCurrentProcess(), ERROR_NOT_ENOUGH_MEMORY);

    // will never get here
    return;
}


//*****************************************************************************
//
// class CRegSzNamedValueDp
//
// data packet for RegSZ named value
//
//*****************************************************************************
int CRegSzNamedValueDp::Update()
{
    int err = ERROR_SUCCESS;

    ASSERT(m_tagType == NamedValueSz);
    ASSERT(m_fModified);

    err = g_util.WriteRegSzNamedValue(m_hRoot,
                      (LPCTSTR)m_szKeyPath,
                      (LPCTSTR)m_szValueName,
                      (LPCTSTR)m_szValue,
                      m_szValue.GetLength() + 1);
    return err;
}

long CRegSzNamedValueDp::Read(HKEY hkey)
{
    return 0;
}

CString CRegSzNamedValueDp::Value()
{
    return m_szValue;
}


CRegSzNamedValueDp::CRegSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName, TCHAR *szValue)
: m_szValue(szValue)
{
    m_tagType = NamedValueSz;
    m_hRoot = hRoot;
    m_szKeyPath = szKeyPath;
    m_szValueName = szValueName;
}


BOOL CDataPacket::IsIdentifiedBy(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName)
{
    if (((m_tagType == NamedValueSz) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath) &&
         (m_szValueName == szValueName)) ||
        ((m_tagType == NamedValueDword) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath)  &&
         (m_szValueName == szValueName) ))
        return TRUE;

    return FALSE;
}

BOOL CRegSzNamedValueDp::IsIdentifiedBy(HKEY hRoot, TCHAR * szKeyPath, TCHAR * szValueName)
{
    if (((m_tagType == NamedValueSz) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath) &&
         (m_szValueName == szValueName)))
        return TRUE;

    return FALSE;
}

//////////////////////////////////////////////////////////////////////
// CRegMultiSzNamedValueDp Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegMultiSzNamedValueDp::CRegMultiSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName)
{
    m_tagType = NamedValueMultiSz;
    m_hRoot = hRoot;
    m_szKeyPath = szKeyPath;
    m_szValueName = szValueName;
}

CRegMultiSzNamedValueDp::~CRegMultiSzNamedValueDp()
{

}

BOOL CRegMultiSzNamedValueDp::IsIdentifiedBy(HKEY hRoot, TCHAR * szKeyPath, TCHAR * szValueName)
{
    if (((m_tagType == NamedValueMultiSz) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath) &&
         (m_szValueName == szValueName)))
        return TRUE;

    return FALSE;
}

int CRegMultiSzNamedValueDp::Update()
{
    int err = ERROR_SUCCESS;

    ASSERT(m_tagType == NamedValueMultiSz);
    ASSERT(m_fModified);

    // build up string to save
    // calculate size of string
    int nSize=0, nIndex = 0;

    for (nIndex = 0; nIndex < m_strValues.GetSize(); nIndex ++)
    {
        CString sTmp = m_strValues.GetAt(nIndex);
        nSize += sTmp.GetLength()+1;
    }
    nSize += 2;

    // build up string to save
    TCHAR* lpszTmp = new TCHAR[nSize];
    if (lpszTmp)
    {
        int nOffset = 0;
        for (nIndex = 0; nIndex < m_strValues.GetSize(); nIndex ++)
        {
            CString sTmp = m_strValues.GetAt(nIndex);
            _tcscpy((TCHAR*)(&lpszTmp[nOffset]), (LPCTSTR) sTmp);
            nOffset += sTmp.GetLength()+1;
        }

        // finish with two nulls
        lpszTmp[nOffset++] = TEXT('\0');
        lpszTmp[nOffset++] = TEXT('\0');
    
        err = g_util.WriteRegMultiSzNamedValue(m_hRoot,
                          (LPCTSTR)m_szKeyPath,
                          (LPCTSTR)m_szValueName,
                          lpszTmp,
                          nOffset);
        delete lpszTmp;
    }

    return err;
}

void CRegMultiSzNamedValueDp::Clear()
{
    m_strValues.RemoveAll();
}

long CRegMultiSzNamedValueDp::Read(HKEY hKey)
{
    ASSERT(hKey  != NULL);

    HKEY hkEndpoints = NULL;

    DWORD dwType = REG_MULTI_SZ;
    DWORD dwcbBuffer = 1024;
    TCHAR* pszBuffer = new TCHAR[1024];

    ASSERT(pszBuffer != NULL);

    // try to read values into default sized buffer
    LONG lErr = RegQueryValueEx(hKey, 
                        (LPCTSTR)m_szValueName, 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);

    // if buffer is not big enough, extend it and reread
    if (lErr == ERROR_MORE_DATA)
    {
        delete  pszBuffer;
        DWORD dwNewSize = (dwcbBuffer + 1 / sizeof(TCHAR));
        pszBuffer = new TCHAR[dwNewSize];
        if (pszBuffer)
            dwcbBuffer = dwNewSize;
    
        lErr = RegQueryValueEx(m_hRoot, 
                        (LPCTSTR)m_szValueName, 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);
    }

    if ((lErr == ERROR_SUCCESS) && 
        (dwcbBuffer > 0) &&
        (dwType == REG_MULTI_SZ))
    {
        // parse each string
        TCHAR * lpszRegEntry = pszBuffer;

        while(lpszRegEntry && *lpszRegEntry)
        {
            // caclulate length of entry
            CString sTmp(lpszRegEntry);
            int nLenEntry = sTmp.GetLength();
            m_strValues.Add(sTmp);

            lpszRegEntry += nLenEntry+1;
        }
    }
    else if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
        g_util.PostErrorMessage();

    delete pszBuffer;
    SetModified(FALSE);

    return lErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\epoptppg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       epoptppg.h
//
//  Contents:   Defines the classes CRpcOptionsPropertyPage,
//              which manages the RPC endpoint options per AppId.
//
//  Classes:    
//
//  Methods:    
//
//  History:    02-Dec-96   Ronans    Created.
//
//----------------------------------------------------------------------


#ifndef __EPOPTPPG_H__
#define __EPOPTPPG_H__	
class CEndpointData;

/////////////////////////////////////////////////////////////////////////////
// CRpcOptionsPropertyPage dialog

class CRpcOptionsPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRpcOptionsPropertyPage)

// Construction
public:
	CRpcOptionsPropertyPage();
	~CRpcOptionsPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();
	void UpdateSelection();
	void AddEndpoint(CEndpointData* pED);
	void RefreshEPList();
	void ClearProtocols();
	BOOL m_bCanModify;
	BOOL Validate();
	void InitData(CString AppName, HKEY hkAppID);

	CString GetProtseq();
	CString GetEndpoint();
	CString GetDynamicOptions();

	int m_nProtocolIndex; // index into protocol array

// Dialog Data
	//{{AFX_DATA(CRpcOptionsPropertyPage)
	enum { IDD = IDD_RPCOPTIONS };
	CListCtrl	m_lstProtseqs;
	CButton	m_btnUpdate;
	CButton	m_btnRemove;
	CButton	m_btnClear;
	CButton	m_btnAdd;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRpcOptionsPropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CEndpointData* m_epSysDefault;
	CImageList m_imgNetwork;
	CObList m_colProtseqs;	// collection of protseq objects
	BOOL m_bChanged;		// flag to indicate if data changed

	// Generated message map functions
	//{{AFX_MSG(CRpcOptionsPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnClearEndpoints();
	afx_msg void OnRemoveEndpoint();
	afx_msg void OnUpdateEndpoint();
	afx_msg void OnAddEndpoint();
	afx_msg void OnSelectProtseq(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnPropertiesProtseq(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	int m_nSelected;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\epoptppg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       epoptppg.cpp
//
//  Contents:   Implements the classes CRpcOptionsPropertyPage
//
//  Classes:    
//
//  Methods:    CRpcOptionsPropertyPage::CRpcOptionsPropertyPage
//              CRpcOptionsPropertyPage::~CRpcOptionsPropertyPage
//
//  History:    02-Dec-96   RonanS    Created.
//
//----------------------------------------------------------------------

#include "stdafx.h"
#include "olecnfg.h"
#include "resource.h"
#include "Epoptppg.h"
#include "Epprops.h"
#include "TChar.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CRpcOptionsPropertyPage property page

IMPLEMENT_DYNCREATE(CRpcOptionsPropertyPage, CPropertyPage)

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::CRpcOptionsPropertyPage
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CRpcOptionsPropertyPage::CRpcOptionsPropertyPage() : CPropertyPage(CRpcOptionsPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CRpcOptionsPropertyPage)
    //}}AFX_DATA_INIT

    m_bChanged = FALSE;

    // make distinguished ednpoint data description for default settings
    m_epSysDefault = new  CEndpointData;
    m_nSelected = -1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::~CRpcOptionsPropertyPage
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CRpcOptionsPropertyPage::~CRpcOptionsPropertyPage()
{
    ClearProtocols();

    // remove distinguished default settings descriptor
    if (m_epSysDefault)
        delete m_epSysDefault;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::DoDataExchange
//
//  Synopsis:   Standard method for dialog data exchange. MFC uses this to 
//              transfer data between the controls and the C++ classes memeber variables.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRpcOptionsPropertyPage)
    DDX_Control(pDX, IDC_LSTPROTSEQ, m_lstProtseqs);
    DDX_Control(pDX, IDC_CMDUPDATE, m_btnUpdate);
    DDX_Control(pDX, IDC_CMDREMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_CMDCLEAR, m_btnClear);
    DDX_Control(pDX, IDC_CMDADD, m_btnAdd);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRpcOptionsPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CRpcOptionsPropertyPage)
    ON_BN_CLICKED(IDC_CMDCLEAR, OnClearEndpoints)
    ON_BN_CLICKED(IDC_CMDREMOVE, OnRemoveEndpoint)
    ON_BN_CLICKED(IDC_CMDUPDATE, OnUpdateEndpoint)
    ON_BN_CLICKED(IDC_CMDADD, OnAddEndpoint)
    ON_NOTIFY(NM_CLICK, IDC_LSTPROTSEQ, OnSelectProtseq)
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    ON_WM_HELPINFO()
    ON_NOTIFY(NM_DBLCLK, IDC_LSTPROTSEQ, OnPropertiesProtseq)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRpcOptionsPropertyPage message handlers




//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnInitDialog
//
//  Synopsis:   This standard MFC method will be called when the dialog is to be initialised.
//              It is called when the WIN32 Window object receives a WM_INITDIALOG message.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();
    
    // setup image list control for dialog (for use with listview)
    m_imgNetwork.Create( IDB_IMGNETWORK, 16, 0, RGB(255,255,255));
    m_lstProtseqs.SetImageList(&m_imgNetwork, LVSIL_SMALL);
    ASSERT(m_imgNetwork.GetImageCount() == 2);

    RefreshEPList();
 
    return TRUE;  // return TRUE unless you set the focus to a control
}



const TCHAR szEndpointText[] = TEXT("Endpoint");
const int lenEndpoint = (sizeof(szEndpointText) / sizeof(TCHAR)) -1; 

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::InitData
//
//  Synopsis:   Method to initialise options
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::InitData(CString AppName, HKEY hkAppID)
{
    // read DCOM endpoint data from the registry    
    ASSERT(hkAppID != NULL);

    HKEY hkEndpoints = NULL;

    DWORD dwType = REG_MULTI_SZ;

    // try to allocate a buffer. 
    LONG lErr = ERROR_OUTOFMEMORY;
    DWORD dwcbBuffer = 1024 * sizeof(TCHAR);
    TCHAR* pszBuffer = new TCHAR[1024];
    ASSERT(pszBuffer != NULL);
    if (pszBuffer)
    {
        // try to read values into default sized buffer
        lErr = RegQueryValueEx(hkAppID, 
                        TEXT("Endpoints"), 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);

        // if buffer is not big enough, extend it and reread
        if (lErr == ERROR_MORE_DATA)
        {
            delete  pszBuffer;
            lErr = ERROR_OUTOFMEMORY;
            pszBuffer = new TCHAR[(dwcbBuffer/sizeof(TCHAR)) + 1];
            if (pszBuffer)
            {
                lErr = RegQueryValueEx(hkAppID, 
                        TEXT("Endpoints"), 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);    
            }
        }
    }

    if ((lErr == ERROR_SUCCESS) && 
        (dwcbBuffer > 0) &&
        (dwType == REG_MULTI_SZ))
    {
        // parse each string
        TCHAR * lpszRegEntry = pszBuffer;


        while(*lpszRegEntry)
        {
            // caclulate length of entry
            int nLenEntry = _tcslen(lpszRegEntry);

            // ok its a valid endpoint so parse it
            TCHAR* pszProtseq = NULL;
            TCHAR* pszEndpointData = NULL;
            TCHAR* pszTmpDynamic = NULL;
            CEndpointData::EndpointFlags nDynamic;

            pszProtseq = _tcstok(lpszRegEntry, TEXT(", "));

            pszTmpDynamic = _tcstok(NULL, TEXT(", "));
            nDynamic = (CEndpointData::EndpointFlags) _ttoi(pszTmpDynamic);

            pszEndpointData = _tcstok(NULL, TEXT(", "));

            // at this point we should have the protseq, endpoint and flags
            // .. so add the entry

            // ignore result as we will continue even if one fails
            AddEndpoint(new CEndpointData(pszProtseq, nDynamic, pszEndpointData));
            lpszRegEntry += nLenEntry + 1;
        }
    }
    else if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
        g_util.PostErrorMessage();

    delete pszBuffer;
    m_bChanged = FALSE;
    SetModified(FALSE);

    // select first item
    if (!m_colProtseqs.GetCount())
        // add default item
        m_colProtseqs.AddTail(m_epSysDefault);

    m_nSelected = 0;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnClearEndpoints
//
//  Synopsis:   Clears endpoint list and restores default settings
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnClearEndpoints() 
{
    // clear protocol list 
    ClearProtocols();
    m_bChanged = TRUE;

    m_colProtseqs.AddTail(m_epSysDefault);
    m_nSelected = 0;

    RefreshEPList();
    SetModified(TRUE);
    SetFocus();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnRemoveEndpoint
//
//  Synopsis:   Updates display after removal of endpoint
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnRemoveEndpoint() 
{
    if (m_nSelected != (-1))
    {
        if (m_colProtseqs.GetCount() == 1)
            OnClearEndpoints();
        else
        {
            // get the corresponding endpoint data object
            
            CEndpointData * pData = (CEndpointData*) m_lstProtseqs.GetItemData(m_nSelected);
            POSITION pos = m_colProtseqs. Find(pData, NULL);

            if (pos)
            {
                // remove item
                m_colProtseqs.RemoveAt(pos);
                if (pData != m_epSysDefault)
                    delete pData;

                // update item focus
                if (m_nSelected >= m_colProtseqs.GetCount())
                    m_nSelected = -1;

                UpdateData(FALSE);

                m_bChanged = TRUE;
                SetModified(TRUE);
                RefreshEPList();
                SetFocus();
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnUpdateEndpoint
//
//  Synopsis:   Called to process update command btn on existing endpoint
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnUpdateEndpoint() 
{
    // if there's a current selection (should always be the case)
    if (m_nSelected !=  -1)
    {
        // get the corresponding endpoint data object
        CEndpointData * pData = (CEndpointData*) m_lstProtseqs.GetItemData(m_nSelected);
        
        if (pData != m_epSysDefault)
        {
            CEndpointDetails ced;
    
            ced.SetOperation( CEndpointDetails::opUpdateProtocol);
            ced.SetEndpointData(pData);
            
            if (ced.DoModal() == IDOK)
                {
                pData = ced.GetEndpointData(pData);
                m_bChanged = TRUE;
                SetModified(TRUE);
                RefreshEPList();
                }
            SetFocus();
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnAddEndpoint
//
//  Synopsis:   Called to process add endpoint command button
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnAddEndpoint() 
{
    CEndpointDetails ced;

    ced.SetOperation( CEndpointDetails::opAddProtocol);

    if (ced.DoModal() == IDOK)
    {
        // create new endpoint
        CEndpointData *pNewEndpoint = new CEndpointData();
        ASSERT(pNewEndpoint);

        pNewEndpoint = ced.GetEndpointData(pNewEndpoint);
        ASSERT(pNewEndpoint);

        // check if protseq is already in collection
        POSITION pos = NULL;

        pos = m_colProtseqs.GetHeadPosition();
        while (pos != NULL)
            {
            CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);
            if (pEPD -> m_pProtocol == pNewEndpoint -> m_pProtocol)
                {
                delete pNewEndpoint;
                pNewEndpoint = NULL;

                AfxMessageBox((UINT)IDS_DUPLICATE_PROTSEQ);
                break;
                }
            }

        // only add the endpoint if its not already in collection
        if (pNewEndpoint)
        {
            // reset old hilited item 
            if (m_nSelected != -1)
            {
                m_lstProtseqs.SetItemState(m_nSelected, 0, LVIS_SELECTED | LVIS_FOCUSED);
                m_lstProtseqs.Update(m_nSelected);
            }

            // add new endpoint
            AddEndpoint(pNewEndpoint);

            // set new item in list 
            CString sTmp;

            if (pNewEndpoint -> m_pProtocol)
                sTmp .LoadString(pNewEndpoint -> m_pProtocol -> nResidDesc);

            // insert item and store pointer to its associated CEndpointData
            int nImageNum = (pNewEndpoint -> m_nDynamicFlags != CEndpointData::edDisableEP) ? 0 : 1;
            m_nSelected = m_lstProtseqs.InsertItem(0, sTmp, nImageNum);

            if (m_nSelected != -1)
            {
                m_lstProtseqs.SetItemData(m_nSelected, (DWORD_PTR)pNewEndpoint);
                UpdateSelection();
                m_bChanged = TRUE;
                SetModified(TRUE);
            }
        }
    }
    SetFocus();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::ClearProtocols
//
//  Synopsis:   Clears protocol list
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::ClearProtocols()
{
    // clean up endpoint data collection
    POSITION pos = NULL;

    pos = m_colProtseqs.GetHeadPosition();
    while (pos != NULL)
        {
        CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);
        if (pEPD != m_epSysDefault)
            delete pEPD;
        }

    m_colProtseqs.RemoveAll();
    m_nSelected = -1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::RefreshEPList
//
//  Synopsis:   Refreshes display from protocol list
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::RefreshEPList()
{
    POSITION pos = m_colProtseqs.GetHeadPosition();
    
    // clear the list controls current contents
    m_lstProtseqs.DeleteAllItems();

    while (pos != NULL)
        {
        CString sTmp;
        CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);

        if (pEPD -> m_pProtocol)
            sTmp .LoadString(pEPD -> m_pProtocol -> nResidDesc);

        // insert item and store pointer to its associated CEndpointData
        int nImageNum = (pEPD -> m_nDynamicFlags != CEndpointData::edDisableEP) ? 0 : 1;
        m_lstProtseqs.InsertItem(0, sTmp, nImageNum);
        m_lstProtseqs.SetItemData(0, (DWORD_PTR)pEPD);
        }

    UpdateSelection();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::AddEndpoint
//
//  Synopsis:   This method adds a new endpoint to the collection
//              of endpoints (m_colProtSeqs). If the collection justs consists of 
//              the default endpoint, it removes it first.
//
//  Arguments:  pED - The new endpoint object to add
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::AddEndpoint(CEndpointData* pED)
{
    // remove default item if present
    if ((m_colProtseqs.GetCount() == 1) &&
        (m_colProtseqs.GetHead() == m_epSysDefault))
    {
        m_colProtseqs.RemoveAll();
        if (m_lstProtseqs.GetItemCount())
            m_lstProtseqs.DeleteItem(0);
    }
    
    // add new item 
    m_colProtseqs.AddTail(pED);
    m_bChanged = TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnSelectProtseq
//
//  Synopsis:   This method is called when an element is selected from the listview 
//              containing the list of protocols and endpoints. 
//              It updates the buttons and controls to reflect the current selection
//
//  Arguments:  Standard args for ListCtrl callbacks
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnSelectProtseq(NMHDR* pNMHDR, LRESULT* pResult) 
{
    m_nSelected = m_lstProtseqs.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);

    UpdateSelection();
    *pResult = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::UpdateSelection
//
//  Synopsis:   Updates UI after protocol has been selected
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::UpdateSelection()
{
    // check to see what buttons should be enabled
    if ((m_colProtseqs.GetCount() == 1) &&
        (m_colProtseqs.GetHead() == m_epSysDefault))
        {
        m_btnClear.EnableWindow(FALSE);
        m_btnRemove.EnableWindow(FALSE);
        m_btnUpdate.EnableWindow(FALSE);
        }
    else
        {
        m_btnClear.EnableWindow(TRUE);
        if (m_nSelected ==  -1)
            {
            m_btnRemove.EnableWindow(FALSE);
            m_btnUpdate.EnableWindow(FALSE);
            }
        else
            {
             // get the corresponding endpoint data object
            CEndpointData * pData = (CEndpointData*) m_lstProtseqs.GetItemData(m_nSelected);
            m_btnRemove.EnableWindow(TRUE);
            m_btnUpdate.EnableWindow(TRUE);
            }
        }


    // set up initial selection
    if (m_nSelected != (-1))
    {
        m_lstProtseqs.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        m_lstProtseqs.Update(m_nSelected);
    }
    
    UpdateData(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnSetActive
//
//  Synopsis:   Called when page is activated
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnSetActive() 
{
    BOOL bRetval = CPropertyPage::OnSetActive();

    PostMessage(WM_SETFOCUS);
    return bRetval;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnSetFocus
//
//  Synopsis:   Called when page gets focus
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnSetFocus(CWnd* pOldWnd) 
{
    CPropertyPage::OnSetFocus(pOldWnd);
    m_lstProtseqs.SetFocus();
    
    if (m_nSelected != (-1))
    {
        m_lstProtseqs.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        m_lstProtseqs.Update(m_nSelected);
    }
    else
    {
        TRACE(TEXT("Invalid state"));
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnKillFocus
//
//  Synopsis:   Called when page loses focus
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnKillFocus(CWnd* pNewWnd) 
{
    CPropertyPage::OnKillFocus(pNewWnd);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnKillActive
//
//  Synopsis:   Called when page is deactivated
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnKillActive() 
{
    return CPropertyPage::OnKillActive();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnHelpInfo
//
//  Synopsis:   Called to display help info on items
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CRpcOptionsPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}

void CRpcOptionsPropertyPage::OnPropertiesProtseq(NMHDR* pNMHDR, LRESULT* pResult) 
{
    m_nSelected = m_lstProtseqs.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);

    OnUpdateEndpoint();
    UpdateSelection();
    
    *pResult = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::ValidateChanges
//
//  Synopsis:   To be called to validate the endpoint set before saving
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);

    // only validate if data has changed
    if (m_bChanged)
    {
        // validate endpoint entries
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::UpdateChanges(HKEY hkAppID)
{
    ASSERT(hkAppID != NULL);

    // only write the keys if there have been changes
    if (m_bChanged)
    {
        // write the DCOM endpoint data to the registry if necessary    
        LONG lErr = ERROR_SUCCESS;

        // delete old key
        lErr = RegDeleteValue(hkAppID, TEXT("Endpoints"));

        // if we successfully deleted the old value (or
        // there was no old value) then write the new values
        if ((lErr == ERROR_SUCCESS) || (lErr == ERROR_FILE_NOT_FOUND))
        {
            POSITION pos = NULL;
            int inxEP = 0;
            int nLenRegString = 0;
            TCHAR * lpszBuffer , *lpszBuffer2;

            // calculate string length
            pos = m_colProtseqs.GetHeadPosition();
            while (pos != NULL)
                {
                CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);
                ASSERT(pEPD != NULL);

                if (pEPD != m_epSysDefault)
                    {
                    // create string for saving
                    CString sKeyValue;
                    sKeyValue.Format(TEXT("%s,%d,%s"), 
                            (LPCTSTR)(pEPD -> m_szProtseq), 
                            pEPD -> m_nDynamicFlags, 
                            (LPCTSTR) pEPD -> m_szEndpoint);
                    nLenRegString += sKeyValue.GetLength() + 1;
                    }
                }

            // if the combined string length is zero, we don't need to write anything
            if (nLenRegString)
            {
                lpszBuffer2 = lpszBuffer = new TCHAR[nLenRegString+1];

                pos = m_colProtseqs.GetHeadPosition();
                while (pos != NULL)
                    {
                    CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);

                    if (pEPD != m_epSysDefault)
                        {
                        // create string for saving
                        CString sKeyValue;
                        sKeyValue.Format(TEXT("%s,%d,%s"), 
                                (LPCTSTR)(pEPD -> m_szProtseq), 
                                pEPD -> m_nDynamicFlags, 
                                (LPCTSTR) pEPD -> m_szEndpoint);
                        lstrcpy(lpszBuffer2, sKeyValue);
                        lpszBuffer2 += sKeyValue.GetLength() + 1;   // skip over trailing null
                        }
                    }
                *lpszBuffer2 = 0;

                // write out the string
                lErr = RegSetValueEx(hkAppID, 
                        (LPCTSTR)TEXT("Endpoints"), 
                        NULL, 
                        REG_MULTI_SZ, 
                        (BYTE*)(LPCTSTR)lpszBuffer, 
                        (nLenRegString + 1) * sizeof(TCHAR));

                delete lpszBuffer;
            }
        }
    else 
        g_util.PostErrorMessage();

    SetModified(FALSE);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::CancelChanges()
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\defprot.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       locppg.h
//
//  Contents:   Defines the classes CDefaultProtocols
//
//  Classes:
//
//  Methods:
//
//  History:    02-Jul-97   ronans  Created.
//
//----------------------------------------------------------------------

#ifndef __DEFPROT_H__
#define __DEFPROT_H__

/////////////////////////////////////////////////////////////////////////////
// CDefaultProtocols property page

class CDefaultProtocols : public CPropertyPage
{
    DECLARE_DYNCREATE(CDefaultProtocols)

// Construction
public:
    BOOL m_bChanged;
    void RefreshProtocolList();
    void UpdateSelection();
    CDefaultProtocols();
    ~CDefaultProtocols();

// Dialog Data
    //{{AFX_DATA(CDefaultProtocols)
    enum { IDD = IDD_PPGDEFPROT };
    CButton m_btnProperties;
    CButton m_btnRemove;
    CButton m_btnMoveUp;
    CButton m_btnMoveDown;
    CButton m_btnAdd;
    CListCtrl   m_lstProtocols;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefaultProtocols)
    public:
    virtual BOOL OnKillActive();
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    CImageList  m_imgNetwork;    // image list for use in protocols
    int         m_nDefaultProtocolsIndex;
    CObArray    m_arrProtocols;
    int         m_nSelected;


    // Generated message map functions
    //{{AFX_MSG(CDefaultProtocols)
    virtual BOOL OnInitDialog();
    afx_msg void OnAddProtocol();
    afx_msg void OnMoveProtocolDown();
    afx_msg void OnMoveProtocolUp();
    afx_msg void OnRemoveProtocol();
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnSelectProtocol(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnProperties();
    afx_msg void OnPropertiesClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\epprops.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       endpointDetails.h
//
//  Contents:   Defines the classes CEndpointDetails,
//
//  Classes:    
//
//  Methods:    
//
//  History:    03-Dec-96   Ronans    Created.
//
//----------------------------------------------------------------------


#ifndef __ENDPOINTDETAILS_H__
#define __ENDPOINTDETAILS_H__

/////////////////////////////////////////////////////////////////////////////
// ProtocolDesc structure

struct ProtocolDesc {

	enum endpFormat {
		ef_Integer255 = 1,
		ef_IpPortNum = 2, 
		ef_NamedPipe = 4, 
		ef_Integer = 8, 
		ef_DecNetObject = 16, 
		ef_Char22 = 32, 
		ef_VinesSpPort = 64,
		ef_sAppService = 128 };

	LPCTSTR pszProtseq;
	int nResidDesc;
	int	 nEndpFmt;
	int nAddrTip;
	int nEndpointTip;
	BOOL bAllowDynamic;
    BOOL m_bSupportedInCOM;
};

int FindProtocol(LPCTSTR pszProtSeq);

/////////////////////////////////////////////////////////////////////////////
// CEndpointData

class CEndpointData : public CObject
{
	DECLARE_DYNAMIC(CEndpointData)

public:
	BOOL AllowGlobalProperties();
	BOOL GetDescription(CString&);
	enum EndpointFlags { edUseStaticEP = 0, edUseInternetEP = 1, edUseIntranetEP = 2, edDisableEP = 3 };

	CEndpointData();
	CEndpointData(LPCTSTR szProtseq, EndpointFlags nDynamic = edUseStaticEP, LPCTSTR szEndpoint = NULL);

	CString m_szProtseq;
	EndpointFlags m_nDynamicFlags;
	CString m_szEndpoint;
	ProtocolDesc *m_pProtocol;

};

/////////////////////////////////////////////////////////////////////////////
// CEndpointDetails dialog

class CEndpointDetails : public CDialog
{
// Construction
public:
	void UpdateProtocolUI();
	void SetEndpointData(CEndpointData* pData);
	CEndpointData* GetEndpointData(CEndpointData *);
	CEndpointDetails(CWnd* pParent = NULL);   // standard constructor


	enum operation { opAddProtocol, opUpdateProtocol };

	void SetOperation (  operation opTask );

    enum btnOrder { rbiDisable = 0, rbiDefault,  rbiStatic, rbiIntranet, rbiInternet }; 

    // Dialog Data
	//{{AFX_DATA(CEndpointDetails)
	enum { IDD = IDD_RPCEP_DETAILS };
	CButton	m_rbDisableEP;
	CStatic	m_stProtseq;
	CStatic	m_stInstructions;
	CEdit	m_edtEndpoint;
	CButton	m_rbStaticEP;
	CComboBox	m_cbProtseq;
	CString	m_szEndpoint;
	int		m_nDynamic;
	//}}AFX_DATA

	CButton	m_rbDynamicInternet;
	CButton	m_rbDynamicIntranet;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEndpointDetails)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CEndpointData::EndpointFlags m_nDynamicFlags;
	int m_nProtocolIndex;
	operation m_opTask;
	CEndpointData *m_pCurrentEPData;

	// Generated message map functions
	//{{AFX_MSG(CEndpointDetails)
	virtual BOOL OnInitDialog();
	afx_msg void OnChooseProtocol();
	afx_msg void OnEndpointAssignment();
    afx_msg void OnEndpointAssignmentStatic();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif
/////////////////////////////////////////////////////////////////////////////
// CAddProtocolDlg dialog

const long MIN_PORT = 0;
const long MAX_PORT = 0xffff;


class CAddProtocolDlg : public CDialog
{
// Construction
public:
	CAddProtocolDlg(CWnd* pParent = NULL);   // standard constructor
	CEndpointData* GetEndpointData(CEndpointData *);

// Dialog Data
	//{{AFX_DATA(CAddProtocolDlg)
	enum { IDD = IDD_ADDPROTOCOL };
	CComboBox	m_cbProtseq;
	CStatic	m_stInstructions;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddProtocolDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddProtocolDlg)
	afx_msg void OnChooseProtocol();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	int m_nProtocolIndex;
	CEndpointData *m_pCurrentEPData;

};

class CPortRange : public CObject
{
    friend class CPortRangesDlg;
    friend class CAddPortDlg;
public:
    CPortRange(long start, long finish);
    long Start();
    long Finish();
    BOOL operator<(CPortRange& rRange);

private:
    long m_dwStart;
    long m_dwFinish;
};

inline CPortRange::CPortRange(long start, long finish)
{
    m_dwStart = start;
    m_dwFinish = finish;
}

inline long CPortRange::Start()
{
    return m_dwStart;
}

inline long CPortRange::Finish()
{
    return m_dwFinish;
}

inline BOOL CPortRange::operator<(CPortRange& rRange)
{
    return (m_dwStart < rRange.m_dwStart);
}
/////////////////////////////////////////////////////////////////////////////
// CPortRangesDlg dialog


class CPortRangesDlg : public CDialog
{
// Construction
public:
	CPortRangesDlg(CWnd* pParent = NULL);   // standard constructor
    ~CPortRangesDlg();

	void RemoveAllRanges(CObArray& rRanges);
	void RefreshRanges(CPortRange *pModifiedRange, BOOL bAdded);

    enum cprRangeAssignment { cprInternet = 0, cprIntranet = 1 };
    enum cprDefaultRange { cprDefaultInternet = 0, cprDefaultIntranet = 1 };

// Dialog Data
	//{{AFX_DATA(CPortRangesDlg)
	enum { IDD = IDD_RPC_PORT_RANGES };
	CButton	m_rbRangeInternet;
	CStatic	m_stInstructions;
	CListBox	m_lbRanges;
	CButton	m_btnRemoveAll;
	CButton	m_btnRemove;
	CButton	m_btnAdd;
	int		m_nrbDefaultAssignment;
	int		m_nrbRangeAssignment;          // 1 = intranet, 0 = internet
	//}}AFX_DATA
    CButton	m_rbRangeIntranet;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPortRangesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void CondenseRangeSet(CObArray &arrSrc);
	void SortRangeSet(CObArray &arrSrc);
	void CreateInverseRangeSet(CObArray& arrSrc, CObArray& arrDest);

	// Generated message map functions
	//{{AFX_MSG(CPortRangesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnAddPortRange();
	afx_msg void OnRemovePortRange();
	afx_msg void OnRemoveAllRanges();
	afx_msg void OnAssignRangeInternet();
	afx_msg void OnAssignRangeIntranet();
	afx_msg void OnSelChangeRanges();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        afx_msg void OnDefaultInternet();
        afx_msg void OnDefaultIntranet();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CObArray* m_pRanges;
	int m_nSelection;
    CObArray m_arrInternetRanges;
    CObArray m_arrIntranetRanges;

    int m_nInetPortsIdx;
    int m_nInetPortsAvailableIdx;
    int m_nInetDefaultPortsIdx;

    BOOL m_bChanged;

};
/////////////////////////////////////////////////////////////////////////////
// CAddPortDlg dialog

class CAddPortDlg : public CDialog
{
// Construction
public:
    CPortRange* GetPortRange();
	BOOL Validate();
	CAddPortDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddPortDlg)
	enum { IDD = IDD_ADD_PORT_RANGE };
	CEdit	m_edtPortRange;
	CButton	m_btnOk;
	CStatic	m_stInstructions;
	CString	m_sRange;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddPortDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddPortDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnChangePortrange();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	long m_dwEndPort;
	long m_dwStartPort;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\inetppg.cpp ===
// InternetPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "olecnfg.h"
#include "inetppg.h"
#include "util.h"
#include <tchar.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInternetPropertyPage property page

IMPLEMENT_DYNCREATE(CInternetPropertyPage, CPropertyPage)

CInternetPropertyPage::CInternetPropertyPage() : CPropertyPage(CInternetPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CInternetPropertyPage)
    m_bAllowAccess = FALSE;
    m_bAllowInternet = FALSE;
    m_bAllowLaunch = FALSE;
    //}}AFX_DATA_INIT

    m_bAllowInternet = m_bAllowLaunch = m_bAllowAccess = FALSE;
    m_bCanModify = TRUE;
}

CInternetPropertyPage::~CInternetPropertyPage()
{
}


void PASCAL DDX_Enable(CDataExchange* pDX, int nIDC, BOOL bEnable)
{
    HWND hWndCtrl = pDX->PrepareCtrl(nIDC);

    :: EnableWindow(hWndCtrl,bEnable);
}


void CInternetPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CInternetPropertyPage)
    DDX_Control(pDX, IDC_ALLOWLAUNCH, m_chkLaunch);
    DDX_Control(pDX, IDC_ALLOWINTERNET, m_chkInternet);
    DDX_Control(pDX, IDC_ALLOWACCESS, m_chkAccess);
    DDX_Check(pDX, IDC_ALLOWACCESS, m_bAllowAccess);
    DDX_Check(pDX, IDC_ALLOWINTERNET, m_bAllowInternet);
    DDX_Check(pDX, IDC_ALLOWLAUNCH, m_bAllowLaunch);
    //}}AFX_DATA_MAP

    DDX_Enable(pDX, IDC_ALLOWLAUNCH, m_bAllowInternet);
    DDX_Enable(pDX, IDC_ALLOWACCESS, m_bAllowInternet);

}


BEGIN_MESSAGE_MAP(CInternetPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CInternetPropertyPage)
    ON_BN_CLICKED(IDC_ALLOWINTERNET, OnAllowInternet)
    ON_BN_CLICKED(IDC_ALLOWACCESS, OnAllowaccess)
    ON_BN_CLICKED(IDC_ALLOWLAUNCH, OnAllowlaunch)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInternetPropertyPage message handlers

//+-------------------------------------------------------------------------
//
//  Member:     CInternetPropertyPage::InitData
//
//  Synopsis:   Method to initialise options
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CInternetPropertyPage::InitData(CString AppName, HKEY hkAppID)
{
    // read internet permissions data from the registry 
    ASSERT(hkAppID != NULL);

    TCHAR szInternetPermission[128];
    DWORD dwBufferSize = 128 * sizeof(TCHAR);
    DWORD dwType = REG_SZ;

    LONG lErr = RegQueryValueEx(hkAppID, 
                                TEXT("DcomHttpPermission"), 
                                0,
                                &dwType,
                                (LPBYTE)szInternetPermission,
                                &dwBufferSize);

    if (lErr == ERROR_SUCCESS)
    {
        if (dwBufferSize != 0)
        {
            TCHAR *pszToken = _tcstok(szInternetPermission, TEXT(" "));
            
            // parse retrieved value
            while (pszToken != NULL)
            {
                if (_tcsicmp(pszToken, TEXT("LAUNCH")) == 0)
                {
                    m_bAllowLaunch = TRUE;
                    m_bAllowInternet = TRUE;
                }
                else if (_tcsicmp(pszToken, TEXT("ACCESS")) == 0)
                {
                    m_bAllowAccess = TRUE;
                    m_bAllowInternet = TRUE;
                }
                else if (_tcsicmp(pszToken, TEXT("NONE")) == 0)
                {
                    m_bAllowAccess = FALSE;
                    m_bAllowInternet = FALSE;
                    m_bAllowInternet = FALSE;
                }

                pszToken = _tcstok(NULL, TEXT(" "));
            }
        }
    }
    else
        // nt 4.0 returns ERROR_FILE_NOT_FOUND if no value is found 
        if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
            {
            m_bCanModify = FALSE;
            g_util.PostErrorMessage();
            }

    SetModified(FALSE);
    m_bChanged = FALSE;
}


void CInternetPropertyPage::OnAllowInternet() 
{
    m_bChanged = TRUE;
    UpdateData(TRUE);
    SetModified(TRUE);
}

void CInternetPropertyPage::OnAllowaccess() 
{
    m_bChanged = TRUE;
    UpdateData(TRUE);
    SetModified(TRUE);
 }

void CInternetPropertyPage::OnAllowlaunch() 
{
    m_bChanged = TRUE;
    UpdateData(TRUE);
    SetModified(TRUE);
}

BOOL CInternetPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    /*
    if(-1 != pHelpInfo->iCtrlId)
    {
            WORD hiWord = 0x8000 | CGeneralPropertyPage::IDD;
            WORD loWord = pHelpInfo->iCtrlId;
            DWORD dwLong = MAKELONG(loWord,hiWord);

            WinHelp(dwLong, HELP_CONTEXTPOPUP);
            return TRUE;
    }

    else
    */
    {
            return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\epprops.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       epprops.cpp
//
//  Contents:   Implements the classes CEndpointDetails which manage the
//              Endpoint properties dialog.
//
//  Classes:
//
//  Methods:
//
//  History:    03-Dec-96   RonanS    Created.
//
//----------------------------------------------------------------------

#include "stdafx.h"
#include "olecnfg.h"
#include "Epoptppg.h"
#include "Epprops.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEndpointData
//
// The CEndpointData object is used to hold information about a users choices for
// a specific protocol and endpoint combination.
// Each endpoint will also contain an user readable description to be displayed in
// protocol lists and user displays

IMPLEMENT_DYNAMIC(CEndpointData, CObject)


// change this to point to index of ncacn_ip_tcp or other default protocol
#define TCP_INDEX 4

ProtocolDesc aProtocols [] =
{
    { _T("*"),          // default system protocols
        IDS_EPDESC_DEFAULT,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE,
        TRUE
    },

    { _T("ncacn_nb_tcp"),
        IDS_EPDESC_NCACN_NB_TCP,
        ProtocolDesc::ef_Integer255,
        IDS_NTMACHINENAME,
        IDS_INTEGER255,
        FALSE,
        FALSE
    },

    { _T("ncacn_nb_ipx"),
        IDS_EPDESC_NCACN_NB_IPX,
        ProtocolDesc::ef_Integer255,
        IDS_NTMACHINENAME,
        IDS_INTEGER255 ,
        FALSE,
        TRUE
    },

    { _T("ncacn_nb_nb"),
        IDS_EPDESC_NCACN_NB_NB,
        ProtocolDesc::ef_Integer255,
        IDS_NTMACHINENAME,
        IDS_INTEGER255 ,
        FALSE,
        TRUE
    },

    { _T("ncacn_ip_tcp"),
        IDS_EPDESC_NCACN_IP_TCP,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE,
        TRUE
    },

    { _T("ncacn_np"),
        IDS_EPDESC_NCACN_NP,
        ProtocolDesc::ef_NamedPipe,
        IDS_NTSERVER,
        IDS_NAMEDPIPE ,
        FALSE,
        FALSE
    },

    { _T("ncacn_spx"),
        IDS_EPDESC_NCACN_SPX,
        ProtocolDesc::ef_Integer,
        IDS_IPXINETADDR,
        IDS_INTEGER ,
        FALSE,
        TRUE
    },

    { _T("ncacn_dnet_nsp"),
        IDS_EPDESC_NCACN_DNET_NSP,
        ProtocolDesc::ef_DecNetObject,
        IDS_DECNET,
        IDS_DECNETOBJECT ,
        FALSE,
        FALSE
    },

    { _T("ncacn_at_dsp"),
        IDS_EPDESC_NCACN_AT_DSP,
        ProtocolDesc::ef_Char22,
        IDS_APPLETALK,
        IDS_ATSTRING ,
        FALSE,
        FALSE
    },

    { _T("ncacn_vnns_spp"),
        IDS_EPDESC_NCACN_VNNS_SPP,
        ProtocolDesc::ef_VinesSpPort,
        IDS_VINES,
        IDS_VINESPORT ,
        FALSE,
        FALSE
    },

    { _T("ncadg_ip_udp"),
        IDS_EPDESC_NCADG_IP_UDP,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE,
        TRUE
    },

    { _T("ncadg_ipx"),
        IDS_EPDESC_NCADG_IPX,
        ProtocolDesc::ef_Integer,
        IDS_IPXINETADDR,
        IDS_INTEGER ,
        FALSE,
        TRUE
    },

    { _T("ncacn_http"),
        IDS_EPDESC_NCACN_HTTP,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE ,
        TRUE
        },
};


//+-------------------------------------------------------------------------
//
//  Member:     CEndpointData::CEndpointData
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData::CEndpointData(LPCTSTR szProtseq, EndpointFlags nDynamic, LPCTSTR szEndpoint)
: m_szProtseq(szProtseq), m_nDynamicFlags(nDynamic), m_szEndpoint(szEndpoint)
{
    int i = FindProtocol(szProtseq);
    if (i != (-1))
        m_pProtocol = (&aProtocols[i]);
    else
        m_pProtocol = NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointData::CEndpointData
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData::CEndpointData()
{
    m_szProtseq = aProtocols[0].pszProtseq;
    m_nDynamicFlags = edUseStaticEP;
    m_pProtocol = &aProtocols[0];
}

BOOL CEndpointData::GetDescription(CString &rsDesc)
{

    if (m_pProtocol)
    {
        rsDesc .LoadString(m_pProtocol -> nResidDesc);
        return TRUE;
    }

    return FALSE;
}

BOOL CEndpointData::AllowGlobalProperties()
{
    if (m_pProtocol)
    {
        return m_pProtocol -> bAllowDynamic;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CEndpointDetails dialog
//
// The CEndpointDetails dialog is used for adding or modifying an existing endpoint
//


//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::CEndpointDetails
//
//  Synopsis:   Constructor
//
//  Arguments:
//              CWnd*   pParent     The parent window
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointDetails::CEndpointDetails(CWnd* pParent /*=NULL*/)
    : CDialog(CEndpointDetails::IDD, pParent)
{
    //{{AFX_DATA_INIT(CEndpointDetails)
    m_szEndpoint = _T("");
    m_nDynamic = -1;
    //}}AFX_DATA_INIT

    m_nProtocolIndex = -1;
    m_opTask = opAddProtocol;
    m_pCurrentEPData = NULL;
    m_nDynamic = (int) rbiDefault;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::SetOperation
//
//  Synopsis:   Sets the operation to one of update or add new data
//              This method determines whether the dialog is being
//              used to select a new end point or modify an existing one
//
//  Arguments:
//              opTask  The operation to select
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::SetOperation (  operation opTask )
{
    m_opTask = opTask;
}

BOOL isNumericCStr(CString &rString)
{
    int i = 0;

    for (i = 0; i < rString.GetLength(); i++)
    {
        if ((rString[i] < TEXT('0')) || (rString[i] > TEXT('9')))
            return FALSE;
    }

    return TRUE;
}

void ReportEndpointError(CDataExchange *pDX, int nProtocol)
{
    if (nProtocol != -1)
    {
        CString sTmpTemplate, sTmpSpecific, sTmpOverall;
        sTmpTemplate.LoadString(IDS_ERR_ENDPOINT);

        sTmpSpecific.LoadString(aProtocols[nProtocol].nEndpointTip);

        sTmpOverall.Format(sTmpTemplate, (LPCTSTR)sTmpSpecific);
        AfxMessageBox(sTmpOverall, MB_OK | MB_ICONEXCLAMATION);
        pDX -> Fail();
    }
}

void PASCAL DDV_ValidateEndpoint(CDataExchange* pDX, int nProtocol, CEndpointDetails::btnOrder bo, CString & rszEndpoint)
{
    if (pDX -> m_bSaveAndValidate)
    {
        rszEndpoint.TrimLeft();
        rszEndpoint.TrimRight();

        // a non empty endpoint is only acceptable when choosing a static endpoint
        if (!rszEndpoint.IsEmpty())
        {
            if (bo == CEndpointDetails::rbiStatic)
            {
                if (nProtocol!= -1)
                {
                    switch (aProtocols[nProtocol].nEndpFmt)
                    {
                    case ProtocolDesc::ef_Integer255:
                        if (!isNumericCStr(rszEndpoint))
                            ReportEndpointError(pDX, nProtocol);

                        if (_ttol((LPCTSTR)rszEndpoint) > 255)
                            ReportEndpointError(pDX, nProtocol);
                        break;

                    case ProtocolDesc::ef_IpPortNum:
                        if (!isNumericCStr(rszEndpoint))
                            ReportEndpointError(pDX, nProtocol);
                        if (_ttol((LPCTSTR)rszEndpoint) > 65535)
                            ReportEndpointError(pDX, nProtocol);
                        break;


                    case ProtocolDesc::ef_Integer:
                        if (!isNumericCStr(rszEndpoint))
                            ReportEndpointError(pDX, nProtocol);
                        break;


                    case ProtocolDesc::ef_Char22:
                        if (rszEndpoint.GetLength() > 22)
                            ReportEndpointError(pDX, nProtocol);
                        break;

                    case ProtocolDesc::ef_VinesSpPort:
                    case ProtocolDesc::ef_sAppService:
                    case ProtocolDesc::ef_NamedPipe:
                    case ProtocolDesc::ef_DecNetObject:
                    default:
                        // no validation
                        break;
                    }
                }
                return;
            }
        else 
            ReportEndpointError(pDX, nProtocol);
        }
        else
        {
             if (bo == CEndpointDetails::rbiStatic)
                ReportEndpointError(pDX, nProtocol);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::DoDataExchange
//
//  Synopsis:   Performs standard dialog data exchange
//
//  Arguments:
//				CDataExchange*	pDx	The data exchange object
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::DoDataExchange(CDataExchange* pDX)
{
    if (!pDX -> m_bSaveAndValidate)
    {
        switch(m_nDynamicFlags)
        {
        case CEndpointData::edDisableEP:
            m_nDynamic = rbiDisable;
            break;

        case CEndpointData::edUseStaticEP:
            if (m_szEndpoint.IsEmpty())
                m_nDynamic = rbiDefault;
            else
                m_nDynamic = rbiStatic;
            break;

        case CEndpointData::edUseIntranetEP:
            m_nDynamic = rbiIntranet;
            break;

        case CEndpointData::edUseInternetEP:
            m_nDynamic = rbiInternet;
            break;
        }

    }

    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEndpointDetails)
    DDX_Control(pDX, IDC_EPDISABLE, m_rbDisableEP);
    DDX_Control(pDX, IDC_SPROTSEQ, m_stProtseq);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    DDX_Control(pDX, IDC_EENDPOINT, m_edtEndpoint);
    DDX_Control(pDX, IDC_EPSTATICEP, m_rbStaticEP);
    DDX_Control(pDX, IDC_CBPROTSEQ, m_cbProtseq);
    DDX_Radio(pDX, IDC_EPDISABLE, m_nDynamic);
    //}}AFX_DATA_MAP


    DDX_Text(pDX, IDC_EENDPOINT, m_szEndpoint);
    if(((btnOrder)m_nDynamic) == rbiStatic)
        DDV_ValidateEndpoint(pDX, m_nProtocolIndex, (btnOrder)m_nDynamic, m_szEndpoint);

    DDX_Control(pDX, IDC_EPDYNAMIC_INTER, m_rbDynamicInternet);
    DDX_Control(pDX, IDC_EPDYNAMIC_INTRA, m_rbDynamicIntranet);

    if (pDX -> m_bSaveAndValidate)
        switch((btnOrder)m_nDynamic)
        {
        case rbiDisable:
            m_nDynamicFlags = CEndpointData::edDisableEP;
            break;

        case rbiDefault:
        case rbiStatic:
            m_nDynamicFlags = CEndpointData::edUseStaticEP;
            break;

        case rbiIntranet:
            m_nDynamicFlags = CEndpointData::edUseIntranetEP;
            break;

        case rbiInternet:
            m_nDynamicFlags = CEndpointData::edUseInternetEP;
            break;
        }
}


BEGIN_MESSAGE_MAP(CEndpointDetails, CDialog)
    //{{AFX_MSG_MAP(CEndpointDetails)
    ON_CBN_SELCHANGE(IDC_CBPROTSEQ, OnChooseProtocol)
    ON_BN_CLICKED(IDC_EPDYNAMIC_INTER, OnEndpointAssignment)
    ON_BN_CLICKED(IDC_EPDYNAMIC_INTRA, OnEndpointAssignment)
    ON_BN_CLICKED(IDC_EPSTATICEP, OnEndpointAssignmentStatic)
    ON_BN_CLICKED(IDC_EPDISABLE, OnEndpointAssignment)
    ON_BN_CLICKED(IDC_EPDYNAMIC_DEFAULT, OnEndpointAssignment)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEndpointDetails message handlers


int FindProtocol(LPCTSTR lpszProtSeq)
{
    int i = 0;

    while(i < sizeof(aProtocols) / sizeof(ProtocolDesc))
        {
        if (lstrcmp(lpszProtSeq, aProtocols[i].pszProtseq) == 0)
            return i;
        i++;
        }
    return -1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::OnInitDialog
//
//  Synopsis:   Called by MFC when the dialog message WM_INITDIALOG is recieved.
//				Used to initialise the dialog state
//
//  Arguments:  None
//
//  Returns:    TRUE  - to set focus to the default push button
//              FALSE - if focus has been set to some other control.
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CEndpointDetails::OnInitDialog()
{
    CDialog::OnInitDialog();

    int i = 0;
    int index = 0;
    int defaultItem = -1;

    // initialise combobox with list of protocols
    for (i = 1; i < sizeof(aProtocols) / sizeof(ProtocolDesc); i++)
    {
        if (aProtocols[i].m_bSupportedInCOM)
        {
            CString tmp((LPCTSTR) UIntToPtr( aProtocols[i].nResidDesc ));    // get string from resource
            index =  m_cbProtseq.AddString(tmp);
            if (index >= 0)
                m_cbProtseq.SetItemData(index, (DWORD)i);

            if (m_nProtocolIndex != -1)
            {
                if (i == m_nProtocolIndex)
                    defaultItem = index;
            }
            else if (i == TCP_INDEX)
            {
                m_nProtocolIndex = i;
                defaultItem = index;
            }
        }
    }


    // set up prompt and instructions for dialog
    if (m_opTask == opAddProtocol)
    {
        CString sInstructions((LPCTSTR)IDS_INSTRUCTIONS_ADDPROTOCOL) ;
        CString sCaption((LPCTSTR) IDS_CAPTION_ADDPROTOCOL);
        m_stInstructions.SetWindowText(sInstructions);
        SetWindowText(sCaption);
        m_stProtseq.ShowWindow(SW_HIDE);
    }
    else
    {
        CString sInstructions((LPCTSTR)IDS_INSTRUCTIONS_UPDATEPROTOCOL) ;
        CString sCaption((LPCTSTR) IDS_CAPTION_UPDATEPROTOCOL);
        m_stInstructions.SetWindowText(sInstructions);
        SetWindowText(sCaption);
        m_cbProtseq.ShowWindow(SW_HIDE);
        m_cbProtseq.EnableWindow(FALSE);
    }

    //  default to tcpip - unless we are updating an existing
    // protocol
    if (m_nProtocolIndex != (-1))
        m_cbProtseq.SetCurSel(defaultItem);

    UpdateProtocolUI();
    m_edtEndpoint.EnableWindow(((btnOrder)m_nDynamic) == rbiStatic);

    return TRUE;  // return TRUE unless you set the focus to a control

}

//+-------------------------------------------------------------------------
//
//  Member:     OnChooseProtocol
//
//  Synopsis:   Updates UI after protocol has been chosen
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::OnChooseProtocol()
{
    int sel = m_cbProtseq.GetCurSel();
    if (sel >= 0)
    {
        m_nProtocolIndex = (int) m_cbProtseq.GetItemData(sel);
        m_nDynamic = (int) rbiDefault;
        m_szEndpoint.Empty();
        UpdateProtocolUI();
        UpdateData(FALSE);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     OnEndpointAssignment
//
//  Synopsis:   Handles radio buttons for endpoint assignment
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::OnEndpointAssignment()
{
    int i = m_nDynamic;

    if (m_edtEndpoint.IsWindowEnabled())
    {
        m_szEndpoint.Empty();
        m_edtEndpoint.SetWindowText(NULL);
        m_edtEndpoint.EnableWindow(FALSE);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     OnEndpointAssignmentStatic
//
//  Synopsis:   Handles radio buttons for endpoint assignment
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::OnEndpointAssignmentStatic()
{
    int i = m_nDynamic;

    if (!m_edtEndpoint.IsWindowEnabled())
    {
        m_szEndpoint.Empty();
        m_edtEndpoint.SetWindowText(NULL);
        m_edtEndpoint.EnableWindow(TRUE);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     GetEndpointData
//
//  Synopsis:   Fills out CEndpointData structure according to current selections
//
//  Arguments:  CEndpointData *     Pointer to CEndpointData structure to fill out
//
//  Returns:    CEndpointData *     Pointer to filled out CEndpointData *
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData* CEndpointDetails::GetEndpointData(CEndpointData *pData)
{
    if (m_nProtocolIndex != -1)
        pData -> m_pProtocol = &aProtocols[m_nProtocolIndex];
    else
        pData -> m_pProtocol = NULL;

    pData -> m_szProtseq = aProtocols[m_nProtocolIndex].pszProtseq;
    pData -> m_nDynamicFlags = m_nDynamicFlags;
    pData -> m_szEndpoint = m_szEndpoint;
    return pData;
}

//+-------------------------------------------------------------------------
//
//  Member:     SetEndpointData
//
//  Synopsis:   Sets endpoint data for updating
//
//  Arguments:  pData   The endpoint to update
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::SetEndpointData(CEndpointData* pData)
{
    ASSERT(pData != NULL);

    m_pCurrentEPData = pData;

    if (pData)
    {
        m_nDynamicFlags = pData -> m_nDynamicFlags;
        m_nDynamic = (int)(pData -> m_nDynamicFlags);
        m_szEndpoint = pData -> m_szEndpoint;
        m_nProtocolIndex = FindProtocol(pData -> m_szProtseq);
    }
    else
    {
        m_nDynamicFlags = CEndpointData::edUseStaticEP;
        m_szEndpoint .Empty();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::UpdateProtocolUI
//
//  Synopsis:   Updates protocol UI based on m_nProtocolIndex and  m_pCurrentData
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    08-Jan-97 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::UpdateProtocolUI()
{
    ASSERT(m_nProtocolIndex >= 0);
    ASSERT(m_nProtocolIndex < (sizeof(aProtocols) / sizeof(ProtocolDesc)));

    // set static to point to protocol description string
    CString tmp((LPCTSTR) UIntToPtr( aProtocols[m_nProtocolIndex].nResidDesc )); // get string from resource
    m_stProtseq.SetWindowText(tmp);

    // check if dynamic endpoint options are enabled for this
    m_rbDynamicInternet.EnableWindow(aProtocols[m_nProtocolIndex].bAllowDynamic);
    m_rbDynamicIntranet.EnableWindow(aProtocols[m_nProtocolIndex].bAllowDynamic);
}


/////////////////////////////////////////////////////////////////////////////
// CAddProtocolDlg dialog


CAddProtocolDlg::CAddProtocolDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CAddProtocolDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddProtocolDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_nProtocolIndex = -1;
    m_pCurrentEPData = NULL;
}


void CAddProtocolDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddProtocolDlg)
    DDX_Control(pDX, IDC_CBPROTSEQ, m_cbProtseq);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddProtocolDlg, CDialog)
    //{{AFX_MSG_MAP(CAddProtocolDlg)
    ON_CBN_SELCHANGE(IDC_CBPROTSEQ, OnChooseProtocol)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddProtocolDlg message handlers

void CAddProtocolDlg::OnChooseProtocol()
{
    int sel = m_cbProtseq.GetCurSel();
    if (sel >= 0)
        m_nProtocolIndex = (int) m_cbProtseq.GetItemData(sel);
}

BOOL CAddProtocolDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    int i = 0;
    int index = 0;

    // initialise combobox with list of protocols
    for (i = 1; i < sizeof(aProtocols) / sizeof(ProtocolDesc); i++)
    {
        if (aProtocols[i].m_bSupportedInCOM)
        {
            CString tmp((LPCTSTR) UIntToPtr( aProtocols[i].nResidDesc ));    // get string from resource
            index =  m_cbProtseq.AddString(tmp);
            if (index >= 0)
                m_cbProtseq.SetItemData(index, (DWORD)i);
        }
    }


    CString sInstructions((LPCTSTR)IDS_INSTRUCTIONS_ADDPROTOCOL) ;
    CString sCaption((LPCTSTR) IDS_CAPTION_ADDPROTOCOL);

    m_stInstructions.SetWindowText(sInstructions);
    SetWindowText(sCaption);

    //  default to tcpip - unless we are updating an existing
    // protocol
    if (m_nProtocolIndex == (-1))
    {
        m_nProtocolIndex = (int)m_cbProtseq.GetItemData(TCP_INDEX - 1);
        m_cbProtseq.SetCurSel(TCP_INDEX - 1);
    }
    else
        m_cbProtseq.SetCurSel(m_nProtocolIndex - 1);


    return TRUE;  // return TRUE unless you set the focus to a control
}

//+-------------------------------------------------------------------------
//
//  Member:     GetEndpointData
//
//  Synopsis:   Fills out CEndpointData structure according to current selections
//
//  Arguments:  CEndpointData *     Pointer to CEndpointData structure to fill out
//
//  Returns:    CEndpointData *     Pointer to filled out CEndpointData *
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData* CAddProtocolDlg::GetEndpointData(CEndpointData *pData)
{
    if (m_nProtocolIndex != -1)
        pData -> m_pProtocol = &aProtocols[m_nProtocolIndex];
    else
        pData -> m_pProtocol = NULL;

    pData -> m_szProtseq = aProtocols[m_nProtocolIndex].pszProtseq;
    pData -> m_szEndpoint.Empty();
    return pData;
}
/////////////////////////////////////////////////////////////////////////////
// CPortRangesDlg dialog


CPortRangesDlg::CPortRangesDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CPortRangesDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPortRangesDlg)
    m_nrbDefaultAssignment = -1;
    m_nrbRangeAssignment = -1;
    //}}AFX_DATA_INIT

    m_nSelection = -1;
    m_nrbDefaultAssignment = (int)cprDefaultIntranet;
    m_nrbRangeAssignment = (int)cprIntranet;
    m_pRanges = &m_arrInternetRanges;
    m_bChanged = FALSE;
}


void CPortRangesDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPortRangesDlg)
    DDX_Control(pDX, IDC_ASSIGN_RANGE_INTERNET, m_rbRangeInternet);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    DDX_Control(pDX, IDC_LIST1, m_lbRanges);
    DDX_Control(pDX, IDC_BTNREMOVEALL, m_btnRemoveAll);
    DDX_Control(pDX, IDC_BTNREMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_BTNADD, m_btnAdd);
    DDX_Radio(pDX, IDC_DEFAULT_INTERNET, m_nrbDefaultAssignment);       // 1 = intranet, 0 = internet
    DDX_Radio(pDX, IDC_ASSIGN_RANGE_INTERNET, m_nrbRangeAssignment);    // 1 = intranet, 0 = internet
    //}}AFX_DATA_MAP
    DDX_Control(pDX, IDC_ASSIGN_RANGE_INTRANET, m_rbRangeIntranet);
}

CPortRangesDlg::~CPortRangesDlg()
{
    int nIndex;

    for (nIndex = 0; nIndex < m_arrInternetRanges.GetSize(); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) m_arrInternetRanges.GetAt(nIndex);
        delete pRange;
    }

    m_arrInternetRanges.RemoveAll();

    for (nIndex = 0; nIndex < m_arrIntranetRanges.GetSize(); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) m_arrIntranetRanges.GetAt(nIndex);
        delete pRange;
    }

    m_arrIntranetRanges.RemoveAll();

}

BEGIN_MESSAGE_MAP(CPortRangesDlg, CDialog)
    //{{AFX_MSG_MAP(CPortRangesDlg)
    ON_BN_CLICKED(IDC_BTNADD, OnAddPortRange)
    ON_BN_CLICKED(IDC_BTNREMOVE, OnRemovePortRange)
    ON_BN_CLICKED(IDC_BTNREMOVEALL, OnRemoveAllRanges)
    ON_BN_CLICKED(IDC_ASSIGN_RANGE_INTERNET, OnAssignRangeInternet)
    ON_BN_CLICKED(IDC_ASSIGN_RANGE_INTRANET, OnAssignRangeIntranet)
    ON_LBN_SELCHANGE(IDC_LIST1, OnSelChangeRanges)
    ON_WM_HELPINFO()
    ON_BN_CLICKED(IDC_DEFAULT_INTERNET, OnDefaultInternet)
    ON_BN_CLICKED(IDC_DEFAULT_INTRANET, OnDefaultIntranet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPortRangesDlg message handlers

BOOL ExtractPortsFromString(CString &rPortRange, long &dwStartPort, long &dwEndPort)
{
    if (!rPortRange.IsEmpty())
    {
        int nRangeLength = rPortRange.GetLength();

        // extract the two numbers
        CString sStartPort,sEndPort;

        sStartPort = rPortRange.SpanIncluding(TEXT("0123456789"));

        if (!sStartPort.IsEmpty())
            dwEndPort = dwStartPort = _tcstol((LPCTSTR)sStartPort, NULL, 10);

        if (sStartPort.IsEmpty() || (dwStartPort > MAX_PORT) || (dwStartPort < MIN_PORT))
            return FALSE;

        int nIndex = sStartPort.GetLength();

        // skip - or whitespace
        while ((nIndex < nRangeLength) &&
                ((rPortRange.GetAt(nIndex) == TEXT(' ')) ||
                (rPortRange.GetAt(nIndex) == TEXT('\t')) ||
                (rPortRange.GetAt(nIndex) == TEXT('-'))))
            nIndex++;

        // extract second port
        sEndPort = rPortRange.Mid(nIndex);

        // check for second valid number
        if (!sEndPort.IsEmpty())
        {
            CString sTmp = sEndPort.SpanIncluding(TEXT("0123456789"));
            dwEndPort = _tcstol((LPCTSTR)sTmp, NULL, 10);

            // ensure all characters are numeric
            if (sEndPort.GetLength() != sTmp.GetLength())
                return FALSE;

            if (dwEndPort > MAX_PORT)
                return FALSE;

            if (dwEndPort < dwStartPort)
                return FALSE;
        }

        return TRUE;
    }
    return FALSE;
}

BOOL PortsToString(CString &rsPort, long dwStartPort, long dwEndPort)
{
    rsPort.Empty();
    if (dwStartPort == dwEndPort)
        rsPort.Format(TEXT("%d"), dwStartPort);
    else
        rsPort.Format(TEXT("%d-%d"), dwStartPort, dwEndPort);

    return TRUE;
}


BOOL CPortRangesDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // set up instructions
    CString sTmp((LPCTSTR)IDS_INSTRUCTIONS_PORTRANGES);
    m_stInstructions.SetWindowText(sTmp);

    m_btnAdd.EnableWindow(TRUE);
    m_btnRemoveAll.EnableWindow(TRUE);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Rpc\PortsInternetAvailable
    // this determines whether the range read later refers to internet or intranet port range
    int err;

    // read in whether ports are available for internet
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("PortsInternetAvailable"),
                                        &m_nInetPortsAvailableIdx);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_nInetPortsAvailableIdx);

        CString sTmp = pCdp -> Value();

        if ((sTmp == TEXT("y")) || (sTmp == TEXT("Y")))
        {
            m_nrbRangeAssignment = (int)cprInternet;
            m_pRanges = &m_arrInternetRanges;
        }
        else
        {
            m_nrbRangeAssignment = (int)cprIntranet;
            m_pRanges = &m_arrIntranetRanges;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }


    // read in ports list
    err = g_virtreg.ReadRegMultiSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("Ports"),
                                        &m_nInetPortsIdx);
    if (err == ERROR_SUCCESS)
    {
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt(m_nInetPortsIdx);

        CStringArray& rPorts = pCdp -> Values();

        // copy protocols
        int nIndex;
        for (nIndex = 0; nIndex < rPorts.GetSize(); nIndex++)
        {
            CString sTmp = rPorts.GetAt(nIndex);
            long dwStartPort, dwEndPort;
            ExtractPortsFromString(sTmp, dwStartPort, dwEndPort);
            m_pRanges -> Add(new CPortRange(dwStartPort, dwEndPort));
        }

        // set selection to first item
        m_nSelection = 0;
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // read in default policy
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("UseInternetPorts"),
                                        &m_nInetDefaultPortsIdx);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_nInetDefaultPortsIdx);

        CString sTmp = pCdp -> Value();

        if ((sTmp == TEXT("y")) || (sTmp == TEXT("Y")))
            m_nrbDefaultAssignment = (int)cprDefaultInternet;
        else
            m_nrbDefaultAssignment = (int)cprDefaultIntranet;
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    m_bChanged = FALSE;
    RefreshRanges(NULL, TRUE);

    // focus and selection will be set to listbox
//    if (m_nSelection != -1)
//        return FALSE;

    UpdateData(FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CPortRangesDlg::OnAddPortRange()
{
    CAddPortDlg capd;

    if (capd.DoModal() == IDOK)
    {
        CPortRange* pNewPort = capd.GetPortRange();
        m_pRanges -> Add(pNewPort);

        SortRangeSet(*m_pRanges);

        RefreshRanges(pNewPort, TRUE);
        m_bChanged = TRUE;
    }
    SetFocus();
}

void CPortRangesDlg::OnRemovePortRange()
{
    if (m_nSelection != -1)
    {
        CPortRange *pRange = (CPortRange*)m_pRanges -> GetAt(m_nSelection);
        m_pRanges -> RemoveAt(m_nSelection);
        m_lbRanges.DeleteString(m_nSelection);
        RefreshRanges(pRange, FALSE);
        
        delete pRange;
        m_bChanged = TRUE;
        
        if (!m_lbRanges.GetCount())
        {
            m_nrbDefaultAssignment = (int)cprDefaultIntranet;
            m_nrbRangeAssignment = (int)cprIntranet;
            UpdateData(FALSE);
        }
    }
}

void CPortRangesDlg::OnRemoveAllRanges()
{
    RemoveAllRanges(*m_pRanges);
    RefreshRanges(NULL, TRUE);
    m_nrbDefaultAssignment = (int)cprDefaultIntranet;
    m_nrbRangeAssignment = (int)cprIntranet;
    UpdateData(FALSE);
    m_bChanged = TRUE;
}

void CPortRangesDlg::RefreshRanges(CPortRange *pModifiedRange, BOOL bAdded)
{
    if (!pModifiedRange && bAdded)
    {
        m_nSelection = 0;
        m_lbRanges.ResetContent();
    }

    // for a deleted item we only need to update the selection
    for (int nIndex = 0; bAdded && (nIndex < m_pRanges -> GetSize()); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) m_pRanges  -> GetAt(nIndex);
        int nNewIndex = -1;

        if (!pModifiedRange || (pModifiedRange == pRange))
        {
            // add string for range
            CString sTmp;
            PortsToString(sTmp, pRange -> m_dwStart, pRange -> m_dwFinish);
            ;
            if ((nNewIndex = m_lbRanges.InsertString(nIndex, sTmp))!= LB_ERR)
                m_lbRanges.SetItemDataPtr(nNewIndex, pRange);

            if (pModifiedRange)
            {
                m_nSelection = nNewIndex;
                break;
            }
        }
    }

    // check if selection is out of range
    int nCount = m_lbRanges.GetCount();
    if (m_nSelection >= nCount)
        m_nSelection = nCount -1;

    // update selection settings
    m_btnRemove.EnableWindow(m_nSelection != -1);
    m_btnRemoveAll.EnableWindow(nCount > 0);

    CWnd * pTmpRadioBtn = NULL;

    pTmpRadioBtn = GetDlgItem(IDC_ASSIGN_RANGE_INTERNET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    pTmpRadioBtn = GetDlgItem(IDC_ASSIGN_RANGE_INTRANET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    pTmpRadioBtn = GetDlgItem(IDC_DEFAULT_INTERNET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    pTmpRadioBtn = GetDlgItem(IDC_DEFAULT_INTRANET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    if (m_nSelection != -1)
        m_lbRanges.SetCurSel(m_nSelection);
}

void CPortRangesDlg::CreateInverseRangeSet(CObArray & arrSrc, CObArray & arrDest)
{
    CondenseRangeSet(arrSrc);

    int nIndex;

    long nPreviousFinish = -1;

    // dont bother creating inverse range set for empty range set
    if (arrSrc.GetSize() != 0)
    {
        for (nIndex = 0; nIndex < arrSrc.GetSize(); nIndex++)
        {
            CPortRange *pRange = (CPortRange*) arrSrc.GetAt(nIndex);

            if ((pRange -> m_dwStart - nPreviousFinish) > 1)
            {
                CPortRange *pNewRange = new CPortRange(nPreviousFinish+1,pRange -> m_dwStart -1);
                arrDest.Add(pNewRange);
            }
            nPreviousFinish = pRange -> m_dwFinish;
        }

        // special case for last item
        if (MAX_PORT > nPreviousFinish)
        {
            CPortRange *pFinalRange = new CPortRange(nPreviousFinish+1,MAX_PORT);
            arrDest.Add(pFinalRange);
        }
    }
}

void CPortRangesDlg::SortRangeSet(CObArray& arrSrc)
{
    // bubble sort of port range set
    BOOL bChange;
    int nIndex;

    // iterate until no changes
    do
    {
        bChange = FALSE;
        for (nIndex = 0; nIndex < (arrSrc.GetSize() -1 ); nIndex++)
        {
            CPortRange *pRange1 = (CPortRange*) arrSrc.GetAt(nIndex);
            CPortRange *pRange2 = (CPortRange*) arrSrc.GetAt(nIndex+1);

            if (*pRange2 < *pRange1)
            {
                arrSrc.SetAt(nIndex, (CObject*)pRange2);
                arrSrc.SetAt(nIndex+1, (CObject*)pRange1);
                bChange = TRUE;
            }
        }
    }
    while (bChange);
}


void CPortRangesDlg::CondenseRangeSet(CObArray &arrSrc)
{
    SortRangeSet(arrSrc);

    int nIndex;

    for (nIndex = 0; nIndex < (arrSrc.GetSize() -1 ); nIndex++)
    {
        CPortRange *pRange1 = (CPortRange*) arrSrc.GetAt(nIndex);
        CPortRange *pRange2 = (CPortRange*) arrSrc.GetAt(nIndex+1);

        if (pRange1 -> m_dwFinish >= pRange2 -> m_dwStart)
        {
            if (pRange1 -> m_dwFinish < pRange2 -> m_dwFinish)
                pRange1 -> m_dwFinish = pRange2 -> m_dwFinish;

            arrSrc.RemoveAt(nIndex+1);
            delete pRange2;
        }
    }
}

void CPortRangesDlg::RemoveAllRanges(CObArray & arrSrc)
{
    int nIndex;

    for (nIndex = 0; nIndex < arrSrc.GetSize(); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) arrSrc.GetAt(nIndex);
        arrSrc.SetAt(nIndex, NULL);
        delete pRange;
    }

    arrSrc.RemoveAll();

    RefreshRanges(NULL, TRUE);
}

void CPortRangesDlg::OnAssignRangeInternet()
{
    if (m_pRanges != &m_arrInternetRanges)
    {
        m_pRanges = &m_arrInternetRanges;
        RemoveAllRanges(*m_pRanges);
        CreateInverseRangeSet(m_arrIntranetRanges, m_arrInternetRanges);

        RefreshRanges(NULL, TRUE);
    	m_bChanged = TRUE;
    }
}

void CPortRangesDlg::OnAssignRangeIntranet()
{
    if (m_pRanges != &m_arrIntranetRanges)
    {
        m_pRanges = &m_arrIntranetRanges;
        RemoveAllRanges(*m_pRanges);
        CreateInverseRangeSet(m_arrInternetRanges, m_arrIntranetRanges);

        RefreshRanges(NULL, TRUE);
        m_bChanged = TRUE;

    }
}

void CPortRangesDlg::OnDefaultInternet()
{
        m_bChanged = TRUE;
}

void CPortRangesDlg::OnDefaultIntranet()
{
        m_bChanged = TRUE;
}

void CPortRangesDlg::OnSelChangeRanges()
{
    if ((m_nSelection = m_lbRanges.GetCurSel()) == LB_ERR)
        m_nSelection = -1;
}

void CPortRangesDlg::OnOK()
{
    UpdateData(TRUE);   
    if (m_bChanged)
    {
        // write out registry data if necessary
        // if there are no port ranges - then delete the keys
        if ((m_arrInternetRanges.GetSize() == 0) &&
            (m_arrIntranetRanges.GetSize() == 0))
        {
            if (m_nInetPortsIdx != -1)
                g_virtreg.MarkHiveForDeletion(m_nInetPortsIdx);
            if (m_nInetPortsAvailableIdx != -1)
                g_virtreg.MarkHiveForDeletion(m_nInetPortsAvailableIdx);
            if (m_nInetDefaultPortsIdx != -1)
                g_virtreg.MarkHiveForDeletion(m_nInetDefaultPortsIdx);
        }
        else
        {
            // write out updated / new key values

            // port range assignments
            TCHAR* pTmp = ((m_nrbRangeAssignment == (int)cprInternet) ? TEXT("Y") : TEXT("N"));
            if (m_nInetPortsAvailableIdx != -1)
                g_virtreg.ChgRegSzNamedValue(m_nInetPortsAvailableIdx, pTmp);
            else
            {
                g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("PortsInternetAvailable"),
                                        pTmp,
                                        &m_nInetPortsAvailableIdx);
            }

            // default port assignments
            pTmp = ((m_nrbDefaultAssignment == (int)cprDefaultInternet) ? TEXT("Y") : TEXT("N"));
            if (m_nInetDefaultPortsIdx != -1)
                g_virtreg.ChgRegSzNamedValue(m_nInetDefaultPortsIdx, pTmp);
            else
            {
            g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("UseInternetPorts"),
                                        pTmp,
                                        &m_nInetDefaultPortsIdx);
            }

            // Actual port ranges
            if (m_nInetPortsIdx == -1)
                g_virtreg.NewRegMultiSzNamedValue(HKEY_LOCAL_MACHINE,
                                TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                TEXT("Ports"),
                                &m_nInetPortsIdx);

            if (m_nInetPortsIdx != -1)
            {
                CRegMultiSzNamedValueDp * pMszdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt( m_nInetPortsIdx);
                pMszdp -> Clear();

                CStringArray& rStrings = pMszdp -> Values();
                for (int nIndex = 0; nIndex < m_pRanges -> GetSize(); nIndex++)
                {
                    CPortRange *pRange = (CPortRange*) m_pRanges -> GetAt(nIndex);
                    CString sTmp;

                    PortsToString(sTmp, pRange -> Start(), pRange -> Finish());
                    rStrings.Add(sTmp);
                }
                pMszdp -> SetModified(TRUE);
            }

        }
    }

    CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CAddPortDlg dialog


CAddPortDlg::CAddPortDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CAddPortDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddPortDlg)
    m_sRange = _T("");
    //}}AFX_DATA_INIT

    m_dwStartPort = -1;
    m_dwEndPort = -1;
}


void CAddPortDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddPortDlg)
    DDX_Control(pDX, IDC_PORTRANGE, m_edtPortRange);
    DDX_Control(pDX, IDOK, m_btnOk);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    DDX_Text(pDX, IDC_PORTRANGE, m_sRange);
    //}}AFX_DATA_MAP

    if (pDX -> m_bSaveAndValidate)
    {
        m_sRange.TrimLeft();
        m_sRange.TrimRight();
    }
}


BEGIN_MESSAGE_MAP(CAddPortDlg, CDialog)
    //{{AFX_MSG_MAP(CAddPortDlg)
    ON_EN_CHANGE(IDC_PORTRANGE, OnChangePortrange)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddPortDlg message handlers


BOOL CAddPortDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    
    CString sTmp((LPCTSTR)IDS_ADDPORT_INSTRUCTIONS);

    m_stInstructions.SetWindowText(sTmp);
    m_btnOk.EnableWindow(FALSE);
    m_edtPortRange.SetFocus();
    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddPortDlg::OnOK()
{
    UpdateData(TRUE);

    if (Validate())
        CDialog::OnOK();
    else
    {
		CString sTmp((LPCTSTR)IDS_INVALID_PORTRANGE);
        AfxMessageBox((LPCTSTR)sTmp);
    }
}


BOOL CAddPortDlg::Validate()
{
    // check contents of m_sRange
    long dwStartPort = -1, dwEndPort = -1;
    return ExtractPortsFromString(m_sRange, m_dwStartPort, m_dwEndPort);
}

void CAddPortDlg::OnChangePortrange()
{
    UpdateData(TRUE);

    m_btnOk.EnableWindow(!m_sRange.IsEmpty());

}

CPortRange* CAddPortDlg::GetPortRange()
{
    return new CPortRange(m_dwStartPort, m_dwEndPort);

}

BOOL CAddPortDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CAddPortDlg::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}

BOOL CAddProtocolDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CAddProtocolDlg::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}

BOOL CEndpointDetails::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CEndpointDetails::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}

BOOL CPortRangesDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CPortRangesDlg::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;

        // both radio button pairs should generate same help id
        if (loWord == IDC_DEFAULT_INTRANET)
            loWord = IDC_DEFAULT_INTERNET;

        // both radio button pairs should generate same help id
        if (loWord == IDC_ASSIGN_RANGE_INTRANET)
            loWord = IDC_ASSIGN_RANGE_INTERNET;

        DWORD dwLong = MAKELONG(loWord,hiWord);


        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\inetppg.h ===
// InternetPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInternetPropertyPage dialog

class CInternetPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CInternetPropertyPage)

// Construction
public:
    void InitData(CString AppName, HKEY hkAppID);
    CInternetPropertyPage();
    ~CInternetPropertyPage();

// Dialog Data
    //{{AFX_DATA(CInternetPropertyPage)
    enum { IDD = IDD_INTERNET };
    CButton m_chkLaunch;
    CButton m_chkInternet;
    CButton m_chkAccess;
    BOOL    m_bAllowAccess;
    BOOL    m_bAllowInternet;
    BOOL    m_bAllowLaunch;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CInternetPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    BOOL m_bCanModify;
    BOOL m_bChanged;
    // Generated message map functions
    //{{AFX_MSG(CInternetPropertyPage)
    afx_msg void OnAllowInternet();
    afx_msg void OnAllowaccess();
    afx_msg void OnAllowlaunch();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\locppg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       locppg.cpp
//
//  Contents:   Implements the classes CGeneralPropertyPage,
//              CLocationPropertyPage, CSecurityPropertyPage and
//              CIdentityPropertyPage which manage the four property
//              pages per AppId.
//
//  Classes:
//
//  Methods:    CGeneralPropertyPage::CGeneralPropertyPage
//              CGeneralPropertyPage::~CGeneralPropertyPage
//              CGeneralPropertyPage::DoDataExchange
//              CLocationPropertyPage::CLocationPropertyPage
//              CLocationPropertyPage::~CLocationPropertyPage
//              CLocationPropertyPage::DoDataExchange
//              CLocationPropertyPage::OnBrowse
//              CLocationPropertyPage::OnRunRemote
//              CLocationPropertyPage::UpdateControls
//              CLocationPropertyPage::OnSetActive
//              CLocationPropertyPage::OnChange
//              CSecurityPropertyPage::CSecurityPropertyPage
//              CSecurityPropertyPage::~CSecurityPropertyPage
//              CSecurityPropertyPage::DoDataExchange
//              CSecurityPropertyPage::OnDefaultAccess
//              CSecurityPropertyPage::OnCustomAccess
//              CSecurityPropertyPage::OnDefaultLaunch
//              CSecurityPropertyPage::OnCustomLaunch
//              CSecurityPropertyPage::OnDefaultConfig
//              CSecurityPropertyPage::OnCustomConfig
//              CSecurityPropertyPage::OnEditAccess
//              CSecurityPropertyPage::OnEditLaunch
//              CSecurityPropertyPage::OnEditConfig
//              CIdentityPropertyPage::CIdentityPropertyPage
//              CIdentityPropertyPage::~CIdentityPropertyPage
//              CIdentityPropertyPage::DoDataExchange
//              CIdentityPropertyPage::OnBrowse
//              CIdentityPropertyPage::OnChange
//
//  History:    23-Apr-96   BruceMa    Created.
//              ??-Oct-97   ronans     General fixes and cleanup 
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "assert.h"
#include "resource.h"
#include "types.h"
#include "LocPPg.h"
#include "clspsht.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "virtreg.h"

#if !defined(STANDALONE_BUILD)
#include "ntlsa.h"
#endif



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CGeneralPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CLocationPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CSecurityPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CIdentityPropertyPage, CPropertyPage)


/////////////////////////////////////////////////////////////////////////////
// CGeneralPropertyPage property page

CGeneralPropertyPage::CGeneralPropertyPage() : CPropertyPage(CGeneralPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CGeneralPropertyPage)
    m_szServerName = _T("");
    m_szServerPath = _T("");
    m_szServerType = _T("");
    m_szPathTitle = _T("");
    m_szComputerName = _T("");
    //}}AFX_DATA_INIT

    m_authLevel = Defaultx;
    m_authLevelIndex = -1;
    m_bChanged = FALSE;
}

CGeneralPropertyPage::~CGeneralPropertyPage()
{
    CancelChanges();
}

void CGeneralPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    switch (m_iServerType)
    {
    case INPROC:
	m_szPathTitle.LoadString(IDS_PATH);
	GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
	GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
	GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
        m_szServerType.LoadString(IDS_SERVERTYPE_INPROC);
	break;

  case LOCALEXE:
        m_szPathTitle.LoadString(IDS_PATH);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
	m_szServerType.LoadString(IDS_SERVERTYPE_LOCALEXE);
        break;
    
    case SERVICE:
        m_szPathTitle.LoadString(IDS_SERVICENAME);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
	m_szServerType.LoadString(IDS_SERVERTYPE_SERVICE);
        break;
    
    case PURE_REMOTE:
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_SHOW);
        m_szServerType.LoadString(IDS_SERVERTYPE_PURE_REMOTE);
        break;
    
    case REMOTE_LOCALEXE:
        m_szPathTitle.LoadString(IDS_PATH);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_SHOW);
	m_szServerType.LoadString(IDS_SERVERTYPE_REMOTE_LOCALEXE);
        break;
    
    case REMOTE_SERVICE:
        m_szPathTitle.LoadString(IDS_SERVICENAME);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_SHOW);
	m_szServerType.LoadString(IDS_SERVERTYPE_REMOTE_SERVICE);
        break;
    
    case SURROGATE:
        m_szPathTitle.LoadString(IDS_PATH);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
	m_szServerType.LoadString(IDS_SERVERTYPE_SURROGATE);
        break;

   default:
        m_szServerType.LoadString(IDS_SERVERTYPE_UNKNOWN);
	break;
    }
    
    //{{AFX_DATA_MAP(CGeneralPropertyPage)
    DDX_Control(pDX, IDC_COMBO1, m_authLevelCBox);
    DDX_Text(pDX, IDC_SERVERNAME, m_szServerName);
    DDX_Text(pDX, IDC_SERVERPATH, m_szServerPath);
    DDX_Text(pDX, IDC_SERVERTYPE, m_szServerType);
    DDX_Text(pDX, IDC_PATHTITLE, m_szPathTitle);
    DDX_Text(pDX, IDC_MACHINE, m_szComputerName);
    //}}AFX_DATA_MAP
}

void CGeneralPropertyPage::OnEditchangeCombo1() 
{
    // TODO: Add your control notification handler code here
    
}

void CGeneralPropertyPage::OnSelchangeCombo1() 
{
    int iSel;

    // Get the new selection
    iSel = m_authLevelCBox.GetCurSel();
    m_authLevel = (AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(iSel);

    // Virtually write it to the registry
    if (m_authLevelIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(g_hAppid,
                                        NULL,
                                        TEXT("AuthenticationLevel"),
                                        m_authLevel,
                                        &m_authLevelIndex);
    }
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_authLevelIndex,
                                        m_authLevel);
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(m_bChanged = TRUE);
}

BOOL CGeneralPropertyPage::OnInitDialog() 
{
    int iIndex;
    int   err;
    CPropertyPage::OnInitDialog();
    
    // Populate the authentication combo boxe
    CString sTemp;

    m_authLevelCBox.ResetContent();

    // Associate values with entries
    sTemp.LoadString(IDS_DEFAULT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Defaultx);

    sTemp.LoadString(IDS_NONE);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, None);

    sTemp.LoadString(IDS_CONNECT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Connect);

    sTemp.LoadString(IDS_CALL);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Call);

    sTemp.LoadString(IDS_PACKET);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Packet);

    sTemp.LoadString(IDS_PACKETINTEGRITY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketIntegrity);

    sTemp.LoadString(IDS_PACKETPRIVACY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketPrivacy);
    
    m_authLevelCBox.SetCurSel(Defaultx);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacyAuthenticationLevel
    err = g_virtreg.ReadRegDwordNamedValue(g_hAppid,
                                           NULL,
                                           TEXT("AuthenticationLevel"),
                                           &m_authLevelIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_authLevelIndex);

        m_authLevel = (AUTHENTICATIONLEVEL) pCdp->GetDwordValue();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err != ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }
    else
        m_authLevel = Defaultx;

    // AuthenticationLevel
    for (int k = 0; k < m_authLevelCBox.GetCount(); k++)
    {
        if (((AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(k)) == m_authLevel)
        {
            m_authLevelCBox.SetCurSel(k);
            break;
        }
    }

    SetModified(m_bChanged = FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//+-------------------------------------------------------------------------
//
//  Member:     CGeneralPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CGeneralPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGeneralPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CGeneralPropertyPage::UpdateChanges(HKEY hkAppID)
{
    if (m_authLevelIndex >= 0)
    {
        if (m_bChanged)
        {
            // delete key if its the default
            if (m_authLevel == Defaultx)
                g_virtreg.MarkForDeletion(m_authLevelIndex);
            g_virtreg.Apply(m_authLevelIndex);
        }
        g_virtreg.Remove(m_authLevelIndex);
        m_authLevelIndex = -1;
    }
    m_bChanged = FALSE;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGeneralPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CGeneralPropertyPage::CancelChanges()
{
    if (m_authLevelIndex >= 0)
    {
        g_virtreg.Remove(m_authLevelIndex);
        m_authLevelIndex = -1;
    }

    return TRUE;
}



BOOL CGeneralPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CGeneralPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}

BEGIN_MESSAGE_MAP(CGeneralPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CGeneralPropertyPage)
    ON_WM_HELPINFO()
    ON_CBN_EDITCHANGE(IDC_COMBO1, OnEditchangeCombo1)
    ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchangeCombo1)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLocationPropertyPage property page

CLocationPropertyPage::CLocationPropertyPage() : CPropertyPage(CLocationPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CLocationPropertyPage)
    m_szComputerName = _T("");
    m_fAtStorage = FALSE;
    m_fLocal = FALSE;
    m_fRemote = FALSE;
    m_iInitial = 2;
    //}}AFX_DATA_INIT
    m_bChanged = FALSE;
}

CLocationPropertyPage::~CLocationPropertyPage()
{
}

void CLocationPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLocationPropertyPage)
    DDX_Text(pDX, IDC_EDIT1, m_szComputerName);
    DDV_MaxChars(pDX, m_szComputerName, 256);
    DDX_Check(pDX, IDC_CHECK1, m_fAtStorage);
    DDX_Check(pDX, IDC_CHECK2, m_fLocal);
    DDX_Check(pDX, IDC_CHECK3, m_fRemote);
    //}}AFX_DATA_MAP
    if (m_fRemote)
    {
        pDX->PrepareEditCtrl(IDC_EDIT1);
        if (m_szComputerName.GetLength() == 0  &&  m_iInitial == 0)
        {
            CString szTemp;
            szTemp.LoadString(IDS_INVALIDSERVER);
            MessageBox(szTemp);
            pDX->Fail();
        }
    }

    if (m_fAtStorage)
    {
        m_pPage1->m_szComputerName.LoadString(IDS_ATSTORAGE);
    }
    else
        m_pPage1->m_szComputerName = m_szComputerName;

    switch(m_pPage1->m_iServerType)
    {
    case LOCALEXE:
    case SERVICE:
        if (m_fAtStorage || m_fRemote)
            m_pPage1->m_iServerType += 3;
        break;
    
    case REMOTE_LOCALEXE:
    case REMOTE_SERVICE:
        if (!(m_fAtStorage || m_fRemote))
            m_pPage1->m_iServerType -= 3;
        break;
    }

    if (m_iInitial)
        m_iInitial--;
}

BEGIN_MESSAGE_MAP(CLocationPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CLocationPropertyPage)
    ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
    ON_BN_CLICKED(IDC_CHECK3, OnRunRemote)
    ON_EN_CHANGE(IDC_EDIT1, OnChange)
    ON_BN_CLICKED(IDC_CHECK1, OnChange)
    ON_BN_CLICKED(IDC_CHECK2, OnChange)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CLocationPropertyPage::OnBrowse()
{
    TCHAR szMachine[MAX_PATH];

    if (g_util.InvokeMachineBrowser(szMachine))
    {
        // Strip off "\\" - if present
        int nIndex = 0;
        while(szMachine[nIndex] == TEXT('\\'))
            nIndex++;

        GetDlgItem(IDC_EDIT1)->SetWindowText(&szMachine[nIndex]);
        SetModified(m_bChanged = TRUE);
    }
}

void CLocationPropertyPage::OnRunRemote()
{
    SetModified(m_bChanged = TRUE);
    UpdateControls();
}

void CLocationPropertyPage::UpdateControls()
{
    BOOL fChecked = IsDlgButtonChecked(IDC_CHECK3);
    GetDlgItem(IDC_EDIT1)->EnableWindow(fChecked);

    // Leave this browse button disabled until after SUR Beta 2
    GetDlgItem(IDC_BUTTON1)->EnableWindow(fChecked);
}

BOOL CLocationPropertyPage::OnSetActive()
{
    if (!m_fCanBeLocal)
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    UpdateControls();
    return CPropertyPage::OnSetActive();
}

void CLocationPropertyPage::OnChange()
{
    SetModified(m_bChanged = TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLocationPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CLocationPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);

    // Check that remote servers are valid connectable machines
    if (m_fRemote)
    {
        if (!g_util.VerifyRemoteMachine((TCHAR *) LPCTSTR(m_szComputerName)))
            return FALSE;
    }
    
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLocationPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CLocationPropertyPage::UpdateChanges(HKEY hkAppID)
{
    long lErr;

    ////////////////////////////////////////////////////////////////////
    // Persist Location property page data
    if (m_fAtStorage)
        lErr = RegSetValueEx(
                hkAppID,
                TEXT("ActivateAtStorage"),
                0,
                REG_SZ,
                (BYTE *)TEXT("Y"),
                sizeof(TCHAR) * 2);
    else
        lErr = RegDeleteValue(hkAppID, TEXT("ActivateAtStorage"));


    if (m_fRemote)
        lErr = RegSetValueEx(
                hkAppID,
                TEXT("RemoteServerName"),
                0,
                REG_SZ,
                (BYTE *)(LPCTSTR)m_szComputerName,
                (1 + m_szComputerName.GetLength()) * sizeof(TCHAR));
    else
        lErr = RegDeleteValue(hkAppID, TEXT("RemoteServerName"));

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLocationPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CLocationPropertyPage::CancelChanges()
{
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSecurityPropertyPage property page

CSecurityPropertyPage::CSecurityPropertyPage() : CPropertyPage(CSecurityPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CSecurityPropertyPage)
    m_iAccess             = -1;
    m_iLaunch             = -1;
    m_iConfig             = -1;
    m_iAccessIndex        = -1;
    m_iLaunchIndex        = -1;
    m_iConfigurationIndex = -1;
    //}}AFX_DATA_INIT
}

CSecurityPropertyPage::~CSecurityPropertyPage()
{
}

void CSecurityPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecurityPropertyPage)
    DDX_Radio(pDX, IDC_RADIO1, m_iAccess);
    DDX_Radio(pDX, IDC_RADIO3, m_iLaunch);
    DDX_Radio(pDX, IDC_RADIO5, m_iConfig);
    //}}AFX_DATA_MAP
    GetDlgItem(IDC_BUTTON1)->EnableWindow(1 == m_iAccess);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(1 == m_iLaunch);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(1 == m_iConfig);
}

BEGIN_MESSAGE_MAP(CSecurityPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CSecurityPropertyPage)
    ON_BN_CLICKED(IDC_RADIO1, OnDefaultAccess)
    ON_BN_CLICKED(IDC_RADIO2, OnCustomAccess)
    ON_BN_CLICKED(IDC_RADIO3, OnDefaultLaunch)
    ON_BN_CLICKED(IDC_RADIO4, OnCustomLaunch)
    ON_BN_CLICKED(IDC_RADIO5, OnDefaultConfig)
    ON_BN_CLICKED(IDC_RADIO6, OnCustomConfig)
    ON_BN_CLICKED(IDC_BUTTON1, OnEditAccess)
    ON_BN_CLICKED(IDC_BUTTON2, OnEditLaunch)
    ON_BN_CLICKED(IDC_BUTTON3, OnEditConfig)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSecurityPropertyPage::OnDefaultAccess()
{
    // Disable the edit access permissions window
    UpdateData(TRUE);

    // If there is an SD here then mark it for delete
    if (m_iAccessIndex != -1)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_iAccessIndex);
        pCdp->MarkForDeletion(TRUE);
        SetModified(TRUE);
    }
}

void CSecurityPropertyPage::OnCustomAccess()
{
    UpdateData(TRUE);

    // If there is an SD here then unmark it for delete
    if (m_iAccessIndex != -1)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_iAccessIndex);
        pCdp->MarkForDeletion(FALSE);
        SetModified(TRUE);
    }
}

void CSecurityPropertyPage::OnDefaultLaunch()
{
    UpdateData(TRUE);

    // If there is an SD here then mark it for delete
    if (m_iLaunchIndex != -1)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_iLaunchIndex);
        pCdp->MarkForDeletion(TRUE);
        SetModified(TRUE);
    }
}

void CSecurityPropertyPage::OnCustomLaunch()
{
    UpdateData(TRUE);

    // If there is an SD here then unmark it for delete
    if (m_iLaunchIndex != -1)
    {
        CDataPacket *pCdp = g_virtreg.GetAt(m_iLaunchIndex);
        pCdp->MarkForDeletion(FALSE);
    }
}

void CSecurityPropertyPage::OnDefaultConfig()
{
    int   err;
    ULONG ulSize = 1;
    BYTE *pbValue = NULL;

    // Read the security descriptor for HKEY_CLASSES_ROOT
    // Note: We always expect to get ERROR_INSUFFICIENT_BUFFER
    err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue,
                            &ulSize);
    if (err == ERROR_INSUFFICIENT_BUFFER)
    {
        pbValue = new BYTE[ulSize];
        if (pbValue == NULL)
        {
            return;
        }
        err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                pbValue,
                                &ulSize);
        if (err != ERROR_SUCCESS)
            return;
    }
    else
        return;
    
    // Change the custom security back to the default, if there is a custom
    // security descriptor, but just in the virtual registry -
    // in case the user cancels
    if (m_iConfigurationIndex != -1)
    {
        CDataPacket * pCdb = g_virtreg.GetAt(m_iConfigurationIndex);
        pCdb->ChgACL((SECURITY_DESCRIPTOR *) pbValue, TRUE);
        pCdb->SetModified(TRUE);
    }
    delete pbValue;

    UpdateData(TRUE);
    SetModified(TRUE);
}


void CSecurityPropertyPage::OnCustomConfig()
{
    // If a security descriptor already exists, then the user was here
    // before, then selected default configuration.  So just copy the
    // original as the extant custom configuration
    if (m_iConfigurationIndex != -1)
    {
        CDataPacket *pCdb = g_virtreg.GetAt(m_iConfigurationIndex);
        pCdb->ChgACL(pCdb->pkt.racl.pSecOrig, TRUE);
        pCdb-> SetModified(TRUE);
    }

    UpdateData(TRUE);
    SetModified(TRUE);
}


void CSecurityPropertyPage::OnEditAccess()
{
    int     err;

    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           g_hAppid,
                           NULL,
                           TEXT("AccessPermission"),
                           &m_iAccessIndex,
                           SingleACL,
                           dcomAclAccess);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
}

void CSecurityPropertyPage::OnEditLaunch()
{
    int     err;

    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           g_hAppid,
                           NULL,
                           TEXT("LaunchPermission"),
                           &m_iLaunchIndex,
                           SingleACL,
                           dcomAclLaunch);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
}

void CSecurityPropertyPage::OnEditConfig()
{
    int     err = ERROR_SUCCESS;

    // Invoke the ACL editor
    err = g_util.ACLEditor2(m_hWnd,
                            g_hAppid,
                            g_rghkCLSID,
                            g_cCLSIDs,
                            g_szAppTitle,
                            &m_iConfigurationIndex,
                            RegKeyACL);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
    else if (err == ERROR_ACCESS_DENIED)
        g_util.CkForAccessDenied(ERROR_ACCESS_DENIED);
    else if (err != IDCANCEL)
        g_util.PostErrorMessage();
}

//+-------------------------------------------------------------------------
//
//  Member:     CSecurityPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CSecurityPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSecurityPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CSecurityPropertyPage::UpdateChanges(HKEY hkAppID)
{
    ////////////////////////////////////////////////////////////////////
    // Persist Security property page data

    // Access permissions
    // Use default access permissions
    if (m_iAccess == 0)
    {
        // Delete the local AccessPermission named value to force this
        // AppID to use the default global named value DefaultAccessPermission
        long lErr = RegDeleteValue(hkAppID, TEXT("AccessPermission"));
    }

    // Use per AppID access permissions
    else
    {
        // If the user edited security, then persist that now
        if (m_iAccessIndex >= 0)
        {
            long lErr = g_virtreg.Apply(m_iAccessIndex);
            g_virtreg.Remove(m_iAccessIndex);
            m_iAccessIndex = -1;
        }
    }

    // Launch permissions
    // Use default Launch permissions
    if (m_iLaunch == 0)
    {
        // Delete the local LaunchPermission named value to force this
        // AppID to use the default global named value DefaultLaunchPermission
        long lErr = RegDeleteValue(hkAppID, TEXT("LaunchPermission"));
    }

    // Use per AppID Launch permissions
    else
    {
        // If the user edited security, then persist that now
        if (m_iLaunchIndex >= 0)
        {
            long lErr = g_virtreg.Apply(m_iLaunchIndex);
            g_virtreg.Remove(m_iLaunchIndex);
            m_iLaunchIndex = -1;
        }
    }

    // Configuration permissions
    // Only meaningful on a per AppID basis
    // If the user edited configuration security, then persist that now
    if (m_iConfigurationIndex >= 0)
    {
        long lErr = g_virtreg.Apply(m_iConfigurationIndex);
        g_virtreg.Remove(m_iConfigurationIndex);
        m_iConfigurationIndex = -1;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSecurityPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CSecurityPropertyPage::CancelChanges()
{
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CIdentityPropertyPage property page

CIdentityPropertyPage::CIdentityPropertyPage() : CPropertyPage(CIdentityPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CIdentityPropertyPage)
    m_szUserName = _T("");
    m_szPassword = _T("");
    m_szConfirmPassword = _T("");
    m_iIdentity = -1;
    //}}AFX_DATA_INIT
}

CIdentityPropertyPage::~CIdentityPropertyPage()
{
}

void CIdentityPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    // If server is not a service, disable IDC_RADIO4 on page4.
    if (m_fService)
    {
        GetDlgItem(IDC_RADIO1)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
    }
    else
    {
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
    }

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIdentityPropertyPage)
    DDX_Text(pDX, IDC_EDIT1, m_szUserName);
    DDV_MaxChars(pDX, m_szUserName, 128);
    DDX_Text(pDX, IDC_EDIT2, m_szPassword);
    DDV_MaxChars(pDX, m_szPassword, 128);
    DDX_Text(pDX, IDC_EDIT3, m_szConfirmPassword);
    DDV_MaxChars(pDX, m_szConfirmPassword, 128);
    DDX_Radio(pDX, IDC_RADIO1, m_iIdentity);
    //}}AFX_DATA_MAP

    GetDlgItem(IDC_EDIT1)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_STATIC1)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_EDIT2)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_STATIC2)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_EDIT3)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_STATIC3)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_BUTTON1)->EnableWindow(2 == m_iIdentity);
}

BEGIN_MESSAGE_MAP(CIdentityPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CIdentityPropertyPage)
    ON_EN_CHANGE(IDC_EDIT1, OnChange)
    ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
    ON_WM_HELPINFO()
    ON_EN_CHANGE(IDC_EDIT2, OnChange)
    ON_EN_CHANGE(IDC_EDIT3, OnChange)
    ON_BN_CLICKED(IDC_RADIO1, OnChange)
    ON_BN_CLICKED(IDC_RADIO2, OnChange)
    ON_BN_CLICKED(IDC_RADIO4, OnChange)
	ON_BN_CLICKED(IDC_RADIO3, OnChangeToUser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CIdentityPropertyPage::OnBrowse()
{
    TCHAR szUser[128];
    
    if (g_util.InvokeUserBrowser(m_hWnd, szUser))
    {
        GetDlgItem(IDC_EDIT1)->SetWindowText(szUser);
        UpdateData(TRUE);
        SetModified(TRUE);
    }
}

void CIdentityPropertyPage::OnChange()
{
    UpdateData(TRUE);
    SetModified(TRUE);
}

void CIdentityPropertyPage::OnChangeToUser() 
{
    if (g_util.IsBackupDC())
    {
        CString sTmp((LPCTSTR)IDS_BDCCONFIRM);
        int reply = AfxMessageBox(sTmp, MB_YESNO);
        if (reply == IDYES ) {
            UpdateData(TRUE);
            SetModified(TRUE);
        }
        else
        {
            UpdateData(FALSE);

            // set focus to old button 
            switch (m_iIdentity)
            {
            case 0:
                GetDlgItem(IDC_RADIO1)->SetFocus();
                break;

            case 1:
                GetDlgItem(IDC_RADIO2)->SetFocus();
                break;

            case 2:
                GetDlgItem(IDC_RADIO3)->SetFocus();
                break;

            case 3:
                GetDlgItem(IDC_RADIO4)->SetFocus();
                break;
            }
        }
    }
    else
    {
        // get old identity value
        UpdateData(TRUE);
        SetModified(TRUE);
    }
	
}


//+-------------------------------------------------------------------------
//
//  Member:     CIdentityPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CIdentityPropertyPage::ValidateChanges()
{
    CString szUserName;

    UpdateData(TRUE);

    if (m_iIdentity == 2)
    {
        // Check that the username is not blank
        if (_tcslen(m_szUserName) == 0)
        {
            CString szTemp((LPCTSTR)IDS_BLANKUSERNAME);
            MessageBox(szTemp);
            return FALSE;
        }

/*
        // Check that the password is not blank
        if (_tcslen(m_szPassword) == 0)
        {
            CString szTemp((LPCTSTR)IDS_BLANKPASSWORD);
            MessageBox(szTemp);
            return FALSE;
        }
*/

        // Check that the password has been confirmed
        if (m_szPassword != m_szConfirmPassword)
        {
            CString szTemp((LPCTSTR)IDS_NOMATCH);
            MessageBox(szTemp);
            return FALSE;
        }

        int iSplitPoint = m_szUserName.ReverseFind('\\');
        if (iSplitPoint < 0)
        {
            DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;

            // user didn't specify a domain
            if (!GetComputerName(m_szDomain.GetBuffer(dwSize), &dwSize))
            {
                m_szDomain.ReleaseBuffer();
                g_util.PostErrorMessage();
                return FALSE;
            }
            m_szDomain.ReleaseBuffer();
            szUserName = m_szUserName;
            m_szUserName = m_szDomain + "\\" + m_szUserName;
        }
        else
        {
            // user did specify a domain
            m_szDomain = m_szUserName.Left(iSplitPoint);
            szUserName = m_szUserName.Mid(iSplitPoint + 1);
        }

        // Validate the domain and user name
        BOOL                fOk = FALSE;
        BYTE                sid[256];
        DWORD               cbSid = 256;
        TCHAR               szAcctDomain[MAX_PATH];
        DWORD               cbAcctDomain = MAX_PATH * sizeof(TCHAR);
        SID_NAME_USE        acctType;

        CString sFullUserName = m_szDomain + "\\" + m_szUserName;
        fOk = LookupAccountName(NULL,
                                (TCHAR *) ((LPCTSTR) m_szUserName),
                                sid,
                                &cbSid,
                                szAcctDomain,
                                &cbAcctDomain,
                                &acctType);

        // if successful, then validate domain name and account type
        if (fOk)
        {
            fOk = ((_tcsicmp((TCHAR *) ((LPCTSTR) m_szDomain), szAcctDomain) == 0)
                   &&
                   (acctType == SidTypeUser));

            // If still unsuccessful, then try to match the domain against
            // this computer's name
            if (!fOk)
            {
                TCHAR szThisComputer[MAX_COMPUTERNAME_LENGTH + 1];
                DWORD dwSize;

                if (GetComputerName(szThisComputer, &dwSize))
                {
                    fOk = (_tcsicmp((TCHAR *) ((LPCTSTR) szThisComputer),
                                    szAcctDomain) == 0
                           &&
                           acctType == SidTypeDomain);
                }
            }
        }

        if (!fOk)
        {
            CString szTemp((LPCTSTR)IDS_NOACCOUNT);
            MessageBox(szTemp);
            return FALSE;
        }
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIdentityPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CIdentityPropertyPage::UpdateChanges(HKEY hkAppID)
{
    long lErr;

#if !defined(STANDALONE_BUILD)
        // Write the RunAs password to the Lsa private database
        // (Note: We do this even if it's a service since QueryServiceConfig
        //  doesn't return the password, though we can use ChangeServiceConfig
        //  to set the password in the service database.)
    if (m_iIdentity == 2)
    {
        if (!g_util.StoreUserPassword(g_szAppid, m_szPassword))
            g_util.PostErrorMessage();

        // Add rights to this user's account for "SeBatchLogonRight"
        int err;

        CString szUserName = m_szUserName;

        // ronans - do not display errors when trying to set account rights on backup domain controllers
        if ((err = g_util.SetAccountRights((LPCTSTR) szUserName, m_fService ? SE_SERVICE_LOGON_NAME : SE_BATCH_LOGON_NAME ) != ERROR_SUCCESS)
            && !g_util.IsBackupDC())
            g_util.PostErrorMessage(err);
    }
#endif

    switch (m_iIdentity)
    {
    case 0:
        {
            CString szTemp(TEXT("Interactive User"));
            lErr = RegSetValueEx(
                    hkAppID,
                    TEXT("RunAs"),
                    0,
                    REG_SZ,
                    (BYTE *)(LPCTSTR)szTemp,
                    (1 + szTemp.GetLength()) * sizeof(TCHAR));
            break;
        }

    case 1:
    case 3:
        lErr = RegDeleteValue(hkAppID,
                          TEXT("RunAs"));
    break;

    case 2:
        lErr = RegSetValueEx(hkAppID,
                         TEXT("RunAs"),
                         0,
                         REG_SZ,
                         (BYTE *)(LPCTSTR)m_szUserName,
                         (1 + m_szUserName.GetLength()) *
                         sizeof(TCHAR));
        break;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIdentityPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CIdentityPropertyPage::CancelChanges()
{
    return TRUE;
}








BOOL CLocationPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CLocationPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}


BOOL CSecurityPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CSecurityPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}


BOOL CIdentityPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CIdentityPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\newsrvr.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       newsrvr.cpp
//
//  Contents:   Implements the new server dialog
//
//  Classes:
//
//  Methods:    CNewServer::CNewServer
//              CNewServer::~CNewServer
//              CNewServer::DoDataExchange
//              CNewServer::OnLocal
//              CNewServer::OnRemote
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "olecnfg.h"
#include "newsrvr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewServer dialog


CNewServer::CNewServer(CWnd* pParent /*=NULL*/)
        : CDialog(CNewServer::IDD, pParent)
{
        //{{AFX_DATA_INIT(CNewServer)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}


void CNewServer::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CNewServer)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewServer, CDialog)
        //{{AFX_MSG_MAP(CNewServer)
        ON_BN_CLICKED(IDC_RADIO1, OnLocal)
        ON_BN_CLICKED(IDC_RADIO2, OnRemote)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewServer message handlers

void CNewServer::OnLocal()
{
        // TODO: Add your control notification handler code here
        GetDlgItem(IDC_EDIT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(TRUE);
        GetDlgItem(IDC_EDIT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON2)->EnableWindow(FALSE);
}

void CNewServer::OnRemote()
{
        // TODO: Add your control notification handler code here
        GetDlgItem(IDC_EDIT3)->EnableWindow(TRUE);
        GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE);
        GetDlgItem(IDC_EDIT2)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\locppg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       locppg.h
//
//  Contents:   Defines the classes CGeneralPropertyPage,
//              CLocationPropertyPage, CSecurityPropertyPage and
//              CIdentityPropertyPage which manage the four property
//              pages per AppId.
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef __LOCPPG_H__
#define __LOCPPG_H__

/////////////////////////////////////////////////////////////////////////////
// CGeneralPropertyPage dialog

class CGeneralPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CGeneralPropertyPage)

    // Construction
public:
    CGeneralPropertyPage();
    ~CGeneralPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CGeneralPropertyPage)
    enum { IDD = IDD_PROPPAGE5 };
    CComboBox   m_authLevelCBox;
    CString m_szServerName;
    CString m_szServerPath;
    CString m_szServerType;
    CString m_szPathTitle;
    CString m_szComputerName;
    //}}AFX_DATA

    int m_iServerType;
    BOOL m_fSurrogate;
    BOOL m_bChanged;

    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CGeneralPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CGeneralPropertyPage)
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnEditchangeCombo1();
    afx_msg void OnSelchangeCombo1();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    AUTHENTICATIONLEVEL m_authLevel;
    int m_authLevelIndex;
};


/////////////////////////////////////////////////////////////////////////////
// CLocationPropertyPage dialog

class CLocationPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CLocationPropertyPage)

// Construction
public:
    CLocationPropertyPage();
    ~CLocationPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CLocationPropertyPage)
    enum { IDD = IDD_PROPPAGE11 };
    CString m_szComputerName;
    BOOL    m_fAtStorage;
    BOOL    m_fLocal;
    BOOL    m_fRemote;
    int     m_iInitial;
    //}}AFX_DATA

    BOOL    m_fCanBeLocal;
    CGeneralPropertyPage * m_pPage1;
    BOOL    m_bChanged;

    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CLocationPropertyPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CLocationPropertyPage)
    afx_msg void OnBrowse();
    afx_msg void OnRunRemote();
    afx_msg void OnChange();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void UpdateControls();
};


/////////////////////////////////////////////////////////////////////////////
// CSecurityPropertyPage dialog

class CSecurityPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CSecurityPropertyPage)

// Construction
public:
    CSecurityPropertyPage();
    ~CSecurityPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CSecurityPropertyPage)
    enum { IDD = IDD_PROPPAGE21 };
    int             m_iAccess;
    int             m_iLaunch;
    int             m_iConfig;
    int             m_iAccessIndex;
    int             m_iLaunchIndex;
    int             m_iConfigurationIndex;
    //}}AFX_DATA


    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSecurityPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSecurityPropertyPage)
    afx_msg void OnDefaultAccess();
    afx_msg void OnCustomAccess();
    afx_msg void OnDefaultLaunch();
    afx_msg void OnCustomLaunch();
    afx_msg void OnDefaultConfig();
    afx_msg void OnCustomConfig();
    afx_msg void OnEditAccess();
    afx_msg void OnEditLaunch();
    afx_msg void OnEditConfig();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CIdentityPropertyPage dialog

class CIdentityPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CIdentityPropertyPage)

    // Construction
public:
    CIdentityPropertyPage();
    ~CIdentityPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CIdentityPropertyPage)
    enum { IDD = IDD_PROPPAGE3 };
    CString m_szUserName;
    CString m_szPassword;
    CString m_szConfirmPassword;
    int m_iIdentity;
    //}}AFX_DATA

    CString m_szDomain;
    int m_fService;

    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CIdentityPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CIdentityPropertyPage)
    afx_msg void OnChange();
    afx_msg void OnBrowse();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnChangeToUser();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
#endif // __LOCPPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\oleui.cpp ===
// olecnfg.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"

#include "olecnfg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\olecnfg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       olecnfg.h
//
//  Contents:   Implements the class COlecnfgApp - the top level class
//              for dcomcnfg.exe
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp:
// See olecnfg.cpp for the implementation of this class
//

class COlecnfgApp : public CWinApp
{
public:
    COlecnfgApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COlecnfgApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(COlecnfgApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\newsrvr.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       newsrvr.h
//
//  Contents:   Defines the class CNewServer for the new server dialog
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////
// CNewServer dialog
#ifndef _NEWSRVR_H_
#define _NEWSRVR_H_

class CNewServer : public CDialog
{
// Construction
public:
        CNewServer(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CNewServer)
        enum { IDD = IDD_DIALOG1 };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CNewServer)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CNewServer)
        afx_msg void OnLocal();
        afx_msg void OnRemote();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

#endif //_NEWSRVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\olecnfg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       olecnfg.cpp
//
//  Contents:   Implements the class COlecnfgApp - the top level class
//              for dcomcnfg.exe
//
//  Classes:    
//
//  Methods:    COlecnfgApp::COlecnfgApp
//              COlecnfgApp::InitInstance
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "olecnfg.h"
#include "CStrings.h"   
#include "CReg.h"
#include "types.h"
#include "datapkt.h"
#include "virtreg.h"
#include "CnfgPSht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp

BEGIN_MESSAGE_MAP(COlecnfgApp, CWinApp)
    //{{AFX_MSG_MAP(COlecnfgApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
    //}}AFX_MSG

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp construction

COlecnfgApp::COlecnfgApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only COlecnfgApp object

COlecnfgApp theApp;

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp initialization

BOOL COlecnfgApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.
    
#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif
    
    // This tool really so only be run by administrators.  We check this
    // by trying to get KEY_ALL_ACCESS rights to
    // HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE
    HKEY hKey;
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\OLE"),
                     0, KEY_ALL_ACCESS, &hKey)
        != ERROR_SUCCESS)
    {
        CString sCaption;
        CString sMessage;
        
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    sMessage.LoadString(IDS_ADMINSONLY);
    MessageBox(NULL, sMessage, sCaption, MB_OK);
        return FALSE;
    }
    
    // The main body of oleui
    COlecnfgPropertySheet psht;
    m_pMainWnd = &psht;
    INT_PTR nResponse = psht.DoModal();
    if (nResponse == IDOK)
    {
        g_virtreg.Ok(0);
    }
    else if (nResponse == IDCANCEL)
    {
        g_virtreg.Cancel(0);
    }
    
    // Remove the virtual registry
    g_virtreg.RemoveAll();
    
    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by olecnfg.rc
//
#define IDD_OLECNFG_DIALOG              102
#define IDD_PROPPAGE1                   104
#define IDD_PROPPAGE2                   105
#define IDD_PROPPAGE11                  107
#define IDD_PROPPAGE21                  108
#define IDD_PROPPAGE3                   109
#define IDD_PROPPAGE4                   110
#define IDD_PROPPAGE5                   111
#define IDD_RPCOPTIONS                  128
#define IDR_MAINFRAME                   129
#define IDD_DIALOG1                     130
#define IDR_ACCELERATOR1                131
#define IDI_ICON1                       133
#define IDD_RPCEP_DETAILS               135
#define IDI_ICON2                       137
#define IDB_IMGNETWORK                  142
#define IDD_INTERNET                    239
#define IDD_PPGDEFPROT                  241
#define IDD_ADDPROTOCOL                 242
#define IDD_RPC_PORT_RANGES             243
#define IDD_ADD_PORT_RANGE              244
#define IDS_ABOUTBOX                    300
#define IDS_PROPSHT_CAPTION             301
#define IDS_NOTIPAVAILABLE              302
#define IDS_PROTSEQ                     303
#define IDS_PROPSHT_CAPTION1            304
#define IDS_PSMAIN_TITLE                305
#define IDS_NONE                        306
#define IDS_DEFAULT                     307
#define IDS_CONNECT                     308
#define IDS_CALL                        309
#define IDS_PACKET                      310
#define IDS_PACKETINTEGRITY             311
#define IDS_PACKETPRIVACY               312
#define IDS_ANONYMOUS                   313
#define IDS_IDENTIFY                    314
#define IDS_IMPERSONATE                 315
#define IDS_DELEGATE                    316
#define IDS_ACCESSDENIED                317
#define IDS_SYSTEMMESSAGE               318
#define IDS_NA                          319
#define IDS_SERVERTYPE0                 320
#define IDS_SERVERTYPE_INPROC           320
#define IDS_SERVERTYPE1                 321
#define IDS_SERVERTYPE_LOCALEXE         321
#define IDS_SERVERTYPE2                 322
#define IDS_SERVERTYPE_SERVICE          322
#define IDS_SERVERTYPE3                 323
#define IDS_SERVERTYPE_PURE_REMOTE      323
#define IDS_SERVERTYPE4                 324
#define IDS_SERVERTYPE_REMOTE_LOCALEXE  324
#define IDS_SERVERTYPE5                 325
#define IDS_SERVERTYPE_REMOTE_SERVICE   325
#define IDS_SERVERTYPE6                 326
#define IDS_SERVICENAME                 327
#define IDS_PATH                        328
#define IDS_ATSTORAGE                   329
#define IDS_NOMATCH                     330
#define IDS_INVALIDSERVER               331
#define IDS_NOLOGON                     332
#define IDS_NOACCOUNT                   333
#define IDS_ADMINSONLY                  334
#define IDS_BLANKUSERNAME               335
#define IDS_BLANKPASSWORD               336
#define IDS_BITMAP1                     337
#define IDS_LocalService                338
#define IDS__LocalService               339
#define IDS_RemoteServerName            340
#define IDS_REBOOT                      341
#define IDS_ActivateAtStorage           342
#define IDS_RunAs                       343
#define IDS_InteractiveUser             344
#define IDS_AccessPermission            345
#define IDS_LaunchPermission            346
#define IDS_Y                           347
#define IDS_LocalServer32               348
#define IDS__LocalServer32              349
#define IDS_LocalServer                 350
#define IDS__LocalServer                351
#define IDS_CLSID                       352
#define IDS_AppID                       353
#define IDS_NULL                        354
#define IDS_The_CLSID_                  355
#define IDS_IMPERSONATION               356
#define IDS__item_                      357
#define IDS_ANONYMOUS2                  358
#define IDS_comma_and_title_            359
#define IDS_IDENTITY                    360
#define IDS__has_the_                   361
#define IDS_CLSID_                      362
#define IDS_DCOM_Configuration_Warning  363
#define IDS_SOFTWARE_Microsoft_OLE      367
#define IDS_Clsid2                      368
#define IDS_EnableDCOM                  369
#define IDS_LegacyAuthenticationLevel   370
#define IDS_LegacyImpersonationLevel    371
#define IDS_LegacySecureReferences      372
#define IDS_DefaultccessPermission      373
#define IDS_DefaultLaunchPermission     374
#define IDS_HKEY_CLASSES_ROOT           375
#define IDS_Allow_                      376
#define IDS_Deny                        377
#define IDS_Deny_                       378
#define IDS_Registry_value              379
#define IDS_Browse_for_users            380
#define IDS_SCM_                        381
#define IDS_The_security_               382
#define IDS_backslash                   383
#define IDS_Key_Read                    384
#define IDS_Query_Value                 385
#define IDS_Set_Value                   386
#define IDS_Create_Subkey               387
#define IDS_Enumerate_Subkeys           388
#define IDS_Notify                      389
#define IDS_Create_Link                 390
#define IDS_Delete                      391
#define IDS_Write_DAC                   392
#define IDS_Read_Control                393
#define IDS_Read                        394
#define IDS_Full_Control                395
#define IDS_Special_AccessDotDotDot     396
#define IDS_Registry_Key                397
#define IDS_Registry_Application        398
#define IDS_Write_Owner                 399
#define IDS_BADSD                       400
#define IDS_EFFECTIVE                   401
#define IDS_DYNAMIC                     402
#define IDS_NTMACHINENAME               403
#define IDS_SERVICENAME2                404
#define IDS_INETADDR                    405
#define IDS_INETPORT                    406
#define IDS_INTEGER255                  407
#define IDS_NTSERVER                    408
#define IDS_NAMEDPIPE                   409
#define IDS_INTEGER                     410
#define IDS_IPXINETADDR                 411
#define IDS_DECNET                      412
#define IDS_DECNETOBJECT                413
#define IDS_APPLETALK                   414
#define IDS_ATSTRING                    415
#define IDS_VINES                       416
#define IDS_VINESPORT                   417
#define IDS_DYNAMIC_INTERNET            418
#define IDS_DYNAMIC_INTRANET            419
#define IDS_EPDESC_NCACN_NB_TCP         420
#define IDS_EPDESC_NCACN_NB_IPX         421
#define IDS_EPDESC_NCACN_NB_NB          422
#define IDS_EPDESC_NCACN_IP_TCP         423
#define IDS_EPDESC_NCACN_NP             424
#define IDS_EPDESC_NCACN_SPX            425
#define IDS_EPDESC_NCACN_DNET_NSP       426
#define IDS_EPDESC_NCACN_AT_DSP         427
#define IDS_EPDESC_NCACN_VNNS_SPP       428
#define IDS_EPDESC_NCADG_IP_UDP         429
#define IDS_EPDESC_NCADG_IPX            430
#define IDS_EPDESC_NCALRPC              431
#define IDS_EPSTATIC                    432
#define IDS_INSTRUCTIONS_ADDPROTOCOL    433
#define IDS_CAPTION_ADDPROTOCOL         434
#define IDS_INSTRUCTIONS_UPDATEPROTOCOL 435
#define IDS_CAPTION_UPDATEPROTOCOL      436
#define IDS_EPDYNAMICINTRA              437
#define IDS_EPDYNAMICINTER              438
#define IDS_CANTCONVERT                 439
#define IDS_EPDESC_DEFAULT              440
#define IDS_DUPLICATE_PROTSEQ           441
#define IDS_EPDESC_NCACN_HTTP           442
#define IDS_ADDPORT_INSTRUCTIONS        443
#define IDS_INVALID_PORTRANGE           444
#define IDS_INSTRUCTIONS_PORTRANGES     445
#define IDS_BDCCONFIRM                  446
#define IDS_ERR_ENDPOINT                447
#define IDS_ALLOW_ACCESS                448
#define IDS_DENY_ACCESS                 449
#define IDS_ALLOW_LAUNCH                450
#define IDS_DENY_LAUNCH                 451
#define IDS_ALLOW_CONFIG                452
#define IDS_DENY_CONFIG                 453
#define IDS_SERVERTYPE_SURROGATE        454
#define IDS_SERVERTYPE_UNKNOWN          455
#define IDS_FATALOUTOFMEMORY            456
#define IDS_FATALOUTOFMEMORYTITLE       457
#define IDC_BUTTON1                     1000
#define IDC_EENDPOINT                   1001
#define IDC_CBPROTSEQ                   1002
#define IDC_LIST1                       1003
#define IDC_RADIO1                      1004
#define IDC_RADIO2                      1005
#define IDC_CHECK1                      1006
#define IDC_CHECK2                      1007
#define IDC_CHECK3                      1008
#define IDC_BUTTON2                     1009
#define IDC_EDIT1                       1010
#define IDC_BUTTON3                     1011
#define IDC_ASSIGN_RANGE_INTERNET       1012
#define IDC_RADIO3                      1015
#define IDC_CHKEFFECTIVE                1016
#define IDC_CHKDYNAMIC                  1017
#define IDC_LIST2                       1019
#define IDC_EDIT2                       1023
#define IDC_EDIT3                       1024
#define IDC_COMBO1                      1025
#define IDC_COMBO2                      1026
#define IDC_RADIO4                      1027
#define IDC_RADIO5                      1032
#define IDC_RADIO6                      1033
#define IDC_SERVERNAME                  1037
#define IDC_SERVERICON                  1038
#define IDC_SERVERTYPE                  1039
#define IDC_SERVERPATH                  1040
#define IDC_RUNNING                     1041
#define IDC_MACHINE                     1042
#define IDC_PATHTITLE                   1043
#define IDC_MACHINETITLE                1044
#define IDC_STATIC1                     1045
#define IDC_STATIC2                     1046
#define IDC_STATIC3                     1047
#define IDC_APPTYPE                     1048
#define IDC_APPNAME                     1049
#define IDC_LSTPROTSEQ                  1051
#define IDC_CMDADD                      1052
#define IDC_CMDREMOVE                   1053
#define IDC_CMDUPDATE                   1054
#define IDC_CMDCLEAR                    1055
#define IDC_SINSTRUCTIONS               1056
#define IDS_DESCRIPTION                 1057
#define IDC_SPROTSEQ                    1058
#define IDC_ENABLEINTERNET              1059
#define IDC_ALLOWINTERNET               1060
#define IDC_ALLOWACCESS                 1061
#define IDC_ALLOWLAUNCH                 1062
#define IDC_BTNADD                      1063
#define IDC_BTNREMOVEALL                1064
#define IDC_BTNREMOVE                   1065
#define IDC_DEFAULT_INTERNET            1066
#define IDC_DEFAULT_INTRANET            1067
#define IDC_PORTRANGE                   1068
#define IDC_CMDMOVEUP                   1069
#define IDC_CMDMOVEDOWN                 1070
#define IDC_ENETADDRESS                 1071
#define IDC_SDESCRIPTION                1072
#define IDC_EPSTATIC                    1073
#define IDC_EPDYNAMIC_DEFAULT           1074
#define IDC_EPDYNAMIC_INTRA             1075
#define IDC_EPDISABLE                   1076
#define IDC_ASSIGN_RANGE_INTRANET       1077
#define IDC_EPSTATICEP                  1078
#define IDC_EPDYNAMIC_INTER             1079
#define IDC_RIDENTIFICATION             1080
#define IDC_RANONYMOUS                  1081
#define IDC_RIMPERSONATION              1082

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        460
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1083
#define _APS_NEXT_SYMED_VALUE           600
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\stdafx.h ===
#if !defined(STDAFX_DCOMCNFG_INCLUDED)
#define STDAFX_DCOMCNFG_INCLUDED

//#define VC_EXTRALEAN      // Exclude rarely-used stuff from Windows headers

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#endif

//
// There is a conflict between ASSERT in the nt headers and ASSERT in the MFC headers.
// We'll just take the MFC one. 
//
#ifdef ASSERT
#undef ASSERT
#endif // ASSERT


#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#ifndef ASSERT
#error ole32\oleui\stdafx.h: ASSERT is not defined
#endif // !ASSERT

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include <iaccess.h>
#include "assert.h"
#include "resource.h"
#include "types.h"

#include "afxtempl.h"
#include "util.h"
#include "datapkt.h"
#include "virtreg.h"

#endif // !defined(STDAFX_DCOMCNFG_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  olecnfg.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\srvppg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       srvppg.cpp
//
//  Contents:   Implements the classes CServersPropertyPage,
//              CMachinePropertyPage and CDefaultSecurityPropertyPage to
//              manage the three property pages for top level info
//
//  Classes:
//
//  Methods:    CServersPropertyPage::CServersPropertyPage
//              CServersPropertyPage::~CServersPropertyPage
//              CServersPropertyPage::OnProperties
//              CServersPropertyPage::DoDataExchange
//              CServersPropertyPage::OnServerProperties
//              CServersPropertyPage::OnInitDialog
//              CServersPropertyPage::FetchAndDisplayClasses
//              CServersPropertyPage::OnList1
//              CServersPropertyPage::OnDoubleclickedList1
//              CServersPropertyPage::OnButton2
//              CMachinePropertyPage::CMachinePropertyPage
//              CMachinePropertyPage::~CMachinePropertyPage
//              CMachinePropertyPage::DoDataExchange
//              CMachinePropertyPage::OnInitDialog
//              CMachinePropertyPage::OnCombo1
//              CMachinePropertyPage::OnCheck1
//              CMachinePropertyPage::OnCheck2
//              CMachinePropertyPage::OnEditchangeCombo1
//              CMachinePropertyPage::OnSelchangeCombo1
//              CMachinePropertyPage::OnEditchangeCombo2
//              CMachinePropertyPage::OnSelchangeCombo2
//              CDefaultSecurityPropertyPage::CDefaultSecurityPropertyPage
//              CDefaultSecurityPropertyPage::~CDefaultSecurityPropertyPage
//              CDefaultSecurityPropertyPage::DoDataExchange
//              CDefaultSecurityPropertyPage::OnInitDialog
//              CDefaultSecurityPropertyPage::OnButton1
//              CDefaultSecurityPropertyPage::OnButton2
//              CDefaultSecurityPropertyPage::OnButton3
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "assert.h"
#include "resource.h"
#include "CStrings.h"
#include "CReg.h"
#include "types.h"
#include "SrvPPg.h"
#include "ClsPSht.h"
#include "newsrvr.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "virtreg.h"






#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CDefaultSecurityPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CServersPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CMachinePropertyPage, CPropertyPage)


// The globals used for communicating arguments between dialog classes
CUtility         g_util;
CVirtualRegistry g_virtreg;
HKEY             g_hAppid;
HKEY            *g_rghkCLSID;
unsigned         g_cCLSIDs;
TCHAR           *g_szAppTitle;
BOOL             g_fReboot = FALSE;
TCHAR           *g_szAppid;

/////////////////////////////////////////////////////////////////////////////
// CServersPropertyPage property page

CServersPropertyPage::CServersPropertyPage() : CPropertyPage(CServersPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CServersPropertyPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_fApplications   = TRUE;
}

CServersPropertyPage::~CServersPropertyPage()
{
}

void CServersPropertyPage::OnProperties()
{
    CClsidPropertySheet propSheet;
    SItem              *pItem;
    HKEY                hKey;
    HKEY               *phClsids;
    TCHAR               szBuf[128];

    // Get the selected item
    pItem = m_registry.GetItem((DWORD)m_classesLst.GetItemData(m_dwSelection));

    // Save the AppID
    g_szAppid = (TCHAR*)(LPCTSTR)pItem->szAppid;

    // Open the appid key
    _tcscpy(szBuf, TEXT("AppId\\"));
    _tcscat(szBuf, (LPCTSTR)(pItem->szAppid));
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szBuf, 0, KEY_ALL_ACCESS, &hKey)
        != ERROR_SUCCESS)
    {
        g_util.PostErrorMessage();
        return;
    }

    // Open a key for each clsid associated with this appid
    phClsids = new HKEY[pItem->ulClsids];
    if (phClsids == NULL)
    {
        g_util.PostErrorMessage();
        return;
    }
    for (UINT ul = 0; ul < pItem->ulClsids; ul++)
    {
        _tcscpy(szBuf, TEXT("ClsId\\"));
        _tcscat(szBuf, pItem->ppszClsids[ul]);
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szBuf, 0, KEY_ALL_ACCESS,
                         &phClsids[ul])
            != ERROR_SUCCESS)
        {
            g_util.PostErrorMessage();
            RegCloseKey(hKey);
            for (UINT ul2 = 0; ul2 < ul; ul2++)
            {
                RegCloseKey(phClsids[ul2]);
            }
            delete phClsids;
            return;
        }

    }

    if (propSheet.InitData(m_szSelection, hKey, phClsids, pItem->ulClsids))
    {
        propSheet.DoModal();
    }

    // This is where you would retrieve information from the property
    // sheet if propSheet.DoModal() returned IDOK.  We aren't doing
    // anything for simplicity.

    // Close the registry keys we opened for the ClsidPropertySheet
    RegCloseKey(hKey);
    for (ul = 0; ul < pItem->ulClsids; ul++)
    {
        RegCloseKey(phClsids[ul]);
    }
    delete phClsids;
}


void CServersPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServersPropertyPage)
    DDX_Control(pDX, IDC_LIST1, m_classesLst);
    //}}AFX_DATA_MAP

    GotoDlgCtrl(GetDlgItem(IDC_BUTTON1));
}


BEGIN_MESSAGE_MAP(CServersPropertyPage, CPropertyPage)
        //{{AFX_MSG_MAP(CServersPropertyPage)
        ON_BN_CLICKED(IDC_BUTTON1, OnServerProperties)
        ON_LBN_SELCHANGE(IDC_LIST1, OnList1)
        ON_LBN_DBLCLK(IDC_LIST1, OnDoubleclickedList1)
        ON_BN_CLICKED(IDC_BUTTON2,OnButton2)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()




void CServersPropertyPage::OnServerProperties()
{
    m_dwSelection = m_classesLst.GetCurSel();
    m_classesLst.GetText(m_dwSelection, m_szSelection);
    OnProperties();

}

BOOL CServersPropertyPage::OnInitDialog()
{
    // Disable property sheet help button
//    m_psp.dwFlags &= ~PSH_HASHELP;

    CPropertyPage::OnInitDialog();

    // Fetch and display the servers for the types specified
    FetchAndDisplayClasses();


    GotoDlgCtrl(GetDlgItem(IDC_BUTTON1));

    // Invoke the work-around to fix WM_HELP problem on subclassed controls
    g_util.FixHelp(this);

    return FALSE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}


void CServersPropertyPage::FetchAndDisplayClasses(void)
{
    // Collect applications
    m_registry.Init();

    //  Clear the list box
    m_classesLst.ResetContent();

    //  Store application names in the list box
    SItem *pItem;

    while (pItem = m_registry.GetNextItem())
    {
        if (!pItem->fDontDisplay)
        {
            if (!pItem->szTitle.IsEmpty())
            {
                m_classesLst.AddString(pItem->szTitle);
            }
            else if (!pItem->szItem.IsEmpty())
            {
                m_classesLst.AddString(pItem->szItem);
            }
            else
            {
                m_classesLst.AddString(pItem->szAppid);
            }
        }
    }

    // The list box sorted the items during the AddString's, so now we
    // have to associate each item with its index in CRegistry
    DWORD cbItems = m_registry.GetNumItems();

    for (DWORD k = 0; k < cbItems; k++)
    {
        SItem *pItem = m_registry.GetItem(k);
        int    iLBItem;

        if (pItem && !pItem->fDontDisplay)
        {
            if (!pItem->szTitle.IsEmpty())
            {
                iLBItem = m_classesLst.FindStringExact(-1, pItem->szTitle);
            }
            else if (!pItem->szItem.IsEmpty())
            {
                iLBItem = m_classesLst.FindStringExact(-1, pItem->szItem);
            }
            else
            {
                iLBItem = m_classesLst.FindStringExact(-1, pItem->szAppid);
            }
            m_classesLst.SetItemData(iLBItem, k);
        }
    }


    // Select the first item
    m_classesLst.SetCurSel(0);

    OnList1();

}



void CServersPropertyPage::OnList1()
{
    m_dwSelection = m_classesLst.GetCurSel();
    // enable or disable the properties button as necessary
    BOOL bEnableState = GetDlgItem(IDC_BUTTON1)->IsWindowEnabled();
    BOOL bNewEnableState = m_dwSelection != LB_ERR;
    if (bNewEnableState != bEnableState)
        GetDlgItem(IDC_BUTTON1)->EnableWindow(bNewEnableState);
    m_classesLst.GetText(m_dwSelection, m_szSelection);
}

void CServersPropertyPage::OnDoubleclickedList1()
{
    m_dwSelection = m_classesLst.GetCurSel();
    m_classesLst.GetText(m_dwSelection, m_szSelection);
    OnProperties();
}

void CServersPropertyPage::OnButton2()
{
    CNewServer newServerDialog;

    newServerDialog.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMachinePropertyPage property page

CMachinePropertyPage::CMachinePropertyPage() : CPropertyPage(CMachinePropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CMachinePropertyPage)
    //}}AFX_DATA_INIT

    m_fEnableDCOM = FALSE;
    m_fEnableDCOMIndex = -1;
    m_fEnableDCOMHTTP = FALSE;
    m_fEnableDCOMHTTPIndex = -1;
    m_fEnableRpcProxy = FALSE;
    m_fOriginalEnableRpcProxy = FALSE;
    m_fEnableRpcProxyIndex = -1;


    m_authLevel = Connect;
    m_authLevelIndex = -1;
    m_impersonateLevel = Identify;
    m_impersonateLevelIndex = -1;
    m_fLegacySecureReferences = FALSE;
    m_fLegacySecureReferencesIndex = -1;
}



CMachinePropertyPage::~CMachinePropertyPage()
{
}



void CMachinePropertyPage::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CMachinePropertyPage)
        DDX_Control(pDX, IDC_ENABLEINTERNET, m_EnableDCOMInternet);
        DDX_Control(pDX, IDC_CHECK2, m_legacySecureReferencesChk);
        DDX_Control(pDX, IDC_CHECK1, m_EnableDCOMChk);
        DDX_Control(pDX, IDC_COMBO2, m_impersonateLevelCBox);
        DDX_Control(pDX, IDC_COMBO1, m_authLevelCBox);
    //}}AFX_DATA_MAP
}




BEGIN_MESSAGE_MAP(CMachinePropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CMachinePropertyPage)
        ON_BN_CLICKED(IDC_COMBO1, OnCombo1)
        ON_BN_CLICKED(IDC_CHECK1, OnCheck1)
        ON_BN_CLICKED(IDC_CHECK2, OnCheck2)
        ON_CBN_EDITCHANGE(IDC_COMBO1, OnEditchangeCombo1)
        ON_CBN_EDITCHANGE(IDC_COMBO2, OnEditchangeCombo2)
        ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchangeCombo1)
        ON_CBN_SELCHANGE(IDC_COMBO2, OnSelchangeCombo2)
        ON_WM_HELPINFO()
        ON_BN_CLICKED(IDC_ENABLEINTERNET, OnChkEnableInternet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




BOOL CMachinePropertyPage::OnInitDialog()
{
    int iIndex;

    // Disable property sheet help button
//    m_psp.dwFlags &= ~PSH_HASHELP;

    CPropertyPage::OnInitDialog();

    // Populate the authentication combo boxe
    CString sTemp;

    m_authLevelCBox.ResetContent();

    // Associate values with entries
    sTemp.LoadString(IDS_DEFAULT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Defaultx);

    sTemp.LoadString(IDS_NONE);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, None);

    sTemp.LoadString(IDS_CONNECT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Connect);

    sTemp.LoadString(IDS_CALL);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Call);

    sTemp.LoadString(IDS_PACKET);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Packet);

    sTemp.LoadString(IDS_PACKETINTEGRITY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketIntegrity);

    sTemp.LoadString(IDS_PACKETPRIVACY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketPrivacy);


    // Populate the impersonation level combo box
    m_impersonateLevelCBox.ResetContent();

    // Associate values with entries
    sTemp.LoadString(IDS_ANONYMOUS);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Anonymous);

    sTemp.LoadString(IDS_IDENTIFY);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Identify);

    sTemp.LoadString(IDS_IMPERSONATE);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Impersonate);

    sTemp.LoadString(IDS_DELEGATE);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Delegate);


    // Set defaults
    // EnableDCOM is unchecked initially
    m_authLevelCBox.SetCurSel(Connect);
    m_impersonateLevelCBox.SetCurSel(Identify);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.EnableDCOM
    int err;

    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("EnableDCOM"),
                                        &m_fEnableDCOMIndex);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_fEnableDCOMIndex);
        CString sTmp = pCdp->Value();

        if (sTmp[0] == TEXT('y')  ||
            sTmp[0] == TEXT('Y'))
        {
            m_fEnableDCOM = TRUE;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.EnableInternetDCOM
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("EnableDCOMHTTP"),
                                        &m_fEnableDCOMHTTPIndex);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_fEnableDCOMHTTPIndex);
        CString sTmp = pCdp->Value();

        if  (m_fEnableDCOM &&
            ((sTmp[0] == TEXT('y'))  ||
            (sTmp[0] == TEXT('Y'))))
        {
            m_fEnableDCOMHTTP = TRUE;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Rpc\RpcProxy\Enabled
    err = g_virtreg.ReadRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\Rpc\\RpcProxy"),
                                        TEXT("Enabled"),
                                        &m_fEnableRpcProxyIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = (CDataPacket*)g_virtreg.GetAt(m_fEnableRpcProxyIndex);
        DWORD dwTmp = pCdp -> GetDwordValue();

        if (dwTmp)
        {
            m_fEnableRpcProxy = TRUE;
            m_fOriginalEnableRpcProxy = TRUE;
        }
    }
    else if ((err != ERROR_ACCESS_DENIED)  &&  (err != ERROR_FILE_NOT_FOUND))
    {
        g_util.PostErrorMessage();
    }

    // enable proxy if dcomhttp is enabled
    if (m_fEnableDCOMHTTP)
    {
        m_fEnableRpcProxy = TRUE;
        if (m_fEnableRpcProxyIndex == -1)
        {
            g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                            TEXT("SOFTWARE\\Microsoft\\Rpc\\RpcProxy"),
                                            TEXT("Enabled"),
                                            1,
                                            &m_fEnableRpcProxyIndex);
        }
        // Else simply update it in the virtual registry
        else
        {
            g_virtreg.ChgRegDwordNamedValue(m_fEnableRpcProxyIndex,1);
        }
    }


    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacyAuthenticationLevel
    err = g_virtreg.ReadRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                                           TEXT("LegacyAuthenticationLevel"),
                                           &m_authLevelIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_authLevelIndex);

        m_authLevel = (AUTHENTICATIONLEVEL) pCdp->GetDwordValue();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacyImpersonationLevel
    err = g_virtreg.ReadRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                                           TEXT("LegacyImpersonationLevel"),
                                           &m_impersonateLevelIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_impersonateLevelIndex);

        m_impersonateLevel = (IMPERSONATIONLEVEL) pCdp->GetDwordValue();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacySecureReferences
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("LegacySecureReferences"),
                                        &m_fLegacySecureReferencesIndex );
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_fLegacySecureReferencesIndex);
        CString sTmp = pCdp->Value();

        if (sTmp[0] == TEXT('y')  ||
            sTmp[0] == TEXT('Y'))
        {
            m_fLegacySecureReferences = TRUE;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }


    // Set the controls according to the current values

    // EnableDCOM
    if (m_fEnableDCOM)
    {
        m_EnableDCOMChk.SetCheck(1);
        GetDlgItem(IDC_COMBO1)->EnableWindow(TRUE);
        GetDlgItem(IDC_COMBO2)->EnableWindow(TRUE);
        GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
        GetDlgItem(IDC_ENABLEINTERNET)->EnableWindow(TRUE);
    }
    else
    {
        m_EnableDCOMChk.SetCheck(0);
        GetDlgItem(IDC_ENABLEINTERNET)->EnableWindow(FALSE);
    }

    m_EnableDCOMInternet.SetCheck(m_fEnableDCOMHTTP);


    // AuthenticationLevel
    for (int k = 0; k < m_authLevelCBox.GetCount(); k++)
    {
        if (((AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(k)) ==
             m_authLevel)
        {
            m_authLevelCBox.SetCurSel(k);
            break;
        }
    }

    // ImpersonationLevel
    for (k = 0; k < m_impersonateLevelCBox.GetCount(); k++)
    {
        if (((AUTHENTICATIONLEVEL) m_impersonateLevelCBox.GetItemData(k)) ==
             m_impersonateLevel)
        {
            m_impersonateLevelCBox.SetCurSel(k);
            break;
        }
    }

    // LegacySecureReferences
    if (m_fLegacySecureReferences)
    {
        m_legacySecureReferencesChk.SetCheck(1);
    }
    else
    {
        m_legacySecureReferencesChk.SetCheck(0);
    }

    // Invoke the work-around to fix WM_HELP problem on subclassed controls
    g_util.FixHelp(this);

    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}




void CMachinePropertyPage::OnCombo1()
{
    m_authLevelCBox.ShowDropDown(TRUE);

}



void CMachinePropertyPage::OnCheck1()
{
    // Flip the EnableDCOM flag
    m_fEnableDCOM ^= 1;

    //  Disable or enable the other dialog controls:
    GetDlgItem(IDC_COMBO1)->EnableWindow(m_fEnableDCOM);
    GetDlgItem(IDC_COMBO2)->EnableWindow(m_fEnableDCOM);
    GetDlgItem(IDC_CHECK2)->EnableWindow(m_fEnableDCOM);
    GetDlgItem(IDC_ENABLEINTERNET)->EnableWindow(m_fEnableDCOM);

    // Virtually write it to the registry
    if (m_fEnableDCOMIndex == -1)
    {
        g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                     TEXT("SOFTWARE\\Microsoft\\OLE"),
                                     TEXT("EnableDCOM"),
                                     m_fEnableDCOM ? _T("Y") : _T("N"),
                                     &m_fEnableDCOMIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegSzNamedValue(m_fEnableDCOMIndex,
                                     m_fEnableDCOM ? _T("Y") : _T("N"));
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}

void CMachinePropertyPage::OnChkEnableInternet()
{
    // Flip the EnableDCOM flag
    m_fEnableDCOMHTTP ^= 1;

    // if Com Internet services are enable then enable proxy
    // otherwise set it to its original value in case non DCOM RPC application is using it
    if (m_fEnableDCOMHTTP)
        m_fEnableRpcProxy = TRUE;
    else
        m_fEnableRpcProxy = m_fOriginalEnableRpcProxy;

    // Virtually write it to the registry
    if (m_fEnableDCOMHTTPIndex == -1)
    {
        g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                     TEXT("SOFTWARE\\Microsoft\\OLE"),
                                     TEXT("EnableDCOMHTTP"),
                                     m_fEnableDCOMHTTP ? _T("Y") : _T("N"),
                                     &m_fEnableDCOMHTTPIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegSzNamedValue(m_fEnableDCOMHTTPIndex,
                                     m_fEnableDCOMHTTP ? _T("Y") : _T("N"));
    }

    if (m_fEnableRpcProxyIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Rpc\\RpcProxy"),
                    TEXT("Enabled"),
                    m_fEnableRpcProxy ? 1 : 0,
                    &m_fEnableRpcProxyIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_fEnableRpcProxyIndex,
                                     m_fEnableRpcProxy ? 1 : 0);
    }


    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}


void CMachinePropertyPage::OnCheck2()
{

    // Flip LegacySecureeferences flag
    m_fLegacySecureReferences ^= 1;

    // Virtually write it to the registry
    if (m_fLegacySecureReferencesIndex == -1)
    {
        g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                     TEXT("SOFTWARE\\Microsoft\\OLE"),
                                     TEXT("LegacySecureReferences"),
                                     m_fLegacySecureReferences ? _T("Y")
                                      : _T("N"),
                                     &m_fLegacySecureReferencesIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegSzNamedValue(m_fLegacySecureReferencesIndex,
                                     m_fLegacySecureReferences ? _T("Y") : _T("N"));
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}



void CMachinePropertyPage::OnEditchangeCombo1()
{
}


void CMachinePropertyPage::OnSelchangeCombo1()
{
    int iSel;

    // Get the new selection
    iSel = m_authLevelCBox.GetCurSel();
    m_authLevel = (AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(iSel);

    // Virtually write it to the registry
    if (m_authLevelIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("LegacyAuthenticationLevel"),
                                        m_authLevel,
                                        &m_authLevelIndex);
    }
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_authLevelIndex,
                                        m_authLevel);
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);

}



void CMachinePropertyPage::OnEditchangeCombo2()
{
}





void CMachinePropertyPage::OnSelchangeCombo2()
{
    int iSel;

    // Get the new selection
    iSel = m_impersonateLevelCBox.GetCurSel();
    m_impersonateLevel =
        (IMPERSONATIONLEVEL) m_impersonateLevelCBox.GetItemData(iSel);

    // Virtually write it to the registry
    if (m_impersonateLevelIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("LegacyImpersonationLevel"),
                                        m_impersonateLevel,
                                        &m_impersonateLevelIndex);
    }
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_impersonateLevelIndex,
                                        m_impersonateLevel);
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}






/////////////////////////////////////////////////////////////////////////////
// CDefaultSecurityPropertyPage property page

CDefaultSecurityPropertyPage::CDefaultSecurityPropertyPage() : CPropertyPage(CDefaultSecurityPropertyPage::IDD)
{
        //{{AFX_DATA_INIT(CDefaultSecurityPropertyPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_accessPermissionIndex        = -1;
    m_launchPermissionIndex        = -1;
    m_configurationPermissionIndex = -1;
    m_fAccessChecked               = FALSE;
}



CDefaultSecurityPropertyPage::~CDefaultSecurityPropertyPage()
{
}



void CDefaultSecurityPropertyPage::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDefaultSecurityPropertyPage)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDefaultSecurityPropertyPage, CPropertyPage)
        //{{AFX_MSG_MAP(CDefaultSecurityPropertyPage)
        ON_BN_CLICKED(IDC_BUTTON1, OnButton1)
        ON_BN_CLICKED(IDC_BUTTON2, OnButton2)
        ON_BN_CLICKED(IDC_BUTTON3, OnButton3)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()



// Default access permissions
BOOL CDefaultSecurityPropertyPage::OnInitDialog(void)
{
    BOOL fPostMsg = FALSE;

    // Disable property sheet help button
//    m_psp.dwFlags &= ~PSH_HASHELP;

    if (!m_fAccessChecked)
    {

        // Check whether we are denied access to
        // HKEY_LOCAL_MACHINE
        if (!g_util.CkAccessRights(HKEY_LOCAL_MACHINE, NULL))
        {
            GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
            fPostMsg = TRUE;
        }

        // Post a message to the user
        if (fPostMsg)
        {
            CString sMsg;
            CString sCaption;

            sMsg.LoadString(IDS_ACCESSDENIED);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(sMsg, sCaption, MB_OK);
        }
    }

    m_fAccessChecked = TRUE;
    return TRUE;
}



// Default access permissions
void CDefaultSecurityPropertyPage::OnButton1()
{
    int     err;
    
    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           HKEY_LOCAL_MACHINE,
                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                           TEXT("DefaultAccessPermission"),
                           &m_accessPermissionIndex,
                           SingleACL,
                           dcomAclAccess);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
    {
        // This is a reboot event
        g_fReboot = TRUE;

        SetModified(TRUE);
    }
}


// Default launch permissions
void CDefaultSecurityPropertyPage::OnButton2()
{
    int     err;

    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           HKEY_LOCAL_MACHINE,
                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                           TEXT("DefaultLaunchPermission"),
                           &m_launchPermissionIndex,
                           SingleACL,
                           dcomAclLaunch);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
    {
        // This is a reboot event
        g_fReboot = TRUE;

        SetModified(TRUE);
    }

}


// Default configuration permissions
void CDefaultSecurityPropertyPage::OnButton3()
{
    int     err;

    err = g_util.ACLEditor2(m_hWnd,
                            HKEY_CLASSES_ROOT,
                            NULL,
                            0,
                            NULL,
                           &m_configurationPermissionIndex,
                            RegKeyACL);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
}

BOOL CDefaultSecurityPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CDefaultSecurityPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }

    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }

    return CPropertyPage::OnHelpInfo(pHelpInfo);
}



BOOL CMachinePropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CMachinePropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }

    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}



BOOL CServersPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CServersPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }

    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\srvppg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       srvppg.h
//
//  Contents:   Defines the classes CServersPropertyPage,
//              CMachinePropertyPage and CDefaultSecurityPropertyPage to
//              manage the three property pages for top level info
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef __SRVPPG_H__
#define __SRVPPG_H__


/////////////////////////////////////////////////////////////////////////////
// CServersPropertyPage dialog

class CServersPropertyPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CServersPropertyPage)

// Construction
public:
        CServersPropertyPage();
        ~CServersPropertyPage();
void OnProperties();
void FetchAndDisplayClasses();


// Dialog Data
        //{{AFX_DATA(CServersPropertyPage)
        enum { IDD = IDD_PROPPAGE1 };
        CListBox        m_classesLst;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CServersPropertyPage)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual BOOL OnInitDialog();

        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CServersPropertyPage)
        afx_msg void OnServerProperties();
        afx_msg void OnList1();
        afx_msg void OnDoubleclickedList1();
        afx_msg void OnButton2();
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

private:
        CRegistry m_registry;
        BOOL      m_fApplications;
        DWORD     m_dwSelection;
        TCHAR     m_szSelection[MAX_PATH];

};


/////////////////////////////////////////////////////////////////////////////
// CMachinePropertyPage dialog

class CMachinePropertyPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CMachinePropertyPage)

        // Construction
public:
        CMachinePropertyPage();
        ~CMachinePropertyPage();
    
        // Dialog Data
        //{{AFX_DATA(CMachinePropertyPage)
        enum { IDD = IDD_PROPPAGE2 };
        CButton m_EnableDCOMInternet;
        CButton m_legacySecureReferencesChk;
        CButton m_EnableDCOMChk;
        CComboBox       m_impersonateLevelCBox;
        CComboBox       m_authLevelCBox;
    //}}AFX_DATA


        // Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CMachinePropertyPage)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual BOOL OnInitDialog();
        //}}AFX_VIRTUAL

        // Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CMachinePropertyPage)
        afx_msg void OnCombo1();
        afx_msg void OnCheck1();
        afx_msg void OnCheck2();
        afx_msg void OnEditchangeCombo1();
        afx_msg void OnEditchangeCombo2();
        afx_msg void OnSelchangeCombo1();
        afx_msg void OnSelchangeCombo2();
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        afx_msg void OnChkEnableInternet();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

private:
        AUTHENTICATIONLEVEL m_authLevel;
        int                 m_authLevelIndex;
        IMPERSONATIONLEVEL  m_impersonateLevel;
        int                 m_impersonateLevelIndex;
        BOOL                m_fEnableDCOM;
        int                 m_fEnableDCOMIndex;
        BOOL                m_fLegacySecureReferences;
        int                 m_fLegacySecureReferencesIndex;
        BOOL                m_fEnableDCOMHTTP;
        int                 m_fEnableDCOMHTTPIndex;
        BOOL                m_fEnableRpcProxy;
        BOOL                m_fOriginalEnableRpcProxy;
        int                 m_fEnableRpcProxyIndex;

};


/////////////////////////////////////////////////////////////////////////////
// CDefaultSecurityPropertyPage dialog

class CDefaultSecurityPropertyPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CDefaultSecurityPropertyPage)

// Construction
public:
        CDefaultSecurityPropertyPage();
        ~CDefaultSecurityPropertyPage();

// Dialog Data
        //{{AFX_DATA(CDefaultSecurityPropertyPage)
        enum { IDD = IDD_PROPPAGE4 };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CDefaultSecurityPropertyPage)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual BOOL OnInitDialog();
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CDefaultSecurityPropertyPage)
        afx_msg void OnButton1();
        afx_msg void OnButton2();
        afx_msg void OnButton3();
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

private:
        int  m_accessPermissionIndex;
        int  m_launchPermissionIndex;
        int  m_configurationPermissionIndex;
        BOOL m_fAccessChecked;
};




#endif // __SRVPPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\types.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       types.h
//
//  Contents:   Defines a few generic types
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------
#ifndef __DCOMCNFG_TYPES_H__
#define __DCOMCNFG_TYPES_H__

// Note. These values are derived from rpcdce.h
typedef enum tagAUTHENTICATIONLEVEL
 {Defaultx=0, None=1, Connect=2, Call=3, Packet=4, PacketIntegrity=5,
  PacketPrivacy=6} AUTHENTICATIONLEVEL;

typedef enum tagIMPERSONATIONLEVEL
 {Anonymous=1, Identify=2, Impersonate=3, Delegate=4} IMPERSONATIONLEVEL;


#define GUIDSTR_MAX 38



// These are help ID's for the "Help" button in the various dialogs
// in the ACL editor
#define IDH_REGISTRY_VALUE_PERMISSIONS       1
#define IDH_ADD_USERS_AND_GROUPS             2
#define IDH_LOCAL_GROUP_MEMBERSHIP           3
#define IDH_GLOBAL_GROUP_MEMBERSHIP          4
#define IDH_FIND_ACCOUNT1                    5
#define IDH_REGISTRY_APPLICATION_PERMISSIONS 6
#define IDH_REGISTRY_KEY_PERMISSIONS         7
#define IDH_SPECIAL_ACCESS_GLOBAL            8
#define IDH_SPECIAL_ACCESS_PER_APPID         9
#define IDH_SELECT_DOMAIN                    10
#define IDH_BROWSE_FOR_USERS                 11
#define IDH_FIND_ACCOUNT2                    14  // == IDH_BROWSE_FOR_USERS + 3
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\util.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       util.cpp
//
//  Contents:   Implements the utility class CUtility
//
//  Classes:
//
//  Methods:    CUtility::CkForAccessDenied
//              CUtility::CkAccessRights
//              CUtility::PostErrorMessage (x2)
//              CUtility::WriteRegSzNamedValue
//              CUtility::WriteRegDwordNamedValue
//              CUtility::WriteRegSingleACL
//              CUtility::WriteRegKeyACL
//              CUtility::WriteRegKeyACL2
//              CUtility::WriteLsaPassword
//              CUtility::DeleteRegKey
//              CUtility::DeleteRegValue
//              CUtility::WriteSrvIdentity
//              CUtility::ACLEditor
//              CUtility::ACLEditor2
//              CUtility::InvokeUserBrowser
//              CUtility::InvokeMachineBrowser
//              CUtility::StringFromGUID
//              CUtility::IsEqualGuid
//              CUtility::AdjustPrivilege
//              CUtility::VerifyRemoteMachine
//              CUtility::RetrieveUserPassword
//              CUtility::StoreUserPassword
//              CUtility::LookupProcessInfo
//              CUtility::MakeSecDesc
//              CUtility::CheckForValidSD
//              CUtility::SDisIAC
//              CUtility::CheckSDForCOM_RIGHTS_EXECUTE
//              CUtility::ChangeService
//              CUtility::UpdateDCOMInfo(void)
//              CUtility::FixHelp
//              CUtility::CopySD
//              CUtility::SetInheritanceFlags
//
// Functons:    callBackFunc
//              ControlFixProc
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "assert.h"
#include "resource.h"
#include "afxtempl.h"
#include "types.h"
#include "datapkt.h"
#include "clspsht.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "virtreg.h"

extern "C"
{
#if !defined(STANDALONE_BUILD)
#include <ntlsa.h>
#include <ntseapi.h>
#include <sedapi.h>
#endif

#include <winnetwk.h>

#if !defined(STANDALONE_BUILD)
#include <uiexport.h>
#include <lm.h>
#endif

#include <rpc.h>
#include <rpcdce.h>
#include <aclapi.h>
}

#include <objsel.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const IID IID_IAccessControl = {0xEEDD23E0,0x8410,0x11CE,{0xA1,0xC3,0x08,0x00,0x2B,0x2B,0x8D,0x8F}};

static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";

static const DWORD SIZEOF_SID        = 44;

// This leaves space for 2 access allowed ACEs in the ACL.
const DWORD SIZEOF_ACL        = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) +
                                2 * SIZEOF_SID;

static const DWORD SIZEOF_TOKEN_USER = sizeof(TOKEN_USER) + SIZEOF_SID;

static const SID   LOCAL_SYSTEM_SID  = {SID_REVISION, 1, {0,0,0,0,0,5},
                                 SECURITY_LOCAL_SYSTEM_RID };

static const DWORD NUM_SEC_PKG       = 8;




// These are required for the method CUtility::UpdateDCOMInfo which invokes
// an RPC proxy which expects the following


extern "C" void * _stdcall MIDL_user_allocate(size_t size)
{
    return new BYTE[size];
}


extern "C" void _stdcall MIDL_user_free(void *p)
{
    delete p;
}

CUtility::CUtility(void)
{
    HRESULT hr = OleInitialize(NULL);
    m_bCheckedDC = NULL;    // have we checked if we're on a BDC yet ?
    m_bIsBdc = FALSE;
    m_pszDomainController = NULL;
}



CUtility::~CUtility(void)
{
#if !defined(STANDALONE_BUILD)
    if (m_pszDomainController) 
        NetApiBufferFree(m_pszDomainController);
#endif

    OleUninitialize();
}



void CUtility::CkForAccessDenied(int err)
{
    if (err == ERROR_ACCESS_DENIED)
    {
        CString sMsg;
        CString sCaption;
        sMsg.LoadString(IDS_ACCESSDENIED);
        sCaption.LoadString(IDS_SYSTEMMESSAGE);
        MessageBox(NULL, sMsg, sCaption, MB_OK);
    }
}



BOOL CUtility::CkAccessRights(HKEY hRoot, LPCTSTR szKeyPath)
{
    int                  err;
    HKEY                 hKey = NULL;
    BYTE                 aSid[256];
    DWORD                cbSid = 256;
    PSECURITY_DESCRIPTOR pSid = (PSECURITY_DESCRIPTOR) aSid;
    BOOL                 fFreePsid = FALSE;


    // Open the specified key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

    // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return TRUE;
    }

    if (err == ERROR_SUCCESS)
    {
        // Fetch the security descriptor on this key
        err = RegGetKeySecurity(hKey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                (PSECURITY_DESCRIPTOR) aSid,
                                &cbSid);
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSid = (PSECURITY_DESCRIPTOR) malloc(cbSid);
            if (pSid == NULL)
            {
                if (hKey != hRoot)
                {
                    RegCloseKey(hKey);
                }
                return FALSE;
            }
            fFreePsid = TRUE;
            err = RegGetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    (PSECURITY_DESCRIPTOR) pSid,
                                    &cbSid);
        }

        // We've read the security descriptor - now try to write it
        if (err == ERROR_SUCCESS)
        {
            err = RegSetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    pSid);
        }

        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
    }

    if (fFreePsid)
    {
        free(pSid);
    }
	
    return err == ERROR_SUCCESS ? TRUE : FALSE;
}






void CUtility::PostErrorMessage(void)
{
    TCHAR szMessage[256];

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                  0, szMessage, sizeof(szMessage) / sizeof(TCHAR), NULL);
    CString sCaption;
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    MessageBox(NULL, szMessage, sCaption, MB_OK);
}






void CUtility::PostErrorMessage(int err)
{
    TCHAR szMessage[256];

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
                  0, szMessage, sizeof(szMessage) / sizeof(TCHAR), NULL);
    CString sCaption;
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    MessageBox(NULL, szMessage, sCaption, MB_OK);
}




// Write a named string value to the registry
int CUtility::WriteRegSzNamedValue(HKEY   hRoot,
                                   LPCTSTR szKeyPath,
                                   LPCTSTR szValueName,
                                   LPCTSTR szVal,
                                   DWORD  dwSize)
{
    int  err;
    HKEY hKey;
    ULONG lSize;

    // Open the key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

        // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        DWORD dwDisp;
        err = RegCreateKeyEx(hRoot, 
                             szKeyPath,
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisp);
    }

    if (err != ERROR_SUCCESS)
        return err;

    // Attempt to write the named value
    lSize = _tcslen(szVal) + 1;
    err = RegSetValueEx(hKey, szValueName, NULL, REG_SZ, (BYTE *) szVal, lSize*sizeof(TCHAR));
    if (hKey != hRoot)
        RegCloseKey(hKey);
    return err;
}

// Write a named multi string value to the registry
int CUtility::WriteRegMultiSzNamedValue(HKEY   hRoot,
                                   LPCTSTR szKeyPath,
                                   LPCTSTR szValueName,
                                   LPCTSTR szVal,
                                   DWORD  dwSize)
{
    int  err = ERROR_SUCCESS;
    HKEY hKey;

    // Open the key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

        // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        DWORD dwDisp;
        err = RegCreateKeyEx(hRoot, 
                             szKeyPath,
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisp);
    }

    if (err != ERROR_SUCCESS)
        return err;

    // Attempt to write the named value
    err = RegSetValueEx(hKey, szValueName, NULL, REG_MULTI_SZ, (BYTE *) szVal, dwSize*sizeof(TCHAR) );

    if (hKey != hRoot)
        RegCloseKey(hKey);
    return err;
}






// Write a named DWORD value to the registry
int CUtility::WriteRegDwordNamedValue(HKEY   hRoot,
                                      LPCTSTR szKeyPath,
                                      LPCTSTR szValueName,
                                      DWORD  dwVal)
{
    int  err;
    HKEY hKey;

    // Open the key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

    // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        DWORD dwDisp;
        err = RegCreateKeyEx(hRoot, 
                             szKeyPath,
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisp);
    }

    if (err != ERROR_SUCCESS)
        return err;


    // Attempt to write the named value
    if (RegSetValueEx(hKey, szValueName, NULL, REG_DWORD, (BYTE *) &dwVal,
                      sizeof(DWORD))
        != ERROR_SUCCESS)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return GetLastError();
    }

    // Return the value
    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    return ERROR_SUCCESS;
}



// Write an ACL as a registry named value
int CUtility::WriteRegSingleACL(HKEY   hRoot,
                                LPCTSTR szKeyPath,
                                LPCTSTR szValueName,
                                PSECURITY_DESCRIPTOR pSec)
{
    int                   err;
    HKEY                  hKey = hRoot;
    PSrSecurityDescriptor pSrSec;
    PSrAcl                pDacl;

    // Open the key unless the key path is NULL
    if (szKeyPath)
    {
        if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey))
            != ERROR_SUCCESS)
        {
            return err;
        }
    }

    ULONG cbLen;
    BOOL fIsIAC = SDisIAC((SECURITY_DESCRIPTOR * )pSec);
    // If there are no ACE's and this is DefaultAccessPermission, then
    // interpret this as activator access only which we indicate by
    // removing the named value
    if (!fIsIAC)
    {
        pSrSec = (PSrSecurityDescriptor) pSec;
        pDacl = (PSrAcl) (((BYTE *) pSec) + (pSrSec->Dacl));
        if (_tcscmp(szValueName, TEXT("DefaultAccessPermission")) == 0  &&
            pDacl->AceCount == 0)
        {
            err = RegDeleteValue(hKey, szValueName);
            return err;
        }
        cbLen = RtlLengthSecurityDescriptor(pSec);
    }
    else
    {
        cbLen = (ULONG) GlobalSize(pSec);
    }
    // Else write the ACL simply as a REG_SZ value
    err = RegSetValueEx(hKey,
                        szValueName,
                        0,
                        REG_BINARY,
                        (BYTE *) pSec,
                        cbLen);

    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    return err;
}



// Write an ACL on a registry key
int CUtility::WriteRegKeyACL(HKEY   hKey,
                             HKEY  *phClsids,
                             unsigned cClsids,
                             PSECURITY_DESCRIPTOR pSec,
                             PSECURITY_DESCRIPTOR pSecOrig)
{
    int err;

    // The logic is somewhat different depending on whether we're starting
    // with HKEY_CLASSES_ROOT or a specific AppID
    if (hKey == HKEY_CLASSES_ROOT)
    {
        return WriteRegKeyACL2(hKey, hKey, pSec, pSecOrig);
    }

    // It's a specific AppID
    else
    {
        // Write the security on the AppID key
        if (err = RegSetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    pSec) != ERROR_SUCCESS)
        {
            return err;
        }

        // Iterate over the CLSID's covered by this AppID and recursively
        // write security on them and their subkeys
        for (UINT k = 0; k < cClsids; k++)
        {
            if (err = WriteRegKeyACL2(phClsids[k], phClsids[k], pSec, pSecOrig)
                != ERROR_SUCCESS)
            {
                return err;
            }
        }
    }
    return ERROR_SUCCESS;
}



// Write an ACL recursively on a registry key provided the current
// security descriptor on the key is the same as the passed in
// original security descriptor
int CUtility::WriteRegKeyACL2(HKEY                 hRoot,
                              HKEY                 hKey,
                              PSECURITY_DESCRIPTOR pSec,
                              PSECURITY_DESCRIPTOR pSecOrig)
{
    BYTE                 aCurrSD[256] = {0};
    DWORD                cbCurrSD = 256;
    PSECURITY_DESCRIPTOR pCurrSD = (PSECURITY_DESCRIPTOR) aCurrSD;
    BOOL                 fFreePCurrSD = FALSE;
    int                  err;
    BOOL                 fProceed;

    // Read the current security descriptor on this key
    err = RegGetKeySecurity(hKey,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            aCurrSD,
                            &cbCurrSD);
    if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
    {
        pCurrSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbCurrSD);
        if (pCurrSD == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        fFreePCurrSD = TRUE;
    }
    else if (err != ERROR_SUCCESS)
    {
        return err;
    }
    if ((err = RegGetKeySecurity(hKey,
                                 OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 DACL_SECURITY_INFORMATION,
                                 pCurrSD,
                                 &cbCurrSD)
         != ERROR_SUCCESS))
    {
        if (fFreePCurrSD)
        {
            GlobalFree(pCurrSD);
        }
        return err;
    }

    // Only proceed down this subtree if the current SD and the
    // original SD are the same
    fProceed = CompareSDs((PSrSecurityDescriptor) pCurrSD,
                          (PSrSecurityDescriptor) pSecOrig);

    // We're done with the current security descriptor
    if (fFreePCurrSD)
    {
        GlobalFree(pCurrSD);
    }

    if (!fProceed)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return ERROR_SUCCESS;
    }

    // Write the top level ACL
    err = RegSetKeySecurity(hKey,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pSec);

    // Now enumerate the subkeys and write ACL's on them
    DWORD iSubKey;
    TCHAR szSubKeyName[128];
    HKEY  hKey2;

    iSubKey = 0;

    while (err == ERROR_SUCCESS)
    {
        // Enumerate the next key
        err = RegEnumKey(hKey, iSubKey, szSubKeyName, 128);
        if (err != ERROR_SUCCESS)
        {
            break;
        }

        // Prepare for the next key
        iSubKey++;

        // Open this subkey and recursively write the ACL on it and
        // all of its subkeys
        if (RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_ALL_ACCESS, &hKey2)
            == ERROR_SUCCESS)
        {
            err = WriteRegKeyACL2(hRoot, hKey2, pSec, pSecOrig);
        }
    }

    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }
    return err == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : err;
}




// Write a user's password to the private LSA database
int CUtility::WriteLsaPassword(CLSID appid, LPCTSTR szPassword)
{
    return ERROR_SUCCESS;
}



int CUtility::DeleteRegKey(HKEY hRoot, LPCTSTR szKeyPath)
{
    return RegDeleteKey(hRoot, szKeyPath);
}



int CUtility::DeleteRegValue(HKEY hRoot, LPCTSTR szKeyPath, LPCTSTR szValueName)
{
    int  err;
    HKEY hKey;

    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS)
    {
        err = RegDeleteValue(hKey, szValueName);
        if (hRoot != hKey)
            RegCloseKey(hKey);
    }

    return err;
}



// Change the identity under which a service runs
int CUtility::WriteSrvIdentity(LPCTSTR szService, LPCTSTR szIdentity)
{
    return ERROR_SUCCESS;
}

DWORD __stdcall callBackFunc(HWND                 hwndParent,
                             HANDLE               hInstance,
                             ULONG_PTR            CallBackContext,
                             PSECURITY_DESCRIPTOR SecDesc,
                             PSECURITY_DESCRIPTOR SecDescNewObjects,
                             BOOLEAN              ApplyToSubContainers,
                             BOOLEAN              ApplyToSubObjects,
                             LPDWORD              StatusReturn)
{
    int err = ERROR_SUCCESS;
    PCallBackContext pCallBackContext = (PCallBackContext) CallBackContext;

    SECURITY_DESCRIPTOR* pSD = (SECURITY_DESCRIPTOR*) SecDesc;
    SECURITY_DESCRIPTOR_RELATIVE* pSDr = (SECURITY_DESCRIPTOR_RELATIVE*) SecDesc;

    PSrAcl                pDacl;
    PSrAce                pAce;
    DWORD                 cbAces;

    // Check whether the security descriptor is self-relative
    if (!(pSD->Control & SE_SELF_RELATIVE))
    {
        pDacl = (PSrAcl) pSD->Dacl;
    }
    else
    {
        pDacl = (PSrAcl) (((BYTE *) pSDr) + (pSDr->Dacl));
    }
    if (pDacl)
    {	
    	// Do over the ACE's
	    for (pAce = (PSrAce) (((BYTE *) pDacl) + sizeof(SSrAcl)),
         	cbAces = pDacl->AceCount;cbAces;
	        pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize),cbAces--)
    	{
                if (pAce->Type == 1  &&  pAce->AccessMask == GENERIC_ALL)
                {
                        pAce->AccessMask = COM_RIGHTS_EXECUTE;
                }
        }
    }


    // Set the inheritance flags on the new security descriptor
    if (pCallBackContext->pktType == RegKeyACL)
    {
        g_util.SetInheritanceFlags((SECURITY_DESCRIPTOR *) SecDesc);
    }

    if (pCallBackContext->fIsIAC)
    {
        // try to convert to a serialized IAccessControl
        SECURITY_DESCRIPTOR * pNewSD = g_util.IACfromSD((SECURITY_DESCRIPTOR *)SecDesc);
        if (pNewSD)
        {
            SecDesc = pNewSD;
        }
        else
        {
            pCallBackContext->fIsIAC = FALSE; // failed so treat it as if it is an old-style SD
            CString sMsg;
            CString sCaption;
            sMsg.LoadString(IDS_CANTCONVERT);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(NULL, sMsg, sCaption, MB_OK);
        }
    }
    else
    {
        SECURITY_DESCRIPTOR * pNewSD;
        // just copy the security descriptor to get it into Global Memory        
        if (!g_util.CopySD((SECURITY_DESCRIPTOR *)SecDesc, &pNewSD))
        {
            *StatusReturn = ERROR_OUTOFMEMORY;	
            return ERROR_OUTOFMEMORY;
        }
        SecDesc = pNewSD;
    }

    // Write the new or modified security descriptor
    if (*pCallBackContext->pIndex == -1)
    {
        if (pCallBackContext->pktType == SingleACL)
        {
            err = g_virtreg.NewRegSingleACL(
                    pCallBackContext->info.single.hRoot,
                    pCallBackContext->info.single.szKeyPath,
                    pCallBackContext->info.single.szValueName,
                    (SECURITY_DESCRIPTOR *) SecDesc,
                    pCallBackContext->fIsIAC,   // If it's an IAC then it's already SELF-RELATIVE
                    pCallBackContext->pIndex);
        }
        else
        {
            err = g_virtreg.NewRegKeyACL(
                    pCallBackContext->info.regKey.hKey,
                    pCallBackContext->info.regKey.phClsids,
                    pCallBackContext->info.regKey.cClsids,
                    pCallBackContext->info.regKey.szTitle,
                    pCallBackContext->origSD,
                    (SECURITY_DESCRIPTOR *) SecDesc,
                    pCallBackContext->fIsIAC,   // If it's an IAC then it's already SELF-RELATIVE
                    pCallBackContext->pIndex);
        }
    }
    else
    {
        g_virtreg.ChgRegACL(*pCallBackContext->pIndex,
                            (SECURITY_DESCRIPTOR *) SecDesc,
                            pCallBackContext->fIsIAC);  // If it's an IAC then it's already SELF-RELATIVE
    }

    *StatusReturn = err;
    return err;
}


// Invoke the ACL editor on the specified named value.  This method
// writes an ACL data packet to the virtual registry.  This method is for
// Access and Launch security only (pktType SingleACL).
int CUtility::ACLEditor(HWND       hWnd,
                        HKEY       hRoot,
                        LPCTSTR    szKeyPath,
                        LPCTSTR    szValueName,
                        int       *pIndex,
                        PACKETTYPE pktType,
                        dcomAclType eAclType)
{
#if !defined(STANDALONE_BUILD)
    int                  err;
    HKEY                 hKey;
    BYTE                 aSD[128];
    DWORD                cbSD = 128;
    DWORD                dwType;
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *) aSD;
    BOOL                 fFreePSD = FALSE;
    SID                 *pSid;
    TCHAR                szAllow[32];
    TCHAR                szDeny[32];
    CString              szAllow_;
    CString              szDeny_;

    // Build the allow and deny strings
	switch (eAclType)
	{
	case dcomAclAccess:
		szAllow_.LoadString(IDS_ALLOW_ACCESS);
		szDeny_.LoadString(IDS_DENY_ACCESS);
		break;

	case dcomAclLaunch:
		szAllow_.LoadString(IDS_ALLOW_LAUNCH);
		szDeny_.LoadString(IDS_DENY_LAUNCH);
		break;

	case dcomAclConfig:
		szAllow_.LoadString(IDS_ALLOW_CONFIG);
		szDeny_.LoadString(IDS_DENY_CONFIG);
		break;
	}

    _tcscpy(szAllow, (LPCTSTR) szAllow_);
    _tcscpy(szDeny, (LPCTSTR) szDeny_);

    // Fetch the current SD, either from the registry, by default if the
    // named value doesn't exist or from the virtual registry
    if (*pIndex == -1)
    {
        // Open the specified key
        if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0,
                                KEY_ALL_ACCESS, &hKey))
            != ERROR_SUCCESS)
        {
            return err;
        }

        // Attempt to read the specified named value
        err = RegQueryValueEx(hKey, szValueName, 0, &dwType, (BYTE *) aSD,
                              &cbSD);

        if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbSD);
            if (pSD == NULL)
            {
                RegCloseKey(hKey);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            fFreePSD = TRUE;
            err = RegQueryValueEx(hKey, szValueName, 0, &dwType,
                                  (BYTE *) pSD, &cbSD);
        }
        // The named valued doesn't exist.  If this is
        // \\HKEY_CLASSES_ROOT\...
        // then use the default named value if it exists
        else if (err != ERROR_SUCCESS)
        {
            if (hRoot != HKEY_LOCAL_MACHINE)
            {
                RegCloseKey(hKey);
                if (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       TEXT("SOFTWARE\\Microsoft\\OLE"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKey)
                    != ERROR_SUCCESS)
                {
                    return err;
                }

                // Attempt to read the specified named value
                TCHAR szDefault[32];

                _tcscpy(szDefault, TEXT("Default"));
                _tcscat(szDefault, szValueName);
                err = RegQueryValueEx(hKey, szDefault, 0, &dwType,
                                      (BYTE *) aSD, &cbSD);
                if (err == ERROR_MORE_DATA)
                {
                    pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbSD);
                    if (pSD == NULL)
                    {
                        RegCloseKey(hKey);
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                    fFreePSD = TRUE;
                    err = RegQueryValueEx(hKey, szDefault, 0, &dwType,
                                          (BYTE *) pSD, &cbSD);
                }
            }
        }

        RegCloseKey(hKey);

        // If still don't have an SD, then simply create one
        if (err != ERROR_SUCCESS)
        {
            if (!g_util.LookupProcessInfo(&pSid, NULL))
            {
                return GetLastError();
            }
            if (!g_util.MakeSecDesc(pSid, &pSD))
            {
                delete pSid;
                return GetLastError();
            }
            fFreePSD = TRUE;
        }
    }

    // Fetch the most recently edited SD
    else
    {
        CDataPacket *pCdp = g_virtreg.GetAt(*pIndex);

        pSD = pCdp -> pkt.acl.pSec;
    }


    // Initialize the callback context
    m_sCallBackContext.pktType = pktType;
    m_sCallBackContext.pIndex = pIndex;
    m_sCallBackContext.origSD = pSD;
    m_sCallBackContext.info.single.hRoot = hRoot;
    m_sCallBackContext.info.single.szKeyPath = (TCHAR*)szKeyPath;
    m_sCallBackContext.info.single.szValueName = (TCHAR*)szValueName;

    // Invoke the ACL editor
    DWORD                       dwStatus;
    GENERIC_MAPPING             genericMapping;
    CString                     szObjectType;

    szObjectType.LoadString(IDS_Registry_value);

    SED_HELP_INFO   helpInfo =
        {
            TEXT("dcomcnfg.hlp"),
            {HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG}
        };

    SED_OBJECT_TYPE_DESCRIPTOR  objTyp =
            {1,                                // Revision
             FALSE,                            // Is container?
             FALSE,                            // Allow new object perms?
             FALSE,                            // Specific to generic?
             &genericMapping,                  // Generic mapping
             NULL,                             // Generic mapping new
             (TCHAR *) ((LPCTSTR) szObjectType), // Object type name
             &helpInfo,                        // Help info
             TEXT(""),                         // Ckbox title
             TEXT(""),                         // Apply title
             TEXT(""),                         //
             NULL,                             // Special object access
             NULL                              // New special object access
            };

    SED_APPLICATION_ACCESS      appAccess[] =
            {{SED_DESC_TYPE_RESOURCE, COM_RIGHTS_EXECUTE, 0, szAllow},
             {SED_DESC_TYPE_RESOURCE, 0, 0, szDeny}};

    SED_APPLICATION_ACCESSES    appAccesses =
            {2,              // Count of access groups
             appAccess,      // Access array
             szAllow         // Default access name
            };

    // Intialize the help contexts
    helpInfo.aulHelpContext[HC_MAIN_DLG] =
        IDH_REGISTRY_VALUE_PERMISSIONS;
    helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
        IDH_SPECIAL_ACCESS_GLOBAL;
    helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
        IDH_SPECIAL_ACCESS_GLOBAL;
    helpInfo.aulHelpContext[HC_ADD_USER_DLG] =
        IDH_ADD_USERS_AND_GROUPS;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
        IDH_LOCAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
        IDH_GLOBAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
        IDH_FIND_ACCOUNT1;

    genericMapping.GenericRead    = GENERIC_ALL;
    genericMapping.GenericWrite   = GENERIC_ALL;
    genericMapping.GenericExecute = GENERIC_ALL;
    genericMapping.GenericAll     = GENERIC_ALL;

    if (!CheckForValidSD(pSD))
    {
        // make a valid security descriptor so we can continue
        if (!g_util.LookupProcessInfo(&pSid, NULL))
        {
            return GetLastError();
        }
        if (!g_util.MakeSecDesc(pSid, &pSD))
        {
            delete pSid;
            return GetLastError();
        }
        fFreePSD = TRUE;
    }
    m_sCallBackContext.fIsIAC = SDisIAC(pSD);
    if (m_sCallBackContext.fIsIAC)
    {
        // convert to a true security descriptor
        SECURITY_DESCRIPTOR * pNewSD = SDfromIAC(pSD);
        if (!pNewSD)
        {
            // failed so pop up an error box
            CString sMsg, sCaption;
            sMsg.LoadString(IDS_BADSD);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(NULL, sMsg, sCaption, MB_OK);
            // make a valid security descriptor so we can continue
            if (!g_util.LookupProcessInfo(&pSid, NULL))
            {
                return GetLastError();
            }
            if (!g_util.MakeSecDesc(pSid, &pNewSD))
            {
                delete pSid;
                return GetLastError();
            }
        }
        if (fFreePSD)
        {
            GlobalFree(pSD);
        }
        pSD=pNewSD;
        fFreePSD = TRUE;
    }

    // If this is for Access or Launch permissons then check that the
    // SD contains only allows and deny's for COM_RIGHTS_EXECUTE
    if (!CheckSDForCOM_RIGHTS_EXECUTE(pSD))
    {
        return IDCANCEL;
    }
    // Invoke the ACL editor
    SedDiscretionaryAclEditor(hWnd,              // Owner hWnd
                              GetModuleHandle(NULL), // Owner hInstance
                              NULL,              // Server
                              &objTyp,           // ObjectTyp,
                              &appAccesses,      // Application accesses
                              (TCHAR*)szValueName,       // Object name,
                              callBackFunc, // Callback function
                              (ULONG_PTR) &m_sCallBackContext, // Callback context
                              pSD,              // Security descriptor,
                              FALSE,             // Couldnt read Dacl,
                              FALSE,             // Can't write Dacl,
                              &dwStatus,         // SED status return,
                              0);                // Flags

    // Check status return
    if (dwStatus != ERROR_SUCCESS)
    {
//        PostErrorMessage(dwStatus);
    }

    // We're done
    if (fFreePSD)
    {
        GlobalFree(pSD);
    }

    return dwStatus == 0 ? ERROR_SUCCESS : IDCANCEL;
#else
    return IDCANCEL;
#endif
}





// Invoke the ACL editor on the specified key.  This method writes an ACL
// data packet to the virtual registry.  This method supports configuration
// security only (pktType RegKeyACL).
int CUtility::ACLEditor2(HWND       hWnd,
                         HKEY       hKey,
                         HKEY      *phClsids,
                         unsigned   cClsids,
                         TCHAR     *szTitle,
                         int       *pIndex,
                         PACKETTYPE pktType)
{
#if !defined(STANDALONE_BUILD)
    int                  err;
    BYTE                 aSD[128];
    DWORD                cbSD = 128;
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *) aSD;
    BOOL                 fFreePSD = FALSE;
    TCHAR                szKeyRead[32];
    CString              szKeyRead_;
    TCHAR                szHkeyClassesRoot[32];
    CString              szHkeyClassesRoot_;


    // Initialize strings
    szKeyRead_.LoadString(IDS_Key_Read);
    _tcscpy(szKeyRead, (LPCTSTR) szKeyRead_);
    szHkeyClassesRoot_.LoadString(IDS_HKEY_CLASSES_ROOT);
    _tcscpy(szHkeyClassesRoot, (LPCTSTR) szHkeyClassesRoot_);

    if (*pIndex == -1)
    {
        // Read the security descriptor on this key
        err = RegGetKeySecurity(hKey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                aSD,
                                &cbSD);
        if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbSD);
            if (pSD == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            fFreePSD = TRUE;
        }
        else if (err != ERROR_SUCCESS)
        {
            return err;
        }
        if ((err = RegGetKeySecurity(hKey,
                                     OWNER_SECURITY_INFORMATION |
                                     GROUP_SECURITY_INFORMATION |
                                     DACL_SECURITY_INFORMATION,
                                     pSD,
                                     &cbSD)
             != ERROR_SUCCESS))
        {
            if (fFreePSD)
            {
                GlobalFree(pSD);
            }
            return err;
        }
    }

    // Fetch the most recently edited SD
    else
    {
        CDataPacket *pCdp = g_virtreg.GetAt(*pIndex);

        pSD = pCdp -> pkt.racl.pSec;
    }


    // Initialize the callback context
    m_sCallBackContext.pktType = pktType;
    m_sCallBackContext.pIndex = pIndex;
    m_sCallBackContext.origSD = pSD;
    m_sCallBackContext.info.regKey.hKey = hKey;
    m_sCallBackContext.info.regKey.phClsids = phClsids;
    m_sCallBackContext.info.regKey.cClsids = cClsids;
    m_sCallBackContext.info.regKey.szTitle = szTitle;

    // Invoke the ACL editor
    DWORD                       dwStatus;
    GENERIC_MAPPING             genericMapping;

    CString                     szObjectType;
    szObjectType.LoadString(IDS_Registry_Key);
    CString szQueryValue;
    szQueryValue.LoadString(IDS_Query_Value);
    CString szSetValue;
    szSetValue.LoadString(IDS_Set_Value);
    CString szCreateSubkeys;
    szCreateSubkeys.LoadString(IDS_Create_Subkey);
    CString szEnumerateSubkeys;
    szEnumerateSubkeys.LoadString(IDS_Enumerate_Subkeys);
    CString szNotify;
    szNotify.LoadString(IDS_Notify);
    CString szCreateLink;
    szCreateLink.LoadString(IDS_Create_Link);
    CString szDelete;
    szDelete.LoadString(IDS_Delete);
    CString szWriteDAC;
    szWriteDAC.LoadString(IDS_Write_DAC);
    CString szWriteOwner;
    szWriteOwner.LoadString(IDS_Write_Owner);
    CString szReadControl;
    szReadControl.LoadString(IDS_Read_Control);
    CString szRead;
    szRead.LoadString(IDS_Read);
    CString szFullControl;
    szFullControl.LoadString(IDS_Full_Control);
    CString szSpecialAccess;
    szSpecialAccess.LoadString(IDS_Special_AccessDotDotDot);


    SED_HELP_INFO               helpInfo =
    {
        TEXT("dcomcnfg.hlp"),
        {HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG}
    };

    SED_OBJECT_TYPE_DESCRIPTOR  objTyp =
            {SED_REVISION1,                    // Revision
             FALSE,                            // Is container?
             FALSE,                            // Allow new object perms?
             FALSE,                            // Specific to generic?
             &genericMapping,                  // Generic mapping
             NULL,                             // Generic mapping new
             (TCHAR *) ((LPCTSTR) szObjectType), // Object type name
             &helpInfo,                        // Help info
             TEXT(""),                         // Ckbox title
             TEXT(""),                         // Apply title
             TEXT(""),                         //
             (TCHAR *) ((LPCTSTR) szSpecialAccess), // Special Access menu item
             NULL                              // New special object access
            };


    SED_APPLICATION_ACCESS      appAccess[] =
    {
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_QUERY_VALUE,        0,
           (TCHAR *) ((LPCTSTR) szQueryValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_SET_VALUE,          0,
           (TCHAR *) ((LPCTSTR) szSetValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_SUB_KEY,     0,
           (TCHAR *) ((LPCTSTR) szCreateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_ENUMERATE_SUB_KEYS, 0,
           (TCHAR *) ((LPCTSTR) szEnumerateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_NOTIFY,             0,
           (TCHAR *) ((LPCTSTR) szNotify) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_LINK,        0,
           (TCHAR *) ((LPCTSTR) szCreateLink) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, 0x00010000, /* DELETE, */ 0,
           (TCHAR *) ((LPCTSTR) szDelete) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_DAC,              0,
           (TCHAR *) ((LPCTSTR) szWriteDAC) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_OWNER,            0,
           (TCHAR *) ((LPCTSTR) szWriteOwner) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, READ_CONTROL,           0,
           (TCHAR *) ((LPCTSTR) szReadControl) },
        { SED_DESC_TYPE_RESOURCE,         KEY_READ,               0,
           (TCHAR *) ((LPCTSTR) szRead) },
        { SED_DESC_TYPE_RESOURCE,         GENERIC_ALL, /* KEY_ALL_ACCESS, */ 0,
           (TCHAR *) ((LPCTSTR) szFullControl) }
    };

    SED_APPLICATION_ACCESSES    appAccesses =
        {12,              // Count of access groups
         appAccess,       // Access array
         szKeyRead        // Default access name
        };

    // Intialize the help contexts
    helpInfo.aulHelpContext[HC_MAIN_DLG] =
        IDH_REGISTRY_KEY_PERMISSIONS;
    if (hKey == HKEY_CLASSES_ROOT)
    {
        helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_GLOBAL;
        helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_GLOBAL;
    }
    else
    {
        helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_PER_APPID;
        helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_PER_APPID;
    }

    helpInfo.aulHelpContext[HC_ADD_USER_DLG] =
        IDH_ADD_USERS_AND_GROUPS;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
        IDH_LOCAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
        IDH_GLOBAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
        IDH_FIND_ACCOUNT1;

    genericMapping.GenericRead    = KEY_READ;
    genericMapping.GenericWrite   = KEY_WRITE;
    genericMapping.GenericExecute = KEY_READ;
    genericMapping.GenericAll     = KEY_ALL_ACCESS;

    if (!CheckForValidSD(pSD))
    {
        return IDCANCEL;
    }
    m_sCallBackContext.fIsIAC = SDisIAC(pSD);
    if (m_sCallBackContext.fIsIAC)
    {
        // convert to a true security descriptor
        SECURITY_DESCRIPTOR * pNewSD = SDfromIAC(pSD);
        if (!pNewSD)
        {
            // failed so pop up an error box
            CString sMsg, sCaption;
            sMsg.LoadString(IDS_BADSD);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(NULL, sMsg, sCaption, MB_OK);
            return IDCANCEL;
        }
        if (fFreePSD)
        {
            GlobalFree(pSD);
        }
        pSD=pNewSD;
        fFreePSD = TRUE;
    }

    // Invoke the ACL editor
    SedDiscretionaryAclEditor(hWnd,              // Owner hWnd
                              GetModuleHandle(NULL), // Owner hInstance
                              NULL,              // Server
                              &objTyp,           // ObjectTyp,
                              &appAccesses,      // Application accesses
                              szTitle ? szTitle : szHkeyClassesRoot,// Object name,
                              callBackFunc, // Callback function
                              (ULONG_PTR) &m_sCallBackContext, // Callback context
                              pSD,              // Security descriptor,
                              FALSE,             // Couldnt read Dacl,
                              FALSE,             // Can't write Dacl,
                              &dwStatus,         // SED status return,
                              0);                // Flags

    // Check status return
    if (dwStatus != ERROR_SUCCESS)
    {
//        PostErrorMessage(dwStatus);
    }

    // We're done
    if (fFreePSD)
    {
        GlobalFree(pSD);
    }

    return dwStatus == 0 ? ERROR_SUCCESS : IDCANCEL;
#else
    return IDCANCEL;
#endif
}




BOOL CUtility::InvokeUserBrowser(HWND hWnd, TCHAR *szUser)
{
    BOOL             fRet = FALSE;
#if !defined(STANDALONE_BUILD)
    CString          szTitle;

    szTitle.LoadString(IDS_Browse_for_users);

    IDsObjectPicker *pDsObjectPicker = NULL;

    
    HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_IDsObjectPicker, 
                                  (void**)&pDsObjectPicker);
    if (SUCCEEDED(hr))
    {
        IDataObject *pDataObject = NULL;
        
        // Fill in the structures necessary to init the dialog.
        DSOP_SCOPE_INIT_INFO rgInitInfo[2];

        ZeroMemory(rgInitInfo, sizeof(rgInitInfo));
        
        rgInitInfo[0].cbSize  = sizeof(DSOP_SCOPE_INIT_INFO);
        rgInitInfo[0].flType  = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
        rgInitInfo[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE | 
                                DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
        rgInitInfo[0].FilterFlags.flDownlevel         = DSOP_DOWNLEVEL_FILTER_USERS;
        rgInitInfo[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

        rgInitInfo[1].cbSize  = sizeof(DSOP_SCOPE_INIT_INFO);
        rgInitInfo[1].flType  = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN |
                                DSOP_SCOPE_TYPE_GLOBAL_CATALOG |
                                DSOP_SCOPE_TYPE_WORKGROUP |
                                DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE |
                                DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE |
                                DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
                                DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
        rgInitInfo[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
        rgInitInfo[1].FilterFlags.flDownlevel         = DSOP_DOWNLEVEL_FILTER_USERS;
        rgInitInfo[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

        DSOP_INIT_INFO dsInitInfo = { sizeof(dsInitInfo) };        
        dsInitInfo.aDsScopeInfos = rgInitInfo;
        dsInitInfo.cDsScopeInfos = sizeof(rgInitInfo) / sizeof(rgInitInfo[0]);

        hr = pDsObjectPicker->Initialize(&dsInitInfo);
        if (SUCCEEDED(hr))
        {
            hr = pDsObjectPicker->InvokeDialog(hWnd, &pDataObject);
        }

        // Yes, I mean S_OK.  The return code is S_FALSE if the user hits CANCEL.
        if (hr == S_OK)
        {
            // Why, yes, this DOES _s_u_c_k_!
            CLIPFORMAT cfDsObjectPicker = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
            STGMEDIUM stgMed = { TYMED_HGLOBAL, 
                                 NULL, 
                                 NULL };
            FORMATETC fmtEtc = { cfDsObjectPicker, 
                                 NULL, 
                                 DVASPECT_CONTENT, 
                                 -1, 
                                 TYMED_HGLOBAL };
            
            hr = pDataObject->GetData(&fmtEtc, &stgMed);
            if (SUCCEEDED(hr))
            {
                PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(stgMed.hGlobal);

                // Only care about the first item (should be single select, see above).
                assert(pSelList->cItems <= 1);

                PWSTR pwszName   = NULL;
                PWSTR pwszDomain = NULL;
                PWSTR pwszPath = pSelList->aDsSelection[0].pwzADsPath;
                if (pwszPath && pwszPath[0])
                {
                    // e.g. "WinNT://REDMOND/johndoty"
                    pwszName = wcsrchr(pwszPath, L'/');
                    assert(pwszName != NULL);
                    if (pwszName == NULL)
                        pwszName = pwszPath;
                    
                    *pwszName = L'\0';
                    
                    pwszDomain = wcsrchr(pwszPath, L'/');
                    assert(pwszDomain != NULL);
                    if (pwszDomain == NULL)
                        pwszDomain = pwszPath;
                    else
                        pwszDomain++;
                    
                    pwszName++;
                }
                else
                {
                    // e.g. "Everyone"
                    pwszName = pSelList->aDsSelection[0].pwzName;
                }
                
                if (pwszName && pwszName[0])
                {
                    // Text buffer has already been allocated (*gulp*)
                    CString szBackslash;
                    szBackslash.LoadString(IDS_backslash);
                    
                    if (pwszDomain)
                        _tcscpy(szUser, pwszDomain);
                    else
                        szUser[0] = L'\0';
                    _tcscat(szUser, (LPCTSTR) szBackslash);
                    _tcscat(szUser, pwszName);
                    
                    fRet = TRUE;
                }

                ::GlobalUnlock(stgMed.hGlobal);
                ReleaseStgMedium(&stgMed);
            }
            
            pDataObject->Release();
        }
        
        pDsObjectPicker->Release();
    }
    
#endif
    
    return fRet;
}







BOOL CUtility::InvokeMachineBrowser(TCHAR *szMachine)
{
#if !defined(STANDALONE_BUILD)
    ///////////////////////////////////////////////////
   // If we end up not wanting to use I_SystemFocusDialog, then the code below
   // is the start for fetching machine resources ourselves
/*
    DWORD       dwErr;
    NETRESOURCE aNetResource[1000];
    HANDLE      hNetwork;
    DWORD       dwEntries = 100;
    DWORD       dwBufSize =  sizeof(aNetResource);

    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         0,
                         NULL,
                         &hNetwork);

    if (dwErr == NO_ERROR)
    {
        dwEntries = 0xffffffff;
        dwErr = WNetEnumResource(hNetwork,
                                 &dwEntries,
                                 aNetResource,
                                 &dwBufSize);
    }

    WNetCloseEnum(hNetwork);

    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         0,
                         aNetResource,
                         &hNetwork);

    if (dwErr == NO_ERROR)
    {
        dwEntries = 0xffffffff;
        dwErr = WNetEnumResource(hNetwork,
                                 &dwEntries,
                                 &aNetResource[1],
                                 &dwBufSize);
    }


    return dwErr == NO_ERROR ? TRUE : FALSE;
*/
///////////////////////////////////////////////////////




    UINT  err;
    BOOL  fOkPressed = FALSE;

    err = I_SystemFocusDialog(GetForegroundWindow(),
//                              FOCUSDLG_BROWSE_LOGON_DOMAIN |
//                              FOCUSDLG_BROWSE_WKSTA_DOMAIN,
                              0x30003,
                              szMachine,
                              128,
                              &fOkPressed,
                              TEXT("dcomcnfg.hlp"),
                              IDH_SELECT_DOMAIN);

    if (err == ERROR_SUCCESS  &&  fOkPressed)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
#else
    return FALSE;
#endif
}





int CUtility::StringFromGUID(GUID &rguid, TCHAR *lpsz, int cbMax)
{
    int i;
    LPWSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = L'{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }
    *p++ = L'}';
    *p   = L'\0';

    return GUIDSTR_MAX;
}




BOOL  CUtility::IsEqualGuid(GUID &guid1, GUID &guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}



BOOL CUtility::AdjustPrivilege(TCHAR *szPrivilege)
{
    HANDLE           hProcessToken = 0;
    BOOL             bOK = FALSE;
    TOKEN_PRIVILEGES privileges;

    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                           &hProcessToken ) )
    {
        return FALSE;
    }

    privileges.PrivilegeCount = 1;
    privileges.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;
    if( !LookupPrivilegeValue(NULL, szPrivilege,
                              &privileges.Privileges[ 0 ].Luid ) )
    {
        return FALSE;
    }

    if( !AdjustTokenPrivileges( hProcessToken, FALSE,
                                &privileges,
                                0L, NULL, NULL ) )
    {
        return FALSE;
    }

    if( hProcessToken )
    {
        CloseHandle( hProcessToken );
    }

    return TRUE;
}



BOOL CUtility::VerifyRemoteMachine(TCHAR *szRemoteMachine)
{
    NETRESOURCE sResource;
    NETRESOURCE sResource2;
    DWORD       dwErr;
    HANDLE      hEnum;
    DWORD       cbEntries;
    DWORD       cbBfr;

    // TODO: Get this function to work.  Right now WNetEnumResource is
    // screwing up the stack, causing an AV and anyway returns the error
    // ERROR_NO_MORE_ITEMS which I don't understand.
    //
    // Also, it is not clear that we should verify the remote machine name.
    // It may have different formats, e.g. IP address or a URL specification.
    // It may not even be on an NT network.  In any case it may be offline
    // currently.
    return TRUE;

    sResource.dwScope       = RESOURCE_GLOBALNET;
    sResource.dwType        = RESOURCETYPE_ANY;
    sResource.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    sResource.dwUsage       = RESOURCEUSAGE_CONTAINER;
    sResource.lpLocalName   = NULL;
    sResource.lpRemoteName  = szRemoteMachine;
    sResource.lpComment     = NULL;
    sResource.lpProvider    = NULL;



    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         RESOURCEUSAGE_CONTAINER,
                         &sResource,
                         &hEnum);

    if (dwErr == NO_ERROR)
    {
        cbEntries = 1;
        cbBfr = sizeof(NETRESOURCE);
        dwErr = WNetEnumResource(hEnum, &cbEntries, &sResource2, &cbBfr);
    }

    CloseHandle(hEnum);

    return TRUE;

}




BOOL CUtility::RetrieveUserPassword(TCHAR *szAppid, CString &sPassword)
{
#if !defined(STANDALONE_BUILD)
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    PLSA_UNICODE_STRING   psPassword;
    TCHAR                 szKey[4 + GUIDSTR_MAX + 1];

    // Formulate the access key
    if (_tcslen(szAppid) > GUIDSTR_MAX)
        return FALSE;
    
    _tcscpy(szKey, TEXT("SCM:"));
    _tcscat(szKey, szAppid);

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (_tcslen(szKey) + 1) * sizeof(TCHAR);
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(TCHAR);
    sKey.Buffer              = szKey;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return FALSE;
    }

    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return FALSE;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // Possible for LsaRetrievePrivateData to return success but with a NULL
    // psPassword.   If this happens we fail.
    if (!psPassword)
    {
        return FALSE;
    }

    // Copy the password
    sPassword = psPassword->Buffer;

    // Clear and free lsa's buffer
    SecureZeroMemory(psPassword->Buffer, psPassword->Length);
    LsaFreeMemory( psPassword );

    return TRUE;
#else
    return FALSE;
#endif
}





BOOL CUtility::StoreUserPassword(TCHAR *szAppid, CString &szPassword)
{
#if !defined(STANDALONE_BUILD)
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    LSA_UNICODE_STRING    sPassword;
    TCHAR                 szKey[4 + GUIDSTR_MAX + 1];

    // Formulate the access key
    if (_tcslen(szAppid) > GUIDSTR_MAX)
        return FALSE;
    
    _tcscpy(szKey, TEXT("SCM:"));
    _tcscat(szKey, szAppid);

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (_tcslen(szKey) + 1) * sizeof(TCHAR);
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(TCHAR);
    sKey.Buffer              = szKey;

    // Make the password a UNICODE string
    sPassword.Length = (_tcslen(LPCTSTR(szPassword)) + 1) * sizeof(TCHAR);
    sPassword.Buffer = (TCHAR *) LPCTSTR(szPassword);
    sPassword.MaximumLength = sPassword.Length;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_CREATE_SECRET, &hPolicy)))
    {
        return FALSE;
    }

    // Store the user's password
    if (!NT_SUCCESS(LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        g_util.PostErrorMessage();
        LsaClose(hPolicy);
        return FALSE;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    return TRUE;
#else
    return FALSE;
#endif
}






BOOL CUtility::LookupProcessInfo(SID **ppSid, TCHAR **ppszPrincName)
{
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lIgnore;
    DWORD              lSidLen;
    DWORD              lNameLen    = 0;
    DWORD              lDomainLen  = 0;
    TCHAR             *pDomainName = NULL;
    SID_NAME_USE       sIgnore;

    if (ppszPrincName != NULL)
        *ppszPrincName = NULL;

    // Open the process's token.
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        // Lookup SID of process token.
        if (GetTokenInformation( hToken, TokenUser, pTokenUser,
                                 sizeof(aMemory), &lIgnore ))
        {
            // Allocate memory to hold the SID.
            lSidLen = GetLengthSid( pTokenUser->User.Sid );
            *ppSid = (SID *) new BYTE[lSidLen];
            if (*ppSid == NULL)
            {
                return FALSE;
            }
            memcpy(*ppSid, pTokenUser->User.Sid, lSidLen);

            // Stop now if the caller doesn't want the user name.
            if (ppszPrincName != NULL)
            {
                // Find out how much memory to allocate for the name.
                LookupAccountSid(NULL, pTokenUser->User.Sid, NULL, &lNameLen,
                                 NULL, &lDomainLen, NULL );
                if (lNameLen != 0)
                {
                    // Allocate memory for the user's name.
                    *ppszPrincName =
                        (TCHAR *) new BYTE[lNameLen*sizeof(TCHAR)];
                    if (ppszPrincName == NULL)
                    {
                        CloseHandle( hToken );
                        return FALSE;
                    }
                    pDomainName = (TCHAR *) new BYTE[lDomainLen*sizeof(TCHAR)];
                    if (pDomainName == NULL)
                    {
                        delete ppszPrincName;
                        CloseHandle( hToken );
                        return FALSE;
                    }

                    // Find the user's name.
                    if (!LookupAccountSid( NULL, pTokenUser->User.Sid,
                                           *ppszPrincName, &lNameLen,
                                           pDomainName,
                                           &lDomainLen, &sIgnore))
                    {
                        delete ppszPrincName;
                        delete pDomainName;
                        CloseHandle( hToken );
                        return FALSE;
                    }
                }
                delete ppszPrincName;
                delete pDomainName;
            }
        }
        CloseHandle( hToken );
    }

    return TRUE;
}






BOOL CUtility::MakeSecDesc(SID *pSid, SECURITY_DESCRIPTOR **ppSD)
{
    ACL               *pAcl;
    DWORD              lSidLen;
    SID               *pGroup;
    SID               *pOwner;

    // In case we fail
    *ppSD = NULL;

    // Allocate the security descriptor.
    lSidLen = GetLengthSid( pSid );
    *ppSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED,
                  sizeof(SECURITY_DESCRIPTOR) + 2*lSidLen + SIZEOF_ACL);
    if (*ppSD == NULL)
    {
        return FALSE;
    }
    pGroup = (SID *) (*ppSD + 1);
    pOwner = (SID *) (((BYTE *) pGroup) + lSidLen);
    pAcl   = (ACL *) (((BYTE *) pOwner) + lSidLen);

    // Initialize a new security descriptor.
    if (!InitializeSecurityDescriptor(*ppSD, SECURITY_DESCRIPTOR_REVISION))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Initialize a new ACL.
    if (!InitializeAcl(pAcl, SIZEOF_ACL, ACL_REVISION2))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

// Comment out this code because the only time we create a default SD is
// when attempting to edit
// \\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.DefaultAccessPermission
// which we want to start with 0 ACE's
/*
    // Allow the current user access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE, pSid ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Allow local system access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &LOCAL_SYSTEM_SID ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }
*/

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( *ppSD, TRUE, pAcl, FALSE ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Set the group.
    memcpy( pGroup, pSid, lSidLen );
    if (!SetSecurityDescriptorGroup( *ppSD, pGroup, FALSE ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Set the owner.
    memcpy( pOwner, pSid, lSidLen );
    if (!SetSecurityDescriptorOwner( *ppSD, pOwner, FALSE ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Check the security descriptor.
    assert(IsValidSecurityDescriptor(*ppSD));

    return TRUE;
}


// Accepts either a traditional security descriptor or an IAccessControl
BOOL CUtility::CheckForValidSD(SECURITY_DESCRIPTOR *pSD)
{
    WORD dwType = 0;
    if (pSD)
    {
        dwType = *((WORD *)pSD);
    }
    if ((dwType != 1) && (dwType != 2))
    {
        CString sMsg, sCaption;
        sMsg.LoadString(IDS_BADSD);
        sCaption.LoadString(IDS_SYSTEMMESSAGE);
        MessageBox(NULL, sMsg, sCaption, MB_OK);
        return FALSE;
    }
    return TRUE;
}

// Check to see if the security descriptor is really a serialized IAccessControl.
BOOL CUtility::SDisIAC(SECURITY_DESCRIPTOR *pSD)
{
    WORD dwType = *((WORD *)pSD);
    if (dwType == 2)
    {
        return TRUE;
    }
    return FALSE;
}

SECURITY_DESCRIPTOR * CUtility::SDfromIAC(SECURITY_DESCRIPTOR * pSD)
{
    IStream * pStream;
    IAccessControl * pIAC;
    IPersistStream * pIPS;
    HRESULT hr;
    BOOL fReturn;

    // Un-serialize the IAccessControl
    hr = CreateStreamOnHGlobal((HGLOBAL)pSD, FALSE, &pStream);
    if (FAILED(hr))
    {
        return NULL;
    }
    // skip version
    DWORD dwVersion;
    hr = pStream->Read(&dwVersion, sizeof(DWORD), NULL);
    if (FAILED(hr) || dwVersion != 2)
    {
        return NULL;
    }
    // skip CLSID
    CLSID clsid;
    hr = pStream->Read(&clsid, sizeof(CLSID), NULL);
    if (FAILED(hr))
    {
        return NULL;
    }
    // create and IAccessControl and get an IPersistStream
    hr = CoCreateInstance(clsid,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IAccessControl,
                          (void **)&pIAC);
    if (FAILED(hr))
    {
        pStream->Release();
        return NULL;
    }
    hr = pIAC->QueryInterface(IID_IPersistStream, (void **) &pIPS);
    if (FAILED(hr))
    {
        pIAC->Release();
        pStream->Release();
        return NULL;
    }
    hr = pIPS->Load(pStream);
    pIPS->Release();
    pStream->Release();
    if (FAILED(hr))
    {
        pIAC->Release();
        return NULL;
    }

    // Create an EXPLICIT_ACCESS list for each entry in the IAccessControl
    DWORD cAces;
    ACTRL_ACCESS_ENTRYW * rgAE;
    ACTRL_ACCESS * pAccess;
//    PTRUSTEE pOwner;
//    PTRUSTEE pGroup;
//    hr = pIAC->GetAllAccessRights(NULL, &pAccess, &pOwner, &pGroup);
    hr = pIAC->GetAllAccessRights(NULL, &pAccess, NULL, NULL);
    if (FAILED(hr) || (pAccess->cEntries == 0))
    {
        pIAC->Release();
        return NULL;
    }
    // we're assuming only one property entry
    cAces = pAccess->pPropertyAccessList->pAccessEntryList->cEntries;
    rgAE = pAccess->pPropertyAccessList->pAccessEntryList->pAccessList;

    EXPLICIT_ACCESS * rgEA = new EXPLICIT_ACCESS[cAces];
    DWORD i;

    for (i = cAces; i--;)
    {
        LPTSTR szName = rgAE[i].Trustee.ptstrName;
        if (TRUSTEE_IS_NAME == rgAE[i].Trustee.TrusteeForm && 0 == wcscmp(rgAE[i].Trustee.ptstrName, L"*"))
        {
            szName = new WCHAR [wcslen(L"EVERYONE") + 1];
            if (!szName)
            {
                pIAC->Release();
                return NULL;
            }
            wcscpy(szName, L"EVERYONE");
        }
        DWORD dwAccessPermissions = rgAE[i].Access;    // should always be COM_RIGHTS_EXECUTE or GENERIC_ALL
        ACCESS_MODE AccessMode;
        switch (rgAE[i].fAccessFlags)
        {
        case ACTRL_ACCESS_ALLOWED:
            AccessMode = SET_ACCESS;
            dwAccessPermissions = COM_RIGHTS_EXECUTE;    // HACK! Required to get ACL editor to work.
            break;
        case ACTRL_ACCESS_DENIED:
        default:
            AccessMode = DENY_ACCESS;
            dwAccessPermissions = GENERIC_ALL;    // HACK! Required to get ACL editor to work.
            break;
        }
        DWORD dwInheritance = rgAE[i].Inheritance;     // Carefull. May not be allowed.
        BuildExplicitAccessWithName(
                    &rgEA[i],
                    szName,
                    dwAccessPermissions,
                    AccessMode,
                    dwInheritance);
    }

    SECURITY_DESCRIPTOR * pSDNew = NULL;
    ULONG cbSize = 0;
    // create the new Security descriptor
    hr = BuildSecurityDescriptor(NULL, //pOwner,
                                 NULL, //pGroup,
                                 cAces,
                                 rgEA,
                                 0,
                                 NULL,
                                 NULL,
                                 &cbSize,
                                 (void **)&pSDNew);
    if (ERROR_SUCCESS != hr)
    {
        // For some reason this may fail with this error even when it appears to have worked
        // A subsequent call seems to have no affect (i.e. it doesn't work like
        // other security descriptor calls that expect you to allocate the buffer yourself)
        if (ERROR_INSUFFICIENT_BUFFER != hr)
        {
            return NULL;
        }
    }
    SECURITY_DESCRIPTOR * pSDCopy = (SECURITY_DESCRIPTOR *)GlobalAlloc(GMEM_FIXED, cbSize);
    if (!pSDCopy)
    {
        LocalFree(pSDNew);
        return NULL;
    }
    memcpy(pSDCopy, pSDNew, cbSize);
    LocalFree(pSDNew);
    //delete [] rgAE;
    pIAC->Release();
    return pSDCopy;
}

SECURITY_DESCRIPTOR * CUtility::IACfromSD(SECURITY_DESCRIPTOR * pSD)
{
    IAccessControl * pIAC = NULL;

    // create new IAccessControl object
    HRESULT hr;

    hr = CoCreateInstance(CLSID_DCOMAccessControl,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IAccessControl,
                          (void **) &pIAC);

    if (FAILED(hr))
    {
        return (NULL);
    }
    IPersistStream * pIPS;
    hr = pIAC->QueryInterface(IID_IPersistStream, (void **) &pIPS);
    if (FAILED(hr))
    {
        pIAC->Release();
        return NULL;
    }
    hr = pIPS->Load(NULL);
    if (FAILED(hr))
    {
        pIPS->Release();
        pIAC->Release();
        return NULL;
    }

    BOOL fReturn, fDaclPresent, fDaclDefaulted;
    ACL * pDacl;

    // get the ACL list
    fReturn = GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pDacl, &fDaclDefaulted);
    if (fReturn && fDaclPresent)
    {
        PEXPLICIT_ACCESS rgEA;
        ULONG cAces;
#if 0    // Set to 1 when GetExplicitEntriesFromAcl works
        DWORD dwReturn = GetExplicitEntriesFromAcl(pDacl,
                                                   &cAces,
                                                   &rgEA);

        // enumerate the ACL, building list of objects to add to IAccessControl object
        if (dwReturn != ERROR_SUCCESS)
        {
            pIAC->Release();
            return NULL;
        }

        ACTRL_ACCESSW stAccess;
        ACTRL_PROPERTY_ENTRYW stProperty;
        ACTRL_ACCESS_ENTRY_LISTW stAccessList;
        stAccess.cEntries = 1;
        stAccess.pPropertyAccessList = &stProperty;
        stProperty.lpProperty = NULL;
        stProperty.pAccessEntryList = &stAccessList;
        stProperty.fListFlags = 0;
        stAccessList.cEntries = cAces;
        ACTRL_ACCESS_ENTRYW * rgAE = new ACTRL_ACCESS_ENTRYW[cAces];
	stAccessList.pAccessList = rgAE;
        ULONG i;
        for (i = cAces; i--; )
        {
            rgAE[i].Trustee = rgEA[i].Trustee;
            if (rgEA[i].Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                // convert to a named trustee
                rgAE[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                SID * pSid = (SID *)rgEA[i].Trustee.ptstrName;
                DWORD cbName = 0;
                DWORD cbDomain = 0;
                LPTSTR szName = NULL;
                LPTSTR szDomain = NULL;
                SID_NAME_USE snu;
                fReturn = LookupAccountSid(NULL,
                                           pSid,
                                           szName,
                                           &cbName,
                                           szDomain,
                                           &cbDomain,
                                           &snu);
                szName = (LPTSTR) new char [cbName];
                szDomain = (LPTSTR) new char [cbDomain];
                fReturn = LookupAccountSid(NULL,
                                           pSid,
                                           szName,
                                           &cbName,
                                           szDomain,
                                           &cbDomain,
                                           &snu);
                CString * pcs = new CString;
                (*pcs) = TEXT("\\\\");
                (*pcs) += szDomain;
                (*pcs) += TEXT("\\");
                (*pcs) += szName;
                rgAE[i].Trustee.ptstrName = (LPTSTR)(LPCTSTR)(*pcs);
            }
            else
            {
#if 0   // REMOVE THIS HACK when GetExplicitEntriesFromAcl works as it should
                if (rgAE[i].Trustee.TrusteeType < TRUSTEE_IS_WELL_KNOWN_GROUP)
                {
                    rgAE[i].Trustee.TrusteeType = (enum _TRUSTEE_TYPE)((unsigned)rgAE[i].Trustee.TrusteeType + 1);
                }
#endif
                if (rgAE[i].Trustee.TrusteeType == TRUSTEE_IS_WELL_KNOWN_GROUP)
                {
                    // IAccessControl::GrantAccessRights doesn't like TRUSTEE_IS_WELL_KNOWN_GROUP for some reason
                    rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                }
            }
            // test for "the world"
            if (TRUSTEE_IS_WELL_KNOWN_GROUP == rgAE[i].Trustee.TrusteeType &&
                0 == _wcsicmp(L"Everyone", rgAE[i].Trustee.ptstrName))
            {
                rgAE[i].Trustee.ptstrName[0] = L'*';
                rgAE[i].Trustee.ptstrName[1] = 0;
            }
            rgAE[i].Access = rgEA[i].grfAccessPermissions;
            rgAE[i].ProvSpecificAccess = 0;
            rgAE[i].Inheritance = rgEA[i].grfInheritance;
            rgAE[i].lpInheritProperty = NULL;
            switch (rgEA[i].grfAccessMode)
            {
            case SET_ACCESS:
                rgAE[i].fAccessFlags = ACTRL_ACCESS_ALLOWED;
                break;
            case DENY_ACCESS:
            default:
                rgAE[i].fAccessFlags = ACTRL_ACCESS_DENIED;
                break;
            }
        }
#else
        ACL_SIZE_INFORMATION aclInfo;
        fReturn = GetAclInformation(pDacl, &aclInfo, sizeof(aclInfo), AclSizeInformation);
        if (!fReturn)
        {
	    pIPS->Release();
	    pIAC->Release();
            return NULL;
        }
        cAces = aclInfo.AceCount;
        ACE_HEADER * pAceHeader;

        ACTRL_ACCESSW stAccess;
        ACTRL_PROPERTY_ENTRYW stProperty;
        ACTRL_ACCESS_ENTRY_LISTW stAccessList;
        stAccess.cEntries = 1;
        stAccess.pPropertyAccessList = &stProperty;
        stProperty.lpProperty = NULL;
        stProperty.pAccessEntryList = &stAccessList;
        stProperty.fListFlags = 0;
        stAccessList.cEntries = cAces;
        ACTRL_ACCESS_ENTRYW * rgAE = new ACTRL_ACCESS_ENTRYW[cAces];
        if (!rgAE) 
	{
	   pIPS->Release();
	   pIAC->Release();
	   return NULL;
	}
	stAccessList.pAccessList = rgAE;
        ULONG i;
        for (i = cAces; i--; )
        {
            rgAE[i].ProvSpecificAccess = 0;
            rgAE[i].Inheritance = NO_INHERITANCE;
            rgAE[i].lpInheritProperty = NULL;
            rgAE[i].Trustee.pMultipleTrustee = NULL;
            rgAE[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            rgAE[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
            rgAE[i].Access = COM_RIGHTS_EXECUTE;

            fReturn = GetAce(pDacl, i, (LPVOID *)&pAceHeader);
            if (!fReturn)
            {
	       delete [] rgAE;
	       pIPS->Release();
	       pIAC->Release();
               return NULL;
            }

            SID * pSid = NULL;

            switch (pAceHeader->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                {
                    rgAE[i].fAccessFlags = ACTRL_ACCESS_ALLOWED;
                    ACCESS_ALLOWED_ACE * pAce = (ACCESS_ALLOWED_ACE *)pAceHeader;
                    pSid = (SID *) &(pAce->SidStart);
                }
                break;
            case ACCESS_DENIED_ACE_TYPE:
                {
                    rgAE[i].fAccessFlags = ACTRL_ACCESS_DENIED;
                    ACCESS_DENIED_ACE * pAce = (ACCESS_DENIED_ACE *)pAceHeader;
                    pSid = (SID *) &(pAce->SidStart);
                }
                break;
            default:
                break;
            }

            TCHAR szName[MAX_PATH];
            TCHAR szDomain[MAX_PATH];
            DWORD cbName = MAX_PATH;
            DWORD cbDomain = MAX_PATH;
            SID_NAME_USE use;

            if(pSid)
            {
                fReturn = LookupAccountSid(NULL,
                                           pSid,
                                           szName,
                                           &cbName,
                                           szDomain,
                                           &cbDomain,
                                           &use);
            }
            else
            {
                fReturn = FALSE;  // i.e., we took default path above
            }

            if (!fReturn)
            {
	       delete [] rgAE;
	       pIPS->Release();
	       pIAC->Release();
               return NULL;
            }

            switch (use)
            {
            case SidTypeUser:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_USER;
                break;
            case SidTypeGroup:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                break;
            case SidTypeAlias:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;
                break;
            case SidTypeWellKnownGroup:
                //rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                break;
            case SidTypeDeletedAccount:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_DELETED;
                break;
            case SidTypeInvalid:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_INVALID;
                break;
            case SidTypeDomain:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP; //TRUSTEE_IS_DOMAIN;
                break;
            case SidTypeUnknown:
            default:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
                break;
            }
            CString sz;
            // test for "the world"
            if (0 == wcslen(szDomain) && 0 == _wcsicmp(L"Everyone", szName))
            {
                sz = "*";
            }
            else
            {
                sz = szDomain;
                sz += "\\";
                sz += szName;
            }

            WCHAR * wsz = new WCHAR[sz.GetLength() + 1];
            wcscpy(wsz, (LPCWSTR)sz);
            rgAE[i].Trustee.ptstrName = wsz;
        }
#endif
        delete [] rgAE;
        hr = pIAC->GrantAccessRights(&stAccess);
        if (FAILED(hr))
        {
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        // free up structures
        // LocalFree(rgEA);
    }
    // serialize the IAccessControl object

    // Find out how big it is
    ULARGE_INTEGER size;
    hr = pIPS->GetSizeMax(&size);
    if (FAILED(hr))
    {
        pIPS->Release();
        pIAC->Release();
        return NULL;
    }
    size.QuadPart += sizeof(DWORD) + sizeof (CLSID);
    HANDLE hMem = GlobalAlloc(GMEM_FIXED, size.LowPart);
    if (hMem != NULL)
    {
        IStream * pStream;
        hr = CreateStreamOnHGlobal(hMem, FALSE, &pStream);
        if (FAILED(hr))
        {
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        DWORD dwVersion = 2;
        CLSID clsid = CLSID_DCOMAccessControl;
        hr = pStream->Write(&dwVersion, sizeof(DWORD), NULL);
        if (FAILED(hr))
        {
            pStream->Release();
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        hr = pStream->Write(&clsid, sizeof(CLSID), NULL);
        if (FAILED(hr))
        {
            pStream->Release();
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        hr = pIPS->Save(pStream, TRUE);
        pStream->Release();
        if (FAILED(hr))
        {
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
    }
    pIPS->Release();
    pIAC->Release();
    return (SECURITY_DESCRIPTOR *) hMem;
}


BOOL CUtility::CheckSDForCOM_RIGHTS_EXECUTE(SECURITY_DESCRIPTOR *pSD)
{
    PSrAcl                        pDacl;
    PSrAce                        pAce;
    DWORD                         cbAces;
    SECURITY_DESCRIPTOR_RELATIVE* pSDr = (SECURITY_DESCRIPTOR_RELATIVE*) pSD;

    // Check whether the security descriptor is self-relative
    if (!(pSD->Control & SE_SELF_RELATIVE))
    {
        pDacl = (PSrAcl) pSD->Dacl;

        // Check for a deny ALL
        if (pDacl == NULL)
        {
            return TRUE;
        }
    }
    else
    {
        // First check for a deny ALL
        if (pSDr->Dacl == 0)
        {
            return TRUE;
        }

        pDacl = (PSrAcl) (((BYTE *) pSDr) + (pSDr->Dacl));
    }

    // Do over the ACE's
    for (pAce = (PSrAce) (((BYTE *) pDacl) + sizeof(SSrAcl)),
         cbAces = pDacl->AceCount;
         cbAces;
         pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize),
         cbAces--)
    {
        // workaround for the ACL editor bug. If the ACL editor sees a non GENERIC_ALL deny ACE, it 
	// complains. So we convert COM_RIGHTS_EXECUTE to GENERIC_ALL. On the way back we will
	// do the reverse. See CallBackFunc for the other half of this fix.

	if (pAce->Type == 1  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE)
        {
            pAce->AccessMask = GENERIC_ALL;
        }        
        // Check that it is
        // a) an allow on COM_RIGHTS_EXECUTE
        // b) a deny on GENERIC_ALL,
        // c) a deny on COM_RIGHTS_EXECUTE,
        // d) a deny ALL (handled above if the DACL is NULL) or
        // e) an allow everyone (handled implicitly if cbAces == 0)
        if (!(((pAce->Type == 0  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE)
               ||
               (pAce->Type == 1  &&  pAce->AccessMask == GENERIC_ALL)
               ||
               (pAce->Type == 1  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE))))
        {
            CString szText;
            CString szTitle;

            szText.LoadString(IDS_The_security_);
            szTitle.LoadString(IDS_DCOM_Configuration_Warning);

            if (MessageBox(GetForegroundWindow(),
                           (LPCTSTR) szText,
                           (LPCTSTR) szTitle,
                           MB_YESNO) == IDYES)
            {
                pAce->Flags = 0;
                pAce->Type = 0;
                pAce->AccessMask = COM_RIGHTS_EXECUTE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL CUtility::ChangeService(LPCTSTR szService,
                             LPCTSTR szIdentity,
                             LPCTSTR szPassword,
                             LPCTSTR szDisplay)
{
    SC_HANDLE            hSCManager;
    SC_HANDLE            hService;
    QUERY_SERVICE_CONFIG qsc;
    DWORD dwBytesNeeded = 0;
    LPTSTR lpszTmpDisplay = (LPTSTR)szDisplay;

    // Open the service control manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ | GENERIC_WRITE))
    {
        // Try to open a handle to the requested service
        if (!(hService = OpenService(hSCManager,
                                     szService,
                                     GENERIC_READ | GENERIC_WRITE)))
        {
            g_util.PostErrorMessage();
            CloseServiceHandle(hSCManager);
            return FALSE;
        }

        // Close the service manager's database
        CloseServiceHandle(hSCManager);


        if (QueryServiceConfig(hService, &qsc, sizeof(qsc), &dwBytesNeeded))
            lpszTmpDisplay = qsc.lpDisplayName;

        // Change service identity parameters
        if (ChangeServiceConfig(hService,
                                SERVICE_NO_CHANGE, // SERVICE_WIN32_OWN_PROCESS,
                                SERVICE_NO_CHANGE, // SERVICE_DEMAND_START,
                                SERVICE_NO_CHANGE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                szIdentity,
                                szPassword,
                                NULL))
        {

            // Return success
            CloseServiceHandle(hService);
            return TRUE;
        }
        else
        {
            g_util.PostErrorMessage();
            CloseServiceHandle(hService);
            return FALSE;
        }
    }

    else
    {
        g_util.PostErrorMessage();
        return FALSE;
    }

}


// defined in ole32
extern "C" void UpdateDCOMSettings();

BOOL CUtility::UpdateDCOMInfo(void)
{
    UpdateDCOMSettings();
    return TRUE;    
}

LRESULT CALLBACK ControlFixProc( HWND  hwnd, UINT  uMsg, WPARAM wParam,
                                 LPARAM  lParam);

// This is a work-around because there is a bug in msdev 4.1: Cannot get
// WM_HELP message processed by a control on which DDX_Control data exchange
// is done because of subclassing problem.  See msdn Q145865 for a discussion
// plus work-around code.
void CUtility::FixHelp(CWnd* pWnd)
{
    // search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLongPtr(pWndChild->GetSafeHwnd(),
                          GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
        {
            SetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC,
                          (LONG_PTR)ControlFixProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}



LRESULT CALLBACK ControlFixProc(HWND  hwnd, UINT  uMsg, WPARAM wParam,
                                LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
        // bypass MFC's handler, message will be sent to parent
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}




// Compare two security descriptors in self-relative form to
// determine if they're the same
BOOL CUtility::CompareSDs(PSrSecurityDescriptor pSD1,
                          PSrSecurityDescriptor pSD2)
{
    PSID   pSid1, pSid2;
    PSrAcl pDacl1, pDacl2;
    PSrAce pAce1, pAce2;
    BYTE   *p1, *p2;

    // Compare the owners
    pSid1 = (PSID) (((BYTE *) pSD1) + pSD1->Owner);
    pSid2 = (PSID) (((BYTE *) pSD2) + pSD2->Owner);
    if (!EqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    // Compare the groups
    pSid1 = (PSID) (((BYTE *) pSD1) + pSD1->Group);
    pSid2 = (PSID) (((BYTE *) pSD2) + pSD2->Group);
    if (!EqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    // Compare the DACL's
    pDacl1 = (PSrAcl) (((BYTE *) pSD1) + pSD1->Dacl);
    pDacl2 = (PSrAcl) (((BYTE *) pSD2) + pSD2->Dacl);

    // Check first that they are the same size and have the same
    // number of ACE's
    if (! (pDacl1->AclSize  == pDacl2->AclSize  &&
           pDacl1->AceCount == pDacl2->AceCount))
    {
        return FALSE;
    }

    // Now compare the ACL ACE by ACE
    pAce1 = (PSrAce) (((BYTE *) pDacl1) + sizeof(SSrAcl));
    pAce2 = (PSrAce) (((BYTE *) pDacl2) + sizeof(SSrAcl));
    for (int k = 0; k < pDacl1->AceCount; k++)
    {
        // Check the ACE headers
        if (! (pAce1->Type       == pAce2->Type        &&
               pAce1->AceSize    == pAce2->AceSize     &&
               pAce1->AccessMask == pAce2->AccessMask))
        {
            return FALSE;
        }

        // Check the SID's
        p1 = (BYTE *) (((BYTE *) pAce1) + sizeof(ACE_HEADER));
        p2 = (BYTE *) (((BYTE *) pAce2) + sizeof(ACE_HEADER));
        for (ULONG j = 0; j < pAce1->AceSize - sizeof(ACE_HEADER); j++)
        {
            if (p1[j] != p2[j])
            {
                return FALSE;
            }
        }

        // Go to the next ACE
        pAce1 = (PSrAce) (((BYTE *) pAce1) + pAce1->AceSize);
        pAce2 = (PSrAce) (((BYTE *) pAce2) + pAce2->AceSize);
    }

    return TRUE;
}





int CUtility::SetAccountRights(LPCTSTR szUser, TCHAR *szPrivilege)
{
#if !defined(STANDALONE_BUILD)
    int                   err;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES objAtt;
    DWORD                 cbSid = 1;
    TCHAR                 szDomain[MAX_PATH];
    DWORD                 cbDomain = MAX_PATH * sizeof(TCHAR);
    PSID                  pSid = NULL;
    SID_NAME_USE          snu;
    LSA_UNICODE_STRING    privStr;

    
    // Fetch the SID for the specified user
    if ((err = GetPrincipalSID(szUser, &pSid)) != ERROR_SUCCESS)
        return err;

    memset(&objAtt, 0, sizeof(LSA_OBJECT_ATTRIBUTES));
    
    if (IsBackupDC()) {
        TCHAR* pszPDC;
        LSA_UNICODE_STRING    lsaPDC;

        pszPDC = PrimaryDCName();

        lsaPDC.Length = _tcslen (pszPDC) * sizeof (TCHAR)-2;
        lsaPDC.MaximumLength = lsaPDC.Length + sizeof (TCHAR);
        lsaPDC.Buffer = &pszPDC[2];

        err = LsaOpenPolicy(&lsaPDC, &objAtt, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION, &hPolicy);
    }
    else
        err = LsaOpenPolicy(NULL, &objAtt, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION, &hPolicy);
 
    if (err != ERROR_SUCCESS) {
        return GetLastError();
    }

    // Set the specified privilege on this account
    privStr.Length = _tcslen(szPrivilege) * sizeof(TCHAR);
    privStr.MaximumLength = privStr.Length + sizeof(TCHAR);
    privStr.Buffer = szPrivilege;
    err = LsaAddAccountRights(hPolicy, pSid, &privStr, 1);
    
    // We're done
    delete pSid;
    LsaClose(hPolicy);

    if (err != ERROR_SUCCESS) {
        return GetLastError();
    }

#endif
    return ERROR_SUCCESS;
}

// NOTE: Cannot handle IAccessControl style SDs

void CUtility::CopyAbsoluteSD( SECURITY_DESCRIPTOR *pSDSrc,  SECURITY_DESCRIPTOR **pSDDest)
{
   (*pSDDest)->Revision = pSDSrc->Revision;
   (*pSDDest)->Sbz1 = pSDSrc->Sbz1;
   (*pSDDest)->Control = pSDSrc->Control;
   (*pSDDest)->Group = (*pSDDest)->Owner = (*pSDDest)->Dacl = (*pSDDest)->Sacl = NULL;
   BYTE* pOffSet=(BYTE*)(*pSDDest)+sizeof(SECURITY_DESCRIPTOR);
   if (pSDSrc->Dacl != NULL)
   {
	  memcpy(pOffSet,pSDSrc->Dacl,pSDSrc->Dacl->AclSize);
	  (*pSDDest)->Dacl = (PACL)pOffSet;
	  pOffSet += pSDSrc->Dacl->AclSize;
   }
   if (pSDSrc->Owner != NULL)
   {
	  memcpy(pOffSet,pSDSrc->Owner,GetLengthSid(pSDSrc->Owner));
	  (*pSDDest)->Owner = (PSID)pOffSet;
	  pOffSet += GetLengthSid(pSDSrc->Owner);
   }
   if (pSDSrc->Group != NULL)
   {
	  memcpy(pOffSet,pSDSrc->Group,GetLengthSid(pSDSrc->Group));
	  (*pSDDest)->Group = (PSID)pOffSet;
   }
	  
}
// This method is included only because in the debug version when using
// MFC they validate the C++ heap, whereas RtlCopySecurityDescriptor uses
// the standard process heap, causing MFC to throw a breakpoint

// The return value indicates the success or failure of the operation

// NTBUG 310004. This function is called to copy both self-relative and absolute
// SDs. In its previous incarnation, it corrupted heap when called to
// copy an absolute SD. Now I do the right thing.

// NOTE: This function can not handle IAccessControl style SDs despite
// appearances to the contrary. This is OK, because dcomcnfg.exe does
// not handle such SDs at all. 

BOOL CUtility::CopySD(SECURITY_DESCRIPTOR *pSrc, SECURITY_DESCRIPTOR **pDest)
{
#if !defined(STANDALONE_BUILD)
    ULONG                cbLen;

	*pDest = NULL;
	if (IsValidSecurityDescriptor(pSrc))
	{
		if (SDisIAC(pSrc))
		{
			cbLen = (ULONG) GlobalSize(pSrc);
		}
		else
		{
			cbLen = RtlLengthSecurityDescriptor(pSrc);
		}
		*pDest = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
		if (*pDest)
		{
			// if the SD is already self-relative, just copy
			if ((pSrc)->Control & SE_SELF_RELATIVE )
			{
				memcpy(*pDest, pSrc, cbLen);
				return TRUE;
			}
			else 
			{
				// workaround an ACLEDIT bug (NT 352977). When the DACL has no ACES,
				// ACLEDIT returns incorrect AclSize, causing an AV  
				// when I copy it. So fix it here.
				if ((pSrc)->Dacl != NULL && ((pSrc)->Dacl->AceCount == 0))
					(pSrc)->Dacl->AclSize=sizeof(ACL);
				CopyAbsoluteSD(pSrc,pDest);
				return TRUE;
			}
			GlobalFree(*pDest);
		}
	}
#endif
	return FALSE;
}




// Set the inheritance flags on a security descriptor so keys created
// under the key having this security descriptor will inherit all its
// ACE's.  We do this as a utility routine rather than via the ACL
// editor because doing that adds check boxes and such to the ACL editor,
// so it's cleaner this way.
//
// Note. The security descriptor is expected to be in absolute form
void CUtility::SetInheritanceFlags(SECURITY_DESCRIPTOR *pSec)
{
    PSrAcl pAcl = (PSrAcl) pSec->Dacl;
    PSrAce pAce;
    int    k;

    // Do over the ACE's this DACL
    for (k = pAcl->AceCount, pAce = (PSrAce) (((BYTE *) pAcl) + sizeof(SSrAcl));
         k;
         k--, pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize))
    {
        pAce->Flags |= CONTAINER_INHERIT_ACE;
    }
}



HRESULT CUtility::GetPrincipalSID (LPCTSTR Principal, PSID *Sid)
{
    DWORD        sidSize = 0;
    TCHAR        refDomain [256];
    DWORD        refDomainSize = 0;
    DWORD        returnValue;
    SID_NAME_USE snu;
    BOOL         bSuccess;
    
    bSuccess = LookupAccountName (NULL,
                       Principal,
                       *Sid,
                       &sidSize,
                       refDomain,
                       &refDomainSize,
                       &snu);

    // codework - we need to check if this is correct
    // what about multisuer machines - ie hydra
    if ((returnValue = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        return returnValue;

    if ((*Sid = new BYTE[sidSize]) == NULL)
        return ERROR_OUTOFMEMORY;

    if (!LookupAccountName (NULL,
                            Principal,
                            *Sid,
                            &sidSize,
                            refDomain,
                            &refDomainSize,
                            &snu))
    {
        delete *Sid;
	*Sid = NULL;
	return GetLastError();
    }

    return ERROR_SUCCESS;
}

// this method, on first execution, checks if the current machine is a backup domain controller and if so,
// caches the value and returns TRUE. Subsequent executions will use cached value.
BOOL CUtility::IsBackupDC()
{
#if !defined(STANDALONE_BUILD)
    USER_MODALS_INFO_2    *umi2 = NULL;
    SERVER_INFO_101       *si101 = NULL;
    DWORD                 dw;

    if (!m_bCheckedDC) {
        if ((dw = NetServerGetInfo (NULL, 101, (LPBYTE *) &si101)) == 0)
        {
            if (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)
            {
                if ((dw = NetUserModalsGet (NULL, 2, (LPBYTE *) &umi2)) == 0)
                {
                    if(umi2)
                    {
                        NetGetDCName (NULL, umi2->usrmod2_domain_name, (LPBYTE *) &m_pszDomainController);
                        NetApiBufferFree (umi2);
                    }
                    m_bIsBdc = TRUE;
                }
            }
        }
        m_bCheckedDC = TRUE;

        if (si101)
            NetApiBufferFree (si101);

    }

    return m_bIsBdc;
#else
    return FALSE;
#endif
}

TCHAR* CUtility::PrimaryDCName()
{

    static TCHAR s_tszUnknownDomainName[] = _T("UnknownDCName");
#if !defined(STANDALONE_BUILD)
    if (IsBackupDC())
    {
        if(m_pszDomainController){
            return m_pszDomainController;
        }
        else
        {
            return  s_tszUnknownDomainName;
        }
    }
#endif

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\util.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       util.cpp
//
//  Contents:   Defnes the utility class CUtility
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef _UTIL_H_
#define _UTIL_H_

// note dependencies on the following two files
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#define COM_RIGHTS_EXECUTE 1


typedef struct
{
    HKEY                 hRoot;
    TCHAR               *szKeyPath;
    TCHAR               *szValueName;
} SSingleCallBack;



typedef struct
{
    HKEY                 hKey;
    HKEY                *phClsids;
    unsigned             cClsids;
    TCHAR               *szTitle;
} SRegKeyCallBack;



typedef struct tagCallBackContext
{
    PACKETTYPE           pktType;
    int                 *pIndex;
    SECURITY_DESCRIPTOR *origSD;
    BOOL                fIsIAC;
    union
    {
        SSingleCallBack single;
        SRegKeyCallBack regKey;
    }                   info;
} SCallBackContext, *PCallBackContext;



typedef struct
{
    WORD  Control;
    BYTE  Reserved1;
    BYTE  Revision;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
} SSrSecurityDescriptor, *PSrSecurityDescriptor;



typedef struct
{
    BYTE Revision;
    BYTE Reserved1;
    WORD AclSize;
    WORD AceCount;
    WORD Reserved2;
} SSrAcl, *PSrAcl;



typedef struct
{
    BYTE Type;
    BYTE Flags;
    WORD AceSize;
    ULONG AccessMask;
} SSrAce, *PSrAce;


#if !defined(STANDALONE_BUILD)
#define USER_DETAILS_BUFFER_SIZE 1024

typedef struct tagUserDetailsPlus
{
    USERDETAILS sUserDetails;
    BYTE        bBuffer[USER_DETAILS_BUFFER_SIZE];
} SUserDetailsPlus;
#endif

enum dcomAclType { dcomAclAccess, dcomAclLaunch, dcomAclConfig };

class CUtility
{
public:
          CUtility(void);

         ~CUtility(void);

    void  PostErrorMessage(void);

    void  PostErrorMessage(int err);

    void  CkForAccessDenied(int err);

    BOOL  CkAccessRights(HKEY hRoot, LPCTSTR szKeyPath);

    int   WriteRegSzNamedValue(HKEY   hRoot,
                               LPCTSTR szKeyPath,
                               LPCTSTR szValueName,
                               LPCTSTR szVal,
                               DWORD  dwSize);

    int WriteRegMultiSzNamedValue(HKEY   hRoot,
                                   LPCTSTR szKeyPath,
                                   LPCTSTR szValueName,
                                   LPCTSTR szVal,
                                   DWORD  dwSize);


    int   WriteRegDwordNamedValue(HKEY   hRoot,
                                  LPCTSTR szKeyPath,
                                  LPCTSTR szValueName,
                                  DWORD  dwVal);

    int   WriteRegSingleACL(HKEY   hRoot,
                            LPCTSTR szKeyPath,
                            LPCTSTR szValueName,
                            PSECURITY_DESCRIPTOR pSec);

    int   WriteRegKeyACL(HKEY   hKey,
                         HKEY  *phClsids,
                         unsigned cClsids,
                         PSECURITY_DESCRIPTOR pSec,
                         PSECURITY_DESCRIPTOR pSecOrig);

    int   WriteRegKeyACL2(HKEY   hRoot,
                          HKEY   hKey,
                          PSECURITY_DESCRIPTOR pSec,
                          PSECURITY_DESCRIPTOR pSecOrig);

    int   WriteLsaPassword(CLSID  appid,
                           LPCTSTR szPassword);

    int   WriteSrvIdentity(LPCTSTR szService,
                           LPCTSTR szIdentity);

    int   DeleteRegKey(HKEY hRoot, LPCTSTR szKeyPath);

    int   DeleteRegValue(HKEY hRoot, LPCTSTR szKeyPath, LPCTSTR szValueName);

    int   ACLEditor(HWND       hWnd,
                    HKEY       hRoot,
                    LPCTSTR    szKeyPath,
                    LPCTSTR    szValueName,
                    int       *nIndex,
                    PACKETTYPE pktType,
                    dcomAclType eAclType);

    int   ACLEditor2(HWND       hWnd,
                     HKEY       hKey,
                     HKEY      *phClsids,
                     unsigned   cClsids,
                     TCHAR     *szTitle,
                     int       *nIndex,
                     PACKETTYPE pktType);

    BOOL  InvokeUserBrowser(HWND hWnd, TCHAR *szUser);

    BOOL  InvokeMachineBrowser(TCHAR *szMachine);

    int  StringFromGUID(GUID  &rguid, TCHAR *lpsz, int cbMax);

    BOOL IsEqualGuid(GUID &guid1, GUID &guid2);

    BOOL AdjustPrivilege(TCHAR *szPrivilege);

    BOOL VerifyRemoteMachine(TCHAR *szRemoteMachine);

    BOOL RetrieveUserPassword(TCHAR *szAppid, CString &sPassword);

    BOOL StoreUserPassword(TCHAR *szAppid, CString &sPassword);

    BOOL LookupProcessInfo(SID **ppSid, TCHAR **ppszPrincName);

    BOOL MakeSecDesc(SID *pSid, SECURITY_DESCRIPTOR **ppSD);

    BOOL ChangeService(LPCTSTR szService,
                       LPCTSTR szIdentity,
                       LPCTSTR szPassword,
                       LPCTSTR szDisplay);

    int  UpdateDCOMInfo(void);

    void FixHelp(CWnd* pWnd);

    BOOL CompareSDs(PSrSecurityDescriptor pSD1, PSrSecurityDescriptor pSD2);

    int SetAccountRights( LPCTSTR szUser, TCHAR *szPrivilege);

    BOOL CopySD(SECURITY_DESCRIPTOR *pSrc, SECURITY_DESCRIPTOR **pDest);

    void CopyAbsoluteSD(SECURITY_DESCRIPTOR *pSrc, SECURITY_DESCRIPTOR **pDest);

    void SetInheritanceFlags(SECURITY_DESCRIPTOR *pSec);

    BOOL CheckForValidSD(SECURITY_DESCRIPTOR *pSD);
    BOOL SDisIAC(SECURITY_DESCRIPTOR *pSD);
    SECURITY_DESCRIPTOR * IACfromSD(SECURITY_DESCRIPTOR * pSD);
    SECURITY_DESCRIPTOR * SDfromIAC(SECURITY_DESCRIPTOR * pIAC);

    // added for BDC fix 

    HRESULT GetPrincipalSID (LPCTSTR Principal, PSID *Sid);

    // checks if we're on a BDC
    BOOL    IsBackupDC();
    TCHAR*  PrimaryDCName();


 private:
    BOOL CheckSDForCOM_RIGHTS_EXECUTE(SECURITY_DESCRIPTOR *pSD);

    SCallBackContext  m_sCallBackContext;
    void             *m_args[8];
    BOOL              m_bCheckedDC;
    BOOL              m_bIsBdc;
    TCHAR*            m_pszDomainController;
};



extern CUtility       g_util;
extern HKEY           g_hAppid;
extern HKEY          *g_rghkCLSID;
extern unsigned       g_cCLSIDs;
extern TCHAR         *g_szAppTitle;
extern BOOL           g_fReboot;
extern TCHAR         *g_szAppid;

#endif //_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\virtreg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       virtreg.cpp
//
//  Contents:   Implements the class CVirtualRegistry which manages a
//              virtual registry
//
//  Classes:
//
//  Methods:    CVirtualRegistry::CVirtualRegistry
//              CVirtualRegistry::~CVirtualRegistry
//              CVirtualRegistry::ReadRegSzNamedValue
//              CVirtualRegistry::NewRegSzNamedValue
//              CVirtualRegistry::ChgRegSzNamedValue
//              CVirtualRegistry::ReadRegDwordNamedValue
//              CVirtualRegistry::NewRegDwordNamedValue
//              CVirtualRegistry::ChgRegDwordNamedValue
//              CVirtualRegistry::NewRegSingleACL
//              CVirtualRegistry::ChgRegACL
//              CVirtualRegistry::NewRegKeyACL
//              CVirtualRegistry::ReadLsaPassword
//              CVirtualRegistry::NewLsaPassword
//              CVirtualRegistry::ChgLsaPassword
//              CVirtualRegistry::ReadSrvIdentity
//              CVirtualRegistry::NewSrvIdentity
//              CVirtualRegistry::ChgSrvIdentity
//              CVirtualRegistry::MarkForDeletion
//              CVirtualRegistry::GetAt
//              CVirtualRegistry::Remove
//              CVirtualRegistry::Cancel
//              CVirtualRegistry::Apply
//              CVirtualRegistry::ApplyAll
//              CVirtualRegistry::Ok
//              CVirtualRegistry::SearchForRegEntry
//              CVirtualRegistry::SearchForLsaEntry
//              CVirtualRegistry::SearchForSrvEntry
//
//  History:    23-Apr-96   BruceMa     Created.
//              15-Dec-96   RonanS      Tidied up to remove memory leaks
//                                      Use array of pointers to avoid bitwise copy
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "assert.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include "ntlsa.h"
}
#endif

#include "winsvc.h"
#include "types.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
    extern "C"
    {
    #include <getuser.h>
    }
#endif

#include "util.h"
#include "virtreg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CVirtualRegistry::CVirtualRegistry(void)
{
    m_pkts.SetSize(0, 8);
}



CVirtualRegistry::~CVirtualRegistry(void)
{
    // ronans - remove any remaining items
    RemoveAll();
}




// Read a named string value from the registry and cache it
int CVirtualRegistry::ReadRegSzNamedValue(HKEY   hRoot,
                                          TCHAR *szKeyPath,
                                          TCHAR *szValueName,
                                          int   *pIndex)
{
    int     err;
    HKEY    hKey;
    ULONG   lSize;
    DWORD   dwType;
    TCHAR   szVal[MAX_PATH];

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket * pCdp = GetAt(*pIndex);
        ASSERT(pCdp);                           // should always be non null
        if (pCdp->IsDeleted())
        {
            *pIndex = -1;
            return ERROR_FILE_NOT_FOUND;
        }
        else
            return ERROR_SUCCESS;
    }

    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        return err;
    }

    // Attempt to read the named value
    lSize = MAX_PATH * sizeof(TCHAR);
    if ((err = RegQueryValueEx(hKey, szValueName, NULL, &dwType, (BYTE *) szVal,
                        &lSize))
        != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        if (hKey != hRoot)
            RegCloseKey(hKey);
        return err;
    }

    // Build a data packet
    if (dwType == REG_SZ)
    {
        CDataPacket * pNewPacket = new CRegSzNamedValueDp(hRoot, szKeyPath, szValueName, szVal);
        ASSERT(pNewPacket);

        if (!pNewPacket)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        *pIndex = (int)m_pkts.Add(pNewPacket);
        pNewPacket->SetModified( FALSE);
        return ERROR_SUCCESS;
    }
    else
        return ERROR_BAD_TOKEN_TYPE;
}

// Read a named string value from the registry and cache it
int CVirtualRegistry::ReadRegMultiSzNamedValue(HKEY   hRoot,
                                          TCHAR *szKeyPath,
                                          TCHAR *szValueName,
                                          int   *pIndex)
{
    int     err = ERROR_SUCCESS;
    HKEY    hKey;

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket * pCdp = GetAt(*pIndex);
        ASSERT(pCdp);                           // should always be non null
        if (pCdp->IsDeleted())
        {
            *pIndex = -1;
            return ERROR_FILE_NOT_FOUND;
        }
        else
            return err;
    }

    // Build a data packet
    CRegMultiSzNamedValueDp * pNewPacket = new CRegMultiSzNamedValueDp(hRoot, szKeyPath, szValueName);
    ASSERT(pNewPacket);
    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS)
    {
        if (pNewPacket)
        {
            // read the key
            if ((err = pNewPacket -> Read(hKey)) == ERROR_SUCCESS)
            {
                *pIndex = (int)m_pkts.Add(pNewPacket);
                pNewPacket->SetModified( FALSE);
            }
            else
            {
                g_util.CkForAccessDenied(err);
                delete pNewPacket;
                if (hKey != hRoot)
                    RegCloseKey(hKey);
            }            
        }
        else
            err = ERROR_NOT_ENOUGH_MEMORY;

        if (err != ERROR_SUCCESS)
            g_util.CkForAccessDenied(err);

        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
    }
    else
       delete pNewPacket;

    return err;
}


int  CVirtualRegistry::NewRegSzNamedValue(HKEY   hRoot,
                                          TCHAR  *szKeyPath,
                                          TCHAR  *szValueName,
                                          TCHAR  *szVal,
                                          int    *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp *)GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp->ChgSzValue(szVal);
        return ERROR_SUCCESS;
    }

    // Build a data packet and add it
    CRegSzNamedValueDp * pNewPacket = new CRegSzNamedValueDp (hRoot, szKeyPath, szValueName, szVal);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);

    return ERROR_SUCCESS;
}

int  CVirtualRegistry::NewRegMultiSzNamedValue(HKEY   hRoot,
                                          TCHAR  *szKeyPath,
                                          TCHAR  *szValueName,
                                          int    *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp *)GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp->Clear();
        pCdp -> SetModified(TRUE);
        return ERROR_SUCCESS;
    }

    // Build a data packet and add it
    CRegMultiSzNamedValueDp * pNewPacket = new CRegMultiSzNamedValueDp (hRoot, szKeyPath, szValueName);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    pNewPacket -> SetModified(TRUE);
    *pIndex = (int)m_pkts.Add(pNewPacket);

    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgRegSzNamedValue(int nIndex, TCHAR  *szVal)
{
    CRegSzNamedValueDp* pCdp = (CRegSzNamedValueDp*)m_pkts.ElementAt(nIndex);
    pCdp->ChgSzValue(szVal);
}



// Read a named DWORD value from the registry
int CVirtualRegistry::ReadRegDwordNamedValue(HKEY   hRoot,
                                             TCHAR *szKeyPath,
                                             TCHAR *szValueName,
                                             int   *pIndex)
{
        int   err;
    HKEY  hKey;
    ULONG lSize;
    DWORD dwType;
    DWORD dwVal;

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }

    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        return err;
    }

    // Attempt to read the named value
    lSize = sizeof(DWORD);
   if ((err = RegQueryValueEx(hKey, szValueName, NULL, &dwType, (BYTE *) &dwVal,
                       &lSize))
        != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return err;
    }

    // Close the registry key
    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    // Build a data packet
    if (dwType == REG_DWORD)
    {
        CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, dwVal);
        ASSERT(pNewPacket);
        if (!pNewPacket)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *pIndex = (int)m_pkts.Add(pNewPacket);
        pNewPacket-> SetModified(FALSE);

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_BAD_TOKEN_TYPE;
    }
}



int  CVirtualRegistry::NewRegDwordNamedValue(HKEY   hRoot,
                                             TCHAR  *szKeyPath,
                                             TCHAR  *szValueName,
                                             DWORD  dwVal,
                                             int   *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket * pCdp = GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp->pkt.nvdw.dwValue = dwVal;
        pCdp->SetModified(TRUE);
        return ERROR_SUCCESS;
    }

    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, dwVal);
    ASSERT(pNewPacket);

    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    pNewPacket->SetModified(TRUE);
    return ERROR_SUCCESS;
}


void CVirtualRegistry::ChgRegDwordNamedValue(int nIndex, DWORD dwVal)
{
    CDataPacket * pCdp = m_pkts.ElementAt(nIndex);

    pCdp->pkt.nvdw.dwValue = dwVal;
    pCdp->SetModified( TRUE);
}


int  CVirtualRegistry::NewRegSingleACL(HKEY   hRoot,
                                       TCHAR  *szKeyPath,
                                       TCHAR  *szValueName,
                                       SECURITY_DESCRIPTOR *pacl,
                                       BOOL   fSelfRelative,
                                       int                 *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, pacl, fSelfRelative);
    ASSERT(pNewPacket);

    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;

    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}


void CVirtualRegistry::ChgRegACL(int                  nIndex,
                                 SECURITY_DESCRIPTOR *pacl,
                                 BOOL                 fSelfRelative)
{
    CDataPacket * pCdp = m_pkts.ElementAt(nIndex);

    pCdp->ChgACL(pacl, fSelfRelative);
    pCdp->SetModified(TRUE);
}



int  CVirtualRegistry::NewRegKeyACL(HKEY                hKey,
                                    HKEY               *phClsids,
                                    unsigned            cClsids,
                                    TCHAR               *szTitle,
                                    SECURITY_DESCRIPTOR *paclOrig,
                                    SECURITY_DESCRIPTOR *pacl,
                                    BOOL                fSelfRelative,
                                    int                 *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hKey, phClsids, cClsids, szTitle, paclOrig, pacl, fSelfRelative);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



int CVirtualRegistry::ReadLsaPassword(CLSID &clsid,
                                      int   *pIndex)
{
#if !defined(STANDALONE_BUILD)

    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    TCHAR                 szKey[GUIDSTR_MAX + 5];
    PLSA_UNICODE_STRING   psPassword;


    // Check if we already have an entry fo this
    *pIndex = SearchForLsaEntry(clsid);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }

    // Formulate the access key
    lstrcpyW(szKey, L"SCM:");
    g_util.StringFromGUID(clsid, &szKey[4], GUIDSTR_MAX);
    szKey[GUIDSTR_MAX + 4] = L'\0';

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (USHORT)((lstrlenW(szKey) + 1) * sizeof(WCHAR));
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(WCHAR);
    sKey.Buffer              = szKey;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return GetLastError();
    }

    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return GetLastError();
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // prefix thinks we can get success with a null
    if (!psPassword)
        return ERROR_NOT_ENOUGH_MEMORY;     	
	
    // Build a data packet
    CDataPacket * pNewPacket = new CDataPacket(psPassword->Buffer, clsid);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    pNewPacket->SetModified( FALSE );
    *pIndex = (int)m_pkts.Add(pNewPacket);

#endif
    return ERROR_SUCCESS;
}



int  CVirtualRegistry::NewLsaPassword(CLSID &clsid,
                                      TCHAR  *szPassword,
                                      int   *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(szPassword, clsid);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgLsaPassword(int   nIndex,
                                      TCHAR *szPassword)
{
    CDataPacket * pCdp = m_pkts.ElementAt(nIndex);

    pCdp -> ChgPassword(szPassword);
    pCdp -> SetModified(TRUE);
}



int CVirtualRegistry::ReadSrvIdentity(TCHAR *szService,
                                      int   *pIndex)
{
    SC_HANDLE            hSCManager;
    SC_HANDLE            hService;
    QUERY_SERVICE_CONFIG sServiceQueryConfig;
    DWORD                dwSize;


    // Check if we already have an entry fo this
    *pIndex = SearchForSrvEntry(szService);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }

    // Open the service control manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, szService, GENERIC_READ))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Query the service
            if (QueryServiceConfig(hService, &sServiceQueryConfig,
                                   sizeof(QUERY_SERVICE_CONFIG), &dwSize))
            {
                // Build a data packet
                CDataPacket * pNewPacket = new CDataPacket(szService, sServiceQueryConfig.lpServiceStartName);
                ASSERT(pNewPacket);
                if (!pNewPacket)
                    return ERROR_NOT_ENOUGH_MEMORY;
                pNewPacket->SetModified(FALSE);
                *pIndex = (int)m_pkts.Add(pNewPacket);

                // Return success
                CloseServiceHandle(hSCManager);
                CloseServiceHandle(hService);
                return ERROR_SUCCESS;
            }
        }
        CloseServiceHandle(hSCManager);
    }

    return GetLastError();
}



int  CVirtualRegistry::NewSrvIdentity(TCHAR  *szService,
                                      TCHAR  *szIdentity,
                                      int   *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(szService, szIdentity);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgSrvIdentity(int    nIndex,
                                      TCHAR  *szIdentity)
{
    CDataPacket  *pCdp = m_pkts.ElementAt(nIndex);

    pCdp -> ChgSrvIdentity(szIdentity);
    pCdp -> SetModified( TRUE);
}



void CVirtualRegistry::MarkForDeletion(int nIndex)
{
    CDataPacket * pCdp = GetAt(nIndex);
    pCdp->MarkForDeletion(TRUE);
    pCdp->SetModified(TRUE);
}

void CVirtualRegistry::MarkHiveForDeletion(int nIndex)
{
    CDataPacket * pCdp = GetAt(nIndex);
    pCdp->MarkHiveForDeletion(TRUE);
    pCdp->SetModified(TRUE);
}



CDataPacket * CVirtualRegistry::GetAt(int nIndex)
{
    return m_pkts.ElementAt(nIndex);
}




void CVirtualRegistry::Remove(int nIndex)
{
    CDataPacket * pCdp = GetAt(nIndex);

    // ronans - must always destroy even if packet has not been marked dirty
    if (pCdp)
        delete pCdp;

    // overwrite with empty data packet
    m_pkts.SetAt(nIndex, new CDataPacket);
}




void CVirtualRegistry::RemoveAll(void)
{
    int nSize = (int)m_pkts.GetSize();
    for (int k = 0; k < nSize; k++)
    {
        Remove(k);

        CDataPacket * pCdp = GetAt(k);

        // remove empty packet
        if  (pCdp)
            delete pCdp;

    }

    m_pkts.RemoveAll();
}




void CVirtualRegistry::Cancel(int nIndex)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = nIndex; k < nSize; k++)
    {
        m_pkts.SetAt(nIndex, new CDataPacket);
    }
}



int  CVirtualRegistry::Apply(int nIndex)
{
    int err = ERROR_SUCCESS;
    int nSize = (int)m_pkts.GetSize();
    CDataPacket *pCdp = m_pkts.ElementAt(nIndex);

    if (pCdp->IsModified())
        err = pCdp -> Apply();

    return err;;
}







int  CVirtualRegistry::ApplyAll(void)
{
    int nSize = (int)m_pkts.GetSize();

    // Persist all non-empty data packets
    for (int k = 0; k < nSize; k++)
    {
        Apply(k);
    }

    return ERROR_SUCCESS;
}




int  CVirtualRegistry::Ok(int nIndex)
{
    return 0;
}




int CVirtualRegistry::SearchForRegEntry(HKEY hRoot,
                                        TCHAR *szKeyPath,
                                        TCHAR *szValueName)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket * pCdp = GetAt(k);
        if (pCdp -> IsIdentifiedBy(hRoot, szKeyPath, szValueName))
            return k;
    }

    return -1;
}




int CVirtualRegistry::SearchForLsaEntry(CLSID appid)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket * pCdp = GetAt(k);
        if (pCdp->m_tagType == Password  &&
            g_util.IsEqualGuid(pCdp->pkt.pw.appid, appid))
        {
            return k;
        }
    }

    return -1;
}




int CVirtualRegistry::SearchForSrvEntry(TCHAR *szServiceName)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket * pCdp = GetAt(k);
        if (pCdp->m_tagType == ServiceIdentity                &&
            (_tcscmp(pCdp->pkt.si.szServiceName, szServiceName)))
        {
            return k;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleui\virtreg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       virtreg.h
//
//  Contents:   Defines the class CVirtualRegistry which manages a
//              virtual registry
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------



#ifndef _VIRTREG_H_
#define _VIRTREG_H_

class CVirtualRegistry
{
 public:
    CVirtualRegistry(void);
    ~CVirtualRegistry(void);

    int ReadRegSzNamedValue(HKEY   hRoot,
                          TCHAR *szKeyPath,
                          TCHAR *szValueName,
                          int   *pIndex);

    int ReadRegMultiSzNamedValue(HKEY   hRoot,
                          TCHAR *szKeyPath,
                          TCHAR *szValueName,
                          int   *pIndex);

    int  NewRegSzNamedValue(HKEY    hRoot,
                          TCHAR  *szKeyPath,
                          TCHAR  *szValueName,
                          TCHAR  *szVal,
                          int    *pIndex);

    int  NewRegMultiSzNamedValue(HKEY    hRoot,
                          TCHAR  *szKeyPath,
                          TCHAR  *szValueName,
                          int    *pIndex);

    void ChgRegSzNamedValue(int     nIndex,
                          TCHAR  *szVal);


    int ReadRegDwordNamedValue(HKEY   hRoot,
                             TCHAR *szKeyPath,
                             TCHAR *szValueName,
                             int   *pIndex);

    int NewRegDwordNamedValue(HKEY   hRoot,
                            TCHAR  *szKeyPath,
                            TCHAR  *szValueName,
                            DWORD  dwVal,
                            int   *pIndex);

    void ChgRegDwordNamedValue(int   nIndex,
                             DWORD dwVal);


    int  NewRegSingleACL(HKEY   hRoot,
                       TCHAR  *szKeyPath,
                       TCHAR  *szValueName,
                       SECURITY_DESCRIPTOR *pacl,
                       BOOL   fSelfRelative,
                       int                 *pIndex);

    void ChgRegACL(int                  nIndex,
                 SECURITY_DESCRIPTOR *pacl,
                 BOOL                 fSelfRelative);


    int NewRegKeyACL(HKEY                hKey,
                   HKEY               *phClsids,
                   unsigned            cClsids,
                   TCHAR               *szTitle,
                   SECURITY_DESCRIPTOR *paclOrig,
                   SECURITY_DESCRIPTOR *pacl,
                   BOOL                fSelfRelative,
                   int                 *pIndex);


    int ReadLsaPassword(CLSID &clsid,
                      int   *pIndex);

    int NewLsaPassword(CLSID &clsid,
                     TCHAR  *szPassword,
                     int   *pIndex);

    void ChgLsaPassword(int   nIndex,
                      TCHAR *szPassword);


    int ReadSrvIdentity(TCHAR  *szService,
                      int   *pIndex);

    int NewSrvIdentity(TCHAR  *szService,
                     TCHAR  *szIdentity,
                     int   *pIndex);

    void ChgSrvIdentity(int    nIndex,
                      TCHAR  *szIdentity);

    void MarkForDeletion(int nIndex);
    void MarkHiveForDeletion(int nIndex);

    CDataPacket * GetAt(int nIndex);

    void Remove(int nIndex);

    void RemoveAll(void);

    void Cancel(int nIndex);

    int Apply(int nIndex);

    int ApplyAll(void);

    int Ok(int nIndex);


 private:
    int SearchForRegEntry(HKEY hRoot,
                        TCHAR *szKeyPath,
                        TCHAR *szValueName);

    int SearchForLsaEntry(CLSID appid);

    int SearchForSrvEntry(TCHAR *szServiceName);

    CArray<CDataPacket*, CDataPacket*> m_pkts;
};



extern CVirtualRegistry g_virtreg;

#endif //_VIRTREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    daytona.inc

Abstract:

    This file is included from all of the daytona sources files. It
    is handy for doing things like turning off precompiled headers
    to get around compiler bugs, and other such global activities.

Notes:

    We define _OLE32_ so that when building ole32.dll we don't have
    DECLSPEC_IMPORT defined (see objbase.h)

!ENDIF

C_DEFINES=    \
              $(C_DEFINES)          \
              -DNOEXCEPTIONS        \
              -DINC_OLE2            \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
	      -DCAIROLE_DOWNLEVEL   \
	      -DDCOM		    \
              -DMSWMSG              \
	      -DDCOM_SECURITY       \
              -DNEWPROPS            \
              -D_TRACKLINK_=1       \
              $(TRACELOG)

#  DECLSPEC_IMPORT control (see objbase.h)
!if "$(MINORCOMP)"=="com" || "$(MINORCOMP)"=="stg" || "$(MINORCOMP)"=="ole232" || "$(MINORCOMP)"=="common"
C_DEFINES=    \
              $(C_DEFINES)          \
              -D_OLE32_
!endif

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

MSC_WARNING_LEVEL=/W3 /WX

GPCH_BUILD=daytona
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\dfsetup\dfsetup.cxx ===
#include "windows.h"

__cdecl main(int argc, char **argv)
{
    char szSystemPath[_MAX_PATH];
    
    char szFilename[_MAX_PATH];
    char szCurPath[_MAX_PATH+1];
    
    int len;
    UINT dwFilename = sizeof(szFilename)/sizeof(szFilename[0]);;
    DWORD dwstatus;
    
    if (GetSystemDirectory(szSystemPath, sizeof(szSystemPath)/sizeof(szSystemPath[0])) == 0)
    {
        return (dwstatus = GetLastError());
    }
      

    //Get the path to the install source directory
    if ((len = GetModuleFileName(NULL, szCurPath, sizeof(szCurPath)/sizeof(szCurPath[0]))) == 0)
    {
        return (dwstatus =GetLastError());
    }

    szCurPath[sizeof(szCurPath)/sizeof(szCurPath[0])-1] = '\0';
    
    while (szCurPath[--len] != '\\')
        continue;
    szCurPath[len+1] = '\0';

    // install the file to the system directory
    dwstatus = VerInstallFile(0,"DFLAYOUT.DLL", "DFLAYOUT.DLL",
                              szCurPath, szSystemPath, szSystemPath,
                              szFilename, &dwFilename);
    

    return dwstatus;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1


# include <debnot.h>
# include <sem.hxx>
# include <dllsem.hxx>

extern "C"
{
# include <windows.h>
# include <strsafe.h>
}


unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CDLLStaticMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    char buffer[256];

    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                StringCbPrintfA(buffer, sizeof(buffer), "%d.%03d> ", pid, tid );
                OutputDebugStringA (buffer);
                StringCbPrintfA(buffer, sizeof(buffer), "%s: ", pszComp );
                OutputDebugStringA (buffer);
            }
            StringCbVPrintfA (buffer, sizeof(buffer), ppszfmt, pargs);
            OutputDebugStringA (buffer);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                StringCbPrintfA (buffer, sizeof(buffer), "%03d> ", tid );
                OutputDebugStringA (buffer);
                StringCbPrintfA (buffer, sizeof(buffer), "%s: ", pszComp);
                OutputDebugStringA (buffer);
            }
            StringCbVPrintfA(buffer, sizeof(buffer), ppszfmt, pargs);
            OutputDebugStringA (buffer);
        }

        mxs.Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl _asdprintf( char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    char szAssertCaption[MAX_PATH];
    char szModuleName[256];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, sizeof(szModuleName)))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    StringCbPrintfA(szAssertCaption, sizeof(szAssertCaption),
        "Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);


    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}


#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\dftool\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\docfile\astghead.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:	astghead.cxx
//
//  Contents:	Precompiled header for async
//
//  History:	28-Mar-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ole2.h>
#include <ocidl.h>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <debnot.h>
#include <error.hxx>
#include <except.hxx>
#include <docfilep.hxx>
#include <dfmsp.hxx>


#include "astg.hxx"
#include "asyncerr.hxx"

#if defined (_CHICAGO_)
#include <widewrap.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\docfile\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\dfsetup\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\docfile\asyncapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       asyncapi.cxx
//
//  Contents:   APIs for async docfiles
//
//  Classes:
//
//  Functions:
//
//  History:    19-Dec-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop


#include "filllkb.hxx"

#ifdef ASYNC
#include <expdf.hxx>
#endif


#if DBG == 1
DECLARE_INFOLEVEL(astg);
#endif

#ifdef COORD
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               ITransaction *pTransaction,
               CExposedDocFile **ppdfExp,
               CLSID *pcid);
#else
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               CExposedDocFile **ppdfExp,
               CLSID *pcid);
#endif //COORD

#ifndef KACF_OLE32ENABLEASYNCDOCFILE
#define KACF_OLE32ENABLEASYNCDOCFILE 0x00000200
#endif

BOOL AllowAsyncDocfile()
{
    // By default, StgOpenAsyncDocfileOnIFillLockBytes,
    // StgGetIFillLockBytesOnILockBytes,
    // StgGetIFillLockBytesOnFile are disabled
    return (BOOL)APPCOMPATFLAG(KACF_OLE32ENABLEASYNCDOCFILE);
}

STDAPI StgOpenAsyncDocfileOnIFillLockBytes(IFillLockBytes *pflb,
                                           DWORD grfMode,
                                           DWORD asyncFlags,
                                           IStorage **ppstgOpen)
{
    if (!AllowAsyncDocfile())
        return STG_E_UNIMPLEMENTEDFUNCTION;

    SCODE sc;
    ILockBytes *pilb;
    IStorage *pstg;
    IFileLockBytes *pfl;

    sc = ValidateInterface(pflb, IID_IFillLockBytes);
    if (FAILED(sc))
    {
        return sc;
    }
    sc = ValidateOutPtrBuffer(ppstgOpen);
    if (FAILED(sc))
    {
        return sc;
    }
    *ppstgOpen = NULL;

    //We're going to do a song and dance here because the ILockBytes
    //implementation we return from StgGetIFillLockBytesOnFile won't
    //let you QI for ILockBytes (because those methods aren't thread safe,
    //among other things).  Instead we QI for a private interface and do
    //a direct cast if that succeeds.  Otherwise we're on someone else's
    //implementation so we just go right for ILockBytes.

    sc = pflb->QueryInterface(IID_IFileLockBytes, (void **)&pfl);
    if (FAILED(sc))
    {
	    sc = pflb->QueryInterface(IID_ILockBytes, (void **)&pilb);
	    if (FAILED(sc))
	    {
	        return sc;
	    }
    }
    else
    {
	    pilb = (ILockBytes *)((CFileStream *)pfl);
    }

    //If we're operating on the docfile owned ILockBytes, then we can
    //  go directly to DfFromLB instead of using StgOpenStorageOnILockBytes
    //  which will avoid creating another shared heap.

    if (pfl != NULL)
    {
        pfl->Release();
        pilb = NULL;

        CFileStream *pfst = (CFileStream *)pflb;
        CPerContext *ppc = pfst->GetContextPointer();
#ifdef MULTIHEAP
        CSafeMultiHeap smh(ppc);
#endif

#ifdef COORD
        astgChk(DfFromLB(ppc,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         NULL,
                         (CExposedDocFile **)&pstg,
                         NULL));
#else
        astgChk(DfFromLB(ppc,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         (CExposedDocFile **)&pstg,
                         NULL));
#endif
        //Note:  Don't release the ILB reference we got from the QI
        //  above, since DfFromLB recorded that pointer but didn't
        //  AddRef it.
        pfst->AddRef();  // CExposedDocfile will release this reference
    }
    else
    {
        IFillLockBytes *pflb2;
        if (SUCCEEDED(pilb->QueryInterface(IID_IDefaultFillLockBytes,
                                           (void **)&pflb2)))
        {
            CFillLockBytes *pflbDefault = (CFillLockBytes *)pflb;
            CPerContext *ppc;
            pflb2->Release();
            astgChk(StgOpenStorageOnILockBytes(pilb,
                                               NULL,
                                               grfMode,
                                               NULL,
                                               0,
                                               &pstg));
            //Get PerContext pointer from pstg
            ppc = ((CExposedDocFile *)pstg)->GetContext();
            pflbDefault->SetContext(ppc);
        }
        else
        {
            astgChk(StgOpenStorageOnILockBytes(pilb,
                                               NULL,
                                               grfMode,
                                               NULL,
                                               0,
                                               &pstg));
        }
        pilb->Release();
        pilb = NULL;
    }
    astgChkTo(EH_stg, ((CExposedDocFile *)pstg)->InitConnection(NULL));
    ((CExposedDocFile *)pstg)->SetAsyncFlags(asyncFlags);


    *ppstgOpen = pstg;

    return NOERROR;

EH_stg:
    pstg->Release();
Err:
    if (pilb != NULL)
        pilb->Release();
    if (sc == STG_E_PENDINGCONTROL)
    {
        sc = E_PENDING;
    }
    return ResultFromScode(sc);
}

STDAPI StgGetIFillLockBytesOnILockBytes( ILockBytes *pilb,
					 IFillLockBytes **ppflb)
{
    if (!AllowAsyncDocfile())
        return STG_E_UNIMPLEMENTEDFUNCTION;

    SCODE sc = S_OK;
    CFillLockBytes *pflb = NULL;

    sc = ValidateOutPtrBuffer(ppflb);
    if (FAILED(sc))
    {
        return sc;
    }
    sc = ValidateInterface(pilb, IID_ILockBytes);
    if (FAILED(sc))
    {
        return sc;
    }
    
    pflb = new CFillLockBytes(pilb);
    if (pflb == NULL)
    {
	return STG_E_INSUFFICIENTMEMORY;
    }
    sc = pflb->Init();
    if (FAILED(sc))
    {
        pflb->Release();
	*ppflb = NULL;
	return sc;
    }

    *ppflb = pflb;
    return NOERROR;
}


STDAPI StgGetIFillLockBytesOnFile(OLECHAR const *pwcsName,
				  IFillLockBytes **ppflb)
{
    if (!AllowAsyncDocfile())
        return STG_E_UNIMPLEMENTEDFUNCTION;

    SCODE sc;
    IMalloc *pMalloc;
    CFileStream *plst;
    CFillLockBytes *pflb;
    CPerContext *ppc;

    astgChk(ValidateNameW(pwcsName, _MAX_PATH));
    astgChk(ValidateOutPtrBuffer(ppflb));
    
    DfInitSharedMemBase();
    astgHChk(DfCreateSharedAllocator(&pMalloc, FALSE));
    astgMemTo(EH_Malloc, plst = new (pMalloc) CFileStream(pMalloc));
    astgChkTo(EH_plst, plst->InitGlobal(RSF_CREATE,
                                       DF_DIRECT | DF_READ |
                                       DF_WRITE | DF_DENYALL));
    astgChkTo(EH_plst, plst->InitFile(pwcsName));

    astgMemTo(EH_plstInit, ppc = new (pMalloc) CPerContext(pMalloc));
    astgChkTo(EH_ppc, ppc->InitNewContext());
    //We want 0 normal references on the per context, and one reference
    //  to the shared memory.
    ppc->DecRef();
    plst->SetContext(ppc);
    plst->StartAsyncMode();
    astgChkTo(EH_plstInit, ppc->InitNotificationEvent(plst));

    *ppflb = (IFillLockBytes *)plst;

    return S_OK;

EH_ppc:
    delete ppc;
EH_plstInit:
    plst->Delete();
EH_plst:
    plst->Release();
EH_Malloc:
    pMalloc->Release();
Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\dftool\dftool.cxx ===
#include "windows.h"

__cdecl main(int argc, char **argv)
{
    char szSystemPath[_MAX_PATH];
    
    char szFilename[_MAX_PATH];
    char szCurPath[_MAX_PATH+1];
    
    int len;
    UINT dwFilename = sizeof(szFilename)/sizeof(szFilename[0]);
    DWORD dwstatus;
    
    if (GetSystemDirectory(szSystemPath, sizeof(szSystemPath)/sizeof(szSystemPath[0])) == 0)
    {
        return (dwstatus = GetLastError());
    }
      

    //Get the path to the install source directory
    if ((len = GetModuleFileName(NULL, szCurPath, sizeof(szCurPath)/sizeof(szCurPath[0]))) == 0)
    {
        return (dwstatus =GetLastError());
    }

    szCurPath[sizeof(szCurPath)/sizeof(szCurPath[0])-1] = '\0';
    while (szCurPath[--len] != '\\')
        continue;
    szCurPath[len+1] = '\0';

    // install the file to the system directory
    dwstatus = VerInstallFile(0,"DFLAYOUT.DLL", "DFLAYOUT.DLL",
                              szCurPath, szSystemPath, szSystemPath,
                              szFilename, &dwFilename);
    if (dwstatus)
    {
        return dwstatus;
    }

	
    // install the file to the system directory
    dwFilename = sizeof(szFilename)/sizeof(szFilename[0]);
    dwstatus = VerInstallFile(0,"DFLAYOUT.EXE", "DFLAYOUT.EXE",
                              szCurPath, szSystemPath, szSystemPath,
                              szFilename, &dwFilename);


    return dwstatus;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\h\valid.h ===
#if DBG==1 && defined(WIN32) && !defined(_CHICAGO_)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32) && !defined(_CHICAGO_)

#define IsValidPtrIn(pv,cb)  (true)
#define IsValidPtrOut(pv,cb) (pv != NULL)

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__); goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); retVar = retval;  goto label; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\docfile\daytona\makefile.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!ifndef MIDL
MIDL = midl.exe
!endif


SDKINC=$(BASEDIR)\public\sdk\inc
INCLUDES=$(SDKINC);$(INCLUDES)
MIDL_UUIDDIR=$(O)
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_TLBDIR=$(O)

MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Oicf \
 -oldnames \
 -char unsigned \
 -error allocation \
 -ms_ext -c_ext \
 -robust \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES)

SSWITCH=-prefix sstub _

$(O)\iconn.h:	..\iconn.idl
     $(MIDL) $(MIDL_FLAGS) -out $(O) -header iconn.h  iconn.idl

DEST_TREE=daytona

allidl:   $(O)\iconn.h

clean:
	  -erase $(O)\iconn.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\layapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	layapi.cxx
//
//  Contents:	API for layout tool
//
//  Classes:	
//
//  Functions:	
//
//  History:	12-Feb-96	PhilipLa	Created
//              21-Feb-96       SusiA           New API, moved ReLayoutDocfile to method
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include <header.hxx>

#include "laylkb.hxx"
#include "laywrap.hxx"

#if DBG == 1
DECLARE_INFOLEVEL(lay);
#endif

STDAPI StgOpenLayoutDocfile(OLECHAR const *pwcsDfName,
                            DWORD grfMode,
                            DWORD reserved,
                            IStorage **ppstgOpen)
{
    SCODE sc;
    CLayoutLockBytes *pllkb;
    IStorage *pstg;

    if ((reserved != 0) ||  (!ppstgOpen))
    {
        return STG_E_INVALIDPARAMETER;
    }
    if (!(pwcsDfName))
    {
        return STG_E_INVALIDNAME;
    }
    
    pllkb = new CLayoutLockBytes();
    if (pllkb == NULL)
    {
	return STG_E_INSUFFICIENTMEMORY;
    }

    if (FAILED(sc = pllkb->Init(pwcsDfName, grfMode)))
    {
        pllkb->Release();
        return sc;
    }
    
    sc = StgOpenStorageOnILockBytes(pllkb,
				    NULL,
				    grfMode,
				    NULL,
				    0,
				    &pstg);

    if (FAILED(sc))
    {
        pllkb->Release();
	return sc;
    }

    *ppstgOpen = new CLayoutRootStorage(pstg, pllkb);
    if (*ppstgOpen == NULL)
    {
        pstg->Release();
        pllkb->Release();
	return STG_E_INSUFFICIENTMEMORY;
    }

    pstg->Release();
    pllkb->Release();
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\docfile\filllkb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	filllkb.cxx
//
//  Contents:	IFillLockBytes and ILockBytes wrapper for async docfiles
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include "filllkb.hxx"
#include <valid.h>
#include <utils.hxx>


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::CFillLockBytes, public
//
//  Synopsis:	Default constructor
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFillLockBytes::CFillLockBytes(ILockBytes *pilb)
{
    _pilb = pilb;
    pilb->AddRef();
    _ulHighWater = 0;
    _ulFailurePoint = 0;
    _dwTerminate = UNTERMINATED;
#ifdef ASYNC
    _ppc = NULL;
#else
    _hNotifyEvent = INVALID_HANDLE_VALUE;
#endif
    _fCSInitialized = FALSE;
    _cRefs = 1;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::~CFillLockBytes, public
//
//  Synopsis:	Destructor
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFillLockBytes::~CFillLockBytes()
{
    astgAssert(_pilb == NULL);
#ifdef ASYNC
#ifdef MULTIHEAP    
    if (_ppc)
    {
        CSafeMultiHeap smh(_ppc);
        if (_ppc->ReleaseSharedMem() == 0)
            g_smAllocator.Uninit();
    }
#endif    
#else
    if (_hNotifyEvent != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hNotifyEvent);
    }
#endif
    if (_fCSInitialized)
        DeleteCriticalSection(&_csThreadProtect);
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Init, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CFillLockBytes::Init(void)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Init:%p()\n", this));

    if (FALSE == _fCSInitialized)
    {
        __try
        {
            InitializeCriticalSection(&_csThreadProtect);
            _fCSInitialized = TRUE;
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return HRESULT_FROM_WIN32( GetExceptionCode() );
        }
    }

#ifndef ASYNC
    _hNotifyEvent = CreateEvent(NULL,
                                TRUE,
                                FALSE,
                                NULL);
    if (_hNotifyEvent == NULL)
    {
        return Win32ErrorToScode(GetLastError());
    }
#endif    

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Init\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CFillLockBytes::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFillLockBytes::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::QueryInterface(?, %p)\n",
                ppvObj));
    
    astgChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;

    sc = S_OK;
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (ILockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_ILockBytes))
    {
        *ppvObj = (ILockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_IFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
        CFillLockBytes::AddRef();
    }
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IFillInfo))
    {
        *ppvObj = (IFillInfo *)this;
        CFillLockBytes::AddRef();
    }
#endif    
    else if (IsEqualIID(iid, IID_IDefaultFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::QueryInterface => %p\n",
                ppvObj));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CFillLockBytes::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CFillLockBytes::AddRef(void)
{
    InterlockedIncrement (&_cRefs);
    return _cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Release, public
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFillLockBytes::Release(void)
{
    LONG lRet;
    InterlockedDecrement (&_cRefs);
    lRet = _cRefs;

    if (lRet == 0)
    {
        _pilb->Release();
        _pilb = NULL;
        delete this;
    }
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::ReadAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::ReadAt(ULARGE_INTEGER ulOffset,
                                    VOID HUGEP *pv,
                                    ULONG cb,
                                    ULONG *pcbRead)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::ReadAt:%p()\n", this));

    if (NULL == pv || NULL == pcbRead)
        return STG_E_INVALIDPARAMETER;

        if (_dwTerminate == TERMINATED_ABNORMAL)
        {
            sc = STG_E_INCOMPLETE;
        }
        else if ((_dwTerminate == TERMINATED_NORMAL) ||
                 (ULIGetLow(ulOffset) + cb <= _ulHighWater))
        {
            sc = _pilb->ReadAt(ulOffset, pv, cb, pcbRead);
        }
        else
        {
            *pcbRead = 0;
            _ulFailurePoint = cb + ULIGetLow(ulOffset);
            sc = E_PENDING;
        }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::ReadAt\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::WriteAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::WriteAt(ULARGE_INTEGER ulOffset,
                                     VOID const HUGEP *pv,
                                     ULONG cb,
                                     ULONG *pcbWritten)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::WriteAt:%p()\n", this));

    if (NULL == pv || NULL == pcbWritten)
        return STG_E_INVALIDPARAMETER;

        if (_dwTerminate == TERMINATED_ABNORMAL)
        {
            sc = STG_E_INCOMPLETE;
        }
        else if ((_dwTerminate == TERMINATED_NORMAL) ||
                 (ULIGetLow(ulOffset) + cb <= _ulHighWater))
        {
            sc = _pilb->WriteAt(ulOffset, pv, cb, pcbWritten);
        }
        else
        {
            *pcbWritten = 0;
            _ulFailurePoint = cb + ULIGetLow(ulOffset);
            sc = E_PENDING;
        }
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::WriteAt\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Flush, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Flush(void)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Flush:%p()\n", this));
    sc = _pilb->Flush();
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Flush\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::SetSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::SetSize(ULARGE_INTEGER cb)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetSize:%p()\n", this));

        if (_dwTerminate == TERMINATED_ABNORMAL)
        {
            sc = STG_E_INCOMPLETE;
        }
        else if ((_dwTerminate == TERMINATED_NORMAL) ||
                 (ULIGetLow(cb) <= _ulHighWater))
        {
            sc = _pilb->SetSize(cb);
        }
        else
        {
            _ulFailurePoint = ULIGetLow(cb);
            sc = E_PENDING;
        }
        
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetSize\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::LockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::LockRegion:%p()\n", this));

    sc = _pilb->LockRegion(libOffset, cb, dwLockType);

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::LockRegion\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::UnlockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::UnlockRegion:%p()\n", this));
    sc = _pilb->UnlockRegion(libOffset, cb, dwLockType);
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::UnlockRegion\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Stat, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Stat:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->Stat(pstatstg, grfStatFlag);
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Stat\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::FillAppend, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::FillAppend(void const *pv,
                                        ULONG cb,
                                        ULONG *pcbWritten)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::FillAppend:%p()\n", this));

    sc = ValidateBuffer (pv, cb);
    if (!SUCCEEDED(sc))
        return sc;

    if (_dwTerminate != UNTERMINATED)
    {
        sc = STG_E_TERMINATED;
    }
    else
    {
        ULONG cbWritten;
        ULARGE_INTEGER uli;
        uli.QuadPart = _ulHighWater;
        sc = _pilb->WriteAt(uli, pv, cb, &cbWritten);
        _ulHighWater += cbWritten;
        if (pcbWritten != NULL)
        {
            *pcbWritten = cbWritten;
        }
#ifdef ASYNC        
        if (_ppc)
        {
            HANDLE hEvent = _ppc->GetNotificationEvent();
            if (!PulseEvent(hEvent))
            {
                sc = Win32ErrorToScode(GetLastError());
            }
        }
#else
        if (!PulseEvent(_hNotifyEvent))
        {
            sc = Win32ErrorToScode(GetLastError());
        }
#endif        
    }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::FillAppend\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::FillAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::FillAt(ULARGE_INTEGER ulOffset,
                                    void const *pv,
                                    ULONG cb,
                                    ULONG *pcbWritten)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::FillAt:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::FillAt\n"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::SetFillSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::SetFillSize(ULARGE_INTEGER ulSize)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetFillSize:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->SetSize(ulSize);
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetFillSize\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Terminate, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Terminate(BOOL bCanceled)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Terminate:%p()\n", this));
    _dwTerminate = (bCanceled) ? TERMINATED_ABNORMAL : TERMINATED_NORMAL;
#ifdef ASYNC
    if (_ppc)
    {
        HANDLE hEvent = _ppc->GetNotificationEvent();
        if (!SetEvent(hEvent))
        {
            return Win32ErrorToScode(GetLastError());
        }
    }
#else
    if (!SetEvent(_hNotifyEvent))
    {
        return Win32ErrorToScode(GetLastError());
    }
#endif    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Terminate\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetFailureInfo, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::GetFailureInfo(ULONG *pulWaterMark,
                                            ULONG *pulFailurePoint)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CFillLockBytes::GetFailureInfo:%p()\n", this));
    *pulWaterMark = _ulHighWater;
    *pulFailurePoint = _ulFailurePoint;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetFailureInfo\n"));
    return S_OK;
}

#ifndef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetNotificationEvent, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

HANDLE CFillLockBytes::GetNotificationEvent(void)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::GetNotificationEvent:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetNotificationEvent\n"));
    return _hNotifyEvent;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetTerminationStatus, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::GetTerminationStatus(DWORD *pdwFlags)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CFillLockBytes::GetTerminationStatus:%p()\n", this));
    *pdwFlags = _dwTerminate;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetTerminationStatus\n"));
    return S_OK;
}



SCODE CFillLockBytes::SetFailureInfo(ULONG ulWaterMark,
                                     ULONG ulFailurePoint)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetFailureInfo:%p()\n", this));
    _ulHighWater =ulWaterMark;
    _ulFailurePoint = ulFailurePoint ;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetFailureInfo\n"));
    return S_OK;
}
#if DBG==1
void CFillLockBytes::PulseFillEvent()
{
#ifdef ASYNC    
    if (_ppc)
    {
        HANDLE hEvent = _ppc->GetNotificationEvent();
        PulseEvent(hEvent);
    }
#else
    PulseEvent(_hNotifyEvent);
#endif    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\laylkb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	laylkb.cxx
//
//  Contents:	File ILockBytes implementation for layout storage
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include "laylkb.hxx"
#include <valid.h>
#include <dfver.h>


class CSafeCriticalSection
{
public:
    inline CSafeCriticalSection(CRITICAL_SECTION *pcs);
    inline ~CSafeCriticalSection();
private:
    CRITICAL_SECTION *_pcs;
};

inline CSafeCriticalSection::CSafeCriticalSection(CRITICAL_SECTION *pcs)
{
    _pcs = pcs;
    EnterCriticalSection(_pcs);
}

inline CSafeCriticalSection::~CSafeCriticalSection()
{
    LeaveCriticalSection(_pcs);
#if DBG == 1
    _pcs = NULL;
#endif
}

#define TAKE_CS CSafeCriticalSection scs(&_cs);
    


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::CLayoutLockBytes, public
//
//  Synopsis:	Default constructor
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

CLayoutLockBytes::CLayoutLockBytes(void)
{
    _cReferences = 1;
    _h = INVALID_HANDLE_VALUE;
    _hScript = INVALID_HANDLE_VALUE;
    _fLogging = FALSE;
    _cbSectorShift = 0;
    _atcScriptName[0] = TEXT('\0');
    _awcName[0] = L'\0';
    _fCSInitialized = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::~CLayoutLockBytes, public
//
//  Synopsis:	Destructor
//
//  Returns:	Appropriate status code
//
//  History:	20-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

CLayoutLockBytes::~CLayoutLockBytes()
{
    if (_h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_h);
        _h = INVALID_HANDLE_VALUE;
    }
    if (_hScript != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hScript);
        _hScript = INVALID_HANDLE_VALUE;
    }

    if (_fCSInitialized)
        DeleteCriticalSection(&_cs);
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Init, public
//
//  Synopsis:	Initialization function
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CLayoutLockBytes::Init(OLECHAR const *pwcsName,
                             DWORD grfMode)
{
    SCODE sc = S_OK;
    BYTE abHeader[sizeof(CMSFHeaderData)];
    ULONG cbRead;

    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Init:%p()\n", this));
    
    if (pwcsName == NULL)
        return STG_E_INVALIDNAME;

    if (FALSE == _fCSInitialized)
    {
        __try
        {
            InitializeCriticalSection(&_cs);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return HRESULT_FROM_WIN32( GetExceptionCode() );
        }

        _fCSInitialized = TRUE;
    }

    _grfMode = grfMode;

#ifndef UNICODE
    TCHAR atcPath[MAX_PATH + 1];
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (!WideCharToMultiByte(
        uCodePage,
        0,
        pwcsName,
        -1,
        atcPath,
        MAX_PATH + 1,
        NULL,
        NULL))
    {
        return STG_E_INVALIDNAME;
    }

    _h = CreateFileA(atcPath,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING,                   
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);
#else    
    _h = CreateFile(pwcsName,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING,                   
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);
#endif    
  
    if (_h == INVALID_HANDLE_VALUE)
    {
        layErr(Err, Win32ErrorToScode(GetLastError()));
    }

    layChk(StringCbCopyW(_awcName, sizeof(_awcName), pwcsName));

    //Get the sector size
    boolChk(ReadFile(_h, abHeader, sizeof(CMSFHeaderData), &cbRead, NULL));
    if (cbRead != sizeof(CMSFHeaderData))
    {
        return STG_E_READFAULT;
    }
    
    _cbSectorShift = ((CMSFHeaderData *)abHeader)->_uSectorShift;

    if (((CMSFHeaderData*)abHeader)->_uDllVersion > rmjlarge)
        return STG_E_OLDDLL;

    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Init\n"));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CLayoutLockBytes::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::QueryInterface(?, %p)\n",
                 ppvObj));
    
    layChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;

    sc = S_OK;
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IUnknown *)this;
        CLayoutLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_ILockBytes))
    {
        *ppvObj = (ILockBytes *)this;
        CLayoutLockBytes::AddRef();
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::QueryInterface => %p\n",
                 ppvObj));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CLayoutLockBytes::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutLockBytes::AddRef(void)
{
    LONG lRet;

    layDebugOut((DEB_TRACE, "In  CLayoutLockBytes::AddRef()\n"));

    lRet = InterlockedIncrement(&_cReferences);

    layDebugOut((DEB_TRACE, "Out CLayoutLockBytes::AddRef\n"));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Release, public
//
//  History:	20-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutLockBytes::Release(void)
{
    LONG lRet;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        delete this;
    }

    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Release\n"));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::ReadAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::ReadAt(ULARGE_INTEGER ulOffset,
                                      VOID HUGEP *pv,
                                      ULONG cb,
                                      ULONG *pcbRead)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::ReadAt:%p()\n", this));

    ULONG ulLow = ulOffset.LowPart;
    LONG lHigh = (LONG)ulOffset.HighPart;

    if ((_fLogging)&&(ulOffset.QuadPart >= sizeof(CMSFHeaderData)))
    {
        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return STG_E_INVALIDHANDLE;
        }

        ULONG ulFirstSector = (ULONG) ((ulOffset.QuadPart -
                                       ((ULONGLONG)1 << _cbSectorShift))
                                       >> _cbSectorShift);
        
        ULONG ulLastSector = (ULONG) ((ulOffset.QuadPart + (cb - 1) -
                                      ((ULONGLONG)1 << _cbSectorShift)) 
                                      >> _cbSectorShift);
        ULONG ulSect;
        ULONG cbScriptWritten;

        for (ulSect = ulFirstSector; ulSect <= ulLastSector; ulSect++)
        {
            
            layAssert(_hScript !=INVALID_HANDLE_VALUE);

            boolChk(WriteFile(_hScript,
                              (VOID *)&ulSect,
                              sizeof(ULONG),
                              &cbScriptWritten,
                              NULL));


            if (cbScriptWritten != sizeof(ULONG))
            {
                return STG_E_WRITEFAULT;
            }
        }    
    }

    negChk(SetFilePointer(_h,
                          ulLow,
                          &lHigh,
                          FILE_BEGIN));
    boolChk(ReadFile(_h, pv, cb, pcbRead, NULL));
    
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::ReadAt\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::WriteAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::WriteAt(ULARGE_INTEGER ulOffset,
                                       VOID const HUGEP *pv,
                                       ULONG cb,
                                       ULONG *pcbWritten)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::WriteAt:%p()\n", this));

    ULONG ulLow = ulOffset.LowPart;
    LONG lHigh = (LONG)ulOffset.HighPart;

    if ((_fLogging)&&(ulOffset.QuadPart >= sizeof(CMSFHeaderData)))
    {
        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return STG_E_INVALIDHANDLE;
        }

        ULONG ulFirstSector = (ULONG) ((ulOffset.QuadPart -
                                       ((ULONGLONG)1 << _cbSectorShift))
                                       >> _cbSectorShift);
        ULONG ulLastSector = (ULONG) ((ulOffset.QuadPart + (cb - 1) -
                                      ((ULONGLONG)1 << _cbSectorShift)) 
                                      >> _cbSectorShift);
        ULONG ulSect;
        ULONG cbScriptWritten;

        for (ulSect = ulFirstSector; ulSect <= ulLastSector; ulSect++)
        {
            boolChk(WriteFile(_hScript,
                              (VOID *)&ulSect,
                              sizeof(ULONG),
                              &cbScriptWritten,
                              NULL));
            if (cbScriptWritten != sizeof(ULONG))
            {
                return STG_E_WRITEFAULT;
            }
        }    
    }
    
    negChk(SetFilePointer(_h,
                          ulLow,
                          &lHigh,
                          FILE_BEGIN));
    boolChk(WriteFile(_h, pv, cb, pcbWritten, NULL));
    
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::WriteAt\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Flush, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::Flush(void)
{
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Flush:%p()\n", this));
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Flush\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::SetSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::SetSize(ULARGE_INTEGER cb)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::SetSize:%p()\n", this));
    LONG lHigh = (LONG)cb.HighPart;
    ULONG ulLow = cb.LowPart;

    negChk(SetFilePointer(_h, ulLow, &lHigh, FILE_BEGIN));
    boolChk(SetEndOfFile(_h));
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::SetSize\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::LockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::LockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::LockRegion:%p()\n", this));
    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    boolChk(LockFile(_h,
                     libOffset.LowPart,
                     libOffset.HighPart,
                     cb.LowPart,
                     cb.HighPart));
            
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::LockRegion\n"));
Err:    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::UnlockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::UnlockRegion(ULARGE_INTEGER libOffset,
                                            ULARGE_INTEGER cb,
                                            DWORD dwLockType)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::UnlockRegion:%p()\n", this));
    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    boolChk(UnlockFile(_h,
                       libOffset.LowPart,
                       libOffset.HighPart,
                       cb.LowPart,
                       cb.HighPart));
            
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::UnlockRegion\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Stat, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc;

    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Stat:%p()\n", this));

    negChk(pstatstg->cbSize.LowPart =
           GetFileSize(_h, &pstatstg->cbSize.HighPart));
    boolChk(GetFileTime(_h, &pstatstg->ctime, &pstatstg->atime,
                        &pstatstg->mtime));
    pstatstg->grfLocksSupported = LOCK_EXCLUSIVE | LOCK_ONLYONCE;
    
    pstatstg->type = STGTY_LOCKBYTES;
    pstatstg->grfMode = _grfMode;
    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        pstatstg->pwcsName = (OLECHAR *)CoTaskMemAlloc(
             (lstrlenW(_awcName) + 1) * sizeof(OLECHAR));
        if (pstatstg->pwcsName == NULL)
            return STG_E_INSUFFICIENTMEMORY;

        StringCchCopyW (pstatstg->pwcsName, lstrlenW(_awcName)+1, _awcName);
    }
    sc = S_OK;

    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Stat\n"));
    return NOERROR;

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::StartLogging, public
//
//  Returns:	Appropriate status code
//
//  Modifies:	_fLogging
//
//  History:	24-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CLayoutLockBytes::StartLogging(void)
{
    CSafeCriticalSection scs(&_cs);
    
    OLECHAR acTempPathName[MAX_PATH + 1];
    SCODE sc = S_OK;

    if (_fLogging)
    {
        return STG_E_INUSE;                   //logging already started!
    }
    

    if (_atcScriptName[0] != TEXT('\0'))
    {
        LONG dwDistanceToMoveHigh = 0;
        
        //Script has already been started.  Need to reopen it and seek
        //  to the end.
#ifndef UNICODE
        _hScript = CreateFileA
#else
        _hScript = CreateFile
#endif        
                   (_atcScriptName,
                    GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);

        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return LAST_STG_SCODE;
        }
        
        negChk(SetFilePointer(_hScript, 0, &dwDistanceToMoveHigh, FILE_END));
    }
    else
    {
        TCHAR atcPath[MAX_PATH + 1];
        //Generate the script name, then create it.
        
        UINT ui = GetTempPath(MAX_PATH, atcPath);
        if (0 == ui)
        {
            layErr(Err, Win32ErrorToScode(GetLastError()));
        }
        else if (ui > MAX_PATH)
        {
            layErr(Err, STG_E_PATHNOTFOUND);
        }

        boolChk(GetTempFileName(atcPath, TEXT("SCR"), 0, _atcScriptName));
        
        //GetTempFileName actually creates the file, so we open with
        //  OPEN_EXISTING
#ifndef UNICODE
        _hScript = CreateFileA
#else
        _hScript = CreateFile
#endif        
                   (_atcScriptName,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING, 
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);

        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return LAST_STG_SCODE;
        }
    }
    
    _fLogging = TRUE;

Err:
    return sc; 		
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::StopLogging, public
//
//  Returns:	Appropriate status code
//
//  Modifies:	_fLogging
//
//  History:	24-Feb-96	SusiA	Created
//
//  Notes:	
//
//-----------------------------------------------------------------------------
SCODE CLayoutLockBytes::StopLogging(void)
{
    SCODE sc = S_OK;
    CSafeCriticalSection scs(&_cs);
    
    if (!_fLogging)
    {
        return STG_E_UNKNOWN;
    }
    
    boolChk(CloseHandle(_hScript));
    _hScript = INVALID_HANDLE_VALUE; 
    _fLogging = FALSE;

Err:
    return sc; 		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\docfile\stgconn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:	stgconn.cxx
//
//  Contents:	Connection points for Async Storage/Stream Wrappers
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include <sinklist.hxx>
#include <utils.hxx>

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::CConnectionPoint, public
//
//  Synopsis:	Constructor
//
//  Arguments:
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

CConnectionPoint::CConnectionPoint()
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::CConnectionPoint:%p()\n", this));
    _cReferences = 1;
    _dwCookie = 0;
    _pSinkHead = NULL;
    _pParentCP = NULL;

    _fCSInitialized = FALSE;
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::CConnectionPoint\n"));
}


CConnectionPoint::~CConnectionPoint()
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::~CConnectionPoint:%p()\n", this));
    TakeCS();
    if (_pParentCP)
        _pParentCP->Release();

    // clean up the advise list
    CSinkList *psltemp = _pSinkHead;
    CSinkList *pslprev = NULL;
    
    while (psltemp)
    {
        pslprev = psltemp;
        psltemp = psltemp->GetNext();
        pslprev->GetProgressNotify()->Release();
        delete pslprev;
    }

    if (_fCSInitialized)
    {
        ReleaseCS();
        DeleteCriticalSection(&_csSinkList);
    }
    
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::~CConnectionPoint\n"));
}

SCODE CConnectionPoint::Init()
{
    if (FALSE == _fCSInitialized)
    {
        __try
        {
            InitializeCriticalSection(&_csSinkList);
            _fCSInitialized = TRUE;
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return HRESULT_FROM_WIN32( GetExceptionCode() );
        }
    }
    return S_OK;
}

#ifndef ASYNC
void CConnectionPoint::Init(IConnectionPointContainer *pCPC)
{
    _pCPC = pCPC;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Notify,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	14-Jan-96	SusiA	Created
//              27-Feb-96       SusiA   Moved from Async wrappers 
//
//----------------------------------------------------------------------------
SCODE CConnectionPoint::Notify(SCODE scFailure,
                               IFillLockBytes *piflb,
                               BOOL fDefaultLockBytes)
{
    SCODE sc = S_OK;
    BOOL fAccurate = (scFailure == E_PENDING);
    ULONG ulWaterMark;
    ULONG ulFailurePoint;

    HANDLE hNotifyEvent;

    if (fDefaultLockBytes)
    {
        CFillLockBytes *pflb = (CFillLockBytes *)piflb;
        
        pflb->GetFailureInfo(&ulWaterMark,
                             &ulFailurePoint);

        pflb->ReleaseCriticalSection();
        
        while (((sc = NotifySinks(ulWaterMark,
                                  ulFailurePoint,
                                  fAccurate, 
                                  STG_S_MONITORING)) == STG_S_BLOCK) ||
               (sc == STG_S_MONITORING) ||
               // S_OK is a synonym for STG_S_MONITORING
               (sc == S_OK))
        {	
            DWORD dwFlags;
            
            // wait for an event to signal
            hNotifyEvent = pflb->GetNotificationEvent();
            WaitForSingleObject(hNotifyEvent, INFINITE);
			
            pflb->GetTerminationStatus(&dwFlags);
            // client terminated call?
            if (dwFlags == TERMINATED_ABNORMAL)
                return STG_E_INCOMPLETE;

            // download is complete
            else if (dwFlags == TERMINATED_NORMAL)
                return S_OK;

            else
            {
                //Note:  Don't overwrite the failure point we recorded
                //  before, since it may have been changed by some
                //  other thread.
                
                //Don't need to take the critical section here, since
                //we don't care about the current failure point.
                ULONG ulFailurePointCurrent;
                pflb->GetFailureInfo(&ulWaterMark,
                                     &ulFailurePointCurrent);

                // all the data is available now
                if (ulWaterMark >= ulFailurePoint)
                {
                    // we won't care what the return value is, so send STG_S_BLOCK,
                    // and all sinks are will have fOwner == FALSE
                    NotifySinks(ulWaterMark, ulFailurePoint, fAccurate, STG_S_BLOCK);
                    break;
                }
            }
				
        }
    }
    
    if ((sc == STG_S_RETRYNOW) || (sc == STG_S_BLOCK) || (sc == STG_S_MONITORING))
        return S_OK;
    else return sc;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::NotifySinks,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	23-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

SCODE CConnectionPoint::NotifySinks(ULONG ulProgressCurrent,
                                    ULONG ulProgressMaximum,
                                    BOOL  fAccurate,
                                    SCODE sc)
{
    
    CSinkList *pslTemp;
    TakeCS();


    // closest node with a connection point that wants to determine
    // behavior does
    // priority first to last on this Connection Point, then the 
    // parent connection point.

    pslTemp = GetHead();
	
    while (((sc == S_OK) ||(sc == STG_S_MONITORING))
            &&(pslTemp!=NULL))
    {
        sc = pslTemp->GetProgressNotify()
            ->OnProgress(ulProgressCurrent, ulProgressMaximum, fAccurate, TRUE);
        pslTemp = pslTemp->GetNext();
    }

    // notify the rest of the connections
    while (pslTemp !=NULL)
    {
        pslTemp->GetProgressNotify()
            ->OnProgress(ulProgressCurrent, ulProgressMaximum, fAccurate, FALSE);
        pslTemp = pslTemp->GetNext();
    }

    //call parent storage advise list next
    if (_pParentCP)
        sc = _pParentCP->NotifySinks(ulProgressCurrent,
                                     ulProgressMaximum,
                                     fAccurate,
                                     sc);
    
    ReleaseCS();
    return sc;

	
}

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::QueryInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	01-Jan-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::QueryInterface:%p()\n",
                  this));

    *ppvObj = NULL;

    if ((IsEqualIID(iid, IID_IUnknown)) ||
	(IsEqualIID(iid, IID_IDocfileAsyncConnectionPoint)))
    {
        *ppvObj = (IDocfileAsyncConnectionPoint *)this;
        CConnectionPoint::AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::QueryInterface\n"));
    return ResultFromScode(sc);
}



//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::AddRef, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void)
{
    LONG lRet;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::AddRef:%p()\n",
                  this));
    lRet = InterlockedIncrement(&_cReferences);
    
    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::AddRef\n"));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Release, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPoint::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::Release:%p()\n",
                  this));

    astgAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);

    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
    { 
        astgAssert((lRet > 0) && "Connection point released too many times.");
    }
    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::Release\n"));
    return lRet;
}

#ifndef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::GetConnectionInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CConnectionPoint::GetConnectionInterface:%p()\n",
                  this));

    
    *pIID = IID_IProgressNotify;
          
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::GetConnectionInterface\n"));
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::GetConnectionPointContainer, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CConnectionPoint::GetConnectionPointContainer:%p()\n",
                  this));

    *ppCPC = _pCPC;
    _pCPC->AddRef();
    
    astgDebugOut((DEB_ITRACE,
                  "Out CConnectionPoint::GetConnectionPointContainer\n"));
    return S_OK;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Clone, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	26-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CConnectionPoint::Clone( CConnectionPoint *pcp)
{
    SCODE sc = S_OK;
    void *pv = NULL;

    astgDebugOut((DEB_ITRACE,"In  CConnectionPoint::Clone:%p()\n", this));

    TakeCS();
    pcp->TakeCS();

    CSinkList *pslNew = NULL;
    CSinkList *pslPrev = NULL;
    CSinkList *pslOld = pcp->GetHead();
    
    

    while (pslOld != NULL)
    {   
        astgMem(pslNew = new CSinkList);
        
        pslNew->SetNext(NULL);

        if (pslPrev)
            pslPrev->SetNext(pslNew);
        else
            _pSinkHead = pslNew;
        
        pslPrev = pslNew;
        
        pslNew->SetCookie(pslOld->GetCookie());
        
        //Note:  The QueryInterface will give us a reference to hold on to.
        astgChk(pslOld->GetProgressNotify()->QueryInterface(IID_IProgressNotify, &pv));
        pslNew->SetProgressNotify((IProgressNotify *)pv);
        
        pslOld= pslOld->GetNext();
    }

    _dwCookie = pcp->GetCookie();
    
    astgDebugOut((DEB_ITRACE,"Out CConnectionPoint::Clone\n"));

Err:
    while (_pSinkHead != NULL)
    {
        CSinkList *pSinkNext = _pSinkHead;
        delete _pSinkHead;
        _pSinkHead = pSinkNext;
    }

    pcp->ReleaseCS();
    ReleaseCS();

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint:: Advise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------
#ifdef ASYNC
STDMETHODIMP CConnectionPoint::AddConnection(IProgressNotify *pSink,
                                             DWORD *pdwCookie)
#else
STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnkSink,
                                      DWORD *pdwCookie)
#endif
{
    SCODE sc = S_OK;
    CSinkList *pslNew = NULL;
    CSinkList *pslTemp = _pSinkHead;
    
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::Advise:%p()\n", this));
    TakeCS();
    
    IProgressNotify *ppn;
	
    astgMem(pslNew = new CSinkList);
    *pdwCookie = ++_dwCookie;
    pslNew->SetCookie(*pdwCookie);
    
#ifdef ASYNC
    pSink->AddRef();
    pslNew->SetProgressNotify(pSink);
#else
    void *pv;
    //Note:  The QueryInterface will give us a reference to hold on to.
    astgChk(pUnkSink->QueryInterface(IID_IProgressNotify, &pv));
    pslNew->SetProgressNotify((IProgressNotify *)pv);
#endif
    
    //Add new node to end of list
    if (pslTemp == NULL)
        _pSinkHead = pslNew;
    else
    {
        while(pslTemp->GetNext() != NULL)
            pslTemp = pslTemp->GetNext();
        pslTemp->SetNext(pslNew); 
    }
    ReleaseCS();

    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::Advise\n"));
    return sc;
Err:
    ReleaseCS();
    delete pslNew;
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Unadvise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

#ifdef ASYNC
STDMETHODIMP CConnectionPoint::RemoveConnection(DWORD dwCookie)
#else
STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
#endif
{
    CSinkList *pslTemp;
    CSinkList *pslPrev;
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::Unadvise:%p()\n", this));
    
    TakeCS();
    
    pslTemp = _pSinkHead;
    pslPrev = NULL;
    
    while ((pslTemp != NULL) && (pslTemp->GetCookie() != dwCookie))
    {
        pslPrev = pslTemp;
        pslTemp = pslTemp->GetNext();
    }

    if (pslTemp != NULL)
    {
        //Found the sink.  Delete it from the list.
        if (pslPrev != NULL)
        {
            pslPrev->SetNext(pslTemp->GetNext());
        }
        else
        {
            _pSinkHead = pslTemp->GetNext();
        }
        pslTemp->GetProgressNotify()->Release();
        
        delete pslTemp;
    }
    else
    {   //Client passed in unknown cookie.
        ReleaseCS();
        return E_UNEXPECTED;
    }
    ReleaseCS();

    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::Unadvise\n"));
    return S_OK;
}

#ifndef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::EnumConnections, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::EnumConnections(
    IEnumConnections **ppEnum)
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::EnumConnections:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::EnumConnections\n"));
    return E_NOTIMPL;
}
#endif

#ifdef ASYNC
STDMETHODIMP CConnectionPoint::GetParent(IDocfileAsyncConnectionPoint **ppdacp)
{
    *ppdacp = _pParentCP;
    return S_OK;
}
#endif

void CConnectionPoint::TakeCS(void)
{
    astgAssert (_fCSInitialized);
    EnterCriticalSection(&_csSinkList);
}

void CConnectionPoint::ReleaseCS(void)
{
    astgAssert (_fCSInitialized);
    LeaveCriticalSection(&_csSinkList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\layout.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layout.cxx
//
//  Contents:	Code for the relayout tool
//
//  Classes:	
//
//  Functions:	
//
//  History:	12-Feb-96	PhilipLa	Created
//              21-Feb-96       SusiA           Put funtions on ILayoutStorage
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include <dirfunc.hxx>
#include "laylkb.hxx"
#include "laywrap.hxx"

#include <stddef.h>

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::LayoutScript
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pStorageLayout] -- Pointer to storage layout array
//              [nEntries] -- Number of entries in the array
//              [grfInterleavedFlag] -- Specifies disposition of control
//                                      structures
//
//  Returns:	Appropriate status code
//
//  History:	21-Feb-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::LayoutScript( StorageLayout  *pStorageLayout,
                                               DWORD nEntries,
                                               DWORD glfInterleavedFlag)
{

    SCODE sc;

    if ((LONG)nEntries < 0)
    {
        return E_INVALIDARG;
    }
    
    if ((LONG)nEntries == 0)
    {
        return  S_OK;
    }
    
    if ((glfInterleavedFlag != STG_LAYOUT_INTERLEAVED) &&
        (glfInterleavedFlag != STG_LAYOUT_SEQUENTIAL )   )
    {    
        return STG_E_INVALIDFLAG;
    }

    if (pStorageLayout == NULL)
    {   
        return STG_E_INVALIDPOINTER;
    }

    if (FAILED(sc = BeginMonitor()))
    {
        return sc;
    }
    
    if (FAILED(sc = ProcessLayout(pStorageLayout,
                                  nEntries,
                                  glfInterleavedFlag)))
    {
        // ignore errors from EndMonitor
        EndMonitor();
        return sc;
    }

    if (FAILED(sc = EndMonitor()))
    {
        return sc;
    }

    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::BeginMonitor
//
//  Synopsis:	Begin monitoring the ILockBytes operations for recording a
//              script.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	21-Feb-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::BeginMonitor(void)
{
    SCODE sc = S_OK;
    sc = _pllkb->StartLogging();
    return ResultFromScode(sc);   		

}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::EndMonitor
//
//  Synopsis:	Stop monitoring ILockBytes operations for script recording.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	21-Feb-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::EndMonitor(void)
{
    SCODE sc = S_OK;
    sc =  _pllkb->StopLogging();
    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ReLayoutDocfile
//
//  Synopsis:   Relayout the docfile into the new name specified.
//
//  Arguments:	[pwcsNewName] -- Name of destination file
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//      	21-Feb-96       SusiA           Made a method on ILayoutStorage
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::ReLayoutDocfile(OLECHAR *pwcsNewDfName)
{
    SCODE sc;

#if (!defined(UNICODE) && (!defined(_MAC)))

    WCHAR awcScriptName[MAX_PATH + 1];

	
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (!MultiByteToWideChar(
        uCodePage,
        0,
        _pllkb->GetScriptName(),
        -1,
        awcScriptName,
        MAX_PATH + 1
        ))
    {
        return STG_E_INVALIDNAME;
    }
    sc = StgLayoutDocfile(_pllkb->GetHandle(),
                          pwcsNewDfName,
                          awcScriptName);
#else 
    
    
    sc = StgLayoutDocfile(_pllkb->GetHandle(),
                          pwcsNewDfName,
                          _pllkb->GetScriptName());
#endif //UNICODE

    if (FAILED(sc))
    {
        //Delete new file
#ifdef UNICODE        
        DeleteFileW(pwcsNewDfName);
#elif defined( _MAC)
        DeleteFile(pwcsNewDfName);
#else
		
        TCHAR atcPath[MAX_PATH + 1];

        uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

        //Note:  Intentionally ignore an error if it happens here.  We
        //  want to return the error from StgLayoutDocfile, not from
        //  the cleanup path.
        WideCharToMultiByte(
            uCodePage,
            0,
            pwcsNewDfName,
            -1,
            atcPath,
            _MAX_PATH + 1,
            NULL,
            NULL);
        DeleteFileA(atcPath);

#endif // UNICODE       
    }
    else
    {
        //Delete Script File
        DeleteFile(_pllkb->GetScriptName());
        //Note:  Intentionally ignore an error if it happens here.  We
        //  want to return the error from StgLayoutDocfile, not from
        //  the cleanup path.
        _pllkb->ClearScriptName();
            
    }
    return sc;
}

#if DBG == 1
STDMETHODIMP CLayoutRootStorage::GetScript(TCHAR **ptcsScriptFileName)
{
   
    *ptcsScriptFileName = _pllkb->GetScriptName();
    return S_OK;                                                                            
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ReLayoutDocfileOnILockBytes
//
//  Synopsis:   Relayout the docfile into a generic ILockBytes implementation.
//
//  Arguments:	[pILockBytes] -- destination relayout ILockBytes
//
//  Returns:	Appropriate status code
//
//  History:	09-Jun-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::ReLayoutDocfileOnILockBytes(ILockBytes *pILockBytes)
{
    return STG_E_UNIMPLEMENTEDFUNCTION;
}

//+---------------------------------------------------------------------------
//
//  Function:	StgLayoutDocfile
//
//  Synopsis:	Given an old file and an unprocessed script, relayout the
//              docfile into the new name specified.
//
//  Arguments:	[hOld] -- Handle of source file
//              [pwcsNewDfName] -- Name of destination file
//              [pwcsScriptName] -- Name of unprocessed script file
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE StgLayoutDocfile(HANDLE hOld,
                       OLECHAR const *pwcsNewDfName,
                       OLECHAR const *pwcsScriptName)
{
    SCODE sc = S_OK;
    CMappedFile mfOld, mfNew, mfScript;
    MAPFILE *pvOld, *pvNew, *pvScript;
    ULONG ulScriptSize;
    ULONG csectScript, csectProcessed, csectFile;
    ULONG cbSectorSize;
    ULONG i;
    
    SECT *psProcessedScript = NULL;
   
    if (pwcsNewDfName == NULL)
        return STG_E_INVALIDNAME;

#ifdef _MAC
    layChkTo(EH_End, mfOld.InitFromHandle(hOld,
                                          GENERIC_READ, 
                                          FALSE,
                                          NULL));
#else
    layChkTo(EH_End, mfOld.InitFromHandle(hOld,
                                          GENERIC_READ, 
                                          TRUE,
                                          NULL));
#endif
    layChkTo(EH_End, mfNew.Init(pwcsNewDfName,
                                mfOld.GetSize(),
                                GENERIC_READ | GENERIC_WRITE,
                                CREATE_ALWAYS,
                                NULL));

    
    if ((pwcsScriptName !=NULL)          && 
        (pwcsScriptName[0] != TEXT('\0'))   )
    {
        sc = mfScript.Init(pwcsScriptName,
                           0,
                           GENERIC_READ,
                           OPEN_EXISTING,
                           NULL);
        layChkTo(EH_End, sc);

        if (sc == STG_S_FILEEMPTY)
        {
            pvScript = NULL;
        }
        else 
        {
            pvScript = &mfScript;
        }
    }
    else
    {
        pvScript = NULL;
    }

    pvOld = &mfOld;
    pvNew = &mfNew;

    
    //From this point on, we may get an exception while we're poking around
    //  in one of the memory maps.  We need to handle this case and be able
    //  to properly return an error and clean up if it happens.

#ifndef _MAC
    __try
        {
#endif
            //Figure out how many sectors are in the file
            cbSectorSize = 1 << pvOld->GetUSHORT(
                (ULONG) offsetof(CMSFHeaderData,_uSectorShift));
            pvOld->SetSectorSize(cbSectorSize);
            pvNew->SetSectorSize(cbSectorSize);
		
            const ULONG cbHeader = cbSectorSize;
            csectFile = (mfOld.GetSize() + cbSectorSize - 1 -
                         cbHeader) / cbSectorSize;

            SECT sectRangeLocks = (OLOCKREGIONEND - cbHeader + cbSectorSize - 1)
                                   / cbSectorSize;

            if (pvScript)
            {   
                ulScriptSize = mfScript.GetSize();
            }
            else
            {
                ulScriptSize = 0;
            }

            csectProcessed = max(ulScriptSize / sizeof(SECT), csectFile);
            layMem(psProcessedScript = new SECT[csectProcessed]);

            for (i = 0; i < csectProcessed; i++)
            {
                psProcessedScript[i] = ENDOFCHAIN;
            }
    
            ULONG csectControl;
            layChk(ProcessControl(psProcessedScript,
                                  pvOld,
                                  &csectControl));
           
            layChk(ProcessScript(psProcessedScript,
                                 pvScript,
                                 csectFile,
                                 ulScriptSize / sizeof(SECT),
                                 csectControl,
                                 sectRangeLocks,
                                 &csectScript));

            //layAssert(csectScript == csectFile);

            layChk(CopyData(pvNew,
                            pvOld,
                            psProcessedScript,
                            csectFile,
                            cbSectorSize));

            layChk(RemapHeader(pvNew, psProcessedScript, csectFile));
            layChk(RemapDIF(pvNew, psProcessedScript, csectFile, cbSectorSize));
            layChk(RemapFat(pvNew,
                            pvOld,
                            psProcessedScript,
                            csectFile,
                            cbSectorSize));
            layChk(RemapDirectory(pvNew,
                                  psProcessedScript,
                                  csectFile,
                                  cbSectorSize));
        Err:
            delete [] psProcessedScript;

#ifndef _MAC
	}
    
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        sc = STG_E_WRITEFAULT;
    }
#endif

    pvOld = NULL;
    pvNew = NULL;

	 
EH_End:    
    return sc; 		
}


//+---------------------------------------------------------------------------
//
//  Function:	GetDIFSect
//
//  Synopsis:	Return a pointer to the appropriate sector in the DIF
//
//  Arguments:	[pvBase] -- Pointer to base address of memory mapped file
//              [iDIF] -- Index into DIF desired
//              [cbSectorSize] -- Size in bytes of sector
//
//  Returns:	Pointer to appropriate sector
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFatSect * GetDIFSect(MAPFILE *pvBase,
                      ULONG iDIF,
                      ULONG cbSectorSize,
                      SECT *psect)
{
    USHORT cSectPerFat = (USHORT)(cbSectorSize / sizeof(SECT));
    SECT sectDif = pvBase->GetULONG(
        (ULONG) offsetof(CMSFHeaderData,_sectDifStart));


    for (ULONG i = 0; i < iDIF; i++)
    {
        CFatSect  *pdif = pvBase->GetCFatSect((sectDif * cbSectorSize) +
                                              cbSectorSize);
		
        sectDif = pdif->GetSect(cSectPerFat - 1);
		
        pvBase->Remove(pdif);
    }

    if (psect)
    {
        *psect = sectDif;
    }
    return pvBase->GetCFatSect((sectDif * cbSectorSize) +
                               cbSectorSize);
}



//+---------------------------------------------------------------------------
//
//  Function:	GetFatSect
//
//  Synopsis:	Return a pointer to the appropriate sector in the fat
//
//  Arguments:	[pvBase] -- Pointer to base address of memory mapped file
//              [iFat] -- Index into fat desired
//              [cbSectorSize] -- Size in bytes of sector
//
//  Returns:	Pointer to appropriate sector
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFatSect *GetFatSect(MAPFILE *pvBase,
                     ULONG iFat,
                     ULONG cbSectorSize,
                     SECT *psect)
{
    SECT sectFat;
    
    if (iFat < CSECTFAT)
    {
        //Fatsect can be found in header
        sectFat = pvBase->GetULONG(
            (ULONG) offsetof(CMSFHeaderData,_sectFat[iFat]));
    }
    else
    {
        ULONG cFatPerDif = (cbSectorSize / sizeof(SECT)) - 1;
        ULONG iDIF = (iFat - CSECTFAT) / cFatPerDif;
        USHORT oDIF = (USHORT)((iFat - CSECTFAT) % cFatPerDif);
        CFatSect *pDif = GetDIFSect(pvBase, iDIF, cbSectorSize, NULL);
        sectFat = pDif->GetSect(oDIF);

        pvBase->Remove(pDif);
    }

    CFatSect *pbFat = pvBase->GetCFatSect(
        (sectFat * cbSectorSize) + cbSectorSize);

    if (psect)
    {
        *psect = sectFat;
    }
    return (CFatSect *)pbFat;
}



//+---------------------------------------------------------------------------
//
//  Function:	GetNext
//
//  Synopsis:	Given a sector, return the next sector in the fat chain
//
//  Arguments:	[pvBase] -- Pointer to base address of memory mapped file
//              [sect] -- Sect desired
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate SECT value
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SECT GetNext(MAPFILE *pvBase,
             SECT sect,
             ULONG cbSectorSize)
{
    SECT newsect;

    ULONG csectPerFat = cbSectorSize / sizeof(SECT);
    ULONG iFat = sect / csectPerFat;
    USHORT oFat = (USHORT)(sect % csectPerFat);
    CFatSect *pfs = GetFatSect(pvBase, iFat, cbSectorSize, NULL);
    
    newsect = pfs->GetSect(oFat);

    pvBase->Remove(pfs);

    return newsect;
}
            


//+---------------------------------------------------------------------------
//
//  Function:	ProcessControl, private
//
//  Synopsis:	Add control structures to processed script
//
//  Arguments:	[psProcessed] -- Pointer to processed script
//              [pvOld] -- Pointer to old file
//              [pcsectControl] -- Return location for total sectors processed
//
//  Returns:	Appropriate status code
//
//  History:	05-Mar-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE ProcessControl(SECT *psProcessed,
                     MAPFILE *pvOld,
                     ULONG *pcsectControl)
{
    SECT sectCurrent = 0;
    CMSFHeaderData *phdr = (CMSFHeaderData *)pvOld->GetCMSFHeaderData();

    ULONG csectDif, csectFat;
    ULONG cbSectorSize;

    csectDif = phdr->_csectDif;
    csectFat = phdr->_csectFat;
    cbSectorSize = 1 << phdr->_uSectorShift;

    //We want the structures in the following order:
    //1) Enough fat and DIFat sectors to hold themselves and all of the
    //    directory sectors.
    //2) All of the directory sectors
    //3) Everything else - the rest of the difat, the fat, and the minifat.

    //First find out how big the directory is
    SECT sectDir = phdr->_sectDirStart;
    ULONG csectDir = 0;
    while (sectDir != ENDOFCHAIN)
    {
        sectDir = GetNext(pvOld, sectDir, cbSectorSize);
        csectDir++;
    }

    //Now compute the number of fat sectors we need to hold the directory
    // plus the fat sectors themselves.
    ULONG csectFatNeeded = 0;
    ULONG csectDifNeeded = 0;
    ULONG csectNeededLast = 0;
    ULONG cfsSect = (cbSectorSize / sizeof(SECT));

    do
    {
        csectNeededLast = csectFatNeeded;
        csectFatNeeded = (csectFatNeeded + csectDifNeeded + csectDir +
                          cfsSect - 1) /
            cfsSect;
        if (csectFatNeeded > CSECTFAT)
        {
            csectDifNeeded = (csectFatNeeded - CSECTFAT + cfsSect - 2) /
                (cfsSect - 1);
        }
    }
    while (csectFatNeeded != csectNeededLast);

    //Now we know how many DIF, Fat, and Directory sectors we need.
    //Lay those out first.

    //For those of you keeping score, the docfile will need to have exactly
    //  csectFatNeeded + csectDifNeeded sectors downloaded before it can
    //  be opened.
    for (ULONG i = 0; i < csectDifNeeded; i++)
    {
        SECT sectDif;
        pvOld->Remove(GetDIFSect(pvOld, i, cbSectorSize, &sectDif));
        psProcessed[sectDif] = sectCurrent++;
    }

    for (i = 0; i < csectFatNeeded; i++)
    {
        SECT sectFat;

        pvOld->Remove(GetFatSect(pvOld, i, cbSectorSize, &sectFat));
        psProcessed[sectFat] = sectCurrent++;
    }
    sectDir = phdr->_sectDirStart;
    for (i = 0; i < csectDir; i++)
    {
        layAssert(sectDir != ENDOFCHAIN);
        psProcessed[sectDir] = sectCurrent++;
        sectDir = GetNext(pvOld, sectDir, cbSectorSize);
    }

    //Now put down everything else
    for (i = csectDifNeeded; i < csectDif; i++)
    {
        SECT sectDif;

        GetDIFSect(pvOld, i, cbSectorSize, &sectDif);
        pvOld->Remove(GetDIFSect(pvOld, i, cbSectorSize, &sectDif));
        psProcessed[sectDif] = sectCurrent++;
    }
    for (i = csectFatNeeded; i < csectFat; i++)
    {
        SECT sectFat;
        pvOld->Remove(GetFatSect(pvOld, i, cbSectorSize, &sectFat));
        psProcessed[sectFat] = sectCurrent++;
    }
    //Finally minifat
    SECT sectMiniFat = phdr->_sectMiniFatStart;
    while (sectMiniFat != ENDOFCHAIN)
    {
        psProcessed[sectMiniFat] = sectCurrent++;
        sectMiniFat = GetNext(pvOld, sectMiniFat, cbSectorSize);
    }
    
    *pcsectControl = sectCurrent;

    pvOld->Remove(phdr);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:	ProcessScript
//
//  Synopsis:	Given a list of sectors in order, construct a mapping
//              of old sector->new sector
//
//  Arguments:	[psProcessed] -- Pointer to destination buffer
//              [psOriginal] -- Pointer to source script buffer
//              [csectFile] -- Count of sectors in file
//              [csectOriginal] -- Count of entries in original script
//              [sectRangeLocks] -- sector containing docfile range locks
//              [pcsectProcessed] -- Return location for number of entries
//                                   in processed script
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE ProcessScript(SECT *psProcessed,
                    MAPFILE *psOriginal,
                    ULONG csectFile,
                    ULONG csectOriginal,
                    ULONG csectControl,
                    SECT  sectRangeLocks,
                    ULONG *pcsectProcessed)
{
    SCODE sc = S_OK;
#if DBG == 1    
    ULONG csectProcessed = 0;
#endif    
    ULONG cDuplicates = 0;
    ULONG cUnlisted = 0;
    
    for (ULONG i = 0; i < csectOriginal; i++)
    {
        SECT sectOld = (*psOriginal)[i];

        if (sectOld >= csectFile)
        {
            //Weird.  We're past the range of the file.
            return STG_E_UNKNOWN;
        }
        
#if DBG == 1            
        if (sectOld + 1> csectProcessed)
        {
            csectProcessed = sectOld + 1;
        }
#endif            

        if (psProcessed[sectOld] == ENDOFCHAIN)
        {
            psProcessed[sectOld] = i - cDuplicates + csectControl;
        }
        else
        {
            cDuplicates++;
        }
    }


    //Fill in holes
    for (i = 0; i < csectFile; i++)
    {
        if (psProcessed[i] == ENDOFCHAIN)
        {
            SECT sectNew = csectOriginal - cDuplicates + csectControl +
                cUnlisted;
            if (sectNew == sectRangeLocks)  // skip over range locks
            {
                sectNew++;
                cUnlisted++;
            }
            psProcessed[i] = sectNew;
            cUnlisted++;
#if DBG == 1            
            if (sectNew + 1> csectProcessed)
            {
                csectProcessed = sectNew + 1;
            }
#endif            
        }
#if DBG == 1
        //If we have control structures at the end of the file that are
        //  not in the script anywhere (which may happen particularly often
        //  on files produced with simple mode), we want to make sure to
        //  update the count on those.  For retail builds, we don't really
        //  care about the count, so we can skip this.
        else if (psProcessed[i] + 1 > csectProcessed)
        {
            csectProcessed = psProcessed[i] + 1;
        }
#endif        
    }
       
#if DBG == 1
    for (i = 0; i < csectProcessed; i++)
    {
        layDebugOut((DEB_IERROR, "Script[%lu] = %lx\n", i, psProcessed[i]));
    }
#endif

#if DBG == 1    
    *pcsectProcessed = csectProcessed;
#else
    *pcsectProcessed = csectFile;
#endif
    
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Function:	CopyData
//
//  Synopsis:	Given an old->new mapping, copy data from old mapping to
//              new mapping
//
//  Arguments:	[pvNew] -- Pointer to destination mapped file
//              [pvOld] -- Pointer to source mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in the file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CopyData(MAPFILE *pvNew,
               MAPFILE *pvOld,
               SECT *psScript,
               ULONG csectFile,
               ULONG cbSectorSize)
{
    SCODE sc = S_OK;

#ifdef SUPPORT_FILE_MAPPING    
    BYTE *pbSrc, *pbDest;

    pbSrc = (BYTE *)(pvOld->GetBaseAddress());
    pbDest = (BYTE *)(pvNew->GetBaseAddress());
#endif    
    
    for (ULONG i = 0; i < csectFile; i++)
    {
#ifdef SUPPORT_FILE_MAPPING        
		
        BYTE *pbSrcStart = (BYTE *)pbSrc + (i * cbSectorSize) +
            cbSectorSize;
        BYTE *pbDestStart = (BYTE *)pbDest + (psScript[i] * cbSectorSize) +
            cbSectorSize;
        
        if ((pbSrc != NULL) && pbDest != NULL)
        {
            CopyMemory(pbDestStart, pbSrcStart, cbSectorSize);
        }
        else
#endif // SUPPORT_FILE_MAPPING        
        {
            BYTE *pbBuffer = (BYTE *) CoTaskMemAlloc(cbSectorSize);
            
            if (!pbBuffer)
            {
                return STG_E_INSUFFICIENTMEMORY;
            }
            
            if (S_OK == (sc = pvOld->ReadFromFile(pbBuffer, 
                                                  (i * cbSectorSize) +
                                                  cbSectorSize,
                                                  cbSectorSize )))
            {
                sc = pvNew->WriteToFile(pbBuffer, 
                                                 (psScript[i] * cbSectorSize) +
                                                 cbSectorSize, 
                                                 cbSectorSize );
            }
            
            
            CoTaskMemFree(pbBuffer);

            if (S_OK != sc)
            {
                return sc;
            }
        }
        

    }
    //Also the header.
#ifdef SUPPORT_FILE_MAPPING

    if ((pbSrc != NULL) && (pbDest != NULL))
    {
        CopyMemory(pbDest, pbSrc, sizeof(CMSFHeaderData));
    }
    else
#endif
    {
	
        BYTE *pbBuffer = (BYTE *) CoTaskMemAlloc(sizeof(CMSFHeaderData));
	
        if (!pbBuffer)
        {
            return STG_E_INSUFFICIENTMEMORY;
        }
	
        if (S_OK == (sc = pvOld->ReadFromFile( pbBuffer, 
                                               0,
                                               sizeof(CMSFHeaderData) )))
        {
            sc = pvNew->WriteToFile( pbBuffer, 
                                              0, 
                                              sizeof(CMSFHeaderData) );
        }
        
        

        CoTaskMemFree(pbBuffer);

        if (S_OK != sc)
        {
            return sc;
        }
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapHeader
//
//  Synopsis:	Remap the docfile header using a processed script
//
//  Arguments:	[pvNew] -- Pointer to base of memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE RemapHeader(MAPFILE *pvNew, SECT *psScript, ULONG csectFile)
{

    SCODE sc = S_OK;

    CMSFHeaderData *ph = (CMSFHeaderData *)pvNew->GetCMSFHeaderData();

    //Directory start will never be EOC

    ph->_sectDirStart = psScript[ph->_sectDirStart];

    if (ph->_sectMiniFatStart != ENDOFCHAIN)
        ph->_sectMiniFatStart = psScript[ph->_sectMiniFatStart];

    if (ph->_sectDifStart != ENDOFCHAIN)
        ph->_sectDifStart = psScript[ph->_sectDifStart];

    for (ULONG i = 0; i < CSECTFAT; i++)
    {
        if (ph->_sectFat[i] != FREESECT)
        {
            ph->_sectFat[i] = psScript[ph->_sectFat[i]];
        }
    }

    sc = pvNew->WriteToFile(ph);
    pvNew->Remove(ph);
    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapDIF
//
//  Synopsis:	Remap the DIF according to a processed script
//
//  Arguments:	[pvNew] -- Pointer to base of memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE RemapDIF(MAPFILE *pvNew,
               SECT *psScript,
               ULONG csectFile,
               ULONG cbSectorSize)
{
    CMSFHeaderData *ph = (CMSFHeaderData *)pvNew->GetCMSFHeaderData();

    SCODE sc = S_OK;

    CFatSect *pfs = NULL;
    USHORT csectPerDif = (USHORT)(cbSectorSize / sizeof(SECT));
    SECT sectDif = ph->_sectDifStart;

    for (ULONG i = 0; i < ph->_csectDif; i++)
    {

        pfs = pvNew->GetCFatSect((sectDif * cbSectorSize) +
                                 cbSectorSize    );

        for (USHORT j = 0; j < csectPerDif; j++)
        {
            SECT sectOld = pfs->GetSect(j);
            
            if ((sectOld != FREESECT) &&
                (sectOld != ENDOFCHAIN))
            {
                pfs->SetSect(j, psScript[sectOld]);
            }
        }

        sectDif = pfs->GetNextFat(csectPerDif - 1);

        sc = pvNew->WriteToFile(pfs);
        pvNew->Remove(pfs);

    }

    pvNew->Remove(ph);
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapFat
//
//  Synopsis:	Remap the Fat according to a processed script and the original
//              file
//
//  Arguments:	[pvNew] -- Pointer to base of destination memory mapped file
//              [pvOld] -- Pointer to base of source memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//  Notes:	Since the processed script does not contain information
//              about individual fat chains, we need the old file in order
//              to construct the new fat.
//
//----------------------------------------------------------------------------

SCODE RemapFat(MAPFILE *pvNew,
               MAPFILE *pvOld,
               SECT *psScript,
               ULONG csectFile,
               ULONG cbSectorSize)
{
    CFatSect *pfsNew;
    CFatSect *pfsOld;

    SCODE sc = S_OK;

    ULONG csectFat = pvNew->GetULONG(
        (ULONG) offsetof(CMSFHeaderData, _csectFat));

    USHORT csectPerFat = (USHORT)(cbSectorSize / sizeof(SECT));

    for (ULONG i = 0; i < csectFat; i++)
    {
        pfsNew = GetFatSect(pvNew, i, cbSectorSize, NULL);
        memset(pfsNew, 0xFF, cbSectorSize);

        sc = pvNew->WriteToFile(pfsNew);
        if (sc != S_OK)
        {
            return sc;
        }
        pvNew->Remove(pfsNew);
    }

    for (i = 0; i < csectFat; i++)
    {
        pfsOld = GetFatSect(pvOld, i, cbSectorSize, NULL);

        for (USHORT j = 0; j < csectPerFat; j++)
        {
            if (i * csectPerFat + j >= csectFile)
            {
                //Sector outside of current file size - no remapping
                //is necessary, and sector has already been marked
                //as free above.
                break;
            }
            
            SECT sectOld = pfsOld->GetSect(j);
            SECT sectNew = psScript[i * csectPerFat + j];
            ULONG iFatNew = sectNew / csectPerFat;
            USHORT oFatNew = (USHORT)(sectNew % csectPerFat);
            
            pfsNew = GetFatSect(pvNew, iFatNew, cbSectorSize, NULL);
            
            if (sectOld > MAXREGSECT)
            {
                pfsNew->SetSect(oFatNew, sectOld);
            }
            else
            {
                //Need to map contents.
                SECT sectMap = psScript[sectOld];
                pfsNew->SetSect(oFatNew, sectMap);
            }
            sc = pvNew->WriteToFile(pfsNew);
            pvNew->Remove(pfsNew);
        }

        pvOld->Remove(pfsOld);
    }
    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapDirectory
//
//  Synopsis:	Remap a directory based on a processed script
//
//  Arguments:	[pvNew] -- Pointer to base of memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE RemapDirectory(MAPFILE *pvNew,
                     SECT *psScript,
                     ULONG csectFile,
                     ULONG cbSectorSize)
{
    CMSFHeaderData *ph = (CMSFHeaderData *)pvNew->GetCMSFHeaderData();

    SCODE sc = S_OK;

    USHORT csectPerFat = (USHORT)(cbSectorSize / sizeof(SECT));
    USHORT cEntryPerSect = (USHORT)(cbSectorSize / sizeof(CDirEntry));
    SECT sectDir = ph->_sectDirStart;

    while (sectDir != ENDOFCHAIN)
    {
        CDirSect *pds = pvNew->GetCDirSect((sectDir * cbSectorSize) +
                                           cbSectorSize   );

        for (USHORT i = 0; i < cEntryPerSect; i++)
        {
            CDirEntry *pde = pds->GetEntry(i);

            if (STREAMLIKE(pde->GetFlags()))
            {
                SECT sectOld = (ULONG) pde->GetStart();
#ifdef LARGE_STREAMS
                ULONGLONG ulSize = pde->GetSize(cbSectorSize > 512);
#else
                ULONG ulSize = pde->GetSize();
#endif
                swap ((char *) &sectOld, sizeof(SECT));
                swap ((char *) &ulSize, sizeof(ulSize));
				
				            
                if ((ulSize >= ph->_ulMiniSectorCutoff) ||
                    (pde->GetFlags() == STGTY_ROOT))
                {
                    if ((sectOld != ENDOFCHAIN) && (sectOld != FREESECT))
                    {
                        SECT sectNew = psScript[sectOld];
                        swap ((char *) &sectNew, sizeof(SECT));
                        pde->SetStart(sectNew);
                    }
                }
            }
        }
        sectDir = GetNext(pvNew, sectDir, cbSectorSize);

        sc = pvNew->WriteToFile(pds);
        pvNew->Remove(pds);
    }
    pvNew->Remove(ph);
        
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\layouter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layouter.cxx
//
//  Contents:	Error functions
//
//  Classes:	
//
//  Functions:	
//
//  History:	21-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:	Win32ErrorToScode, public
//
//  Synopsis:	Map a Win32 error into a corresponding scode, remapping
//              into Facility_Storage if appropriate.
//
//  Arguments:	[dwErr] -- Win32 error to map
//
//  Returns:	Appropriate scode
//
//  History:	22-Sep-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE Win32ErrorToScode(DWORD dwErr)
{
    layAssert((dwErr != NO_ERROR) &&
             "Win32ErrorToScode called on NO_ERROR");

    SCODE sc = STG_E_UNKNOWN;

    switch (dwErr)
    {
    case ERROR_INVALID_FUNCTION:
        sc = STG_E_INVALIDFUNCTION;
        break;
    case ERROR_FILE_NOT_FOUND:
        sc = STG_E_FILENOTFOUND;
        break;
    case ERROR_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;
    case ERROR_TOO_MANY_OPEN_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;
    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;
    case ERROR_INVALID_HANDLE:
        sc = STG_E_INVALIDHANDLE;
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;
    case ERROR_NO_MORE_FILES:
        sc = STG_E_NOMOREFILES;
        break;
    case ERROR_WRITE_PROTECT:
        sc = STG_E_DISKISWRITEPROTECTED;
        break;
    case ERROR_SEEK:
        sc = STG_E_SEEKERROR;
        break;
    case ERROR_WRITE_FAULT:
        sc = STG_E_WRITEFAULT;
        break;
    case ERROR_READ_FAULT:
        sc = STG_E_READFAULT;
        break;
    case ERROR_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;
    case ERROR_LOCK_VIOLATION:
        sc = STG_E_LOCKVIOLATION;
        break;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
        sc = STG_E_FILEALREADYEXISTS;
        break;
    case ERROR_INVALID_PARAMETER:
        sc = STG_E_INVALIDPARAMETER;
        break;
    case ERROR_INVALID_NAME:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILENAME_EXCED_RANGE:
        sc = STG_E_INVALIDNAME;
        break;
    case ERROR_INVALID_FLAGS:
        sc = STG_E_INVALIDFLAG;
        break;
    default:
        sc = WIN32_SCODE(dwErr);
        break;
    }
        
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\layouthd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	layouthd.cxx
//
//  Contents:	Precompiled header for docfile layout
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

#ifdef _MAC
#define MAC_DOCFILE
#endif

#ifdef MAC_DOCFILE

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ole2.h>
#include <error.hxx>
#include <debnot.h>
#include "machead.hxx"  


#else
#define SUPPORT_FILE_MAPPING
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ole2.h>
#include <error.hxx>
#include <debnot.h>

#endif //_MAC



#include "layout.hxx"
#include "layouter.hxx"
#include <msf.hxx>

//#ifdef SUPPORT_FILE_MAPPING
//#define MAPFILE void
//#else
#define MAPFILE CMappedFile
//#endif

#include "mapfile.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\mapfile.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	mapfile.cxx
//
//  Contents:	Mapped file class implementation
//
//  Classes:	
//
//  Functions:	
//
//  History:	12-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

//#define TEST_MAPPING_LOWMEM

CMappedFile::~CMappedFile(void)
{
#ifdef SUPPORT_FILE_MAPPING
    if (_pbBase != NULL)
    {
        UnmapViewOfFile(_pbBase);
    }
    if (_hMapping != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hMapping);
    }
#endif
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMappedFile::InitFromHandle, public
//
//  Synopsis:	Initialize object based on file handle
//
//  Arguments:	[h] -- File handle
//              [fReadOnly] -- TRUE if mapping is to be read-only
//              [fDuplicate] -- TRUE if handle is to be duplicated
//              [pvDesiredBaseAddress] -- Desired address for mapping
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMappedFile::InitFromHandle(HANDLE h,
                                  BOOL fReadOnly,
                                  BOOL fDuplicate,
                                  void *pvDesiredBaseAddress)
{
    SCODE sc = S_OK;

    if (fDuplicate)
    {
        if (!DuplicateHandle(GetCurrentProcess(),
                             h,
                             GetCurrentProcess(),
                             &_hFile,
                             0,
                             TRUE,
                             DUPLICATE_SAME_ACCESS))
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }
    }
    else
    {
        _hFile = h;
    }
#ifdef SUPPORT_FILE_MAPPING

#ifndef UNICODE
    _hMapping = CreateFileMappingA
#else
    _hMapping = CreateFileMapping
#endif
                 (_hFile,
                  NULL, // No security
                  (fReadOnly) ? PAGE_READONLY : PAGE_READWRITE,
                  0,
                  0, //File size determines map size
                  NULL); // Unnamed

#ifdef TEST_MAPPING_LOWMEM
    CloseHandle(_hMapping);
    _hMapping = NULL;
#endif
    
    if (_hMapping != NULL)
    {
        //Mapping created OK, now map view
        _pbBase = MapViewOfFileEx(_hMapping,
                                  (fReadOnly) ? FILE_MAP_READ : FILE_MAP_WRITE,
                                  0,
                                  0,
                                  0,
                                  pvDesiredBaseAddress);

        if (_pbBase == NULL)
        {
            sc = STG_SCODE(GetLastError());
            CloseHandle(_hMapping);
            _hMapping = INVALID_HANDLE_VALUE;
        }
    }

#endif //SUPPORT_FILE_MAPPING

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMappedFile::Init, public
//
//  Synopsis:	Initialize based on a filename
//
//  Arguments:	[pwcsName] -- Filename for file
//              [dwSize] -- Desired size of file, 0 for no size change
//              [dwAccess] -- Access mode for file (see CreateFile)
//              [dwCreationDisposition] -- Creation for file (see CreateFile)
//              [pvDesiredBaseAddress] -- Desired base address for mapping
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMappedFile::Init(OLECHAR const *pwcsName,
                        DWORD dwSize,
                        DWORD dwAccess,
                        DWORD dwCreationDisposition,
                        void *pvDesiredBaseAddress)
{
    SCODE sc;
    BOOL fReadOnly = ((dwAccess & GENERIC_WRITE) == 0);

    layAssert(!fReadOnly || (dwSize == 0));
    if (pwcsName == NULL)
        return STG_E_INVALIDNAME;

#if (!defined(UNICODE) && !defined(_MAC))

    TCHAR atcPath[MAX_PATH + 1];
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (!WideCharToMultiByte(
        uCodePage,
        0,
        pwcsName,
        -1,
        atcPath,
        MAX_PATH + 1,
        NULL,
        NULL))
    {
        return STG_E_INVALIDNAME;
    }

    _hFile = CreateFileA(atcPath,
                        dwAccess,
                        0, //No sharing
                        NULL, //No security
                        dwCreationDisposition,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL); // No template file
#else    
    _hFile = CreateFile(pwcsName,
                        dwAccess,
                        0, //No sharing
                        NULL, //No security
                        dwCreationDisposition,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL); // No template file
#endif    
    


    if (_hFile == INVALID_HANDLE_VALUE)
    {
        layErr(Err, STG_SCODE(GetLastError()));
    }

    if (dwSize != 0)
    {
        DWORD dw = SetFilePointer(_hFile,
                                  dwSize,
                                  NULL,
                                  FILE_BEGIN);
        if (dw == 0xFFFFFFFF)
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }

        if (!SetEndOfFile(_hFile))
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }
    }
    else 
    {   
        DWORD dwFileSize;

        dwFileSize = GetFileSize(_hFile, NULL);

        if (dwFileSize == 0xFFFFFFFF)
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }
        
        if ( dwFileSize == 0 )
        {
            return STG_S_FILEEMPTY;
        }

    }   
    layChk(InitFromHandle(_hFile, fReadOnly, FALSE, pvDesiredBaseAddress));

Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\laywrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	laywrap.cxx
//
//  Contents:	IStorage wrapper for layout docfile
//
//  Classes:	
//
//  Functions:	
//
//  History:	14-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include "laywrap.hxx"
#include "layouter.hxx"

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::QueryInterface, public
//
//  History:	14-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    *ppvObj = NULL;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::QueryInterface:%p()\n", this));    
 
    if (IsEqualIID(iid, IID_IUnknown)) 
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IStorage))
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IRootStorage))
    {
        IRootStorage *prstg;
        if (FAILED(_pRealStg->QueryInterface(IID_IRootStorage,
                                             (void **) &prstg)))
        {
            return E_NOINTERFACE;
        }

        prstg->Release();
        
        *ppvObj = (IRootStorage *)this;
    }
    else if (IsEqualIID(iid, IID_ILayoutStorage))
    {
        *ppvObj = (ILayoutStorage *)this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
    {
        AddRef();
    }
    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::QueryInterface:%p()\n", this));    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::AddRef, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutRootStorage::AddRef(void)
{	
    LONG lRet;
    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::AddRef:%p()\n", this));
    lRet = InterlockedIncrement(&_cReferences);
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::AddRef\n"));
    return lRet;
	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Release, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutRootStorage::Release(void)
{
    LONG lRet;
    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        delete this;
    }
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Release\n"));
    return (ULONG)lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::CreateStream, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::CreateStream(OLECHAR const *pwcsName,
                                              DWORD grfMode,
                                              DWORD reserved1,
                                              DWORD reserved2,
                                              IStream **ppstm)
{
    SCODE sc;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::CreateStream:%p()\n", this));
    
    sc = _pRealStg->CreateStream(pwcsName,
                                 grfMode,
                                 reserved1,
                                 reserved2,
                                 ppstm);


    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::CreateStream:%p()\n", this));

    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::OpenStream, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::OpenStream(OLECHAR const *pwcsName,
                                            void *reserved1,
                                            DWORD grfMode,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::OpenStream:%p()\n", this));
    
    sc = _pRealStg->OpenStream(pwcsName,
                               reserved1,
                               grfMode,
                               reserved2,
                               ppstm);

    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::OpenStream:%p()\n", this));
    
    return ResultFromScode(sc);   		

}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::CreateStorage, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::CreateStorage(OLECHAR const *pwcsName,
                                               DWORD grfMode,
                                               DWORD reserved1,
                                               LPSTGSECURITY reserved2,
                                               IStorage **ppstg)
{
    SCODE sc = S_OK;
    
    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::CreateStorage:%p()\n", this));
  
    sc = _pRealStg->CreateStorage( pwcsName,
                                   grfMode,
                                   reserved1,
                                   reserved2,
                                   ppstg);
		
    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::CreateStorage:%p()\n", this));
    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::OpenStorage, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::OpenStorage(OLECHAR const *pwcsName,
                                             IStorage *pstgPriority,
                                             DWORD grfMode,
                                             SNB snbExclude,
                                             DWORD reserved,
                                             IStorage **ppstg)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::OpenStorage:%p()\n", this));
	
    sc = _pRealStg->OpenStorage(pwcsName,
                                pstgPriority,
                                grfMode,
                                snbExclude,
                                reserved,
                                ppstg);
		
    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::OpenStorage:%p()\n", this));
    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::CopyTo, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::CopyTo(DWORD ciidExclude,
                                        IID const *rgiidExclude,
                                        SNB snbExclude,
                                        IStorage *pstgDest)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::CopyTo%p()\n", this));
   
    sc = _pRealStg->CopyTo(ciidExclude,
                           rgiidExclude,
                           snbExclude,
                           pstgDest);

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::CopyTo\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::MoveElementTo, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::MoveElementTo(OLECHAR const *lpszName,
                                               IStorage *pstgDest,
                                               OLECHAR const *lpszNewName,
                                               DWORD grfFlags)
{
    SCODE sc = S_OK;
	
    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::MoveElementTo%p()\n", this));
    
    sc = _pRealStg->MoveElementTo(lpszName,
                                  pstgDest,
                                  lpszNewName,
                                  grfFlags) ;

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::MoveElementTo\n"));
    
    return ResultFromScode(sc); 		
	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Commit, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::Commit(DWORD grfCommitFlags)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Commit%p()\n", this));
   
    sc = _pRealStg->Commit(grfCommitFlags);
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Commit\n"));	
    return ResultFromScode(sc); 		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Revert, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::Revert(void)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Revert%p()\n", this));
   
    sc = _pRealStg->Revert();
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Revert\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::EnumElements, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::EnumElements(DWORD reserved1,
                                              void *reserved2,
                                              DWORD reserved3,
                                              IEnumSTATSTG **ppenm)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::EnumElements%p()\n", this));
   
    sc = _pRealStg->EnumElements(reserved1,
                                 reserved2,
                                 reserved3,
                                 ppenm);

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::EnumElements\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::DestroyElement, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::DestroyElement(OLECHAR const *pwcsName)
{
    SCODE sc = S_OK;
    
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::DestroyElement\n"));
    
    sc = _pRealStg->DestroyElement(pwcsName);
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::DestroyElement\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::RenameElement, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::RenameElement(OLECHAR const *pwcsOldName,
                                               OLECHAR const *pwcsNewName)
{
    SCODE sc = S_OK;

    sc = _pRealStg->RenameElement(pwcsOldName, pwcsNewName);
    
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::RenameElement\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SetElementTimes, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SetElementTimes(const OLECHAR *lpszName,
                                                 FILETIME const *pctime,
                                                 FILETIME const *patime,
                                                 FILETIME const *pmtime)
{
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::SetElementTimes\n"));

    sc = _pRealStg->SetElementTimes(lpszName,
                                    pctime,
                                    patime,
                                    pmtime);
		
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::SetElementTimes\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SetClass, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SetClass(REFCLSID clsid)
{
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::SetClass\n"));	
    
    sc = _pRealStg->SetClass(clsid);

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::SetClass\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SetStateBits, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SetStateBits(DWORD grfStateBits,
                                              DWORD grfMask)
{
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::SetStateBits\n"));

    sc = _pRealStg->SetStateBits(grfStateBits, grfMask);
		
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::SetStateBits\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Stat, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Stat%p()\n", this));
   
    sc = _pRealStg->Stat( pstatstg,  grfStatFlag);
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Stat\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SwitchToFile, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SwitchToFile(OLECHAR *ptcsFile)
{
    SCODE sc = S_OK;
    IRootStorage *prstg;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::%p()\n", this));

    layVerify(SUCCEEDED(_pRealStg->QueryInterface(IID_IRootStorage,
                                                  (void **) &prstg)));

    sc = prstg->SwitchToFile(ptcsFile);

    prstg->Release();

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::\n"));	
    return ResultFromScode(sc); 	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\test\laytest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	laytest.cxx
//
//  History:	15-May-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "scripts.hxx"


HRESULT StgLayoutDocfile(HANDLE hOld,
                         OLECHAR const *pwcsNewName,
                         OLECHAR const *pwcsScriptName);

typedef ULONG SECT;


#define FailMsg(MSG) {printf MSG; exit(1);}

#define DoCmd(MSG, CODE, FAILMSG) \
printf(MSG " => %s (0x%lX)\n", (sc = ResultFromScode(CODE), ScText(sc)), sc); \
if (FAILED(sc)) {printf(FAILMSG "\n");}

#define SHIFT(c,v)  ( (c)--, (v)++)

#include <assert.h>

void BeginTest(void)
{
    HRESULT hr;

    hr = CoInitialize(NULL);
    Result(hr, "CoInitialize");
}


void EndTest(int rc)
{
    if (rc == 0)
        printf("Test SUCCEEDED\n");
    else
        printf("Test FAILED\n");
    CoUninitialize();
    exit(rc);
}

void PrintStat(STATSTG *pstat, BOOL fEnum)
{
    printf("%s: '%ws'\n", pstat->type == STGTY_STORAGE ? "Storage" : "Stream",
           pstat->pwcsName);
    //printf("Type: %lu, %lu\n", pstat->type, pstat->dwStgFmt);
    printf("Type: %lu, %lu\n", pstat->type);
    if (!fEnum)
        printf("Mode: %lX\n", pstat->grfMode);
    if (pstat->type == STGTY_STREAM)
    {
        printf("Size: %lu:%lu\n", pstat->cbSize.HighPart,
               pstat->cbSize.LowPart);
        if (!fEnum)
            printf("Locks: %lX\n", pstat->grfLocksSupported);
    }
    else
    {
        if (pstat->ctime.dwHighDateTime != 0 ||
            pstat->ctime.dwLowDateTime != 0)
            printf("Ctime: %s\n", FileTimeText(&pstat->ctime));
        if (pstat->mtime.dwHighDateTime != 0 ||
            pstat->mtime.dwLowDateTime != 0)
            printf("Mtime: %s\n", FileTimeText(&pstat->mtime));
        if (pstat->atime.dwHighDateTime != 0 ||
            pstat->atime.dwLowDateTime != 0)
            printf("Atime: %s\n", FileTimeText(&pstat->atime));
    }
    if (!fEnum)
        printf("Clsid: %s\n", GuidText(&pstat->clsid));
}
void PrintStatInfo(STATSTG *pstat)
{
    PrintStat(pstat, TRUE);
}

#define OLDFILENAME L"StartDocfile.Doc"
#define NEWFILENAME L"d:\\scratch\\NewD.doc"
#define SCRIPTFILENAME L"Script"
#define DOCFILENAME L"d:\\nt\\private\\ole32\\stg\\async\\layout\\test\\test.doc"

void t_script(void)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgNew, *pstgOld;
    ILayoutStorage *pLayout;
    
    int i;

    BYTE buffer[4096];
    

    sc = StgOpenLayoutDocfile(DOCFILENAME,
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            0,
                            &pstgRoot);
    Result(sc, "StgOpenLayoutDocfile");


    pstgRoot->QueryInterface(IID_ILayoutStorage,(void **) &pLayout);
    
    for (i=0; i < NUMTESTS; i++)
    {
        sc = pLayout->LayoutScript(
	    arrWord[i].LayoutArray,
	    arrWord[i].nEntries,
	    STG_LAYOUT_SEQUENTIAL); // sequential (all up front) control structures

        Result(sc, "LayoutScript");


    }
    // Write new compound file with desired layout
    sc = pLayout->ReLayoutDocfile(NEWFILENAME);
    
    Result(sc, "ReLayoutDocfile");

    sc = StgOpenStorage(NEWFILENAME,
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,
                        0,
                        &pstgNew);
    Result(sc, "Open new file");

    if (!CompareStorages(pstgRoot, pstgNew))
    {
        Fail("Files did not compare identical\n");
    }
    
    pLayout->Release();
    pstgNew->Release();
    pstgRoot->Release();
}

void __cdecl main(int argc, char **argv)
{
    SCODE sc;
    BeginTest();

    //t_layout();

    t_script();

    EndTest(0);
    exit(0);	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\layscrpt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layscrpt.cxx
//
//  Contents:	Code for  the LayoutScript method
//
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include <dirfunc.hxx>
#include "layout.hxx"
#include "laylkb.hxx"
#include "laywrap.hxx"

#define NULL_TERM               L'\0'
#define BACKSLASH               L'\\'
#define MAX_BUFFER              0x10000

//#define UNIT_TEST     


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::FreeStmList
//
//  Synopsis:	Free the stream linked list
//
//  Arguments:	[pStmList] -- Pointer STREAMLIST node
//
//----------------------------------------------------------------------------

void  CLayoutRootStorage::FreeStmList( STREAMLIST *pStmList)
{
    STREAMLIST *ptmp = pStmList;

    while (pStmList)
    {
        ptmp = pStmList->pnext;

#ifdef UNIT_TEST     
        wprintf(L"STGTY_STREAM    %ls\n", pStmList->pwcsStmName );
#endif        
        CoTaskMemFree(pStmList->pwcsStmName);
        pStmList->pStm->Release();
        delete pStmList;
        
        pStmList = ptmp;

    }


    
}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::FreeStgList
//
//  Synopsis:	Free the storage linked list
//
//  Arguments:	[pStgList] -- Pointer STORAGELIST node
//
//----------------------------------------------------------------------------

void  CLayoutRootStorage::FreeStgList( STORAGELIST *pStgList)
{
    STORAGELIST *ptmp;

    while (pStgList)
    {
        ptmp = pStgList->pnext;
#ifdef UNIT_TEST     
        wprintf(L"STGTY_STORAGE    %ls\n", pStgList->pwcsStgName );
#endif

        CoTaskMemFree(pStgList->pwcsStgName);
        pStgList->pStg->Release();
        delete pStgList;

        pStgList = ptmp;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessOpen
//
//  Synopsis:	Open the storage or stream
//
//  Arguments:	[pwcsElementPathName] -- full "path" name of element to open
//              [dwType] STGTY_STORAGE or STGTY_STREAM
//              [ppIstgStm] interface pointer to the opened Storage or Stream
//              [cOffset]  offset of beginning of the read
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------

SCODE CLayoutRootStorage::ProcessOpen(OLECHAR *pwcsElementPathName, 
                                      DWORD dwType, 
                                      void **ppIStgStm,
                                      LARGE_INTEGER cOffset)
{    
    SCODE sc = S_OK;

    IStorage *pStgNew;
    IStream  *pStmNew;

    IStorage *pStg = this;

    STORAGELIST *pStgList;
    STREAMLIST  *pStmList;

    OLECHAR  *pwcsStg = pwcsElementPathName,
             *pwcsTemp = pwcsElementPathName;
    
    OLECHAR  *pwcsBuffer;

    if ( (!pwcsElementPathName) || (pwcsElementPathName[0] == NULL_TERM))
    {
        return STG_E_PATHNOTFOUND;
    }
   
    // process storage path
    while (1)
    {
        while ((*pwcsTemp) && (*pwcsTemp != BACKSLASH))
        { 
            pwcsTemp++;
        }

        pwcsBuffer = (OLECHAR *) CoTaskMemAlloc
                     ((INT)(pwcsTemp - pwcsElementPathName + 1) *
                      sizeof(OLECHAR) );
        
        if (!pwcsBuffer)
        {
            return STG_E_INSUFFICIENTMEMORY;   
        }
        
        lstrcpynW (pwcsBuffer, 
                  pwcsElementPathName,
                  (INT)(pwcsTemp - pwcsElementPathName + 1));

        pwcsBuffer[pwcsTemp - pwcsElementPathName] = NULL_TERM;

        if (!(*pwcsTemp))
        {
            //we are at the end, now handle leaf Storage or stream
            break;
        }

        pStgList = _pStgList;

        // see if this storage is already in the list
        while (pStgList)
        {
            if (!(lstrcmpW(pwcsBuffer, pStgList->pwcsStgName )))
            {
                break;
            }

            pStgList = pStgList->pnext;     
        }
        if (pStgList)
        {
            pStgNew = pStgList->pStg;
            CoTaskMemFree(pwcsBuffer);
        }
        else
        {
            sc = pStg->OpenStorage(pwcsBuffer+(pwcsStg-pwcsElementPathName),
                            NULL,
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL,
                            0,
                            &pStgNew);
            if (FAILED(sc))
            {
                CoTaskMemFree(pwcsBuffer);
                return sc;
            }
        
            // add the storage to the list    
            pStgList = _pStgList;
                
            if (NULL == (_pStgList = new STORAGELIST))
            {
                CoTaskMemFree(pwcsBuffer);
                pStgNew->Release();
                _pStgList = pStgList;               // restore the old list
                return STG_E_INSUFFICIENTMEMORY;
            }

            _pStgList->pwcsStgName = pwcsBuffer;
            _pStgList->pStg = pStgNew;
            _pStgList->pnext = pStgList;

        }

        pStg = pStgNew;
        pwcsStg = ++pwcsTemp;
    
    }
    
    //process leaf storage
    if (dwType == STGTY_STORAGE)
    {
        sc = pStg->OpenStorage(pwcsBuffer+(pwcsStg-pwcsElementPathName),
                            NULL,
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL,
                            0,
                            &pStgNew);
        if (FAILED(sc))
        {
            CoTaskMemFree(pwcsBuffer);
            return sc;
        }

        // add the storage to the list    
        pStgList = _pStgList;
                
        if (NULL == (_pStgList = new STORAGELIST))
        {
           CoTaskMemFree(pwcsBuffer);
           pStgNew->Release();
           _pStgList = pStgList;               // restore the old list
           return STG_E_INSUFFICIENTMEMORY;
        }

        _pStgList->pwcsStgName = pwcsBuffer;
        _pStgList->pStg = pStgNew;
        _pStgList->pnext = pStgList;

        *ppIStgStm = (void *) pStgNew;
    }
    //process leaf stream
    else 
    {
        sc = pStg->OpenStream(pwcsBuffer+(pwcsStg-pwcsElementPathName),
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        0,
                        &pStmNew);
                
        if (FAILED(sc))
        {
           CoTaskMemFree(pwcsBuffer); 
           return sc;
        }

        pStmList = _pStmList;

        if (NULL == (_pStmList = new STREAMLIST))
        {
           CoTaskMemFree(pwcsBuffer);
           pStmNew->Release();
           _pStmList = pStmList;               // restore the old list
           return STG_E_INSUFFICIENTMEMORY;
        }
        
        _pStmList->pwcsStmName = pwcsBuffer;
        _pStmList->pStm = pStmNew;
        _pStmList->fDone = FALSE;
        _pStmList->cOffset = cOffset;
        _pStmList->pnext = pStmList;
         
        *ppIStgStm = (void *) pStmNew; 
   }

   return sc;

}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessItem
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pLayoutItem] -- Pointer to a StorageLayout element of the array
//              [fStmDone] -- indicate whether the stream finished reading
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------

SCODE CLayoutRootStorage::ProcessItem( StorageLayout  *pLayoutItem, BOOL *fStmDone )
{
    SCODE sc = S_OK;

    STREAMLIST *pStmList = _pStmList;
    STORAGELIST *pStgList = _pStgList;
    IStorage *pStgNew;
    IStream *pStmNew;

    ULARGE_INTEGER libNewPosition;
    ULONG cbRead;

    BYTE *pb = NULL;

    *fStmDone = FALSE;

    if ((pLayoutItem->cOffset.QuadPart < 0) || (pLayoutItem->cBytes.QuadPart < 0))
    {
        return STG_E_INVALIDPARAMETER;
    }
    
    switch (pLayoutItem->LayoutType)
    {
        
        case STGTY_STORAGE:

#ifdef UNIT_TEST
            wprintf(L"STGTY_STORAGE    %ls      %lu%lu         %lu%lu\n", 
                  pLayoutItem->pwcsElementName,
                  pLayoutItem->cOffset.HighPart,
                  pLayoutItem->cOffset.LowPart,
                  pLayoutItem->cBytes.HighPart,
                  pLayoutItem->cBytes.LowPart);
#endif
           
            while (pStgList)
            {
                if (!(lstrcmpW(pLayoutItem->pwcsElementName,
                                pStgList->pwcsStgName )))
                {
                    break;
                }

                pStgList = pStgList->pnext;     
            }
            
            // if storage was not found in the list, open the storage
            // and add it to the list
            if (!pStgList)
            {
                sc = ProcessOpen(pLayoutItem->pwcsElementName, 
                            STGTY_STORAGE, 
                            (void **)&pStgNew,
                            pLayoutItem->cOffset);
                     
                if (FAILED(sc))
                {
                    // the application may try to open Storages 
                    // that do not really exist in the compound file,
                    // and we will let them try.
                    if (sc == STG_E_FILENOTFOUND)
                    {
                        return S_OK;
                    }
                    else
                    {
                        return sc;
                    }
                }
            
            }

            break;

        case STGTY_STREAM:    

#ifdef UNIT_TEST
            wprintf(L"STGTY_STREAM    %ls      %lu%lu         %lu%lu\n", 
                  pLayoutItem->pwcsElementName,
                  pLayoutItem->cOffset.HighPart,
                  pLayoutItem->cOffset.LowPart,
                  pLayoutItem->cBytes.HighPart,
                  pLayoutItem->cBytes.LowPart);
#endif
            
            while (pStmList)
            {
                if (!(lstrcmpW(pLayoutItem->pwcsElementName,
                                pStmList->pwcsStmName )))
                {
                    pStmNew = pStmList->pStm;
                    break;
                }
                pStmList = pStmList->pnext;     
            }
            
            // if stream was not found in the list, open the stream, 
            // and add it to the list
            if (pStmList)
            {
                if( pStmList->fDone )
                {
                    *fStmDone = TRUE;
                    return S_OK;
                }
            }
            else
            {
                
                sc = ProcessOpen(pLayoutItem->pwcsElementName, 
                                STGTY_STREAM, 
                                (void **)&pStmNew,
                                pLayoutItem->cOffset);
                
                if (FAILED(sc))
                {
                    // the application may try to open Streams 
                    // that do not really exist in the compound file,
                    // and we will let them try.
                    if (sc == STG_E_FILENOTFOUND)
                    {
                        return S_OK;
                    }
                    else
                    {
                        return sc;
                    }
                }

                pStmList = _pStmList;
                
            }

            // seek to the correct position
            
            sc = pStmNew->Seek(
                    pStmList->cOffset,
                    STREAM_SEEK_SET,	
                    &libNewPosition );
            
            if (FAILED(sc))
            {
               return sc;
            }

            // read the stream and update the script information

            if (NULL == (pb = (BYTE  *) CoTaskMemAlloc(pLayoutItem->cBytes.LowPart)) )
            {
                return STG_E_INSUFFICIENTMEMORY;
            }

            sc = pStmNew->Read(pb, 
                    pLayoutItem->cBytes.LowPart,
                    &cbRead);

            CoTaskMemFree(pb);
            pb = NULL;
    
            if (FAILED(sc))
            {
               return sc;
            }
            //we have reached the end of the stream, mark it as done
            if (cbRead < pLayoutItem->cBytes.LowPart)
            {
	        pStmList->fDone = TRUE;
            }
	    
            pStmList->cOffset.QuadPart += cbRead;
           
            break;
        
        
        default:
            // we just handle storages and stream types
            return  STG_E_INVALIDPARAMETER;

    }
    
    return sc;
   
}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessRepeatLoop
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pStorageLayout] -- Pointer to storage layout array
//              [nEntries] -- Number of entries in the array
//              [nRepeatStart] -- address of index of start of repeat loop
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------
SCODE CLayoutRootStorage::ProcessRepeatLoop( StorageLayout  *pStorageLayout,
                                DWORD nEntries,
                                int * nRepeatStart)
{
    SCODE       sc = S_OK;

    int         i,
                nLoopCount = 0, 
                nLoopTimes;
    
    BOOL        fDone = FALSE,
                fUntilDone;


    // Are we going to repeat until all streams are read to the end?
    if ((nLoopTimes = (LONG) pStorageLayout[*nRepeatStart].cBytes.LowPart) != STG_TOEND)
        fUntilDone = FALSE; 
    else
    {
        fUntilDone = TRUE;
        nLoopTimes =  1;
    }
    // finished when all streams are completely read, or we have
    // looped through the specified amount of times
    while ((!fDone)&&(nLoopCount < nLoopTimes))
    {
        if (!fUntilDone)
            nLoopCount ++;

        i = *nRepeatStart;
        fDone = TRUE;

        // STGTY_REPEAT with 0 bytes indicates the end of this repeat block
        while (!((pStorageLayout[++i].LayoutType == STGTY_REPEAT ) &&
                 (pStorageLayout[i].cBytes.QuadPart == 0)) )                               
        {
            if (i >= (LONG) nEntries)
            {
                return E_INVALIDARG;
            }
            
             // beginning of another repeat block    
            if (pStorageLayout[i].LayoutType == STGTY_REPEAT )
            {
                if ((pStorageLayout[i].pwcsElementName !=NULL) ||
                    (pStorageLayout[i].cOffset.QuadPart < 0) || 
                    (pStorageLayout[i].cBytes.QuadPart < 0) )
                {
                    return  STG_E_INVALIDPARAMETER;
                }
                layChk(ProcessRepeatLoop(pStorageLayout,
                                     nEntries,
                                     &i));
            }
                    
            else
            {
                 layChk(ProcessItem(&(pStorageLayout[i]), &fDone));                            
                   
            }
        }
     }   
     *nRepeatStart = i;

Err:

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessLayout
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pStorageLayout] -- Pointer to storage layout array
//              [nEntries] -- Number of entries in the array
//              [grfInterleavedFlag] -- Specifies disposition of control
//                                      structures
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------


SCODE CLayoutRootStorage::ProcessLayout( StorageLayout  *pStorageLayout,
                                DWORD nEntries,
                                DWORD glfInterleavedFlag)
{

    SCODE       sc = S_OK;
    int         i; 
	BOOL        fUnused;
    
    for (i = 0; i < (LONG) nEntries; i++)
    {
            
        if (pStorageLayout[i].LayoutType == STGTY_REPEAT )
        {

            if (pStorageLayout[i].cBytes.QuadPart != 0)
            {
                if ((pStorageLayout[i].pwcsElementName !=NULL) ||
                    (pStorageLayout[i].cOffset.QuadPart < 0) || 
                    (pStorageLayout[i].cBytes.QuadPart < 0) )
                {
                    return  STG_E_INVALIDPARAMETER;
                }
                layChk(ProcessRepeatLoop(pStorageLayout,
                                     nEntries,
                                     &i));
            }
            else  //end repeat block with no matching beginning
            {
                sc = E_INVALIDARG;
                layChk(sc);

            }


        }
        else // (pStorageLayout[i].LayoutType == STGTY_REPEAT )
        {
            layChk(ProcessItem(&(pStorageLayout[i]), &fUnused));
        }
    }    

 
    

Err:
    if (_pStgList)
    {
        FreeStgList(_pStgList);
        _pStgList = NULL;
    }
    if (_pStmList)
    {
        FreeStmList(_pStmList);
        _pStmList = NULL;
    }
    return sc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\test\pch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	pch.cxx
//
//  History:	09-Sep-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <time.h>

#include <windows.h>
//#include <stgint.h>
#include <objbase.h>

#include <debnot.h>
#include <error.hxx>

#include "tutils.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layoutui\cklayout.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layoutui.cxx
//
//  Contents:	debug UI implementation on Docfile Layout Tool
//
//  Classes:    CLayoutApp	
//
//  Functions:	
//
//  History:	07-Apr-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layoutui.hxx"

#if DBG==1

BOOL CompareStatStg(STATSTG *pstat1, STATSTG *pstat2)
{
    if (lstrcmpW(pstat1->pwcsName, pstat2->pwcsName) != 0)
    {
        return FALSE;
    }
    if (pstat1->type != pstat2->type)
    {
        return FALSE;
    }
    if (!IsEqualIID(pstat1->clsid, pstat2->clsid))
    {
        return FALSE;
    }
    if (pstat1->type == STGTY_STREAM)
    {
        if ((pstat1->cbSize).QuadPart != (pstat2->cbSize).QuadPart)
        {
            return FALSE;
        }
    }
    //Also check statebits and timestamps?
    
    return TRUE;
}


BOOL CompareStreams(IStream *pstm1, IStream *pstm2)
{
    const ULONG BUFSIZE = 4096;
    BYTE buffer1[BUFSIZE];
    BYTE buffer2[BUFSIZE];
    ULONG cbRead1;
    ULONG cbRead2;
    STATSTG stat1;
    STATSTG stat2;
    LARGE_INTEGER li;
    li.QuadPart = 0;

    pstm1->Seek(li, STREAM_SEEK_SET, NULL);
    pstm2->Seek(li, STREAM_SEEK_SET, NULL);

    do
    {
        SCODE sc;
        sc = pstm1->Read(buffer1, BUFSIZE, &cbRead1);
        if (FAILED(sc))
        {
            return FALSE;
        }
        sc = pstm2->Read(buffer2, BUFSIZE, &cbRead2);
        if (FAILED(sc))
        {
            return FALSE;
        }
        if ((cbRead1 != cbRead2) || (memcmp(buffer1, buffer2, cbRead1) != 0))
        {
            return FALSE;
        }
    }
    while (cbRead1 == BUFSIZE);
    
    return TRUE;
}


BOOL CompareStorages(IStorage *pstg1, IStorage *pstg2)
{
    SCODE           sc1, sc2, sc;
    HRESULT         hr = TRUE;

    IStorage        *pstgChild1,
                    *pstgChild2;
    
    IStream         *pstmChild1,
                    *pstmChild2;

    IEnumSTATSTG    *penum1 = NULL,
                    *penum2 = NULL;
    STATSTG         stat1, 
                    stat2;

    pstg1->EnumElements(0, 0, 0, &penum1);

    if (!penum1)
        return FALSE;

    pstg2->EnumElements(0, 0, 0, &penum2);
    
    if (!penum2)
    {
        penum1->Release();
        return FALSE;
    }

    do
    {
        ULONG celtFetched1, celtFetched2;
        
        sc1 = penum1->Next(1, &stat1, &celtFetched1);
        if (FAILED(sc1))
        {
            hr = FALSE;
            goto Done;
        }
        sc2 = penum2->Next(1, &stat2, &celtFetched2);
        if (FAILED(sc2) || (celtFetched1 != celtFetched2) || (sc1 != sc2))
        {
            hr = FALSE;
            goto Done;
        }
        if (celtFetched1 == 0)
        {
            // we are done
            hr = TRUE;
            goto Done;
            
        }
        
        if (!CompareStatStg(&stat1, &stat2))
        {
            hr = FALSE;
            goto Done;
        }

        //Items have compared OK so far.  Now compare contents.
        if (stat1.type == STGTY_STREAM)
        {
            sc = pstg1->OpenStream(stat1.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild1);
            if (FAILED(sc))
            {
                hr = FALSE;
                goto Done;
            }
            sc = pstg2->OpenStream(stat2.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild2);
            if (FAILED(sc))
            {
                pstmChild1->Release();
                hr = FALSE;
                goto Done;
            }
            if (!CompareStreams(pstmChild1, pstmChild2))
            {
                pstmChild1->Release();
                pstmChild2->Release();
                hr = FALSE;
                goto Done;
            }
            pstmChild1->Release();
            pstmChild2->Release();
        }
        else
        {
            //Compare storages
            sc = pstg1->OpenStorage(stat1.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild1);
            if (FAILED(sc))
            {
                hr = FALSE;
                goto Done;
            }

            sc = pstg2->OpenStorage(stat2.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild2);
            if (FAILED(sc))
            {
                pstgChild1->Release();
                hr = FALSE;
                goto Done;
            }
            if (!CompareStorages(pstgChild1, pstgChild2))
            {
                pstgChild1->Release();
                pstgChild2->Release();
                hr = FALSE;
                goto Done;        
            }
            pstgChild1->Release();
            pstgChild2->Release();
        }

        CoTaskMemFree(stat1.pwcsName);
        CoTaskMemFree(stat2.pwcsName);

    } while (sc1 != S_FALSE);
    
    
Done:
    
    penum1->Release();
    penum2->Release();
    
    return hr;

    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::IdenticalFiles public
//
//  Synopsis:	Check two docfiles to ensure they are the same
//
//  Returns:	TRUE is the files are identical, FALSE is they are not
//
//  History:	07-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL CLayoutApp::IdenticalFiles( TCHAR *patcFileOne,
                               TCHAR *patcFileTwo)
{
    
    SCODE            sc;
    IStorage         *pstgOne, 
                     *pstgTwo;
    OLECHAR          awcNewFileOne[MAX_PATH];
    OLECHAR          awcNewFileTwo[MAX_PATH];


    sc = StgOpenStorage(TCharToOleChar(patcFileOne, awcNewFileOne, MAX_PATH),
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,
                        0,
                        &pstgOne);
    if (FAILED(sc))
    {
        return FALSE;
    }
    
    sc = StgOpenStorage (TCharToOleChar(patcFileTwo, awcNewFileTwo, MAX_PATH),
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,
                        0,
                        &pstgTwo);
    if (FAILED(sc))
    {
        pstgOne->Release();
        return FALSE;
    }
        

    sc = CompareStorages(pstgOne, pstgTwo);
    
    pstgOne->Release();
    pstgTwo->Release();

    if (sc) 
        return TRUE;
    else
        return FALSE;
    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layoutui\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layoutui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by layoutui.rc
//
#define IDS_ADDFILES_TITLE              20
#define IDS_TEMPFILE_PREFIX             21
#define IDS_FILTER_BEGIN                100
#define IDD_MAIN                        101
#define IDS_ALL_FILES                   101
#define IDS_ALL_FILES_EXT               102
#define IDS_WORD_FILES                  103
#define IDS_WORD_FILES_EXT              104
#define IDS_EXCEL_FILES                 105
#define IDS_EXCEL_FILES_EXT             106
#define IDS_PPT_FILES                   107
#define IDS_PPT_FILES_EXT               108
#define IDS_PUB_FILES                   109
#define IDS_PUB_FILES_EXT               110
#define IDS_FILTER_END                  111
#define IDR_ACCELERATOR1                133
#define IDS_MAIN_WINDOW_FAIL            200
#define IDC_BTN_ADD                     201
#define IDS_MAIN_WINDOW_FAIL_TITLE      201
#define IDC_BTN_REMOVE                  202
#define IDS_ADDFILES_BUFFERTOOSMALL     202
#define IDC_BTN_OPTIMIZE                203
#define IDS_ADDFILES_BUFFERTOOSMALL_TITLE 203
#define IDS_OPTIMIZE_SUCCESS            204
#define IDS_OPTIMIZE_SUCCESS_TITLE      205
#define IDS_OPTIMIZE_OUTOFMEM           206
#define IDS_OPTIMIZE_OUTOFMEM_TITLE     207
#define IDS_OPTIMIZE_NOPATH             208
#define IDS_OPTIMIZE_NOPATH_TITLE       209
#define IDS_ERROR_FILE_NOT_CREATED      210
#define IDS_OPTIMIZE_FAILED             212
#define IDS_OPTIMIZE_FAILED_TITLE       213
#define IDS_FILE_BEFORE                 214
#define IDS_FILE_AFTER_NOTFOUND         215
#define IDS_FILE_AFTER_NOTDOCFILE       216
#define IDS_FILE_AFTER_CORRUPT          217
#define IDS_FILE_AFTER_COMPLETE         218
#define IDS_FILE_AFTER_FILE_NOT_OPENED  219
#define IDS_OPTIMIZING_FILES            220
#define IDS_RENAME_ERROR                221
#define IDS_RENAME_MESSAGE              222
#define IDS_DELETE_ERROR                223
#define IDS_FILE_AFTER_READ_ONLY   	224
#define IDS_OPTIMIZE_ERROR	   	225 
#define IDS_OPTIMIZE                    300
#define IDC_LIST_FILES                  301
#define IDS_CANCEL                      301
#define IDC_STATIC_FILES                401

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layoutui\laymain.cxx ===
#include "layoutui.hxx"


INT WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR  lpCmdLine,
    INT    nCmdShow
)
{
    CLayoutApp *pLayoutApp;

    pLayoutApp = new CLayoutApp(hInstance);

    if( !pLayoutApp )
        return 0;

    if( !pLayoutApp->InitApp() )
        return 0;

    return pLayoutApp->DoAppMessageLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layout\test\tutils.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	tutils.cxx
//
//  Contents:	Generic utilities for tests
//
//  History:	06-Aug-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

static BOOL fExitOnFail = TRUE;

BOOL GetExitOnFail(void)
{
    return fExitOnFail;
}

void SetExitOnFail(BOOL set)
{
    fExitOnFail = set;
}

// Print out an error message and terminate
void Fail(char *fmt, ...)
{
    va_list args;

    args = va_start(args, fmt);
    fprintf(stderr, "** Fatal error **: ");
    vfprintf(stderr, fmt, args);
    va_end(args);
    EndTest(1);
}

typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_E_EXTANTMARSHALLINGS, "STG_E_EXTANTMARSHALLINGS",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))

// Convert a status code to text
char *ScText(SCODE sc)
{
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == sc)
	    return scodes[i].text;
    return "<Unknown SCODE>";
}

// Output a call result and check for failure
HRESULT Result(HRESULT hr, char *fmt, ...)
{
    SCODE sc;
    va_list args;

    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    sc = GetScode(hr);
    printf(" - %s (0x%lX)\n", ScText(sc), sc);
    if (FAILED(sc) && fExitOnFail)
        Fail("Unexpected call failure\n");
    return hr;
}

// Perform Result() when the expectation is failure
HRESULT IllResult(HRESULT hr, char *fmt, ...)
{
    SCODE sc;
    va_list args;

    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    sc = GetScode(hr);
    printf(" - %s (0x%lX)\n", ScText(sc), sc);
    if (SUCCEEDED(sc) && fExitOnFail)
        Fail("Unexpected call success\n");
    return hr;
}

char *TcsText(TCHAR *ptcs)
{
    static char buf[256];

    TTOA(ptcs, buf, 256);
    return buf;
}

char *FileTimeText(FILETIME *pft)
{
    static char buf[80];
    struct tm ctm;
#ifndef FLAT    
    WORD dosdate, dostime;

    if (CoFileTimeToDosDateTime(pft, &dosdate, &dostime))
    {
        ctm.tm_sec   = (dostime & 31)*2;
        ctm.tm_min   = (dostime >> 5) & 63;
        ctm.tm_hour  = dostime >> 11;
        ctm.tm_mday  = dosdate & 31;
        ctm.tm_mon   = ((dosdate >> 5) & 15)-1;
        ctm.tm_year  = (dosdate >> 9)+80;
        ctm.tm_wday  = 0;
#else
    SYSTEMTIME st;
        
    if (FileTimeToSystemTime(pft, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
#endif        
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidText(GUID *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}

#define CROW 16

void BinText(ULONG cbSize, BYTE *pb)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                putchar(pb[i]);
            else
                putchar('.');
        pb += cb;
        printf("'\n");
    }
}

TCHAR *TestFile(TCHAR *ptcsName, char *pszFile)
{
    char achFn[MAX_PATH];
    char *dir, *file;
    int len;
    
    dir = getenv("DFDATA");
    if (dir)
        strcpy(achFn, dir);
    else
        strcpy(achFn, ".");
    len = strlen(achFn);
    if (achFn[len-1] != '\\')
        achFn[len++] = '\\';
        
    if (pszFile)
    {
        strcpy(achFn+len, pszFile);
    }    
    else
    {
        file = getenv("DFFILE");
        if (file)
            strcpy(achFn+len, file);
        else
            strcpy(achFn+len, "TEST.DFL");
    }
    
    ATOT(achFn, ptcsName, MAX_PATH);
    return ptcsName+len;
}

#if WIN32 == 300
char *TestFormat(DWORD *pdwFmt, DWORD *pgrfMode)
{
    char *fmt;
        
    fmt = getenv("STGFMT");
    if (fmt == NULL || !strcmp(fmt, "doc"))
    {
        fmt = "document";
        *pdwFmt = STGFMT_DOCUMENT;
    }
    else if (!strcmp(fmt, "file"))
    {
        fmt = "file";
        *pdwFmt = STGFMT_FILE;
    }
    else
    {
        fmt = "directory";
        *pdwFmt = STGFMT_DIRECTORY;
        *pgrfMode &= ~STGM_CREATE;
    }
    return fmt;
}
#endif

BOOL CompareStatStg(STATSTG *pstat1, STATSTG *pstat2)
{
    if (wcscmp(pstat1->pwcsName, pstat2->pwcsName) != 0)
    {
        printf("Names compared wrong: %ws and %ws\n",
               pstat1->pwcsName, pstat2->pwcsName);
        return FALSE;
    }
    if (pstat1->type != pstat2->type)
    {
        printf("Types compares wrong on %ws and %ws: %lu and %lu\n",
               pstat1->pwcsName,
               pstat2->pwcsName,
               pstat2->type,
               pstat2->type);
        
        return FALSE;
    }
    if (!IsEqualIID(pstat1->clsid, pstat2->clsid))
    {
        printf("Class IDs for %ws and %ws compared bad\n",
               pstat1->pwcsName,
               pstat2->pwcsName);
        return FALSE;
    }
    if (pstat1->type == STGTY_STREAM)
    {
        if ((pstat1->cbSize).QuadPart != (pstat2->cbSize).QuadPart)
        {
            printf("Sizes for %ws and %ws compared bad: %lu and %lu\n",
                   pstat1->pwcsName,
                   pstat2->pwcsName,
                   (pstat1->cbSize).LowPart,
                   (pstat2->cbSize).LowPart);
            
            return FALSE;
        }
    }
    //Also check statebits and timestamps?
    
    return TRUE;
}


BOOL CompareStreams(IStream *pstm1, IStream *pstm2)
{
    const ULONG BUFSIZE = 4096;
    BYTE buffer1[BUFSIZE];
    BYTE buffer2[BUFSIZE];
    ULONG cbRead1;
    ULONG cbRead2;
    STATSTG stat1;
    STATSTG stat2;
    LARGE_INTEGER li;
    li.QuadPart = 0;

    pstm1->Seek(li, STREAM_SEEK_SET, NULL);
    pstm2->Seek(li, STREAM_SEEK_SET, NULL);

    do
    {
        SCODE sc;
        sc = pstm1->Read(buffer1, BUFSIZE, &cbRead1);
        if (FAILED(sc))
        {
            printf("Read failed with %lx\n", sc);
            return FALSE;
        }
        sc = pstm2->Read(buffer2, BUFSIZE, &cbRead2);
        if (FAILED(sc))
        {
            printf("Read failed with %lx\n", sc);
            return FALSE;
        }
        if ((cbRead1 != cbRead2) || (memcmp(buffer1, buffer2, cbRead1) != 0))
        {
            if (cbRead1 != cbRead2)
            {
                printf("Stream compare returned different bytes read: %lu and %lu\n",
                       cbRead1,
                       cbRead2);
            }
            else
            {
                printf("Data mismatch.\n");
            }
            return FALSE;
        }
    }
    while (cbRead1 == BUFSIZE);
    
    return TRUE;
}


BOOL CompareStorages(IStorage *pstg1, IStorage *pstg2)
{
    SCODE sc1, sc2, sc;
    IStorage *pstgChild1, *pstgChild2;
    IStream *pstmChild1, *pstmChild2;
    IEnumSTATSTG *penum1, *penum2;
    STATSTG stat1, stat2;

    pstg1->EnumElements(0, 0, 0, &penum1);
    pstg2->EnumElements(0, 0, 0, &penum2);

    do
    {
        ULONG celtFetched1, celtFetched2;
        
        sc1 = penum1->Next(1, &stat1, &celtFetched1);
        if (FAILED(sc1))
        {
            printf("EnumElements 1 failed with %lx\n", sc1);
            return FALSE;
        }
        sc2 = penum2->Next(1, &stat2, &celtFetched2);
        if (FAILED(sc2) || (celtFetched1 != celtFetched2) || (sc1 != sc2))
        {
            if (FAILED(sc2))
            {
                printf("EnumElements 2 failed with %lx\n", sc2);
            }
            else
            {
                printf("Return code mismatch: %lx and %lx\n", sc1, sc2);
            }
            return FALSE;
        }
        if (celtFetched1 == 0)
        {
            //We're done.
            return TRUE;
        }
        
        if (!CompareStatStg(&stat1, &stat2))
        {
            return FALSE;
        }

        //Items have compared OK so far.  Now compare contents.
        if (stat1.type == STGTY_STREAM)
        {
            sc = pstg1->OpenStream(stat1.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild1);
            if (FAILED(sc))
            {
                printf("OpenStream on pstg1 for %ws failed with %lx\n",
                       stat1.pwcsName,
                       sc);
                return FALSE;
            }
            sc = pstg2->OpenStream(stat2.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild2);
            if (FAILED(sc))
            {
                printf("OpenStream on pstg2 for %ws failed with %lx\n",
                       stat2.pwcsName,
                       sc);
                return FALSE;
            }
            if (!CompareStreams(pstmChild1, pstmChild2))
            {
                printf("Stream compare on %ws and %ws failed.\n",
                       stat1.pwcsName,
                       stat2.pwcsName);
                return FALSE;
            }
            pstmChild1->Release();
            pstmChild2->Release();
        }
        else
        {
            //Compare storages
            sc = pstg1->OpenStorage(stat1.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild1);
            if (FAILED(sc))
            {
                printf("OpenStorage on pstg1 for %ws failed with %lx\n",
                       stat1.pwcsName,
                       sc);
                return FALSE;
            }

            sc = pstg2->OpenStorage(stat2.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild2);
            if (FAILED(sc))
            {
                printf("OpenStorage on pstg2 for %ws failed with %lx\n",
                       stat2.pwcsName,
                       sc);
                return FALSE;
            }
            if (!CompareStorages(pstgChild1, pstgChild2))
            {
                printf("CompareStorages failed for %ws and %ws\n",
                       stat1.pwcsName,
                       stat2.pwcsName);
                return FALSE;
            }
            pstgChild1->Release();
            pstgChild2->Release();
        }

        //printf("Object %ws compared OK.\n", stat1.pwcsName);
        CoTaskMemFree(stat1.pwcsName);
        CoTaskMemFree(stat2.pwcsName);

    } while (sc1 != S_FALSE);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layoutui\olesite.cxx ===
#include "layoutui.hxx"


STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, void** ppObject)
{
	if (riid==IID_IUnknown || riid==IID_IOleClientSite) 
        {
		*ppObject=(IOleClientSite*) this;
                AddRef();
        }	
        else 
        {
	        return E_NOINTERFACE;
	}
	return NO_ERROR;
}

STDMETHODIMP_(ULONG) COleClientSite::AddRef() 
{
    return InterlockedIncrement( &_cReferences);
}

STDMETHODIMP_(ULONG) COleClientSite::Release() 
{
    LONG lRef = InterlockedDecrement(&_cReferences);
    if (lRef == 0)
    {
        delete this;
    }

    return lRef;
}

STDMETHODIMP COleClientSite::SaveObject( void)
{
    return E_FAIL;
}

STDMETHODIMP COleClientSite::GetMoniker( 
     /* [in] */ DWORD dwAssign,
    /* [in] */ DWORD dwWhichMoniker,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk)
{
    return S_OK;
}

STDMETHODIMP COleClientSite::GetContainer( 
    /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer)
{
    *ppContainer=NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP COleClientSite::ShowObject( void)
{
    return S_OK;
}

STDMETHODIMP COleClientSite::OnShowWindow( 
    /* [in] */ BOOL fShow)
{
    return S_OK;
}

STDMETHODIMP COleClientSite::RequestNewObjectLayout( void)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\async\layoutui\layoutui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layoutui.cxx
//
//  Contents:	UI implementation on Docfile Layout Tool
//
//  Classes:    CLayoutApp	
//
//  Functions:	
//
//  History:	23-Mar-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layoutui.hxx"
#include <strsafe.h>

// Constants for File Addition dialogs
#define MAX_FILES_BUFFER        2048
#define MAX_TITLE_LEN           256
#define MAX_FILTER_LEN          256
#define MAX_PREFIX_LEN          5

#define WIDTH                   500
#define HEIGHT                  300

#define NULL_TERM               TEXT('\0')
#define BACKSLASH               TEXT("\\")
#define SPACE                   TEXT(' ')

#define MALLOC(x)               HeapAlloc(GetProcessHeap(), 0, x );
#define FREE(x)                 HeapFree(GetProcessHeap(), 0, x );
#define JumpOnFail(sc)          if( FAILED(sc) ) goto Err;

// Since the LayoutDlgProc must be static for the Callback,
// we need a way to reference the member variables inside of
// LayoutDlgProc
static CLayoutApp *pStaticThis;

#ifdef STRICT
static WNDPROC lpfnwpListBoxProc = NULL;
static WNDPROC lpfnwpButtonProc  = NULL;
#define SUBCLASS_WNDPROC  WNDPROC
#else
static FARPROC lpfnwpListBoxProc = NULL;
static FARPROC lpfnwpButtonProc  = NULL;
#define SUBCLASS_WNDPROC  FARPROC
#endif

// currently supported version of NT
#define NT_MAJOR_VER 3
#define NT_MINOR_VER 51
// currently supported version of Win95
#define WIN95_MAJOR_VER 4

BOOL 	g_fIsNT351 = FALSE;

//+---------------------------------------------------------------------------
//  
//  Function IsOperatingSystemOK
//  
//  Synopsis:	Checks to see if thid OS version is compatible
//              with this application. 
//              NT40 Win95 and NT3.51 are supprted.
//              Sets g_fIsNT351
//              
//  History:	27-July-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL  IsOperatingSystemOK(void)
{
    OSVERSIONINFO osversioninfo = {0};

    // get operating system info
    osversioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osversioninfo))
    {
        return FALSE;
    }

    // if NT, check version
    if (osversioninfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if ( osversioninfo.dwMajorVersion <  NT_MAJOR_VER )
        {
            return FALSE;
        }
        if ( osversioninfo.dwMajorVersion ==  NT_MAJOR_VER )
            if ( osversioninfo.dwMinorVersion <  NT_MINOR_VER )
        {
            return FALSE;
        }
        if ( osversioninfo.dwMajorVersion ==  NT_MAJOR_VER )
            if ( osversioninfo.dwMinorVersion ==  NT_MINOR_VER )
        {
            g_fIsNT351 = TRUE;
            return TRUE;
        }
        return TRUE;
        

    }
	
    // else if Win95 check version
    else if (osversioninfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {	
		if ( osversioninfo.dwMajorVersion <  WIN95_MAJOR_VER )
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    // else unrecognized OS  (should never make it here)
    else
    {
        return FALSE;
    }

    

}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::CLayoutApp public
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


CLayoutApp::CLayoutApp(HINSTANCE hInst)
{
    m_hInst        = hInst;
    m_hwndMain     = hwndNil;
    
    pStaticThis    = this;
    m_bOptimizing  = FALSE;    
    m_bCancelled   = FALSE;
    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::InitApp public
//
//  Synopsis:	Initialize the application
//
//  Returns:	TRUE is sucessful, FALSE is FAILED
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL CLayoutApp::InitApp(void)
{
    
    if (!IsOperatingSystemOK())
    {
        return FALSE;
    }

    if( !InitWindow() )
    {
        DisplayMessage(NULL, 
                    IDS_MAIN_WINDOW_FAIL,
                    IDS_MAIN_WINDOW_FAIL_TITLE, 
                    MB_ICONSTOP);
        return FALSE;
    }

    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DoAppMessageLoop public
//
//  Synopsis:	Main window message loop
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


INT CLayoutApp::DoAppMessageLoop(void)
{
    MSG msg;
    HACCEL hAccel;

    hAccel = LoadAccelerators( m_hInst, MAKEINTRESOURCE(IDR_ACCELERATOR1) );

    while (GetMessage (&msg, NULL, 0, 0))
          {
          if (m_hwndMain == 0 || !IsDialogMessage (m_hwndMain, &msg))
               {
               TranslateMessage (&msg) ;
               DispatchMessage  (&msg) ;
               }
          }
    
    return (INT) msg.wParam;
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::InitWindow public
//
//  Synopsis:	Initialize the main window
//
//  Returns:	TRUE is sucessful, FALSE is FAILED
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL CLayoutApp::InitWindow (void)
{
    m_hwndMain = CreateDialog(  m_hInst,
                 MAKEINTRESOURCE(IDD_MAIN),
                 NULL,
                 LayoutDlgProc);

    if( m_hwndMain == NULL )
        return FALSE;

    EnableButtons();
    DragAcceptFiles(m_hwndMain, TRUE);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::InitApp public
//
//  Synopsis:	Application Callback function
//
//  Returns:	TRUE is message was handled.  FALSE otherwise
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


LONG CALLBACK CLayoutApp::ListBoxWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{   
    switch (uMsg)
    {
    case WM_SETCURSOR:
        if( (HWND)wParam == pStaticThis->m_hwndMain )
            SetCursor(LoadCursor(NULL, (pStaticThis->m_bCancelled ? IDC_WAIT : IDC_ARROW)));

        return bMsgHandled;
    }

    return (LONG) CallWindowProc(lpfnwpListBoxProc, hWnd, uMsg, wParam, lParam);
}


LONG CALLBACK CLayoutApp::ButtonWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{   
    switch (uMsg)
    {
    case WM_SETCURSOR:
        if( (HWND)wParam == pStaticThis->m_hwndMain )
            SetCursor(LoadCursor(NULL, (pStaticThis->m_bCancelled ? IDC_WAIT : IDC_ARROW)));

        return bMsgHandled;
    }

    return  (LONG) CallWindowProc(lpfnwpButtonProc, hWnd, uMsg, wParam, lParam);
}


INT_PTR CALLBACK CLayoutApp::LayoutDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{   
    SCODE sc          = S_OK;
    WORD  wId         = LOWORD((DWORD)wParam);
    WORD  wNotifyCode = HIWORD((DWORD)wParam);
    DWORD thrdid;
    static HANDLE hthread;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pStaticThis->m_hwndBtnAdd      = GetDlgItem( hDlg, IDC_BTN_ADD );
        pStaticThis->m_hwndBtnRemove   = GetDlgItem( hDlg, IDC_BTN_REMOVE );
        pStaticThis->m_hwndBtnOptimize = GetDlgItem( hDlg, IDC_BTN_OPTIMIZE );
        pStaticThis->m_hwndListFiles   = GetDlgItem( hDlg, IDC_LIST_FILES );
        pStaticThis->m_hwndStaticFiles = GetDlgItem( hDlg, IDC_STATIC_FILES );

#ifdef _WIN64
        lpfnwpListBoxProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndListFiles,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ListBoxWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndBtnAdd,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndBtnRemove,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndBtnOptimize,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );
#else
        lpfnwpListBoxProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndListFiles,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ListBoxWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndBtnAdd,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndBtnRemove,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndBtnOptimize,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );
#endif // _WIN64

	// resize dialog and center it on the screen
	{
		RECT rcScreen;
		GetWindowRect(GetDesktopWindow(), &rcScreen);

		SetWindowPos(
			hDlg,
			HWND_TOP,
			(rcScreen.right - rcScreen.left - WIDTH) / 2,
			(rcScreen.bottom - rcScreen.top - HEIGHT) / 2,
			WIDTH,
			HEIGHT,
			SWP_SHOWWINDOW);
	}
        return TRUE;

    case WM_SIZE:
		pStaticThis->ReSizeWindow(lParam);
		return bMsgHandled;

    case WM_GETMINMAXINFO:
	{
	LPMINMAXINFO lpminmax = (LPMINMAXINFO) lParam;

	lpminmax->ptMinTrackSize.x = gdxWndMin;
	lpminmax->ptMinTrackSize.y = gdyWndMin;
	}
	return bMsgHandled;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        PostQuitMessage(0);
        return bMsgHandled;

    case WM_DROPFILES:
        {
            TCHAR atcFileName[MAX_PATH];
            HDROP hdrop  = (HDROP)wParam;
            INT   nFiles = DragQueryFile(hdrop, 0xFFFFFFFF, NULL, 0);
            INT   i;

            for( i=0; i < nFiles; i++ )
            {
                if( DragQueryFile(hdrop, i, atcFileName, MAX_PATH) != 0 )
                    pStaticThis->AddFileToListBox(atcFileName);
            }
            DragFinish(hdrop);
            pStaticThis->EnableButtons();
        }
        return bMsgHandled;

    case WM_SETCURSOR:
        if( (HWND)wParam == pStaticThis->m_hwndMain )
            SetCursor(LoadCursor(NULL, (pStaticThis->m_bCancelled ? IDC_WAIT : IDC_ARROW)));

        return bMsgHandled;

    case WM_COMMAND:
        switch( wId )
	{ 
	case IDC_BTN_ADD:
            pStaticThis->AddFiles();
            return bMsgHandled;

	case IDC_BTN_REMOVE:
            pStaticThis->RemoveFiles();
            return bMsgHandled;

	case IDC_BTN_OPTIMIZE:
            
            if (pStaticThis->m_bOptimizing)  //Cancel Button click
            {   
                pStaticThis->m_bCancelled = TRUE;
                
                //SetCursor(LoadCursor(NULL, IDC_WAIT));
                
                return bMsgHandled; 
            }
            else                //Optimize Button Click
            {
                
                pStaticThis->m_bOptimizing = TRUE;
                pStaticThis->SetActionButton( IDS_CANCEL );
                hthread = CreateThread(NULL,0,
                            (LPTHREAD_START_ROUTINE) &(pStaticThis->OptimizeFiles),
			     NULL, 0, &thrdid);
                
                return bMsgHandled;

            }

        case IDC_LIST_FILES:
            switch( wNotifyCode )
            {
            case LBN_SELCHANGE:
                pStaticThis->EnableButtons();
                return bMsgHandled;
            
            default:
                break;
            }

        default:
            break;
        }

        break;

    }

    return bMsgNotHandled;
}    

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::ReSizeWindow public
//
//  Synopsis:	Handle resizing the main dialog
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::ReSizeWindow (LPARAM lParam)
{
	int nW = LOWORD(lParam);
	int nH = HIWORD(lParam);

	int nBorder  = 10;
        int nButtonH = 25;
	int nButtonW = 100;
	int nStaticH = 15;

        int nListY = nBorder + nStaticH;
        int nListW = nW - 3 * nBorder - nButtonW;
        int nListH = nH - nListY - nBorder;

        int nButtonX = 2 * nBorder + nListW;

        MoveWindow(m_hwndStaticFiles, nBorder,  nBorder, nListW, nStaticH, TRUE);
        MoveWindow(m_hwndListFiles  , nBorder,  nListY,  nListW, nH - nButtonH - nBorder, TRUE);

        MoveWindow(m_hwndBtnAdd     , nButtonX, nListY, nButtonW, nButtonH, TRUE);
        MoveWindow(m_hwndBtnRemove  , nButtonX, nListY + 3 * nBorder, nButtonW, nButtonH, TRUE);
        MoveWindow(m_hwndBtnOptimize, nButtonX, nListY + nListH - nButtonH, nButtonW, nButtonH, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::AddFiles public
//
//  Synopsis:	Add and display selected files to the dialog window
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::AddFiles (void)
{
    //We add 1 to atcFile so that we can double null terminate 
    //the string they give us in the 3.51 case

    TCHAR atcFile[MAX_FILES_BUFFER +1 ];
    
    TCHAR atcTitle[MAX_TITLE_LEN];
    TCHAR atcFilter[MAX_FILTER_LEN];

    
    OPENFILENAME ofn;
    FillMemory( (LPVOID)&ofn, sizeof(ofn), 0 );

    ofn.lStructSize = sizeof( ofn );
    ofn.hwndOwner = m_hwndMain;
    ofn.hInstance = m_hInst;

    FormFilterString( atcFilter, MAX_FILTER_LEN );
    ofn.lpstrFilter = atcFilter;

    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex = 0;

    *atcFile = NULL_TERM;
    ofn.lpstrFile = atcFile;
    ofn.nMaxFile = MAX_FILES_BUFFER;

    ofn.lpstrFileTitle = NULL;
    ofn.lpstrInitialDir = NULL;

    LoadString( m_hInst, IDS_ADDFILES_TITLE, atcTitle, MAX_TITLE_LEN );
    ofn.lpstrTitle = atcTitle;

    if (g_fIsNT351)  //NT 3.51 doesn't support OFN_EXPLORER
    {
        ofn.Flags = OFN_ALLOWMULTISELECT |
                OFN_HIDEREADONLY     |
                OFN_FILEMUSTEXIST    |
                OFN_PATHMUSTEXIST;
    }
    else
    {
        ofn.Flags = OFN_ALLOWMULTISELECT |
                OFN_HIDEREADONLY     |
                OFN_EXPLORER         |
                OFN_FILEMUSTEXIST    |
                OFN_PATHMUSTEXIST;
    }

    if( !GetOpenFileName( &ofn ) )
    {
        DWORD dw = CommDlgExtendedError();
        
        if( dw == FNERR_BUFFERTOOSMALL )
            DisplayMessage( m_hwndMain,
                            IDS_ADDFILES_BUFFERTOOSMALL,
                            IDS_ADDFILES_BUFFERTOOSMALL_TITLE,
                            0);
        return;
    }

    WriteFilesToList( atcFile );
    
    EnableButtons();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::FormFilterString public
//
//  Synopsis:	Specifies which files (with which extension are to be displayed
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::FormFilterString( TCHAR *patcFilter, INT nMaxLen )
{
    int nLen;
    UINT uStrID;

    //NOTE:  the string resources must be in sequence
    uStrID = IDS_FILTER_BEGIN+1;

    // this is an internal function and so we aren't checking for
    // enough room in the string buffer, patcFilter
    while( uStrID != IDS_FILTER_END )
    {
        LoadString( m_hInst, uStrID++, patcFilter, nMaxLen );
        nLen = lstrlen( patcFilter );
        nMaxLen -= nLen + 1;
        patcFilter += nLen;
        *patcFilter++ = NULL_TERM;
    }

    *patcFilter = NULL_TERM;
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::WriteFilesToList public
//
//  Synopsis:   For NT4.0 and Win95
//              Gets and writes the files, complete with path, to the File List
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::WriteFilesToList( TCHAR *patcFilesList )
{
    TCHAR *patcDir;
    TCHAR atcFile[MAX_PATH];
    BOOL bOneFile = TRUE;
    
    patcDir = patcFilesList;
        
    if (g_fIsNT351)  
    {
        // NT 3.51 stores SPACES instead of NULLs
        // between multiple file names
        // so we need some preprocessing here
        
        while ( *patcFilesList != NULL_TERM )
        {
            if (*patcFilesList == SPACE)
            {
               *patcFilesList = NULL_TERM;
            }
            patcFilesList++;
        }

        // and we need to double NULL terminate
        *(++patcFilesList) = NULL_TERM;
         
        //reset the pointer to the start
        patcFilesList = patcDir;

    }    
    
    while( *patcFilesList++ != NULL_TERM )
        ;

    while( *patcFilesList != NULL_TERM )
    {
        bOneFile = FALSE;
        StringCbCopy ( atcFile, sizeof(atcFile), patcDir );
        StringCbCat ( atcFile, sizeof(atcFile), BACKSLASH );
        StringCbCat ( atcFile, sizeof(atcFile), patcFilesList );
        AddFileToListBox( atcFile );
        while( *patcFilesList++ != NULL_TERM )
            ;
    }

    // if only one file was selected, 
    // the filename isn't separated by it's path, 
    // but is one complete filename
    if( bOneFile )
    {
        AddFileToListBox( patcDir );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::AddFileToListBox public
//
//  Synopsis:   displays the file to the dialog list box
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::AddFileToListBox( TCHAR *patcFile )
{
    
    // add the file iff the file is not already displayed
    if (LB_ERR == SendMessage(m_hwndListFiles, 
                            LB_FINDSTRING, 
                            (WPARAM)0, 
                            (LPARAM)(LPCTSTR)patcFile))
    {
        SendMessage(m_hwndListFiles,
                    LB_ADDSTRING,
                    (WPARAM)0,
                    (LPARAM)(LPCTSTR)patcFile);
    }

    SetListBoxExtent();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::RemoveFileFromListBox public
//
//  Synopsis:   remove the displayed the file from the dialog list box
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::RemoveFileFromListBox( INT nIndex )
{
    SendMessage(m_hwndListFiles, 
                LB_DELETESTRING, 
                (WPARAM)nIndex, 
                (LPARAM)0);

    SetListBoxExtent();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::SetListBoxExtent public
//
//  Synopsis:   Handles making a horizontal scroll bar if necessary
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::SetListBoxExtent( void )
{
    INT i;
    INT nExtent = 0;
    LPARAM nItems  =  SendMessage( m_hwndListFiles,
                                LB_GETCOUNT, 
                                (WPARAM)0, 
                                (LPARAM)0);
    TCHAR atcFile[MAX_PATH];
    HDC hdc = NULL;
    SIZE size;

    
    if( nItems == 0 )
        goto lSetListBoxExtent_Exit;

    if( (hdc = GetDC(m_hwndMain)) == NULL)
        goto lSetListBoxExtent_Exit;

    for( i=0; i < (INT) nItems; i++ )
    {
        SendMessage(m_hwndListFiles, 
                    LB_GETTEXT, 
                    (WPARAM)i, 
                    (LPARAM)(LPCTSTR)atcFile);
        

        GetTextExtentPoint32(
            hdc,
            atcFile,
            lstrlen(atcFile),
            &size);

        nExtent = max(nExtent, (INT)size.cx);
    }

lSetListBoxExtent_Exit:

    if( hdc )
        ReleaseDC( m_hwndMain, hdc );

    SendMessage(m_hwndListFiles, 
                LB_SETHORIZONTALEXTENT, 
                (WPARAM)nExtent, 
                (LPARAM)0);
}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::RemoveFiles public
//
//  Synopsis:   remove one or more files from displayed list
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::RemoveFiles (void)
{
    INT  i;
    INT *pnSelItems;;
    LPARAM nSelItems = SendMessage(  m_hwndListFiles,
                                   LB_GETSELCOUNT, 
                                   (WPARAM)0, 
                                   (LPARAM)0);

    if( nSelItems == 0 )
        return;

    pnSelItems = (LPINT) MALLOC( sizeof(INT)* (INT)nSelItems );

    if( !pnSelItems )
        return;

    SendMessage(m_hwndListFiles, 
                LB_GETSELITEMS, 
                (WPARAM)nSelItems, 
                (LPARAM)(LPINT)pnSelItems);

    // start from bottom of list to keep the indices correct
    for( i= (INT)nSelItems; --i >= 0; )
        RemoveFileFromListBox( pnSelItems[i] );

    FREE( pnSelItems );

    EnableButtons();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DisplayMessage public
//
//  Synopsis:   message box general routine with no file names
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

INT CLayoutApp::DisplayMessage(HWND hWnd,
                               UINT uMessageID,
                               UINT uTitleID,
                               UINT uFlags)
{
    TCHAR atcMessage[MAX_PATH];
    TCHAR atcTitle[MAX_PATH];

    LoadString(m_hInst, uMessageID, atcMessage, MAX_PATH);
    LoadString(m_hInst, uTitleID, atcTitle, MAX_PATH);

    if( hWnd )
	SetForegroundWindow(hWnd);

    return MessageBox(hWnd, atcMessage, atcTitle, uFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DisplayMessageWithFileName public
//
//  Synopsis:   message box general routine with 1 file name
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

INT CLayoutApp::DisplayMessageWithFileName(HWND hWnd,
                               UINT uMessageIDBefore,
                               UINT uMessageIDAfter,
                               UINT uTitleID,
                               UINT uFlags,
                               TCHAR *patcFileName)
{
    TCHAR atcMessageBefore[MAX_PATH];
    TCHAR atcMessageAfter[MAX_PATH];
    TCHAR atcTitle[MAX_PATH];
    TCHAR atcFileErrorMsg[MAX_PATH*3];


    LoadString(m_hInst, uMessageIDBefore, atcMessageBefore, MAX_PATH);
    LoadString(m_hInst, uMessageIDAfter, atcMessageAfter, MAX_PATH);
    LoadString(m_hInst, uTitleID, atcTitle, MAX_PATH);

    StringCbCopy (atcFileErrorMsg, sizeof(atcFileErrorMsg), atcMessageBefore);
    StringCbCat (atcFileErrorMsg, sizeof(atcFileErrorMsg), patcFileName);
    StringCbCat (atcFileErrorMsg, sizeof(atcFileErrorMsg), atcMessageAfter);

    if( hWnd )
	SetForegroundWindow(hWnd);

    return MessageBox(hWnd, atcFileErrorMsg, atcTitle, uFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DisplayMessageWithTwoFileNames public
//
//  Synopsis:   message box general routine with 2 file names
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

INT CLayoutApp::DisplayMessageWithTwoFileNames(HWND hWnd,
                               UINT uMessageID,
                               UINT uTitleID,
                               UINT uFlags,
                               TCHAR *patcFirstFileName,
                               TCHAR *patcLastFileName)
{
    TCHAR atcMessage[MAX_PATH];
    TCHAR atcTitle[MAX_PATH];
    TCHAR atcFileErrorMsg[MAX_PATH*3];


    LoadString(m_hInst, uMessageID, atcMessage, MAX_PATH);
    LoadString(m_hInst, uTitleID, atcTitle, MAX_PATH);

    StringCbCopy (atcFileErrorMsg, sizeof(atcFileErrorMsg), patcFirstFileName);
    StringCbCat (atcFileErrorMsg, sizeof(atcFileErrorMsg), atcMessage);
    StringCbCat (atcFileErrorMsg, sizeof(atcFileErrorMsg), patcLastFileName);

    if( hWnd )
	SetForegroundWindow(hWnd);

    return MessageBox(hWnd, atcFileErrorMsg, atcTitle, uFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::EnableButtons public
//
//  Synopsis:   Updates the buttons.  Optimize turns to Cancel 
//              during optimize function.
//              Remove is greyed if no files are displayed
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::EnableButtons( BOOL bShowOptimizeBtn )
{
    LPARAM nItems    = SendMessage(  m_hwndListFiles,
                                  LB_GETCOUNT, 
                                  (WPARAM)0, 
                                  (LPARAM)0);
    LPARAM nSelItems = SendMessage(  m_hwndListFiles,
                                  LB_GETSELCOUNT, 
                                  (WPARAM)0, 
                                  (LPARAM)0);

    EnableWindow( m_hwndBtnAdd,      TRUE          );
    EnableWindow( m_hwndBtnRemove,   nSelItems > 0 );
    EnableWindow( m_hwndBtnOptimize, nItems > 0 && bShowOptimizeBtn );
}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::OptimizeFiles public
//
//  Synopsis:   Static function to call the optimizeFiles worker routine
//
//  Returns:	Appropriate status code
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

DWORD CLayoutApp::OptimizeFiles (void *args)
{
    SCODE sc;

    sc = CoInitialize(NULL);
    
    sc = pStaticThis->OptimizeFilesWorker();
    
    CoUninitialize();

    pStaticThis->HandleOptimizeReturnCode(sc);

                pStaticThis->m_bCancelled = FALSE;

                pStaticThis->SetActionButton( IDS_OPTIMIZE );
                pStaticThis->m_bOptimizing = FALSE;
                
                //SetCursor(LoadCursor(NULL, IDC_ARROW));
                    
    return 0;

    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::OptimizeFilesWorker public
//
//  Synopsis:   Optimize all the displayed files.  Make temp files,
//              optimize to temp file, then rename temp back to original file.
//
//  Returns:	Appropriate status code
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

SCODE CLayoutApp::OptimizeFilesWorker (void)
{
    INT   i, j;
    SCODE sc = S_OK;
    BOOL fResult;
    
    TCHAR atcFileName[MAX_PATH];
    TCHAR atcTempPath[MAX_PATH];
    TCHAR atcTempFile[MAX_PATH];
    TCHAR atcPrefix[MAX_PREFIX_LEN];
    TCHAR **ppatcTempFiles = NULL;
    INT   *pintErrorFlag = NULL;
    INT   nItems = (INT) SendMessage( m_hwndListFiles,
                                LB_GETCOUNT, 
                                (WPARAM)0, 
                                (LPARAM)0 );

    if( nItems == 0 )
        return S_OK;

    ppatcTempFiles = (TCHAR **) MALLOC( sizeof(TCHAR *) * nItems );
    
    if( !ppatcTempFiles )
        return STG_E_INSUFFICIENTMEMORY;

    FillMemory( (LPVOID)ppatcTempFiles, sizeof(TCHAR *) * nItems, 0 );

    pintErrorFlag = (INT *) MALLOC( sizeof(INT) * nItems );
    
    if( !pintErrorFlag )
    {
        sc = STG_E_INSUFFICIENTMEMORY;
        JumpOnFail(sc);
    }
    
    FillMemory( (LPVOID)pintErrorFlag, sizeof(INT) * nItems, 0 );
    
    UINT ui = GetTempPath(MAX_PATH, atcTempPath);
    if (0 == ui || ui > MAX_PATH)
    {   
         sc = GetLastError();
         JumpOnFail(sc);
    }

    LoadString( m_hInst, IDS_TEMPFILE_PREFIX, atcPrefix, MAX_PREFIX_LEN );

    for( i=0; i < nItems; i++ )
    {
        
        // handle Cancel pressed and cleanup
        if (m_bCancelled)
        {   
            m_bCancelled = FALSE;

            for( j=0; j < i ; j++ )
                DeleteFile(ppatcTempFiles[j]);
         
            sc = STG_E_NONEOPTIMIZED;
            JumpOnFail(sc);
        }

        if( GetTempFileName( atcTempPath, atcPrefix, (UINT)0, atcTempFile ) == 0 )
        {
            sc = GetLastError();
            JumpOnFail(sc);
        }

        ppatcTempFiles[i] =
            (TCHAR *) MALLOC( (lstrlen(atcTempFile) + 1) * sizeof(TCHAR) );

        if( !ppatcTempFiles[i] )
        {
            sc = STG_E_INSUFFICIENTMEMORY;
            JumpOnFail(sc);
        }

        StringCchCopy (ppatcTempFiles[i], lstrlen(atcTempFile)+1, atcTempFile);
    }

     
    for( i=0; i < nItems; i++ )
    {
        // handle Cancel pressed and cleanup
        if (m_bCancelled)
        {   
            m_bCancelled = FALSE;

            for( j=i; j < nItems ; j++ )
            {
                DeleteFile(ppatcTempFiles[j]);
                pintErrorFlag[j] = 1;    
            }
            sc = STG_E_NONEOPTIMIZED;
                
            for( j=nItems; --j >= 0; )
            {
                if (pintErrorFlag[j])
                {
                    RemoveFileFromListBox(j);
                }
                else 
                {
                    sc = S_OK;
                }
        
            }
            EnableButtons();
            goto Err;
        }
        
        SendMessage( m_hwndListFiles, 
                     LB_GETTEXT, 
                     (WPARAM)i, 
                     (LPARAM)(LPINT)atcFileName );

        sc = DoOptimizeFile( atcFileName, ppatcTempFiles[i] );

#if DBG==1
        //check that files are identical here.
       if ((SUCCEEDED(sc)) && (!IdenticalFiles( atcFileName, ppatcTempFiles[i])))
       {   
           sc = STG_E_DOCFILECORRUPT;
           
       }
#endif
              
        if (!SUCCEEDED(sc))
        {    
            // This file could not be optimized.  Display Error message  
            switch( sc )
            {
            // the file is read only
            case STG_E_ACCESSDENIED:
    
                DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_FILE_AFTER_READ_ONLY,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);
                break;

            // the file is not in a legal docfile format.
            case STG_E_FILEALREADYEXISTS:
        
                DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_FILE_AFTER_NOTDOCFILE,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);
                break;

            default:
                DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_OPTIMIZE_ERROR,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);       
                break;
            }
            
            pintErrorFlag[i] = 1;
            DeleteFile( ppatcTempFiles[i] );
            continue;    
        }
        
        
        //remove the (unoptimized) original file        
        fResult = DeleteFile( atcFileName );
        if (!fResult)
        {   
            sc = GetLastError();

            DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_DELETE_ERROR,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);   
                
            DisplayMessageWithTwoFileNames(m_hwndMain, 
                        IDS_RENAME_MESSAGE,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName,
                        ppatcTempFiles[i]);   

            SendMessage( m_hwndListFiles, 
                     LB_DELETESTRING, 
                     (WPARAM)i, 
                     (LPARAM)0);

            SendMessage( m_hwndListFiles, 
                     LB_INSERTSTRING, 
                     (WPARAM)i, 
                     (LPARAM)(LPINT)ppatcTempFiles[i] );
            
            continue;
        }
            
        // rename the optimized file to the original file name    
        fResult = MoveFile( ppatcTempFiles[i], atcFileName );
        
        if (!fResult)
        {   
            sc = GetLastError();

            DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_RENAME_ERROR,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        ppatcTempFiles[i]);   
                
            DisplayMessageWithTwoFileNames(m_hwndMain, 
                        IDS_RENAME_MESSAGE,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName,
                        ppatcTempFiles[i]);   

            SendMessage( m_hwndListFiles, 
                        LB_DELETESTRING, 
                        (WPARAM)i, 
                        (LPARAM)0);

            SendMessage( m_hwndListFiles, 
                        LB_INSERTSTRING, 
                        (WPARAM)i, 
                        (LPARAM)(LPINT)ppatcTempFiles[i] );
                
            continue;
        }
          
        DeleteFile( ppatcTempFiles[i] );
    }    

    // remove files from list box that could not be optimized
    //bSuccess is set if at least one file was sucessfully optimized.
    sc = STG_E_NONEOPTIMIZED;
    
    for( i=nItems; --i >= 0; )
    {
        if (pintErrorFlag[i])
        {
            RemoveFileFromListBox(i);
        }
        else 
        {
            sc = S_OK;
        }
        
    }
    EnableButtons();
Err:

    if ( pintErrorFlag )
        FREE( pintErrorFlag);

    if( ppatcTempFiles )
    {
        for( i=0; i < nItems; i++ )
        {
            if( ppatcTempFiles[i] )
                FREE( ppatcTempFiles[i] );
        }
    
        FREE( ppatcTempFiles );
    }
    return sc;
    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DoOptimizeFile public
//
//  Synopsis:   Monitor and relayout docfile to temp file.
//
//  Returns:	Appropriate status code
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

SCODE CLayoutApp::DoOptimizeFile( TCHAR *patcFileName, TCHAR *patcTempFile )
{
    IStorage        *pStg       = NULL;
    ILayoutStorage  *pLayoutStg = NULL;
    IUnknown        *punkApp    = NULL;
    IPersistStorage *pPersist   = NULL;
    IOleObject      *pObj       = NULL;
    COleClientSite  *pSite      = NULL;
    SCODE            sc         = S_OK;
    STATSTG          stat;
    OLECHAR          awcNewFileName[MAX_PATH];


    sc = StgOpenLayoutDocfile
            (TCharToOleChar(patcFileName, awcNewFileName, MAX_PATH),
             STGM_DIRECT |
             STGM_READWRITE | 
             STGM_SHARE_EXCLUSIVE, 
             NULL,
             &pStg);

 
    JumpOnFail(sc);

    sc = pStg->QueryInterface( IID_ILayoutStorage, (void**) &pLayoutStg );
    JumpOnFail(sc);

    // begin monitoring
    sc = pLayoutStg->BeginMonitor();
    JumpOnFail(sc);

    sc = pStg->Stat(&stat, STATFLAG_NONAME);
    JumpOnFail(sc);

    pStg->Release();
    pStg = NULL;
   
    // open the application type of the input storage
    sc = CoCreateInstance( stat.clsid, 
                           NULL,
                           (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD),
                           IID_IUnknown,
                           (void**) &punkApp );
    JumpOnFail(sc);
  
    // load the document through the IPersistStorage Interface
    sc = punkApp->QueryInterface( IID_IPersistStorage, (void**) &pPersist );
    JumpOnFail(sc);

    sc = pPersist->Load( pStg );
    JumpOnFail(sc);

    sc = punkApp->QueryInterface( IID_IOleObject, (void**) &pObj );
    JumpOnFail(sc);

    punkApp->Release();
    punkApp = NULL;

    // Open as a client
    pSite = new COleClientSite;
    if (NULL == pSite)
        JumpOnFail (sc = STG_E_INSUFFICIENTMEMORY);

    pSite->m_patcFile = patcFileName;
    
    sc = pObj->DoVerb(OLEIVERB_OPEN, NULL, (IOleClientSite*) pSite, 0, NULL, NULL);
    JumpOnFail(sc);

    pObj->Close( OLECLOSE_NOSAVE );
    
    // end monitoring and relayout
    if( pLayoutStg )
    {
        sc = pLayoutStg->EndMonitor();
        JumpOnFail(sc);
    
        sc = pLayoutStg->ReLayoutDocfile(
            TCharToOleChar(patcTempFile, awcNewFileName, MAX_PATH) );
        JumpOnFail(sc);
    }

Err:

    if( pStg )
        pStg->Release();

    if( punkApp )
        punkApp->Release();

    if( pSite )
        pSite->Release();

    if (pLayoutStg)
        pLayoutStg->Release();

    if (pPersist)
        pPersist->Release();

    if (pObj)
        pObj->Release();

    return sc;
  }
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::HandleOptimizeReturnCode public
//
//  Synopsis:   message box general routine to display apprpriate message 
//              based on the Optimize returned SCODE
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::HandleOptimizeReturnCode( SCODE sc )
{
    switch( sc )
    {
    case S_OK:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_SUCCESS, IDS_OPTIMIZE_SUCCESS_TITLE, 0);
        break;

    case STG_E_FILENOTFOUND:
    case STG_E_INSUFFICIENTMEMORY:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_OUTOFMEM, IDS_OPTIMIZE_OUTOFMEM_TITLE, 0);
        break;
    
    case STG_E_PATHNOTFOUND:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_NOPATH, IDS_OPTIMIZE_NOPATH_TITLE, 0);
        break;
    case STG_E_NONEOPTIMIZED:
        // already displayed errors for why each file could not be optimized.
        break;

    default:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_FAILED, IDS_OPTIMIZE_FAILED_TITLE, 0);
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::TCharToOleChar public
//
//  Synopsis:   helper function for UNICODE/ANSI TCHAR to OLEchar conversion
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


OLECHAR *CLayoutApp::TCharToOleChar(TCHAR *patcSrc, OLECHAR *pawcDst, INT nDstLen)
{
#ifdef UNICODE
    
    // this is already UNICODE
    return patcSrc;

#else

    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    *pawcDst = NULL_TERM;

    // convert to UNICODE
    MultiByteToWideChar(
        uCodePage,
        0,
        patcSrc,
        -1,
        pawcDst,
        nDstLen-1 );

    return pawcDst;

#endif
}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::SetActionButton public
//
//  Synopsis:   change the text of the button
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::SetActionButton( UINT uID )
{
    TCHAR atcText[MAX_PATH];

    LoadString( m_hInst, uID, atcText, MAX_PATH );

    SetWindowText( m_hwndBtnOptimize, atcText );

    UpdateWindow( m_hwndMain );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\chinst.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       chinst.cxx
//
//  Contents:   DocFile child instance management code
//
//  History:    19-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

// Permissions checked in the less-restrictive rule
#define TCANTSET DF_READ
#define DCANTSET (DF_READ | DF_WRITE)
#define CANTCLEAR (DF_DENYREAD | DF_DENYWRITE)

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::Add, private
//
//  Synopsis:   Registers an instance of a child
//
//  Arguments:  [prv] - Child
//
//  History:    17-Oct-91       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_Add)
#endif

void CChildInstanceList::Add(PRevertable *prv)
{
    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::Add(%p)\n", prv));
    prv->_prvNext = _prvHead;
    _prvHead = P_TO_BP(CBasedRevertablePtr, prv);
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::Add\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FindByName, private
//
//  Synopsis:   Finds a child instance by name
//
//  Arguments:  [pdfn] - Name
//
//  Returns:    Pointer to instance or NULL
//
//  History:    12-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_FindByName)
#endif

PRevertable *CChildInstanceList::FindByName(CDfName const *pdfn)
{
    PRevertable *prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FindByName:%p(%ws)\n",
                this, pdfn->GetBuffer()));
    for (prv = BP_TO_P(PRevertable *, _prvHead);
         prv;
         prv = BP_TO_P(PRevertable *, prv->_prvNext))
    {
        if (prv->_dfn.IsEqual(pdfn))
            return prv;
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FindByName\n"));
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FlushBufferedData, private
//
//  Synopsis:   Calls each child, instructing it to flush property data.
//
//  Arguments:  [recursionlevel] -- current level in hierachy below initial
//                                  entry point.
//
//  Returns:    SCODE
//
//  History:    5-May-1995       BillMo Created
//
//----------------------------------------------------------------------------

#ifdef NEWPROPS

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_FindByName)
#endif

SCODE CChildInstanceList::FlushBufferedData(int recursionlevel)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FlushBufferedData:%p\n",
                this));

    for (prv = BP_TO_P(PRevertable *, _prvHead);
         prv && sc == S_OK;
         prv = BP_TO_P(PRevertable *, prv->_prvNext))
    {
        sc = prv->FlushBufferedData(recursionlevel + 1);
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FlushBufferedData\n"));
    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::DeleteByName, private
//
//  Synopsis:   Removes an instance from the instance list
//              and reverts it
//
//  Arguments:  [pdfn] - Name or NULL
//
//  History:    17-Oct-91       DrewB   Created
//
//  Notes:      The entry does not have to exist
//              There can be multiple entries
//              If name is NULL, all entries match
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_DeleteByName)
#endif

void CChildInstanceList::DeleteByName(CDfName const *pdfn)
{
    CBasedRevertablePtr *pprv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::DeleteByName(%ws)\n",
                pdfn->GetBuffer()));
    for (pprv = &_prvHead; *pprv; )
        if (NULL == pdfn || (*pprv)->_dfn.IsEqual(pdfn))
        {
            (*pprv)->RevertFromAbove();
            *pprv = (*pprv)->_prvNext;
        }
        else
            pprv = &(*pprv)->_prvNext;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::DeleteByName\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::RemoveRv, private
//
//  Synopsis:   Removes a specific instance from the instance list
//
//  Arguments:  [prv] - Instance
//
//  History:    17-Oct-91       DrewB   Created
//
//  Notes:      The entry does not have to exist
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_RemoveRv)
#endif

void CChildInstanceList::RemoveRv(PRevertable *prvRv)
{
    CBasedRevertablePtr *prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::RemoveRv(%p)\n", prvRv));
    for (prv = &_prvHead; *prv; prv = &(*prv)->_prvNext)
        if (*prv == prvRv)
        {
            *prv = (*prv)->_prvNext;
            break;
        }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::RemoveRv\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::IsDenied, private
//
//  Synopsis:   Checks the parent instantiation list for a previous
//              instance of the given child with DENY flags on
//              Also determines whether child mode flags are
//              less restrictive than the parent's
//
//  Arguments:  [pdfn] - Instance name
//              [dfCheck] - Access modes to check for denial
//              [dfAgainst] - Access modes to check against
//
//  Returns:    Appropriate status code
//
//  History:    17-Oct-91       DrewB   Created
//              28-Oct-92       AlexT   Converted to names
//
//  Notes:      The instance doesn't have to be in the list.
//              If it isn't, it's not denied
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_IsDenied)
#endif

SCODE CChildInstanceList::IsDenied(CDfName const *pdfn,
                                   DFLAGS const dfCheck,
                                   DFLAGS const dfAgainst)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::IsDenied("
                "%p, %lX, %lX)\n", pdfn, dfCheck, dfAgainst));

    olAssert(pdfn != NULL && aMsg("IsDenied, null name"));

    // Check to see if permissions are less restrictive than
    // parent permissions
    // This checks to see that a child isn't specifying
    // a permission that its parent doesn't
    // For example, giving read permission when the parent
    // doesn't
    if ((~dfAgainst & dfCheck &
         (P_TRANSACTED(dfAgainst) ? TCANTSET : DCANTSET)) ||
        (dfAgainst & ~dfCheck & CANTCLEAR))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // Check for DENY_*
    olAssert((DF_DENYALL >> DF_DENIALSHIFT) == DF_READWRITE);
    for (prv = BP_TO_P(PRevertable *, _prvHead);
         prv != NULL; prv = prv->GetNext())
    {
        if (prv->_dfn.IsEqual(pdfn))
        {
            // Check for existing instance with DENY_* mode
            if ((((prv->GetDFlags() & DF_DENYALL) >> DF_DENIALSHIFT) &
                 dfCheck) != 0 ||
            // Check for instance with permission already given that
            // new instance wants to deny
                (((dfCheck & DF_DENYALL) >> DF_DENIALSHIFT) &
                 prv->GetDFlags()) != 0)
            {
                sc = STG_E_ACCESSDENIED;
                break;
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::IsDenied\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member: CChildInstanceList::EmptyCache, public
//
//  Synopsis:   empties the stream caches
//
//  History:    22-Jun-99   HenryLee  Created
//
//---------------------------------------------------------------

void CChildInstanceList::EmptyCache ()
{
    for (PRevertable *prv = BP_TO_P(PRevertable *, _prvHead);
         prv != NULL; prv = prv->GetNext())
    {
        prv->EmptyCache();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\cdocfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       cdocfile.cxx
//
//  Contents:   Implementation of CDocFile methods for DocFiles
//
//  History:    11-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <vectfunc.hxx>

//+--------------------------------------------------------------
//
//  Member:     CDocFile::InitFromEntry, public
//
//  Synopsis:   Creation/Instantiation constructor for embeddings
//
//  Arguments:  [pstghParent] - Parent handle
//              [pdfn] - Name
//              [fCreate] - Create/Instantiate
//              [dwType] - Type of entry
//
//  Returns:    Appropriate status code
//
//  History:    16-Dec-91       DrewB   Created
//
//  Algorithm:  Create or get the entry from the multistream
//
//---------------------------------------------------------------

SCODE CDocFile::InitFromEntry(CStgHandle *pstghParent,
                              CDfName const *pdfn,
                              BOOL const fCreate)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::InitFromEntry(%p, %ws, %d)\n",
                pstghParent, pdfn, fCreate));
    if (fCreate)
        sc = pstghParent->CreateEntry(pdfn, STGTY_STORAGE, &_stgh);
    else
        sc = pstghParent->GetEntry(pdfn, STGTY_STORAGE, &_stgh);

    if (SUCCEEDED(sc))
        AddRef();
    olDebugOut((DEB_ITRACE, "Out CDocFile::InitFromEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::CreateDocFile, public
//
//  Synopsis:   Creates a DocFile object in a parent
//
//  Arguments:  [pdfn] - Name of DocFile
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry
//              [ppdfDocFile] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    11-Dec-91       DrewB   Created
//
//  Algorithm:  Allocate new docfile and init from given entry
//
//---------------------------------------------------------------

SCODE CDocFile::CreateDocFile(CDfName const *pdfn,
                              DFLAGS const df,
                              DFLUID dlSet,
                              PDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateDocFile:%p("
                "%ws, %X, %lu, %p)\n", this, pdfn, df, dlSet,
                ppdfDocFile));

    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDocFile::GetNewLuid(_pdfb->GetMalloc());

    pdf = GetReservedDocfile(dlSet);
    olAssert(pdf != NULL && aMsg("Reserved Docfile not found"));

    if (pdf != NULL)
        olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, TRUE));

    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdf:
    pdf->ReturnToReserve(BP_TO_P(CDFBasis *,_pdfb));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetDocFile, public
//
//  Synopsis:   Instantiates an existing docfile
//
//  Arguments:  [pdfn] - Name of stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppdfDocFile] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    11-Dec-91       DrewB   Created
//
//  Algorithm:  Allocate new docfile and init from given entry
//
//---------------------------------------------------------------

SCODE CDocFile::GetDocFile(CDfName const *pdfn,
                           DFLAGS const df,
                           PDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n", this, pdfn, df, ppdfDocFile));

    UNREFERENCED_PARM(df);

    DFLUID dl = CDocFile::GetNewLuid(_pdfb->GetMalloc());
    olMem(pdf = new (_pdfb->GetMalloc()) CDocFile(dl,
                                                  BP_TO_P(CDFBasis *, _pdfb)));

    olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, FALSE));

    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdf:
    delete pdf;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::RenameEntry, public
//
//  Synopsis:   Renames a child
//
//  Arguments:  [pdfnName] - Old name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    12-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::RenameEntry(CDfName const *pdfnName,
                            CDfName const *pdfnNewName)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::RenameEntry(%ws, %ws)\n",
                pdfnName, pdfnNewName));
    sc = _stgh.RenameEntry(pdfnName, pdfnNewName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::RenameEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently destroys a child
//
//  Arguments:  [pdfnName] - Name of child
//              [fClean] - Ignored
//
//  Returns:    Appropriate status code
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::DestroyEntry(CDfName const *pdfnName,
                             BOOL fClean)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));
    UNREFERENCED_PARM(fClean);
    sc = _stgh.DestroyEntry(pdfnName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DestroyEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::IsEntry, public
//
//  Synopsis:   Determines whether the given object is a member
//              of the DocFile
//
//  Arguments:  [pdfnName] - Name
//              [peb] - Entry buffer to fill in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [peb]
//
//  History:    07-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::IsEntry(CDfName const *pdfnName,
                        SEntryBuffer *peb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::IsEntry(%ws, %p)\n",
                pdfnName, peb));
    sc = _stgh.IsEntry(pdfnName, peb);
    olDebugOut((DEB_ITRACE, "Out CDocFile::IsEntry => %lu, %lu, %lu\n",
                sc, peb->luid, peb->dwType));
    return sc;
}

#ifdef INDINST
//+--------------------------------------------------------------
//
//  Member:     CDocFile::Destroy, public
//
//  Synopsis:   Destroys the DocFile
//
//  History:    12-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

void CDocFile::Destroy(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFile::Destroy()\n"));
    olAssert(_cReferences == 1);
    olVerSucc(_stgh.DestroyEntry(NULL);
    CDocFile::Release();
    olDebugOut((DEB_ITRACE, "Out CDocFile::Destroy\n"));
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetTime, public
//
//  Synopsis:   Gets a time
//
//  Arguments:  [wt] - Which time
//              [ptm] - Time return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ptm]
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    return _stgh.GetTime(wt, ptm);
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetAllTimes, public
//
//  Synopsis:   Gets all time values
//
//  Arguments:  [patm] - Access Time
//              [pmtm] - Modification Time
//		[pctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:   [patm]
//		[pmtm]
//		[pctm]	
//
//  History:    26-May-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CDocFile::GetAllTimes(TIME_T *patm, TIME_T *pmtm, TIME_T *pctm)
{
    return _stgh.GetAllTimes(patm, pmtm, pctm);
}
//+--------------------------------------------------------------
//
//  Member:     CDocFile::SetAllTimes, public
//
//  Synopsis:   Sets all time values
//
//  Arguments:  [atm] - Access Time
//              [mtm] - Modification Time
//				[ctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:  	
//
//  History:    22-Nov-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CDocFile::SetAllTimes(TIME_T atm, TIME_T mtm, TIME_T ctm)
{
    return _stgh.SetAllTimes(atm, mtm, ctm);
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::SetTime, public
//
//  Synopsis:   Sets a time
//
//  Arguments:  [wt] - Which time
//              [tm] - New time
//
//  Returns:    Appropriate status code
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::SetTime(WHICHTIME wt, TIME_T tm)
{
    return _stgh.SetTime(wt, tm);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetClass, public
//
//  Synopsis:   Gets the class ID
//
//  Arguments:  [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetClass(CLSID *pclsid)
{
    return _stgh.GetClass(pclsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - New class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetClass(REFCLSID clsid)
{
    return _stgh.SetClass(clsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetStateBits, public
//
//  Synopsis:   Gets the state bits
//
//  Arguments:  [pgrfStateBits] - State bits return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pgrfStateBits]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    return _stgh.GetStateBits(pgrfStateBits);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - Bits to set
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return _stgh.SetStateBits(grfStateBits, grfMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\debug.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992
//
//  File:       debug.cxx
//
//  Contents:   Debugging routines
//
//  History:    07-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#if DBG == 1

#include <stdarg.h>
#include <dfdeb.hxx>
#include <logfile.hxx>
#include <df32.hxx>

//+-------------------------------------------------------------
//
//  Function:   DfDebug, public
//
//  Synopsis:   Sets debugging level
//
//---------------------------------------------------------------

DECLARE_INFOLEVEL(ol);

#define LOGFILENAME L"logfile.txt"

static CGlobalFileStream *_pgfstLogFiles = NULL;
WCHAR gwcsLogFile[] = LOGFILENAME;

STDAPI_(void) DfDebug(ULONG ulLevel, ULONG ulMSFLevel)
{
#if DBG == 1
    olInfoLevel = ulLevel;
    SetInfoLevel(ulMSFLevel);
    _SetWin4InfoLevel(ulLevel | ulMSFLevel);

    olDebugOut((DEB_ITRACE, "\n--  DfDebug(0x%lX, 0x%lX)\n",
                ulLevel, ulMSFLevel));
#endif
}

// Resource limits

static LONG lResourceLimits[CDBRESOURCES] =
{
    0x7fffffff,                         // DBR_MEMORY
    0x7fffffff,                         // DBR_XSCOMMITS
    0x0,                                // DBR_FAILCOUNT
    0x0,                                // DBR_FAILLIMIT
    0x0,                                // DBR_FAILTYPES
    0x0,                                // DBRQ_MEMORY_ALLOCATED
    0x0,                                // DBRI_ALLOC_LIST
    0x0,                                // DBRI_LOGFILE_LIST
    0x0,                                // DBRF_LOGGING
    0x0,                                // DBRQ_HEAPS
    0x0                                 // DBRF_SIFTENABLE
};

#define CBRESOURCES sizeof(lResourceLimits)

#define RESLIMIT(n) lResourceLimits[n]
#define TAKEMTX
#define RELEASEMTX

//+---------------------------------------------------------------------------
//
//  Function:   DfSetResLimit, public
//
//  Synopsis:   Sets a resource limit
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(void) DfSetResLimit(UINT iRes, LONG lLimit)
{
    TAKEMTX;

    RESLIMIT(iRes) = lLimit;

    RELEASEMTX;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfGetResLimit, public
//
//  Synopsis:   Gets a resource limit
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(LONG) DfGetResLimit(UINT iRes)
{
    // Doesn't need serialization
    return RESLIMIT(iRes);
}

STDAPI_(void) DfSetFailureType(LONG lTypes)
{
    RESLIMIT(DBR_FAILTYPES) = lTypes;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   HaveResource, private
//
//  Synopsis:   Checks to see if a resource limit is exceeded
//              and consumes resource if not
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

BOOL HaveResource(UINT iRes, LONG lRequest)
{
    if (RESLIMIT(DBRF_SIFTENABLE) == FALSE)
        return TRUE;

    if (RESLIMIT(iRes) >= lRequest)
    {
        TAKEMTX;

        RESLIMIT(iRes) -= lRequest;

        RELEASEMTX;

        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ModifyResLimit, private
//
//  Synopsis:   Adds to a resource limit
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

LONG ModifyResLimit(UINT iRes, LONG lChange)
{
    LONG l;

    TAKEMTX;

    RESLIMIT(iRes) += lChange;
    l = RESLIMIT(iRes);

    RELEASEMTX;

    return l;
}

//+-------------------------------------------------------------------------
//
//  Function:   SimulateFailure
//
//  Synopsis:   Check for simulated failure
//
//  Effects:    Tracks failure count
//
//  Arguments:  [failure] -- failure type
//
//  Returns:    TRUE if call should fail, FALSE if call should succeed
//
//  Modifies:   RESLIMIT(DBR_FAILCOUNT)
//
//  Algorithm:  Increment failure count, fail if count has succeeded
//              limit
//
//  History:    21-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

BOOL SimulateFailure(DBFAILURE failure)
{
    LONG l;
    BOOL fFail;

    //  We don't special case failure types, yet.

    if (RESLIMIT(DBRF_SIFTENABLE) != FALSE &&
        (failure & RESLIMIT(DBR_FAILTYPES)))
    {
        TAKEMTX;

        RESLIMIT(DBR_FAILCOUNT)++;
        l = RESLIMIT(DBR_FAILLIMIT);
        fFail = RESLIMIT(DBR_FAILCOUNT) >= l;

        RELEASEMTX;

        if (l == 0)
        {
            //  We're not simulating any failures;  just tracking them
            return(FALSE);
        }

        return fFail;
    }
    else
    {
        return FALSE;
    }
}

//+--------------------------------------------------------------
//
//  Class:      CChecksumBlock (cb)
//
//  Purpose:    Holds a memory block that is being checksummed
//
//  Interface:  See below
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

class CChecksumBlock
{
public:
    CChecksumBlock(char *pszName,
                   void *pvAddr,
                   ULONG cBytes,
                   DWORD dwFlags,
                   CChecksumBlock *pcbNext,
                   CChecksumBlock *pcbPrev);
    ~CChecksumBlock(void);

    char *_pszName;
    void *_pvAddr;
    ULONG _cBytes;
    DWORD _dwFlags;
    CChecksumBlock *_pcbNext, *_pcbPrev;
    ULONG _ulChecksum;
};

// Global list of checksummed blocks
static CChecksumBlock *pcbChkBlocks = NULL;

//+--------------------------------------------------------------
//
//  Member:     CChecksumBlock::CChecksumBlock, private
//
//  Synopsis:   Ctor
//
//  Arguments:  [pszName] - Block name
//              [pvAddr] - Starting addr
//              [cBytes] - Length
//              [dwFlags] - Type flags
//              [pcbNext] - Next checksum block
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

CChecksumBlock::CChecksumBlock(char *pszName,
                               void *pvAddr,
                               ULONG cBytes,
                               DWORD dwFlags,
                               CChecksumBlock *pcbNext,
                               CChecksumBlock *pcbPrev)
{
    ULONG i;
    char *pc;

    olVerify(_pszName = new char[strlen(pszName)+1]);
    StringCchCopyA (_pszName, strlen(pszName)+1, pszName);
    _pvAddr = pvAddr;
    _cBytes = cBytes;
    _dwFlags = dwFlags;
    _pcbNext = pcbNext;
    if (pcbNext)
        pcbNext->_pcbPrev = this;
    _pcbPrev = pcbPrev;
    if (pcbPrev)
        pcbPrev->_pcbNext = this;
    _ulChecksum = 0;
    pc = (char *)pvAddr;
    for (i = 0; i<cBytes; i++)
        _ulChecksum += *pc++;
}

//+--------------------------------------------------------------
//
//  Member:     CChecksumBlock::~CChecksumBlock, private
//
//  Synopsis:   Dtor
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

CChecksumBlock::~CChecksumBlock(void)
{
    delete _pszName;
}

//+--------------------------------------------------------------
//
//  Function:   DbgChkBlocks, private
//
//  Synopsis:   Verify checksums on all current blocks
//
//  Arguments:  [dwFlags] - Types of blocks to check
//              [pszFile] - File check was called from
//              [iLine] - Line in file
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgChkBlocks(DWORD dwFlags, char *pszFile, int iLine)
{
    CChecksumBlock *pcb;

    for (pcb = pcbChkBlocks; pcb; pcb = pcb->_pcbNext)
        if (pcb->_dwFlags & dwFlags)
        {
            ULONG i, ulSum = 0;
            char *pc;

            for (pc = (char *)pcb->_pvAddr, i = 0; i<pcb->_cBytes; i++)
                ulSum += *pc++;
            if (ulSum != pcb->_ulChecksum)
                olDebugOut((DEB_ERROR, "* Bad checksum %s:%d '%s' %p:%lu *\n",
                            pszFile, iLine, pcb->_pszName,
                            pcb->_pvAddr, pcb->_cBytes));
            else if (dwFlags & DBG_VERBOSE)
                olDebugOut((DEB_ERROR, "* Checksum passed %s:%d"
                            " '%s' %p:%lu *\n",
                            pszFile, iLine, pcb->_pszName,
                            pcb->_pvAddr, pcb->_cBytes));
        }
}

//+--------------------------------------------------------------
//
//  Function:   DbgAddChkBlock, private
//
//  Synopsis:   Adds a checksum block
//
//  Arguments:  [pszName] - Name of block
//              [pvAddr] - Starting addr
//              [cBytes] - Length
//              [dwFlags] - Type flags
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgAddChkBlock(char *pszName,
                    void *pvAddr,
                    ULONG cBytes,
                    DWORD dwFlags)
{
    CChecksumBlock *pcb;

    olVerify(pcb = new CChecksumBlock(pszName, pvAddr, cBytes,
                                      dwFlags, pcbChkBlocks, NULL));
    pcbChkBlocks = pcb;
}

//+--------------------------------------------------------------
//
//  Function:   DbgFreeChkBlock, private
//
//  Synopsis:   Removes a block from the list
//
//  Arguments:  [pvAddr] - Block's check address
//
//  History:    10-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgFreeChkBlock(void *pvAddr)
{
    CChecksumBlock *pcb;

    for (pcb = pcbChkBlocks; pcb; pcb = pcb->_pcbNext)
        if (pcb->_pvAddr == pvAddr)
        {
            if (pcb->_pcbPrev)
                pcb->_pcbPrev->_pcbNext = pcb->_pcbNext;
            else
                pcbChkBlocks = pcb->_pcbNext;
            if (pcb->_pcbNext)
                pcb->_pcbNext->_pcbPrev = pcb->_pcbPrev;
            delete pcb;
            return;
        }
}

//+--------------------------------------------------------------
//
//  Function:   DbgFreeChkBlocks, private
//
//  Synopsis:   Frees all checksum blocks
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgFreeChkBlocks(void)
{
    CChecksumBlock *pcb;

    while (pcbChkBlocks)
    {
        pcb = pcbChkBlocks->_pcbNext;
        delete pcbChkBlocks;
        pcbChkBlocks = pcb;
    }
}

static CGlobalFileStream *g_pDebugLogGlobalFileStream = NULL;

inline CGlobalFileStream *GetGlobalFileStream()
{
    return g_pDebugLogGlobalFileStream;
}

inline void SetGlobalFileStream(CGlobalFileStream *pgfst)
{
    g_pDebugLogGlobalFileStream = pgfst;
}

#ifdef MULTIHEAP
static CFileStream *g_pDebugLogFileStream = NULL;
#endif


SCODE GetLogFile(CFileStream **pfs)
#ifdef MULTIHEAP
{
    // Do not use shared memory to write log files
    SCODE sc = S_OK;

    if (GetGlobalFileStream() == NULL)
    {
        g_pDebugLogGlobalFileStream = ::new CGlobalFileStream
                (NULL, 0, LOGFILEDFFLAGS, LOGFILESTARTFLAGS);
        SetGlobalFileStream (g_pDebugLogGlobalFileStream);

        g_pDebugLogFileStream = ::new CFileStream (NULL);
    }
    g_pDebugLogFileStream->InitFromGlobal(GetGlobalFileStream());
    *pfs = g_pDebugLogFileStream;
    return sc;
}
#else
{
    SCODE sc = S_OK;
    CFileStream *pfsLoop = NULL;

    *pfs = NULL;

    if (GetGlobalFileStream() == NULL)
    {
        IMalloc *pMalloc;

        olHChk(DfCreateSharedAllocator(&pMalloc));
        SetGlobalFileStream(new (pMalloc) CGlobalFileStream(pMalloc,
                                                            0, LOGFILEDFFLAGS,
                                                            LOGFILESTARTFLAGS));
        pMalloc->Release();
    }

    if (GetGlobalFileStream() != NULL)
    {
        pfsLoop = GetGlobalFileStream()->Find(GetCurrentContextId());

        if (pfsLoop == NULL)
        {
            IMalloc *pMalloc;
            olHChk(DfCreateSharedAllocator(&pMalloc));

            pfsLoop = new (pMalloc) CFileStream(pMalloc);
            pMalloc->Release();

            if (pfsLoop != NULL)
                pfsLoop->InitFromGlobal(GetGlobalFileStream());
        }
    }

EH_Err:
    *pfs = pfsLoop;
    return sc;
}
#endif // MULIHEAP

SCODE _FreeLogFile(void)
{
#ifdef MULTIHEAP
    if (GetGlobalFileStream())
    {
        g_pDebugLogFileStream->RemoveFromGlobal();
        memset (g_pDebugLogGlobalFileStream, 0, sizeof(CContextList));
        ::delete g_pDebugLogFileStream;
        ::delete g_pDebugLogGlobalFileStream;
        SetGlobalFileStream (NULL);
    }
    return S_OK;
#else
    CFileStream *pfsLoop = NULL;

    if (GetGlobalFileStream())
        pfsLoop = GetGlobalFileStream()->Find(GetCurrentContextId());

    if (pfsLoop != NULL)
    {
        pfsLoop->vRelease();
        GetGlobalFileStream()->Release();
        SetGlobalFileStream(NULL);
        return S_OK;
    }

    return STG_E_UNKNOWN;
#endif
}

long cLogNestings = 0;

void OutputLogfileMessage(char const *format, ...)
{
    int length;
    char achPreFormat[] = "PID[%lx] TID[%lx] ";
    char achBuffer[256];
    ULONG cbWritten;
    CFileStream *pfs = NULL;
    va_list arglist;
    STATSTG stat;

    if (cLogNestings > 0)
        return;

    TAKEMTX;
    cLogNestings++;

    va_start(arglist, format);

    GetLogFile(&pfs);

    if (NULL != pfs)
    {
        pfs->InitFile(gwcsLogFile);
        pfs->Stat(&stat, STATFLAG_NONAME);

        if (DfGetResLimit(DBRF_LOGGING) & DFLOG_PIDTID)
        {
            //  Prepare prefix string
            StringCbPrintfA(achBuffer, sizeof(achBuffer), "PID[%8lx] TID[%8lx] ",
                             GetCurrentProcessId(), GetCurrentThreadId());

            //  length does not include NULL terminator
            length = (int) strlen(achBuffer);

            pfs->WriteAt(stat.cbSize, achBuffer, length, &cbWritten);
            stat.cbSize.LowPart += cbWritten;
        }

        //  Write caller data to logfile
        StringCbVPrintfA(achBuffer, sizeof(achBuffer), format, arglist);

        length = (int) strlen(achBuffer);
        for (int i = 0; i < length; i++)
        {
            if (((achBuffer[i] < 32) || (achBuffer[i] > 127)) &&
                (achBuffer[i] != '\n') && (achBuffer[i] != '\t'))
            {
                achBuffer[i] = '.';
            }
        }

        pfs->WriteAt(stat.cbSize, achBuffer, length, &cbWritten);
    }

    cLogNestings--;
    RELEASEMTX;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\dfbasis.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dfbasis.cxx
//
//  Contents:   Docfile basis implementation
//
//  History:    28-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <sstream.hxx>
#include <ole.hxx>
#include <entry.hxx>
#include <smalloc.hxx>
#include <lock.hxx>

size_t CDFBasis::_aReserveSize[CDFB_CLASSCOUNT] =
{
    sizeof(CDocFile),
    sizeof(CDirectStream),
    sizeof(CWrappedDocFile),
    sizeof(CTransactedStream)
};

//+--------------------------------------------------------------
//
//  Member:     CDFBasis::Release, public
//
//  Synopsis:   Decrease reference count and free memory
//
//  History:    02-Mar-92       DrewB   Created
//		24-Jul-95	SusiA   Take mutex prior to delete
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDFBasis_vRelease)
#endif

void CDFBasis::vRelease(void)
{
    LONG lRet;
    
    olDebugOut((DEB_ITRACE, "In  CDFBasis::Release()\n"));
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
#if !defined(MULTIHEAP)
        //take the mutex here instead of in the allocator.
        g_smAllocator.GetMutex()->Take(DFM_TIMEOUT); 
#endif
	delete this;
#if !defined(MULTIHEAP)
	g_smAllocator.GetMutex()->Release();
#endif
 
    
    }
    olDebugOut((DEB_ITRACE, "Out CDFBasis::Release()\n"));
}

#ifdef DIRECTWRITERLOCK
//+--------------------------------------------------------------
//
//  Member:     CDFBasis::TryReadLocks, public
//
//  Synopsis:   attempts to obtain read locks
//
//  Arguments:  [ulOpenLock] - lock index for this open docfile
//              [ulMask]     - range lock mask
//
//  History:    30-Apr-96    HenryLee     Created
//
//  Notes:      tree mutex and update lock must be taken
//
//---------------------------------------------------------------
HRESULT CDFBasis::TryReadLocks (CGlobalContext *pgc, ULONG ulMask) 
{
    HRESULT sc = S_OK;
    ULARGE_INTEGER cbLength = {0,0};
    ULARGE_INTEGER ulOffset = {0,0};
    ILockBytes *plst = GetBase();

    olAssert (pgc != NULL);

    ULISetLow(cbLength, COPENLOCKS);
        
    ULISetLow(ulOffset, ODIRECTWRITERLOCK & ulMask);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    olVerSucc(plst->UnlockRegion(ulOffset,cbLength,LOCK_ONLYONCE));

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDFBasis::WaitForWriteAccess, public
//
//  Synopsis:   attempts to obtain write access
//
//  Arguments:  [dwTimeout]  - in milliseconds
//              [ulOpenLock] - lock index for this open docfile
//
//  History:    30-Apr-96    HenryLee     Created
//
//  Notes:      tree mutex must be taken
//
//---------------------------------------------------------------
HRESULT CDFBasis::WaitForWriteAccess (DWORD dwTimeout, CGlobalContext *pgc)
{
    olDebugOut((DEB_ITRACE,"In  CDFBasis::WaitForWriteAccess(%d)\n",dwTimeout));

    HRESULT sc = S_OK;
    BOOL    fUpdateLocked = FALSE;
    BOOL    fDenyLocked = FALSE;
    ULARGE_INTEGER cbLength = {0,0};
    ULARGE_INTEGER ulOffset = {0,0};
    ILockBytes *plst = GetBase();
    const ULONG ulMask = 0xFFFFFFFF;

    // lock out other opens
    ULISetLow(ulOffset, OUPDATE & ulMask);
    ULISetLow(cbLength, 1);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    fUpdateLocked = TRUE;

    // lock out future readers
    ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
    ULISetLow(cbLength, COPENLOCKS);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    fDenyLocked = TRUE;

    // try to identify current readers
    sc = TryReadLocks (pgc, ulMask);

    if (sc == STG_E_LOCKVIOLATION && dwTimeout != 0)
    {
        const DWORD dwWaitInitial = 100;
        DWORD dwWait = dwWaitInitial, dwWaitTotal = 0; 
        for (;;)
        {
            sc = TryReadLocks (pgc, ulMask);
            if (sc != STG_E_LOCKVIOLATION || dwWaitTotal >= dwTimeout)
            {
                break;
            }
            Sleep(dwWait);
            dwWaitTotal += dwWait;
            dwWait *= 2;
        }
    }

EH_Err:
    if (fDenyLocked && !SUCCEEDED(sc))

    {
        ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
        ULISetLow(cbLength, COPENLOCKS);
        olVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }

    if (fUpdateLocked)
    {
        ULISetLow(ulOffset, OUPDATE & ulMask);
        ULISetLow(cbLength, 1);
        olVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }

    if (sc == STG_E_LOCKVIOLATION) sc = STG_E_INUSE;
    if (SUCCEEDED(sc)) _fWriteLocked = TRUE;

    olDebugOut((DEB_ITRACE,"Out CDFBasis::WaitForWriteAccess(%x)\n", sc));
    return sc;
};

//+--------------------------------------------------------------
//
//  Member:     CDFBasis::ReleaseWriteAccess, public
//
//  Synopsis:   relinquishes write access
//              releases all locks except for ulOpenLock
//
//  History:    30-Apr-96    HenryLee     Created
//
//  Notes:      tree mutex must be taken
//
//---------------------------------------------------------------
HRESULT CDFBasis::ReleaseWriteAccess ()
{
    olDebugOut((DEB_ITRACE,"In  CDFBasis::ReleaseWriteAccess()\n"));

    HRESULT sc = S_OK;
    BOOL    fUpdateLocked = FALSE;
    ULARGE_INTEGER cbLength = {0,0};
    ULARGE_INTEGER ulOffset = {0,0};
    const ULONG ulMask = 0xFFFFFFFF;
    ILockBytes *plst = GetBase();

    // lock out other opens
    ULISetLow(ulOffset, OUPDATE & ulMask);
    ULISetLow(cbLength, 1);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    fUpdateLocked = TRUE;

    // undo WaitForWriteAccess
    ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
    ULISetLow(cbLength, COPENLOCKS);
    olChk(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));

EH_Err:
    if (fUpdateLocked)
    {
        ULISetLow(ulOffset, OUPDATE & ulMask);
        ULISetLow(cbLength, 1);
        olVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }

    if (SUCCEEDED(sc)) _fWriteLocked = FALSE;

    olDebugOut((DEB_ITRACE,"Out CDFBasis::ReleaseWriteAccess(%x)\n", sc));
    return sc;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\dfhead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dfhead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    26-Oct-92 AlexT    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <ole2.h>

#include <propset.h>
#include <propapi.h>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <propstm.hxx>

#include <msf.hxx>

#include <olesem.hxx>
#include <dfexcept.hxx>
#include <docfilep.hxx>
#include <publicdf.hxx>
#include <psstream.hxx>
#include <wdocfile.hxx>
#include <dffuncs.hxx>
#include <funcs.hxx>
#include <debug.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\dfiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dfiter.cxx
//
//  Contents:   Implementations of CDocFile iterator methods
//
//  History:    16-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Member:	CDocFile::FindGreaterEntry, public
//
//  Synopsis:	Returns the next greater child
//
//  Arguments:	[pdfnKey] - Previous key
//              [pib] - Fast iterator buffer
//              [pstat] - Full iterator buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

SCODE CDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                 SIterBuffer *pib,
                                 STATSTGW *pstat)
{
    SID sidChild;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::FindGreaterEntry:%p(%p, %p, %p)\n",
                this, pdfnKey, pib, pstat));
    olAssert((pib == NULL) != (pstat == NULL));

    if (SUCCEEDED(sc = _stgh.GetMS()->GetChild(_stgh.GetSid(), &sidChild)))
    {
        if (sidChild == NOSTREAM)
        {
            sc = STG_E_NOMOREFILES;
        }
        else
        {
            SID sid = 0;  // initialize recursion count to 0
            if (SUCCEEDED(sc = _stgh.GetMS()->FindGreaterEntry(sidChild,
                                                               pdfnKey,
                                                               &sid)))
            {
                sc = _stgh.GetMS()->StatEntry(sid, pib, pstat);
            }
        }
    }

    olDebugOut((DEB_ITRACE, "Out CDocFile::FindGreaterEntry\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDocFile::StatEntry, public
//
//  Synopsis:	Gets information for a child
//
//  Arguments:	[pdfn] - Child name
//              [pib] - Short information
//              [pstat] - Full information
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

SCODE CDocFile::StatEntry(CDfName const *pdfn,
                          SIterBuffer *pib,
                          STATSTGW *pstat)
{
    SEntryBuffer eb;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::StatEntry:%p(%p, %p, %p)\n",
                this, pdfn, pib, pstat));
    olAssert((pib == NULL) != (pstat == NULL));

    olChk(_stgh.GetMS()->IsEntry(_stgh.GetSid(), pdfn, &eb));
    sc = _stgh.GetMS()->StatEntry(eb.sid, pib, pstat);

    olDebugOut((DEB_ITRACE, "Out CDocFile::StatEntry\n"));
 EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\dffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       dffuncs.cxx
//
//  Contents:   Private support functions for the DocFile code
//
//  Methods:    StartMS
//              DeleteContents
//
//  History:    11-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Method:     CDocFile::DeleteContents, public
//
//  Synopsis:   Deletes all entries in a DocFile recursing on entries
//              with children
//
//  Returns:    Appropriate status code
//
//  History:    25-Sep-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::DeleteContents(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DeleteContents()\n"));
    sc = _stgh.DestroyEntry(NULL);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DeleteContents\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CDocFile::ApplyChanges, public
//
//  Synopsis:   Applies a list of updates to a docfile
//              Creates source entries in destination and links
//              them to child instances in the given TL
//
//  Arguments:  [ulChanged] - List of changes
//
//  Returns:    Appropriate status code
//
//  History:    12-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::ApplyChanges(CUpdateList &ulChanged)
{
    SCODE sc = S_OK;
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CDocFile::ApplyChanges(%p)\n",
                ulChanged.GetHead()));

    for (pud = ulChanged.GetHead(); pud; pud = pud->GetNext())
    {
        if (pud->IsDelete())
            olChk(DestroyEntry(pud->GetOriginalName(), FALSE));
        else if (pud->IsRename())
            olChk(RenameEntry(pud->GetOriginalName(),
                              pud->GetCurrentName()));
        else
        {
            olAssert(pud->IsCreate());
            olChk(CreateFromUpdate(pud, this, DF_WRITE));
        }
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::ApplyChanges\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::CopyTo, public
//
//  Synopsis:   Copies the contents of one DocFile to another
//
//  Arguments:  [pdfTo] - Destination DocFile
//              [dwFlags] - Control flags
//              [snbExclude] - Partial instantiation list
//
//  Returns:    Appropriate status code
//
//  History:    26-Sep-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::CopyTo(CDocFile *pdfTo,
                       DWORD dwFlags,
                       SNBW snbExclude)
{
    CDfName dfnKey;
    SIterBuffer ib;
    PSStream *psstFrom = NULL, *psstTo = NULL;
    CDocFile *pdfFromChild = NULL, *pdfToChild = NULL;
    DFLUID dlLUID = DF_NOLUID;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CopyTo:%p(%p, %lX, %p)\n", this,
               pdfTo, dwFlags, snbExclude));
    for (;;)
    {
	if (FAILED(FindGreaterEntry(&dfnKey, &ib, NULL)))
	    break;
        dfnKey.Set(&ib.dfnName);

        switch(REAL_STGTY(ib.type))
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            olChkTo(EH_pwcsName, GetDocFile(&ib.dfnName, DF_READ, ib.type,
                                            (PDocFile **)&pdfFromChild));
            // Destination must be a direct docfile
            olChkTo(EH_Get, CDocFile::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
            olChkTo(EH_Reserve, pdfTo->CreateDocFile(&ib.dfnName, DF_WRITE,
                                                     dlLUID, ib.type,
                                                   (PDocFile **)&pdfToChild));
            if (dwFlags & CDF_EXACT)
                pdfToChild->CopyTimesFrom(pdfFromChild);

            CLSID clsid;
            olChkTo(EH_Create, pdfFromChild->GetClass(&clsid));
            olChkTo(EH_Create, pdfToChild->SetClass(clsid));

            DWORD grfStateBits;
            olChkTo(EH_Create, pdfFromChild->GetStateBits(&grfStateBits));
            olChkTo(EH_Create, pdfToChild->SetStateBits(grfStateBits,
                                                        0xffffffff));

            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && NameInSNB(&ib.dfnName, snbExclude) ==
                  S_OK))
                olChkTo(EH_Create,
                        pdfFromChild->CopyTo(pdfToChild, dwFlags, NULL));

            pdfFromChild->Release();
            pdfToChild->Release();
            break;

        case STGTY_STREAM:
            olChkTo(EH_pwcsName, GetStream(&ib.dfnName, DF_READ,
                                           ib.type, &psstFrom));
            // Destination must be a direct docfile
            olChkTo(EH_Get,
                    CDirectStream::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
            
            olChkTo(EH_Reserve,
                    pdfTo->CreateStream(&ib.dfnName, DF_WRITE, dlLUID,
                                        ib.type, &psstTo));

            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && NameInSNB(&ib.dfnName, snbExclude) ==
                  S_OK))
                olChkTo(EH_Create, CopySStreamToSStream(psstFrom, psstTo));

            psstFrom->Release();
            psstTo->Release();
            break;

        default:
            olAssert(!aMsg("Unknown entry type in CDocFile::CopyTo"));
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::CopyTo\n"));
    return S_OK;

 EH_Create:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE && pdfToChild)
        pdfToChild->Release();
    else if (REAL_STGTY(ib.type) == STGTY_STREAM && psstTo)
        psstTo->Release();
    olAssert(&ib.dfnName);
    olVerSucc(pdfTo->DestroyEntry(&ib.dfnName, TRUE));
    goto EH_Get;
 EH_Reserve:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE)
        CDocFile::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
    else if (REAL_STGTY(ib.type) == STGTY_STREAM)
        CDirectStream::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Get:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE && pdfFromChild)
        pdfFromChild->Release();
    else if (REAL_STGTY(ib.type) == STGTY_STREAM && psstFrom)
        psstFrom->Release();
 EH_pwcsName:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\dfname.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	dfname.cxx
//
//  Contents:	CDfName implementation
//
//  History:	14-May-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:	CDfName::IsEqual, public
//
//  Synopsis:	Compares two CDfNames
//
//  Arguments:	[pdfn] - Name to compare against
//
//  Returns:	TRUE/FALSE
//
//  History:	11-May-93	DrewB	Created
//
//----------------------------------------------------------------------------

BOOL CDfName::IsEqual(CDfName const *pdfn) const
{
    if (_cb != pdfn->_cb)
        return FALSE;
    return dfwcsnicmp((WCHAR *)_ab, (WCHAR *)pdfn->_ab, _cb/sizeof(WCHAR)) == 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDfName::CopyString, public
//
//  Synopsis:	Makes a proper copy of a name in a WCHAR string
//
//  Arguments:	[pwcs] - String
//
//  History:	14-May-93	DrewB	Created
//
//  Notes:	Uses leading characters to determine the format of
//              the name in the string
//
//----------------------------------------------------------------------------

void CDfName::CopyString(WCHAR const *pwcs)
{
    Set(pwcs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\dfxact.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dfxact.cxx
//
//  Contents:   CDocFile transactioning methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CDocFile::BeginCommitFromChild, public
//
//  Synopsis:   Start two-phase commit, requested by child
//
//  Arguments:  [ulChanged] - Update list
//              [dwFlags] - Flags controlling commit
//              [pdfChild] - Child object
//
//  Returns:    Appropriate status code
//
//  History:    04-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::BeginCommitFromChild(CUpdateList &ulChanged,
                                     DWORD const dwFlags,
                                     CWrappedDocFile *pdfChild)
{
    SCODE sc;
    TIME_T tm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::BeginCommitFromChild:%p("
                "%p, %lX, %p)\n", this, ulChanged.GetHead(), dwFlags,
                pdfChild));
    UNREFERENCED_PARM(dwFlags);

    // Copy-on-write will back these changes out if they fail
    if (pdfChild->GetDirty() & DIRTY_CREATETIME)
    {
        olVerSucc(pdfChild->GetTime(WT_CREATION, &tm));
        olChk(SetTime(WT_CREATION, tm));
    }
    if (pdfChild->GetDirty() & DIRTY_MODIFYTIME)
    {
        olVerSucc(pdfChild->GetTime(WT_MODIFICATION, &tm));
        olChk(SetTime(WT_MODIFICATION, tm));
    }
    if (pdfChild->GetDirty() & DIRTY_ACCESSTIME)
    {
        olVerSucc(pdfChild->GetTime(WT_ACCESS, &tm));
        olChk(SetTime(WT_ACCESS, tm));
    }
    if (pdfChild->GetDirty() & DIRTY_CLASS)
    {
        CLSID clsid;

        olVerSucc(pdfChild->GetClass(&clsid));
        olChk(SetClass(clsid));
    }
    if (pdfChild->GetDirty() & DIRTY_STATEBITS)
    {
        DWORD grfStateBits;

        olVerSucc(pdfChild->GetStateBits(&grfStateBits));
        olChk(SetStateBits(grfStateBits, 0xffffffff));
    }

    _ulChangedHolder = ulChanged;
    sc = ApplyChanges(ulChanged);

    olDebugOut((DEB_ITRACE, "Out CDocFile::BeginCommitFromChild\n"));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::EndCommitFromChild
//
//  Synopsis:   Ends two-phase commit, requested by child
//
//  Arguments:  [df] - COMMIT/ABORT
//              [pdfChild] - Child object
//
//  History:    07-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

void CDocFile::EndCommitFromChild(DFLAGS const df,
                                  CWrappedDocFile *pdfChild)
{
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CDocFile::EndCommitFromChild:%p(%X, %p)\n",
                this, df, pdfChild));

    UNREFERENCED_PARM(pdfChild);

    if (P_COMMIT(df))
    {
        // Finalize updates
        for (pud = _ulChangedHolder.GetHead(); pud; pud = pud->GetNext())
            if (pud->IsCreate())
                // Remove reference to child's XSM so that list destruction
                // won't free it
                pud->SetXSM(NULL);
        _ulChangedHolder.Empty();
    }
    else
    {
        for (pud = _ulChangedHolder.GetTail(); pud; pud = pud->GetPrev())
            if (pud->IsCreate())
            {
                // We need to do two things:
                //
                // Break any SetBase links that might have been created
                //
                // Return newly created objects to the creators so
                // that they can be returned to the preallocation
                // pool

                if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                    STGTY_STORAGE)
                {
                    CWrappedDocFile *pwdf = (CWrappedDocFile *)pud->GetXSM();
                    CDocFile *pddf;

                    if (pwdf != NULL && 
                        (pddf = (CDocFile *)pwdf->GetBase()) != NULL)
                    {
                        // AddRef so SetBase won't free memory
                        pddf->AddRef();
                        pwdf->SetBase(NULL);
                        ReturnDocFile(pddf);
                    }
                }
                else
                {
                    CTransactedStream *pwstm = (CTransactedStream *)pud->
                        GetXSM();
                    CDirectStream *pdstm;

                    olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
                             == STGTY_STREAM);
                    if (pwstm != NULL &&
                        (pdstm = (CDirectStream *)pwstm->GetBase()) != NULL)
                    {
                        // AddRef so SetBase won't free memory
                        pdstm->AddRef();
                        pwstm->SetBase(NULL);
                        ReturnStream(pdstm);
                    }
                }
            }
        _ulChangedHolder.Unlink();
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::EndCommitFromChild\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\dfstream.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dfstream.cxx
//
//  Contents:   Implementations of CDocFile stream methods
//
//  History:    18-Oct-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Method:     CDocFile::CreateStream, public
//
//  Synopsis:   Creates a named stream in a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry to be created
//              [ppsstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppsstStream]
//
//  History:    22-Aug-91       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDocFile_CreateStream) // Dirdf_Create_TEXT
#endif

SCODE CDocFile::CreateStream(CDfName const *pdfn,
                             DFLAGS const df,
                             DFLUID dlSet,
                             PSStream **ppsstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateStream("
            "%ws, %X, %lu, %p)\n",
                pdfn, df, dlSet, ppsstStream));

    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDirectStream::GetNewLuid(_pdfb->GetMalloc());
#ifndef REF
    pstm = new (BP_TO_P(CDFBasis *, _pdfb)) CDirectStream(dlSet);
    olAssert(pstm != NULL && aMsg("Reserved stream unavailable"));
#else
    olMem(pstm = new CDirectStream(dlSet));
#endif //!REF

    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, TRUE));

    *ppsstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateStream => %p\n",
                *ppsstStream));
    return S_OK;

EH_pstm:
#ifndef REF
    pstm->ReturnToReserve(BP_TO_P(CDFBasis *, _pdfb));
#else
    delete pstm;
EH_Err:
#endif //!REF
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CDocFile::GetStream, public
//
//  Synopsis:   Retrieves an existing stream from a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppsstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppsstStream]
//
//  History:    22-Aug-91       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDocFile_GetStream) // Dirdf_Open_TEXT
#endif

SCODE CDocFile::GetStream(CDfName const *pdfn,
                          DFLAGS const df,
                          PSStream **ppsstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetStream(%ws, %X, %p)\n",
                pdfn, df, ppsstStream));

    UNREFERENCED_PARM(df);

    DFLUID dl = CDirectStream::GetNewLuid(_pdfb->GetMalloc());
#ifndef REF
    olMem(pstm = new(_pdfb->GetMalloc()) CDirectStream(dl));
#else
    olMem(pstm = new CDirectStream(dl));
#endif //!REF

    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, FALSE));

    *ppsstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetStream => %p\n",
                *ppsstStream));
    return S_OK;

EH_pstm:
    delete pstm;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\entry.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       entry.cxx
//
//  Contents:   Entry implementations
//
//  History:    29-Jul-92       DrewB   Created
//              10-Apr-95       HenryLee remove Sleep
//
//---------------------------------------------------------------

#include <dfhead.cxx>
#include <smalloc.hxx>

#pragma hdrstop

#define PDOCFILE_VCALL(x)                             \
    if (_sig == CDOCFILE_SIG)                         \
        return ((CDocFile *)this)->x;                 \
    else if (_sig == CWRAPPEDDOCFILE_SIG)             \
        return ((CWrappedDocFile *)this)->x;          \
    else olAssert (!"Invalid signature on PDocFile!");\
    return STG_E_INVALIDFUNCTION;                     

#define PSSTREAM_VCALL(x)                             \
    if (_sig == CDIRECTSTREAM_SIG)                    \
        return ((CDirectStream *)this)->x;            \
    else if (_sig == CTRANSACTEDSTREAM_SIG)           \
        return ((CTransactedStream *)this)->x;        \
    else olAssert (!"Invalid signature on PSStream!");\
    return STG_E_INVALIDFUNCTION;

#define PTIMEENTRY_VCALL(x)                           \
    if (_sig == CDOCFILE_SIG)                         \
        return ((CDocFile *)this)->x;                 \
    else if (_sig == CWRAPPEDDOCFILE_SIG)             \
        return ((CWrappedDocFile *)this)->x;          \
    else olAssert (!"Invalid signature on PTimeEntry");\
    return STG_E_INVALIDFUNCTION;

//+--------------------------------------------------------------
//
//  Member:     PTimeEntry::CopyTimesFrom, public
//
//  Synopsis:   Copies one entries times to another
//
//  Arguments:  [ptenFrom] - From
//
//  Returns:    Appropriate status code
//
//  History:    29-Jul-92       DrewB   Created
//		26-May-95	SusiA	Removed GetTime; Added GetAllTimes
//		22-Nov-95	SusiA	SetAllTimes at once
//
//---------------------------------------------------------------

SCODE PTimeEntry::CopyTimesFrom(PTimeEntry *ptenFrom)
{
    SCODE sc;
    TIME_T atm;  //Access time
    TIME_T mtm;	 //Modification time
    TIME_T ctm;  //Creation time

    olDebugOut((DEB_ITRACE, "In  PTimeEntry::CopyTimesFrom(%p)\n",
                ptenFrom));
    olChk(ptenFrom->GetAllTimes(&atm, &mtm, &ctm));
    olChk(SetAllTimes(atm, mtm, ctm));
    olDebugOut((DEB_ITRACE, "Out PTimeEntry::CopyTimesFrom\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	PBasicEntry::GetNewLuid, public
//
//  Synopsis:	Returns a new luid
//
//  History:	21-Oct-92	AlexT	Created
//
//---------------------------------------------------------------

//We used to have a mutex here - it turns out that this is unnecessary,
//  since we're already holding the tree mutex.  We get a performance
//  win by eliminating the mutex.

DFLUID PBasicEntry::GetNewLuid(const IMalloc *pMalloc)
{
    DFLUID luid;

    luid = ((CSmAllocator *)pMalloc)->IncrementLuid();
    return luid;
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::GetTime, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    PTIMEENTRY_VCALL (GetTime (wt, ptm));
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::SetTime, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::SetTime(WHICHTIME wt, TIME_T tm)
{
    PTIMEENTRY_VCALL (SetTime (wt, tm));
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::GetAllTimes, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::GetAllTimes(TIME_T *patm, TIME_T *pmtm, TIME_T *pctm)
{
    PTIMEENTRY_VCALL (GetAllTimes (patm, pmtm, pctm));
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::SetTime, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::SetAllTimes(TIME_T atm, TIME_T mtm, TIME_T ctm)
{
    PTIMEENTRY_VCALL (SetAllTimes (atm, mtm, ctm));
}

//+--------------------------------------------------------------
//
//  Member:     PBasicEntry::Release, public
//
//  Synopsis:   Release resources for a PBasicEntry
//
//  History:    11-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

void PBasicEntry::Release(void)
{
    LONG lRet;

    olDebugOut((DEB_ITRACE, "In  PBasicEntry::Release()\n"));
    olAssert(_cReferences > 0);

    lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        if (_sig == CDOCFILE_SIG)
            delete (CDocFile *)this;
        else if (_sig == CWRAPPEDDOCFILE_SIG)
            delete (CWrappedDocFile *)this;
        else if (_sig == CDIRECTSTREAM_SIG)
            delete (CDirectStream *)this;
        else if (_sig == CTRANSACTEDSTREAM_SIG)
            delete (CTransactedStream *)this;
        else
            olAssert (!"Invalid signature on PBasicEntry!");
    }
    olDebugOut((DEB_ITRACE, "Out PBasicEntry::Release\n"));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::BeginCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PSStream::BeginCommitFromChild(
#ifdef LARGE_STREAMS
                ULONGLONG ulSize,
#else
                ULONG ulSize,
#endif
                CDeltaList *pDelta,
                CTransactedStream *pstChild)
{
    PSSTREAM_VCALL (BeginCommitFromChild (ulSize, pDelta, pstChild));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::EndCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PSStream::EndCommitFromChild(DFLAGS df, CTransactedStream *pstChild)
{
    if (_sig == CDIRECTSTREAM_SIG)
        ((CDirectStream *)this)->EndCommitFromChild (df, pstChild);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->EndCommitFromChild (df, pstChild);
    else olAssert (!"Invalid signature on PSStream!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PSStream::EmptyCache, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PSStream::EmptyCache()
{
    if (_sig == CDIRECTSTREAM_SIG)
        ((CDirectStream *)this)->EmptyCache();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->EmptyCache();
    else olAssert (!"Invalid signature on PSStream!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PSStream::GetDeltaList, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

CDeltaList * PSStream::GetDeltaList(void)
{
    if (_sig == CDIRECTSTREAM_SIG)
        return ((CDirectStream *)this)->GetDeltaList ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        return ((CTransactedStream *)this)->GetDeltaList ();
    else olAssert (!"Invalid signature on PSStream!");
    return NULL;
}

//+--------------------------------------------------------------
//
//  Member: PSStream::ReadAt, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PSStream::ReadAt(
#ifdef LARGE_STREAMS
                ULONGLONG ulOffset,
#else
                ULONG ulOffset,
#endif
                VOID *pBuffer,
                ULONG ulCount,
                ULONG STACKBASED *pulRetval)
{
    PSSTREAM_VCALL (ReadAt (ulOffset, pBuffer, ulCount, pulRetval));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::WriteAt, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PSStream::WriteAt(
#ifdef LARGE_STREAMS
                ULONGLONG ulOffset,
#else
                ULONG ulOffset,
#endif
                VOID const *pBuffer,
                ULONG ulCount,
                ULONG STACKBASED *pulRetval)
{
    PSSTREAM_VCALL (WriteAt (ulOffset, pBuffer, ulCount, pulRetval));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::SetSize, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE PSStream::SetSize(ULONGLONG ulNewSize)
#else
SCODE PSStream::SetSize(ULONG ulNewSize)
#endif
{
    PSSTREAM_VCALL (SetSize (ulNewSize));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::GetSize, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
void PSStream::GetSize(ULONGLONG *pulSize)
#else
void PSStream::GetSize(ULONG *pulSize)
#endif
{
    if (_sig == CDIRECTSTREAM_SIG)
        ((CDirectStream *)this)->GetSize (pulSize);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->GetSize (pulSize);
    else olAssert (!"Invalid signature on PSStream!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::DestroyEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::DestroyEntry(CDfName const *pdfnName,
                               BOOL fClean)
{
    PDOCFILE_VCALL (DestroyEntry(pdfnName, fClean));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::RenameEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::RenameEntry(CDfName const *pdfnName,
                  CDfName const *pdfnNewName)
{
    PDOCFILE_VCALL (RenameEntry (pdfnName, pdfnNewName));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetClass, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetClass(CLSID *pclsid)
{
    PDOCFILE_VCALL (GetClass (pclsid));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::SetClass, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::SetClass(REFCLSID clsid)
{
    PDOCFILE_VCALL (SetClass (clsid));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetStateBits, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    PDOCFILE_VCALL (GetStateBits (pgrfStateBits));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::SetStateBits, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    PDOCFILE_VCALL (SetStateBits (grfStateBits, grfMask));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::CreateDocFile, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::CreateDocFile(CDfName const *pdfnName,
                DFLAGS const df,
                DFLUID luidSet,
                PDocFile **ppdfDocFile)
{
    PDOCFILE_VCALL (CreateDocFile (pdfnName, df, luidSet, ppdfDocFile));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetDocFile, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetDocFile(CDfName const *pdfnName,
                 DFLAGS const df,
                 PDocFile **ppdfDocFile)
{
    PDOCFILE_VCALL (GetDocFile (pdfnName, df, ppdfDocFile));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::CreateStream, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::CreateStream(CDfName const *pdfnName,
                   DFLAGS const df,
                   DFLUID luidSet,
                   PSStream **ppsstStream)
{
    PDOCFILE_VCALL (CreateStream (pdfnName, df, luidSet, ppsstStream));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetStream, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetStream(CDfName const *pdfnName,
                DFLAGS const df,
                PSStream **ppsstStream)
{
    PDOCFILE_VCALL (GetStream (pdfnName, df, ppsstStream));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::FindGreaterEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                   SIterBuffer *pib,
                                   STATSTGW *pstat)
{
    PDOCFILE_VCALL (FindGreaterEntry (pdfnKey, pib, pstat));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::StatEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::StatEntry(CDfName const *pdfn,
                            SIterBuffer *pib,
                            STATSTGW *pstat)
{
    PDOCFILE_VCALL (StatEntry (pdfn, pib, pstat));
}


//+--------------------------------------------------------------
//
//  Member: PDocFile::BeginCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::BeginCommitFromChild(CUpdateList &ulChanged,
                       DWORD const dwFlags,
                                       CWrappedDocFile *pdfChild)
{
    PDOCFILE_VCALL (BeginCommitFromChild (ulChanged, dwFlags, pdfChild));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::EndCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PDocFile::EndCommitFromChild(DFLAGS const df,
                                    CWrappedDocFile *pdfChild)
{
    if (_sig == CDOCFILE_SIG)
        ((CDocFile *)this)->EndCommitFromChild (df, pdfChild);
    else if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->EndCommitFromChild (df, pdfChild);
    else olAssert (!"Invalid signature on PTimeEntry!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::IsEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::IsEntry(CDfName const *pdfnName,
              SEntryBuffer *peb)
{
    PDOCFILE_VCALL (IsEntry (pdfnName, peb));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::DeleteContents, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::DeleteContents(void)
{
    PDOCFILE_VCALL (DeleteContents());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\fastlock.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       fastlock.cxx
//
//  Contents:   Implementation of CDfMutex methods for DocFiles
//
//  History:    26-Jul-94       DonnaLi   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>
#pragma hdrstop

#include <df32.hxx>
#include <secdes.hxx>   // from com\inc

#ifdef UNICODE
#define GLOBAL_CS L"GlobalCsMutex"
#else
#define GLOBAL_CS "GlobalCsMutex"
#endif

//
// This is the number of characters to skip over in the name
// pased to CDfMutex::Init.  The name consists of the string
// OleDfRoot followed by the hex representation of a unique
// number for each Docfile.  We skip CHARS_TO_SKIP number of
// characters in the name to produce a related and yet unique
// name for the file mapping containing global state for the
// critical section.
//
#define CHARS_TO_SKIP 3


//+--------------------------------------------------------------
//
//  Member:     CDfMutex::Init, public
//
//  Synopsis:   This routine creates and initializes the global
//              critical section if it does not already exist.
//              It then attaches to the global critical section.
//
//  Arguments:  [lpName] - Supplies the critical section name
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Uses a mutex to serialize global critical section
//              creation and initialization
//              The name passed in is used to create or open the
//              semaphore embedded in the global critical section.
//              The name with the first CHARS_TO_SKIP characters
//              skipped is used to create or open the file mapping
//              containing global state of the critical section.
//              If a file mapping with that name already exists,
//              it is not reinitialized.  The caller instead just
//              attaches to it.
//
//---------------------------------------------------------------

SCODE
CDfMutex::Init(
    TCHAR * lpName
    )
{
    HANDLE                  hGlobalMutex;
    SCODE                   scResult = S_OK;
    DWORD                   dwResult;
    LPSECURITY_ATTRIBUTES   lpsa = NULL;

#if WIN32 == 100 || WIN32 > 200
    CGlobalSecurity         gs;
    if (FAILED(scResult = gs.Init(TRUE))) return scResult;
#else
    LPSECURITY_ATTRIBUTES gs = NULL;
#endif

#ifndef MULTIHEAP
#if WIN32 == 100 || WIN32 > 200
    CWorldSecurityDescriptor wsd;
    SECURITY_ATTRIBUTES secattr;

    secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
    secattr.lpSecurityDescriptor = &wsd;
    secattr.bInheritHandle = FALSE;
#endif

    //
    // Serialize all global critical section initialization
    //

    hGlobalMutex = CreateMutex(
#if WIN32 == 100 || WIN32 > 200
            &secattr,           //  LPSECURITY_ATTRIBUTES   lpsa
#else
            gs,
#endif
            TRUE,               //  BOOL                    fInitialOwner
            GLOBAL_CS           //  LPCTSTR                 lpszMutexName
            );

    //
    // If the mutex create/open failed, then bail
    //

    if ( !hGlobalMutex )
    {
        return LAST_SCODE;
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS )
    {

        //
        // Since the mutex already existed, the request for ownership has
        // no effect.
        //
        // wait for the mutex
        //

        if ( WaitForSingleObject (hGlobalMutex, INFINITE) == WAIT_FAILED )
        {
            scResult = LAST_SCODE;
            CloseHandle (hGlobalMutex);
            return scResult;
        }
    }

    //
    // We now own the global critical section creation mutex. Create/Open the
    // named semaphore.
    //
#endif

    _hLockSemaphore = CreateSemaphore (
            gs,             //  LPSECURITY_ATTRIBUTES   lpsa
            0,              //  LONG                    cSemInitial
            MAXLONG-1,      //  LONG                    cSemMax
            lpName          //  LPCTSTR                 lpszSemName
            );

    //
    // If the semaphore create/open failed, then bail
    //

    if ( !_hLockSemaphore )
    {
        scResult = LAST_SCODE;
    }
    else
    {
        //
        // Create/open a shared file mapping object
        // If we created it, we need to initialize the global structure.
        // Otherwise just point to it.
        // The global critical section creation mutex allows us to do
        // this safely.
        //

        _hSharedMapping = CreateFileMappingT (
                INVALID_HANDLE_VALUE, //  HANDLE                  hFile
                gs,                 //  LPSECURITY_ATTRIBUTES   lpsa
                PAGE_READWRITE,     //  DWORD                   fdwProtect
                0,                  //  DWORD               dwMaximumSizeHigh
                1024,               //  DWORD               dwMaximumSizeLow
                lpName+CHARS_TO_SKIP//  LPCTSTR             lpszMapName
                );

        if ( !_hSharedMapping )
        {
            scResult = LAST_SCODE;
            CloseHandle (_hLockSemaphore);
            _hLockSemaphore = (HANDLE)NULL;
        }
        else
        {
            dwResult = GetLastError();

            _pGlobalPortion = (PGLOBAL_SHARED_CRITICAL_SECTION)
                    MapViewOfFile (
                    _hSharedMapping,    //  HANDLE          hMapObject
                    FILE_MAP_WRITE,     //  DWORD           fdwAccess
                    0,                  //  DWORD           dwOffsetHigh
                    0,                  //  DWORD           dwOffsetLow
                    0                   //  DWORD           cbMap
                    );

            if (!_pGlobalPortion)
            {
                scResult = LAST_SCODE;
                CloseHandle (_hLockSemaphore);
                _hLockSemaphore = (HANDLE)NULL;
                CloseHandle (_hSharedMapping);
                _hSharedMapping = (HANDLE)NULL;
            }
            else if (dwResult != ERROR_ALREADY_EXISTS )
            {
                //
                // We created the file mapping, so initialize the
                // global portion.
                //

                _pGlobalPortion->LockCount = -1;
#ifdef SUPPORT_RECURSIVE_LOCK
                _pGlobalPortion->RecursionCount = 0;
                _pGlobalPortion->OwningThread = 0;
#else
#if DBG == 1
                _pGlobalPortion->OwningThread = 0;
#endif
#endif
                _pGlobalPortion->Reserved = 0;
            }
        }
    }


#ifndef MULTIHEAP
    ReleaseMutex (hGlobalMutex);
    CloseHandle (hGlobalMutex);
#endif

    return scResult;
}


//+--------------------------------------------------------------
//
//  Member:     CDfMutex::~CDfMutex, public
//
//  Synopsis:   This routine detaches from an existing global
//              critical section.
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Create or get the entry from the multistream
//
//---------------------------------------------------------------

CDfMutex::~CDfMutex(
    void
    )
{
    //If we're holding the mutex, we need to get rid of it here.

#ifdef SUPPORT_RECURSIVE_LOCK
    if ((_pGlobalPortion) &&
        (_pGlobalPortion->OwningThread == GetCurrentThreadId()))
    {
#else
    if (_pGlobalPortion)
    {
#if DBG == 1
        olAssert (_pGlobalPortion->OwningThread == 0 || _pGlobalPortion->OwningThread == GetCurrentThreadId());
#endif
#endif
        Release();
    }

    if ( _pGlobalPortion )
    {
        UnmapViewOfFile (_pGlobalPortion);
    }

    if ( _hLockSemaphore )
    {
        CloseHandle (_hLockSemaphore);
    }
    if ( _hSharedMapping )
    {
        CloseHandle (_hSharedMapping);
    }
}

//+--------------------------------------------------------------
//
//  Member:     CDfMutex::Take, public
//
//  Synopsis:   This routine enters the global critical section.
//
//  Arguments:  [dwTimeout] - Supplies the timeout
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Enters the critical section if nobody owns it or
//              if the current thread already owns it.
//              Waits for the critical section otherwise.
//
//---------------------------------------------------------------

SCODE
CDfMutex::Take (
    DWORD   dwTimeout
    )
{
    olAssert (_pGlobalPortion->LockCount >= -1);

#ifdef SUPPORT_RECURSIVE_LOCK

    olAssert (_pGlobalPortion->RecursionCount >= 0);

    DWORD ThreadId;

    ThreadId = GetCurrentThreadId();

#endif

    //
    // Increment the lock variable. On the transition to 0, the caller
    // becomes the absolute owner of the lock. Otherwise, the caller is
    // either recursing, or is going to have to wait
    //

    if ( !InterlockedIncrement (&_pGlobalPortion->LockCount) )
    {
        //
        // lock count went from -1 to 0, so the caller
        // is the owner of the lock
        //

#ifdef SUPPORT_RECURSIVE_LOCK
        _pGlobalPortion->RecursionCount = 1;
        _pGlobalPortion->OwningThread = ThreadId;
#else
#if DBG == 1
        _pGlobalPortion->OwningThread = GetCurrentThreadId();
#endif
#endif
        return S_OK;
    }
    else
    {
#ifdef SUPPORT_RECURSIVE_LOCK
        //
        // If the caller is recursing, then increment the recursion count
        //

        if ( _pGlobalPortion->OwningThread == ThreadId )
        {
            _pGlobalPortion->RecursionCount++;
            return S_OK;
        }
        else
        {
#else
#if DBG == 1
        olAssert (_pGlobalPortion->OwningThread != GetCurrentThreadId());
#endif
#endif
            switch (WaitForSingleObject(
                    _hLockSemaphore,
                    dwTimeout
                    ))
            {
                case WAIT_OBJECT_0:
                case WAIT_ABANDONED:
#ifdef SUPPORT_RECURSIVE_LOCK
                    _pGlobalPortion->RecursionCount = 1;
                    _pGlobalPortion->OwningThread = ThreadId;
#else
#if DBG == 1
                    _pGlobalPortion->OwningThread = GetCurrentThreadId();
#endif
#endif
                    return S_OK;
                case WAIT_TIMEOUT:
                    return STG_E_INUSE;
                default:
                    return LAST_SCODE;
            }
#ifdef SUPPORT_RECURSIVE_LOCK
        }
#endif
    }
}


//+--------------------------------------------------------------
//
//  Member:     CDfMutex::Release, public
//
//  Synopsis:   This routine leaves the global critical section
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Leaves the critical section if this is the owning
//              thread.
//
//---------------------------------------------------------------

VOID
CDfMutex::Release(
    void
    )
{
#ifdef SUPPORT_RECURSIVE_LOCK
    if ( _pGlobalPortion->OwningThread != GetCurrentThreadId() ) return;
#else
#if DBG == 1
    olAssert (_pGlobalPortion->OwningThread == 0 || _pGlobalPortion->OwningThread == GetCurrentThreadId());
#endif
#endif

    olAssert (_pGlobalPortion->LockCount >= -1);

#ifdef SUPPORT_RECURSIVE_LOCK
    olAssert (_pGlobalPortion->RecursionCount >= 0);

    //
    // decrement the recursion count. If it is still non-zero, then
    // we are still the owner so don't do anything other than dec the lock
    // count
    //

    if ( --_pGlobalPortion->RecursionCount )
    {
        InterlockedDecrement(&_pGlobalPortion->LockCount);
    }
    else
    {
        //
        // We are really leaving, so give up ownership and decrement the
        // lock count
        //

        _pGlobalPortion->OwningThread = 0;
#else
#if DBG == 1
        _pGlobalPortion->OwningThread = 0;
#endif
#endif

        //
        // Check to see if there are other waiters. If so, then wake up a waiter
        //

        if ( InterlockedDecrement(&_pGlobalPortion->LockCount) >= 0 )
        {
            ReleaseSemaphore(
                    _hLockSemaphore,    //  HANDLE  hSemaphore
                    1,                  //  LONG    cReleaseCount
                    NULL                //  LPLONG  lplPreviousCount
                    );
        }
#ifdef SUPPORT_RECURSIVE_LOCK
    }
#endif
}

//+--------------------------------------------------------------
//
//  Member:     CDfMutex::IsHandleValid, public
//
//  Synopsis:   This routine checks the mutex handle for validity
//
//  History:    09-May-2001      HenryLee    created
//
//---------------------------------------------------------------

BOOL CDfMutex::IsHandleValid (TCHAR *ptcsName)
{
#if WIN32 == 100
    BOOL fValid = FALSE;
    NTSTATUS nts = STATUS_SUCCESS;
    WCHAR wcsBuffer[MAX_PATH] = L"";
    OBJECT_NAME_INFORMATION *poni = (OBJECT_NAME_INFORMATION *) wcsBuffer;

    nts = NtQueryObject (_hLockSemaphore, ObjectNameInformation, poni,
                         sizeof(wcsBuffer), NULL);

    if (NT_SUCCESS(nts))
    {
        if (poni->Name.Length < sizeof(wcsBuffer) - sizeof (*poni))
        {
            poni->Name.Buffer[poni->Name.Length / sizeof(WCHAR)] = L'\0';
            if (!lstrcmp (poni->Name.Buffer, ptcsName))
                fValid = TRUE;
        }
    }
#else
    BOOL fValid = TRUE;
#endif

    return fValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\freelist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       freelist.cxx
//
//  Contents:   CFreeList implementation
//
//  History:    05-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <freelist.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CFreeList::Reserve, public
//
//  Synopsis:   Allocates memory for a given number of blocks
//
//  Arguments:  [pMalloc] - Allocator to use to allocate blocks
//              [cBlocks] - Number of blocks to allocate
//              [cbBlock] - Block size
//
//  Returns:    Appropriate status code
//
//  History:    05-Nov-92       DrewB   Created
//              21-May-93       AlexT   Add allocator
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CFreeList_Reserve)
#endif

SCODE CFreeList::Reserve(IMalloc *pMalloc, UINT cBlocks, size_t cbBlock)
{
    SFreeBlock *pfb;
    UINT i;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CFreeList::Reserve:%p(%lu, %u)\n",
                this, cBlocks, cbBlock));
    olAssert(cbBlock >= sizeof(SFreeBlock));
    for (i = 0; i<cBlocks; i++)
    {
        olMem(pfb = (SFreeBlock *)
              CMallocBased::operator new (cbBlock, pMalloc));
        pfb->pfbNext = _pfbHead;
        _pfbHead = P_TO_BP(CBasedFreeBlockPtr, pfb);
    }
    olDebugOut((DEB_ITRACE, "Out CFreeList::Reserve\n"));
    return S_OK;

 EH_Err:
    SFreeBlock *pfbT;

    for (; i>0; i--)
    {
        olAssert(_pfbHead != NULL);
        pfbT = BP_TO_P(SFreeBlock *, _pfbHead->pfbNext);
        delete (CMallocBased *) BP_TO_P(SFreeBlock *, _pfbHead);
        _pfbHead = P_TO_BP(CBasedFreeBlockPtr, pfbT);
    }
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreeList::Unreserve, public
//
//  Synopsis:   Removes N blocks from the list
//
//  Arguments:  [cBlocks] - Number of blocks to free
//
//  History:    05-Nov-92       DrewB   Created
//              21-May-93       AlexT   Switch to CMallocBased
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CFreeList_Unreserve)
#endif

void CFreeList::Unreserve(UINT cBlocks)
{
    SFreeBlock *pfbT;

    olDebugOut((DEB_ITRACE, "In  CFreeList::Unreserve:%p(%lu)\n",
                this, cBlocks));
    for (; cBlocks>0; cBlocks--)
    {
        olAssert(_pfbHead != NULL);
        pfbT = BP_TO_P(SFreeBlock *, _pfbHead->pfbNext);
        delete (CMallocBased *) BP_TO_P(SFreeBlock *, _pfbHead);
        _pfbHead = P_TO_BP(CBasedFreeBlockPtr, pfbT);
    }
    olDebugOut((DEB_ITRACE, "Out CFreeList::Unreserve\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\funcs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       funcs.cxx
//
//  Contents:   Generic DocFile support functions
//
//  Functions:  ModeToTFlags
//              CheckName
//              VerifyPerms
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <df32.hxx>


//+--------------------------------------------------------------
//
//  Function:   ModeToDFlags, private
//
//  Synopsis:   Translates STGM flags to DF flags
//
//  Arguments:  [dwModeFlags]
//
//  Returns:    DF_*
//
//  History:    04-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

DFLAGS ModeToDFlags(DWORD const dwModeFlags)
{
    DFLAGS df;

    olDebugOut((DEB_ITRACE, "In  ModeToDFlags(%lX)\n", dwModeFlags));
    if ((dwModeFlags & STGM_TRANSACTED) == 0)
        df = DF_DIRECT;
    else
        df = DF_TRANSACTED;
    if ((dwModeFlags & STGM_TRANSACTED) &&
        (dwModeFlags & STGM_PRIORITY) == 0 &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_DENY_WRITE &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
        df |= DF_INDEPENDENT;
    switch(dwModeFlags & STGM_RDWR)
    {
    case STGM_READ:
        df |= DF_READ;
        break;
    case STGM_WRITE:
        df |= DF_WRITE;
        break;
    case STGM_READWRITE:
        df |= DF_READWRITE;
        break;
    default:
        olAssert(FALSE);
        break;
    }
    switch(dwModeFlags & STGM_DENY)
    {
    case STGM_SHARE_DENY_READ:
        df |= DF_DENYREAD;
        break;
    case STGM_SHARE_DENY_WRITE:
        df |= DF_DENYWRITE;
        break;
    case STGM_SHARE_EXCLUSIVE:
        df |= DF_DENYALL;
        break;
        // Default is deny none
    }
    if (dwModeFlags & STGM_PRIORITY)
        df |= DF_PRIORITY;

#ifdef USE_NOSNAPSHOT_ALWAYS
    //This makes all transacted-writeable !deny-write instances no-snapshot,
    //  for testing.
    if ((dwModeFlags & STGM_TRANSACTED) &&
        !(df & DF_DENYWRITE) &&
        (df & DF_WRITE))
    {
        df |= DF_NOSNAPSHOT;
        df &= ~DF_INDEPENDENT;
    }
#else
    if (dwModeFlags & STGM_NOSNAPSHOT)
    {
        df |= DF_NOSNAPSHOT;
        df &= ~DF_INDEPENDENT;
    }
#endif //USE_NOSNAPSHOT_ALWAYS

#ifdef USE_NOSCRATCH_ALWAYS
    //This makes everything NOSCRATCH, for testing.
    if ((dwModeFlags & STGM_TRANSACTED) && (df & DF_WRITE))
        df |= DF_NOSCRATCH;
#else
    if (dwModeFlags & STGM_NOSCRATCH)
        df |= DF_NOSCRATCH;
#endif
#if WIN32 == 300
    if (dwModeFlags & STGM_EDIT_ACCESS_RIGHTS)
        df |= DF_ACCESSCONTROL;
#endif

    olDebugOut((DEB_ITRACE, "Out ModeToDFlags => %lX\n", df));
    return df;
}

//+--------------------------------------------------------------
//
//  Function:   DFlagsToMode, private
//
//  Synopsis:   Converts the read/write/denials/transacted/priority
//              to STGM flags
//
//  Arguments:  [df] - DFlags
//
//  Returns:    STGM flags
//
//  History:    24-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

DWORD DFlagsToMode(DFLAGS const df)
{
    DWORD dwMode = 0;

    olDebugOut((DEB_ITRACE, "In  DFlagsToMode(%X)\n", df));
    if (P_READ(df))
        if (P_WRITE(df))
            dwMode = STGM_READWRITE;
        else
            dwMode = STGM_READ;
    else if (P_WRITE(df))
        dwMode = STGM_WRITE;
    // Must have either read or write, so no else

    if (P_DENYREAD(df))
        if (P_DENYWRITE(df))
            dwMode |= STGM_SHARE_EXCLUSIVE;
        else
            dwMode |= STGM_SHARE_DENY_READ;
    else if (P_DENYWRITE(df))
        dwMode |= STGM_SHARE_DENY_WRITE;
    else
        dwMode |= STGM_SHARE_DENY_NONE;

    if (P_TRANSACTED(df))
        dwMode |= STGM_TRANSACTED;

    if (P_PRIORITY(df))
        dwMode |= STGM_PRIORITY;

    if (P_NOSCRATCH(df))
        dwMode |= STGM_NOSCRATCH;

    if (P_NOSNAPSHOT(df))
        dwMode |= STGM_NOSNAPSHOT;

    olDebugOut((DEB_ITRACE, "Out DFlagsToMode\n"));
    return dwMode;
}

//+--------------------------------------------------------------
//
//  Function:   VerifyPerms, private
//
//  Synopsis:   Checks flags to see if they are valid
//
//  Arguments:  [grfMode] - Permissions
//              [fRoot] - TRUE if checking root storage
//
//  Returns:    Appropriate status code
//
//  Notes:      This routine is called when opening a root storage
//              or a subelement.  When changing root permissions,
//              use the fRoot flag to preserve compatibily for
//              return codes when opening subelements
//
//  History:    19-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE VerifyPerms(DWORD grfMode, BOOL fRoot)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  VerifyPerms(%lX)\n", grfMode));

    // Check for valid flags
    if ((grfMode & STGM_RDWR) > STGM_READWRITE ||
        (grfMode & STGM_DENY) > STGM_SHARE_DENY_NONE ||
        (grfMode & ~(STGM_RDWR | STGM_DENY | STGM_DIRECT | STGM_TRANSACTED |
                     STGM_PRIORITY | STGM_CREATE | STGM_CONVERT | STGM_SIMPLE |
                     STGM_NOSCRATCH |
#ifndef DISABLE_NOSNAPSHOT
                     STGM_NOSNAPSHOT |
#endif
#if WIN32 >= 300
                     STGM_EDIT_ACCESS_RIGHTS |
#endif
#ifdef DIRECTWRITERLOCK
             STGM_DIRECT_SWMR |
#endif
                     STGM_FAILIFTHERE | STGM_DELETEONRELEASE)))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // If priority is specified...
    if (grfMode & STGM_PRIORITY)
    {
        // Make sure no priority-denied permissions are specified
        if ((grfMode & STGM_RDWR) == STGM_WRITE ||
            (grfMode & STGM_RDWR) == STGM_READWRITE ||
            (grfMode & STGM_TRANSACTED))
            olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    // Check to make sure only one existence flag is specified
    // FAILIFTHERE is zero so it can't be checked
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) ==
        (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // If not transacted and not priority, you can either be
    // read-only deny write or read-write deny all
    if ((grfMode & (STGM_TRANSACTED | STGM_PRIORITY)) == 0)
    {
        if ((grfMode & STGM_RDWR) == STGM_READ)
        {
            //  we're asking for read-only access

            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
#ifdef DIRECTWRITERLOCK
                    (!fRoot ||
             (grfMode & STGM_DIRECT_SWMR) == 0 ||
             (grfMode & STGM_DENY) != STGM_SHARE_DENY_NONE) &&
#endif
                (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE)
            {
                //  Can't allow others to have write access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
        else
        {
            //  we're asking for write access

#ifdef DIRECTWRITERLOCK
            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
            (!fRoot ||
             (grfMode & STGM_DIRECT_SWMR) == 0 ||
             (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE))
#else
            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
#endif
            {
                //  Can't allow others to have any access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
    }

    //If this is not a root open, we can't pass STGM_NOSCRATCH or
    // STGM_NOSNAPSHOT
    if (!fRoot && (grfMode & (STGM_NOSCRATCH | STGM_NOSNAPSHOT)))
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    if (grfMode & STGM_NOSCRATCH)
    {
        if (((grfMode & STGM_RDWR) == STGM_READ) ||
            ((grfMode & STGM_TRANSACTED) == 0))
        {
            olErr(EH_Err, STG_E_INVALIDFLAG);
        }
    }

    if (grfMode & STGM_NOSNAPSHOT)
    {
        if (((grfMode & STGM_DENY) == STGM_SHARE_EXCLUSIVE) ||
            ((grfMode & STGM_DENY) == STGM_SHARE_DENY_WRITE) ||
            ((grfMode & STGM_TRANSACTED) == 0) ||
            ((grfMode & STGM_NOSCRATCH) != 0) ||
            ((grfMode & STGM_CREATE) != 0) ||
            ((grfMode & STGM_CONVERT) != 0))
        {
            olErr(EH_Err, STG_E_INVALIDFLAG);
        }
    }

    olDebugOut((DEB_ITRACE, "Out VerifyPerms\n"));
    // Fall through
EH_Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     ValidateNameW, public
//
//  Synopsis:   Validate that a name is valid and no longer than the
//              size specified.
//
//  Arguments:  [pwcsName] -- Pointer to wide character string
//              [cchMax] -- Maximum length for string
//
//  Returns:    Appropriate status code
//
//  History:    23-Nov-98       PhilipLa        Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

SCODE ValidateNameW(LPCWSTR pwcsName, UINT cchMax)
{
    SCODE sc = S_OK;

    if (!IsValidReadPtrIn(pwcsName, cchMax))
        sc = STG_E_INVALIDNAME;
    else
    {
        if (FAILED(StringCchLength(pwcsName, cchMax, NULL)))
            sc = STG_E_INVALIDNAME;
    }
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   CheckName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//  History:    11-Feb-92       DrewB   Created
//                              04-Dec-95               SusiA   Optimized
//
//---------------------------------------------------------------

SCODE CheckName(WCHAR const *pwcsName)
{
    LPCWSTR pChar;
        
        //Each character's position in the array is detrmined by its ascii numeric
        //value.  ":" is 58, so bit 58 of the array will be 1 if ":" is illegal.
        //32bits per position in the array, so 58/32 is in Invalid[1].
        //58%32 = 28th bit ( 0x04000000 ) in Invalid[1].

    /* Invalid characters:                               :  /  !   \ */
    static ULONG const Invalid[128/32] =
        {0x00000000,0x04008002,0x10000000,0x00000000};

    SCODE sc = STG_E_INVALIDNAME;
    olDebugOut((DEB_ITRACE, "In  CheckName(%ws)\n", pwcsName));

    __try
    {
        for (pChar = (LPCWSTR)pwcsName;
             pChar < (LPCWSTR) &pwcsName[CWCMAXPATHCOMPLEN];
             pChar++)
        {
            if (*pChar == L'\0')
            {
                sc = S_OK;
                break;                  // Success
            }

            // Test to see if this is an invalid character
            if (*pChar < 128 &&
                // All values above 128 are valid
                (Invalid[*pChar / 32] & (1 << (*pChar % 32))) != 0)
                // check to see if this character's bit is set
            {
                break;                  // Failure: invalid Char
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    olDebugOut((DEB_ITRACE, "Out CheckName\n"));
    return sc;
        
}


//+--------------------------------------------------------------
//
//  Function:   ValidateSNB, private
//
//  Synopsis:   Validates SNB memory
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//  History:    10-Jun-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE ValidateSNB(SNBW snb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ValidateSNB(%p)\n", snb));
    for (;;)
    {
        olChk(ValidatePtrBuffer(snb));
        if (*snb == NULL)
            break;
        olChk(ValidateNameW(*snb, CWCMAXPATHCOMPLEN));
        snb++;
    }
    olDebugOut((DEB_ITRACE, "Out ValidateSNB\n"));
    return S_OK;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   CopySStreamToSStream
//
//  Synopsis:   Copies the contents of a stream to another stream
//
//  Arguments:  [psstFrom] - Stream to copy from
//              [psstTo] - Stream to copy to
//
//  Returns:    Appropriate status code
//
//  History:    13-Sep-91       DrewB   Created
//
//  Notes:      This function may fail due to out of memory.  It
//              may not be used by callers who must not fail due
//              to out of memory.
//
//---------------------------------------------------------------

SCODE CopySStreamToSStream(PSStream *psstFrom, PSStream *psstTo)
{
    BYTE *pbBuffer = NULL;
    SCODE sc;
#ifdef LARGE_STREAMS
    ULONGLONG cbSize = 0, cbPos;
    ULONG cbRead, cbWritten;
#else
    ULONG cbRead, cbWritten, cbSize, cbPos;
#endif

    // We're allowed to fail due to out of memory
    olMem(pbBuffer = (BYTE *) DfMemAlloc(STREAMBUFFERSIZE));

    // Set destination size for contiguity
    psstFrom->GetSize(&cbSize);
    olChk(psstTo->SetSize(cbSize));

    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        olChk(psstFrom->ReadAt(cbPos, pbBuffer, STREAMBUFFERSIZE,
                               (ULONG STACKBASED *)&cbRead));
        if (cbRead == 0) // EOF
            break;
        olChk(psstTo->WriteAt(cbPos, pbBuffer, cbRead,
                              (ULONG STACKBASED *)&cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }

EH_Err:
    if (pbBuffer != NULL)
        DfMemFree(pbBuffer);
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   dfwcsnicmp, public
//
//  Synopsis:   wide character string compare that interoperates with what
//              we did on 16-bit windows.
//
//  Arguments:  [wcsa] -- First string
//              [wcsb] -- Second string
//              [len] -- Length to compare to
//
//  Returns:    > 0 if wcsa > wcsb
//              < 0 if wcsa < wcsb
//              0 is wcsa == wcsb
//
//  History:    11-May-95       PhilipLa        Created
//                              22-Nov-95       SusiA           Optimize comparisons
//
//  Notes:      This function is necessary because on 16-bit windows our
//              wcsnicmp function converted everything to uppercase and
//              compared the strings, whereas the 32-bit runtimes convert
//              everything to lowercase and compare.  This means that the
//              sort order is different for string containing [\]^_`
//
//----------------------------------------------------------------------------

int dfwcsnicmp(const WCHAR *wcsa, const WCHAR *wcsb, size_t len)
{
    if (!len)
        return 0;

    while (--len && *wcsa &&
                   ( *wcsa == *wcsb ||
                     CharUpperW((LPWSTR)*wcsa) == CharUpperW((LPWSTR)*wcsb)))
    {
        wcsa++;
        wcsb++;
    }
    return (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsa) -
           (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsb);
}


//+--------------------------------------------------------------
//
//  Function:   NameInSNB, private
//
//  Synopsis:   Determines whether the given name is in the SNB
//
//  Arguments:  [dfn] - Name
//              [snb] - SNB
//
//  Returns:    S_OK or S_FALSE
//
//  History:    19-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE NameInSNB(CDfName const *dfn, SNBW snb)
{
    SCODE sc = S_FALSE;

    olDebugOut((DEB_ITRACE, "In  NameInSNB(%ws, %p)\n", dfn, snb));
    TRY
    {
        for (; *snb; snb++)
            if ((lstrlenW(*snb)+1)*sizeof(WCHAR) == dfn->GetLength() &&
#ifdef CASE_SENSITIVE
                memcmp(dfn->GetBuffer(), *snb, dfn->GetLength()) == 0)
#else
                dfwcsnicmp((WCHAR *)dfn->GetBuffer(), (WCHAR *)*snb,
                           dfn->GetLength()/sizeof(WCHAR)) == 0)
#endif
            {
                sc = S_OK;
                break;
            }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out NameInSNB\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Win32ErrorToScode, public
//
//  Synopsis:   Map a Win32 error into a corresponding scode, remapping
//              into Facility_Storage if appropriate.
//
//  Arguments:  [dwErr] -- Win32 error to map
//
//  Returns:    Appropriate scode
//
//  History:    22-Sep-93       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE Win32ErrorToScode(DWORD dwErr)
{
    olAssert((dwErr != NO_ERROR) &&
             aMsg("Win32ErrorToScode called on NO_ERROR"));

    SCODE sc = STG_E_UNKNOWN;

    switch (dwErr)
    {
    case ERROR_INVALID_FUNCTION:
        sc = STG_E_INVALIDFUNCTION;
        break;
    case ERROR_FILE_NOT_FOUND:
        sc = STG_E_FILENOTFOUND;
        break;
    case ERROR_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;
    case ERROR_TOO_MANY_OPEN_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;
    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;
    case ERROR_INVALID_HANDLE:
        sc = STG_E_INVALIDHANDLE;
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;
    case ERROR_NO_MORE_FILES:
        sc = STG_E_NOMOREFILES;
        break;
    case ERROR_WRITE_PROTECT:
        sc = STG_E_DISKISWRITEPROTECTED;
        break;
    case ERROR_SEEK:
        sc = STG_E_SEEKERROR;
        break;
    case ERROR_WRITE_FAULT:
        sc = STG_E_WRITEFAULT;
        break;
    case ERROR_READ_FAULT:
        sc = STG_E_READFAULT;
        break;
    case ERROR_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;
    case ERROR_LOCK_VIOLATION:
        sc = STG_E_LOCKVIOLATION;
        break;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
        sc = STG_E_FILEALREADYEXISTS;
        break;
    case ERROR_INVALID_PARAMETER:
        sc = STG_E_INVALIDPARAMETER;
        break;
    case ERROR_INVALID_NAME:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILENAME_EXCED_RANGE:
        sc = STG_E_INVALIDNAME;
        break;
    case ERROR_INVALID_FLAGS:
        sc = STG_E_INVALIDFLAG;
        break;
    case ERROR_CANT_ACCESS_FILE:
        sc= STG_E_DOCFILECORRUPT;
        break;
    default:
        sc = WIN32_SCODE(dwErr);
        break;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidStgInterface
//
//  Synopsis:   a copy of the old IsValidInterface() from COM
//
//  Arguments:  [pv] -- interface to validate
//
//  Returns:    Appropriate flag
//
//  History:    08-May-2000     HenryLee        Created
//
//----------------------------------------------------------------------------

BOOL IsValidStgInterface( void * pv )
{
    ULONG_PTR *      pVtbl;
    BYTE      *      pFcn;
    volatile BYTE           bInstr;

    __try {
        pVtbl = *(ULONG_PTR **) pv;         // beginning of vtable

#if DBG==1
        for (int i=0 ; i<3; ++i)            // loop through qi,addref,rel
#else
        int i=1;                            // in retail, just do AddRef
#endif
        {
            pFcn = *(BYTE **) &pVtbl[i];

            bInstr = *(BYTE *) pFcn;        // get 1st byte of 1st instruction
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\mem.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Mem.CXX
//
//  Contents:   Memory tracking code
//
//  Classes:    CMemAlloc
//
//  Functions:  DfCreateSharedAllocator
//              DfPrintAllocs
//              DfGetMemAlloced
//
//  History:    17-May-93 AlexT     Created
//
//--------------------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#if defined(WIN32)

#include <smalloc.hxx>
#include <olesem.hxx>
#include <utils.hxx>

// This global variable holds the base address of the shared memory region.
// It is required by the based pointer stuff and is accessed directly.
// Initialization is a side effect of calling DfCreateSharedAllocator or
//  DfSyncSharedMemory

#ifdef MULTIHEAP
//__declspec(thread) void *DFBASEPTR = NULL;
#else
void *DFBASEPTR = NULL;
#endif

#endif

#if DBG == 1
#include <dfdeb.hxx>

#ifdef MEMTRACK
#ifdef WIN32
// Multithread protection for allocation list
CStaticDfMutex _sdmtxAllocs(TSTR("DfAllocList"));

#define TAKE_ALLOCS_MUTEX olVerSucc(_sdmtxAllocs.Take(INFINITE))
#define RELEASE_ALLOCS_MUTEX _sdmtxAllocs.Release()
#else
#define TAKE_ALLOCS_MUTEX
#define RELEASE_ALLOCS_MUTEX
#endif

#define GET_ALLOC_LIST_HEAD ((CMemAlloc *)DfGetResLimit(DBRI_ALLOC_LIST))
#define SET_ALLOC_LIST_HEAD(pma) DfSetResLimit(DBRI_ALLOC_LIST, (LONG)(pma))
#endif // MEMTRACK

#define DEB_MEMORY 0x01000000
#define DEB_LEAKS  0x01100000

const int NEWMEM = 0xDEDE;
const int OLDMEM = 0xEDED;

//+--------------------------------------------------------------
//
//  Class:      CMemAlloc (ma)
//
//  Purpose:    Tracks memory allocations
//
//  Interface:  See below
//
//  History:    08-Jul-92       DrewB   Created
//              17-May-93       AlexT   Add idContext
//
//---------------------------------------------------------------

class CMemAlloc
{
public:
    void *pvCaller;
    void *pvMem;
    ULONG cbSize;
    ContextId idContext;
#ifdef MEMTRACK
    CMemAlloc *pmaPrev, *pmaNext;
#endif
};

//+---------------------------------------------------------------------------
//
//  Function:	AddAlloc, private
//
//  Synopsis:	Puts an allocation into the allocation list
//
//  Arguments:	[pma] - Allocation descriptor
//              [pvCaller] - Allocator
//              [cbSize] - Real size
//              [pvMem] - Memory block
//              [cid] - Context ID
//
//  History:	11-Jan-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static void AddAlloc(CMemAlloc *pma, void *pvCaller, ULONG cbSize,
                     void *pvMem, ContextId cid)
{
    pma->pvCaller = pvCaller;
    pma->cbSize = cbSize;
    pma->pvMem = pvMem;
    pma->idContext = cid;

#ifdef MEMTRACK
    TAKE_ALLOCS_MUTEX;

    pma->pmaNext = GET_ALLOC_LIST_HEAD;
    if (pma->pmaNext)
        pma->pmaNext->pmaPrev = pma;
    pma->pmaPrev = NULL;
    SET_ALLOC_LIST_HEAD(pma);

    RELEASE_ALLOCS_MUTEX;

    ModifyResLimit(DBRQ_MEMORY_ALLOCATED, (LONG)cbSize);

    olDebugOut((DEB_MEMORY, "%s alloced %p:%lu, total %ld\n",
                cid != 0 ? "Task" : "Shrd",
                pvMem, pma->cbSize, DfGetResLimit(DBRQ_MEMORY_ALLOCATED)));

#endif
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:	RemoveAlloc, private
//
//  Synopsis:	Takes an allocation out of the allocation list
//
//  Arguments:	[pma] - Allocation descriptor
//              [pvMem] - Real allocation
//              [cid] - Context ID
//
//  History:	11-Jan-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static void RemoveAlloc(CMemAlloc *pma, void *pvMem, ContextId cid)
{
#ifdef MEMTRACK
    olAssert(pma->pvMem == pvMem && aMsg("Address mismatch"));
    olAssert(pma->idContext == cid && aMsg("Context mismatch"));

    TAKE_ALLOCS_MUTEX;

    if (pma->pmaPrev)
    {
        pma->pmaPrev->pmaNext = pma->pmaNext;
    }
    else
    {
        SET_ALLOC_LIST_HEAD(pma->pmaNext);
    }
    if (pma->pmaNext)
    {
        pma->pmaNext->pmaPrev = pma->pmaPrev;
    }

    RELEASE_ALLOCS_MUTEX;

    ModifyResLimit(DBR_MEMORY, (LONG)pma->cbSize);

    ModifyResLimit(DBRQ_MEMORY_ALLOCATED, -(LONG)pma->cbSize);
    olAssert(DfGetResLimit(DBRQ_MEMORY_ALLOCATED) >= 0);

    olDebugOut((DEB_MEMORY, "%s freed %p:%lu, total %ld\n",
                cid != 0 ? "Task" : "Shrd",
                pma->pvMem, pma->cbSize,
                DfGetResLimit(DBRQ_MEMORY_ALLOCATED)));
#endif
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DfGetMemAlloced, private
//
//  Synopsis:   Returns the amount of memory currently allocated
//
//  History:    08-Jul-92       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(LONG) DfGetMemAlloced(void)
{
    return DfGetResLimit(DBRQ_MEMORY_ALLOCATED);
}

//+--------------------------------------------------------------
//
//  Function:   DfPrintAllocs, private
//
//  Synopsis:   Walks the allocation list and prints out their info
//
//  History:    08-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI_(void) DfPrintAllocs(void)
{
#ifdef MEMTRACK
    CMemAlloc *pma;

    olDebugOut((DEB_ITRACE, "In  DfPrintAllocs()\n"));

    TAKE_ALLOCS_MUTEX;

    pma = GET_ALLOC_LIST_HEAD;
    while (pma != NULL)
    {
        olDebugOut((DEB_LEAKS, "Alloc %s: %p alloc %p:%4lu bytes\n",
                    pma->idContext ? "LOCAL" : "SHARED",
                    pma->pvCaller, pma->pvMem, pma->cbSize));
        pma = pma->pmaNext;
    }

    RELEASE_ALLOCS_MUTEX;

    olDebugOut((DEB_ITRACE, "Out DfPrintAllocs\n"));
#endif
}

#endif

#ifdef MULTIHEAP

CSmAllocator g_SmAllocator;      // optimization for single threaded case
CErrorSmAllocator g_ErrorSmAllocator;
IMalloc *g_pTaskAllocator = 0;
CSharedMemoryBlock g_smb;        // optimize single threaded case
ULONG        g_ulHeapName = 0;   // name of the above heap
TEB *        g_pteb = NtCurrentTeb();

CSmAllocator& GetTlsSmAllocator()
{
    HRESULT hr;
    COleTls otls(hr); // even for main thread, we need to initialize TLS
    memAssert (SUCCEEDED(hr) && "Error initializing TLS");

    if (g_pteb == NtCurrentTeb())
    {
        // return the static global allocator for main thread
        // DoThreadSpecificCleanup does not deallocate this allocator
        return g_SmAllocator;
    }

    if (otls->pSmAllocator == NULL)
    {
        if ((otls->pSmAllocator = new CSmAllocator()) == NULL)
             otls->pSmAllocator = &g_ErrorSmAllocator;
        // DoThreadSpecificCleanup will deallocate this when thread goes away
    }
    return *(otls->pSmAllocator);
}

//
// This initialization used to be done in the global allocator
// which is now a per thread allocator
//
class CResourceCriticalSection
{
public:
    CResourceCriticalSection ()
    {
#if WIN32 == 100
        _nts = RtlInitializeCriticalSection(&g_csScratchBuffer);
#else
        InitializeCriticalSection(&g_csScratchBuffer);
#endif
    }

    ~CResourceCriticalSection ()
    {
#if WIN32 == 100
        if (NT_SUCCESS(_nts))
#endif
            DeleteCriticalSection(&g_csScratchBuffer);
    }

#if WIN32 == 100
    HRESULT GetInitializationError ()
    {
        return NtStatusToScode(_nts);
    }

private:
    NTSTATUS    _nts;
#endif
};
CResourceCriticalSection g_ResourceCriticalSection;

#else
CSmAllocator g_smAllocator;
#endif // MULTIHEAP

//+-------------------------------------------------------------------------
//
//  Member:     CMallocBased::operator new, public
//
//  Synopsis:   Overridden allocator
//
//  Effects:    Allocates memory from given allocator
//
//  Arguments:  [size] -- byte count to allocate
//              [pMalloc] --  allocator
//
//  Returns:    memory block address
//
//  Algorithm:
//
//  History:    21-May-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void *CMallocBased::operator new(size_t size, IMalloc * const pMalloc)

{
#ifndef WIN32
    olAssert(DfGetResLimit(DBRQ_MEMORY_ALLOCATED) >= 0);
#endif
    olAssert(size > 0);

#if DBG==1
    if (SimulateFailure(DBF_MEMORY))
    {
        return(NULL);
    }

    if (!HaveResource(DBR_MEMORY, (LONG)size))
    {
        // Artificial limit exceeded so force failure
        return NULL;
    }
#endif

    void *pv = g_smAllocator.Alloc(
#if DBG==1
                              sizeof(CMemAlloc) +
#endif
                              size);

    if (pv == NULL)
    {
#if DBG==1
        ModifyResLimit(DBR_MEMORY, (LONG)size);
#endif
        return NULL;
    }

#if DBG==1
    memset(pv, NEWMEM, sizeof(CMemAlloc) + size);
#endif



#if DBG==1
    // Put debug info in buffer
    // Note: This assumes CMemAlloc will end up properly aligned
    CMemAlloc *pma = (CMemAlloc *) pv;
    pv = (void *) ((CMemAlloc *) pv + 1);

#if defined(_X86_)
    PVOID ra = *(((void **)&size)-1);
#else
    PVOID ra = _ReturnAddress();
#endif

    AddAlloc(pma, ra, (ULONG) size, pv, 0);
#endif

    return pv;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMallocBased::operator delete
//
//  Synopsis:   Overridden deallocator
//
//  Effects:    Frees memory block
//
//  Arguments:  [pv] -- memory block address
//
//  Algorithm:
//
//  History:    21-May-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CMallocBased::operator delete(void *pv)

{
    if (pv == NULL)
        return;

#if DBG==1
    // Assumes ma ends up properly aligned
    CMemAlloc *pma = (CMemAlloc *) pv;
    pma--;

    RemoveAlloc(pma, pv, 0);

    pv = (void *) pma;

    memset(pv, OLDMEM, (size_t) pma->cbSize);
#endif

    g_smAllocator.Free(pv);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMallocBased::deleteNoMutex
//
//  Synopsis:   deallocator function without Mutex
//
//  Effects:    Frees memory block
//
//  Arguments:  [pv] -- memory block address
//  Algorithm:
//
//  History:    19-Jul-95 	SusiA    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CMallocBased::deleteNoMutex(void *pv)

{
    if (pv == NULL)
        return;

#if DBG==1
    // Assumes ma ends up properly aligned
    CMemAlloc *pma = (CMemAlloc *) pv;
    pma--;

    RemoveAlloc(pma, pv, 0);

    pv = (void *) pma;

    memset(pv, OLDMEM, (size_t) pma->cbSize);
#endif

    g_smAllocator.FreeNoMutex(pv);
}



#if !defined(WIN32) && DBG==1

//+-------------------------------------------------------------------------
//
//  Class:      CSharedMalloc
//
//  Purpose:    Track shared allocators
//
//  Interface:  IMalloc
//
//  History:    28-May-93 AlexT     Created
//
//  Notes:      This is only for builds that use CoCreateStandardMalloc
//              (which is non-WIN32 builds for now).  We inherit from
//              CMallocBased to pick up memory tracking.
//
//--------------------------------------------------------------------------

class CSharedMalloc : public IMalloc, public CMallocBased
{
public:
    CSharedMalloc(IMalloc *pMalloc);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ SIZE_T cb);
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, SIZE_T cb);
    STDMETHOD_(void, Free) (THIS_ void FAR* pv);
    STDMETHOD_(SIZE_T, GetSize) (THIS_ void FAR* pv);
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv);
    STDMETHOD_(void, HeapMinimize) (THIS);

private:
    IMalloc * const _pMalloc;
};

CSharedMalloc::CSharedMalloc(IMalloc *pMalloc)
: _pMalloc(pMalloc)
{
    _pMalloc->AddRef();
}

STDMETHODIMP CSharedMalloc::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    olAssert(!aMsg("CSharedMalloc::QueryInterface unsupported"));
    return(ResultFromScode(E_UNEXPECTED));
}

STDMETHODIMP_(ULONG) CSharedMalloc::AddRef (THIS)
{
    return(_pMalloc->AddRef());
}

STDMETHODIMP_(ULONG) CSharedMalloc::Release (THIS)
{
    ULONG cRef = _pMalloc->Release();

    if (cRef == 0)
        delete this;

    return (ULONG) cRef;
}

STDMETHODIMP_(void FAR*) CSharedMalloc::Alloc (THIS_ SIZE_T cb)
{
    return _pMalloc->Alloc(cb);
}

STDMETHODIMP_(void FAR*) CSharedMalloc::Realloc (THIS_ void FAR* pv, SIZE_T cb)
{
    olAssert(!aMsg("CSharedMalloc::Realloc unsupported"));
    return(NULL);
}

STDMETHODIMP_(void) CSharedMalloc::Free (THIS_ void FAR* pv)
{
    _pMalloc->Free(pv);
}

STDMETHODIMP_(SIZE_T) CSharedMalloc::GetSize (THIS_ void FAR* pv)
{
    olAssert(!aMsg("CSharedMalloc::GetSize unsupported"));
    return(0);
}

STDMETHODIMP_(int) CSharedMalloc::DidAlloc (THIS_ void FAR* pv)
{
    olAssert(!aMsg("CSharedMalloc::DidAlloc unsupported"));
    return(TRUE);
}

STDMETHODIMP_(void) CSharedMalloc::HeapMinimize (THIS)
{
    olAssert(!aMsg("CSharedMalloc::HeapMinimize unsupported"));
}

#endif


#if !defined(MULTIHEAP)
COleStaticMutexSem mxsInitSm;
BOOL fInitialisedSm = FALSE;

//+-------------------------------------------------------------------------
//
//  Function:   DfCreateSharedAllocator
//
//  Synopsis:   Initialises the shared memory region for this process.
//
//  Arguments:  [ppm]		-- return address for shared memory IMalloc*
//
//  Returns:    status code
//
//  History:    27-May-94	MikeSe	Created
//
//  Notes:      This routine is called indirectly through DfCreateSharedAllocator, in
//		such a way that in most circumstances it will be executed
//		exactly once per process. (Because we overwrite the contents
//		of DfCreateSharedAllocator if successful).
//
//		However, in order to be multi-thread safe, we need a process
//		mutex to prevent execution of the initialisation code twice.
//
//		Furthermore, since we are initialising system-wide state
//		(namely the shared memory region) we must provide cross-process
//		mutual exclusion over this activity.
//
//--------------------------------------------------------------------------

HRESULT DfCreateSharedAllocator (IMalloc ** ppm, BOOL fTaskMemory )
{
    // multi-thread safety

    mxsInitSm.Request();

    HRESULT hr = S_OK;

    if ( !fInitialisedSm )
    {
	// We need to do the initialisation. Obtain exclusion against
	//  other processes.

	SECURITY_ATTRIBUTES secattr;
	secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
#ifndef _CHICAGO_
	CWorldSecurityDescriptor wsd;
	secattr.lpSecurityDescriptor = &wsd;
#else
	secattr.lpSecurityDescriptor = NULL;
#endif // !_CHICAGO_
	secattr.bInheritHandle = FALSE;

        HANDLE hMutex = CreateMutex ( &secattr, FALSE, TEXT("OleDfSharedMemoryMutex"));

        if ( hMutex == NULL && GetLastError() == ERROR_ACCESS_DENIED )
            hMutex = OpenMutex(SYNCHRONIZE, FALSE, TEXT("OleDfSharedMemoryMutex"));

	if ( hMutex != NULL )
	{
	    WaitForSingleObject ( hMutex, INFINITE );
            hr = g_smAllocator.Init ( DOCFILE_SM_NAME );
	    if ( SUCCEEDED(hr) )
	    {
	        *ppm = &g_smAllocator;
		// Also set up base address
#ifdef USEBASED
	        DFBASEPTR = g_smAllocator.GetBase();
#endif
	        fInitialisedSm = TRUE;
	    }
	    ReleaseMutex ( hMutex );
	}
        else
	    hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else   // fInitialisedSm is TRUE
    {
        *ppm = &g_smAllocator;
    }
    mxsInitSm.Release();
    return hr;
}

#endif // !defined(MULTIHEAP)

#ifdef MULTIHEAP
//+-------------------------------------------------------------------------
//
//  Function:   DfCreateSharedAllocator
//
//  Synopsis:   Initialises a shared memory region for this process.
//
//  Arguments:  [ppm]       -- return address for shared memory IMalloc*
//
//  Returns:    status code
//
//  History:    20-Nov-95   HenryLee Created
//
//  Notes:      This routine is called indirectly by DfCreateSharedAllocator
//      such a way that in most circumstances it will be executed
//      exactly once per docfile open.
//
//--------------------------------------------------------------------------

HRESULT DfCreateSharedAllocator (IMalloc ** ppm, BOOL fTaskMemory )
{
    HRESULT hr = S_OK;


#if WIN32 == 100
    hr = g_ResourceCriticalSection.GetInitializationError();
    if (!SUCCEEDED(hr))
        return hr;
#endif

    COleTls otls(hr);           // check if TLS is initialized
    if (!SUCCEEDED(hr))
        return hr;

    CSmAllocator *pMalloc = &g_smAllocator;
    *ppm = NULL;

    if ((gs_iSharedHeaps > (DOCFILE_SM_LIMIT / DOCFILE_SM_SIZE)) ||
        fTaskMemory)
    {
        // use task allocator if we eat up 1Gig of address space
        if (g_pTaskAllocator == NULL)
        {
            hr = CoGetMalloc (MEMCTX_TASK, &g_pTaskAllocator);
            if (!SUCCEEDED(hr))
                return hr;
        }

        // reset the allocator state to initialize it properly
        pMalloc->SetState (NULL, NULL, NULL, NULL, 0);

        DFBASEPTR = 0;
        *ppm = g_pTaskAllocator;
    }
    else
    {
        LUID luid;    // generate a unique name
        if (AllocateLocallyUniqueId (&luid) == FALSE)
            return HRESULT_FROM_WIN32(GetLastError());

        // reset the allocator state to initialize it properly
        pMalloc->SetState (NULL, NULL, NULL, NULL, 0);

        hr = pMalloc->Init ( luid.LowPart, FALSE );
        if ( SUCCEEDED(hr) )
        {
            *ppm = pMalloc;
            DFBASEPTR = pMalloc->GetBase();
            pMalloc->AddRef();
        }
    }

    return hr;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:	DfSyncSharedMemory, public
//
//  Synopsis:	Sync up shared memory
//
//  Returns:	Appropriate status code
//
//  History:	08-Apr-94	PhilipLa	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef MULTIHEAP
SCODE DfSyncSharedMemory(ULONG ulHeapName)
#else
SCODE DfSyncSharedMemory(void)
#endif
{
    // make sure we have initialised
    HRESULT hr = S_OK;

#ifdef MULTIHEAP
    CSmAllocator *pMalloc = &g_smAllocator;
    if (ulHeapName != 0)     // reopen a shared heap for unmarshaling
    {
        // reset the allocator state to initialize it properly
        pMalloc->SetState (NULL, NULL, NULL, NULL, 0);

        hr = pMalloc->Init ( ulHeapName, TRUE);
        DFBASEPTR = pMalloc->GetBase();

    }
    else                     // try to create a new shared heap
#else
    if (!fInitialisedSm)
#endif // MULTIHEAP
    {
        IMalloc * pm;
        hr = DfCreateSharedAllocator ( &pm, FALSE );
    }
    if ( SUCCEEDED(hr) )
#ifdef MULTIHEAP
    hr = pMalloc->Sync();
#else
	hr = g_smAllocator.Sync();
#endif

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:	DfInitSharedMemBase, public
//
//  Synopsis:	Set up the base of shared memory
//
//  History:	31-May-94	MikeSe	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DfInitSharedMemBase()
{
#if !defined MULTIHEAP
    // make sure we have initialised. This is sufficient to ensure
    //  that DFBASEPTR is set up
    if (!fInitialisedSm)
    {
        IMalloc * pm;
        HRESULT hr = DfCreateSharedAllocator ( &pm );
    }
#endif
}


#if DBG==1 && !defined(MULTIHEAP)

//+-------------------------------------------------------------------------
//
//  Method:     CLocalAlloc::operator new, public
//
//  Synopsis:   Overloaded new operator to allocate objects from
//		task local space.
//
//  Arguments:  [size] -- Size of block to allocate
//
//  Returns:    Pointer to memory allocated.
//
//  History:    17-Aug-92 	PhilipLa    Created.
//              18-May-93       AlexT       Switch to task IMalloc
//
//--------------------------------------------------------------------------

void *CLocalAlloc::operator new(size_t size)
{
#ifndef WIN32
    olAssert(DfGetResLimit(DBRQ_MEMORY_ALLOCATED) >= 0);
#endif
    olAssert(size > 0);

    if (SimulateFailure(DBF_MEMORY))
    {
        return(NULL);
    }

    if (!HaveResource(DBR_MEMORY, (LONG)size))
    {
        // Artificial limit exceeded so force failure
        return NULL;
    }

    void *pv = TaskMemAlloc(sizeof(CMemAlloc *) + size);

    if (pv != NULL)
    {
        void * const pvOrig = pv;

        memset(pv, NEWMEM, sizeof(CMemAlloc *) + size);

        CMemAlloc *pma = NULL;

        //  Allocate tracking block (with shared memory)
        IMalloc *pMalloc;

#ifdef WIN32
#ifdef MULTIHEAP
        pMalloc = &g_smAllocator;
#else
	if ( FAILED(DfCreateSharedAllocator ( &pMalloc )) )
	    pMalloc = NULL;
#endif // MULTIHEAP
#else
        if (FAILED(DfGetScode(CoGetMalloc(MEMCTX_SHARED, &pMalloc))))
            pMalloc = NULL;
#endif

        if (pMalloc)
        {
            pma = (CMemAlloc *) pMalloc->Alloc(sizeof(CMemAlloc));
            if (pma != NULL)
            {
                memset(pma, NEWMEM, sizeof(CMemAlloc));
                CMemAlloc **ppma = (CMemAlloc **) pv;
                pv = (void *) ((CMemAlloc **)pv + 1);
                *ppma = pma;

                AddAlloc(pma, *(((void **)&size)-1), size, pv,
                         GetCurrentContextId());
            }

            pMalloc->Release();
        }

        if (pma == NULL)
        {
            //  Couldn't allocate tracking block - fail allocation
            TaskMemFree(pvOrig);
            pv = NULL;
        }
    }

    if (pv == NULL)
    {
        ModifyResLimit(DBR_MEMORY, (LONG)size);
    }

    return(pv);
}

//+-------------------------------------------------------------------------
//
//  Method:     CLocalAlloc::operator delete, public
//
//  Synopsis:   Free memory from task local space
//
//  Arguments:  [pv] -- Pointer to memory to free
//
//  History:    17-Aug-92 	PhilipLa    Created.
//              18-May-93       AlexT       Switch to task IMalloc
//
//--------------------------------------------------------------------------

void CLocalAlloc::operator delete(void *pv)
{
    if (pv == NULL)
        return;

    CMemAlloc **ppma = (CMemAlloc **)pv;
    ppma--;

    CMemAlloc *pma = *ppma;

    RemoveAlloc(pma, pv, GetCurrentContextId());

    pv = (void *) ppma;
    memset(pv, OLDMEM, (size_t) pma->cbSize);

    //  Free tracking block
    IMalloc *pMalloc = NULL;

#ifdef WIN32
#ifdef MULTIHEAP
    pMalloc = &g_smAllocator;
#else
    if ( FAILED(DfCreateSharedAllocator ( &pMalloc )) )
        pMalloc = NULL;
#endif // MULTIHEAP
#else
    if (FAILED(DfGetScode(CoGetMalloc(MEMCTX_SHARED, &pMalloc))))
        pMalloc = NULL;
#endif

    if (pMalloc != NULL)
    {
        memset(pma, OLDMEM, sizeof(CMemAlloc));
        pMalloc->Free(pma);
        pMalloc->Release();
    }
    else
        olAssert(!aMsg("Unable to get shared allocator\n"));

    TaskMemFree(pv);
}

#endif // DBG==1 && !defined(MULTIHEAP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\pdffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       pdffuncs.cxx
//
//  Contents:   PDocFile static member functions
//
//  History:    22-Jun-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <tstream.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     PDocFile::CreateFromUpdate, public
//
//  Synopsis:   Creates an object from an update list entry
//
//  Arguments:  [pud] - Update entry
//              [pdf] - Docfile
//              [df] - Permissions
//
//  Returns:    Appropriate status code
//
//  History:    02-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE PDocFile::CreateFromUpdate(CUpdate *pud,
                                 PDocFile *pdf,
                                 DFLAGS df)
{
    PDocFile *pdfChild = NULL;
    PSStream *pstChild = NULL;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  PDocFile::CreateFromUpdate(%p, %p, %X)\n",
                pud, pdf, df));
    olAssert(pud->GetXSM() != NULL);
    switch(pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
    {
    case STGTY_STORAGE:
        olChk(pdf->CreateDocFile(pud->GetCurrentName(), df, pud->GetLUID(),
                                 pud->GetFlags() & ULF_TYPEFLAGS, &pdfChild));
        olChkTo(EH_Create,
                ((CWrappedDocFile *)pud->GetXSM())->SetBase(pdfChild));
        break;
    case STGTY_STREAM:
        olChk(pdf->CreateStream(pud->GetCurrentName(), df, pud->GetLUID(),
                                pud->GetFlags() & ULF_TYPEFLAGS, &pstChild));
        olChkTo(EH_Create,
                ((CTransactedStream *)pud->GetXSM())->SetBase(pstChild));
        break;
    default:
        olAssert(FALSE && aMsg("Unknown type in update list entry"));
        olErr(EH_Err, STG_E_DOCFILECORRUPT);
        break;
    }
    olDebugOut((DEB_ITRACE, "Out PDocFile::CreateFromUpdate\n"));
    return S_OK;

 EH_Create:
    if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) == STGTY_STORAGE)
        if (pdfChild)
            pdfChild->Release();
    else
    {
        olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                 STGTY_STREAM);
        if (pstChild)
            pstChild->Release();
    }
    olVerSucc(pdf->DestroyEntry(pud->GetCurrentName(), TRUE));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     PDocFile::ExcludeEntries, public
//
//  Synopsis:   Excludes the given entries
//
//  Arguments:  [snbExclude] - Entries to exclude
//
//  Returns:    Appropriate status code
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE PDocFile::ExcludeEntries(PDocFile *pdf,
                               SNBW snbExclude)
{
    PSStream *psstChild = NULL;
    PDocFile *pdfChild = NULL;
    SCODE sc;
    CDfName dfnKey;
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  PDocFile::ExcludeEntries(%p)\n",
                snbExclude));
    for (;;)
    {
        if (FAILED(pdf->FindGreaterEntry(&dfnKey, &ib, NULL)))
            break;
        dfnKey.Set(&ib.dfnName);

        if (NameInSNB(&ib.dfnName, snbExclude) == S_OK)
        {
            switch(REAL_STGTY(ib.type))
            {
            case STGTY_STORAGE:
        		olChkTo(EH_pwcsName, pdf->GetDocFile(&ib.dfnName, DF_READ |
        						     DF_WRITE, ib.type,
        						     &pdfChild));
        		olChkTo(EH_Get, pdfChild->DeleteContents());
        		pdfChild->Release();
        		break;
            case STGTY_STREAM:
        	    olChkTo(EH_pwcsName, pdf->GetStream(&ib.dfnName, DF_WRITE,
                                                        ib.type, &psstChild));
                olChkTo(EH_Get, psstChild->SetSize(0));
                psstChild->Release();
                break;
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out ExcludeEntries\n"));
    return S_OK;

EH_Get:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE && pdfChild)
        pdfChild->Release();
    else if (REAL_STGTY(ib.type) == STGTY_STREAM && psstChild)
        psstChild->Release();
EH_pwcsName:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\smalloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       smalloc.cxx
//
//  Contents:   Shared memory heap implementation
//
//  Classes:    
//
//  Functions:  
//
//  History:    29-Mar-94       PhilipLa        Created
//              05-Feb-95   KentCe      Use Win95 Shared Heap.
//              10-May-95   KentCe      Defer Heap Destruction to the last
//                                      process detach.
//
//----------------------------------------------------------------------------

#include <dfhead.cxx>
#pragma hdrstop

#include <smalloc.hxx>
#include <dfdeb.hxx>


#ifdef NEWPROPS
#define FULLIMPL
#endif

//
//  Take advantage of unique Win95 support of a shared heap.
//
#if defined(_CHICAGO_)

#define HEAP_SHARED 0x04000000          // Secret feature of Win95 only.

//
//  Locate the following in a shared data segment.
//
#pragma data_seg(".sdata")

HANDLE gs_hSharedHeap      = NULL;      // hSharedHeap Handle for Win95.
DFLUID gs_dfluid           = LUID_BASE; // shared docfile global LUID

#pragma data_seg()

#define PRINTSTATS

#else // defined(_CHICAGO_)

#ifdef MULTIHEAP
DFLUID gs_dfluid           = LUID_BASE; // task memory heap support
INT    gs_iSharedHeaps     = 0;
#endif

#define DEB_STATS 0x00010000
#define DEB_PRINT 0x00020000


#define PERCENT(a,b,c) (int)((((double)a + (double)b) / (double)c) * 100.0)

#define PRINTSTATS \
        memDebugOut((DEB_STATS,  \
                     "Total size: %lu, Space:  Free: %lu, Alloced: %lu"\
                     "  Blocks:  Free: %lu, Alloced: %lu"\
                     "  Efficiency: %.2f%%\n",\
                     _cbSize,\
                     GetHeader()->_ulFreeBytes,\
                     GetHeader()->_ulAllocedBytes,\
                     GetHeader()->_ulFreeBlocks,\
                     GetHeader()->GetAllocedBlocks(),\
                     PERCENT(GetHeader()->_ulFreeBytes,\
                             GetHeader()->_ulAllocedBytes, _cbSize)));
                     

#if DBG == 1
inline BOOL IsAligned(void *pv)
{
    return !((ULONG_PTR)pv & 7);
}
#else
#define IsAligned(x) TRUE
#endif


#define SHAREDMEMBASE NULL

#endif // !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Init, public
//
//  Synopsis:   Initialize heap for use
//
//  Arguments:  [ulHeapName] -- ID of shared memory heap to use
//              [fUnmarshal] -- TRUE if unmarshaling, FALSE if new open
//
//  Returns:    Appropriate status code
//
//  History:    29-Mar-94       PhilipLa        Created
//              05-Feb-95       KentCe          Use Win95 Shared Heap.
//
//  Remarks:    Review the class destructor if you change this code.
//
//----------------------------------------------------------------------------

#if !defined(MULTIHEAP)
SCODE CSmAllocator::Init(LPWSTR pszName)
#else
SCODE CSmAllocator::Init(ULONG ulHeapName, BOOL fUnmarshal)
#endif
{
    SCODE sc = S_OK;

#if !defined(MULTIHEAP)
    // Initialize the mutex
    sc = _dmtx.Init(TEXT("DocfileAllocatorMutex"));
    if (FAILED(sc))
    {
        return sc;
    }

    sc = _dmtx.Take(DFM_TIMEOUT);
    if (FAILED(sc))
    {
        return sc;
    }
#endif

#if defined(_CHICAGO_)
    //
    //  Create a new shared heap if this is the first time thru.
    //
    if (gs_hSharedHeap == NULL)
    {
        gs_hSharedHeap = HeapCreate(HEAP_SHARED, 0, 0);
#if DBG == 1
        ModifyResLimit(DBRQ_HEAPS, 1);
#endif        
    }

    //
    //  We keep a copy of the shared heap as a flag so the destructor logic
    //  does the right thing.
    //
    //
    m_hSharedHeap = gs_hSharedHeap;

#else
    CSharedMemoryBlock *psmb = NULL;
#ifdef MULTIHEAP
    _cbSize = 0;
    if (!fUnmarshal && g_pteb == NtCurrentTeb())  // only for main thread
    {
        if (g_ulHeapName != 0)  // the global shared memory block is active
        {
            _psmb = &g_smb;                             // needed for GetHeader
            _pbBase = (BYTE *)(_psmb->GetBase());       // needed for GetHeader
            if (_pbBase != NULL && GetHeader()->GetAllocedBlocks() == 0)
            {                                           // its' empty reuse it
                psmb = _psmb;
                _ulHeapName = g_ulHeapName;
                memDebugOut ((DEB_ITRACE, "Out CSmAllocator::Init "
                              " reuse %x\n", g_ulHeapName));
                return sc;
            }
        }
        else
        {
            psmb = _psmb = &g_smb;             // initialize g_smb
        }
    }

    if (psmb == NULL)
    {
        psmb = _psmb = new CSharedMemoryBlock ();
        if (psmb == NULL)
            return STG_E_INSUFFICIENTMEMORY;
    }

    WCHAR awszName[DOCFILE_SM_NAMELEN];
    StringCbPrintfW (awszName, sizeof(awszName), L"DfSharedHeap%X", ulHeapName);
#else
    psmb = &_smb;
#endif

#if WIN32 == 100 || WIN32 > 200
    CGlobalSecurity         gs;
    if (SUCCEEDED(sc = gs.Init(TRUE)))
    {
#else
    LPSECURITY_ATTRIBUTES gs = NULL;
#endif

    //  the SMB needs a few bytes for its own header. If we request
    //  a page sized allocation, those few header bytes will cause an
    //  extra page to be allocated, so to prevent that we subtract off
    //  the header space from our requests.

    sc = psmb->Init(awszName,
                   DOCFILE_SM_SIZE - psmb->GetHdrSize(),        // reserve size
                   INITIALHEAPSIZE - psmb->GetHdrSize(),        // commit size
                   SHAREDMEMBASE,               // base address
                   (SECURITY_DESCRIPTOR *)gs,               // security descriptor
                   TRUE);                       // create if doesn't exist

    // Always pass in TRUE for "fOKToCreate", since passing FALSE
    // will open an existing mapping in read-only mode, but we need read-write

#if WIN32 == 100 || WIN32 > 200
    }
#endif

    if (SUCCEEDED(sc))
    {
#if DBG == 1
        ModifyResLimit(DBRQ_HEAPS, 1);
#endif                
        _cbSize = psmb->GetSize();
        _pbBase = (BYTE *)(psmb->GetBase());
#ifdef MULTIHEAP
        gs_iSharedHeaps++;
        _ulHeapName = ulHeapName;
#endif
        
        if (psmb->Created())
        {
            if (fUnmarshal)  // do not allow creates for unmarshals
            {
                Uninit();
                memErr (EH_Err, STG_E_INVALIDFUNCTION);
            }
            else
            {
                Reset();
            }
        }
        else if (!fUnmarshal)  // do not open existing heaps for root creates
        {
            Uninit();
            memErr (EH_Err, STG_E_INUSE);
        }
        
#ifdef MULTIHEAP
        if (psmb == &g_smb)
            g_ulHeapName = ulHeapName;         // store global heap name
#endif
        PRINTSTATS;
    }
#endif
    
#if defined(MULTIHEAP)
    memDebugOut ((DEB_ITRACE, "Out CSmAllocator::Init sc=%x %x\n",
                  sc, ulHeapName));
#else
    _dmtx.Release();
    memDebugOut ((DEB_ITRACE, "Out CSmAllocator::Init sc=%x\n",
                  sc));
#endif

EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::QueryInterface, public
//
//  Synopsis:   Standard QI
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSmAllocator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::QueryInterface:%p()\n", this));

    if (IsEqualIID(iid, IID_IMalloc) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IMalloc *) this;
        CSmAllocator::AddRef();
    }
    else
        sc = E_NOINTERFACE;
        
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::QueryInterface\n"));

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSmAllocator::AddRef(void)
{
#ifdef MULTIHEAP
    return ++_cRefs;
#else
    return 1;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Release, public
//
//  Synopsis:   Release
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSmAllocator::Release(void)
{
#ifdef MULTIHEAP
    ULONG cRefs = --_cRefs;
    if (cRefs <= 0 && this != &g_ErrorSmAllocator)
        delete this;
    return cRefs;
#else
    return 0;
#endif
}

#if !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::FindBlock, private
//
//  Synopsis:   Find an appropriately sized block in the heap.
//
//  Arguments:  [cb] -- Size of block required
//
//  Returns:    Pointer to block, NULL on failure
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

CBlockHeader * CSmAllocator::FindBlock(SIZE_T cb, CBlockHeader **ppbhPrev)
{
    CBlockHeader *pbhCurrent = GetAddress(GetHeader()->GetFirstFree());
    *ppbhPrev = NULL;
    
    while (pbhCurrent != NULL)
    {
        memAssert(IsAligned(pbhCurrent));
        
        if ((pbhCurrent->GetSize() >= cb) && (pbhCurrent->IsFree()))
        {
            memAssert(pbhCurrent->GetSize() < _cbSize);  //MULTIHEAP
            memAssert((BYTE *)pbhCurrent >= _pbBase && 
                      (BYTE *)pbhCurrent < _pbBase + _cbSize);  // MULTIHEAP
            break;
        }
        else
        {
            memAssert (pbhCurrent->GetNext() <= _cbSize);   // MULITHEAP
            *ppbhPrev = pbhCurrent;
            pbhCurrent = GetAddress(pbhCurrent->GetNext());
        }
    }
    return pbhCurrent;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Reset, private
//
//  Synopsis:   Reset the heap to its original empty state.
//
//  Returns:    Appropriate status code
//
//  History:    04-Apr-94       PhilipLa        Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline SCODE CSmAllocator::Reset(void)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Reset:%p()\n", this));

    CBlockHeader *pbh = (CBlockHeader *)
        (_pbBase + sizeof(CHeapHeader));
            
    memAssert(IsAligned(pbh));
    pbh->SetFree();
    pbh->SetSize(_cbSize - sizeof(CHeapHeader));
    pbh->SetNext(0);

    memAssert((BYTE *)pbh + pbh->GetSize() == _pbBase + _cbSize);
    GetHeader()->SetFirstFree(GetOffset(pbh));
    GetHeader()->SetCompacted();
    GetHeader()->ResetAllocedBlocks();
    GetHeader()->ResetLuid();

#if DBG == 1
    GetHeader()->_ulAllocedBytes = 0;
    GetHeader()->_ulFreeBytes =
        pbh->GetSize() - sizeof(CBlockPreHeader);
    GetHeader()->_ulFreeBlocks = 1;
#endif
        
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Reset\n"));

    return S_OK;
}

#endif // !defined(_CHICAGO_)


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Alloc, public
//
//  Synopsis:   Allocate memory
//
//  Arguments:  [cb] -- Number of bytes to allocate
//
//  Returns:    Pointer to block, NULL if failure
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) CSmAllocator::Alloc (
        SIZE_T cb )
{
    void *pv = NULL;
#if DBG == 1
    SIZE_T cbSize = cb;
#endif
    
#if !defined(_CHICAGO_)
    CBlockHeader *pbh = NULL;
    CBlockHeader *pbhPrev = NULL;
    SCODE sc;
#endif

    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Alloc:%p(%lu)\n", this, cb));

#if defined(_CHICAGO_)

    pv = HeapAlloc(m_hSharedHeap, 0, cb);

#else // !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->Alloc (cb);
    }
#endif

    Sync();

    //The block must be at least large enough to hold the standard
    //  header (size and free bit) and a pointer to the next block.
    if (cb < sizeof(CBlockHeader) - sizeof(CBlockPreHeader))
    {
        cb = sizeof(CBlockHeader) - sizeof(CBlockPreHeader);
    }
    
    cb = cb + sizeof(CBlockPreHeader);

    //Make cb 8 byte aligned.
    if (cb & 7)
    {
        cb += (8 - (cb & 7));
    }

    memAssert((cb >= CBLOCKMIN) && "Undersized block requested.");
    pbh = FindBlock(cb, &pbhPrev);

    if (pbh == NULL)
    {
        if (!(GetHeader()->IsCompacted()))
        {
            //Do a heap merge and try to allocate again.
            CSmAllocator::HeapMinimize();
            pbh = FindBlock(cb, &pbhPrev);
        }
        
        if (pbh == NULL)
        {
#ifdef MULTIHEAP
            CSharedMemoryBlock *psmb = _psmb;
#else
            CSharedMemoryBlock *psmb = &_smb;
#endif
#if DBG == 1
            ULONG ulOldSize = psmb->GetSize();
#endif
            sc = (ULONG)psmb->Commit(_cbSize + (ULONG)max(cb, MINHEAPGROWTH));
            if (SUCCEEDED(sc))
            {
                //Attach newly committed space to free list.
                CBlockHeader *pbhNew = (CBlockHeader *)
                    (_pbBase + _cbSize);

                _cbSize = psmb->GetSize();

                memAssert((pbhPrev == NULL) || (pbhPrev->GetNext() == 0));
                memAssert(_cbSize > ulOldSize);

                if (pbhPrev != NULL)
                {
                    pbhPrev->SetNext(GetOffset(pbhNew));
                }
                else
                {
                    GetHeader()->SetFirstFree(GetOffset(pbhNew));
                }

                pbhNew->SetNext(0);
                pbhNew->SetSize(max(cb, MINHEAPGROWTH));
                pbhNew->SetFree();

                
                memAssert((BYTE *)pbhNew + pbhNew->GetSize() ==
                          _pbBase + _cbSize);
                
#if DBG == 1
                GetHeader()->_ulFreeBytes +=
                    pbhNew->GetSize() - sizeof(CBlockPreHeader);
                GetHeader()->_ulFreeBlocks += 1;
#endif
                
                pbh = pbhNew;
            }
#if DBG == 1
            else
            {
                memDebugOut((DEB_ERROR, "Can't grow shared memory\n"));
                PrintAllocatedBlocks();
            }
#endif            
        }
    }

    if (pbh != NULL)
    {
        //Allocate the found block.
        if ((pbh->GetSize() > cb) &&
            (pbh->GetSize() - cb > CBLOCKMIN))
        {
            //Split an existing block.  No free list update required.
            
            CBlockHeader *pbhNew =
                (CBlockHeader *)((BYTE *)pbh + (pbh->GetSize() - cb));

            pbhNew->SetSize(cb);
            pbhNew->ResetFree();
            pbhNew->SetNext(0);
            
            pbh->SetSize(pbh->GetSize() - cb);
#if DBG == 1
            cbSize = cb;
            GetHeader()->_ulAllocedBytes += (cb - sizeof(CBlockPreHeader));
            //The number of available free bytes decreases by the number
            //  of bytes allocated
            GetHeader()->_ulFreeBytes -= cb;
#endif
            memAssert(IsAligned(pbhNew));
            memAssert(IsAligned(pbh));
            
            pbh = pbhNew;
        }
        else
        {
            //Use an entire block.  Update free list appropriately.
            memAssert(IsAligned(pbh));
            pbh->ResetFree();
            if (pbhPrev != NULL)
            {
                pbhPrev->SetNext(pbh->GetNext());
            }
            else
            {
                GetHeader()->SetFirstFree(pbh->GetNext());
            }
#if DBG == 1
            cbSize = pbh->GetSize() - sizeof(CBlockPreHeader);
            GetHeader()->_ulAllocedBytes += cbSize;
            GetHeader()->_ulFreeBytes -= cbSize;
            GetHeader()->_ulFreeBlocks--;
#endif
            pbh->SetNext(0);
        }
    }

    if (pbh != NULL)
    {
        pv = (BYTE *)pbh + sizeof(CBlockPreHeader);
        GetHeader()->IncrementAllocedBlocks();
    }
#endif // !defined(_CHICAGO_)

    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Alloc=> %p\n", pv));

#if !defined(_CHICAGO_)
    memAssert(IsAligned(pv));
#endif // !defined(_CHICAGO_)

    PRINTSTATS;
    
#if DBG == 1 
    if (pv == NULL)
    {
#if defined(_CHICAGO_)
        memDebugOut((DEB_ERROR,
                     "Failed allocation of %lu bytes.\n",
                     cb));
#else  // !defined(_CHICAGO_)
        memDebugOut((DEB_ERROR,
                     "Failed allocation of %lu bytes.  Heap size is %lu\n",
                     cb,
                     _cbSize));
#endif // !defined(_CHICAGO_)
    }
    else
    {
        //Allocated some bytes.  Record this for leak tracking.
        ModifyResLimit(DBRQ_MEMORY_ALLOCATED, (LONG)pbh->GetSize());
    }
#endif
    
    return pv;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Realloc, public
//
//  Synopsis:   Resize the block given
//
//  Arguments:  [pv] -- Pointer to block to realloc
//              [cb] -- New size for block
//
//  Returns:    Pointer to new block, NULL if failure
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) CSmAllocator::Realloc(
        void *pv,
        SIZE_T cb )
{
    void *pvNew = NULL;
#ifdef FULLIMPL
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Realloc:%p()\n", this));

#if defined(_CHICAGO_)

    pvNew = HeapReAlloc(m_hSharedHeap, 0, pv, cb);

#else
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->Realloc (pv, cb);
    }
#endif

    if ((pv != NULL) && (cb == 0))
    {
        CSmAllocator::Free(pv);
        return NULL;
    }

    pvNew = CSmAllocator::Alloc(cb);
    if (pvNew != NULL && pv != NULL)
    {
        //Copy contents
        memcpy(pvNew, pv, min(cb, CSmAllocator::GetSize(pv)));
        CSmAllocator::Free(pv);
    }
#endif
    
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Realloc\n"));
#endif
    PRINTSTATS;
    
    return pvNew;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::DoFree, private
//
//  Synopsis:   Free a memory block
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//  History:    26-Jul-95       SusiA   Created
//
//----------------------------------------------------------------------------
inline void CSmAllocator::DoFree(void *pv)
{
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        g_pTaskAllocator->Free (pv);
        return;
    }
#endif
   memDebugOut((DEB_ITRACE, "In  CSmAllocator::DoFree:%p(%p)\n", this, pv));
#if DBG == 1
   SSIZE_T cbSize = 0;
#endif   

#if defined(_CHICAGO_)

    if (pv != NULL)
    {
#if DBG == 1
        cbSize = HeapSize(m_hSharedHeap, 0, pv);
#endif        
        HeapFree(m_hSharedHeap, 0, pv);
    }

#else

    Sync();
    
    if (pv != NULL)
    {
        CBlockHeader *pbh = (CBlockHeader *)
            ((BYTE *)pv - sizeof(CBlockPreHeader));
#ifdef MULTIHEAP
        SIZE_T ulSize = pbh->GetSize();  // temporary to hold size for debug
#if DBG == 1
        cbSize = ulSize;
#endif        
#endif

        memAssert(IsAligned(pbh));
        memAssert((BYTE*)pbh >= _pbBase && 
                  (BYTE*)pbh < _pbBase + _cbSize);      // MULTIHEAP
        pbh->SetFree();
        pbh->SetNext(GetHeader()->GetFirstFree());

        GetHeader()->SetFirstFree(GetOffset(pbh));
        GetHeader()->ResetCompacted();
        if (GetHeader()->DecrementAllocedBlocks() == 0)
        {
#ifdef MULTIHEAP
            Uninit();
#else
            
            Reset();
#endif
        }
        
#if DBG == 1
        else
        {
            GetHeader()->_ulAllocedBytes -=
                (pbh->GetSize() - sizeof(CBlockPreHeader));
            memAssert (GetHeader()->_ulAllocedBytes <= _cbSize);
            GetHeader()->_ulFreeBytes +=
                (pbh->GetSize() - sizeof(CBlockPreHeader));
            GetHeader()->_ulFreeBlocks++;
        }
#endif
#ifdef MULTIHEAP
        memDebugOut((DEB_ITRACE, "Out CSmAllocator::DoFree.  Freed %lu\n",
                     ulSize));  // don't access shared memory
#else
        memDebugOut((DEB_ITRACE, "Out CSmAllocator::DoFree.  Freed %lu\n",
                     pbh->GetSize()));
#endif
    }
#endif
#if !defined(MULTIHEAP)
    // the shared heap may have been unmapped, mustn't read it now
    PRINTSTATS;
#endif
#if DBG == 1
   //Freed some bytes, so record that.
   ModifyResLimit(DBRQ_MEMORY_ALLOCATED, (LONG)-cbSize);
#endif   
   
}
//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Free, public
//
//  Synopsis:   Free a memory block
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//  History:    29-Mar-94       PhilipLa        Created
//              26-Jul-95       SusiA           Moved bulk of work to DoFree to
//                                              share code between Free and
//                                              FreeNoMutex
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CSmAllocator::Free(void *pv)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Free:%p(%p)\n", this, pv));
    
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#endif
    DoFree(pv);

}
//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::FreeNoMutex, public
//
//  Synopsis:   Free a memory block without first aquiring the mutex.
//              This function is equivalent to Free above, except that is does 
//              not attempt to first aquire the mutex.  It should be used OLNY 
//              when the calling function guarantees to already have the mutex.         
//    
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//  History:    19-Jul-95       SusiA           Created
//
//----------------------------------------------------------------------------

void CSmAllocator::FreeNoMutex(void *pv)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::FreeNoMutex:%p(%p)\n", this, pv));
    
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
   //ensure we already have the mutex
    memAssert(_dmtx.HaveMutex());
#endif
#endif
    DoFree(pv);

}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::GetSize, public
//
//  Synopsis:   Return the size of the given block
//
//  Arguments:  [pv] -- Block to get size of
//
//  Returns:    Size of block pointer to by pv
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T) CSmAllocator::GetSize(void * pv)
{
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->GetSize (pv);
    }
#endif
    
    Sync();
    
    SIZE_T ulSize = (SIZE_T)-1;
#ifdef FULLIMPL
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::GetSize:%p()\n", this));
    if (pv != NULL)
    {
#if defined(_CHICAGO_)
        ulSize = HeapSize(m_hSharedHeap, 0, pv);
#else
        CBlockHeader *pbh;
        pbh = (CBlockHeader *)((BYTE *)pv - sizeof(CBlockPreHeader));
        
        ulSize = pbh->GetSize() - sizeof(CBlockPreHeader);
#endif
    }
        
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::GetSize\n"));
#endif
    return ulSize;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::DidAlloc, public
//
//  Synopsis:   Return '1' if this heap allocated pointer at pv
//
//  Arguments:  [pv] -- Pointer to block
//
//  Returns:    '1' == This heap allocated block.
//              '0' == This heap did not allocate block.
//              '-1' == Could not determine if this heap allocated block.
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(int) CSmAllocator::DidAlloc(void FAR * pv)
{
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->DidAlloc (pv);
    }
#endif
    int i = -1;
#ifdef FULLIMPL
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::DidAlloc:%p()\n", this));
#if defined(_CHICAGO_)
    if (HeapValidate(m_hSharedHeap, 0, pv))
    {
       i = 1;
    }
    else
    {
       i = 0;
    }
#else  // !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif

    i = ((BYTE *)pv >= _pbBase) && ((BYTE *)pv <= (_pbBase + _cbSize));
#endif // !defined(_CHICAGO_)
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::DidAlloc\n"));
#endif
    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::HeapMinimize, public
//
//  Synopsis:   Minimize the heap
//
//  Arguments:  None.
//
//  Returns:    void.
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CSmAllocator::HeapMinimize(void)
{
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        g_pTaskAllocator->HeapMinimize ();
        return;
    }
#endif
    
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::HeapMinimize:%p()\n", this));

    PRINTSTATS;
    
#if defined(_CHICAGO_)

    HeapCompact(m_hSharedHeap, 0);

#else  // !defined(_CHICAGO_)

    CBlockHeader *pbhCurrent;
    CBlockHeader *pbhLast = NULL;
    BYTE *pbEnd = _pbBase + _cbSize;

#if DBG == 1
    PrintFreeBlocks();
    GetHeader()->_ulAllocedBytes = 0;
    GetHeader()->_ulFreeBytes = 0;
    GetHeader()->_ulFreeBlocks = 0;
#endif
    
    pbhCurrent = (CBlockHeader *)(_pbBase + sizeof(CHeapHeader));

    while ((BYTE *)pbhCurrent < pbEnd)
    {
        memAssert(IsAligned(pbhCurrent));
        memAssert((pbhCurrent->GetSize() != 0) &&
                  "Zero size block found.");
        if (pbhCurrent->IsFree())
        {
            //Check last block.  If adjacent, merge them.  If not,
            //  update pbhNext.
            
            if (pbhLast == NULL)
            {
                GetHeader()->SetFirstFree(GetOffset(pbhCurrent));
#if DBG == 1
                GetHeader()->_ulFreeBlocks = 1;
#endif
            }
            else
            {
                if (pbhLast->GetSize() + GetOffset(pbhLast) ==
                    GetOffset(pbhCurrent))
                {
                    //Merge the blocks.
                    pbhLast->SetSize(pbhLast->GetSize() +
                                     pbhCurrent->GetSize());
                    pbhCurrent = pbhLast;
                }
                else
                {
#if DBG == 1
                    GetHeader()->_ulFreeBytes +=
                        (pbhLast->GetSize() - sizeof(CBlockPreHeader));
                    GetHeader()->_ulFreeBlocks++;
#endif
                    pbhLast->SetNext(GetOffset(pbhCurrent));
                }
            }
            pbhLast = pbhCurrent;
        }
#if DBG == 1
        else
        {
            GetHeader()->_ulAllocedBytes +=
                (pbhCurrent->GetSize() - sizeof(CBlockPreHeader));
        }
#endif
        //Move to next block.
        pbhCurrent =
            (CBlockHeader *)((BYTE *)pbhCurrent + pbhCurrent->GetSize());
    }

    if (pbhLast != NULL)
    {
                    
#if DBG == 1
        GetHeader()->_ulFreeBytes +=
            (pbhLast->GetSize() - sizeof(CBlockPreHeader));
#endif
        pbhLast->SetNext(0);
    }
    else
    {
        GetHeader()->SetFirstFree(0);
    }

    GetHeader()->SetCompacted();
#if DBG == 1
    PrintFreeBlocks();
#endif

#endif // !defined(_CHICAGO_)
    
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::HeapMinimize\n"));
    
    PRINTSTATS;
}

#if !defined(_CHICAGO_)
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::PrintFreeBlocks, private
//
//  Synopsis:   Debug code to print sizes of free blocks
//
//  History:    25-Apr-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

void CSmAllocator::PrintFreeBlocks(void)
{
    CBlockHeader *pbhCurrent = GetAddress(GetHeader()->GetFirstFree());

    memDebugOut((DEB_PRINT, "There are %lu total free blocks\n",
                 GetHeader()->_ulFreeBlocks));
    
    while (pbhCurrent != NULL)
    {
        memDebugOut((DEB_PRINT, "Free block %p has size %lu\n", pbhCurrent,
                     pbhCurrent->GetSize()));
        pbhCurrent = GetAddress(pbhCurrent->GetNext());
    }
}
#endif

#ifdef MULTIHEAP
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::PrintAllocatedBlocks, private
//
//  Synopsis:   Debug code to find allocated block(s) that leaked
//
//  History:    25-Nov-95   HenryLee    Created
//
//----------------------------------------------------------------------------
void CSmAllocator::PrintAllocatedBlocks(void)
{
    CBlockHeader *pbhCurrent;
    CBlockHeader *pbhLast = NULL;
    BYTE *pbEnd = _pbBase + _cbSize;
    ULONG *pul;

    if (_psmb != NULL)
    {
        pbhCurrent = (CBlockHeader *)(_pbBase + sizeof(CHeapHeader));

        while ((BYTE *)pbhCurrent < pbEnd)
        {
            memAssert(IsAligned(pbhCurrent));
            memAssert((pbhCurrent->GetSize() != 0) && "Zero size block found.");
            if (!pbhCurrent->IsFree())
            {
                pul = (ULONG *)((BYTE *)pbhCurrent + sizeof(CBlockPreHeader));
                memDebugOut((DEB_ERROR, "Allocated Block %p %8x %8x (size %lu)\n",
                             pul, *pul, *(pul+1), pbhCurrent->GetSize()));
                
            }
            else
            {
                pul = (ULONG *)pbhCurrent;
                memDebugOut((DEB_ERROR, "Free      Block %p %8x %8x (size %lu)\n",
                             pul, *pul, *(pul+1), pbhCurrent->GetSize()));
            }
            pbhCurrent =
                (CBlockHeader *)((BYTE *)pbhCurrent + pbhCurrent->GetSize());
        }
    }
}
#endif // DBG == 1

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::SetState
//
//  Synopsis:   replace thread local state by PerContext state
//
//  History:    20-Nov-95  Henrylee    Created
//
//----------------------------------------------------------------------------
void CSmAllocator::SetState (CSharedMemoryBlock *psmb, BYTE * pbBase,
                             ULONG ulHeapName, CPerContext ** ppcPrev,
                             CPerContext *ppcOwner)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::SetState(%p, %p, %lx, %p, %p, %p) (this == %p)\n", psmb, pbBase, ulHeapName, ppcPrev, ppcOwner, _ppcOwner, this));

    _psmb = psmb;
    _pbBase = pbBase;
    _cbSize = (_psmb) ? _psmb->GetSize() : 0;
    _ulHeapName = ulHeapName;
    DFBASEPTR = _pbBase;

    if (ppcPrev != NULL)
        *ppcPrev = _ppcOwner;
    _ppcOwner = ppcOwner;

//    memAssert (g_smAllocator.GetBase() == DFBASEPTR);
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::SetState()\n"));
}

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::GetState
//
//  Synopsis:   retrive thread local allocator state into percontext
//
//  History:    20-Nov-95  Henrylee    Created
//
//----------------------------------------------------------------------------
void CSmAllocator::GetState (CSharedMemoryBlock **ppsmb,
                             BYTE ** ppbBase, ULONG *pulHeapName)
{
    *ppsmb = _psmb;
    *ppbBase = _pbBase;
    *pulHeapName = _ulHeapName;
}

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::Uninit
//
//  Synopsis:   unmap the shared memory region
//
//  History:    20-Nov-95  Henrylee    Created
//
//----------------------------------------------------------------------------
SCODE CSmAllocator::Uninit ()
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Uninit\n"));
    if (_psmb != NULL)
    {
        if (_psmb != &g_smb)
        {
            // This is last block in the heap, so we can close the heap
            // now.  There must be no shared heap accesses after this.
            delete _psmb;
#if DBG == 1
            ModifyResLimit(DBRQ_HEAPS, -1);
#endif            
            gs_iSharedHeaps--;
        }
        else
        {
            if (GetHeader()->GetAllocedBlocks() == 0)
                Reset();           // for g_smb
        }
        _psmb = NULL;
    }
    _pbBase = NULL;
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Uninit %x\n", _ulHeapName));

    _ulHeapName = 0;

    return S_OK;
}

#endif // MULTIHEAP

#endif // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\publicdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       publicdf.cxx
//
//  Contents:   Public DocFile implementation
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <time.h>
#include <pbstream.hxx>
#include <tstream.hxx>
#include <sstream.hxx>
#include <lock.hxx>
#include <rpubdf.hxx>

//+--------------------------------------------------------------
//
//  Member: PRevertable::RevertFromAbove, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PRevertable::RevertFromAbove(void)
{
    if (_sig == CPUBDOCFILE_SIG || _sig == CROOTPUBDOCFILE_SIG)
        ((CPubDocFile *)this)->RevertFromAbove();
    else if (_sig == CPUBSTREAM_SIG)
        ((CPubStream *)this)->RevertFromAbove();
    else olAssert (!"Invalid signature on PRevertable");
}

//+--------------------------------------------------------------
//
//  Member: PRevertable::FlushBufferedData, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PRevertable::FlushBufferedData(int recursionlevel)
{
    if (_sig == CPUBDOCFILE_SIG || _sig == CROOTPUBDOCFILE_SIG)
        return ((CPubDocFile *)this)->FlushBufferedData(recursionlevel);
    else if (_sig == CPUBSTREAM_SIG)
        return ((CPubStream *)this)->FlushBufferedData(recursionlevel);
    else olAssert (!"Invalid signature on PRevertable");
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member: PRevertable::EmptyCache, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PRevertable::EmptyCache()
{
    if (_sig == CPUBDOCFILE_SIG || _sig == CROOTPUBDOCFILE_SIG)
        ((CPubDocFile *)this)->EmptyCache();
    else if (_sig == CPUBSTREAM_SIG)
        ((CPubStream *)this)->EmptyCache();
    else olAssert (!"Invalid signature on PRevertable");
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::CPubDocFile, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdfParent] - Parent PubDocFile
//              [pdf] - DocFile basis
//              [df] - Permissions
//              [luid] - LUID
//              [pdfb] - Basis
//              [pdfn] - name
//              [cTransactedDepth] - Number of transacted parents
//              [pmsBase] - Base multistream
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CPubDocFile::CPubDocFile(CPubDocFile *pdfParent,
        PDocFile *pdf,
        DFLAGS const df,
        DFLUID luid,
        CDFBasis *pdfb,
        CDfName const *pdfn,
        UINT cTransactedDepth,
        CMStream *pmsBase)
{
    olDebugOut((DEB_ITRACE, "In  CPubDocFile::CPubDocFile("
            "%p, %p, %X, %lu, %p, %p, %lu, %p)\n",
            pdfParent, pdf, df, luid, pdfb, pdfn, cTransactedDepth,
            pmsBase));
    _pdfParent = P_TO_BP(CBasedPubDocFilePtr, pdfParent);
    _pdf = P_TO_BP(CBasedDocFilePtr, pdf);
    _df = df;
    _luid = luid;
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _cTransactedDepth = cTransactedDepth;

    _wFlags = 0;
    _pmsBase = P_TO_BP(CBasedMStreamPtr, pmsBase);

    _cReferences = 1;
    if (pdfn)
    {
        _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    }
    else
    {
        _dfn.Set((WORD)0, (BYTE *)NULL);
    }

    if (!IsRoot())
        _pdfParent->AddChild(this);

    _sig = CPUBDOCFILE_SIG;

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::CPubDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::~CPubDocFile, public
//
//  Synopsis:   Destructor
//
//  History:    23-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::vdtor(void)
{
    olAssert(_cReferences == 0);

    if (_sig == CROOTPUBDOCFILE_SIG)
    {
        ((CRootPubDocFile *)this)->vdtor();
        return;
    }

    _sig = CPUBDOCFILE_SIGDEL;

    if (SUCCEEDED(CheckReverted()))
    {
        ChangeXs(DF_NOLUID, XSO_RELEASE);
        olAssert(!IsRoot());
        _pdfParent->ReleaseChild(this);

        _cilChildren.DeleteByName(NULL);

        if (_pdf)
            _pdf->Release();
    }
    delete this;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Release, public
//
//  Synopsis:   Releases resources for a CPubDocFile
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::vRelease(void)
{
    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Release()\n"));

    olAssert(_cReferences > 0);

    if (_pdf && !P_TRANSACTED(_df) && SUCCEEDED(CheckReverted()))
    {
        TIME_T tm;

#ifdef ACCESSTIME
        if (SUCCEEDED(DfGetTOD(&tm)))
            olVerSucc(_pdf->SetTime(WT_ACCESS, tm));
#endif

#ifdef NEWPROPS
        olVerSucc(FlushBufferedData(0));
#endif
        if (IsDirty())
        {
            if (SUCCEEDED(DfGetTOD(&tm)))
                olVerSucc(_pdf->SetTime(WT_MODIFICATION, tm));
            if (!IsRoot())
                _pdfParent->SetDirty();
            else
            {
                msfAssert(P_WRITE(_df) &&
                        aMsg("Dirty & Direct but no write access"));
            }
            SetClean();
        }
        if (IsRoot() && P_WRITE(_df))
        {
            SCODE sc;
            sc = _pmsBase->Flush(0);
#if DBG == 1
            if (FAILED(sc))
            {
                olDebugOut((DEB_ERROR,
                            "ILockBytes::Flush() failed in release path "
                            "with error %lx\n", sc));
            }
#endif
        }
    }

    vDecRef();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::Release()\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CPubDocFile::CopyLStreamToLStream, private
//
//  Synopsis:   Copies the contents of a stream to another stream
//
//  Arguments:  [plstFrom] - Stream to copy from
//              [plstTo] - Stream to copy to
//
//  Returns:    Appropriate status code
//
//  History:    13-Sep-91       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::CopyLStreamToLStream(ILockBytes *plstFrom,
        ILockBytes *plstTo)
{
    BYTE *pbBuffer;
    ULONG cbBuffer = 0;
    SCODE sc;
    ULONG cbRead, cbWritten;
    ULARGE_INTEGER cbPos;
    STATSTG stat;
    ULONG cbBufferSave = 0;

    GetSafeBuffer(CB_SMALLBUFFER, CB_LARGEBUFFER, &pbBuffer, &cbBuffer);
    olAssert((pbBuffer != NULL) && aMsg("Couldn't get scratch buffer"));

    // Set destination size for contiguity
    olHChk(plstFrom->Stat(&stat, STATFLAG_NONAME));
    olHChk(plstTo->SetSize(stat.cbSize));

    // Copy between streams
    ULISet32 (cbPos, 0);
    for (;;)
    {
        BOOL fRangeLocks = IsInRangeLocks (cbPos.QuadPart, cbBuffer);
        if (fRangeLocks)
        {
            ULONG ulRangeLocksBegin = OLOCKREGIONEND_SECTORALIGNED;
            // For unbuffered I/O, make sure we skip a whole page
            cbBufferSave = cbBuffer;

            ulRangeLocksBegin -= (_pdfb->GetOpenFlags() & DF_LARGE) ?
                                  CB_PAGEBUFFER : HEADERSIZE;
            cbBuffer = ulRangeLocksBegin - cbPos.LowPart;
        }

        cbWritten = 0;
        if (cbBuffer > 0)
        {
            olHChk(plstFrom->ReadAt(cbPos, pbBuffer, cbBuffer, &cbRead));
            if (cbRead == 0) // EOF
                break;
            olHChk(plstTo->WriteAt(cbPos, pbBuffer, cbRead, &cbWritten));
            if (cbRead != cbWritten)
                olErr(EH_Err, STG_E_WRITEFAULT);
        }

        if (fRangeLocks)
        {
            cbBuffer = cbBufferSave;
            cbWritten = cbBuffer;
        }
        cbPos.QuadPart += cbWritten;
    }
    // Fall through
 EH_Err:
    FreeBuffer(pbBuffer);
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPubDocFile::PrepareForOverwrite, private
//
//  Synopsis:   Make sure that there is enough space to do a commit
//              when the overwrite flag has been specified.
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  History:    08-Jul-92       PhilipLa        Created.
//
//--------------------------------------------------------------------------


SCODE CPubDocFile::PrepareForOverwrite(void)
{
    SCODE sc;
#ifdef LARGE_DOCFILE
    ULONGLONG ulSize;
#else
    ULONG ulSize;
#endif
    ULARGE_INTEGER ulNewSize;

    olChk(GetCommitSize(&ulSize));

    ulNewSize.QuadPart = ulSize;

    if (P_INDEPENDENT(_df))
    {
        STATSTG statOrig;

        olHChk(_pdfb->GetOriginal()->Stat(&statOrig, STATFLAG_NONAME));
        olAssert(ULIGetHigh(statOrig.cbSize) == 0);

        if (ulNewSize.QuadPart > statOrig.cbSize.QuadPart)
        {
            olHChk(_pdfb->GetOriginal()->SetSize(ulNewSize));
        }
    }

    sc = DfGetScode(_pmsBase->GetILB()->SetSize(ulNewSize));
    // Fall through
 EH_Err:
    olDebugOut((DEB_ITRACE,"Out CPubDocFile::PrepareForOverwrite() =>"
            "%lu\n", sc));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPubDocFile::GetCommitSize, public
//
//  Synopsis:	Get the total size needed to commit the current docfile
//              with overwrite permissions.
//
//  Arguments:	[pulSize] -- Return location for size
//
//  Returns:	Appropriate status code
//
//  Algorithm:  For each Transaction Set Member call GetCommitInfo()
//              1)  If Tset member is a Docfile, then GetCommitInfo
//                  returns number of deleted entries and number of
//                  newly created entries.
//              2)  If Tset member is a stream, GetCommitInfo returns
//                  current size and size of base.
//              Determine the number of DirSectors needed to handle
//                  newly created entries.
//              Determine number of data sectors needed to hold new
//                  stream info.
//              Determine number of fat sectors needed to hold new
//                  data and dir sectors.
//              Determine number of DI Fat sectors needed to hold new
//                  fat sectors.
//              Add size of new sectors to the current size of the
//                  base and return that value.
//
//  History:	15-Jun-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#ifdef LARGE_DOCFILE
SCODE CPubDocFile::GetCommitSize(ULONGLONG *pulSize)
#else
SCODE CPubDocFile::GetCommitSize(ULONG *pulSize)
#endif
{
    SCODE sc;
    PTSetMember *ptsm;
    ULONG cDirEntries = 0;
    ULONG cNewSectors = 0;
    ULONG cMiniSectors = 0;
    ULONG cMiniFatSectors;
    ULONG cFatSectors = 0;
    ULONG cFatLast;
    ULONG cDIFatSectors = 0;

    olDebugOut((DEB_ITRACE,"In CPubDocFile::PrepareForOverwrite()\n"));
    //Bytes per sector
    ULONG cbSect = _pmsBase->GetSectorSize();

    if (!(_wFlags & PF_PREPARED))
    {
        //DirEntries per sector
        ULONG cdsSect = cbSect / sizeof(CDirEntry);

        //Fat entries per sector
        ULONG cfsSect = cbSect / sizeof(SECT);

        //Minisectors per sector
        ULONG cmsSect = cbSect / MINISECTORSIZE;

#ifdef LARGE_STREAMS
        ULONGLONG ulRet1 = 0, ulRet2 = 0;
#else
        ULONG ulRet1, ulRet2;
#endif
        for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
        {
            ptsm->GetCommitInfo(&ulRet1, &ulRet2);
            switch(REAL_STGTY(ptsm->ObjectType()))
            {
            case STGTY_STORAGE:
                if (ulRet2 < ulRet1)
                {
                    cDirEntries += (ULONG)(ulRet1 - ulRet2);
                }
                break;
            case STGTY_STREAM:
                //If new size is larger than old...
                if (ulRet2 > ulRet1)
                {
                    if (ulRet2 < MINISTREAMSIZE)
                    {
                        cMiniSectors += (ULONG)(((ulRet2 + MINISECTORSIZE - 1)
                                / MINISECTORSIZE) -
                                ((ulRet1 + MINISECTORSIZE - 1)
                                 / MINISECTORSIZE));
                    }
                    else
                    {
                        ULONG csectOld = (ULONG)((ulRet1 + cbSect - 1)/cbSect);
                        ULONG csectNew = (ULONG)((ulRet2 + cbSect - 1)/cbSect);

                        cNewSectors += (csectNew - csectOld);
                    }
                }
                break;
            default:
                olAssert(!aMsg("Unknown pstm object type"));
                break;
            }
        }

        cNewSectors += (cDirEntries + cdsSect - 1) / cdsSect;
        cMiniFatSectors = ((cMiniSectors + cfsSect - 1) / cfsSect);

        cNewSectors += cMiniFatSectors + ((cMiniSectors + cmsSect -1) / cmsSect);

        do
        {
            cFatLast = cFatSectors;

            cFatSectors = (cNewSectors + cDIFatSectors + cFatSectors + cbSect - 1)
                / cbSect;

            cDIFatSectors = (cFatSectors + cfsSect - 1) / cfsSect;

        }
        while (cFatLast != cFatSectors);

        cNewSectors += cFatSectors + cDIFatSectors;

    }

    STATSTG stat;
    olHChk(_pmsBase->GetILB()->Stat(&stat, STATFLAG_NONAME));

#ifdef LARGE_DOCFILE
    *pulSize = stat.cbSize.QuadPart + cNewSectors * cbSect;
#else
    *pulSize = stat.cbSize.LowPart + cNewSectors * cbSect;
#endif

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::Commit(DWORD const dwFlags)
{
    SCODE sc=S_OK;
#ifndef COORD
    TIME_T tm;
    PTSetMember *ptsm;
    ULONG ulLock = 0;
    DFSIGNATURE sigMSF = 0;

    STATSTG statBase = {0}, statOrig = {0};

    BOOL fFlush = FLUSH_CACHE(dwFlags);

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Commit:%p(%lX)\n",
                this, dwFlags));

    olChk(CheckReverted());
    if (!P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    if (IsDirty())
    {
        olChk(DfGetTOD(&tm));
        olChk(_pdf->SetTime(WT_MODIFICATION, tm));
    }

    if (P_NOSNAPSHOT(_df) && (dwFlags & STGC_OVERWRITE))
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }

#ifdef ACCESSTIME
    olChk(DfGetTOD(&tm));
    olChk(_pdf->SetTime(WT_ACCESS, tm));
#endif

#ifdef NEWPROPS
    olChk(FlushBufferedData(0));
#endif

    if (!P_TRANSACTED(_df))
    {
        if (IsDirty())
        {
            if (!IsRoot())
                _pdfParent->SetDirty();
            SetClean();
        }

        if (_cTransactedDepth == 0)
        {
            if(STGC_CONSOLIDATE & dwFlags)
                sc = Consolidate(dwFlags);

            olChk(_pmsBase->Flush(fFlush));
        }
        return S_OK;
    }

    olAssert(GetTransactedDepth() > 0 &&
             aMsg("Transaction depth/flags conflict"));

    if (GetTransactedDepth() == 1)
    {
        // A transacted depth of 1 means this is the lowest transacted
        // level and committed changes will go into the real file,
        // so do all the special contents protection and locking

        if (_pdfb->GetOrigLockFlags() & LOCK_ONLYONCE)
            olChk(WaitForAccess(_pdfb->GetOriginal(), DF_WRITE,
                                &ulLock));

        olChkTo(EH_GetAccess, _pmsBase->BeginCopyOnWrite(dwFlags));

        if (dwFlags & STGC_OVERWRITE)
        {
            olChkTo(EH_COW, PrepareForOverwrite());
        }

        if (P_INDEPENDENT(_df) || P_NOSNAPSHOT(_df))
        {
            if (_sigMSF == DF_INVALIDSIGNATURE)
            {
                if ((dwFlags & STGC_ONLYIFCURRENT) &&
                    DllIsMultiStream(_pdfb->GetOriginal()) == S_OK)
                    olErr(EH_COW, STG_E_NOTCURRENT);
            }
            else
            {
                olChkTo(EH_COW, DllGetCommitSig(_pdfb->GetOriginal(),
                                                      &sigMSF));
                if (dwFlags & STGC_ONLYIFCURRENT)
                    if (sigMSF != _sigMSF)
                        olErr(EH_COW, STG_E_NOTCURRENT);
            }
        }
    }

    for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
        if ((ptsm->GetFlags() & XSM_DELETED) == 0)
            olChkTo(EH_NoCommit, ptsm->BeginCommit(dwFlags));

    //  10/02/92 - To handle low disk space situations well, we
    //  preallocate the space we'll need to copy (when independent).

    if (P_INDEPENDENT(_df))
    {
        // With DELAYFLUSH we can't be sure of the size
        // of the file until EndCopyOnWrite, but we do
        // know that the file won't grow so this is safe

        olHChkTo(EH_NoCommit, _pdfb->GetBase()->Stat(&statBase,
                                                     STATFLAG_NONAME));
        olAssert(ULIGetHigh(statBase.cbSize) == 0);

        olHChkTo(EH_NoCommit, _pdfb->GetOriginal()->Stat(&statOrig,
                                                         STATFLAG_NONAME));
        olAssert(ULIGetHigh(statOrig.cbSize) == 0);

        if (ULIGetLow(statBase.cbSize) > ULIGetLow(statOrig.cbSize))
        {
            olHChkTo(EH_NoCommit,
                     _pdfb->GetOriginal()->SetSize(statBase.cbSize));
        }
    }

    //End of phase 1 of commit.

    if (GetTransactedDepth() == 1)
    {
        olChkTo(EH_ResetSize,
            _pmsBase->EndCopyOnWrite(dwFlags, DF_COMMIT));
    }

    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // End commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_COMMIT);

    //
    // Do consolidation here, before we might
    // copy the snapshot back to the original file.
    //
    if(STGC_CONSOLIDATE & dwFlags)
    {
        sc = Consolidate(dwFlags);
    }

    //
    // If this is a root storage in transacted w/ snapshot mode.
    // Copy the snapshot back to the original file.  Only the root
    // transacted storage can be intependent so transacted substorages
    // of direct mode opens do not qualify.
    //
    if (P_INDEPENDENT(_df))
    {
        SCODE scTemp;
        // Not robust against power failure!
        // We made sure we had enough disk space by presetting the larger
        // size.  But should the write fail part way through for other
        // reasons then we have lost the original file!
        // To do this robustly we could "commit" the whole base file to the
        // end of the original file.  Then consolidate the result.
        // But... we don't.  Perhaps we could revisit this later.

        olVerSucc(scTemp = CopyLStreamToLStream(_pdfb->GetBase(),
                                       _pdfb->GetOriginal()));
        olVerSucc(_pdfb->GetOriginal()->Flush());
    }

    if (P_INDEPENDENT(_df) || P_NOSNAPSHOT(_df))
    {
        if (_sigMSF == DF_INVALIDSIGNATURE)
        {
            olVerSucc(DllGetCommitSig(_pdfb->GetOriginal(), &_sigMSF));
        }
        else
        {
            _sigMSF = sigMSF+1;
            olVerSucc(DllSetCommitSig(_pdfb->GetOriginal(), _sigMSF));
        }
    }

    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);

    //  Dirty all parents up to the next transacted storage
    if (IsDirty())
    {
        if (!IsRoot())
            _pdfParent->SetDirty();
        SetClean();
    }

    olDebugOut((DEB_ITRACE, "Out CTransactionLevel::Commit\n"));
#if DBG == 1
    VerifyXSMemberBases();
#endif
    _wFlags = (_wFlags & ~PF_PREPARED);

    if (_sig == CROOTPUBDOCFILE_SIG)
    {
        ((CRootPubDocFile *)this)->CommitTimestamps(dwFlags);
    }

    return sc;

EH_ResetSize:
    if (P_INDEPENDENT(_df) &&
        (ULIGetLow(statBase.cbSize) > ULIGetLow(statOrig.cbSize)))
    {
        _pdfb->GetOriginal()->SetSize(statOrig.cbSize);
    }
EH_NoCommit:
    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // Abort commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_ABORT);
EH_COW:
    if (GetTransactedDepth() == 1)
    {
        olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));
    }
EH_GetAccess:
    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);
EH_Err:
    return sc;

#else //COORD
    ULONG ulLock = 0;
    DFSIGNATURE sigMSF;
    ULONG cbSizeBase;
    ULONG cbSizeOrig;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Commit:%p(%lX)\n",
                this, dwFlags));

    sc = CommitPhase1(dwFlags, &ulLock, &sigMSF, &cbSizeBase, &cbSizeOrig);

    //Only do phase 2 if we're transacted and phase 1 succeeded.
    if (P_TRANSACTED(_df) && SUCCEEDED(sc))
    {
        sc = CommitPhase2(dwFlags,
                          TRUE,
                          ulLock,
                          sigMSF,
                          cbSizeBase,
                          cbSizeOrig);
    }

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::Commit -> %lX\n", sc));

    return sc;
#endif //!COORD
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Consolidate, private
//
//  Synopsis:   Consolidates a Docfile by moving sectors down
//              and filling in free space holes in the file.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    10-Feb-1997       BChapman   Created
//
//---------------------------------------------------------------

SCODE CPubDocFile::Consolidate(DWORD dwFlags)
{
    SCODE sc;

    //
    // Consolidation only makes sense when we are writting to the
    // real file, so we only consolidate on top level commits.
    //
    if(GetTransactedDepth() > 1)
    {
        return STG_S_CANNOTCONSOLIDATE;
    }

    //
    // Consolidating NoScratch is not supported.
    //
    if(P_NOSCRATCH(_df))
    {
        return STG_S_CANNOTCONSOLIDATE;
    }

    //
    // We can only Considate if there is one "seperate" open of the
    // file.  Marshaled opens are OK.
    //

    if(P_NOSNAPSHOT(_df))
    {
        sc = IsSingleWriter();
        if (sc != S_OK)
        {
            return STG_S_MULTIPLEOPENS;
        }
    }

    //
    // Make A backup copy of the FAT, header, etc...
    // Get ready to try to make some revertable changes to the file.
    //
    olChk(_pmsBase->BeginCopyOnWrite(dwFlags));

    //
    // Pack the file down.
    //
    olChkTo(EH_Abort, _pmsBase->Consolidate());
    EmptyCache();

    //
    // Finally commit the consolidation.
    //
    olChkTo(EH_Abort, _pmsBase->EndCopyOnWrite(dwFlags, DF_COMMIT));

    return S_OK;

EH_Abort:
    EmptyCache();
    olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));

EH_Err:
    return STG_S_CONSOLIDATIONFAILED;
}


//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::IsSingleWriter, private
//
//  Synopsis:   Compare the number of locks on the file with the number
//              of Contexts that have this file open.
//
//  Arguments:
//
//  Returns:
//
//  History:    10-Feb-1997       BChapman   Created
//
//---------------------------------------------------------------

SCODE CPubDocFile::IsSingleWriter(void)
{
    ILockBytes *ilb;
    SCODE sc;
    ULONG i, cWriteLocks=0;
    ULARGE_INTEGER uliOffset, ulicbLength;

    ilb = _pdfb->GetBase();

    ulicbLength.QuadPart = 1;
    for (i = 0; i < COPENLOCKS; i++)
    {
        uliOffset.QuadPart = (OOPENWRITELOCK+i);
        if(FAILED(ilb->LockRegion(uliOffset, ulicbLength, LOCK_ONLYONCE)))
        {
            ++cWriteLocks;
        }
        else
        {
            ilb->UnlockRegion(uliOffset, ulicbLength, LOCK_ONLYONCE);
        }
    }
    if(_pdfb->CountContexts() == cWriteLocks)
        return S_OK;

    return S_FALSE;
}


//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pdfnName] - Name of element
//              [fClean] - Whether this was invoked as cleanup or not
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::DestroyEntry(CDfName const *pdfnName,
                                BOOL fClean)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));
    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_pdf->DestroyEntry(pdfnName, fClean));
    _cilChildren.DeleteByName(pdfnName);
    SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::DestroyEntry\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::RenameEntry, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pdfnName] - Current name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//              28-Oct-92       AlexT   Add names to XSM's
//              09-Aug-93       AlexT   Disallow renames of open children
//
//---------------------------------------------------------------


SCODE CPubDocFile::RenameEntry(CDfName const *pdfnName,
                               CDfName const *pdfnNewName)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::RenameEntry(%ws, %ws)\n",
               pdfnName, pdfnNewName));
    olChk(CheckReverted());
    if (FAILED(_cilChildren.IsDenied(pdfnName, DF_WRITE | DF_DENYALL, _df)))
    {
        //  Translate all denial errors to STG_E_ACCESSDENIED
        sc = STG_E_ACCESSDENIED;
    }
    else
    {
        sc = _pdf->RenameEntry(pdfnName, pdfnNewName);

        if (SUCCEEDED(sc))
        {
            SetDirty();
        }
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::RenameEntry\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::CreateDocFile, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::CreateDocFile(CDfName const *pdfnName,
                                 DFLAGS const df,
                                 CPubDocFile **ppdfDocFile)
{
    PDocFile *pdf;
    SCODE sc;
    CWrappedDocFile *pdfWrapped = NULL;
    SEntryBuffer eb;
    UINT cNewTDepth;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::CreateDocFile:%p("
               "%ws, %X, %p)\n", this, pdfnName, df, ppdfDocFile));

    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(CDocFile::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
    cNewTDepth = _cTransactedDepth+(P_TRANSACTED(df) ? 1 : 0);
    olChkTo(EH_DirectReserve,
            CWrappedDocFile::Reserve(cNewTDepth, BP_TO_P(CDFBasis *, _pdfb)));

    olChkTo(EH_Reserve, _pdf->CreateDocFile(pdfnName, df, DF_NOLUID,
                                            &pdf));

    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();

    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    olMemTo(EH_pdf,
            *ppdfDocFile = new (_pmsBase->GetMalloc())
                               CPubDocFile(this, pdf, df, eb.luid,
                                           BP_TO_P(CDFBasis *, _pdfb),
                                           pdfnName, cNewTDepth,
                                           BP_TO_P(CMStream *, _pmsBase)));

    if (P_TRANSACTED(df))
    {
        pdfWrapped = new(BP_TO_P(CDFBasis *, _pdfb))
            CWrappedDocFile(pdfnName, eb.luid, df,
                            BP_TO_P(CDFBasis *, _pdfb), *ppdfDocFile);
        olAssert(pdfWrapped != NULL && aMsg("Reserved DocFile not found"));
        olChkTo(EH_pdfWrapped,
                pdfWrapped->Init(pdf));
        (*ppdfDocFile)->AddXSMember(NULL, pdfWrapped, eb.luid);
        (*ppdfDocFile)->SetDF(pdfWrapped);
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::CreateDocFile\n"));
    return S_OK;

 EH_pdfWrapped:
    delete pdfWrapped;
    (*ppdfDocFile)->vRelease();
    *ppdfDocFile = NULL;
    goto EH_Destroy;
 EH_pdf:
    pdf->Release();
    if (P_TRANSACTED(df))
        CWrappedDocFile::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Destroy:
    olVerSucc(_pdf->DestroyEntry(pdfnName, TRUE));
    return sc;
 EH_Reserve:
    CWrappedDocFile::Unreserve(cNewTDepth, BP_TO_P(CDFBasis *, _pdfb));
 EH_DirectReserve:
    CDocFile::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::GetDocFile, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::GetDocFile(CDfName const *pdfnName,
                              DFLAGS const df,
                              CPubDocFile **ppdfDocFile)
{
    PDocFile *pdf;
    SCODE sc;
    CWrappedDocFile *pdfWrapped;
    SEntryBuffer eb;
    UINT cNewTDepth;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n",
               this, pdfnName, df, ppdfDocFile));

    olChk(CheckReverted());
    if (!P_READ(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check to see if an instance with DENY_* exists
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetDocFile(pdfnName, df, &pdf));

    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    cNewTDepth = _cTransactedDepth+(P_TRANSACTED(df) ? 1 : 0);
    olMemTo(EH_pdf,
            *ppdfDocFile = new (_pmsBase->GetMalloc())
                               CPubDocFile(this, pdf, df, eb.luid,
                                           BP_TO_P(CDFBasis *, _pdfb),
                                           pdfnName, cNewTDepth,
                                           BP_TO_P(CMStream *, _pmsBase)));

    if (P_TRANSACTED(df))
    {
        olMemTo(EH_ppdf, pdfWrapped = new(_pmsBase->GetMalloc())
                CWrappedDocFile(pdfnName, eb.luid, df,
                                BP_TO_P(CDFBasis *, _pdfb), *ppdfDocFile));
        olChkTo(EH_pdfWrapped,
                pdfWrapped->Init(pdf));
        (*ppdfDocFile)->AddXSMember(NULL, pdfWrapped, eb.luid);
        (*ppdfDocFile)->SetDF(pdfWrapped);
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::GetDocFile\n"));
    return S_OK;

EH_pdfWrapped:
    delete pdfWrapped;
EH_ppdf:
    (*ppdfDocFile)->vRelease();
    return sc;
EH_pdf:
    pdf->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdstStream]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::CreateStream(CDfName const *pdfnName,
                                DFLAGS const df,
                                CPubStream **ppdstStream)
{
    PSStream *psst;
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::CreateStream:%p("
                "%ws, %X, %p)\n", this, pdfnName, df, ppdstStream));

    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(CDirectStream::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
    olChkTo(EH_DirectReserve,
            CTransactedStream::Reserve(_cTransactedDepth,
                                       BP_TO_P(CDFBasis *, _pdfb)));
    olChkTo(EH_Reserve,
            _pdf->CreateStream(pdfnName, df, DF_NOLUID, &psst));

    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();

    eb.luid = psst->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("Stream id is DF_NOLUID!"));

    olMemTo(EH_Create, *ppdstStream = new (_pmsBase->GetMalloc())
                                          CPubStream(this, df, pdfnName));
    (*ppdstStream)->Init(psst, eb.luid);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::CreateStream\n"));
    return S_OK;

 EH_Create:
    psst->Release();
    olVerSucc(_pdf->DestroyEntry(pdfnName, TRUE));
    return sc;
 EH_Reserve:
    CTransactedStream::Unreserve(_cTransactedDepth,
                                 BP_TO_P(CDFBasis *, _pdfb));
 EH_DirectReserve:
    CDirectStream::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::GetStream, public
//
//  Synopsis:   Gets an existing stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdstStream]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::GetStream(CDfName const *pdfnName,
                             DFLAGS const df,
                             CPubStream **ppdstStream)
{
    PSStream *psst;
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::GetStream(%ws, %X, %p)\n",
                  pdfnName, df, ppdstStream));

    olChk(CheckReverted());
    if (!P_READ(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check permissions
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetStream(pdfnName, df, &psst));

    eb.luid = psst->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("Stream id is DF_NOLUID!"));

    olMemTo(EH_Get, *ppdstStream = new (_pmsBase->GetMalloc())
                                       CPubStream(this, df, pdfnName));


    (*ppdstStream)->Init(psst, eb.luid);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::GetStream\n"));
    return S_OK;

EH_Get:
    psst->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Stat, public
//
//  Synopsis:   Fills in a stat buffer
//
//  Arguments:  [pstatstg] - Buffer
//              [grfStatFlag] - Stat flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;

    if (_sig == CROOTPUBDOCFILE_SIG)
        return ((CRootPubDocFile *)this)->Stat (pstatstg, grfStatFlag);

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Stat(%p, %lu)\n",
                pstatstg, grfStatFlag));
    olAssert(SUCCEEDED(VerifyStatFlag(grfStatFlag)));
    olChk(CheckReverted());

    pstatstg->pwcsName = NULL;
    olChk(_pdf->GetTime(WT_CREATION, &pstatstg->ctime));
    olChk(_pdf->GetTime(WT_MODIFICATION, &pstatstg->mtime));
    pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
    olChk(_pdf->GetClass(&pstatstg->clsid));
    olChk(_pdf->GetStateBits(&pstatstg->grfStateBits));
    olAssert(!IsRoot());

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
       olMem(pstatstg->pwcsName =
                  (WCHAR *)TaskMemAlloc(_dfn.GetLength()));
       memcpy(pstatstg->pwcsName, _dfn.GetBuffer(), _dfn.GetLength());
    }

    pstatstg->grfMode = DFlagsToMode(_df);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::Stat\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::RevertFromAbove, public
//
//  Synopsis:   Parent has asked for reversion
//
//  History:    29-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::RevertFromAbove(void)
{
    olDebugOut((DEB_ITRACE, "In  CPubDocFile::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;

    _cilChildren.DeleteByName(NULL);

    ChangeXs(DF_NOLUID, XSO_RELEASE);
    _pdf->Release();
    _pdf = NULL;
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::RevertFromAbove\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::FlushBufferedData, public
//
//  Synopsis:   Flush buffered data in any child streams.
//
//  History:    5-May-1995       BillMo Created
//
//---------------------------------------------------------------

#ifdef NEWPROPS

SCODE CPubDocFile::FlushBufferedData(int recursionlevel)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::FlushBufferedData:%p()\n", this));

    if ((recursionlevel == 0 && (_df & DF_TRANSACTED)) ||
        (_df & DF_TRANSACTED) == 0)
    {
        sc = _cilChildren.FlushBufferedData(recursionlevel);
    }
    else
    {
        sc = S_OK;
    }

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::FlushBufferedData\n"));

    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::ChangeXs, public
//
//  Synopsis:   Performs an operation on the XS
//
//  Arguments:  [luidTree] - LUID of tree or DF_NOLUID
//              [dwOp] - Operation
//
//  History:    30-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::ChangeXs(DFLUID const luidTree,
                           DWORD const dwOp)
{
    olAssert((dwOp == XSO_RELEASE) || (dwOp == XSO_REVERT));

    PTSetMember *ptsmNext, *ptsmCur, *ptsmPrev;

    for (ptsmNext = _tss.GetHead(); ptsmNext; )
    {
        ptsmCur = ptsmNext;
        ptsmNext = ptsmCur->GetNext();
        olAssert ((ptsmCur->GetName() != ptsmCur->GetTree()));

        if (luidTree == DF_NOLUID || ptsmCur->GetName() == luidTree)
        {
            switch(dwOp)
            {
            case XSO_RELEASE:
                ptsmPrev = ptsmCur->GetPrev();
                _tss.RemoveMember(ptsmCur);
                ptsmCur->Release();
                if (ptsmPrev == NULL)
                    ptsmNext = _tss.GetHead();
                else
                    ptsmNext = ptsmPrev->GetNext();
                break;
            case XSO_REVERT:
                ptsmCur->Revert();
                // Revert might have changed the next pointer
                ptsmNext = ptsmCur->GetNext();
                break;
            }
        }
        else if (luidTree != DF_NOLUID && luidTree == ptsmCur->GetTree())
        {
//         This weirdness is necessary because ptsm will be
//         deleted by the call to ChangeXs.  Since ptsm->GetNext()
//         could also be deleted, we would have no way to continue.
//         ptsm->GetPrev() will never be deleted by the call to
//         ChangeXs, since all children of a node appear _after_
//         that node in the list.  Therefore, ptsm->GetPrev()->GetNext()
//         is the best place to resume the loop.

            ptsmPrev = ptsmCur->GetPrev();

            ChangeXs(ptsmCur->GetName(), dwOp);
            if (ptsmPrev == NULL)
                ptsmNext = _tss.GetHead();
            else
                ptsmNext = ptsmPrev->GetNext();
        }
    }

}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::AddXSMember, public
//
//  Synopsis:   Adds an object to the XS
//
//  Arguments:  [ptsmRequestor] - Object requesting add or NULL if
//                      first addition
//              [ptsmAdd] - Object to add
//              [luid] - LUID of object
//
//  History:    29-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::AddXSMember(PTSetMember *ptsmRequestor,
                              PTSetMember *ptsmAdd,
                              DFLUID luid)
{
    DFLUID luidTree;
    ULONG ulLevel;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::AddXSMember:%p("
                "%p, %p, %ld)\n", this, ptsmRequestor, ptsmAdd, luid));
    if (ptsmRequestor == NULL)
    {
        // If we're starting the XS, this is a new TL and we have
        // no tree
        luidTree = DF_NOLUID;
        ulLevel = 0;
    }
    else
    {
        // We're creating a subobject so it goes in the parent's tree
        luidTree = ptsmRequestor->GetName();
        ulLevel = ptsmRequestor->GetLevel()+1;
    }
    ptsmAdd->SetXsInfo(luidTree, luid, ulLevel);
    InsertXSMember(ptsmAdd);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::AddXSMember\n"));
}

#if DBG == 1

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::VerifyXSMemberBases,public
//
//  Synopsis:   Verify that all XS members have valid bases
//
//  History:    15-Sep-92       AlexT   Created
//
//---------------------------------------------------------------

void CPubDocFile::VerifyXSMemberBases()
{
    PTSetMember *ptsm;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::VerifyXSMemberBases\n"));
    for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
    {
        DWORD otype = REAL_STGTY(ptsm->ObjectType());
        olAssert(otype == STGTY_STORAGE || otype == STGTY_STREAM);
        if (otype == STGTY_STORAGE)
        {
            CWrappedDocFile *pdf = (CWrappedDocFile *) ptsm;
            olAssert(pdf->GetBase() != NULL);
        }
        else
        {
            CTransactedStream *pstm = (CTransactedStream *) ptsm;
            olAssert(pstm->GetBase() != NULL);
        }
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::VerifyXSMemberBases\n"));
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::SetElementTimes, public
//
//  Synopsis:   Sets the times for an element
//
//  Arguments:  [pdfnName] - Name
//              [pctime] - Create time
//              [patime] - Access time
//              [pmtime] - Modify time
//
//  Returns:    Appropriate status code
//
//  History:    10-Nov-92       DrewB     Created
//              06-Sep-95       MikeHill  Added call to CMStream::MaintainFLBModifyTimestamp().
//              26-Apr-99       RogerCh   Removed call to CMStram::MaintainFLBModifyTimestamp().
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::SetElementTimes(CDfName const *pdfnName,
                                   FILETIME const *pctime,
                                   FILETIME const *patime,
                                   FILETIME const *pmtime)
{
    SCODE sc;
    PDocFile *pdf;
    PTSetMember *ptsm = NULL;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::SetElementTimes:%p("
                "%ws, %p, %p, %p)\n", this, pdfnName, pctime,
                patime, pmtime));
    olChk(CheckReverted());

    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
    {
        olErr(EH_Err, STG_E_ACCESSDENIED);
    }
           
    if (pdfnName != NULL)
    {
        if (_cilChildren.FindByName(pdfnName) != NULL)
            olErr(EH_Err, STG_E_ACCESSDENIED);
    }

    if (pdfnName == NULL)
    {
        //Set pdf to the transacted self object.
        pdf = BP_TO_P(PDocFile *, _pdf);
    }
    else if ((ptsm = FindXSMember(pdfnName, _luid)) != NULL)
    {
        if (ptsm->ObjectType() != STGTY_STORAGE)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        pdf = (CWrappedDocFile *)ptsm;
    }
    else olChk(_pdf->GetDocFile(pdfnName, DF_WRITE, &pdf));


    if (pctime)
    {
        olChkTo(EH_pdf, pdf->SetTime(WT_CREATION, *pctime));
    }
    if (pmtime)
    {
        olChkTo(EH_pdf, pdf->SetTime(WT_MODIFICATION, *pmtime));
    }
    if (patime)
    {
        olChkTo(EH_pdf, pdf->SetTime(WT_ACCESS, *patime));
    }

    if (pdfnName != NULL)
        SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::SetElementTimes\n"));
    // Fall through
 EH_pdf:
    if ((ptsm == NULL) && (pdfnName != NULL))
        pdf->Release();
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - Class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::SetClass(REFCLSID clsid)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::SetClass:%p(?)\n", this));
    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    sc = _pdf->SetClass(clsid);

    SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::SetClass\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - State bits
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::SetStateBits:%p(%lu, %lu)\n",
                this, grfStateBits, grfMask));
    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    sc = _pdf->SetStateBits(grfStateBits, grfMask);

    SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::SetStateBits\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::Validate, public static
//
//  Synopsis:   Validates a possibly invalid public docfile pointer
//
//  Arguments:  [pdf] - Memory to check
//
//  Returns:    Appropriate status code
//
//  History:    26-Mar-93       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::Validate(CPubDocFile *pdf)
{
    if (FAILED(ValidateBuffer(pdf, sizeof(CPubDocFile))) ||
        (pdf->_sig != CPUBDOCFILE_SIG && pdf->_sig != CROOTPUBDOCFILE_SIG))
    {
        return STG_E_INVALIDHANDLE;
    }
    return S_OK;
}



#ifdef COORD
//+---------------------------------------------------------------------------
//
//  Member:	CPubDocFile::CommitPhase1, public
//
//  Synopsis:	Do phase 1 of the commit sequence
//
//  Arguments:	[dwFlags] -- Commit flags
//
//  Returns:	Appropriate status code
//
//  History:	07-Aug-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPubDocFile::CommitPhase1(DWORD const dwFlags,
                                ULONG *pulLock,
                                DFSIGNATURE *psigMSF,
                                ULONG *pcbSizeBase,
                                ULONG *pcbSizeOrig)
{
    SCODE sc;
    TIME_T tm;
    PTSetMember *ptsm;
    ULONG ulLock = 0;
    DFSIGNATURE sigMSF;

    BOOL fFlush = FLUSH_CACHE(dwFlags);

    olChk(CheckReverted());
    if (!P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    if (IsDirty())
    {
        olChk(DfGetTOD(&tm));
        olChk(_pdf->SetTime(WT_MODIFICATION, tm));
    }


#ifdef ACCESSTIME
    olChk(DfGetTOD(&tm));
    olChk(_pdf->SetTime(WT_ACCESS, tm));
#endif

    if (!P_TRANSACTED(_df))
    {
        if (IsDirty())
        {
            if (!IsRoot())
                _pdfParent->SetDirty();
            SetClean();
        }

        if (_cTransactedDepth == 0)
        {
            //  Direct all the way
            olChk(_pmsBase->Flush(fFlush));
        }
        return S_OK;
    }

    olAssert(GetTransactedDepth() > 0 &&
             aMsg("Transaction depth/flags conflict"));

    if (GetTransactedDepth() == 1)
    {
        // A transacted depth of 1 means this is the lowest transacted
        // level and committed changes will go into the real file,
        // so do all the special contents protection and locking

        olChk(_pmsBase->BeginCopyOnWrite(dwFlags));

        if (dwFlags & STGC_OVERWRITE)
        {
            olChk(PrepareForOverwrite());
        }

        if (_pdfb->GetOrigLockFlags() & LOCK_ONLYONCE)
            olChkTo(EH_COW, WaitForAccess(_pdfb->GetOriginal(), DF_WRITE,
                                          &ulLock));

        if (P_INDEPENDENT(_df) | P_NOSNAPSHOT(_df))
        {
            if (_sigMSF == DF_INVALIDSIGNATURE)
            {
                if ((dwFlags & STGC_ONLYIFCURRENT) &&
                    DllIsMultiStream(_pdfb->GetOriginal()) == S_OK)
                    olErr(EH_GetAccess, STG_E_NOTCURRENT);
            }
            else
            {
                olChkTo(EH_GetAccess, DllGetCommitSig(_pdfb->GetOriginal(),
                                                      &sigMSF));
                if (dwFlags & STGC_ONLYIFCURRENT)
                    if (sigMSF != _sigMSF)
                        olErr(EH_GetAccess, STG_E_NOTCURRENT);
            }
        }
    }

    for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
        if ((ptsm->GetFlags() & XSM_DELETED) == 0)
            olChkTo(EH_NoCommit, ptsm->BeginCommit(dwFlags));

    //  10/02/92 - To handle low disk space situations well, we
    //  preallocate the space we'll need to copy (when independent).

    if (P_INDEPENDENT(_df))
    {
        STATSTG statBase, statOrig;

        // With DELAYFLUSH we can't be sure of the size
        // of the file until EndCopyOnWrite, but we do
        // know that the file won't grow so this is safe

        olHChkTo(EH_NoCommit, _pdfb->GetBase()->Stat(&statBase,
                                                     STATFLAG_NONAME));
        olAssert(ULIGetHigh(statBase.cbSize) == 0);

        olHChkTo(EH_NoCommit, _pdfb->GetOriginal()->Stat(&statOrig,
                                                         STATFLAG_NONAME));
        olAssert(ULIGetHigh(statOrig.cbSize) == 0);

        if (ULIGetLow(statBase.cbSize) > ULIGetLow(statOrig.cbSize))
        {
            olHChkTo(EH_NoCommit,
                     _pdfb->GetOriginal()->SetSize(statBase.cbSize));
        }
        *pcbSizeBase = ULIGetLow(statBase.cbSize);
        *pcbSizeOrig = ULIGetLow(statOrig.cbSize);
    }
    *pulLock = ulLock;
    *psigMSF = sigMSF;

    return S_OK;

EH_NoCommit:
    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // Abort commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_ABORT);
EH_GetAccess:
    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);
EH_COW:
    if (GetTransactedDepth() == 1)
    {
        olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));
    }
EH_Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CPubDocFile::CommitPhase2, public
//
//  Synopsis:	Do phase 2 of commit
//
//  Arguments:	[dwFlags] -- Commit flags
//
//  Returns:	This can only fail if EndCopyOnWrite fails, which should
//               never happen (but can due to a hard disk error).  We
//               include cleanup code just in case.
//
//  History:	07-Aug-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPubDocFile::CommitPhase2(DWORD const dwFlags,
                                BOOL fCommit,
                                ULONG ulLock,
                                DFSIGNATURE sigMSF,
                                ULONG cbSizeBase,
                                ULONG cbSizeOrig)
{
    SCODE sc;
    PTSetMember *ptsm;

    //The commit was aborted for some reason external to this particular
    //  docfile.  We can handle this by calling directly to our cleanup
    //  code, which will abort and return success.
    if (!fCommit)
    {
        sc = S_OK;
        goto EH_Err;
    }

    if (GetTransactedDepth() == 1)
    {
        olChk(_pmsBase->EndCopyOnWrite(dwFlags, DF_COMMIT));
    }

    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // End commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_COMMIT);

    if (P_INDEPENDENT(_df))
    {
        // Not robust, but we made sure we had enough
        // disk space by presetting the larger size
        // There is no practical way of making this robust
        // and we have never guaranteed behavior in the face
        // of disk errors, so this is good enough

        olVerSucc(CopyLStreamToLStream(_pdfb->GetBase(),
                                       _pdfb->GetOriginal()));
        olVerSucc(_pdfb->GetOriginal()->Flush());
    }

    if (P_INDEPENDENT(_df) || P_NOSNAPSHOT(_df))
    {
        if (_sigMSF == DF_INVALIDSIGNATURE)
        {
            olVerSucc(DllGetCommitSig(_pdfb->GetOriginal(), &_sigMSF));
        }
        else
        {
            _sigMSF = sigMSF+1;
            olVerSucc(DllSetCommitSig(_pdfb->GetOriginal(), _sigMSF));
        }
    }
    
    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);

    //  Dirty all parents up to the next transacted storage
    if (IsDirty())
    {
        if (!IsRoot())
            _pdfParent->SetDirty();
        SetClean();
    }

#if DBG == 1
    VerifyXSMemberBases();
#endif
    _wFlags = (_wFlags & ~PF_PREPARED);

    return S_OK;

EH_Err:
    if (P_INDEPENDENT(_df) && (cbSizeBase > cbSizeOrig))
    {
        ULARGE_INTEGER uliSize;
        ULISet32(uliSize, cbSizeOrig);

        _pdfb->GetOriginal()->SetSize(uliSize);
    }

    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // Abort commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_ABORT);

    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);

    if (GetTransactedDepth() == 1)
    {
        olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));
    }

    return sc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\tlsets.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       tlsets.cxx
//
//  Contents:   Transaction level set manager implementation
//
//  History:    20-Jan-1992     PhilipL Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CTSSet::~CTSSet, public
//
//  Synopsis:   destructor
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_1CTSSet)    // inline?
#endif

CTSSet::~CTSSet()
{
    // Last element should be TS, but we can't check this
    // so allow one last element to exist, assuming it will
    // be the TS
    olAssert(_ptsmHead == NULL ||
             _ptsmHead->GetNext() == NULL);
}

//+--------------------------------------------------------------
//
//  Member:     CTSSet::FindName, public
//
//  Synopsis:   Return the element in the TS with the given name
//
//  Arguments:  [pdfn] - name
//              [ulLevel] - level
//
//  Returns:    Matching element or NULL
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//              28-Oct-1992     AlexT   Convert to name
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_FindName)
#endif

PTSetMember *CTSSet::FindName(CDfName const *pdfn, DFLUID dlTree)
{
    PTSetMember *ptsm;

    olDebugOut((DEB_ITRACE, "In  CTSSet::FindName(%p)\n", pdfn));
    olAssert(pdfn != NULL && aMsg("Can't search for Null name"));

    for (ptsm = BP_TO_P(PTSetMember *, _ptsmHead);
         ptsm; ptsm = ptsm->GetNext())
    {
        if (ptsm->GetDfName()->IsEqual(pdfn) && ptsm->GetTree() == dlTree)
            break;
    }
    olDebugOut((DEB_ITRACE, "Out CTSSet::FindName => %p\n", ptsm));
    return ptsm;
}

//+--------------------------------------------------------------
//
//  Member:     CTSSet::AddMember, public
//
//  Synopsis:   Add the member to the correct position in the list
//
//  Arguments:  [ptsmAdd] - Element to add
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//
//  Notes:      This function inserts the provided element into the
//              list in its correct sorted position.
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_AddMember)
#endif

void CTSSet::AddMember(PTSetMember *ptsmAdd)
{
    PTSetMember *ptsm, *ptsmPrev;

    olDebugOut((DEB_ITRACE, "In  CTSSet::AddMember(%p)\n", ptsmAdd));
    for (ptsm = BP_TO_P(PTSetMember *, _ptsmHead), ptsmPrev = NULL;
         ptsm;
         ptsmPrev = ptsm, ptsm = ptsm->GetNext())
        if (ptsm->GetLevel() >= ptsmAdd->GetLevel())
            break;
    if (ptsm == NULL)
        if (ptsmPrev == NULL)
            // Empty list
            _ptsmHead = P_TO_BP(CBasedTSetMemberPtr, ptsmAdd);
        else
        {
            // Nothing with a higher level, add to end of list
            ptsmPrev->SetNext(ptsmAdd);
            ptsmAdd->SetPrev(ptsmPrev);
        }
    else
    {
        // Add before element with higher level
        ptsmAdd->SetNext(ptsm);
        ptsmAdd->SetPrev(ptsm->GetPrev());
        if (ptsm->GetPrev())
            ptsm->GetPrev()->SetNext(ptsmAdd);
        else
            _ptsmHead = P_TO_BP(CBasedTSetMemberPtr, ptsmAdd);
        ptsm->SetPrev(ptsmAdd);
    }
    olDebugOut((DEB_ITRACE, "Out CTSSet::AddMember\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CTSSet::RemoveMember, public
//
//  Synopsis:   Removes the member from the list
//
//  Arguments:  [ptsmRemove] - Element to remove
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_RemoveMember)
#endif

void CTSSet::RemoveMember(PTSetMember *ptsmRemove)
{
    olDebugOut((DEB_ITRACE, "In  CTSSet::RemoveMember(%p)\n", ptsmRemove));
    PTSetMember *ptsmNext = ptsmRemove->GetNext();
    
    if (ptsmRemove->GetPrev())
        ptsmRemove->GetPrev()->SetNext(ptsmNext);
    else
        _ptsmHead = P_TO_BP(CBasedTSetMemberPtr, ptsmNext);
    if (ptsmRemove->GetNext())
        ptsmRemove->GetNext()->SetPrev(ptsmRemove->GetPrev());
    ptsmRemove->SetNext(NULL);
    ptsmRemove->SetPrev(NULL);
    olDebugOut((DEB_ITRACE, "Out CTSSet::RemoveMember\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\rpubdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       rpubdf.cxx
//
//  Contents:   CRootPubDocFile implementation
//
//  History:    26-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <header.hxx>
#include <rpubdf.hxx>
#include <lock.hxx>
#include <filelkb.hxx>

// Priority mode lock permissions
#define PRIORITY_PERMS DF_READ

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::CRootPubDocFile, public
//
//  Synopsis:   Ctor - Initializes empty object
//
//  History:    30-Mar-92       DrewB     Created
//              05-Sep-5        MikeHill  Init _timeModifyAtCommit.
//
//
//---------------------------------------------------------------


CRootPubDocFile::CRootPubDocFile(IMalloc * const pMalloc) :
    _pMalloc(pMalloc),
    CPubDocFile(NULL, NULL, 0, ROOT_LUID, NULL, NULL, 0, NULL)
{
    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::CRootPubDocFile()\n"));


    _ulPriLock = 0;
	
    // Default to an invalid value.
    _timeModifyAtCommit.dwLowDateTime = _timeModifyAtCommit.dwHighDateTime = (DWORD) -1L;
	
    _sig = CROOTPUBDOCFILE_SIG;

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::CRootPubDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::InitInd, private
//
//  Synopsis:   Initializes independent root
//
//  Arguments:  [plstBase] - Base
//              [snbExclude] - Limited instantiation exclusions
//              [dwStartFlags] - Startup flags
//              [df] - Transactioning flags
//
//  Returns:    Appropriate status code
//
//  History:    11-Jun-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::InitInd(ILockBytes *plstBase,
                               SNBW snbExclude,
                               DWORD const dwStartFlags,
                               DFLAGS const df)
{
    CFileStream *pfstCopy;
    ILockBytes *plkbCopy;
    ULONG ulLock = 0;
    CDocFile *pdfFrom, *pdfTo;
    SCODE sc;
    CMStream *pms;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::InitInd()\n"));

    if ((sc = DllGetCommitSig(plstBase, &_sigMSF)) == STG_E_INVALIDHEADER ||
        sc == STG_E_UNKNOWN)
    {
        _sigMSF = DF_INVALIDSIGNATURE;
    }
    else if (FAILED(sc))
    {
        olErr(EH_Err,sc);
    }

    olMem(pfstCopy = new (_pMalloc) CFileStream(_pMalloc));

    olChkTo(EH_pfstCopy, pfstCopy->InitGlobal(
                        RSF_CREATE | RSF_DELETEONRELEASE | RSF_SNAPSHOT |
                        (dwStartFlags & RSF_ENCRYPTED),
                        DF_READWRITE));
    olChkTo(EH_pfstCopy, pfstCopy->InitSnapShot());

    if (!P_PRIORITY(df) && (_pdfb->GetOrigLockFlags() & LOCK_ONLYONCE))
        olChkTo(EH_pfstCopyInit, WaitForAccess(plstBase, DF_READ, &ulLock));
    if (snbExclude)
    {
        plkbCopy = pfstCopy;
        olChkTo(EH_GetAccess, DllMultiStreamFromStream(_pMalloc,
                                                       &pms, &plstBase,
                                                       dwStartFlags,
                                                       df));
        olMemTo(EH_pmsFrom, pdfFrom = new (_pMalloc)
                CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));
        pdfFrom->AddRef();
        olChkTo(EH_pdfFrom, DllMultiStreamFromStream(_pMalloc,
                                                     &pms, &plkbCopy,
                                                     RSF_CREATE,
                                                     0));
        olMemTo(EH_pmsTo, pdfTo = new (_pMalloc)
                CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));
        pdfTo->AddRef();
        olChkTo(EH_pdfTo, pdfFrom->CopyTo(pdfTo, CDF_EXACT, snbExclude));
        olChkTo(EH_pdfTo, pms->Flush(0));

        pdfFrom->Release();
        pdfTo->Release();
    }
    else if ((dwStartFlags & RSF_TRUNCATE) == 0)
    {
        olChkTo(EH_GetAccess, CopyLStreamToLStream(plstBase, pfstCopy));
    }
    if (!P_PRIORITY(df) && ulLock != 0)
        ReleaseAccess(plstBase, DF_READ, ulLock);

    _pdfb->SetBase(pfstCopy);
    _pdfb->SetOriginal(plstBase);
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::InitInd\n"));
    return S_OK;

EH_pdfTo:
    pdfTo->Release();
    goto EH_pdfFrom;
EH_pmsTo:
    DllReleaseMultiStream(pms);
EH_pdfFrom:
    pdfFrom->Release();
    goto EH_GetAccess;
EH_pmsFrom:
    DllReleaseMultiStream(pms);
EH_GetAccess:
    if (!P_PRIORITY(df) && ulLock != 0)
        ReleaseAccess(plstBase, DF_READ, ulLock);
EH_pfstCopyInit:
EH_pfstCopy:
    olVerSucc(pfstCopy->Release());
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::InitNotInd, private
//
//  Synopsis:   Dependent root initialization
//
//  Arguments:  [plstBase] - Base
//              [snbExclude] - Limited instantiation exclusions
//              [dwStartFlags] - Startup flags
//
//  Returns:    Appropriate status code
//
//  History:    11-Jun-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::InitNotInd(ILockBytes *plstBase,
                            SNBW snbExclude,
                            DWORD const dwStartFlags,
                            DFLAGS const df)
{
    CDocFile *pdf;
    SCODE sc;
    CMStream *pms;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::InitNotInd()\n"));

    if (snbExclude)
    {
        olChk(DllMultiStreamFromStream(_pMalloc,
                                       &pms, &plstBase, dwStartFlags,
                                       df));
        olMemTo(EH_pms, pdf = new(_pMalloc)
              CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));
        pdf->AddRef();
        olChkTo(EH_pdf, PDocFile::ExcludeEntries(pdf, snbExclude));
        olChkTo(EH_pdf, pms->Flush(0));
        pdf->Release();
    }
    _pdfb->SetBase(plstBase);
    plstBase->AddRef();
    _pdfb->SetOriginal(plstBase);
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::InitNotInd\n"));
    return S_OK;

EH_pdf:
    //pdf->Release() will also release the multistream.
    pdf->Release();
    return sc;
EH_pms:
    DllReleaseMultiStream(pms);
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::InitRoot, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [plstBase] - Base LStream
//              [dwStartFlags] - How to start things
//              [df] - Transactioning flags
//              [snbExclude] - Parital instantiation list
//              [ppdfb] - Basis pointer return
//              [pulOpenLock] - Open lock index return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfb]
//              [pulOpenLock]
//
//  History:    09-Dec-91       DrewB           Created
//              09-Jun-92       PhilipLa        Added conversion support
//              05-Sep-95       MikeHill        Initialize _timeModifyAtCommit.
//                                              Removed duplicate call to pdfWrapped->CopyTimesFrom
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::InitRoot(ILockBytes *plstBase,
                                DWORD dwStartFlags,
                                DFLAGS const df,
                                SNBW snbExclude,
                                CDFBasis **ppdfb,
                                ULONG *pulOpenLock,
                                CGlobalContext *pgc)
{
    CWrappedDocFile *pdfWrapped;
    CDocFile *pdfBase;
    CFileStream *pfstScratch;
    CMStream *pmsScratch;
    SCODE sc, scConv = S_OK;
    STATSTG statstg;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::InitRoot("
                "%p, %lX, %lX, %p, %p)\n",
                plstBase, dwStartFlags, df, snbExclude, ppdfb));

    // Exclusion only works with a plain open
    olAssert(snbExclude == NULL ||
             (dwStartFlags & (RSF_CREATEFLAGS | RSF_CONVERT)) == 0);

    //  ILockBytes::Stat calls are very expensive;  we avoid one here
    //  if possible

    HRESULT hr;
    IFileLockBytes *pfl;
    if (SUCCEEDED(plstBase->QueryInterface(IID_IFileLockBytes,
                                              (void**) &pfl)))
    {
        //  This is our private ILockBytes implementation.

        hr = pfl->GetLocksSupported(&statstg.grfLocksSupported);
        if (pfl->IsEncryptedFile())
            dwStartFlags |= RSF_ENCRYPTED;
        pfl->Release();
    }
    else
        hr = plstBase->Stat(&statstg, STATFLAG_NONAME);

    olHChk(hr);

    *pulOpenLock = 0;
    if (statstg.grfLocksSupported & LOCK_ONLYONCE)
        olChk(GetOpen(plstBase, df, TRUE, pulOpenLock));
    if (P_PRIORITY(df) && (statstg.grfLocksSupported & LOCK_ONLYONCE))
        olChkTo(EH_GetOpen, GetAccess(plstBase, PRIORITY_PERMS, &_ulPriLock));

    olMemTo(EH_GetPriority, *ppdfb = new (_pMalloc) CDFBasis(_pMalloc, df,
                                          statstg.grfLocksSupported, pgc));
    _pdfb = P_TO_BP(CBasedDFBasisPtr, *ppdfb);


    if (P_INDEPENDENT(df))
        olChkTo(EH_GetPriority, InitInd(plstBase, snbExclude, dwStartFlags,
                                    df));
    else
        olChkTo(EH_GetPriority,
                InitNotInd(plstBase, snbExclude, dwStartFlags, df));

    olMemTo(EH_SubInit, pfstScratch = new (_pMalloc) CFileStream(_pMalloc));
    olChkTo(EH_pfstScratchInit, pfstScratch->InitGlobal(
                            RSF_CREATE | RSF_DELETEONRELEASE | RSF_SCRATCH |
                            (dwStartFlags & RSF_ENCRYPTED),
                            DF_READWRITE));
    _pdfb->SetDirty(pfstScratch);

    CMStream *pms;
    scConv = DllMultiStreamFromStream(_pMalloc,
                                      &pms, _pdfb->GetPBase(),
                                      dwStartFlags |
                                      ((!P_INDEPENDENT(df) &&
                                        P_TRANSACTED(df)) ? RSF_DELAY : 0),
                                      df);
    _pmsBase = P_TO_BP(CBasedMStreamPtr, pms);

    if (scConv == STG_E_INVALIDHEADER)
        scConv = STG_E_FILEALREADYEXISTS;
    olChkTo(EH_pfstScratchInit, scConv);

    if (P_NOSNAPSHOT(df))
    {
        if ((sc = DllGetCommitSig(plstBase, &_sigMSF)) == STG_E_INVALIDHEADER ||
            sc == STG_E_UNKNOWN)
        {
            _sigMSF = DF_INVALIDSIGNATURE;
        }
        else if (FAILED(sc))
        {
            olErr(EH_pmsBase,sc);
        }
    }
    

    olMemTo(EH_pmsBase, pdfBase = new (_pMalloc)
            CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));

    pdfBase->AddRef();

    if (P_TRANSACTED(df))
    {
        _cTransactedDepth = 1;
        CDfName dfnNull;        //  auto-initialized to 0
        WCHAR wcZero = 0;
        dfnNull.Set(2, (BYTE*)&wcZero);

        //  3/11/93 - Demand scratch when opening/creating transacted
        olChkTo(EH_pdfBaseInit, _pdfb->GetDirty()->InitScratch());

        olMemTo(EH_pdfBaseInit, pdfWrapped = new(_pMalloc)
                        CWrappedDocFile(&dfnNull, pdfBase->GetLuid(), df,
                                BP_TO_P(CDFBasis *, _pdfb), this));
        olChkTo(EH_pdfWrapped,
                pdfWrapped->Init(pdfBase));
        AddXSMember(NULL, pdfWrapped, pdfWrapped->GetLuid());
        _pdf = P_TO_BP(CBasedDocFilePtr, (PDocFile *)pdfWrapped);

    }
    else
        _pdf = P_TO_BP(CBasedDocFilePtr, (PDocFile *)pdfBase);


     // For no-scratch transacted files, also save the Docfile's current modify
     // time.  This will be used on the Release (in vdtor).

     if( P_NOSCRATCH( df ))
     {
        if( FAILED( _pmsBase->GetTime( SIDROOT, WT_MODIFICATION, &_timeModifyAtCommit )))
        {
           // Do not return an error, but record an error flag so that
           // vdtor will not try to use it.

           _timeModifyAtCommit.dwLowDateTime = _timeModifyAtCommit.dwHighDateTime = (DWORD) -1;
        }
     }


    olChkTo(EH_pfstScratchInit,
            DllGetScratchMultiStream(&pmsScratch,
                                     (df & DF_NOSCRATCH),
                                     (ILockBytes **)_pdfb->GetPDirty(),
                                     pms));

    _pdfb->SetScratch(pmsScratch);


    if (df & DF_NOSCRATCH)
    {
        _pdfb->SetBaseMultiStream(pms);
        olChkTo(EH_pfstScratchInit, pmsScratch->InitScratch(pms, TRUE));
        _pmsBase->SetScratchMS(pmsScratch);
    }
    else
    {
        _pdfb->SetBaseMultiStream(NULL);
    }


    _df = df;


   // _pdfb->mxs is constructed automatically
	

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::InitRoot\n"));
    return scConv;


EH_pdfWrapped:
    delete pdfWrapped;
EH_pdfBaseInit:
    pdfBase->Release();
    goto EH_pfstScratchInit;

EH_pmsBase:
    DllReleaseMultiStream(BP_TO_P(CMStream *, _pmsBase));

EH_pfstScratchInit:
    olVerSucc(pfstScratch->Release());
    _pdfb->SetDirty(NULL);
EH_SubInit:
    olVerSucc(_pdfb->GetBase()->Release());
    _pdfb->SetBase(NULL);
EH_GetPriority:
    if (_ulPriLock > 0)
    {
        olAssert(P_PRIORITY(df) &&
                 (statstg.grfLocksSupported & LOCK_ONLYONCE));
        ReleaseAccess(plstBase, PRIORITY_PERMS, _ulPriLock);
        _ulPriLock = 0;
    }
EH_GetOpen:
    if (*pulOpenLock != 0)
    {
        olAssert(statstg.grfLocksSupported & LOCK_ONLYONCE);
        ReleaseOpen(plstBase, df, *pulOpenLock);
        *pulOpenLock = 0;
    }
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::~CRootPubDocFile, public
//
//  Synopsis:   dtor
//
//  History:    09-Dec-91       DrewB     Created
//              05-Sep-95       MikeHill  Revert time using _timeModifyAtCommit.
//
//---------------------------------------------------------------


void CRootPubDocFile::vdtor(void)
{
    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::~CRootPubDocFile\n"));

    olAssert(_cReferences == 0);



   // If this is a no-scratch transacted file, revert the Modify timestamp
   // on the Docfile to that of the last commit.
	
   if( P_NOSCRATCH( _df )
       &&
       ( _timeModifyAtCommit.dwLowDateTime != -1L ||
         _timeModifyAtCommit.dwHighDateTime != -1L )  // Don't use an invalid timestamp.
     )
   {
      TIME_T timeModify;
      BOOL fSetTime = TRUE; // set the modify time only if it's changed

      if(SUCCEEDED(_pmsBase->GetTime( SIDROOT, WT_MODIFICATION, &timeModify)))
      {
          if (timeModify.dwLowDateTime == _timeModifyAtCommit.dwLowDateTime &&
              timeModify.dwHighDateTime == _timeModifyAtCommit.dwHighDateTime)
              fSetTime = FALSE;
      }

      // We call SetFileLockBytesTime, rather than SetTime, so that
      // the underlying Docfile's timestamp is changed, but the Storage's
      // timestamp in the Directory is unchanged.  If we changed the
      // Directory, we would have to flush the Multi-Stream.

      // An error here is ignored.

      if (fSetTime)
         _pmsBase->SetFileLockBytesTime( WT_MODIFICATION, _timeModifyAtCommit );
   }


    // We can't rely on CPubDocFile::~CPubDocFile to do this since
    // we're using a virtual destructor
    _sig = CROOTPUBDOCFILE_SIGDEL;

    if (SUCCEEDED(CheckReverted()))
    {
        ChangeXs(DF_NOLUID, XSO_RELEASE);
        _cilChildren.DeleteByName(NULL);
        if (_ulPriLock > 0)
        {
            // Priority instantiation can't be independent
            olAssert(!P_INDEPENDENT(_df));
            ReleaseAccess(_pdfb->GetBase(), PRIORITY_PERMS, _ulPriLock);
        }

        if (_pdf)
            _pdf->Release();
        if (_pdfb)
            _pdfb->vRelease();


    }
	
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::~CRootPubDocFile\n"));
    delete this;
}


//+---------------------------------------------------------------------------
//
//  Member:	CRootPubDocFile::ReleaseLocks, public
//
//  Synopsis:	Release any locks using the given ILockBytes
//
//  Arguments:	[plkb] -- ILockBytes to use for release
//
//  Returns:	void
//
//  History:	24-Jan-95	PhilipLa	Created
//
//  Notes:	This is a cleanup function used to resolve the many
//              conflicts we get trying to release locks using an
//              ILockBytes in a basis that's already been released.
//
//----------------------------------------------------------------------------

void CRootPubDocFile::ReleaseLocks(ILockBytes *plkb)
{
    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::ReleaseLocks:%p()\n", this));
    if (_ulPriLock > 0)
    {
        // Priority instantiation can't be independent
        olAssert(!P_INDEPENDENT(_df));
        ReleaseAccess(plkb, PRIORITY_PERMS, _ulPriLock);
        _ulPriLock = 0;
    }

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::ReleaseLocks\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::Stat, public
//
//  Synopsis:   Fills in a stat buffer from the base LStream
//
//  Arguments:  [pstatstg] - Stat buffer
//              [grfStatFlag] - Stat flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    25-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::Stat(%p, %lu)\n",
                pstatstg, grfStatFlag));
    olChk(CheckReverted());
    olHChk(_pdfb->GetOriginal()->Stat((STATSTG *)pstatstg, grfStatFlag));
    pstatstg->grfMode = DFlagsToMode(_df);
    olChkTo(EH_pwcsName, _pdf->GetClass(&pstatstg->clsid));
    olChkTo(EH_pwcsName, _pdf->GetStateBits(&pstatstg->grfStateBits));
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::Stat\n"));
    return S_OK;

EH_pwcsName:
    if (pstatstg->pwcsName)
    {
        TaskMemFree(pstatstg->pwcsName);
        pstatstg->pwcsName = NULL;
    }
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootPubDocFile::SwitchToFile, public
//
//  Synopsis:   Switches the underlying file in the base ILockBytes
//
//  Arguments:  [ptcsFile] - Filename
//              [plkb] - The ILockBytes to operate on
//              [pulOpenLock] - On entry, the current open lock
//                              On exit, the new open lock
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pulOpenLock]
//
//  History:    08-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CRootPubDocFile::SwitchToFile(OLECHAR const *ptcsFile,
                                    ILockBytes *plkb,
                                    ULONG *pulOpenLock)
{
    IFileLockBytes *pfl;
    SCODE sc;
    BYTE *pbBuffer;
    ULONG cbBuffer;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::SwitchToFile:%p("
                "%s, %p, %p)\n", this, ptcsFile, plkb, pulOpenLock));

    // If you're transacted, nothing can be dirty in the base
    // If you're not dirty, there's no point in flushing
    // This is also necessary to allow SwitchToFile with a read-only source
    if (!P_TRANSACTED(_df) && IsDirty())
    {
        // Make sure pending changes are flushed
        olChk(_pmsBase->Flush(0));

        // Make sure ILockBytes contents are on disk
        olHChk(plkb->Flush());
    }

#ifdef LARGE_DOCFILE
    ULONGLONG ulCommitSize;
#else
    ULONG ulCommitSize;
#endif
    olChk(GetCommitSize(&ulCommitSize));

    // Check for FileLockBytes
    olHChkTo(EH_NotFile, plkb->QueryInterface(IID_IFileLockBytes,
                                              (void **)&pfl));

    // Release old locks
    if (*pulOpenLock)
        ReleaseOpen(plkb, _df, *pulOpenLock);

    // Ask ILockBytes to switch
    GetSafeBuffer(CB_SMALLBUFFER, CB_LARGEBUFFER, &pbBuffer, &cbBuffer);
    olAssert(pbBuffer != NULL);
    sc = DfGetScode(pfl->SwitchToFile(
            ptcsFile,
            ulCommitSize,
            cbBuffer,
            pbBuffer));

    pfl->Release();
    FreeBuffer(pbBuffer);

    //Record the fact that we have enough space for overwrite commit.
    _wFlags = _wFlags | PF_PREPARED;


    // Attempt to get new locks
    // If SwitchToFile failed, the ILockBytes is the same so this will
    //   restore our open locks released above
    // If SwitchToFile succeeded, the ILockBytes is working on the new file
    //   so this will get locks for that
    if (*pulOpenLock)
    {
        ULONG ulLock;

        // Don't propagate failures here since there's nothing
        // that can be done
        if (SUCCEEDED(GetOpen(plkb, _df, FALSE, &ulLock)))
            *pulOpenLock = ulLock;
    }

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::SwitchToFile\n"));
EH_Err:
    return sc;

EH_NotFile:
    return(STG_E_NOTFILEBASEDSTORAGE);
}



//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    29-Aug-95       MikeHill   Created
//              26-Apr-99       RogerCh    Changed to use GetSystemTimeAsFileTime
//
//---------------------------------------------------------------


void CRootPubDocFile::CommitTimestamps(DWORD const dwFlags)
{
    // For no-scratch transacted files, also save the Docfile's modify
    // time.  This will be used to restore the file's current time on a Release.

    if( P_NOSCRATCH( _df ) && P_TRANSACTED( _df ))
    {
        GetSystemTimeAsFileTime(&_timeModifyAtCommit);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\tset.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	tset.cxx
//
//  Contents:	PTSetMember methods
//
//  History:	16-Apr-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "dfhead.cxx"

#pragma hdrstop

#include <entry.hxx>

//+---------------------------------------------------------------------------
//
//  Member:	PTSetMember::Stat, public
//
//  Synopsis:	Fills in a STATSTG for the XSM
//
//  Arguments:	[pstat] - Buffer to fill in
//              [dwFlags] - STATFLAG_*
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pstat]
//
//  History:	12-Apr-93	DrewB	Created
//
//----------------------------------------------------------------------------

SCODE PTSetMember::Stat(STATSTGW *pstat, DWORD dwFlags)
{
    CWrappedDocFile *pwdf;
    CTransactedStream *ptstm;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  PTSetMember::Stat:%p(%p, %lX)\n",
                this, pstat, dwFlags));

    pstat->type = ObjectType();

    if ((pstat->type & STGTY_REAL) == STGTY_STORAGE)
    {
        PTimeEntry *pen;
        
        pwdf = (CWrappedDocFile *)this;
        pen = pwdf;
        olChk(pen->GetTime(WT_CREATION, &pstat->ctime));
        olChk(pen->GetTime(WT_ACCESS, &pstat->atime));
        olChk(pen->GetTime(WT_MODIFICATION, &pstat->mtime));

        olChk(pwdf->GetClass(&pstat->clsid));
        olChk(pwdf->GetStateBits(&pstat->grfStateBits));
        
        ULISet32(pstat->cbSize, 0);
    }
    else
    {
#ifdef LARGE_STREAMS
        ULONGLONG cbSize;
#else
        ULONG cbSize;
#endif

        ptstm = (CTransactedStream *)this;
        ptstm->GetSize(&cbSize);
        pstat->cbSize.QuadPart = cbSize;
    }

    if ((dwFlags & STATFLAG_NONAME) == 0)
    {
        olMem(pstat->pwcsName =
              (WCHAR *)TaskMemAlloc(_dfnName.GetLength()));
        memcpy(pstat->pwcsName, _dfnName.GetBuffer(), _dfnName.GetLength());
    }
    else
    {
        pstat->pwcsName = NULL;
    }
    
    sc = S_OK;

    olDebugOut((DEB_ITRACE, "Out PTSetMember::Stat\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::BeginCommit, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTSetMember::BeginCommit(DWORD const dwFlags)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        return ((CWrappedDocFile *)this)->BeginCommit(dwFlags);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        return ((CTransactedStream *)this)->BeginCommit (dwFlags);
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::EndCommit, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::EndCommit(DFLAGS const df)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->EndCommit (df);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->EndCommit (df);
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::Revert, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::Revert(void)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->Revert ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->Revert ();
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::GetCommitInfo, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
void PTSetMember::GetCommitInfo(ULONGLONG *pulRet1, ULONGLONG *pulRet2) 
#else
void PTSetMember::GetCommitInfo(ULONG *pulRet1, ULONG *pulRet2) 
#endif
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->GetCommitInfo (pulRet1, pulRet2);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->GetCommitInfo (pulRet1, pulRet2);
    else
    {
        *pulRet1 = 0;
        *pulRet2 = 0;
        olAssert (!"Invalid signature on PTSetMember!");
    }
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::AddRef, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::AddRef(void)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->AddRef ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->AddRef ();
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::Release, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::Release (void)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->Release ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->Release ();
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\ulist.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       ulist.cxx
//
//  Contents:   CUpdateList implementation and support routines
//
//  History:    15-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CUpdate::CUpdate, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdfnCurrentName] - Current name pointer
//              [pdfnOriginalName] - Original name pointer
//              [dlLUID] - LUID
//              [dwFlags] - Flags
//              [ptsm] - Entry object
//
//  History:    15-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdate_CUpdate)
#endif

CUpdate::CUpdate(CDfName const *pdfnCurrent,
                 CDfName const *pdfnOriginal,
                 DFLUID dlLUID,
                 DWORD dwFlags,
                 PTSetMember *ptsm)
{
    SetCurrentName(pdfnCurrent);
    SetOriginalName(pdfnOriginal);
    _dl = dlLUID;
    _dwFlags = dwFlags;
    _ptsm = P_TO_BP(CBasedTSetMemberPtr, ptsm);
    _pudNext = _pudPrev = NULL;
    if (_ptsm)
        _ptsm->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdate::~CUpdate, public
//
//  Synopsis:   Destructor
//
//  History:    05-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdate_1CUpdate)  // inline?
#endif

CUpdate::~CUpdate(void)
{
    if (_ptsm)
        _ptsm->Release();
}

//+--------------------------------------------------------------
//
//  Member:     CUpdateList::Add, public
//
//  Synopsis:   Adds an element to an update list
//
//  Arguments:  [pdfnCurrent] - Current name
//              [pdfnOriginal] - Original name
//              [dlLUID] - LUID
//              [dwFlags] - Flags
//              [ptsm] - Entry object
//
//  Returns:    The new element or NULL
//
//  History:    15-Jan-92       DrewB   Created
//
//  Notes:      Caller must handle NULL
//              Entries must be added in the list in the order of
//              Add calls
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Add)
#endif

CUpdate *CUpdateList::Add(IMalloc * const pMalloc,
                          CDfName const *pdfnCurrent,
                          CDfName const *pdfnOriginal,
                          DFLUID dlLUID,
                          DWORD dwFlags,
                          PTSetMember *ptsm)
{
    CUpdate *pudNew;

    olDebugOut((DEB_ITRACE, "In  CUpdateList::Add:%p("
                "%ws, %ws, %ld, %lX, %p)\n", this, pdfnCurrent->GetBuffer(),
                pdfnOriginal->GetBuffer(), dlLUID, dwFlags, ptsm));

    olAssert((dlLUID != DF_NOLUID || pdfnOriginal != NULL) &&
             aMsg("Create update luid can't be DF_NOLUID"));

    pudNew = new (pMalloc) CUpdate(pdfnCurrent, pdfnOriginal, dlLUID,
                                   dwFlags, ptsm);
    if (pudNew)
    {
        Append(pudNew);
    }
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Add => %p\n", pudNew));
    return pudNew;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::Append, public
//
//  Synopsis:   Appends an update to the list
//
//  Arguments:  [pud] - Update
//
//  History:    25-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Append)
#endif

void CUpdateList::Append(CUpdate *pud)
{
    olDebugOut((DEB_ITRACE, "In  CUpdateList::Append:%p(%p)\n", this, pud));
    if (_pudTail)
        _pudTail->SetNext(pud);
    else
        _pudHead = P_TO_BP(CBasedUpdatePtr, pud);
    pud->SetPrev(BP_TO_P(CUpdate *, _pudTail));
    pud->SetNext(NULL);
    _pudTail = P_TO_BP(CBasedUpdatePtr, pud);
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Append\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::Remove, public
//
//  Synopsis:   Removes an element from the list
//
//  Arguments:  [pud] - Element to remove
//
//  History:    25-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Remove)
#endif

void CUpdateList::Remove(CUpdate *pud)
{
    olDebugOut((DEB_ITRACE, "In CUpdateList::Remove:%p(%p)\n", this, pud));
    olAssert(pud != NULL);
    CUpdate *pudNext = pud->GetNext();
    CUpdate *pudPrev = pud->GetPrev();
    
    if (pud->GetNext())
        pudNext->SetPrev(pudPrev);
    if (pud->GetPrev())
        pudPrev->SetNext(pudNext);
    if (pud == _pudHead)
        _pudHead = P_TO_BP(CBasedUpdatePtr, pudNext);
    if (pud == _pudTail)
        _pudTail = P_TO_BP(CBasedUpdatePtr, pudPrev);
    pud->SetNext(NULL);
    pud->SetPrev(NULL);
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Remove\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CUpdateList::Empty, public
//
//  Synopsis:   Frees all elements in an update list
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Empty)
#endif

void CUpdateList::Empty(void)
{
    CUpdate *pudTmp;

    olDebugOut((DEB_ITRACE, "In  CUpdateList::Empty()\n"));
    while (_pudHead)
    {
        pudTmp = _pudHead->GetNext();
        delete BP_TO_P(CUpdate *, _pudHead);
        _pudHead = P_TO_BP(CBasedUpdatePtr, pudTmp);
    }
    _pudTail = NULL;
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Empty\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::IsEntry, public
//
//  Synopsis:   Checks the update list to see if the given name represents
//              and existing entry in the list
//
//  Arguments:  [pdfn] - Name
//              [ppud] - Update entry return or NULL
//
//  Returns:    UIE_CURRENT - Found as a current name
//              UIE_ORIGINAL - Found as an original name
//              UIE_NOTFOUND
//
//  Modifies:   [ppud]
//
//  History:    02-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_IsEntry)
#endif

UlIsEntry CUpdateList::IsEntry(CDfName const *pdfn, CUpdate **ppud)
{
    CUpdate *pud;
    UlIsEntry ret = UIE_NOTFOUND;

    olDebugOut((DEB_ITRACE, "In  CUpdateList::IsEntry:%p(%ws, %p)\n", this,
                pdfn->GetBuffer(), ppud));
    olAssert(pdfn != NULL && pdfn->GetLength() > 0);
    for (pud = BP_TO_P(CUpdate *, _pudTail); pud; pud = pud->GetPrev())
    {
        if (pdfn->IsEqual(pud->GetCurrentName()))
        {
            ret = UIE_CURRENT;
            break;
        }
        else if (pdfn->IsEqual(pud->GetOriginalName()))
        {
            ret = UIE_ORIGINAL;
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CUpdateList::IsEntry\n"));
    if (ppud)
        *ppud = pud;
    return ret;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::Concat, public
//
//  Synopsis:   Concatenates an update list onto the end of this one
//
//  Arguments:  [ul] - List to concatenate
//
//  History:    02-Nov-92       DrewB   Created
//
//  Notes:      [ul]'s head may be modified
//
//+---------------------------------------------------------------------------

#ifdef FUTURECODE
void CUpdateList::Concat(CUpdateList &ul)
{
    olDebugOut((DEB_ITRACE, "In  CUpdateList::Concat:%p(ul)\n", this));
    if (_pudTail)
    {
        _pudTail->SetNext(ul.GetHead());
        if (ul.GetHead())
        {
            ul.GetHead()->SetPrev(_pudTail);
            olAssert(ul.GetTail() != NULL);
            _pudTail = ul.GetTail();
        }
    }
    else
    {
        olAssert(_pudHead == NULL);
        _pudHead = ul.GetHead();
        _pudTail = ul.GetTail();
    }
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Concat\n"));
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CUpdateList::Exists, public static
//
//  Synopsis:	Traverses an update list from a particular point
//              and determines whether a given name exists or
//              is renamed
//
//  Arguments:	[pud] - Update to look from
//              [ppdfn] - Name in/out
//              [fRename] - Perform renames or quit
//
//  Returns:	TRUE if exists
//              FALSE if deleted
//
//  History:	03-Nov-92	DrewB	Created
//
//----------------------------------------------------------------------------

#ifdef FUTURECODE
BOOL CUpdateList::Exists(CUpdate *pud,
                         CDfName **ppdfn,
                         BOOL fRename)
{
    for (; pud; pud = pud->GetNext())
    {
        if (pud->IsRename() &&
            (*ppdfn)->IsEqual(pud->GetOriginalName()))
        {
            if (fRename)
                *ppdfn = pud->GetCurrentName();
            else
                return FALSE;
        }
        else if (pud->IsDelete() &&
                 (*ppdfn)->IsEqual(pud->GetOriginalName()))
        {
            return FALSE;
        }
    }
    return TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CUpdateList::FindBase, public static
//
//  Synopsis:	Searches backwards in an update list for the creation of
//              a particular object, applying renames if necessary
//
//  Arguments:	[pud] - Update to start from
//              [ppdfn] - Name in/out
//
//  Returns:	Pointer to update entry for creation or NULL if
//              no creation entry.  [ppdfn] is changed to point to
//              the base name.
//
//  Modifies:   [ppdfn]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:      Does not kill the search on deletions; primarily
//              intended to be used with names that represent existing
//              entries, although it will work on any name
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_FindBase)
#endif

CUpdate *CUpdateList::FindBase(CUpdate *pud, CDfName const **ppdfn)
{
    for (; pud; pud = pud->GetPrev())
    {
        if (pud->IsRename() &&
            (*ppdfn)->IsEqual(pud->GetCurrentName()))
        {
            *ppdfn = pud->GetOriginalName();
        }
        else if (pud->IsCreate() &&
                 (*ppdfn)->IsEqual(pud->GetCurrentName()))
        {
            return pud;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\wdffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdffuncs.cxx
//
//  Contents:   CWrappedDocFile support methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::DeleteContents, public
//
//  Synopsis:   Destroys the contents of a docfile
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_DeleteContents)    // Wrapdf_TEXT inline?
#endif

SCODE CWrappedDocFile::DeleteContents(void)
{
#ifdef WRAPPED_DELETE_CONTENTS
    PDocFileIterator *pdfi;
    SCODE sc;
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::DeleteContents:%p()\n",
                this));
    _ulChanged.Empty();
    olChk(GetIterator(&pdfi));
    for (;;)
    {
        if (FAILED(pdfi->BufferGetNext(&ib)))
            break;
        olChkTo(EH_pdfi, DestroyEntry(&ib.dfnName, FALSE));
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::DeleteContents\n"));
    // Fall through
EH_pdfi:
    pdfi->Release();
EH_Err:
    return sc;
#else
    olAssert(!aMsg("CWrappedDocFile::DeleteContents called"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetInitialState, private
//
//  Synopsis:   Sets inital values from a base or defaults
//
//  Arguments:  [pdfBase] - Base object or NULL
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB    Created
//              05-Sep-95       MikeHill Clear the time bits after CopyTimesFrom(base)
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_SetInitialState)
#endif

SCODE CWrappedDocFile::SetInitialState(PDocFile *pdfBase)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetInitialState:%p(%p)\n",
                this, pdfBase));
    if (pdfBase == NULL)
    {
        TIME_T tm;

        olChk(DfGetTOD(&tm));
        _tten.SetTime(WT_CREATION, tm);
        _tten.SetTime(WT_MODIFICATION, tm);
        _tten.SetTime(WT_ACCESS, tm);
        _clsid = CLSID_NULL;
        _grfStateBits = 0;
    }
    else
    {
        olChk(CopyTimesFrom(pdfBase));

        // There's no need for the time bits to be dirty; they don't need
        // to be written to the base because they were just read from the base.

        _fDirty &= ~(BOOL)( DIRTY_CREATETIME | DIRTY_MODIFYTIME | DIRTY_ACCESSTIME );

        olChk(pdfBase->GetClass(&_clsid));
        olChk(pdfBase->GetStateBits(&_grfStateBits));
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetInitialState\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::RevertUpdate, private
//
//  Synopsis:   Reverses an update list entry's effect
//
//  Arguments:  [pud] - Update entry
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_RevertUpdate) // Wrapdf_Revert_TEXT
#endif

void CWrappedDocFile::RevertUpdate(CUpdate *pud)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::RevertUpdate:%p(%p)\n",
                this, pud));
    if (pud->IsCreate())
    {
        CDFBasis *pdfb = BP_TO_P(CDFBasis *, _pdfb);

        olAssert(pud->GetLUID() != DF_NOLUID);
        _ppubdf->DestroyChild(pud->GetLUID());
        if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) == STGTY_STORAGE)
        {
            CDocFile::Unreserve(1, pdfb);
            CWrappedDocFile::Unreserve(_ppubdf->GetTransactedDepth()-1,
                                       pdfb);
        }
        else
        {
            CDirectStream::Unreserve(1, pdfb);
            CTransactedStream::Unreserve(_ppubdf->GetTransactedDepth()-1,
                                         pdfb);
        }
    }
   else if (pud->IsRename())
    {
        // Roll back renames
        olAssert(_ppubdf->FindXSMember(pud->GetOriginalName(),
                                       GetName()) == NULL &&
                 aMsg("Revert rename precondition"));

        _ppubdf->RenameChild(pud->GetCurrentName(), GetName(),
                             pud->GetOriginalName());

        olAssert(_ppubdf->FindXSMember(pud->GetCurrentName(),
                                       GetName()) == NULL &&
                 aMsg("Revert rename postcondition"));
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::RevertUpdate\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\wdfiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdfiter.cxx
//
//  Contents:   CWrappedDocFile iterator methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:	CWrappedDocFile::FindGreaterEntry, public
//
//  Synopsis:	Returns the next greater child
//
//  Arguments:	[pdfnKey] - Previous key
//              [pib] - Fast iterator buffer
//              [pstat] - Full iterator buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                        SIterBuffer *pib,
                                        STATSTGW *pstat)
{
    SCODE sc = STG_E_UNKNOWN;
    CDfName *pdfnGreater, *pdfn;
    CUpdate *pud, *pudGreater;
    BOOL fFilled = FALSE;
    WCHAR *pwcsName;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::FindGreaterEntry:%p("
                "%p, %p, %p)\n", this, pdfnKey, pib, pstat));
    olAssert(pib == NULL || pstat == NULL);

    // Find the update entry that has the next greater name than the key
    pudGreater = NULL;
    for (pud = _ulChanged.GetHead(); pud; pud = pud->GetNext())
    {
        if (pud->IsCreate() || pud->IsRename())
        {
            pdfn = pud->GetCurrentName();
            if (_ulChanged.IsEntry(pdfn, NULL) == UIE_CURRENT &&
                CDirectory::NameCompare(pdfn, pdfnKey) > 0 &&
                (pudGreater == NULL ||
                 CDirectory::NameCompare(pdfn,
                                         pudGreater->GetCurrentName()) < 0))
            {
                pudGreater = pud;
                pdfnGreater = pdfn;
            }
        }
    }

    // Request the next greater name from the base
    if (_pdfBase != NULL)
    {
        CDfName dfnKey;

        // Loop until we either get a valid name or we run out
        dfnKey.Set(pdfnKey);
        for (;;)
        {
            if (FAILED(sc = _pdfBase->FindGreaterEntry(&dfnKey, pib, pstat)))
            {
                if (sc != STG_E_NOMOREFILES)
                {
                    olErr(EH_Err, sc);
                }
                else
                {
                    break;
                }
            }
            if (pib)
                dfnKey.Set(&pib->dfnName);
            else
            {
                olAssert(pstat != NULL);
                dfnKey.CopyString(pstat->pwcsName);
            }

            // Filter this name against the update list
            pdfn = &dfnKey;
            if (_ulChanged.IsEntry(pdfn, NULL) == UIE_ORIGINAL)
            {
                if (pstat)
                    TaskMemFree(pstat->pwcsName);
                continue;
            }

            // If this name is less than the update list name, use
            // the stat entry
            if (pudGreater == NULL ||
                CDirectory::NameCompare(pdfn,
                                        pudGreater->GetCurrentName()) < 0)
            {
                PTSetMember *ptsm;

                fFilled = TRUE;

                if (pstat && (ptsm = _ppubdf->FindXSMember(pdfn, GetName())))
                {
                    pwcsName = pstat->pwcsName;
                    // We want to keep the name already in pstat but pick
                    // up any new times on the XSM
                    olChkTo(EH_name, ptsm->Stat(pstat, STATFLAG_NONAME));
                    pstat->pwcsName = pwcsName;
                }

                // No need to check for renames because Exists would
                // have failed if there was a rename
            }
            else if (pstat)
            {
                TaskMemFree(pstat->pwcsName);
            }

            // Found a valid name, so stop looping
            break;
        }
    }

    if (!fFilled)
    {
        if (pudGreater == NULL)
        {
            sc = STG_E_NOMOREFILES;
        }
        else
        {
            if (pstat)
            {
                if (pudGreater->IsCreate())
                {
                    olChk(pudGreater->GetXSM()->Stat(pstat, 0));
                }
                else
                {
                    olAssert(pudGreater->IsRename());
                    olChk(StatEntry(pudGreater->GetCurrentName(), pib, pstat));
                }
            }
            else
            {
                olAssert(pib != NULL);
                pib->dfnName.Set(pudGreater->GetCurrentName());
                pib->type = pudGreater->GetFlags() & ULF_TYPEFLAGS;
            }
            sc = S_OK;
        }
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::FindGreaterEntry\n"));
 EH_Err:
    return sc;

 EH_name:
    if (pstat)
        TaskMemFree(pwcsName);
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CWrappedDocFile::StatEntry, public
//
//  Synopsis:	Gets information for a child
//
//  Arguments:	[pdfn] - Child name
//              [pib] - Short information
//              [pstat] - Full information
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::StatEntry(CDfName const *pdfn,
                                 SIterBuffer *pib,
                                 STATSTGW *pstat)
{
    CUpdate *pud;
    UlIsEntry uie;
    SCODE sc = S_FALSE;
    CDfName const *pdfnBase = pdfn;
    BOOL fResult = FALSE;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::StatEntry:%p(%p, %p, %p)\n",
                this, pdfn, pib, pstat));
    olAssert((pib != NULL) != (pstat != NULL));

    // Attempt to find the name in the update list
    uie = _ulChanged.IsEntry(pdfn, &pud);
    if (uie == UIE_ORIGINAL)
    {
        // Name has been renamed or deleted
        sc = STG_E_FILENOTFOUND;
        fResult = TRUE;
    }
    else if (uie == UIE_CURRENT)
    {
        if (pib)
        {
            pib->dfnName.Set(pud->GetCurrentName());
            pib->type = pud->GetFlags() & ULF_TYPEFLAGS;
            fResult = TRUE;
            sc = S_OK;
        }
        else
        {

            olAssert(pstat != NULL);

            // Find whether the given name came from a create entry
            // or resolve the name to the base name
            pud = CUpdateList::FindBase(pud, &pdfnBase);
            if (pud != NULL)
            {
                // Stat creation update entry
                olChk(pud->GetXSM()->Stat(pstat, 0));
                fResult = TRUE;
            }
            // else the update entry is a rename of an object in the base
            // and FindBase changed pdfnBase to the base name
        }
    }

    olAssert(fResult || sc == S_FALSE);

    if (!fResult)
    {
        // Haven't found the entry so try the base
        if (_pdfBase)
        {
            olChk(_pdfBase->StatEntry(pdfnBase, pib, pstat));

            // Check to see if we need to return a renamed name
            if (!pdfn->IsEqual(pdfnBase))
            {
                if (pib)
                    pib->dfnName.Set(pdfn);
                else
                {
                    TaskMemFree(pstat->pwcsName);
                    olMem(pstat->pwcsName =
                          (WCHAR *)TaskMemAlloc(pdfn->GetLength()));
                    memcpy(pstat->pwcsName, pdfn->GetBuffer(),
                           pdfn->GetLength());
                }
            }
        }
        else
            sc = STG_E_FILENOTFOUND;
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::StatEntry\n"));
 EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\wdfstrm.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdfstrm.cxx
//
//  Contents:   CWrappedDocFile stream methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <tstream.hxx>

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CreateStream, public
//
//  Synopsis:   Creates a wrapped stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [pppstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pppstStream]
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::CreateStream(CDfName const *pdfnName,
                                    DFLAGS const df,
                                    DFLUID dlSet,
                                    PSStream **ppsstStream)
{
    SEntryBuffer eb;
    SCODE sc;
    CTransactedStream *pstWrapped;
    CUpdate *pud = NULL;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CreateStream("
               "%ws, %X, %lu, %p)\n", pdfnName, df, dlSet,
                ppsstStream));

    if (SUCCEEDED(IsEntry(pdfnName, &eb)))
        olErr(EH_Err, STG_E_FILEALREADYEXISTS);

    olAssert(P_TRANSACTED(_df));

    if (dlSet == DF_NOLUID)
        dlSet = CTransactedStream::GetNewLuid(_pdfb->GetMalloc());
    pstWrapped = GetReservedStream(pdfnName, dlSet, _df);
    if (!P_NOUPDATE(df))
    {
        olMemTo(EH_pstWrapped,
                (pud = _ulChanged.Add(_pdfb->GetMalloc(),
                                      pdfnName, NULL, dlSet,
                                      STGTY_STREAM, pstWrapped)));
    }
    if (pstWrapped != NULL)
    {
        olChkTo(EH_pud, pstWrapped->Init(NULL));
        _ppubdf->AddXSMember(this, pstWrapped, dlSet);
    }
    *ppsstStream = pstWrapped;

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CreateStream => %p\n",
                *ppsstStream));
    return S_OK;

 EH_pud:
    if (pud)
        _ulChanged.Delete(pud);
 EH_pstWrapped:
    pstWrapped->ReturnToReserve(BP_TO_P(CDFBasis *, _pdfb));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetStream, public
//
//  Synopsis:   Instantiates a wrapped stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [pppstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pppstStream]
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetStream(CDfName const *pdfnName,
                                 DFLAGS const df,
                                 PSStream **ppsstStream)
{
    PSStream *psstNew;
    PTSetMember *ptsm;
    CTransactedStream *pstWrapped;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetStream("
               "%ws, %X, %p)\n", pdfnName, df, ppsstStream));

    olAssert(P_TRANSACTED(_df));

    //  Look for this name in this level transaction set

    if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
    {
        if (ptsm->ObjectType() != STGTY_STREAM)
            olErr(EH_Err, STG_E_FILENOTFOUND);
        ptsm->AddRef();
        *ppsstStream = (CTransactedStream *)ptsm;
    }
    else if (_pdfBase == NULL ||
             _ulChanged.IsEntry(pdfnName, NULL) == UIE_ORIGINAL)
    {
        // named entry has been renamed or deleted
        // (we can't have a rename or delete without a base)

        olErr(EH_Err, STG_E_FILENOTFOUND);
    }
    else
    {
        //  We didn't find it here, so we need to ask our parent
        //  Find the right name to ask of the parent

	CDfName const *pdfnRealName = pdfnName;
	CUpdate *pud;
	
	if (_ulChanged.IsEntry(pdfnName, &pud) == UIE_CURRENT &&
	    pud->IsRename())
        {
	    pdfnRealName = pud->GetCurrentName();
            // We don't have to worry about picking up creates
            // because any create would have an XSM that would
            // be detected above
            olVerify(_ulChanged.FindBase(pud, &pdfnRealName) == NULL);
        }

	olAssert(_pdfBase != NULL);
        olChk(_pdfBase->GetStream(pdfnRealName, df, &psstNew));
        olAssert(psstNew->GetLuid() != DF_NOLUID &&
                 aMsg("Stream id is DF_NOLUID!"));

#ifdef USE_NOSCRATCH                                  
        olMemTo(EH_Get, pstWrapped = new(_pdfb->GetMalloc())
                CTransactedStream(pdfnName, psstNew->GetLuid(), _df,
                                  _pdfb->GetBaseMultiStream(),
                                  _pdfb->GetScratch()));
#else
        olMemTo(EH_Get, pstWrapped = new(_pdfb->GetMalloc())
                CTransactedStream(pdfnName, psstNew->GetLuid(), _df,
                                  _pdfb->GetScratch()));
#endif                                  
        olChkTo(EH_pstWrapped, pstWrapped->Init(psstNew));
        *ppsstStream = pstWrapped;
        _ppubdf->AddXSMember(this, pstWrapped, pstWrapped->GetLuid());
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetStream => %p\n",
                *ppsstStream));
    return S_OK;

EH_pstWrapped:
    delete pstWrapped;
EH_Get:
    psstNew->Release();
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\wdfxact.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdfxact.cxx
//
//  Contents:   CWrappedDocFile transactioning methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <sstream.hxx>
#include <tstream.hxx>
#include <dfdeb.hxx>

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::BeginCommit, public
//
//  Synopsis:   Allocates commit resources for two-phase commit
//
//  Arguments:  [dwFlags] - Flags
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::BeginCommit(DWORD const dwFlags)
{
    SCODE sc;
#ifdef INDINST
    DFSIGNATURE sigNew;
#endif

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::BeginCommit(%lX)\n",
                dwFlags));

    olAssert(_pdfBase != NULL);
    olAssert(P_TRANSACTED(_df));

#if DBG == 1
    if (!HaveResource(DBR_XSCOMMITS, 1))
        olErr(EH_Err, STG_E_ABNORMALAPIEXIT);
#endif

    _fBeginCommit = TRUE;
#ifdef INDINST
    _ppubdf->GetNewSignature(&sigNew);
    olChk(_pdfBase->BeginCommitFromChild(_ulChanged, NULL,
                                         _sigBase, sigNew, dwFlags, _ppubdf));
    // INDINST - Ownership of dirty and changed?
    if (P_INDEPENDENT(_df) && _pdfParent)
        olChkTo(EH_Begin,
                _pdfParent->BeginCommitFromChild(_ulChanged,
                                                 _pdfBase, _sigBase, sigNew,
                                                 dwFlags, _ppubdf));
    _sigBaseOld = _sigBase;
    _sigCombinedOld = _sigCombined;
    _sigBase = _sigCombined = sigNew;
#else
    olChk(_pdfBase->BeginCommitFromChild(_ulChanged, dwFlags, this));
#endif
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::BeginCommit\n"));
    return S_OK;

#ifdef INDINST
EH_Begin:
    _pdfBase->EndCommitFromChild(DF_ABORT);
#endif
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::EndCommit, public
//
//  Synopsis:   Performs actual commit/abort for two-phase commit
//
//  Arguments:  [df] - COMMIT/ABORT
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CWrappedDocFile::EndCommit(DFLAGS const df)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::EndCommit(%X)\n",
                df));

    olAssert(P_TRANSACTED(_df));

    if (!_fBeginCommit)
        return;
    _fBeginCommit = FALSE;

#if DBG == 1
    if (P_COMMIT(df))
        ModifyResLimit(DBR_XSCOMMITS, 1);
#endif

    _pdfBase->EndCommitFromChild(df, this);
#ifdef INDINST
    if (P_INDEPENDENT(_df) && _pdfParent)
        olVerSucc(_pdfParent->EndCommitFromChild(df));
#endif

    if (P_COMMIT(df))
    {
        // These are nulled because the memory should be gone
        _ulChanged.Unlink();
        SetClean();
    }
    else
    {
#ifdef INDINST
        _sigBase = _sigBaseOld;
        _sigCombined = _sigCombinedOld;
#endif
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::EndCommit\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::Revert, public
//
//  Synopsis:   Transaction level has requested revert
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CWrappedDocFile::Revert(void)
{
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile %p::Revert()\n", this));
    for (pud = _ulChanged.GetTail(); pud; pud = pud->GetPrev())
        RevertUpdate(pud);
    _ulChanged.Empty();
    olVerSucc(SetInitialState(BP_TO_P(PDocFile *, _pdfBase)));
    SetClean();

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::Revert\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::BeginCommitFromChild, public
//
//  Synopsis:   Start two-phase commit, requested by child
//
//  Arguments:  [ulChanged] - Change list
//              [dwFlags] - Flags controlling commit
//              [pdfChild] - Child object
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::BeginCommitFromChild(CUpdateList &ulChanged,
                                            DWORD const dwFlags,
                                            CWrappedDocFile *pdfChild)
{
    CUpdate *pud, *pudNext;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::BeginCommitFromChild:%p("
                "%p, %lX, %p)\n", this, ulChanged.GetHead(), dwFlags,
                pdfChild));

    UNREFERENCED_PARM(pdfChild);

    olAssert(P_TRANSACTED(_df));
    olAssert(_tssDeletedHolder.GetHead() == NULL);

    _ulChangedHolder = ulChanged;
    _ulChangedOld = _ulChanged;

    for (pud = ulChanged.GetHead(); pud; pud = pudNext)
    {
        if (pud->IsRename())
            _ppubdf->RenameChild(pud->GetOriginalName(), GetName(),
                                 pud->GetCurrentName());
        else if (pud->IsDelete())
        {
            PTSetMember *ptsm;
            if ((ptsm = _ppubdf->FindXSMember(pud->GetOriginalName(),
                                              GetName())) != NULL)
            {
                olAssert(ptsm->GetName() != DF_NOLUID &&
                         aMsg("Can't destroy NOLUID XSM"));
                // Take a reference because RemoveXSMember
                // will call Release
                ptsm->AddRef();
                _ppubdf->RemoveXSMember(ptsm);
                _tssDeletedHolder.AddMember(ptsm);
            }
        }
        else
            if (pud->IsCreate())
                olVerSucc(CreateFromUpdate(pud, this,
                                           DF_WRITE | DF_NOUPDATE |
                                           DF_TRANSACTED));
        pudNext = pud->GetNext();
        _ulChanged.Append(pud);
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::BeginCommitFromChild\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::EndCommitFromChild
//
//  Synopsis:   Ends two-phase commit, requested by child
//
//  Arguments:  [df] - COMMIT/ABORT
//              [pdfChild] - Child object
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CWrappedDocFile::EndCommitFromChild(DFLAGS const df,
                                         CWrappedDocFile *pdfChild)
{
    PTSetMember *ptsm;
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::EndCommitFromChild:%p("
                "%X, %p)\n", this, df, pdfChild));

    olAssert(P_TRANSACTED(_df));

    if (!P_COMMIT(df))
    {
        // Restore our update list
        _ulChanged = _ulChangedOld;

        // Unconcat _ulChanged and ulChanged
        if (_ulChanged.GetTail())
            _ulChanged.GetTail()->SetNext(NULL);
        if (_ulChangedHolder.GetHead())
            _ulChangedHolder.GetHead()->SetPrev(NULL);

        // Back out updates
        for (pud = _ulChangedHolder.GetTail(); pud; pud = pud->GetPrev())
            if (pud->IsCreate())
            {
                // We need to do two things:
                //
                // Break any SetBase links that might have been created
                //
                // Return newly created objects to the creators so
                // that they can be returned to the preallocation
                // pool

                if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                    STGTY_STORAGE)
                {
                    CWrappedDocFile *pwdf = (CWrappedDocFile *)pud->GetXSM();
                    CWrappedDocFile *pwdfBase;

                    if (pwdf != NULL &&
                        (pwdfBase = (CWrappedDocFile *)pwdf->GetBase()) !=
                        NULL)
                    {
                        // Increase ref count because SetBase will release
                        pwdfBase->AddRef();
                        pwdf->SetBase(NULL);
                        ReturnDocFile(pwdfBase);
                    }
                }
                else
                {
                    CTransactedStream *ptstm = (CTransactedStream *)pud->
                        GetXSM();
                    CTransactedStream *ptstmBase;

                    olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
                             == STGTY_STREAM);
                    if (ptstm != NULL &&
                        (ptstmBase = (CTransactedStream *)ptstm->GetBase()) !=
                        NULL)
                    {
                        // Increase ref count because SetBase will release
                        ptstmBase->AddRef();
                        ptstm->SetBase(NULL);
                        ReturnStream(ptstmBase);
                    }
                }
            }
            else if (pud->IsDelete())
            {
                // We use GetName() as the tree because we know that
                // only immediate children can show up in delete records
                if ((ptsm = _tssDeletedHolder.FindName(pud->GetOriginalName(),
                                                       GetName())) != NULL)
                {
                    _tssDeletedHolder.RemoveMember(ptsm);
                    _ppubdf->InsertXSMember(ptsm);
                    // Release the reference we took in BeginCommitFromChild
                    // because InsertXSMember takes a reference
                    ptsm->Release();
                }
            }
            else if (pud->IsRename())
            {
                // Roll back renames
                olAssert(_ppubdf->FindXSMember(pud->GetOriginalName(),
                                               GetName()) == NULL &&
                         aMsg("Abort commit rename precondition"));

                _ppubdf->RenameChild(pud->GetCurrentName(), GetName(),
                                     pud->GetOriginalName());

                olAssert(_ppubdf->FindXSMember(pud->GetCurrentName(),
                                               GetName()) == NULL &&
                         aMsg("Abort commit rename postcondition"));
            }
    }
    else
    {
        // Finalize creations
        for (pud = _ulChangedHolder.GetHead(); pud; pud = pud->GetNext())
            if (pud->IsCreate())
            {
                // Since the object pointed to by GetBase is at our level,
                // we know it is transacted so we can safely cast to
                // PTSetMember
                if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                    STGTY_STORAGE)
                {
                    ptsm = (CWrappedDocFile *)
                        ((CWrappedDocFile *)pud->GetXSM())->GetBase();
                }
                else
                {
                    olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
                             == STGTY_STREAM);
                    ptsm = (CTransactedStream *)
                        ((CTransactedStream *)pud->GetXSM())->GetBase();
                }
                pud->SetXSM(ptsm);
            }

        // Finalize deletions
        while (ptsm = _tssDeletedHolder.GetHead())
        {
            olAssert(ptsm->GetName() != DF_NOLUID &&
                     aMsg("Can't destroy NOLUID XSM"));
            _ppubdf->DestroyChild(ptsm->GetName());
            _tssDeletedHolder.RemoveMember(ptsm);
            ptsm->Release();
        }

        // Pick up state information
        TIME_T tm;

        if (pdfChild->GetDirty() & DIRTY_CREATETIME)
        {
            olVerSucc(pdfChild->GetTime(WT_CREATION, &tm));
            olVerSucc(SetTime(WT_CREATION, tm));
        }
        if (pdfChild->GetDirty() & DIRTY_MODIFYTIME)
        {
            olVerSucc(pdfChild->GetTime(WT_MODIFICATION, &tm));
            olVerSucc(SetTime(WT_MODIFICATION, tm));
        }
        if (pdfChild->GetDirty() & DIRTY_ACCESSTIME)
        {
            olVerSucc(pdfChild->GetTime(WT_ACCESS, &tm));
            olVerSucc(SetTime(WT_ACCESS, tm));
        }
        if (pdfChild->GetDirty() & DIRTY_CLASS)
        {
            CLSID cls;
            
            olVerSucc(pdfChild->GetClass(&cls));
            olVerSucc(SetClass(cls));
        }
        if (pdfChild->GetDirty() & DIRTY_STATEBITS)
        {
            DWORD dwState;
            
            olVerSucc(pdfChild->GetStateBits(&dwState));
            olVerSucc(SetStateBits(dwState, 0xffffffff));
        }
    }

    // Forget temporary commit lists
    _ulChangedOld.Unlink();
    _ulChangedHolder.Unlink();

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::EndCommitFromChild\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetSignature, public
//
//  Synopsis:   Returns signature
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef INDINST
void CWrappedDocFile::GetSignature(DFSIGNATURE *psig)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetSignature()\n"));
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetSignature => %ld\n",
                _sigCombined));
    *psig = _sigCombined;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetSignature, public
//
//  Synopsis:   Sets the signature
//
//  Arguments:  [sig] - Signature
//
//  Returns:    Appropriate status code
//
//  History:    04-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef INDINST
void CWrappedDocFile::SetSignature(DFSIGNATURE sig)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetSignature(%ld)\n", sig));
    _sigCombined = sig;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetSignature\n"));
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetBase, public
//
//  Synopsis:   Sets Base pointer
//
//  Arguments:  [pdf] - New base
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::SetBase(PDocFile *pdf)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetBase(%p)\n", pdf));
    olAssert(_pdfBase == NULL || pdf == NULL);
    if (_pdfBase)
        _pdfBase->Release();
    if (pdf)
    {
        olChk(pdf->CopyTimesFrom(this));
        olChk(pdf->SetClass(_clsid));
        olChk(pdf->SetStateBits(_grfStateBits, 0xffffffff));
    }
    _pdfBase = P_TO_BP(CBasedDocFilePtr, pdf);
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetBase\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CopySelf, public
//
//  Synopsis:   Duplicates this object
//
//  Arguments:  [ptsm] - New object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [*pstm] holds pointer to new object if successful
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef INDINST
SCODE CWrappedDocFile::CopySelf(PTSetMember **pptsm)
{
    CDocFile *pdfCopy;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CopySelf()\n"));
    olChk(_ppubdf->GetScratchDocFile(&pdfCopy));
    olChkTo(EH_pdfCopy,
            CopyDocFileToDocFile(this, pdfCopy, TRUE, FALSE, TRUE, NULL));
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CopySelf => %p\n",
                pdfCopy));
    *pptsm = pdfCopy;
    return S_OK;

EH_pdfCopy:
    pdfCopy->Destroy();
EH_Err:
    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetCommitInfo, public
//
//  Synopsis:   Returns space accounting information for commits
//
//  Arguments:  [pulRet1] - Return for number of new entries
//              [pulRet2] - Return for number of deleted entries
//
//  Modifies:   [pulRet1]
//              [pulRet2]
//
//  History:    07-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
void CWrappedDocFile::GetCommitInfo(ULONGLONG *pulRet1, ULONGLONG *pulRet2)
#else
void CWrappedDocFile::GetCommitInfo(ULONG *pulRet1, ULONG *pulRet2)
#endif
{
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetCommitInfo(%p, %p)\n",
                pulRet1, pulRet2));
    *pulRet1 = 0;
    *pulRet2 = 0;
    for (pud = _ulChanged.GetHead(); pud; pud = pud->GetNext())
        if (pud->IsCreate())
            (*pulRet1)++;
        else if (pud->IsDelete())
            (*pulRet2)++;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetCommitInfo => %Lu, %Lu\n",
                *pulRet1, *pulRet2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\docfile\wdocfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdocfile.cxx
//
//  Contents:   Implementation of CWrappedDocFile methods for DocFiles
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CWrappedDocFile, public
//
//  Synopsis:   Empty object constructor
//
//  Arguments:  [pdfn] - Name
//              [dl] - LUID
//              [df] - Transactioning flags
//              [dwType] - Type of object
//              [pdfb] - Basis
//              [ppubdf] - Public docfile
//
//  History:    30-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

CWrappedDocFile::CWrappedDocFile(CDfName const *pdfn,
                                 DFLUID dl,
                                 DFLAGS const df,
                                 CDFBasis *pdfb,
                                 CPubDocFile *ppubdf)
        : PTSetMember(pdfn, STGTY_STORAGE),
          PDocFile(dl),
          _pdfb(P_TO_BP(CBasedDFBasisPtr, pdfb))
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CWrappedDocFile:%p("
                "%ws, %lu, %X, %p, %p)\n", this, pdfn->GetBuffer(),
                dl, df, pdfb, ppubdf));

    _df = df;
    _fBeginCommit = FALSE;
    _cReferences = 0;
    _pdfParent = NULL;
    _ppubdf = P_TO_BP(CBasedPubDocFilePtr, ppubdf);
    _fDirty = 0;
    _pdfBase = NULL;
    PBasicEntry::_sig = CWRAPPEDDOCFILE_SIG;
    PTSetMember::_sig = CWRAPPEDDOCFILE_SIG;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CWrappedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::Init, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdfBase] - Base DocFile
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::Init(PDocFile *pdfBase)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CWrappedDocFile:%p(%p)\n",
                this, pdfBase));

    olChk(SetInitialState(pdfBase));
    _pdfBase = P_TO_BP(CBasedDocFilePtr, pdfBase);
    AddRef();
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CWrappedDocFile\n"));
    // Fall through
EH_Err:
    return sc;
}


#ifdef COORD
//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::InitPub, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [ppubdf] - Enclosing CPubDocFile
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::InitPub(CPubDocFile *ppubdf)
{
    _ppubdf = P_TO_BP(CBasedPubDocFilePtr, ppubdf);
    return S_OK;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::~CWrappedDocFile, public
//
//  Synopsis:   Destructor
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

CWrappedDocFile::~CWrappedDocFile(void)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::~CWrappedDocFile()\n"));
    olAssert(_cReferences == 0);
    PBasicEntry::_sig = CWRAPPEDDOCFILE_SIGDEL;
    PTSetMember::_sig = CWRAPPEDDOCFILE_SIGDEL;
#ifdef INDINST
    if (P_INDEPENDENT(_df))
        ((CDocFile *)_pdfBase)->Destroy();
    else
#endif
        if (_pdfBase)
            _pdfBase->Release();
    // We don't want SetInitialState in Revert to actually refer to the
    // base because this object is dying and we shouldn't communicate
    // with out base except for the above Release
    _pdfBase = NULL;
    CWrappedDocFile::Revert();
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::~CWrappedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CreateDocFile, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pdfnName] - Name of DocFile
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry
//              [ppdfDocFile] - DocFile pointer return
//
//  Returns:    Appropriate error code
//
//  Modifies:   [*ppdfDocFile] holds DocFile pointer if successful
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::CreateDocFile(CDfName const *pdfnName,
                                     DFLAGS const df,
                                     DFLUID dlSet,
                                     PDocFile **ppdfDocFile)
{
    CWrappedDocFile *pdfWrapped;
    SEntryBuffer eb;
    SCODE sc;
    CUpdate *pud = NULL;
    CDFBasis *pdfb = BP_TO_P(CDFBasis *, _pdfb);

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CreateDocFile:%p("
               "%ws, %X, %lu, %p, %p)\n", this, pdfnName, df, dlSet,
                ppdfDocFile));

    if (SUCCEEDED(IsEntry(pdfnName, &eb)))
        olErr(EH_Err, STG_E_FILEALREADYEXISTS);

    olAssert(P_TRANSACTED(_df));

    if (dlSet == DF_NOLUID)
        dlSet = CWrappedDocFile::GetNewLuid(_pdfb->GetMalloc());

    pdfWrapped = new (pdfb)
        CWrappedDocFile(pdfnName, dlSet, _df,
                        pdfb, BP_TO_P(CPubDocFile *, _ppubdf));
    olAssert(pdfWrapped != NULL && aMsg("Reserved DocFile not found"));

    if (!P_NOUPDATE(df))
    {
        olMemTo(EH_pdfWrapped,
                (pud = _ulChanged.Add(pdfb->GetMalloc(),
                                      pdfnName, NULL, dlSet,
                                      STGTY_STORAGE, pdfWrapped)));
    }
    olChkTo(EH_pud, pdfWrapped->Init(NULL));
    _ppubdf->AddXSMember(this, pdfWrapped, dlSet);
    *ppdfDocFile = pdfWrapped;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CreateDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

 EH_pud:
    if (pud)
        _ulChanged.Delete(pud);
 EH_pdfWrapped:
    pdfWrapped->ReturnToReserve(pdfb);
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetDocFile, public
//
//  Synopsis:   Instantiates or converts an existing stream to a
//              DocFile
//
//  Arguments:  [pdfnName] - Name of stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppdfDocFile] - Pointer to return new object
//
//  Returns:    Appropriate error code
//
//  Modifies:   [*ppdfDocFile] holds DocFile pointer if successful
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetDocFile(CDfName const *pdfnName,
                                  DFLAGS const df,
                                  PDocFile **ppdfDocFile)
{
    PDocFile *pdfNew;
    PTSetMember *ptsm;
    CWrappedDocFile *pdfWrapped;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n", this, pdfnName, df, ppdfDocFile));

    olAssert(P_TRANSACTED(_df));

    //  Look for this name in this level transaction set

    if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
    {
        if (ptsm->ObjectType() != STGTY_STORAGE)
            olErr(EH_Err, STG_E_FILENOTFOUND);

        ptsm->AddRef();
        *ppdfDocFile = (CWrappedDocFile *)ptsm;
    }
    else if (_pdfBase == NULL ||
             _ulChanged.IsEntry(pdfnName, NULL) == UIE_ORIGINAL)
    {
        // named entry has been renamed or deleted
        // (we can't have a rename or delete without a base)

        olErr(EH_Err, STG_E_FILENOTFOUND);
    }
    else
    {
	CDfName const *pdfnRealName = pdfnName;
	CUpdate *pud;
	
	if (_ulChanged.IsEntry(pdfnName, &pud) == UIE_CURRENT &&
            pud->IsRename())
        {
	    pdfnRealName = pud->GetCurrentName();
            // We don't have to worry about picking up creates
            // because any create would have an XSM that would
            // be detected above
            olVerify(_ulChanged.FindBase(pud, &pdfnRealName) == NULL);
        }

	olAssert(_pdfBase != NULL);
	olChk(_pdfBase->GetDocFile(pdfnRealName, df, &pdfNew));
        olAssert(pdfNew->GetLuid() != DF_NOLUID &&
                 aMsg("Docfile id is DF_NOLUID!"));

        CDFBasis *pdfb;
        pdfb = BP_TO_P(CDFBasis *, _pdfb);
        
        olMemTo(EH_Get, pdfWrapped = new(pdfb->GetMalloc())
                CWrappedDocFile(pdfnName, pdfNew->GetLuid(),
                                _df, pdfb, BP_TO_P(CPubDocFile *, _ppubdf)));
        olChkTo(EH_pdfWrapped, pdfWrapped->Init(pdfNew));
        _ppubdf->AddXSMember(this, pdfWrapped, pdfWrapped->GetLuid());
        *ppdfDocFile = pdfWrapped;
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdfWrapped:
    delete pdfWrapped;
EH_Get:
    pdfNew->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::IsEntry, public
//
//  Synopsis:   Determines whether the given object is in the DocFile
//              or not
//
//  Arguments:  [pdfnName] - Object name
//              [peb] - Entry buffer to fill in
//
//  Returns:    Appropriate error code
//
//  Modifies:   [peb]
//
//  History:    15-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::IsEntry(CDfName const *pdfnName,
                               SEntryBuffer *peb)
{
    CUpdate *pud;
    SCODE sc = S_OK;
    UlIsEntry uie;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::IsEntry(%ws, %p)\n",
                pdfnName, peb));

    //  Look in XSM's (for open/created things)

    PTSetMember *ptsm;
    if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
    {
        peb->luid = ptsm->GetName();
        peb->dwType = ptsm->ObjectType();
    }
    else
    {
        uie = _ulChanged.IsEntry(pdfnName, &pud);
        if (uie == UIE_CURRENT)
        {
            peb->luid = pud->GetLUID();
            peb->dwType = pud->GetFlags() & ULF_TYPEFLAGS;
        }
        else if (uie == UIE_ORIGINAL || _pdfBase == NULL)
        {
            sc = STG_E_FILENOTFOUND;
        }
        else
        {
            sc = _pdfBase->IsEntry(pdfnName, peb);
        }
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::IsEntry => %lu, %lu, %lu\n",
                sc, peb->luid, peb->dwType));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::RenameEntry, public
//
//  Synopsis:   Renames an element of the DocFile
//
//  Arguments:  [pdfnName] - Current name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate error code
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::RenameEntry(CDfName const *pdfnName,
                                   CDfName const *pdfnNewName)
{
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::RenameEntry(%ws, %ws)\n",
                pdfnName, pdfnNewName));

    olAssert(P_TRANSACTED(_df));

    if (SUCCEEDED(sc = IsEntry(pdfnNewName, &eb)))
        olErr(EH_Err, STG_E_ACCESSDENIED)
    else if (sc != STG_E_FILENOTFOUND)
        olErr(EH_Err, sc);

    olChk(IsEntry(pdfnName, &eb));
    olMem(_ulChanged.Add(_pdfb->GetMalloc(),
                         pdfnNewName, pdfnName, eb.luid, eb.dwType, NULL));

    _ppubdf->RenameChild(pdfnName, GetName(), pdfnNewName);

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::RenameEntry\n"));
    return S_OK;

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently destroys a child
//
//  Arguments:  [pdfnName] - Name
//              [fClean] - If true, remove create entry from update list
//                         rather than appending a delete update entry
//
//  Returns:    Appropriate error code
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::DestroyEntry(CDfName const *pdfnName,
                                    BOOL fClean)
{
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));

    olAssert(P_TRANSACTED(_df));

    if (fClean)
    {
        CUpdate *pud = NULL;
        UlIsEntry uie;

        uie = _ulChanged.IsEntry(pdfnName, &pud);
        olAssert(uie == UIE_CURRENT);
        RevertUpdate(pud);
        _ulChanged.Delete(pud);
    }
    else
    {
        PTSetMember *ptsm;

        olChk(IsEntry(pdfnName, &eb));
        olMem(_ulChanged.Add(_pdfb->GetMalloc(),
                             NULL, pdfnName, eb.luid, eb.dwType, NULL));

        if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
        {
            olAssert(ptsm->GetName() != DF_NOLUID &&
                     aMsg("Can't destroy NOLUID XSM"));
            _ppubdf->DestroyChild(ptsm->GetName());
        }
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::DestroyEntry\n"));
    return S_OK;

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetTime, public
//
//  Synopsis:   Gets a time
//
//  Arguments:  [wt] - Which time
//              [ptm] - Time return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ptm]
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    _tten.GetTime(wt, ptm);
    return S_OK;
}
//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetAllTimes, public
//
//  Synopsis:   Gets all times
//
//  Arguments:  [patm] - Access Time
//              [pmtm] - Modification Time
//		[pctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:   [atm], [mtm], [ctm]
//
//  History:    26-May-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetAllTimes(TIME_T *patm, TIME_T *pmtm, TIME_T *pctm)
{
    _tten.GetAllTimes(patm, pmtm, pctm);
    return S_OK;
}
//+--------------------------------------------------------------
//
//  Member:      CWrappedDocFile::SetAllTimes, public
//
//  Synopsis:   Sets all time values
//
//  Arguments:  [atm] - Access Time
//              [mtm] - Modification Time
//				[ctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:  	
//
//  History:    22-Nov-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::SetAllTimes(TIME_T atm, TIME_T mtm, TIME_T ctm)
{
    SetDirty((1 << WT_CREATION) | (1 << WT_MODIFICATION) |(1 << WT_ACCESS));
	_tten.SetAllTimes(atm, mtm, ctm);
	return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetTime, public
//
//  Synopsis:   Sets a time
//
//  Arguments:  [wt] - Which time
//              [tm] - New time
//
//  Returns:    Appropriate status code
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::SetTime(WHICHTIME wt, TIME_T tm)
{
    olAssert((1 << WT_CREATION) == DIRTY_CREATETIME);
    olAssert((1 << WT_MODIFICATION) == DIRTY_MODIFYTIME);
    olAssert((1 << WT_ACCESS) == DIRTY_ACCESSTIME);
    SetDirty(1 << wt);
    _tten.SetTime(wt, tm);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetClass, public
//
//  Synopsis:   Gets the class ID
//
//  Arguments:  [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::GetClass(CLSID *pclsid)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetClass:%p(%p)\n",
                this, pclsid));
    *pclsid = _clsid;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetClass\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - New class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::SetClass(REFCLSID clsid)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetClass:%p(?)\n", this));
    _clsid = clsid;
    SetDirty(DIRTY_CLASS);
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetClass\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetStateBits, public
//
//  Synopsis:   Gets the state bits
//
//  Arguments:  [pgrfStateBits] - State bits return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pgrfStateBits]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetStateBits:%p(%p)\n",
                this, pgrfStateBits));
    *pgrfStateBits = _grfStateBits;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetStateBits\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - Bits to set
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetStateBits:%p("
                "%lu, %lu)\n", this, grfStateBits, grfMask));
    _grfStateBits = (_grfStateBits & ~grfMask) | (grfStateBits & grfMask);
    SetDirty(DIRTY_STATEBITS);
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetStateBits\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\astgconn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:	astgconn.cxx
//
//  Contents:	
//
//  Classes:	
//
//  Functions:	
//
//  History:	03-Apr-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "exphead.cxx"
#pragma hdrstop

#include "astgconn.hxx"
#include <filllkb.hxx>
#include <asyncerr.hxx>


SCODE CAsyncConnection::Init(IConnectionPointContainer *pCPC,
                             CAsyncConnection *pacParent)
{
    SCODE sc = S_OK;
    CConnectionPoint *pcpoint;
    olAssert(_pdacp == NULL);

    if (pacParent)
        _dwAsyncFlags = pacParent->_dwAsyncFlags;
    
    olMem(pcpoint = new CConnectionPoint());
    olChk(pcpoint->Init());
    if ((pacParent) && (_dwAsyncFlags & ASYNC_MODE_COMPATIBILITY))
    {
        pcpoint->SetParent(pacParent->_pdacp);
    }
    else
    {
        pcpoint->SetParent(NULL);
    }

    _pCPC = pCPC;
    _pdacp = pcpoint;
EH_Err:
    return sc;
}


SCODE CAsyncConnection::InitClone(IConnectionPointContainer *pCPC,
                                  CAsyncConnection *pac)
{
    SCODE sc = S_OK;
    CConnectionPoint *pcpoint;
    olAssert(pac != NULL);

    _dwAsyncFlags = pac->_dwAsyncFlags;
    
    olMem(pcpoint = new CConnectionPoint());
    olChk(pcpoint->Init());
    if (_dwAsyncFlags & ASYNC_MODE_COMPATIBILITY)
    {
        IDocfileAsyncConnectionPoint *pdacp;
        if (FAILED(sc = pac->_pdacp->GetParent(&pdacp)))
        {
            delete pcpoint;
            return sc;
        }
        pcpoint->SetParent(pdacp);
    }
    else
    {
        pcpoint->SetParent(NULL);
    }

    _pCPC = pCPC;
    _pdacp = pcpoint;
EH_Err:
    return sc;
}

SCODE CAsyncConnection::InitMarshal(IConnectionPointContainer *pCPC,
                                    DWORD dwAsyncFlags,
                                    IDocfileAsyncConnectionPoint *pdacp)
{
    SCODE sc = S_OK;
    _dwAsyncFlags = dwAsyncFlags;
    
    _pCPC = pCPC;
    _pdacp = pdacp;
    if (_pdacp)
        _pdacp->AddRef();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::~CAsyncConnection, public
//
//  Synopsis:	Destructor
//
//  Returns:	Appropriate status code
//
//  History:	03-Apr-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

CAsyncConnection::~CAsyncConnection()
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnection::~CAsyncConnection:%p()\n", this));
    //Note:  _pdacp must be released outside of the tree mutex, which
    //  means we need to extract the pointer and release it elsewhere.
#if 0    
    if (_pdacp != NULL)
    {
        _pdacp->Release();
    }
#endif    
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnection::~CAsyncConnection\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::QueryInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	01-Jan-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    olDebugOut((DEB_TRACE,
                  "In  CAsyncConnection::QueryInterface:%p()\n",
                  this));

    *ppvObj = NULL;

    if ((IsEqualIID(iid, IID_IUnknown)) ||
	(IsEqualIID(iid, IID_IConnectionPoint)))
    {
        *ppvObj = (IConnectionPoint *)this;
        CAsyncConnection::AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    olDebugOut((DEB_TRACE, "Out CAsyncConnection::QueryInterface\n"));
    return ResultFromScode(sc);
}



//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::AddRef, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAsyncConnection::AddRef(void)
{
    ULONG ulRet;
    olDebugOut((DEB_TRACE,
                  "In  CAsyncConnection::AddRef:%p()\n",
                  this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    
    olDebugOut((DEB_TRACE, "Out CAsyncConnection::AddRef\n"));
    return ulRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::Release, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAsyncConnection::Release(void)
{
    LONG lRet;
    olDebugOut((DEB_TRACE,
                  "In  CAsyncConnection::Release:%p()\n",
                  this));

    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);

    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
    { 
        olAssert((lRet > 0) && "Connection point released too many times.");
        lRet = 0;
    
    }
    olDebugOut((DEB_TRACE, "Out CAsyncConnection::Release\n"));
    return (ULONG)lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::Notify,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	14-Jan-96	SusiA	Created
//              27-Feb-96       SusiA   Moved from Async wrappers 
//
//----------------------------------------------------------------------------
SCODE CAsyncConnection::Notify(SCODE scFailure,
                               ILockBytes *pilb,
                               CPerContext *ppc,
                               CSafeSem *pss)
{
    SCODE sc = S_OK;
    BOOL fAccurate = (scFailure == E_PENDING);
    IFillInfo *pfi = ppc->GetFillInfo();
    ULONG ulWaterMark;
    ULONG ulFailurePoint;

    HANDLE hNotifyEvent;

    if (pfi != NULL)
    {
        pfi->GetFailureInfo(&ulWaterMark,
                            &ulFailurePoint);

        pss->Release();
        
        while (((sc = _pdacp->NotifySinks(ulWaterMark,
                                          ulFailurePoint,
                                          fAccurate,
                                          STG_S_MONITORING)) == STG_S_BLOCK) ||
               (sc == STG_S_MONITORING) ||
               // S_OK is a synonym for STG_S_MONITORING
               (sc == S_OK))
        {	
            DWORD dwFlags;

            // wait for an event to signal
            hNotifyEvent = ppc->GetNotificationEvent();
            WaitForSingleObject(hNotifyEvent, INFINITE);

            pfi->GetTerminationStatus(&dwFlags);
            // client terminated call?
            if (dwFlags == TERMINATED_ABNORMAL)
            {
                return STG_E_INCOMPLETE;
            }
            // download is complete
            else if (dwFlags == TERMINATED_NORMAL)
            {
                return S_OK;
            }
            else
            {
                //Note:  Don't overwrite the failure point we recorded
                //  before, since it may have been changed by some
                //  other thread.
                
                //Don't need to take the critical section here, since
                //we don't care about the current failure point.
                ULONG ulFailurePointCurrent;
                pfi->GetFailureInfo(&ulWaterMark,
                                     &ulFailurePointCurrent);

                // all the data is available now
                if (ulWaterMark >= ulFailurePoint)
                {
                    //We don't care what the return value is, so send
                    //STG_S_BLOCK and all sinks will have fOwner == FALSE
                    _pdacp->NotifySinks(ulWaterMark,
                                        ulFailurePoint,
                                        fAccurate,
                                        STG_S_BLOCK);
                    break;
                }
            }
        }
    }
    
    if ((sc == STG_S_RETRYNOW) ||
        (sc == STG_S_BLOCK) ||
        (sc == STG_S_MONITORING))
    {
        return S_OK;
    }
    else return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::GetConnectionInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::GetConnectionInterface(IID *pIID)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnection::GetConnectionInterface:%p()\n",
                this));

    
    *pIID = IID_IProgressNotify;
          
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::GetConnectionInterface\n"));
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::GetConnectionPointContainer, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnection::GetConnectionPointContainer:%p()\n",
                this));

    *ppCPC = _pCPC;
    _pCPC->AddRef();
    
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnection::GetConnectionPointContainer\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::EnumConnections, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::EnumConnections(
    IEnumConnections **ppEnum)
{
    olDebugOut((DEB_ITRACE, "In  CAsyncConnection::EnumConnections:%p()\n", this));
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::EnumConnections\n"));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection:: Advise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::Advise(IUnknown *pUnkSink,
                                      DWORD *pdwCookie)
{
    SCODE sc;
    IProgressNotify *ppnSink;
    
    olDebugOut((DEB_ITRACE, "In  CAsyncConnection::Advise:%p()\n", this));

    olChk(pUnkSink->QueryInterface(IID_IProgressNotify, (void **)&ppnSink));
    sc = _pdacp->AddConnection(ppnSink, pdwCookie);
    ppnSink->Release();
    
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::Advise\n"));
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::Unadvise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::Unadvise(DWORD dwCookie)
{
    SCODE sc;
    olDebugOut((DEB_ITRACE, "In  CAsyncConnection::Unadvise:%p()\n", this));
    sc = _pdacp->RemoveConnection(dwCookie);
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::Unadvise\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::EnumConnectionPoints, public
//
//  Synopsis:	Return enumerator on connection points
//
//  Arguments:	[ppEnum] -- Return pointer of enumerator
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnectionContainer::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnectionContainer::EnumConnectionPoints:%p()\n",
                this));
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnectionContainer::EnumConnectionPoints\n"));
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::FindConnectionPoint, public
//
//  Synopsis:	Return a connection point given an IID
//
//  Arguments:	[iid] -- IID to return connection point for
//              [ppCP] -- Return location for pointer
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnectionContainer::FindConnectionPoint(
    REFIID iid,
    IConnectionPoint **ppCP)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnectionContainer::FindConnectionPoint:%p()\n",
                this));

    CAsyncConnection *pcp;
    
    if (IsEqualIID(iid, IID_IProgressNotify))
    {
        pcp = &_cpoint;
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    pcp->AddRef();
    *ppCP = pcp;
    
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnectionContainer::FindConnectionPoint\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::InitConnection, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  History:	10-Apr-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CAsyncConnectionContainer::InitConnection(CAsyncConnection *pacParent)
{
    return _cpoint.Init(this, pacParent);
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::InitClone, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  History:	10-Apr-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CAsyncConnectionContainer::InitClone(CAsyncConnection *pac)
{
    return _cpoint.InitClone(this, pac);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\cntxlist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       cntxlist.cxx
//
//  Contents:   CContextList implementation
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <cntxlist.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CContextList::_Find, public
//
//  Synopsis:   Looks through the list for a matching context
//
//  Arguments:  [ctxid] - Context to look for
//
//  Returns:    Pointer to object or NULL
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CContextList_Find)
#endif

CContext *CContextList::_Find(ContextId ctxid)
{
    CBasedContextPtr pctx;

    olDebugOut((DEB_ITRACE, "In  CContextList::_Find:%p(%lu)\n", this,
                (ULONG)ctxid));
    for (pctx = _pctxHead; pctx; pctx = pctx->pctxNext)
        if (pctx->ctxid != INVALID_CONTEXT_ID &&
            pctx->ctxid == ctxid)
            break;
    olDebugOut((DEB_ITRACE, "Out CContextList::_Find\n"));
    return BP_TO_P(CContext *, pctx);
}

//+---------------------------------------------------------------------------
//
//  Member:     CContextList::Add, public
//
//  Synopsis:   Adds a context to the list
//
//  Arguments:  [pctx] - Context
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CContextList_Add)
#endif

void CContextList::Add(CContext *pctx)
{
    olDebugOut((DEB_ITRACE, "In  CContextList::Add:%p(%p)\n", this, pctx));
    pctx->pctxNext = _pctxHead;
    pctx->ctxid = GetCurrentContextId();
    _pctxHead = P_TO_BP(CBasedContextPtr, pctx);
    olDebugOut((DEB_ITRACE, "Out CContextList::Add\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CContextList::Remove, public
//
//  Synopsis:   Removes a context from the list
//
//  Arguments:  [pctx] - Context
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CContextList_Remove)
#endif

void CContextList::Remove(CContext *pctx)
{
    CBasedContextPtr *ppctx;
#if DBG == 1
    BOOL fFound = FALSE;
#endif

    olDebugOut((DEB_ITRACE, "In  CContextList::Remove:%p(%p)\n", this, pctx));
    for (ppctx = &_pctxHead; *ppctx; ppctx = &(*ppctx)->pctxNext)
        if (*ppctx == pctx)
        {
#if DBG == 1
            fFound = TRUE;
#endif
            *ppctx = pctx->pctxNext;
            break;
        }
    olAssert(fFound == TRUE);
    olDebugOut((DEB_ITRACE, "Out CContextList::Remove\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\api.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   api.cxx
//
//  Contents:   API entry points
//
//  History:    30-Jun-93   DrewB   Created
//
//----------------------------------------------------------------------------


#include "exphead.cxx"
#pragma hdrstop

#include <propapi.h>
#include <hntfsstg.hxx>
#include <dfentry.hxx>
#include <winefs.h>       // for DuplicateEncryptionInfoFile

SCODE ValidateGrfMode( DWORD grfMode, BOOL fCreateAPI );
HRESULT GetNFFTempName (const WCHAR *pwcsFileName, WCHAR *awcsTmpName);
SCODE ValidateStgOptions (STGOPTIONS * pStgOptions, DWORD stgfmt, BOOL fCreate);
inline SCODE ValidateGrfAttrs (DWORD grfAttrs, DWORD stgfmt)
{
    if (stgfmt != STGFMT_DOCFILE)
    {
        if (grfAttrs != 0)
            return STG_E_INVALIDFLAG;
    }
    else
    {
        if ((grfAttrs & ~FILE_FLAG_NO_BUFFERING) != 0)
            return STG_E_INVALIDFLAG;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfOpenStorageEx
//
//  Synopsis:   Open storage and stream objects
//
//  Arguments:  [pwcsUsersName] - pathanme of the file
//              [fCreateAPI] - create or open
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee    Created
//
//----------------------------------------------------------------------------

STDAPI DfOpenStorageEx (
            const WCHAR* pwcsUsersName,
            BOOL     fCreateAPI,         // create vs open
            DWORD    grfMode,
            DWORD    stgfmt,             // enum
            DWORD    grfAttrs,           // reserved
            STGOPTIONS *pStgOptions,
            void *   reserved,
            REFIID   riid,
            void **  ppObjectOpen)
{
    HRESULT sc = S_OK;
    DWORD dwFullPathLen;
    WCHAR awcsFullName[_MAX_PATH], *pwcsFile;

    //
    // The ANY and STORAGE formats recursivly call back through here
    // for the correct real format (DOCFILE or FILE).  We only call
    // GetFullPathName on real formats, to avoid redundant calls as we
    // recurse.
    //  This then *requires* that the ANY and STORAGE must recurse (i.e. can't
    // call NFFOpen or docfile directly) because the filename has not been
    // properly prepared.
    //
    // For STGFMT_DOCFILE, let the docfile layer handle name checking
    //
    if(STGFMT_ANY != stgfmt &&
       STGFMT_STORAGE != stgfmt &&
       STGFMT_DOCFILE != stgfmt)
    {
        dwFullPathLen = GetFullPathNameW(pwcsUsersName, _MAX_PATH,
                                         awcsFullName,&pwcsFile);

        if (dwFullPathLen == 0)
        {
            DWORD dwErr = GetLastError();

            // In some circumstances (name == " ", for instance),
            // GetFullPathNameW can return 0 and GetLastError returns 0.
            // We want to return STG_E_INVALIDNAME for these.
            if (dwErr != NOERROR)
            {
                olErr(EH_Err, Win32ErrorToScode(dwErr));
            }
            else
            {
                olErr(EH_Err, STG_E_INVALIDNAME);
            }
        }
        else if (dwFullPathLen > _MAX_PATH)
            olErr(EH_Err, STG_E_PATHNOTFOUND);
    }

    //-----------------------------------------
    //  Switch on STGFMT_
    //      STORAGE, DOCFILE, FILE, ANY
    //
    switch(stgfmt)
    {
    case STGFMT_FILE:
      {
        olChk( NFFOpen( awcsFullName, grfMode, NFFOPEN_NORMAL,
                          fCreateAPI, riid, ppObjectOpen) );

      } // case STGFMT_FILE
    break;

    case STGFMT_ANY:
      {
        DWORD stgfmt2=STGFMT_STORAGE;
        //
        // Attempting to CREATE a Storage with STGFMT_ANY is ambiguous,
        // On NTFS STGFMT_FILE could be appropriate,
        // and is therefore invalid.
        //
        if (fCreateAPI)
            olChk (STG_E_INVALIDPARAMETER);

        //
        //   If IsNffAppropriate() returns S_OK use STGFMT_FILE
        // If it returns STG_E_INVALIDFUNCTION try storage (FAT-FS or Docfile).
        // Any other Error, bubble back to the user
        //
        sc = CNtfsStorage::IsNffAppropriate( pwcsUsersName );
        if( SUCCEEDED( sc ) )
        {
            stgfmt2 = STGFMT_FILE;
        }
        else
        {
            if( STG_E_INVALIDFUNCTION == sc )
                stgfmt2 = STGFMT_STORAGE;
            else
                olChk( sc );
        }

        sc = DfOpenStorageEx (pwcsUsersName, fCreateAPI, grfMode, stgfmt2,
                                grfAttrs, pStgOptions, reserved,
                                riid, ppObjectOpen);

        olChk(sc);

      } // case STGFMT_ANY;
    break;

    case STGFMT_STORAGE:
    case STGFMT_DOCFILE:  // GetFullPathName has not yet been called.
      {
        IStorage *pstg = NULL;
        ULONG ulSectorSize = 0;

        if( fCreateAPI )
        {
            if (grfAttrs & FILE_ATTRIBUTE_TEMPORARY)  // create temp file
                pwcsUsersName = NULL;
            olChk( DfCreateDocfile (pwcsUsersName,
                NULL, grfMode, NULL,
                pStgOptions ? pStgOptions->ulSectorSize : 512,
                grfAttrs, &pstg));
        }
        else
            olChk( DfOpenDocfile (pwcsUsersName,
                    NULL,
                    NULL,
                    grfMode,
                    NULL,
                    0,
                    &ulSectorSize,
                    grfAttrs,
                    &pstg));

        if( IID_IStorage != riid )
        {
            sc = pstg->QueryInterface( riid, ppObjectOpen );
            pstg->Release();

            if (fCreateAPI && !SUCCEEDED(sc) && pwcsUsersName != NULL)
            {
                DeleteFileW (pwcsUsersName); //delete newly create file
            }
        }
        else
        {
            *ppObjectOpen = pstg;
            if (pStgOptions != NULL && !fCreateAPI)
                pStgOptions->ulSectorSize = ulSectorSize;
        }

        olChk(sc);

      }   // case STGFMT_DOCFILE
    break;

    default:
        olErr (EH_Err, STG_E_INVALIDPARAMETER);
        break;
    }

EH_Err:
    return sc;

};

//+---------------------------------------------------------------------------
//
//  Function:   StgCreateStorageEx, public
//
//  Synopsis:   Creates a storage or stream object
//
//  Arguments:  [pwcsName] - pathname of file
//              [grfMode] - open mode flags
//              [stgfmt] -  storage format
//              [grfAttrs] -  reserved
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee   Created
//
//----------------------------------------------------------------------------

STDAPI StgCreateStorageEx (const WCHAR* pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            STGOPTIONS * pStgOptions,
            void * reserved,
            REFIID riid,
            void ** ppObjectOpen)
{
    HRESULT sc = S_OK;
    WCHAR awcsTmpPath[_MAX_PATH];

    olDebugOut((DEB_TRACE, "In  StgCreateStorageEx(%ws, %p, %p, %p, %p)\n",
                pwcsName, grfMode, stgfmt, riid, ppObjectOpen));

    olChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (reserved != NULL)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

    olChk( ValidateGrfAttrs (grfAttrs, stgfmt));
    olChk( ValidateGrfMode( grfMode, TRUE ) );
    olChk( VerifyPerms( grfMode, TRUE ) );

    if (pStgOptions != NULL)
        olChk( ValidateStgOptions(pStgOptions, stgfmt, TRUE));

    if (stgfmt == STGFMT_FILE)
    {
      if (pwcsName != NULL)
      {
        olChk (ValidateNameW (pwcsName, _MAX_PATH));
      }
      else
      {
            olChk (GetNFFTempName (pwcsName, awcsTmpPath));
            pwcsName = awcsTmpPath;

            //Add the STGM_CREATE flag so we don't fail with
            //STG_E_FILEALREADYEXISTS when we see that the file already exists
            //later.
            grfMode |= STGM_CREATE;
            grfAttrs |= FILE_ATTRIBUTE_TEMPORARY;
      }
    }

    if (stgfmt == STGFMT_DOCFILE && 
        pStgOptions != NULL &&
        pStgOptions->usVersion >= 2 &&
        pStgOptions->pwcsTemplateFile != NULL)
    {
        DWORD dwAttrs = GetFileAttributes (pStgOptions->pwcsTemplateFile);

        if (dwAttrs == 0xFFFFFFFF)
            olChk (WIN32_SCODE (GetLastError()));

        if (dwAttrs & FILE_ATTRIBUTE_ENCRYPTED)
        {
            DWORD dwErr = DuplicateEncryptionInfoFile(
                pStgOptions->pwcsTemplateFile,
                pwcsName,
                grfMode & STGM_CREATE ? CREATE_ALWAYS : CREATE_NEW,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
            if (dwErr != ERROR_SUCCESS)
                olChk (WIN32_SCODE(dwErr));

            grfAttrs |= FILE_ATTRIBUTE_ENCRYPTED;
        }
    }

    olChk (DfOpenStorageEx (pwcsName, TRUE, grfMode, stgfmt, grfAttrs,
             pStgOptions, reserved, riid, ppObjectOpen));

    olDebugOut((DEB_TRACE, "Out StgCreateStorageEx => %p\n", *ppObjectOpen));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   StgOpenStorageEx
//
//  Synopsis:   Open storage and stream objects
//
//  Arguments:  [pwcsName] - pathanme of the file
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee    Created
//
//----------------------------------------------------------------------------

STDAPI StgOpenStorageEx (const WCHAR *pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            STGOPTIONS * pStgOptions,
            void * reserved,
            REFIID riid,
            void ** ppObjectOpen)
{
    HRESULT sc = S_OK;

    olDebugOut((DEB_TRACE, "In  StgOpenStorageEx(%ws, %p, %p, %p, %p)\n",
                pwcsName, grfMode, stgfmt, riid, ppObjectOpen));

    olChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (reserved != NULL)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

    olChk (ValidateNameW (pwcsName, _MAX_PATH));

    olChk( ValidateGrfAttrs (grfAttrs, stgfmt));
    olChk( ValidateGrfMode( grfMode, FALSE ) );
    olChk( VerifyPerms( grfMode, TRUE ) );

    if (pStgOptions != NULL)
        olChk( ValidateStgOptions(pStgOptions, stgfmt, FALSE));

    olChk (DfOpenStorageEx (pwcsName, FALSE, grfMode, stgfmt, grfAttrs,
             pStgOptions, reserved, riid, ppObjectOpen));


    olDebugOut((DEB_TRACE, "Out StgOpenStorageEx => %p\n", *ppObjectOpen));
EH_Err:

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateGrfMode
//
//  Synopsis:   Sanity checking for the grfMode. (all implementations)
//
//  Arguments:  [grfMode] -- grfMode to check
//              [fCreateAPI] -- Called from CreateStorage vs. OpenStorage.
//
//  Returns:    Appropriate status code
//
//  History:    30-Mar-98   BChapman    Created
//
//----------------------------------------------------------------------------


SCODE ValidateGrfMode( DWORD grfMode, BOOL fCreateAPI )
{
    HRESULT sc=S_OK;

    // If there are any invalid bits set (error)
    if( 0 != ( grfMode & ~( STGM_DIRECT           |   //         0
                            STGM_TRANSACTED       |   //    1 0000
                            STGM_SIMPLE           |   //  800 0000
                            STGM_READ             |   //         0
                            STGM_WRITE            |   //         1
                            STGM_READWRITE        |   //         2
                            STGM_SHARE_DENY_NONE  |   //        40
                            STGM_SHARE_DENY_READ  |   //        30
                            STGM_SHARE_DENY_WRITE |   //        20
                            STGM_SHARE_EXCLUSIVE  |   //        10
                            STGM_PRIORITY         |   //    4 0000
                            STGM_DELETEONRELEASE  |   //  400 0000
                            STGM_NOSCRATCH        |   //   10 0000
                            STGM_CREATE           |   //      1000
                            STGM_CONVERT          |   //    2 0000
                            STGM_FAILIFTHERE      |   //         0
                            STGM_DIRECT_SWMR      |
                            STGM_NOSNAPSHOT  ) ) )    //   20 0000
    {
        olErr( EH_Err, STG_E_INVALIDFLAG );
    }

    // If you Create for ReadOnly (error)
    if( fCreateAPI && ( ( grfMode & STGM_RDWR ) == STGM_READ ) )
        olErr( EH_Err, STG_E_INVALIDFLAG );

    // if you Open/Create for Convert And DeleteOnRelease (error)
    if( ( grfMode & ( STGM_DELETEONRELEASE | STGM_CONVERT ) )
                    == ( STGM_DELETEONRELEASE | STGM_CONVERT ) )
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    if( grfMode & STGM_SIMPLE )
    {
        if( fCreateAPI )
        {
            // If you Create Simple it must be exactly this way.
            if( grfMode != ( STGM_SIMPLE | STGM_READWRITE |
                             STGM_SHARE_EXCLUSIVE | STGM_CREATE ) )
                olErr( EH_Err, STG_E_INVALIDFLAG );
        }
        else
        {
            // If you Open Simple it must be one of these two ways.
            if( grfMode != (STGM_SIMPLE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE )
             && grfMode != (STGM_SIMPLE | STGM_SHARE_EXCLUSIVE | STGM_READ ) )
                olErr( EH_Err, STG_E_INVALIDFLAG );
        }
    }

    if( !fCreateAPI )
    {
        if (grfMode & STGM_DELETEONRELEASE)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);

        if (grfMode & (STGM_CREATE | STGM_CONVERT))
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
    }
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateStgOptions
//
//  Synopsis:   Sanity checking for the StgOptions
//
//  Arguments:  [pStgOptions] -- options to check
//              [stgfmt] -- intended storage format
//
//  Returns:    Appropriate status code
//
//  History:    30-Mar-98   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE ValidateStgOptions (STGOPTIONS * pStgOptions, DWORD stgfmt, BOOL fCreate)
{
#ifdef LARGE_DOCFILE
    HRESULT sc = S_OK;

    olChk(ValidatePtrBuffer(pStgOptions));
    if (pStgOptions->usVersion > STGOPTIONS_VERSION ||
        pStgOptions->usVersion == 0 ||
        pStgOptions->reserved != 0)

    {
        olErr (EH_Err, STG_E_INVALIDPARAMETER);
    }

    if (fCreate)
    {
        // enable large sector support only for docfiles
        if (pStgOptions->ulSectorSize != 512 && stgfmt != STGFMT_DOCFILE)
        {
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
        }

        if (pStgOptions->ulSectorSize != 512 &&
            pStgOptions->ulSectorSize != 4096)
        /*  pStgOptions->ulSectorSize != 8192 &&   */
        /*  pStgOptions->ulSectorSize != 16384 &&  */
        /*  pStgOptions->ulSectorSize != 32768)    */
        {
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
        }

        if (pStgOptions->usVersion >= 2)
        {
            if (stgfmt != STGFMT_DOCFILE)
            {
                olErr (EH_Err, STG_E_INVALIDPARAMETER);
            }
            else if (pStgOptions->pwcsTemplateFile != NULL)
                olChk (ValidatePtrBuffer (pStgOptions->pwcsTemplateFile));
        }
    }
    else
    {
        if (stgfmt != STGFMT_DOCFILE)
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
        if (pStgOptions->usVersion >= 2 && pStgOptions->pwcsTemplateFile !=NULL)
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
    }
EH_Err:
#else
    HRESULT sc = STG_E_INVALIDPARAMETER;
#endif

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member: GetNFFTempName, public
//
//  Synopsis:   returns a filename for temporary NSS files
//
//  Arguments:  [pwcsFileName] - original file name
//              [ppwcsTmpName] - output temporary name
//
//  Returns:    Appropriate status code
//
//  History:    01-Jul-97   HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT GetNFFTempName (const WCHAR *pwcsFileName, WCHAR *awcsTmpName)
{
    HRESULT sc = S_OK;
    WCHAR awcsDir[_MAX_PATH];
    WCHAR *pwcsFile = NULL;

    //
    // Create a temp file in pwcsFileName's directory
    //
    if (pwcsFileName != NULL)
    {
        if (GetFullPathNameW (pwcsFileName, _MAX_PATH, awcsDir, &pwcsFile) == 0)
        {
            const DWORD dwErr = GetLastError();

            //In some circumstances (name == " ", for instance),
            // GetFullPathNameW can return 0 and GetLastError returns 0.
            // We want to return STG_E_INVALIDNAME for these.

            olErr(EH_Err, (dwErr != NOERROR) ? Win32ErrorToScode(dwErr) :
                                                 STG_E_INVALIDNAME);
        }
        else if (pwcsFile) *pwcsFile = L'\0';
    }
    else
    {
        DWORD cch;
        // Create a temp file for StgCreateDocfile (NULL name)
        //
        // try %tmp%, %temp%
        cch = GetTempPath(_MAX_PATH, awcsDir);
        if(0 == cch || cch > _MAX_PATH)
        {
            // finally use current directory
            awcsDir[0] = L'.';
            awcsDir[1] = L'\0';
        }
    }

    if (GetTempFileNameW (awcsDir, TEMPFILE_PREFIX, 0, awcsTmpName)==FALSE)
        olErr (EH_Err, Win32ErrorToScode(GetLastError()));

EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\dfguid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	dfguid.cxx
//
//  Contents:	GUID definitions for useful GUIDS
//
//  History:	16-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <initguid.h>

#ifdef CODESEGMENTS
#pragma code_seg("Marshal_TEXT")
#endif

DEFINE_OLEGUID(CLSID_DfMarshal,			0x0000030b, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\context.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       context.cxx
//
//  Contents:   CPerContext implementation
//
//  History:    14-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <lock.hxx>

//+--------------------------------------------------------------
//
//  Member:     CPerContext::~CPerContext, public
//
//  Synopsis:   Releases internal objects
//
//  History:    14-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CPerContext_1CPerContext)
#endif

CPerContext::~CPerContext(void)
{
#ifndef ASYNC
    //In the ASYNC case, the Close() happens in the Release method.
    if (_plkbBase != NULL)
        Close();
#endif
    if (_pgc)
    {
        _pgc->Remove(this);
        _pgc->Release();
    }

#ifdef ASYNC
    if (_hNotificationEvent != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hNotificationEvent);
        _hNotificationEvent = INVALID_HANDLE_VALUE;
    }
#endif    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPerContext::Close, public
//
//  Synopsis:   Closes the ILockBytes for this context
//
//  History:    09-Apr-93       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CPerContext_Close)
#endif

void CPerContext::Close(void)
{
    if (_ulOpenLock && _pgc)
        ReleaseOpen(_plkbOriginal, _pgc->GetOpenLockFlags(), _ulOpenLock);
    _plkbBase->Release();
    _pfstDirty->Release();
    _plkbOriginal->Release();
    _plkbBase = NULL;
    _pfstDirty = NULL;
    _plkbOriginal = NULL;
#ifdef ASYNC
    if (_pfi != NULL)
    {
        _pfi->Release();
        _pfi = NULL;
    }
#endif    
}

#ifdef MULTIHEAP
//+--------------------------------------------------------------
//
//  Method: CSafeMultiHeap::CSafeMultiHeap
//
//  Purpose:    allows restoration of heap with methods calling "delete this"
//
//  History:    29-Nov-95   HenryLee   Created
//
//---------------------------------------------------------------

CSafeMultiHeap::CSafeMultiHeap(CPerContext *ppc)
{
    _pSmAllocator = &g_smAllocator;
    ppc->SetAllocatorState (&_ppcPrev, _pSmAllocator);
}

//+--------------------------------------------------------------
//
//  Method: CSafeMultiHeap::~CSafeMultiHeap
//
//  Purpose:    allows restoration of heap with methods calling "delete this"
//
//  History:    29-Nov-95   HenryLee   Created
//
//---------------------------------------------------------------

CSafeMultiHeap::~CSafeMultiHeap()
{
    if (_ppcPrev != NULL)
        _ppcPrev->SetAllocatorState(NULL, _pSmAllocator);
    else
        _pSmAllocator->SetState(NULL, NULL, 0, NULL, NULL);
}
#endif // MULTIHEAP

#ifdef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CPerContext::InitNotificationEvent, public
//
//  Returns:	Appropriate status code
//
//  History:	17-Apr-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPerContext::InitNotificationEvent(ILockBytes *plkbBase)
{
    SCODE sc;
    TCHAR atcEventName[CONTEXT_MUTEX_NAME_LENGTH];

    olAssert(_pgc != NULL);

    if (_hNotificationEvent != INVALID_HANDLE_VALUE)
    {
        //Already initialized, ok to exit with no error.
        return S_OK;
    }

    if (plkbBase != NULL)
    {
        //We need to check to see if we're _really_ doing async or not.
        IFileLockBytes *pfl;
        if (SUCCEEDED(sc = plkbBase->QueryInterface(IID_IFileLockBytes,
                                                    (void **)&pfl)))
        {
            pfl->Release();
            if (((CFileStream *)plkbBase)->GetContextPointer() == NULL)
            {
                //We aren't doing async, so we don't need a notification event.
                return E_NOINTERFACE;
            }
        }
        else
            return sc;

        _pgc->GetEventName(atcEventName);
        _hNotificationEvent = CreateEventT(NULL, //No security
                                           TRUE,
                                           FALSE,
                                           atcEventName);
        if (_hNotificationEvent == NULL)
        {
            _hNotificationEvent = INVALID_HANDLE_VALUE;
            return Win32ErrorToScode(GetLastError());
        }
    }
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\dfunmfct.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dfunmfct.cxx
//
//  Contents:   Implementation of CDocfileUnmarshalFactory
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <dfunmfct.hxx>
#include <marshl.hxx>
#include <logfile.hxx>
#include <expdf.hxx>
#include <expst.hxx>
#if WIN32 >= 300
#include <omarshal.hxx>
#endif

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::new, public
//
//  Synopsis:   Overloaded allocator
//
//  Returns:    Memory block for CDocfileUnmarshalFactory instance
//
//  History:    25-Jun-93       AlexT   Created
//
//  Notes:      We only need one instance of CDocfileUnmarshalFactory.
//              We use a static memory block for that instance (so we
//              can share it).  We don't use a static object because
//              we want to avoid the static construction call when this
//              library is loaded.
//
//---------------------------------------------------------------

BYTE abCDocfileUnmarshalFactory[sizeof(CDocfileUnmarshalFactory)];

inline void *CDocfileUnmarshalFactory::operator new(size_t size)
{
    olAssert(size == sizeof(CDocfileUnmarshalFactory) &&
             aMsg("Class size mismatch"));

    return(abCDocfileUnmarshalFactory);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::delete, public
//
//  Synopsis:   Overloaded deallocator
//
//  History:    25-Jun-93       AlexT   Created
//
//  Notes:      Should never be called
//
//---------------------------------------------------------------

void CDocfileUnmarshalFactory::operator delete(void *pv)
{
    olAssert(!aMsg("CDocfileUnmarshalFactory::operator delete called!"));
}

//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject, public
//
//  Synopsis:   Returns class factory objects for CLSID_DfMarshal
//
//  Arguments:  [clsid] - Class ID of object to get
//              [riid] - IID of interface to get
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    26-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------
#ifdef WIN32
HRESULT Storage32DllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv)
#else
STDAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void FAR* FAR* ppv)
#endif // WIN32
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  DllGetClassObject(clsid, riid, %p)\n", ppv));
    TRY
    {
        olChk(ValidatePtrBuffer(ppv));
        *ppv = NULL;
        olChk(ValidateIid(riid));
#if WIN32 >= 300
        if (IsEqualCLSID(clsid, CLSID_NtHandleMarshal))
        {
            if (!IsEqualIID(riid, IID_IUnknown) &&
                !IsEqualIID(riid, IID_IClassFactory))
                olErr(EH_Err, E_NOINTERFACE);
            *ppv = (IClassFactory *) &sCNtHandleUnmarshalFactory;
        }
        else
#endif
        if (IsEqualCLSID(clsid, CLSID_DfMarshal))
        {
            if (!IsEqualIID(riid, IID_IUnknown) &&
                !IsEqualIID(riid, IID_IClassFactory))
                olErr(EH_Err, E_NOINTERFACE);
            // Multiple inits don't hurt
            *ppv = (IClassFactory *)new CDocfileUnmarshalFactory;
            olAssert(*ppv != NULL && aMsg("new CDocfileUnmarshalFactory failed!"));
        }
        else
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_TRACE, "Out DllGetClassObject => %p\n", *ppv));
 EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CDocfileUnmarshalFactory::AddRef(void)
{
    LONG lRet;

    olLog(("%p::In  CDocfileUnmarshalFactory::AddRef()\n", this));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::AddRef:%p()\n",
                this));
    lRet = _AddRef();
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::AddRef => %ld\n",
                lRet));
    olLog(("%p::Out CDocfileUnmarshalFactory::AddRef().  ret == %ld\n",
           this, lRet));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::Release, public
//
//  Synopsis:   Releases resources
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CDocfileUnmarshalFactory::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CDocfileUnmarshalFactory::Release()\n", this));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::Release:%p()\n",
                this));
    lRet = 0;
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::Release => %ld\n",
                lRet));
    olLog(("%p::Out CDocfileUnmarshalFactory::Release().  ret == %ld\n",
           this, lRet));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::QueryInterface(REFIID riid,
                                                      void **ppv)
{
    SCODE sc;

    olLog(("%p::In  CDocfileUnmarshalFactory::QueryInterface(riid, %p)\n",
           this, ppv));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::QueryInterface:%p("
                "riid, %p)\n", this, ppv));
    TRY
    {
        olChk(Validate());
        olChk(ValidateOutPtrBuffer(ppv));
        *ppv = NULL;
        olChk(ValidateIid(riid));
        if (IsEqualIID(riid, IID_IClassFactory) ||
            IsEqualIID(riid, IID_IUnknown))
        {
            _AddRef();
            *ppv = (IClassFactory *)this;
        }
        else if (IsEqualIID(riid, IID_IMarshal))
        {
            _AddRef();
            *ppv = (IMarshal *)this;
        }
        else
            olErr(EH_Err, E_NOINTERFACE);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::QueryInterface => "
                "%p\n", *ppv));
EH_Err:
    olLog(("%p::Out CDocfileUnmarshalFactory::QueryInterface().  "
           "*ppv == %p, ret == 0x%lX\n", this, *ppv, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::GetUnmarshalClass(REFIID riid,
                                                         void *pv,
                                                         DWORD dwDestContext,
                                                         LPVOID pvDestContext,
                                                         DWORD mshlflags,
                                                         LPCLSID pcid)
{
    olLog(("%p::INVALID CALL TO CDocfileUnmarshalFactory::GetUnmarshalClass("
           "riid, %p, %lu, %p, %lu, %p)\n", this, pv, dwDestContext,
           pvDestContext, mshlflags, pcid));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [iid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::GetMarshalSizeMax(REFIID iid,
                                                         void *pv,
                                                         DWORD dwDestContext,
                                                         LPVOID pvDestContext,
                                                         DWORD mshlflags,
                                                         LPDWORD pcbSize)
{
    olLog(("%p::INVALID CALL TO CDocfileUnmarshalFactory::GetMarshalSizeMax("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcbSize));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [iid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::MarshalInterface(IStream *pstStm,
                                                        REFIID iid,
                                                        void *pv,
                                                        DWORD dwDestContext,
                                                        LPVOID pvDestContext,
                                                        DWORD mshlflags)
{
    olLog(("%p::INVALID CALL TO CDocfileUnmarshalFactory::MarshalInterface("
           "%p, riid, %p, %lu, %p, %lu).  Context == %lX\n",
           this, pstStm, pv, dwDestContext, pvDestContext, mshlflags,
           (ULONG)GetCurrentContextId()));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::UnmarshalInterface, public
//
//  Synopsis:   Calls through to DfUnmarshalInterface
//
//  Arguments:  [pstStm] - Marshal stream
//              [riid] - IID of object to unmarshal
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::UnmarshalInterface(IStream *pstStm,
                                                          REFIID iid,
                                                          void **ppv)
{
    return DfUnMarshalInterface(pstStm, iid, TRUE, ppv);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef WIN32
STDMETHODIMP CDocfileUnmarshalFactory::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    IID iid;
    DWORD mshlflags;

    olLog(("%p::In  CDocfileUnmarshalFactory::ReleaseMarshalData(%p)\n",
           this, pstStm));

    olChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    if (IsEqualIID(iid, IID_ILockBytes))
    {
        sc = CFileStream::StaticReleaseMarshalData(pstStm, mshlflags);
    }
    else if (IsEqualIID(iid, IID_IStorage))
    {
        sc = CExposedDocFile::StaticReleaseMarshalData(pstStm, mshlflags);
    }
    else if (IsEqualIID(iid, IID_IStream))
    {
        sc = CExposedStream::StaticReleaseMarshalData(pstStm, mshlflags);
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    olLog(("%p::Out CDocfileUnmarshalFactory::ReleaseMarshalData, sc == %lX\n",
           this, sc));
 EH_Err:
    return ResultFromScode(sc);
}
#else
STDMETHODIMP CDocfileUnmarshalFactory::ReleaseMarshalData(IStream *pstStm)
{
    olLog(("%p::Stb CDocfileUnmarshalFactory::ReleaseMarshalData(%p)\n",
           this, pstStm));
    return NOERROR;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::DisconnectObject(DWORD dwReserved)
{
    olLog(("%p::Stb CDocfileUnmarshalFactory::DisconnectObject(%lu)\n",
           this, dwReserved));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::CreateInstance, public
//
//  Synopsis:   Creates an instance of the docfile IMarshal unmarshaller
//
//  Arguments:  [pUnkOuter] -
//              [riid] - IID of object to create
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::CreateInstance(IUnknown *pUnkOuter,
                                                      REFIID riid,
                                                      LPVOID *ppv)
{
    SCODE sc;

    olLog(("%p::In  CDocfileUnmarshalFactory::CreateInstance(%p, riid, %p)\n",
           this, pUnkOuter, ppv));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::CreateInstance:%p("
                "%p, riid, %p)\n", this, pUnkOuter, ppv));
    TRY
    {
        olChk(Validate());
        olChk(ValidatePtrBuffer(ppv));
        *ppv = NULL;
        olChk(ValidateIid(riid));
        if (pUnkOuter != NULL || !IsEqualIID(riid, IID_IMarshal))
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        _AddRef();
        *ppv = (IMarshal *)this;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::CreateInstance => "
                "%p\n", ppv));
 EH_Err:
    olLog(("%p::Out CDocfileUnmarshalFactory::CreateInstance().  "
           "*ppv == %p, ret == 0x%lX\n", this, *ppv, sc));
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::LockServer, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [fLock] -
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::LockServer(BOOL fLock)
{
    olLog(("%p::Stb CDocfileUnmarshalFactory::LockServer(%d)\n",
           this, fLock));
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\docfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       docfile.c
//
//  Contents:   DocFile root functions (Stg* functions)
//
//  History:    10-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <rpubdf.hxx>
#include <expdf.hxx>
#include <expst.hxx>
#include <dfentry.hxx>
#include <logfile.hxx>
#include <dirfunc.hxx>
#include <wdocfile.hxx>

#include <ole2sp.h>

#ifdef COORD
#include <resource.hxx>
#endif

#ifdef _MAC
#include <ole2sp.h>
#endif


HRESULT IsNffAppropriate(const LPCWSTR pwcsName);

//+--------------------------------------------------------------
//
//  Function:   DfFromLB, private
//
//  Synopsis:   Starts a root Docfile on an ILockBytes
//
//  Arguments:  [plst] - LStream to start on
//              [df] - Permissions
//              [dwStartFlags] - Startup flags
//              [snbExclude] - Partial instantiation list
//              [ppdfExp] - DocFile return
//              [pcid] - Class ID return for opens
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfExp]
//              [pcid]
//
//  History:    19-Mar-92       DrewB   Created
//              18-May-93       AlexT   Added pMalloc
//
//  Algorithm:  Create and initialize a root transaction level
//              Create and initialize a public docfile
//              Create and initialize an exposed docfile
//
//---------------------------------------------------------------


#ifdef COORD
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               ITransaction *pTransaction,
               CExposedDocFile **ppdfExp,
               CLSID *pcid)
#else
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               CExposedDocFile **ppdfExp,
               CLSID *pcid)
#endif //COORD
{
    SCODE sc, scConv;
    CRootPubDocFile *prpdf;

#ifdef COORD
    CPubDocFile *ppubdf;
    CPubDocFile *ppubReturn;
    CWrappedDocFile *pwdf;
    CDocfileResource *pdfr = NULL;
#endif

    CDFBasis *pdfb;
    ULONG ulOpenLock;
    IMalloc *pMalloc = ppc->GetMalloc();

    ppc->AddRef();

    olDebugOut((DEB_ITRACE, "In  DfFromLB(%p, %p, %X, %lX, %p, %p, %p)\n",
                pMalloc, plst, df, dwStartFlags, snbExclude, ppdfExp, pcid));

    //Take the mutex in the CPerContext, in case there is an IFillLockBytes
    //  trying to write data while we're trying to open.
    CSafeSem _ss(ppc);
    olChk(_ss.Take());

#ifdef CHECKCID
    ULONG cbRead;
    olChk(plst->ReadAt(CBCLSIDOFFSET, pcid, sizeof(CLSID), &cbRead));
    if (cbRead != sizeof(CLSID))
        olErr(EH_Err, STG_E_INVALIDHEADER);
    if (!REFCLSIDEQ(*pcid, DOCFILE_CLASSID))
        olErr(EH_Err, STG_E_INVALIDHEADER);
#endif

#ifdef COORD

    if (pTransaction != NULL)
    {
        //If we've passed in an ITransaction pointer, it indicates that we
        //   want to open or create this docfile as part of a coordinated
        //   transaction.  First, we need to find out if there's a docfile
        //   resource manager for that transaction currently existing in
        //   this process.
        //First, check if we're opening transacted.  If we aren't, then we're
        //   not going to allow this docfile to participate in the
        //   transaction.

        if (!P_TRANSACTED(df))
        {
            //Is this the right error?
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
        XACTTRANSINFO xti;
        olChk(pTransaction->GetTransactionInfo(&xti));

        EnterCriticalSection(&g_csResourceList);
        CDocfileResource *pdfrTemp = g_dfrHead.GetNext();

        while (pdfrTemp != NULL)
        {
            if (IsEqualBOID(pdfrTemp->GetUOW(), xti.uow))
            {
                //Direct hit.
                pdfr = pdfrTemp;
                break;
            }
            pdfrTemp = pdfrTemp->GetNext();
        }

        if (pdfr == NULL)
        {
            ITransactionCoordinator *ptc;
            //If there isn't, we need to create one.

            olChkTo(EH_cs, pTransaction->QueryInterface(
                IID_ITransactionCoordinator,
                (void **)&ptc));

            pdfr = new CDocfileResource;
            if (pdfr == NULL)
            {
                ptc->Release();
                olErr(EH_cs, STG_E_INSUFFICIENTMEMORY);
            }
            sc = pdfr->Enlist(ptc);
            ptc->Release();
            if (FAILED(sc))
            {
                pdfr->Release();;
                olErr(EH_cs, sc);
            }

            //Add to list.
            pdfr->SetNext(g_dfrHead.GetNext());
            if (g_dfrHead.GetNext() != NULL)
                g_dfrHead.GetNext()->SetPrev(pdfr);
            g_dfrHead.SetNext(pdfr);
            pdfr->SetPrev(&g_dfrHead);
        }
        else
        {
            //We'll release this reference below.
            pdfr->AddRef();
        }
        LeaveCriticalSection(&g_csResourceList);
    }
#endif

    // Make root
    olMem(prpdf = new (pMalloc) CRootPubDocFile(pMalloc));
    olChkTo(EH_prpdf, scConv = prpdf->InitRoot(plst, dwStartFlags, df,
                                               snbExclude, &pdfb,
                                               &ulOpenLock,
                                               ppc->GetGlobal()));

#ifdef COORD
    if (pTransaction != NULL)
    {
        //Set up a fake transaction level at the root.  A pointer to
        //  this will be held by the resource manager.  The storage pointer
        //  that is passed back to the caller will be a pointer to the
        //  transaction level (non-root) below it.  This will allow the
        //  client to write and commit as many times as desired without
        //  the changes ever actually hitting the file.

        CDfName dfnNull;  //  auto-initialized to 0
        WCHAR wcZero = 0;
        dfnNull.Set(2, (BYTE *)&wcZero);

        olMemTo(EH_prpdfInit, pwdf = new (pMalloc) CWrappedDocFile(
                &dfnNull,
                ROOT_LUID,
                (df & ~DF_INDEPENDENT),
                pdfb,
                NULL));

        olChkTo(EH_pwdf, pwdf->Init(prpdf->GetDF()));
        prpdf->GetDF()->AddRef();

        olMemTo(EH_pwdfInit, ppubdf = new (pMalloc) CPubDocFile(
            prpdf,
            pwdf,
            (df | DF_COORD) & ~DF_INDEPENDENT,
            ROOT_LUID,
            pdfb,
            &dfnNull,
            2,
            pdfb->GetBaseMultiStream()));

        olChkTo(EH_ppubdf, pwdf->InitPub(ppubdf));
        ppubdf->AddXSMember(NULL, pwdf, ROOT_LUID);

        ppubReturn = ppubdf;
    }
    else
    {
        ppubReturn = prpdf;
    }
#endif //COORD


    ppc->SetILBInfo(pdfb->GetBase(),
                    pdfb->GetDirty(),
                    pdfb->GetOriginal(),
                    ulOpenLock);
    ppc->SetLockInfo(ulOpenLock != 0, df);
    // Make exposed

#ifdef COORD
    //We don't need to AddRef ppc since it starts with a refcount of 1.
    olMemTo(EH_ppcInit,
            *ppdfExp = new (pMalloc) CExposedDocFile(
                ppubReturn,
                pdfb,
                ppc));

    if (pTransaction != NULL)
    {
        CExposedDocFile *pexpdf;

        olMemTo(EH_ppcInit, pexpdf = new (pMalloc) CExposedDocFile(
            prpdf,
            pdfb,
            ppc));
        ppc->AddRef();

        sc = pdfr->Join(pexpdf);
        if (FAILED(sc))
        {
            pexpdf->Release();
            olErr(EH_ppcInit, sc);
        }
        pdfr->Release();
    }
#else
    olMemTo(EH_ppcInit,
            *ppdfExp = new (pMalloc) CExposedDocFile(
                prpdf,
                pdfb,
                ppc));
#endif //COORD

    olDebugOut((DEB_ITRACE, "Out DfFromLB => %p\n", *ppdfExp));
    return scConv;

 EH_ppcInit:
    // The context will release this but we want to keep it around
    // so take a reference
    pdfb->GetOriginal()->AddRef();
    pdfb->GetBase()->AddRef();
    pdfb->GetDirty()->AddRef();
    if (ulOpenLock > 0 && ppc->GetGlobal() == NULL)
    {
        //  The global context doesn't exist, so we need to release
        //  the open lock explicitly.

        ReleaseOpen(pdfb->GetOriginal(), df, ulOpenLock);
    }

    //  The open lock has now been released (either explicitly or by ppc)
    ulOpenLock = 0;
#ifdef COORD
EH_ppubdf:
    if (pTransaction != NULL)
    {
        ppubdf->vRelease();
    }
EH_pwdfInit:
    if (pTransaction != NULL)
    {
        prpdf->GetDF()->Release();
    }
EH_pwdf:
    if (pTransaction != NULL)
    {
        pwdf->Release();
    }
 EH_prpdfInit:
#endif //COORD
    pdfb->GetDirty()->Release();
    pdfb->GetBase()->Release();
    if (ulOpenLock > 0)
        ReleaseOpen(pdfb->GetOriginal(), df, ulOpenLock);

    pdfb->SetDirty(NULL);
    pdfb->SetBase(NULL);

 EH_prpdf:
    prpdf->ReleaseLocks(plst);
    prpdf->vRelease();
#ifdef COORD
    if ((pTransaction != NULL) && (pdfr != NULL))
    {
        pdfr->Release();
    }
    goto EH_Err;
 EH_cs:
    LeaveCriticalSection(&g_csResourceList);
#endif

 EH_Err:
    ppc->Release();
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   DfFromName, private
//
//  Synopsis:   Starts a root DocFile from a base name
//
//  Arguments:  [pwcsName] - Name
//              [df] - Permissions
//              [dwStartFlags] - Startup flags
//              [snbExclude] - Partial instantiation list
//              [ppdfExp] - Docfile return
//              [pcid] - Class ID return for opens
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfExp]
//              [pcid]
//
//  History:    19-Mar-92       DrewB   Created
//              18-May-93       AlexT   Add per file allocator
//
//  Notes:      [pwcsName] is treated as unsafe memory
//
//---------------------------------------------------------------


// This set of root startup flags is handled by the multistream
// and doesn't need to be set for filestreams
#define RSF_MSF (RSF_CONVERT | RSF_TRUNCATE | RSF_ENCRYPTED)

#ifdef COORD
SCODE DfFromName(WCHAR const *pwcsName,
                 DFLAGS df,
                 DWORD dwStartFlags,
                 SNBW snbExclude,
                 ITransaction *pTransaction,
                 CExposedDocFile **ppdfExp,
                 ULONG *pulSectorSize,
                 CLSID *pcid)
#else
SCODE DfFromName(WCHAR const *pwcsName,
                 DFLAGS df,
                 DWORD dwStartFlags,
                 SNBW snbExclude,
                 CExposedDocFile **ppdfExp,
                 ULONG *pulSectorSize,
                 CLSID *pcid)
#endif
{
    IMalloc *pMalloc;
    CFileStream *plst;
    CPerContext *ppc;
    CFileStream *plst2 = NULL;
    SCODE sc;
    CMSFHeader *phdr = NULL;
    BOOL fCreated;

    olDebugOut((DEB_ITRACE, "In  DfFromName(%ws, %lX, %lX, %p, %p, %p)\n",
                pwcsName, df, dwStartFlags, snbExclude, ppdfExp, pcid));

    olHChk(DfCreateSharedAllocator(&pMalloc, df & DF_LARGE));

    // Start an ILockBytes from the named file
    olMemTo(EH_Malloc, plst = new (pMalloc) CFileStream(pMalloc));
    olChkTo(EH_plst, plst->InitGlobal(dwStartFlags & ~RSF_MSF, df));
    sc = plst->InitFile(pwcsName);
    fCreated = SUCCEEDED(sc) &&
        ((dwStartFlags & RSF_CREATE) || pwcsName == NULL);
    if (sc == STG_E_FILEALREADYEXISTS && (dwStartFlags & RSF_MSF))
    {
        plst->SetStartFlags(dwStartFlags & ~(RSF_MSF | RSF_CREATE));
        sc = plst->InitFile(pwcsName);
    }
    olChkTo(EH_plst, sc);

    if (!(dwStartFlags & RSF_CREATE))
    {
        ULONG cbDiskSector =  (dwStartFlags & RSF_NO_BUFFERING) ?
                               plst->GetSectorSize() : HEADERSIZE;
        olMemTo (EH_plstInit, phdr = (CMSFHeader*) TaskMemAlloc (cbDiskSector));
        ULARGE_INTEGER ulOffset = {0,0};
        ULONG ulRead;

        olChkTo (EH_plstInit, plst->ReadAt(ulOffset,phdr,cbDiskSector,&ulRead));
        if (ulRead < sizeof(CMSFHeaderData))
            olErr (EH_plstInit, STG_E_FILEALREADYEXISTS);
        sc = phdr->Validate();
        if (sc == STG_E_INVALIDHEADER)
            sc = STG_E_FILEALREADYEXISTS;
        olChkTo (EH_plstInit, sc);
        if (phdr->GetSectorShift() > SECTORSHIFT512)
        {
            IMalloc *pMalloc2 = NULL;
            CGlobalFileStream *pgfst = plst->GetGlobal();
#ifdef MULTIHEAP
            CSharedMemoryBlock *psmb;
            BYTE *pbBase;
            ULONG ulHeapName;
#endif

            df |= DF_LARGE;   // reallocate objects from task memory
            dwStartFlags |= (phdr->GetSectorShift() <<12) & RSF_SECTORSIZE_MASK;
            // create and initialize the task allocator
#ifdef MULTIHEAP
            g_smAllocator.GetState (&psmb, &pbBase, &ulHeapName);
#endif
            olChkTo(EH_taskmem, DfCreateSharedAllocator(&pMalloc2, TRUE));
            pMalloc->Release();
            pMalloc = pMalloc2;

            olMemTo(EH_taskmem, plst2 = new (pMalloc2) CFileStream(pMalloc2));
            olChkTo(EH_taskmem, plst2->InitGlobal(dwStartFlags & ~RSF_MSF, df));

            plst2->InitFromFileStream (plst);
            plst2->GetGlobal()->InitFromGlobalFileStream (pgfst);

#ifdef MULTIHEAP
            g_smAllocator.SetState (psmb, pbBase, ulHeapName, NULL, NULL);
            g_smAllocator.Uninit();  // unmap newly created heap
            g_smAllocator.SetState (NULL, NULL, 0, NULL, NULL);
#endif
            plst = plst2;  // CFileStream was destroyed by Uninit

        }
        TaskMemFree ((BYTE*)phdr);
        phdr = NULL;
    }

    //Create the per context
    olMemTo(EH_plstInit, ppc = new (pMalloc) CPerContext(pMalloc));
    olChkTo(EH_ppc, ppc->InitNewContext());

    {
#ifdef MULTIHEAP
        CSafeMultiHeap smh(ppc);
#endif

    // Start up the docfile
#ifdef COORD
        sc = DfFromLB(ppc, plst, df, dwStartFlags,
                      snbExclude, pTransaction,
                      ppdfExp, pcid);
#else
        sc = DfFromLB(ppc, plst, df, dwStartFlags,
                      snbExclude, ppdfExp, pcid);
#endif //COORD

    //Either DfFromLB has AddRef'ed the per context or it has failed.
    //Either way we want to release our reference here.
        LONG lRet;
        lRet = ppc->Release();
#ifdef MULTIHEAP
        olAssert((FAILED(sc)) || (lRet != 0));
#endif
        if (FAILED(sc))
        {
            if (fCreated || ((dwStartFlags & RSF_CREATE) && !P_TRANSACTED(df)))
                plst->Delete();
            plst->Release();
#ifdef MULTIHEAP
            if (lRet == 0)
            {
                g_smAllocator.Uninit();
            }
#endif
        }
        else if (pulSectorSize != NULL)
        {
            *pulSectorSize = (*ppdfExp)->GetPub()->GetBaseMS()->GetSectorSize();
        }
    }
    pMalloc->Release();

    olDebugOut((DEB_ITRACE, "Out DfFromName => %p\n", *ppdfExp));
    return sc;
EH_ppc:
    delete ppc;
EH_taskmem:
    if (plst2) plst2->Release();
EH_plstInit:
    if (fCreated || ((dwStartFlags & RSF_CREATE) && !P_TRANSACTED(df)))
        plst->Delete();
EH_plst:
    plst->Release();
EH_Malloc:
#ifdef MULTIHEAP
    g_smAllocator.Uninit();  // unmap newly created heap
#endif
    pMalloc->Release();
EH_Err:
    if (phdr != NULL)
        TaskMemFree ((BYTE*)phdr);
    return sc;
}


//+--------------------------------------------------------------
//
//  Function:   DfCreateDocfile, public
//
//  Synopsis:   Creates a root Docfile on a file
//
//  Arguments:  [pwcsName] - Filename
//              [grfMode] - Permissions
//              [reserved] - security attributes
//              [grfAttrs] - Win32 CreateFile attributes
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDAPI DfCreateDocfile (WCHAR const *pwcsName,
#ifdef COORD
                        ITransaction *pTransaction,
#else
                        void *pTransaction,
#endif
                        DWORD grfMode,
#if WIN32 == 300
                        LPSECURITY_ATTRIBUTES reserved,
#else
                        LPSTGSECURITY reserved,
#endif
                        ULONG ulSectorSize,
                        DWORD grfAttrs,
                        IStorage **ppstgOpen)
{
    SafeCExposedDocFile pdfExp;
    SCODE sc;
    DFLAGS df;
    DWORD dwSectorFlag = 0;

    olLog(("--------::In  StgCreateDocFile(%ws, %lX, %lu, %p)\n",
           pwcsName, grfMode, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgCreateDocfile(%ws, %lX, %lu, %p)\n",
               pwcsName, grfMode, reserved, ppstgOpen));

    olAssert(sizeof(LPSTGSECURITY) == sizeof(DWORD));

    olChkTo(EH_BadPtr, ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    if (pwcsName)
        olChk(ValidateNameW(pwcsName, _MAX_PATH));

    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);

    if (grfMode & STGM_SIMPLE)
    {
        if (pTransaction != NULL)
        {
            olErr(EH_Err, STG_E_INVALIDFLAG);
        }
        if (ulSectorSize > 512)
            olErr (EH_Err, STG_E_INVALIDPARAMETER);

        sc = DfCreateSimpDocfile(pwcsName, grfMode, 0, ppstgOpen);
        goto EH_Err;
    }

    olChk(VerifyPerms(grfMode, TRUE));
    if ((grfMode & STGM_RDWR) == STGM_READ ||
        (grfMode & (STGM_DELETEONRELEASE | STGM_CONVERT)) ==
        (STGM_DELETEONRELEASE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    df = ModeToDFlags(grfMode);
    if ((grfMode & (STGM_TRANSACTED | STGM_CONVERT)) ==
        (STGM_TRANSACTED | STGM_CONVERT))
        df |= DF_INDEPENDENT;
    if (ulSectorSize > 512)
    {
        df |= DF_LARGE;
        switch (ulSectorSize)
        {
            case 4096 : dwSectorFlag = RSF_SECTORSIZE4K; break;
            case 8192 : dwSectorFlag = RSF_SECTORSIZE8K; break;
            case 16384 : dwSectorFlag = RSF_SECTORSIZE16K; break;
            case 32768 : dwSectorFlag = RSF_SECTORSIZE32K; break;
            default : olErr (EH_Err, STG_E_INVALIDPARAMETER);
        }
    }
    else if (ulSectorSize != 0 && ulSectorSize != 512)
             olErr (EH_Err, STG_E_INVALIDPARAMETER);

#if WIN32 != 200
    //
    // When we create over NFF files, delete them first.
    // except when we want to preserve encryption information
    //
    if( (STGM_CREATE & grfMode) && !(FILE_ATTRIBUTE_ENCRYPTED & grfAttrs))
    {
        if( SUCCEEDED( IsNffAppropriate( pwcsName ) ) )
        {
            if(FALSE == DeleteFileW( pwcsName ) )
            {
                DWORD dwErr = GetLastError();
                if( dwErr != ERROR_FILE_NOT_FOUND &&
                    dwErr != ERROR_PATH_NOT_FOUND )
                {
                    olErr( EH_Err, Win32ErrorToScode( dwErr ) );
                }
            }
        }
    }
#endif // _CHICAGO_

    DfInitSharedMemBase();
#ifdef COORD
    olChk(sc = DfFromName(pwcsName, df,
                          RSF_CREATE |
                          ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                          ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0) |
                          ((grfMode & STGM_DELETEONRELEASE) ?
                           RSF_DELETEONRELEASE : 0) |
                          (dwSectorFlag) |
                          ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                            RSF_NO_BUFFERING : 0) |
                          ((grfAttrs & FILE_ATTRIBUTE_ENCRYPTED) ?
                            RSF_ENCRYPTED : 0),
                          NULL, pTransaction, &pdfExp, NULL, NULL));
#else
    olChk(sc = DfFromName(pwcsName, df,
                          RSF_CREATE |
                          ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                          ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0) |
                          ((grfMode & STGM_DELETEONRELEASE) ?
                           RSF_DELETEONRELEASE : 0) |
                          (dwSectorFlag) |
                          ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                            RSF_NO_BUFFERING : 0) |
                          ((grfAttrs & FILE_ATTRIBUTE_ENCRYPTED) ?
                            RSF_ENCRYPTED : 0),
                          NULL, &pdfExp, NULL, NULL));
#endif //COORD

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

EH_Err:
    olDebugOut((DEB_TRACE, "Out StgCreateDocfile => %p, ret == %lx\n",
         *ppstgOpen, sc));
    olLog(("--------::Out StgCreateDocFile().  *ppstgOpen == %p, ret == %lx\n",
           *ppstgOpen, sc));

EH_BadPtr:
    FreeLogFile();
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfile, public
//
//  Synopsis:   Creates a root Docfile on a file
//
//  Arguments:  [pwcsName] - Filename
//              [grfMode] - Permissions
//              [reserved] - security attributes
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgCreateDocfile(WCHAR const *pwcsName,
                        DWORD grfMode,
                        LPSTGSECURITY reserved,
                        IStorage **ppstgOpen)
{
    return DfCreateDocfile(pwcsName, NULL, grfMode, reserved, 0, 0, ppstgOpen);
}

//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfileOnILockBytes, public
//
//  Synopsis:   Creates a root Docfile on an lstream
//
//  Arguments:  [plkbyt] - LStream
//              [grfMode] - Permissions
//              [reserved] - Unused
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDAPI StgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
                                    DWORD grfMode,
                                    DWORD reserved,
                                    IStorage **ppstgOpen)
{
    IMalloc *pMalloc;
    CPerContext *ppc;
    SafeCExposedDocFile pdfExp;
    SCODE sc;
    DFLAGS df;
#ifdef MULTIHEAP
    CPerContext pcSharedMemory (NULL);
#endif

    olLog(("--------::In  StgCreateDocFileOnILockBytes(%p, %lX, %lu, %p)\n",
           plkbyt, grfMode, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgCreateDocfileOnILockBytes("
                "%p, %lX, %lu, %p)\n",
                plkbyt, grfMode, reserved, ppstgOpen));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    olChk(ValidateInterface(plkbyt, IID_ILockBytes));

    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) == 0)
        olErr(EH_Err, STG_E_FILEALREADYEXISTS);
    olChk(VerifyPerms(grfMode, TRUE));
    if (grfMode & STGM_DELETEONRELEASE)
        olErr(EH_Err, STG_E_INVALIDFUNCTION);
    df = ModeToDFlags(grfMode);
    if ((grfMode & (STGM_TRANSACTED | STGM_CONVERT)) ==
        (STGM_TRANSACTED | STGM_CONVERT))
        df |= DF_INDEPENDENT;

    DfInitSharedMemBase();
    olHChk(DfCreateSharedAllocator(&pMalloc, TRUE));
#ifdef MULTIHEAP
    // Because a custom ILockbytes can call back into storage code,
    // possibly using another shared heap, we need a temporary
    // owner until the real CPerContext is allocated
    // new stack frame for CSafeMultiHeap constructor/destructor
    {
        pcSharedMemory.GetThreadAllocatorState();
        CSafeMultiHeap smh(&pcSharedMemory);
#endif

    //Create the per context
    olMem(ppc = new (pMalloc) CPerContext(pMalloc));
    olChkTo(EH_ppc, ppc->InitNewContext());

#ifdef COORD
    sc = DfFromLB(ppc, plkbyt, df,
                  RSF_CREATE |
                  ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                  ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0),
                  NULL, NULL, &pdfExp, NULL);
#else
    sc = DfFromLB(ppc, plkbyt, df,
                  RSF_CREATE |
                  ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                  ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0),
                  NULL, &pdfExp, NULL);
#endif //COORD

    pMalloc->Release();

    //Either DfFromLB has AddRef'ed the per context or it has failed.
    //Either way we want to release our reference here.
    ppc->Release();

    olChkTo(EH_Truncate, sc);

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

    //  Success;  since we hold on to the ILockBytes interface,
    //  we must take a reference to it.
    plkbyt->AddRef();

    olDebugOut((DEB_TRACE, "Out StgCreateDocfileOnILockBytes => %p\n",
                *ppstgOpen));
#ifdef MULTIHEAP
    }
#endif
 EH_Err:
    olLog(("--------::Out StgCreateDocFileOnILockBytes().  "
           "*ppstgOpen == %p, ret == %lx\n", *ppstgOpen, sc));
    FreeLogFile();
    return ResultFromScode(sc);

 EH_ppc:
    delete ppc;
    goto EH_Err;

 EH_Truncate:
    if ((grfMode & STGM_CREATE) && (grfMode & STGM_TRANSACTED) == 0)
    {
        ULARGE_INTEGER ulSize;

        ULISet32(ulSize, 0);
        olHVerSucc(plkbyt->SetSize(ulSize));
    }
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Function:   DfOpenDocfile, public
//
//  Synopsis:   Instantiates a root Docfile from a file,
//              converting if necessary
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority mode reopen IStorage
//              [grfMode] - Permissions
//              [snbExclude] - Exclusions for priority reopen
//              [reserved] - security attributes
//              [grfAttrs] - Win32 CreateFile attributes
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI DfOpenDocfile(OLECHAR const *pwcsName,
#ifdef COORD
                     ITransaction *pTransaction,
#else
                     void *pTransaction,
#endif
                     IStorage *pstgPriority,
                     DWORD grfMode,
                     SNB snbExclude,
                     LPSTGSECURITY reserved,
                     ULONG *pulSectorSize,
                     DWORD grfAttrs,
                     IStorage **ppstgOpen)
{
    SafeCExposedDocFile pdfExp;
    SCODE sc;
    WCHAR awcName[_MAX_PATH];
    CLSID cid;

    olLog(("--------::In  StgOpenStorage(%ws, %p, %lX, %p, %lu, %p)\n",
           pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgOpenStorage("
                "%ws, %p, %lX, %p, %lu, %p)\n", pwcsName, pstgPriority,
                grfMode, snbExclude, reserved, ppstgOpen));

    olAssert(sizeof(LPSTGSECURITY) == sizeof(DWORD));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    if (pstgPriority == NULL)
    {
        olChk(ValidateNameW(pwcsName, _MAX_PATH));
        StringCbCopyW(awcName, sizeof(awcName), pwcsName);
    }
    if (pstgPriority)
    {
        STATSTG stat;

        olChk(ValidateInterface(pstgPriority, IID_IStorage));
        olHChk(pstgPriority->Stat(&stat, 0));
        if (lstrlenW (stat.pwcsName) > _MAX_PATH)
            olErr (EH_Err, STG_E_INVALIDNAME);
        StringCbCopyW(awcName, sizeof(awcName), stat.pwcsName);
        TaskMemFree(stat.pwcsName);
    }
#if WIN32 != 200
    if (grfMode & STGM_SIMPLE)
    {
        sc = DfOpenSimpDocfile(pwcsName, grfMode, 0, ppstgOpen);
        goto EH_Err;
    }
#endif
    olChk(VerifyPerms(grfMode, TRUE));
    if (grfMode & (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);
    if (snbExclude)
    {
        if ((grfMode & STGM_RDWR) != STGM_READWRITE)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(ValidateSNB(snbExclude));
    }
    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    if (grfMode & STGM_DELETEONRELEASE)
        olErr(EH_Err, STG_E_INVALIDFUNCTION);

    //Otherwise, try it as a docfile
    if (pstgPriority)
        olChk(pstgPriority->Release());

    DfInitSharedMemBase();
#ifdef COORD
    olChk(DfFromName(awcName, ModeToDFlags(grfMode), RSF_OPEN |
                     ((grfMode & STGM_DELETEONRELEASE) ?
                      RSF_DELETEONRELEASE : 0) |
                     ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                      RSF_NO_BUFFERING : 0),
                     snbExclude, pTransaction, &pdfExp, pulSectorSize, &cid));
#else
    olChk(DfFromName(awcName, ModeToDFlags(grfMode), RSF_OPEN |
                     ((grfMode & STGM_DELETEONRELEASE) ?
                      RSF_DELETEONRELEASE : 0) |
                     ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                      RSF_NO_BUFFERING : 0),
                     snbExclude, &pdfExp, pulSectorSize, &cid));
#endif //COORD

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

    olDebugOut((DEB_TRACE, "Out StgOpenStorage => %p\n", *ppstgOpen));
EH_Err:
    olLog(("--------::Out StgOpenStorage().  *ppstgOpen == %p, ret == %lx\n",
           *ppstgOpen, sc));
    FreeLogFile();

    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   StgOpenStorageOnILockBytes, public
//
//  Synopsis:   Instantiates a root Docfile from an LStream,
//              converting if necessary
//
//  Arguments:  [plkbyt] - Source LStream
//              [pstgPriority] - For priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - For priority reopens
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgOpenStorageOnILockBytes(ILockBytes *plkbyt,
                                  IStorage *pstgPriority,
                                  DWORD grfMode,
                                  SNB snbExclude,
                                  DWORD reserved,
                                  IStorage **ppstgOpen)
{
    IMalloc *pMalloc;
    CPerContext *ppc;
    SCODE sc;
    SafeCExposedDocFile pdfExp;
#ifdef MULTIHEAP
    CPerContext pcSharedMemory(NULL);
#endif
    CLSID cid;

    olLog(("--------::In  StgOpenStorageOnILockBytes("
           "%p, %p, %lX, %p, %lu, %p)\n",
           plkbyt, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgOpenStorageOnILockBytes("
                "%p, %p, %lX, %p, %lu, %p)\n", plkbyt, pstgPriority,
                grfMode, snbExclude, reserved, ppstgOpen));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    olChk(ValidateInterface(plkbyt, IID_ILockBytes));
    if (pstgPriority)
        olChk(ValidateInterface(pstgPriority, IID_IStorage));
    olChk(VerifyPerms(grfMode, TRUE));
    if (grfMode & (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);
    if (grfMode & STGM_DELETEONRELEASE)
        olErr(EH_Err, STG_E_INVALIDFUNCTION);
    if (snbExclude)
    {
        if ((grfMode & STGM_RDWR) != STGM_READWRITE)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(ValidateSNB(snbExclude));
    }
    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    if (pstgPriority)
        olChk(pstgPriority->Release());

    IFileLockBytes *pfl;
    if (SUCCEEDED(plkbyt->QueryInterface(IID_IFileLockBytes,
                                         (void **)&pfl)) &&
        ((CFileStream *)plkbyt)->GetContextPointer() != NULL)
    {
        //Someone passed us the ILockBytes we gave them from
        //StgGetIFillLockBytesOnFile.  It already contains a
        //context pointer, so reuse that rather than creating
        //a whole new shared heap.
        pfl->Release();
        CFileStream *pfst = (CFileStream *)plkbyt;
        CPerContext *ppc2 = pfst->GetContextPointer();
#ifdef MULTIHEAP
        CSafeMultiHeap smh(ppc2);
#endif
#ifdef COORD
        olChk(DfFromLB(ppc2,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         NULL,
                         &pdfExp,
                         NULL));
#else
        olChk(DfFromLB(ppc2,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         &pdfExp,
                         NULL));
#endif
    }
    else
    {
        DfInitSharedMemBase();
        olHChk(DfCreateSharedAllocator(&pMalloc, TRUE));
#ifdef MULTIHEAP
    // Because a custom ILockbytes can call back into storage code,
    // possibly using another shared heap, we need a temporary
    // owner until the real CPerContext is allocated
    // new stack frame for CSafeMultiHeap constructor/destructor
        {
            pcSharedMemory.GetThreadAllocatorState();
            CSafeMultiHeap smh(&pcSharedMemory);
#endif

            //Create the per context
            olMem(ppc = new (pMalloc) CPerContext(pMalloc));
            sc = ppc->InitNewContext();
            if (FAILED(sc))
            {
                delete ppc;
                olErr(EH_Err, sc);
            }

#ifdef COORD
            sc = DfFromLB(ppc,
                          plkbyt, ModeToDFlags(grfMode), RSF_OPEN, snbExclude,
                          NULL, &pdfExp, &cid);
#else
            sc = DfFromLB(ppc,
                          plkbyt, ModeToDFlags(grfMode), RSF_OPEN, snbExclude,
                          &pdfExp, &cid);
#endif //COORD

            pMalloc->Release();

            //Either DfFromLB has AddRef'ed the per context or it has failed.
            //Either way we want to release our reference here.
            ppc->Release();
            olChk(sc);
#ifdef MULTIHEAP
        }
#endif
    }

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

    //  Success;  since we hold on to the ILockBytes interface,
    //  we must take a reference to it.
    plkbyt->AddRef();

    olDebugOut((DEB_TRACE, "Out StgOpenStorageOnILockBytes => %p\n",
                *ppstgOpen));

EH_Err:
    olLog(("--------::Out StgOpenStorageOnILockBytes().  "
           "*ppstgOpen == %p, ret == %lx\n", *ppstgOpen, sc));
    FreeLogFile();

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfGetClass, public
//
//  Synopsis:   Retrieves the class ID of the root entry of a docfile
//
//  Arguments:  [hFile] - Docfile file handle
//              [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//  History:    09-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI DfGetClass(HANDLE hFile,
                  CLSID *pclsid)
{
    SCODE sc;
    DWORD dwCb;
    IMalloc *pMalloc;
    CFileStream *pfst;
    ULARGE_INTEGER uliOffset;
    ULONG ulOpenLock, ulAccessLock;
    BYTE bBuffer[sizeof(CMSFHeader)];
    CMSFHeader *pmsh;
    CDirEntry *pde;

    olDebugOut((DEB_ITRACE, "In  DfGetClass(%p, %p)\n", hFile, pclsid));

    olAssert(sizeof(bBuffer) >= sizeof(CMSFHeader));
    pmsh = (CMSFHeader *)bBuffer;

    olAssert(sizeof(bBuffer) >= sizeof(CDirEntry));
    pde = (CDirEntry *)bBuffer;

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
    {
        olErr(EH_Err, LAST_STG_SCODE);
    }
    if (!ReadFile(hFile, pmsh->GetData(), sizeof(CMSFHeaderData), &dwCb, NULL))
    {
        olErr(EH_Err, LAST_STG_SCODE);
    }
    if (dwCb != sizeof(CMSFHeaderData))
    {
        olErr(EH_Err, STG_E_INVALIDHEADER);
    }
    sc = pmsh->Validate();
    olChk(sc);

    // Now we know it's a docfile

    DfInitSharedMemBase();
    olHChk(DfCreateSharedAllocator(&pMalloc, TRUE));
    olMemTo(EH_pMalloc, pfst = new (pMalloc) CFileStream(pMalloc));
    olChkTo(EH_pfst, pfst->InitGlobal(0, 0));
    olChkTo(EH_pfst, pfst->InitFromHandle(hFile));

    // Take open and access locks to ensure that we're cooperating
    // with real opens

    olChkTo(EH_pfst, GetOpen(pfst, DF_READ, TRUE, &ulOpenLock));
    olChkTo(EH_open, GetAccess(pfst, DF_READ, &ulAccessLock));

#ifdef LARGE_DOCFILE
    uliOffset.QuadPart = (ULONGLONG)(pmsh->GetDirStart() + 1) <<
                          pmsh->GetSectorShift();
#else
    uliOffset.HighPart = 0;
    uliOffset.LowPart = (pmsh->GetDirStart()+1) << pmsh->GetSectorShift();
#endif

    // The root directory entry is always the first directory entry
    // in the first directory sector

    // Ideally, we could read just the class ID directly into
    // pclsid.  In practice, all the important things are declared
    // private or protected so it's easier to read the whole entry

    olChkTo(EH_access, GetScode(pfst->ReadAt(uliOffset, pde,
                                             sizeof(CDirEntry), &dwCb)));
    if (dwCb != sizeof(CDirEntry))
    {
        sc = STG_E_READFAULT;
    }
    else
    {
        if (pde->GetFlags() != STGTY_ROOT)
            olErr (EH_access, STG_E_DOCFILECORRUPT);

        *pclsid = pde->GetClassId();
        sc = S_OK;
    }

    olDebugOut((DEB_ITRACE, "Out DfGetClass\n"));
 EH_access:
    ReleaseAccess(pfst, DF_READ, ulAccessLock);
 EH_open:
    ReleaseOpen(pfst, DF_READ, ulOpenLock);
 EH_pfst:
    pfst->Release();
 EH_pMalloc:
    pMalloc->Release();
 EH_Err:
    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\exphead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       exphead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    26-Oct-92 AlexT    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <ole2.h>

#include <propset.h>
#include <propapi.h>
#include <propstm.hxx>
#include <stgprops.hxx>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <safedecl.hxx>
#include <dfexcept.hxx>

#include <docfilep.hxx>

#include <msf.hxx>

#include <publicdf.hxx>
#include <debug.hxx>
#include <dfmem.hxx>
#include <funcs.hxx>
#ifdef ASYNC
#include <async.hxx>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\expdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       expdf.cxx
//
//  Contents:   Exposed DocFile implementation
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <expdf.hxx>
#include <expst.hxx>
#include <expiter.hxx>
#include <pbstream.hxx>
#include <lock.hxx>
#include <marshl.hxx>
#include <logfile.hxx>
#include <rpubdf.hxx>
#include <expparam.hxx>

#include <olepfn.hxx>

#include <ole2sp.h>

#if WIN32 == 300
IMPLEMENT_UNWIND(CSafeAccess);
IMPLEMENT_UNWIND(CSafeSem);
#endif

extern WCHAR const wcsContents[];



//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CExposedDocFile, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdf] - Public DocFile
//              [pdfb] - DocFile basis
//              [ppc] - Context
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedDocFile::CExposedDocFile(CPubDocFile *pdf,
                                 CDFBasis *pdfb,
                                 CPerContext *ppc)
    : CPropertySetStorage(MAPPED_STREAM_QI),
      _PropertyBagEx( DFlagsToMode( pdf->GetDFlags() ))
{
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CExposedDocFile("
                "%p, %p, %p)\n", pdf, pdfb, ppc));


    _ppc = ppc;
    _pdf = P_TO_BP(CBasedPubDocFilePtr, pdf);
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _pdfb->vAddRef();
    _cReferences = 1;
    _sig = CEXPOSEDDOCFILE_SIG;
#if WIN32 >= 300
    _pIAC = NULL;
#endif

    // Initialize CPropertySetStorage and CPropertyBagEx

    CPropertySetStorage::Init( static_cast<IStorage*>(this), static_cast<IBlockingLock*>(this),
                               FALSE ); // fControlLifetimes (=> Don't addref)

    _PropertyBagEx.Init( static_cast<IPropertySetStorage*>(this),   // Not addref-ed
                         static_cast<IBlockingLock*>(this) );       // Not addref-ed


    //
    // CoQueryReleaseObject needs to have the address of the exposed docfiles
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CExposedDocFile] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CExposedDocFile] =
            **(ULONG_PTR **)((IStorage *)this);
    }

#ifdef COORD
    _ulLock = _cbSizeBase = _cbSizeOrig = 0;
    _sigMSF = 0;
#endif

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CExposedDocFile\n"));
}


SCODE CExposedDocFile::InitMarshal(DWORD dwAsyncFlags,
                                   IDocfileAsyncConnectionPoint *pdacp)
{
    return _cpoint.InitMarshal(this, dwAsyncFlags, pdacp);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::~CExposedDocFile, public
//
//  Synopsis:   Destructor
//
//  History:    23-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedDocFile::~CExposedDocFile(void)
{
    BOOL fClose = FALSE;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::~CExposedDocFile\n"));
    olAssert(_cReferences == 0);

    //In order to call into the tree, we need to take the mutex.
    //The mutex may get deleted in _ppc->Release(), so we can't
    //release it here.  The mutex actually gets released in
    //CPerContext::Release() or in the CPerContext destructor.

    //If _ppc is NULL, we're partially constructed and don't need to
    //worry.
    SCODE sc;

#if WIN32 >= 300
     if (_pIAC != NULL)
     {
        _pIAC->Release();
        _pIAC = NULL;
     }
#endif

#if !defined(MULTIHEAP)
    // TakeSem and ReleaseSem are moved to the Release Method
    // so that the deallocation for this object is protected
    if (_ppc)
    {
        sc = TakeSem();
        SetWriteAccess();
        olAssert(SUCCEEDED(sc));
    }


#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP

    if (_pdf)
    {
        // If we're the last reference on a root object
        // we close the context because all children will become
        // reverted so it is no longer necessary
        if (_pdf->GetRefCount() == 1 && _pdf->IsRoot())
            fClose = TRUE;

        _pdf->CPubDocFile::vRelease();
    }
    if (_pdfb)
        _pdfb->CDFBasis::vRelease();
#if !defined(MULTIHEAP)
    if (_ppc)
    {
        if (fClose)
            _ppc->Close();
        if (_ppc->Release() > 0)
            ReleaseSem(sc);
    }
#ifdef ASYNC
    //Mutex has been released, so we can release the connection point
    //  without fear of deadlock.
    if (pdacp != NULL)
        pdacp->Release();
#endif
#endif // MULTIHEAP

    _sig = CEXPOSEDDOCFILE_SIGDEL;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::~CExposedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Release, public
//
//  Synopsis:   Releases resources for a CExposedDocFile
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedDocFile::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedDocFile::Release()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Release()\n"));

    if (FAILED(Validate()))
        return 0;
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        SCODE sc = S_OK;

        sc = _PropertyBagEx.Commit( STGC_DEFAULT );
        olAssert(SUCCEEDED(sc));

        sc = _PropertyBagEx.ShutDown();
        olAssert(SUCCEEDED(sc));

#ifdef MULTIHEAP
        CSafeMultiHeap smh(_ppc);
        CPerContext *ppc = _ppc;

        if (_ppc)
        {
            sc = TakeSem();
            SetWriteAccess();
            olAssert(SUCCEEDED(sc));
        }
#ifdef ASYNC
        IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
        BOOL fClose = (_pdf) && (_pdf->GetRefCount()==1) && _pdf->IsRoot();
#endif //MULTIHEAP
        delete this;
#ifdef MULTIHEAP
        if (ppc)
        {
            if (fClose)
                ppc->Close();
            if (ppc->Release() == 0)
                g_smAllocator.Uninit();
            else
                if (SUCCEEDED(sc)) ppc->UntakeSem(); 
        }
#ifdef ASYNC
        //Mutex has been released, so we can release the connection point
        //  without fear of deadlock.
        if (pdacp != NULL)
            pdacp->Release();
#endif
#endif
    }
    else if (lRet < 0)
        lRet = 0;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Release %p() => %lu\n", 
                this, lRet));
    olLog(("%p::Out CExposedDocFile::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return (ULONG)lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CheckCopyTo, private
//
//  Synopsis:   Checks for CopyTo legality
//
//  Returns:    Appropriate status code
//
//  History:    07-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

inline SCODE CExposedDocFile::CheckCopyTo(void)
{
    return _pdfb->GetCopyBase() != NULL &&
        _pdf->IsAtOrAbove(_pdfb->GetCopyBase()) ?
            STG_E_ACCESSDENIED : S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ConvertInternalStream, private
//
//  Synopsis:   Converts an internal stream to a storage
//
//  Arguments:  [pwcsName] - Name
//              [pdfExp] - Destination docfile
//
//  Returns:    Appropriate status code
//
//  History:    23-Jun-92       DrewB   Created
//
//---------------------------------------------------------------


static WCHAR const wcsIllegalName[] = {'\\', '\0'};

SCODE CExposedDocFile::ConvertInternalStream(CExposedDocFile *pdfExp)
{
    CPubStream *pstFrom, *pstTo;
    SCODE sc;
    CDfName const dfnIllegal(wcsIllegalName);
    CDfName const dfnContents(wcsContents);

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::ConvertInternalStream(%p)\n",
                pdfExp));
    olChk(_pdf->GetStream(&dfnIllegal, DF_READWRITE | DF_DENYALL, &pstFrom));
    olChkTo(EH_pstFrom, pdfExp->GetPub()->CreateStream(&dfnContents,
                                                       DF_WRITE | DF_DENYALL,
                                                       &pstTo));
    olChkTo(EH_pstTo, CopySStreamToSStream(pstFrom->GetSt(),
                                           pstTo->GetSt()));
    olChkTo(EH_pstTo, _pdf->DestroyEntry(&dfnIllegal, FALSE));
    sc = S_OK;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::ConvertInternalStream\n"));
    // Fall through
EH_pstTo:
    pstTo->CPubStream::vRelease();
EH_pstFrom:
    pstFrom->CPubStream::vRelease();
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateEntry, private
//
//  Synopsis:   Creates elements, used in CreateStream, CreateStorage.
//
//  Arguments:  [pdfn] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    18-Dec-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::CreateEntry(CDfName const *pdfn,
                                   DWORD dwType,
                                   DWORD grfMode,
                                   void **ppv)
{
    SCODE sc;
    SEntryBuffer eb;
    BOOL fRenamed = FALSE;
    CPubStream *pst;
    CExposedStream *pstExp;
    CPubDocFile *pdf;
    CExposedDocFile *pdfExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateEntry:%p("
                "%p, %lX, %lX, %p)\n", this, pdfn, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));

    //  3/11/93 - Demand scratch when opening/creating transacted
    if ((grfMode & STGM_TRANSACTED) == STGM_TRANSACTED)
    {
        olChk(_ppc->GetDirty()->InitScratch());
    }

    if (grfMode & (STGM_CREATE | STGM_CONVERT))
    {
        if (FAILED(sc = _pdf->IsEntry(pdfn, &eb)))
        {
            if (sc != STG_E_FILENOTFOUND)
                olErr(EH_Err, sc);
        }
        else if (eb.dwType == dwType && (grfMode & STGM_CREATE))
            olChk(_pdf->DestroyEntry(pdfn, FALSE));
        else if (eb.dwType == STGTY_STREAM && (grfMode & STGM_CONVERT) &&
                 dwType == STGTY_STORAGE)
        {
            CDfName const dfnIllegal(wcsIllegalName);

            olChk(_pdf->RenameEntry(pdfn, &dfnIllegal));
            fRenamed = TRUE;
        }
        else
            olErr(EH_Err, STG_E_FILEALREADYEXISTS);
    }
    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(_pdf->CreateStream(pdfn, ModeToDFlags(grfMode), &pst));
        olMemTo(EH_pst, pstExp =  new (_pdfb->GetMalloc()) CExposedStream);
        olChkTo(EH_pstExp, pstExp->Init(pst, BP_TO_P(CDFBasis *, _pdfb),
                                        _ppc, NULL));
        _ppc->AddRef();
#ifdef ASYNC
        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_connSt, pstExp->InitConnection(&_cpoint));
        }
#endif
        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(_pdf->CreateDocFile(pdfn, ModeToDFlags(grfMode), &pdf));
        olMemTo(EH_pdf, pdfExp = new (_pdfb->GetMalloc())
                CExposedDocFile(pdf, BP_TO_P(CDFBasis *, _pdfb), _ppc));
        _ppc->AddRef();

        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_pdfExpInit, pdfExp->InitConnection(&_cpoint));
        }

        // If we've renamed the original stream for conversion, convert
        if (fRenamed)
        {
            olChkTo(EH_pdfExpInit, ConvertInternalStream(pdfExp));
            sc = STG_S_CONVERTED;
        }

        *ppv = pdfExp;
    }
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateEntry\n"));
    return sc;

 EH_connSt:
    pstExp->Release();
    goto EH_Del;

 EH_pstExp:
    delete pstExp;
 EH_pst:
    pst->CPubStream::vRelease();
    goto EH_Del;

 EH_pdfExpInit:
    pdfExp->Release();
    goto EH_Del;
 EH_pdf:
    pdf->CPubDocFile::vRelease();
    // Fall through
 EH_Del:
    olVerSucc(_pdf->DestroyEntry(pdfn, TRUE));
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenEntry, private
//
//  Synopsis:   Opens elements, used in OpenStream, OpenStorage.
//
//  Arguments:  [pdfn] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    18-Dec-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::OpenEntry(CDfName const *pdfn,
                                 DWORD dwType,
                                 DWORD grfMode,
                                 void **ppv)
{
    SCODE sc;
    CPubDocFile *pdf;
    CExposedDocFile *pdfExp;
    CPubStream *pst;
    CExposedStream *pstExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenEntry:%p("
                "%p, %lX, %lX, %p)\n", this, pdfn, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));

    //  3/11/93 - Demand scratch when opening/creating transacted
    if ((grfMode & STGM_TRANSACTED) == STGM_TRANSACTED)
    {
        olChk(_ppc->GetDirty()->InitScratch());
    }

    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(_pdf->GetStream(pdfn, ModeToDFlags(grfMode), &pst));
        olMemTo(EH_pst, pstExp = new (_pdfb->GetMalloc()) CExposedStream);
        olChkTo(EH_pstExp, pstExp->Init(pst, BP_TO_P(CDFBasis *, _pdfb),
                                        _ppc, NULL));
        _ppc->AddRef();

        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_connSt, pstExp->InitConnection(&_cpoint));
        }

        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(_pdf->GetDocFile(pdfn, ModeToDFlags(grfMode), &pdf));
        olMemTo(EH_pdf, pdfExp = new (_pdfb->GetMalloc())
                CExposedDocFile(pdf, BP_TO_P(CDFBasis *, _pdfb), _ppc));
        _ppc->AddRef();

        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_connDf, pdfExp->InitConnection(&_cpoint));
        }

        *ppv = pdfExp;
    }

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenEntry\n"));
    return S_OK;
 EH_connSt:
    pstExp->Release();
    return sc;

 EH_pstExp:
    delete pstExp;
    //  Fall through to clean up CPubStream
 EH_pst:
    pst->CPubStream::vRelease();
    return sc;

EH_connDf:
    pdfExp->Release();
    return sc;

 EH_pdf:
    pdf->CPubDocFile::vRelease();
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::CreateStream(WCHAR const *pwcsName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedStream pestm;
    CDfName dfn;

    olDebugOut((DEB_TRACE, "In  CExposedDocFile::CreateStream("
                "%ws, %lX, %lu, %lu, %p)\n", pwcsName, grfMode, reserved1,
                reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::CreateStream(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstm));

    OL_VALIDATE(CreateStream(pwcsName,
                             grfMode,
                             reserved1,
                             reserved2,
                             ppstm));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(CheckCopyTo());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    dfn.Set(pwcsName);
    sc = CreateEntry(&dfn, STGTY_STREAM, grfMode, (void **)&pestm);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
        TRANSFER_INTERFACE(pestm, IStream, ppstm);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::CreateStream => %p\n",
                *ppstm));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStream().  "
           "*ppstm == %p, ret == %lx\n", this, *ppstm, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedStream pestm;
    CDfName dfn;

    olDebugOut((DEB_TRACE, "In  CExposedDocFile::OpenStream("
                "%ws, %p, %lX, %lu, %p)\n", pwcsName, reserved1,
                grfMode, reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::OpenStream(%ws, %lu %lX, %lu, %p)\n",
           this, pwcsName, reserved1, grfMode, reserved2, ppstm));

    OL_VALIDATE(OpenStream(pwcsName,
                           reserved1,
                           grfMode,
                           reserved2,
                           ppstm));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    dfn.Set(pwcsName);
    sc = OpenEntry(&dfn, STGTY_STREAM, grfMode, (void **)&pestm);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
        TRANSFER_INTERFACE(pestm, IStream, ppstm);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::OpenStream => %p\n",
                *ppstm));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStream().  "
           "*ppstm == %p, ret == %lx\n", this, *ppstm, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStorage, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstg] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::CreateStorage(
        WCHAR const *pwcsName,
        DWORD grfMode,
        DWORD reserved1,
        LPSTGSECURITY reserved2,
        IStorage **ppstg)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedDocFile pedf;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::CreateStorage(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstg));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::CreateStorage:%p("
                "%ws, %lX, %lu, %lu, %p)\n", this, pwcsName, grfMode,
                reserved1, reserved2, ppstg));

    OL_VALIDATE(CreateStorage(pwcsName,
                              grfMode,
                              reserved1,
                              reserved2,
                              ppstg));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(CheckCopyTo());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    dfn.Set(pwcsName);
    sc = CreateEntry(&dfn, STGTY_STORAGE, grfMode, (void **)&pedf);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
        TRANSFER_INTERFACE(pedf, IStorage, ppstg);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::CreateStorage => %p\n",
                *ppstg));
EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStorage().  "
           "*ppstg == %p, ret == %lX\n", this, *ppstg, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStorage, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - Priority reopens
//              [reserved]
//              [ppstg] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::OpenStorage(WCHAR const *pwcsName,
                                           IStorage *pstgPriority,
                                           DWORD grfMode,
                                           SNBW snbExclude,
                                           DWORD reserved,
                                           IStorage **ppstg)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedDocFile pdfExp;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::OpenStorage(%ws, %p, %lX, %p, %lu, %p)\n",
           this, pwcsName, pstgPriority, grfMode, snbExclude, reserved,
           ppstg));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::OpenStorage:%p("
                "%ws, %p, %lX, %p, %lu, %p)\n", this, pwcsName, pstgPriority,
                grfMode, snbExclude, reserved, ppstg));


    OL_VALIDATE(OpenStorage(pwcsName,
                            pstgPriority,
                            grfMode,
                            snbExclude,
                            reserved,
                            ppstg));
    
    olChk(Validate());
    if (snbExclude != NULL)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    dfn.Set(pwcsName);
    sc = OpenEntry(&dfn, STGTY_STORAGE, grfMode, (void **)&pdfExp);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
    {
        TRANSFER_INTERFACE(pdfExp, IStorage, ppstg);
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::OpenStorage => %p\n",
                *ppstg));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStorage().  "
           "*ppstg == %p, ret == %lX\n", this, *ppstg, sc));
    return _OLERETURN(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::MakeCopyFlags, public
//
//  Synopsis:   Translates IID array into bit fields
//
//  Arguments:  [ciidExclude] - Count of IIDs
//              [rgiidExclude] - IIDs not to copy
//
//  Returns:    Appropriate status code
//
//  History:    23-Dec-92       DrewB   Created
//
//----------------------------------------------------------------------------


DWORD CExposedDocFile::MakeCopyFlags(DWORD ciidExclude,
                                     IID const *rgiidExclude)
{
    DWORD dwCopyFlags;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::MakeCopyFlags(%lu, %p)\n",
                ciidExclude, rgiidExclude));
    // Copy everything by default
    dwCopyFlags = COPY_ALL;
    for (; ciidExclude > 0; ciidExclude--, rgiidExclude++)
        if (IsEqualIID(*rgiidExclude, IID_IStorage))
            dwCopyFlags &= ~COPY_STORAGES;
        else if (IsEqualIID(*rgiidExclude, IID_IStream))
            dwCopyFlags &= ~COPY_STREAMS;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::MakeCopyFlags\n"));
    return dwCopyFlags;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CopyTo, public
//
//  Synopsis:   Makes a copy of a DocFile
//
//  Arguments:  [ciidExclude] - Length of rgiid array
//              [rgiidExclude] - Array of IIDs to exclude
//              [snbExclude] - Names to exclude
//              [pstgDest] - Parent of copy
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::CopyTo(DWORD ciidExclude,
                                      IID const *rgiidExclude,
                                      SNBW snbExclude,
                                      IStorage *pstgDest)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    SAFE_SEM;
    DWORD i;



    olLog(("%p::In  CExposedDocFile::CopyTo(%lu, %p, %p, %p)\n",
           this, ciidExclude, rgiidExclude, snbExclude, pstgDest));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::CopyTo(%lu, %p, %p, %p)\n",
                ciidExclude, rgiidExclude, snbExclude, pstgDest));

    OL_VALIDATE(CopyTo(ciidExclude,
                       rgiidExclude,
                       snbExclude,
                       pstgDest));
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(_pdf->CheckReverted());

    olAssert(_pdfb->GetCopyBase() == NULL);
    _pdfb->SetCopyBase(BP_TO_P(CPubDocFile *, _pdf));

    // Flush all descendant property set buffers so that their
    // underlying Streams (which are about to be copied) are
    // up to date.

    SetWriteAccess();
    olChkTo(EH_Loop, _pdf->FlushBufferedData(0));
    ClearWriteAccess();

    // Perform the copy.

    sc = CopyDocFileToIStorage(_pdf->GetDF(), pstgDest, snbExclude,
                               MakeCopyFlags(ciidExclude, rgiidExclude));
EH_Loop:
    _pdfb->SetCopyBase(NULL);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::CopyTo\n"));
EH_Err:
    _pdfb->SetCopyBase(NULL);
    olLog(("%p::Out ExposedDocFile::CopyTo().  ret == %lX\n", this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::Commit(DWORD dwFlags)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::Commit(%lX)\n",this, dwFlags));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Commit(%lX)\n", dwFlags));

    OL_VALIDATE(Commit(dwFlags));
    olChk(Validate());

    BEGIN_PENDING_LOOP;

    olChk( _PropertyBagEx.Commit( dwFlags ));
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    if (_pdf->GetTransactedDepth() <= 1) // topmost transacted level or direct
    {
        if (_pdfb->DirectWriterMode() && (*_ppc->GetRecursionCount()) == 0)
            olChk(STG_E_ACCESSDENIED);
    }
#endif

    olChkTo(EH_Loop, _pdf->Commit(dwFlags));

#if WIN32 >= 300
    if (SUCCEEDED(sc) && _pIAC != NULL)
        sc = _pIAC->CommitAccessRights(0);
#endif

EH_Loop:
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Commit().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Revert, public
//
//  Synopsis:   Reverts transacted changes
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::Revert(void)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::Revert()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Revert\n"));

    OL_VALIDATE(Revert());
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

    olChkTo(EH_Loop, _pdf->Revert());

#if WIN32 >= 300
    if (SUCCEEDED(sc) && _pIAC != NULL)
        sc = _pIAC->RevertAccessRights();
#endif
EH_Loop:
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Revert\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Revert().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedIterator pdiExp;
    CDfName dfnTmp;

    olLog(("%p::In  CExposedDocFile::EnumElements(%lu, %p, %lu, %p)\n",
           this, reserved1, reserved2, reserved3, ppenm));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::EnumElements(%p)\n",
                ppenm));

    OL_VALIDATE(EnumElements(reserved1,
                             reserved2,
                             reserved3,
                             ppenm));

    olChk(Validate());

    //ASYNC Note:  It doesn't appear that there's any way that this
    //  function can fail with STG_E_PENDING, so we don't need a pending
    //  loop here.
    olChk(TakeSafeSem());
    if (!P_READ(_pdf->GetDFlags()))
        olErr(EH_Err, STG_E_ACCESSDENIED);
    olChk(_pdf->CheckReverted());
    SafeReadAccess();

    pdiExp.Attach(new CExposedIterator(BP_TO_P(CPubDocFile *, _pdf),
                                       &dfnTmp,
                                       BP_TO_P(CDFBasis *, _pdfb),
                                       _ppc));
    olMem((CExposedIterator *)pdiExp);
    _ppc->AddRef();
#ifdef ASYNC
    if (_cpoint.IsInitialized())
    {
        olChkTo(EH_Exp, pdiExp->InitConnection(&_cpoint));
    }
#endif
    TRANSFER_INTERFACE(pdiExp, IEnumSTATSTG, ppenm);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::EnumElements => %p\n",
                *ppenm));
EH_Err:
    olLog(("%p::Out CExposedDocFile::EnumElements().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
EH_Exp:
    pdiExp->Release();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DestroyElement, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pwcsName] - Name of element
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::DestroyElement(WCHAR const *pwcsName)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::DestroyElement(%ws)\n", this, pwcsName));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::DestroyElement(%ws)\n",
                pwcsName));

    OL_VALIDATE(DestroyElement(pwcsName));
    
    olChk(Validate());
    dfn.Set(pwcsName);

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->DestroyEntry(&dfn, FALSE);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::DestroyElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::DestroyElement().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

_OLESTDMETHODIMP CExposedDocFile::MoveElementTo(WCHAR const *pwcsName,
                                             IStorage *pstgParent,
                                             OLECHAR const *ptcsNewName,
                                             DWORD grfFlags)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    olLog(("%p::In  CExposedDocFile::MoveElementTo("
           "%ws, %p, " OLEFMT ", %lu)\n",
           this, pwcsName, pstgParent, ptcsNewName, grfFlags));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::MoveElementTo("
                "%ws, %p, " OLEFMT ", %lu)\n",
                pwcsName, pstgParent, ptcsNewName, grfFlags));

    OL_VALIDATE(MoveElementTo(pwcsName,
                              pstgParent,
                              ptcsNewName,
                              grfFlags));
    
    olChk(Validate());

#ifdef ASYNC
    //ASYNC Note:  We don't use the normal pending loop macros here because
    //  we have no safe sem and need to pass a NULL.
    do
    {
#endif
        sc = MoveElementWorker(pwcsName,
                               pstgParent,
                               ptcsNewName,
                               grfFlags);
#ifdef ASYNC
        if (!ISPENDINGERROR(sc))
        {
            break;
        }
        else
        {
            SCODE sc2;
            sc2 = _cpoint.Notify(sc,
                                 _ppc->GetBase(),
                                 _ppc,
                                 NULL);
            if (sc2 != S_OK)
            {
                return ResultFromScode(sc2);
            }
        }
    } while (TRUE);
#endif
EH_Err:
    olLog(("%p::Out CExposedDocFile::MoveElementTo().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MoveElementToWorker, public
//
//  Synopsis:   Move an element of a DocFile to an IStorage
//
//  Arguments:  [pwcsName] - Current name
//              [ptcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Open source as storage or stream (whatever works)
//              Create appropriate destination
//              Copy source to destination
//              Set create time of destination equal to create time of source
//              If appropriate, delete source
//
//  History:    10-Nov-92       AlexT   Created
//
//---------------------------------------------------------------


SCODE CExposedDocFile::MoveElementWorker(WCHAR const *pwcsName,
                                         IStorage *pstgParent,
                                         OLECHAR const *ptcsNewName,
                                         DWORD grfFlags)
{
    IUnknown *punksrc = NULL;
    SCODE sc;
    IUnknown *punkdst = NULL;
    IStorage *pstgsrc;
    STATSTG statstg;
    BOOL fCreate = TRUE;
    
    // Determine source type
    sc = GetScode(OpenStorage(pwcsName, NULL,
                              STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                              NULL, NULL, &pstgsrc));
    if (SUCCEEDED(sc))
    {
        HRESULT hr;

        //  It's a storage
        punksrc = pstgsrc;

        IStorage *pstgdst;
        olHChkTo(EH_UnkSrc, pstgsrc->Stat(&statstg, STATFLAG_NONAME));

        hr = pstgParent->CreateStorage(ptcsNewName,
                                       STGM_DIRECT | STGM_WRITE |
                                       STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                                       0, 0, &pstgdst);
        if (DfGetScode(hr) == STG_E_FILEALREADYEXISTS &&
            grfFlags == STGMOVE_COPY)
        {
            fCreate = FALSE;
            //If we're opening an existing thing for merging, we need
            //  read and write permissions so we can traverse the tree.
            hr = pstgParent->OpenStorage(ptcsNewName, NULL,
                                         STGM_DIRECT | STGM_READWRITE |
                                         STGM_SHARE_EXCLUSIVE, NULL,
                                         0, &pstgdst);
        }
        olHChkTo(EH_UnkSrc, hr);

        punkdst = pstgdst;

        sc = DfGetScode(pstgsrc->CopyTo(0, NULL, NULL, pstgdst));
    }
    else if (sc == STG_E_FILENOTFOUND)
    {
        //  Try opening it as a stream
        HRESULT hr;
        
        IStream *pstmsrc, *pstmdst;
        olHChk(OpenStream(pwcsName, NULL,
                          STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                          NULL, &pstmsrc));

        //  It's a stream
        punksrc = pstmsrc;

        olHChkTo(EH_UnkSrc, pstmsrc->Stat(&statstg, STATFLAG_NONAME));

        hr = pstgParent->CreateStream(ptcsNewName,
                                      STGM_DIRECT | STGM_WRITE |
                                      STGM_SHARE_EXCLUSIVE |
                                      STGM_FAILIFTHERE,
                                      0, 0, &pstmdst);
        if (DfGetScode(hr) == STG_E_FILEALREADYEXISTS &&
            grfFlags == STGMOVE_COPY)
        {
            ULARGE_INTEGER uli;
            uli.QuadPart = 0;
            
            fCreate = FALSE;
            //Try to open it instead
            //Note:  We do this instead of doing a CreateStream with
            //  STGM_CREATE because CreateStream can open over an already
            //  open stream, which leads to problems when the destination
            //  and the source are the same.
            olHChkTo(EH_UnkSrc, pstgParent->OpenStream(ptcsNewName,
                                                       0,
                                                       STGM_DIRECT |
                                                       STGM_WRITE |
                                                       STGM_SHARE_EXCLUSIVE,
                                                       0,
                                                       &pstmdst));
            sc = pstmdst->SetSize(uli);
            if (FAILED(sc))
            {
                pstmdst->Release();
                olErr(EH_UnkSrc, sc);
            }
        }
        else
            olHChkTo(EH_UnkSrc, hr);

        punkdst = pstmdst;

        ULARGE_INTEGER cb;
        ULISetLow (cb, 0xffffffff);
        ULISetHigh(cb, 0xffffffff);
        sc = DfGetScode(pstmsrc->CopyTo(pstmdst, cb, NULL, NULL));
    }
    else
        olChk(sc);

    punkdst->Release();

    if (SUCCEEDED(sc))
    {
        //  Make destination create time match source create time
        //  Note that we don't really care if this call succeeded.

        pstgParent->SetElementTimes(ptcsNewName, &statstg.ctime,
                                    NULL, NULL);

	//OK to ignore failure from DestroyElement
        if ((grfFlags & STGMOVE_COPY) == STGMOVE_MOVE)
            DestroyElement(pwcsName);
    }
    else
    {
        //  The copy/move failed, so get rid of the partial result.
        //Only do a delete if the object was newly created.
        if (fCreate)
            pstgParent->DestroyElement(ptcsNewName);
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::MoveElementTo\n"));
    // Fall through
EH_UnkSrc:
    if (punksrc)
        punksrc->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameElement, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pwcsName] - Current name
//              [pwcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::RenameElement(WCHAR const *pwcsName,
                                             WCHAR const *pwcsNewName)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CDfName dfnOld, dfnNew;

    olLog(("%p::In  CExposedDocFile::RenameElement(%ws, %ws)\n",
           this, pwcsName, pwcsNewName));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::RenameElement(%ws, %ws)\n",
               pwcsName, pwcsNewName));

    OL_VALIDATE(RenameElement(pwcsName,
                              pwcsNewName));
    
    olChk(Validate());
    dfnOld.Set(pwcsName);
    dfnNew.Set(pwcsNewName);

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->RenameEntry(&dfnOld, &dfnNew);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::RenameElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::RenameElement().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetElementTimes, public
//
//  Synopsis:   Sets element time stamps
//
//  Arguments:  [pwcsName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::SetElementTimes(WCHAR const *pwcsName,
                                               FILETIME const *pctime,
                                               FILETIME const *patime,
                                               FILETIME const *pmtime)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CDfName dfn;
    CDfName *pdfn = NULL;
    FILETIME ctime, atime, mtime;

    olLog(("%p::In  CExposedDocFile::SetElementTimes(%ws, %p, %p, %p)\n",
           this, pwcsName, pctime, patime, pmtime));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SetElementTimes:%p("
                "%ws, %p, %p, %p)\n", this, pwcsName, pctime, patime, pmtime));

    OL_VALIDATE(SetElementTimes(pwcsName,
                                pctime,
                                patime,
                                pmtime));
    olChk(Validate());
    // Probe arguments and make local copies if necessary
    if (pctime)
    {
        ctime = *pctime;
        pctime = &ctime;
    }
    if (patime)
    {
        atime = *patime;
        patime = &atime;
    }
    if (pmtime)
    {
        mtime = *pmtime;
        pmtime = &mtime;
    }

    if (pwcsName != NULL)
    {
        dfn.Set(pwcsName);
        pdfn = &dfn;
    }

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->SetElementTimes(pdfn, pctime, patime, pmtime);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SetElementTimes\n"));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::SetElementTimes().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::SetClass(REFCLSID rclsid)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CLSID clsid;

    olLog(("%p::In  CExposedDocFile::SetClass(?)\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SetClass:%p(?)\n", this));

    OL_VALIDATE(SetClass(rclsid));
    olChk(Validate());
    clsid = rclsid;

    BEGIN_PENDING_LOOP;
        olChk(TakeSafeSem());
        SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
        olChk(ValidateWriteAccess());
#endif

        sc = _pdf->SetClass(clsid);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SetClass\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetClass().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetStateBits, public
//
//  Synopsis:   Sets state bits
//
//  Arguments:  [grfStateBits] - state bits
//              [grfMask] - state bits mask
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::SetStateBits(%lu, %lu)\n", this,
           grfStateBits, grfMask));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SetStateBits:%p("
                "%lu, %lu)\n", this, grfStateBits, grfMask));

    OL_VALIDATE(SetStateBits(grfStateBits, grfMask));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->SetStateBits(grfStateBits, grfMask);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SetStateBits\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetStateBits().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SAFE_SEM;
    SAFE_ACCESS;
    SCODE sc;
    STATSTGW stat;

    olLog(("%p::In  CExposedDocFile::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Stat(%p)\n", pstatstg));

    OL_VALIDATE(Stat(pstatstg, grfStatFlag));

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    sc = _pdf->Stat(&stat, grfStatFlag);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
    {
        TRY
        {
            *pstatstg = stat;
            pstatstg->type = STGTY_STORAGE;
            ULISet32(pstatstg->cbSize, 0);
            pstatstg->grfLocksSupported = 0;
            pstatstg->STATSTG_dwStgFmt = 0;
        }
        CATCH(CException, e)
        {
            UNREFERENCED_PARM(e);
            if (stat.pwcsName)
                TaskMemFree(stat.pwcsName);
        }
        END_CATCH
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Stat\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Stat().  *pstatstg == %p  ret == %lx\n",
           this, *pstatstg, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedDocFile::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedDocFile::AddRef()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::AddRef()\n"));

    if (FAILED(Validate()))
        return 0;
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::AddRef %p()=> %lu\n",
                this, _cReferences));
    olLog(("%p::Out CExposedDocFile::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::QueryInterface(?, %p)\n",
                ppvObj));

    OL_VALIDATE(QueryInterface(iid, ppvObj));

    olChk(Validate());
    olChk(_pdf->CheckReverted());

    sc = S_OK;
    if (IsEqualIID(iid, IID_IStorage) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStorage *)this;
        CExposedDocFile::AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        if (P_PRIORITY(_pdf->GetDFlags()) && _pdf->IsRoot())
            olErr(EH_Err, E_NOINTERFACE);

        //If the ILockBytes we'd need to marshal doesn't support IMarshal
        //  then we want to do standard marshalling on the storage, mostly
        //  to prevent deadlock problems but also because you'll get better
        //  performance.  So check, then do the right thing.

        IMarshal *pim;
        ILockBytes *plkb;
        plkb = _ppc->GetOriginal();
        if (plkb == NULL)
        {
            plkb = _ppc->GetBase();
        }

        sc = plkb->QueryInterface(IID_IMarshal, (void **)&pim);
        if (FAILED(sc))
        {
            olErr(EH_Err, E_NOINTERFACE);
        }
        pim->Release();

#ifdef MULTIHEAP
        if (_ppc->GetHeapBase() == NULL)
            olErr (EH_Err, E_NOINTERFACE);
#endif

        *ppvObj = (IMarshal *)this;
        CExposedDocFile::AddRef();
    }
    else if (IsEqualIID(iid, IID_IRootStorage))
    {
#ifdef COORD
        if ((!_pdf->IsRoot()) && (!_pdf->IsCoord()))
#else
        if (!_pdf->IsRoot())
#endif
            olErr(EH_Err, E_NOINTERFACE);
        *ppvObj = (IRootStorage *)this;
        CExposedDocFile::AddRef();
    }
#ifdef NEWPROPS
    else if (IsEqualIID(iid, IID_IPropertySetStorage))
    {
        *ppvObj = (IPropertySetStorage *)this;
        CExposedDocFile::AddRef();
    }

#endif
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IConnectionPointContainer) &&
              _cpoint.IsInitialized())
    {
        *ppvObj = (IConnectionPointContainer *)this;
        CExposedDocFile::AddRef();
    }
#endif
#if WIN32 >= 300
    else if (_pdf->IsRoot() && IsEqualIID(iid, IID_IAccessControl))
    {
        ILockBytes *piLB = _pdf->GetBaseMS()->GetILB();
        olAssert((piLB != NULL));
        SCODE scode = S_OK;
        if (_pIAC == NULL)  // use existing _pIAC if available
            scode = piLB->QueryInterface(IID_IAccessControl,(void **)&_pIAC);
        if (SUCCEEDED(scode))
        {
            *ppvObj = (IAccessControl *)this;
            CExposedDocFile::AddRef();
        }
        else sc = E_NOINTERFACE;
   }
#endif
#ifdef DIRECTWRITERLOCK
    else if (_pdf->IsRoot() && IsEqualIID(iid, IID_IDirectWriterLock) &&
             _pdfb->DirectWriterMode())
    {
        *ppvObj = (IDirectWriterLock *) this;
        CExposedDocFile::AddRef();
    }
#endif // DIRECTWRITERLOCK

    else if( IsEqualIID( iid, IID_IPropertyBagEx ))
    {
        *ppvObj = static_cast<IPropertyBagEx*>(&_PropertyBagEx);
        CExposedDocFile::AddRef();
    }
    else if( IsEqualIID( iid, IID_IPropertyBag ))
    {
        *ppvObj = static_cast<IPropertyBag*>(&_PropertyBagEx);
        CExposedDocFile::AddRef();
    }

    else
        sc = E_NOINTERFACE;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::QueryInterface => %p\n",
                *ppvObj));
EH_Err:
    olLog(("%p::Out CExposedDocFile::QueryInterface().  "
           "*ppvObj == %p  ret == %lx\n", this, *ppvObj, sc));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopySStreamToIStream, private
//
//  Synopsis:   Copies a PSStream to an IStream
//
//  Arguments:  [psstFrom] - SStream
//              [pstTo] - IStream
//
//  Returns:    Appropriate status code
//
//  History:    07-May-92       DrewB   Created
//              26-Jun-92       AlexT   Moved to CExposedDocFile
//                                      so we can call SetReadAccess
//
//---------------------------------------------------------------


SCODE CExposedDocFile::CopySStreamToIStream(PSStream *psstFrom,
                                            IStream *pstTo)
{
    BYTE *pbBuffer;
    SCODE sc;
#ifdef LARGE_STREAMS
    ULONGLONG cbPos;
    ULONG cbRead, cbWritten;
#else
    ULONG cbRead, cbWritten, cbPos, cbSizeLow;
#endif
    ULONG ulBufferSize;
    ULARGE_INTEGER cbSize;
    cbSize.QuadPart = 0;

    ulBufferSize = (_pdfb->GetOpenFlags() & DF_LARGE) ?
                    LARGESTREAMBUFFERSIZE : STREAMBUFFERSIZE;

    // This is part of CopyTo and therefore we are allowed to
    // fail with out-of-memory
    olChk(GetBuffer(STREAMBUFFERSIZE, ulBufferSize, &pbBuffer, &ulBufferSize));

    // Set destination size for contiguity
    SetReadAccess();
#ifdef LARGE_STREAMS
    psstFrom->GetSize(&cbSize.QuadPart);
#else
    psstFrom->GetSize(&cbSize.LowPart);
    cbSize.HighPart = 0;
#endif
    ClearReadAccess();

    //  Don't need to SetReadAccess here because pstTo is an IStream
    olHChk(pstTo->SetSize(cbSize));
    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        SetReadAccess();
        olChk(psstFrom->ReadAt(cbPos, pbBuffer, ulBufferSize,
                               (ULONG STACKBASED *)&cbRead));
        ClearReadAccess();
        if (cbRead == 0) // EOF
            break;

        //  Don't need to SetReadAccess here because pstTo is an IStream
        olHChk(pstTo->Write(pbBuffer, cbRead, &cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }
    sc = S_OK;

EH_Err:
    DfMemFree(pbBuffer);
    return sc;
}


//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopyDocFileToIStorage, private
//
//  Synopsis:   Copies a docfile's contents to an IStorage
//
//  Arguments:  [pdfFrom] - From
//              [pstgTo] - To
//              [snbExclude] - Names to not copy
//              [dwCopyFlags] - Bitwise flags for types of objects to copy
//
//  Returns:    Appropriate status code
//
//  History:    07-May-92       DrewB   Created
//              26-Jun-92       AlexT   Moved to CExposedDocFile
//                                      so we can call SetReadAccess
//
//---------------------------------------------------------------


// Variables used by CopyDocFileToIStorage that we
// want to allocate dynamically rather than eating stack space
struct SCopyVars : public CLocalAlloc
{
    PSStream *psstFrom;
    IStream *pstTo;
    PDocFile *pdfFromChild;
    IStorage *pstgToChild;
    DWORD grfStateBits;
    CLSID clsid;
    CDfName dfnKey;
    SIterBuffer ib;
    OLECHAR atcName[CWCSTORAGENAME];
};

SCODE CExposedDocFile::CopyDocFileToIStorage(PDocFile *pdfFrom,
                                             IStorage *pstgTo,
                                             SNBW snbExclude,
                                             DWORD dwCopyFlags)
{
    SCODE sc;
    SCopyVars *pcv = NULL;

    olDebugOut((DEB_ITRACE, "In  CopyDocFileToIStorage:%p(%p, %p, %p, %lX)\n",
                this, pdfFrom, pstgTo, snbExclude, dwCopyFlags));

    // Allocate variables dynamically to conserve stack space since
    // this is a recursive call
    olMem(pcv = new SCopyVars);

    SetReadAccess();
    sc = pdfFrom->GetClass(&pcv->clsid);
    ClearReadAccess();
    olChk(sc);

    // Assume STG_E_INVALIDFUNCTION means that the destination storage
    // doesn't support class IDs
    sc = GetScode(pstgTo->SetClass(pcv->clsid));
    if (FAILED(sc) && sc != STG_E_INVALIDFUNCTION)
        olErr(EH_Err, sc);

    SetReadAccess();
    sc = pdfFrom->GetStateBits(&pcv->grfStateBits);
    ClearReadAccess();
    olChk(sc);

    sc = GetScode(pstgTo->SetStateBits(pcv->grfStateBits, 0xffffffff));
    if (FAILED(sc) && sc != STG_E_INVALIDFUNCTION)
        olErr(EH_Err, sc);

    for (;;)
    {
        SetReadAccess();
        sc = pdfFrom->FindGreaterEntry(&pcv->dfnKey, &pcv->ib, NULL);
        ClearReadAccess();

        if (sc == STG_E_NOMOREFILES)
            break;
        else if (FAILED(sc))
            olErr(EH_pdfi, sc);
        pcv->dfnKey.Set(&pcv->ib.dfnName);

        if (snbExclude && NameInSNB(&pcv->ib.dfnName, snbExclude) == S_OK)
            continue;

        if ((pcv->ib.type == STGTY_STORAGE &&
             (dwCopyFlags & COPY_STORAGES) == 0) ||
            (pcv->ib.type == STGTY_STREAM &&
             (dwCopyFlags & COPY_STREAMS) == 0))
            continue;

        switch(pcv->ib.type)
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            SetReadAccess();
            sc = pdfFrom->GetDocFile(&pcv->ib.dfnName, DF_READ,
                                     pcv->ib.type, &pcv->pdfFromChild);
            ClearReadAccess();
            olChkTo(EH_pdfi, sc);
            // Not optimally efficient, but reduces #ifdef's
            StringCbCopyW (pcv->atcName, sizeof(pcv->atcName), (WCHAR *)pcv->ib.dfnName.GetBuffer());

            //  Don't need to SetReadAccess here because pstgTo is an IStorage.

#ifdef MULTIHEAP
            {
                CSafeMultiHeap smh(_ppc);
                // if pstgTo is an IStorage proxy, then returned IStorage
                // can be custom marshaled and allocator state is lost
#endif
            sc = DfGetScode(pstgTo->CreateStorage(pcv->atcName, STGM_WRITE |
                                                  STGM_SHARE_EXCLUSIVE |
                                                  STGM_FAILIFTHERE,
                                                  0, 0, &pcv->pstgToChild));

            if (sc == STG_E_FILEALREADYEXISTS)
                //We need read and write permissions so we can traverse
                //  the destination IStorage
                olHChkTo(EH_Get, pstgTo->OpenStorage(pcv->atcName, NULL,
                                                     STGM_READWRITE |
                                                     STGM_SHARE_EXCLUSIVE,
                                                     NULL, 0,
                                                     &pcv->pstgToChild));
            else if (FAILED(sc))
                olErr(EH_Get, sc);
#ifdef MULTIHEAP
            }
#endif
            olChkTo(EH_Create,
                  CopyDocFileToIStorage(pcv->pdfFromChild, pcv->pstgToChild,
                                        NULL, dwCopyFlags));
            pcv->pdfFromChild->Release();
            pcv->pstgToChild->Release();
            break;

        case STGTY_STREAM:
            SetReadAccess();
            sc = pdfFrom->GetStream(&pcv->ib.dfnName, DF_READ,
                                    pcv->ib.type, &pcv->psstFrom);
            ClearReadAccess();
            olChkTo(EH_pdfi, sc);
            // Not optimally efficient, but reduces #ifdef's
            StringCbCopyW (pcv->atcName, sizeof(pcv->atcName), (WCHAR *)pcv->ib.dfnName.GetBuffer());

            //  Don't need to SetReadAccess here because pstgTo is an IStorage.

#ifdef MULTIHEAP
            {
                CSafeMultiHeap smh(_ppc);
                // if pstgTo is an IStorage proxy, then returned IStream
                // can be custom marshaled and allocator state is lost
#endif
            olHChkTo(EH_Get,
                     pstgTo->CreateStream(pcv->atcName, STGM_WRITE |
                                          STGM_SHARE_EXCLUSIVE |
                                          STGM_CREATE,
                                          0, 0, &pcv->pstTo));
#ifdef MULTIHEAP
            }
#endif
            olChkTo(EH_Create,
                    CopySStreamToIStream(pcv->psstFrom, pcv->pstTo));
            pcv->psstFrom->Release();
            pcv->pstTo->Release();
            break;

        default:
            olAssert(!aMsg("Unknown type in CopyDocFileToIStorage"));
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CopyDocFileToIStorage\n"));
    sc = S_OK;

 EH_pdfi:
 EH_Err:
    delete pcv;
    return sc;

 EH_Create:
    if (pcv->ib.type == STGTY_STORAGE)
        pcv->pstgToChild->Release();
    else
        pcv->pstTo->Release();
    olVerSucc(pstgTo->DestroyElement(pcv->atcName));
 EH_Get:
    if (pcv->ib.type == STGTY_STORAGE)
        pcv->pdfFromChild->Release();
    else
        pcv->psstFrom->Release();
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Unmarshal, public
//
//  Synopsis:   Creates a duplicate DocFile from parts
//
//  Arguments:  [pstm] - Marshal stream
//              [ppv] - Object return
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    26-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CExposedDocFile::Unmarshal(IStream *pstm,
                                 void **ppv,
                                 DWORD mshlflags)
{
    SCODE sc;
    CDfMutex mtx;
    CPerContext *ppc;
    CPubDocFile *pdf;
    CGlobalContext *pgc;
    CDFBasis *pdfb;
    CExposedDocFile *pedf;
    IStorage *pstgStd = NULL;
    ULONG_PTR df;
    
#ifdef ASYNC
    DWORD dwAsyncFlags;
    IDocfileAsyncConnectionPoint *pdacp;
#endif
#ifdef POINTER_IDENTITY
    CMarshalList *pml;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Unmarshal(%p, %p)\n",
                pstm, ppv));

#ifdef MULTIHEAP
    void *pvBaseOld;
    void *pvBaseNew;
    ContextId cntxid;
    CPerContext pcSharedMemory (NULL);          // bootstrap object
#endif

    //First unmarshal the standard marshalled version
    sc = CoUnmarshalInterface(pstm, IID_IStorage, (void**)&pstgStd);
    if (FAILED(sc))
    {
        // assume that entire standard marshaling stream has been read
        olAssert (pstgStd == NULL);
        sc = S_OK;
    }
    
#ifdef MULTIHEAP
    sc = UnmarshalSharedMemory(pstm, mshlflags, &pcSharedMemory, &cntxid);
    if (!SUCCEEDED(sc))
    {
#ifdef POINTER_IDENTITY
        UnmarshalPointer(pstm, (void **) &pedf);
#endif
        UnmarshalPointer(pstm, (void **)&pdf);
        UnmarshalPointer(pstm, (void **)&pdfb);
        UnmarshalPointer(pstm, (void **)&df);
#ifdef ASYNC
        ReleaseContext(pstm, TRUE, P_INDEPENDENT(df) != 0, mshlflags);
        ReleaseConnection(pstm, mshlflags);
#else
        ReleaseContext(pstm, P_INDEPENDENT(df), mshlflags);
#endif
        olChkTo(EH_std, sc);
    }
    pvBaseOld = DFBASEPTR;
#endif
#ifdef POINTER_IDENTITY
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **) &pedf));
#endif
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **)&pdf));
    olChkTo(EH_mem, CPubDocFile::Validate(pdf));
    olChkTo(EH_pdf, UnmarshalPointer(pstm, (void **)&pdfb));
    olChkTo(EH_pdfb, UnmarshalPointer(pstm, (void **) &df));
    olChkTo(EH_pdfb, UnmarshalPointer(pstm, (void **)&pgc));
    olChkTo(EH_pgc, ValidateBuffer(pgc, sizeof(CGlobalContext)));

    //So far, nothing has called into the tree so we don't really need
    //  to be holding the tree mutex.  The UnmarshalContext call does
    //  call into the tree, though, so we need to make sure this is
    //  threadsafe.  We'll do this my getting the mutex name from the
    //  CGlobalContext, then creating a new CDfMutex object.  While
    //  this is obviously not optimal, since it's possible we could
    //  reuse an existing CDfMutex, the reuse strategy isn't threadsafe
    //  since we can't do a lookup without the possibility of the thing
    //  we're looking for being released by another thread.
    TCHAR atcMutexName[CONTEXT_MUTEX_NAME_LENGTH];
    pgc->GetMutexName(atcMutexName);
    olChkTo(EH_pgc, mtx.Init(atcMutexName));
    olChkTo(EH_pgc, mtx.Take(INFINITE));

    //At this point we're holding the mutex.

#ifdef MULTIHEAP
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     cntxid,
                                     pdf->IsRoot()));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     cntxid,
                                     pdf->IsRoot()));
#endif
    if ((pvBaseNew = DFBASEPTR) != pvBaseOld)
    {
        pdf = (CPubDocFile*) ((ULONG_PTR)pdf - (ULONG_PTR)pvBaseOld
                                            + (ULONG_PTR)pvBaseNew);
        pedf = (CExposedDocFile*) ((ULONG_PTR)pedf - (ULONG_PTR)pvBaseOld
                                                  + (ULONG_PTR)pvBaseNew);
        pdfb = (CDFBasis*) ((ULONG_PTR)pdfb - (ULONG_PTR)pvBaseOld
                                           + (ULONG_PTR)pvBaseNew);
    }
#else
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     pdf->IsRoot()));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     pdf->IsRoot()));
#endif //ASYNC
#endif

#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalConnection(pstm,
                                        &dwAsyncFlags,
                                        &pdacp,
                                        mshlflags));
#endif
    // if we use up 1Gig of address space, use standard unmarshaling
    if (gs_iSharedHeaps > (DOCFILE_SM_LIMIT / DOCFILE_SM_SIZE))
        olErr (EH_ppc, STG_E_INSUFFICIENTMEMORY);

#ifdef POINTER_IDENTITY
    olAssert (pedf != NULL);
    pml = (CMarshalList *) pedf;

    // Warning: these checks must remain valid across processes
    if (SUCCEEDED(pedf->Validate()) && pedf->GetPub() == pdf)
    {
        pedf = (CExposedDocFile *) pml->FindMarshal(GetCurrentContextId());
    }
    else
    {
        pml = NULL;
        pedf = NULL;
    }

    // exposed object is not found or has been deleted
    if (pedf == NULL)
    {
#endif
        olMemTo(EH_ppc, pedf = new (pdfb->GetMalloc())
                               CExposedDocFile(pdf, pdfb, ppc));
        olChkTo(EH_exp, pedf->InitMarshal(dwAsyncFlags, pdacp));
        //InitMarshal adds a reference.
        if (pdacp)
            pdacp->Release();

#ifdef POINTER_IDENTITY
        if (pml) pml->AddMarshal(pedf);
        pdf->vAddRef();  // CExposedDocFile ctor does not AddRef
    }
    else
    {
        pdfb->SetAccess(ppc);
        pedf->AddRef();         // reuse this object
        ppc->Release();         // reuse percontext
    }
#else
    pdf->vAddRef();
#endif

    *ppv = (void *)pedf;
#ifdef MULTIHEAP
    if (pvBaseOld != pvBaseNew)
    {
        pcSharedMemory.SetThreadAllocatorState(NULL);
        g_smAllocator.Uninit();           // delete the extra mapping
    }
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

    mtx.Release();

    //We're returning the custom marshalled version, so we don't need
    //the std marshalled one anymore.
    if (pstgStd != NULL)
        pstgStd->Release();

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Unmarshal => %p\n", *ppv));
    return S_OK;
 EH_exp:
    pedf->Release();
    goto EH_Err;
 EH_ppc:
    ppc->Release();
 EH_mtx:
    mtx.Release();
    goto EH_Err;
 EH_pgc:
    CoReleaseMarshalData(pstm); // release the ILockBytes
    CoReleaseMarshalData(pstm); // release the ILockBytes
    if (P_INDEPENDENT(pdf->GetDFlags()))
        CoReleaseMarshalData(pstm); // release the ILockBytes
#ifdef ASYNC
    ReleaseConnection(pstm, mshlflags);
#endif

 EH_pdfb:
 EH_pdf:
 EH_mem:
EH_Err:
#ifdef MULTIHEAP
    pcSharedMemory.SetThreadAllocatorState(NULL);
    g_smAllocator.Uninit();   // delete the file mapping in error case
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif
 EH_std:
    if (pstgStd != NULL)
    {
        //We can return the standard marshalled version and still succeed.
        *ppv = pstgStd;
        return S_OK;
    }
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::GetUnmarshalClass(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPCLSID pcid)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::GetUnmarshalClass("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcid));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::GetUnmarshalClass:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this,
                pv, dwDestContext, pvDestContext, mshlflags, pcid));

    UNREFERENCED_PARM(pv);
    UNREFERENCED_PARM(mshlflags);

    olChk(ValidateOutBuffer(pcid, sizeof(CLSID)));
    memset(pcid, 0, sizeof(CLSID));
    olChk(ValidateIid(riid));
    olChk(Validate());
    olChk(_pdf->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetUnmarshalClass(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcid));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(VerifyIid(riid, IID_IStorage));
        *pcid = CLSID_DfMarshal;
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::GetUnmarshalClass\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::GetUnmarshalClass().  ret = %lx\n",
        this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::GetMarshalSizeMax(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPDWORD pcbSize)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    UNREFERENCED_PARM(pv);
    olLog(("%p::In  CExposedDocFile::GetMarshalSizeMax("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcbSize));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::GetMarshalSizeMax:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this,
                pv, dwDestContext, pvDestContext, mshlflags, pcbSize));

    olChk(Validate());
    olChk(_pdf->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcbSize));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        sc = GetStdMarshalSize(riid,
                               IID_IStorage,
                               dwDestContext,
                               pvDestContext,
                               mshlflags, pcbSize,
                               sizeof(CPubDocFile *)+sizeof(CDFBasis *)+
                               sizeof(DFLAGS),
#ifdef ASYNC
                               &_cpoint,
                               TRUE,
#endif
                               _ppc, P_INDEPENDENT(_pdf->GetDFlags()));
        DWORD cbSize = 0;
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  &cbSize));
            pmsh->Release();
            *pcbSize += cbSize;
        }
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::GetMarshalSizeMax\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::GetMarshalSizeMax()."
           "*pcbSize == %lu, ret == %lx\n", this, *pcbSize, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::MarshalInterface(IStream *pstStm,
                                               REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::MarshalInterface("
           "%p, riid, %p, %lu, %p, %lu).  Context == %lX\n",
           this, pstStm, pv, dwDestContext,
           pvDestContext, mshlflags,(ULONG)GetCurrentContextId()));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::MarshalInterface:%p("
                "%p, riid, %p, %lu, %p, %lu)\n", this, pstStm, pv,
                dwDestContext, pvDestContext, mshlflags));

    UNREFERENCED_PARM(pv);

    olChk(Validate());
    olChk(_pdf->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->MarshalInterface(pstStm, riid, pv,
                                                 dwDestContext, pvDestContext,
                                                 mshlflags));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(StartMarshal(pstStm, riid, IID_IStorage, mshlflags));

        //Always standard marshal, in case we get an error during
        //unmarshalling of the custom stuff.
        {
            IMarshal *pmsh;
            if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                               dwDestContext, pvDestContext,
                                               mshlflags, &pmsh)))
            {
                sc = GetScode(pmsh->MarshalInterface(pstStm, riid, pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags));
                pmsh->Release();
            }
            olChk(sc);
        }
        
#ifdef MULTIHEAP
        olChk(MarshalSharedMemory(pstStm, _ppc));
#endif
#ifdef POINTER_IDENTITY
        olChk(MarshalPointer(pstStm, (CExposedDocFile*) GetNextMarshal()));
#endif
        olChk(MarshalPointer(pstStm, BP_TO_P(CPubDocFile *, _pdf)));
        olChk(MarshalPointer(pstStm, BP_TO_P(CDFBasis *, _pdfb)));
        olChk(MarshalPointer(pstStm, (void *) LongToPtr(_pdf->GetDFlags()) ));
#ifdef ASYNC
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             TRUE,
                             P_INDEPENDENT(_pdf->GetDFlags())));

        sc = MarshalConnection(pstStm,
                                &_cpoint,
                                dwDestContext,
                                pvDestContext,
                                mshlflags);
#else
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             P_INDEPENDENT(_pdf->GetDFlags())));
#endif

    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::MarshalInterface\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::MarshalInterface().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::UnmarshalInterface(IStream *pstStm,
                                                 REFIID riid,
                                                 void **ppvObj)
{
    olLog(("%p::INVALID CALL TO CExposedDocFile::UnmarshalInterface()\n",
           this));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::StaticReleaseMarshalData, public static
//
//  Synopsis:   Releases any references held in marshal data
//
//  Arguments:  [pstStm] - Marshal data stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Feb-94       DrewB   Created
//
//  Notes:      Assumes standard marshal header has already been read
//
//---------------------------------------------------------------


SCODE CExposedDocFile::StaticReleaseMarshalData(IStream *pstStm,
                                                DWORD mshlflags)
{
    SCODE sc;
    CPubDocFile *pdf;
    CDFBasis *pdfb;
    ULONG_PTR df;
#ifdef POINTER_IDENTITY
    CExposedDocFile *pedf;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::StaticReleaseMarshalData:("
                "%p, %lX)\n", pstStm, mshlflags));

    //First unmarshal the standard marshalled version

    olChk(CoReleaseMarshalData(pstStm));
    // The final release of the exposed object may have shut down the
    // shared memory heap, so do not access shared memory after this point

    //Then do the rest of it.
#ifdef MULTIHEAP
    olChk(SkipSharedMemory(pstStm, mshlflags));
#endif
#ifdef POINTER_IDENTITY
    olChk(UnmarshalPointer(pstStm, (void **) &pedf));
#endif
    olChk(UnmarshalPointer(pstStm, (void **)&pdf));
    olChk(UnmarshalPointer(pstStm, (void **)&pdfb));
    olChk(UnmarshalPointer(pstStm, (void **)&df));
#ifdef ASYNC
    olChk(ReleaseContext(pstStm, TRUE,
                         P_INDEPENDENT(df) != 0,
                         mshlflags));
    olChk(ReleaseConnection(pstStm, mshlflags));
#else
    olChk(ReleaseContext(pstStm, P_INDEPENDENT(df), mshlflags));
#endif

#ifdef MULTIHEAP
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

    olDebugOut((DEB_ITRACE,
                "Out CExposedDocFile::StaticReleaseMarshalData\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    DWORD mshlflags;
    IID iid;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::ReleaseMarshalData(%p)\n", this, pstStm));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::ReleaseMarshalData:%p(%p)\n",
                this, pstStm));

    olChk(Validate());
    olChk(_pdf->CheckReverted());
    olChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    olAssert(IsEqualIID(iid, IID_IStorage));
    sc = StaticReleaseMarshalData(pstStm, mshlflags);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::ReleaseMarshalData\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::ReleaseMarshalData().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::DisconnectObject(DWORD dwReserved)
{
    olLog(("%p::INVALID CALL TO CExposedDocFile::DisconnectObject()\n",
           this));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::SwitchToFile, public
//
//  Synopsis:   Switches the underlying file to another file
//
//  Arguments:  [ptcsFile] - New file name
//
//  Returns:    Appropriate status code
//
//  History:    08-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SwitchToFile(OLECHAR *ptcsFile)
{

    ULONG ulOpenLock;
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::SwitchToFile(" OLEFMT ")\n",
           this, ptcsFile));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SwitchToFile:"
                "%p(" OLEFMT ")\n",
                this, ptcsFile));

    olChk(ValidateNameW(ptcsFile, _MAX_PATH));
    olChk(Validate());

    olChk(TakeSafeSem());
    olChk(_pdf->CheckReverted());
#ifdef COORD
    olAssert(_pdf->IsRoot() || _pdf->IsCoord());
#else
    olAssert(_pdf->IsRoot());
#endif

    SafeReadAccess();

    ulOpenLock = _ppc->GetOpenLock();
#ifdef COORD
    sc = _pdf->GetRoot()->SwitchToFile(ptcsFile,
                                       _ppc->GetOriginal(),
                                       &ulOpenLock);
#else
    sc = ((CRootPubDocFile *)(CPubDocFile*)_pdf)->SwitchToFile(ptcsFile,
                                                 _ppc->GetOriginal(),
                                                 &ulOpenLock);
#endif

    _ppc->SetOpenLock(ulOpenLock);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SwitchToFile\n"));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::SwitchToFile().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

#if WIN32 >= 300
             // IAccessControl methods
STDMETHODIMP CExposedDocFile::GrantAccessRights(ULONG cCount,
                                ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->GrantAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::SetAccessRights(ULONG cCount,
                              ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->SetAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::ReplaceAllAccessRights(ULONG cCount,
                                     ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->ReplaceAllAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::DenyAccessRights(ULONG cCount,
                              ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->DenyAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::RevokeExplicitAccessRights(ULONG cCount,
                                         TRUSTEE pTrustee[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->RevokeExplicitAccessRights(cCount, pTrustee);
}

STDMETHODIMP CExposedDocFile::IsAccessPermitted(TRUSTEE *pTrustee,
                                 DWORD grfAccessPermissions)
{
    olAssert((_pIAC != NULL));
    return _pIAC->IsAccessPermitted(pTrustee, grfAccessPermissions);
}

STDMETHODIMP CExposedDocFile::GetEffectiveAccessRights(TRUSTEE *pTrustee,
                                       DWORD *pgrfAccessPermissions )
{
    olAssert((_pIAC != NULL));
    return _pIAC->GetEffectiveAccessRights(pTrustee, pgrfAccessPermissions);
}

STDMETHODIMP CExposedDocFile::GetExplicitAccessRights(ULONG *pcCount,
                                      PEXPLICIT_ACCESS *pExplicitAccessList)
{
    olAssert((_pIAC != NULL));
    return _pIAC->GetExplicitAccessRights(pcCount, pExplicitAccessList);
}

STDMETHODIMP CExposedDocFile::CommitAccessRights(DWORD grfCommitFlags)
{
    olAssert((_pIAC != NULL));
    return _pIAC->CommitAccessRights(grfCommitFlags);
}

STDMETHODIMP CExposedDocFile::RevertAccessRights()
{
    olAssert((_pIAC != NULL));
    return _pIAC->RevertAccessRights();
}



#endif // if WIN32 >= 300


#ifdef COORD
//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CommitPhase1, public
//
//  Synopsis:   Do phase 1 of an exposed two phase commit
//
//  Arguments:  [grfCommitFlags] -- Commit flags
//
//  Returns:    Appropriate status code
//
//  History:    08-Aug-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CExposedDocFile::CommitPhase1(DWORD grfCommitFlags)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olChk(VerifyCommitFlags(grfCommitFlags));
    olChk(Validate());

    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->CommitPhase1(grfCommitFlags,
                            &_ulLock,
                            &_sigMSF,
                            &_cbSizeBase,
                            &_cbSizeOrig);
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CommitPhase2, public
//
//  Synopsis:   Do phase 2 of an exposed two phase commit
//
//  Arguments:  [grfCommitFlags] -- Commit flags
//              [fCommit] -- TRUE if transaction is to commit, FALSE if abort
//
//  Returns:    Appropriate status code
//
//  History:    08-Aug-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CExposedDocFile::CommitPhase2(DWORD grfCommitFlags,
                                    BOOL fCommit)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olChk(Validate());

    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->CommitPhase2(grfCommitFlags,
                            fCommit,
                            _ulLock,
                            _sigMSF,
                            _cbSizeBase,
                            _cbSizeOrig);

    _ulLock = _cbSizeBase = _cbSizeOrig = 0;
    _sigMSF = 0;
EH_Err:
    return sc;
}
#endif //COORD


#ifdef NEWPROPS

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::Lock, IBlockingLock
//
//  Synopsis:   Acquires the semaphore associated with the docfile.
//
//  Notes:      This member is called by CPropertyStorage.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CExposedDocFile::Lock(DWORD dwTimeout)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    TakeSem();
    SetDifferentBasisAccess(_pdfb, _ppc);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::Unlock, public IBlockingLock
//
//  Synopsis:   Releases the semaphore associated with the docfile.
//
//  Notes:      This member is called by CPropertyStorage.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CExposedDocFile::Unlock(VOID)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    ClearBasisAccess(_pdfb);
    ReleaseSem(S_OK);
    return( S_OK );
}
#endif

#ifdef DIRECTWRITERLOCK
//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::WaitForWriteAccess, public IDirectWriterLock
//
//  Synopsis:   tries to obtain exclusive write access in direct mode
//
//  Notes:      Tree mutex must be taken when accessing recursion count
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::WaitForWriteAccess (DWORD dwTimeout)
{
    SAFE_SEM;
    SAFE_ACCESS;
    HRESULT hr = TakeSafeSem();

    if (SUCCEEDED(hr) && *_ppc->GetRecursionCount() == 0)
    {
        SafeReadAccess();
        hr = _pdfb->WaitForWriteAccess (dwTimeout, _ppc->GetGlobal());
    }
    if (SUCCEEDED(hr)) ++(*_ppc->GetRecursionCount());
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::ReleaseWriteAccess, public IDirectWriterLock
//
//  Synopsis:   releases exclusive write access from WaitForWriteAccess
//
//  Notes:      Tree mutex must be taken when accessing recursion count
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::ReleaseWriteAccess ()
{
    SAFE_SEM;
    SAFE_ACCESS;
    HRESULT hr = TakeSafeSem();

    if (SUCCEEDED(hr) && *_ppc->GetRecursionCount() == 1)
    {
        SafeReadAccess();
        hr = _pdf->Commit(STGC_DEFAULT);  // Flush
        if (SUCCEEDED(hr)) hr = _pdfb->ReleaseWriteAccess();
    }
    if (SUCCEEDED(hr)) --(*_ppc->GetRecursionCount());
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::HaveWriteAccess, public IDirectWriterLock
//
//  Synopsis:   returns S_OK if write lock is active, S_FALSE if not
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::HaveWriteAccess ()
{
    SAFE_SEM;
    HRESULT hr = TakeSafeSem();

    olAssert(_pdfb->DirectWriterMode());
    if (SUCCEEDED(hr))
    {
        hr = (_pdfb->HaveWriteAccess()) ? S_OK : S_FALSE;
    }
    return hr;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ValidateWriteAccess, public
//
//  Synopsis:   returns whether writer currently has write access
//
//  Notes:      tree mutex must be taken
//
//  History:    30-Apr-96    HenryLee     Created
//
//---------------------------------------------------------------
HRESULT CExposedDocFile::ValidateWriteAccess()
{
    if (_pdf->GetTransactedDepth() >= 1)
        return S_OK;

    return (!_pdfb->DirectWriterMode() || (*_ppc->GetRecursionCount()) > 0) ?
            S_OK : STG_E_ACCESSDENIED;
};

#endif // DIRECTWRITERLOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\expiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       expiter.cxx
//
//  Contents:   CExposedIterator implementation
//
//  History:    12-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <expiter.hxx>
#include <sstream.hxx>
#include <ptrcache.hxx>
#include <expparam.hxx>

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::CExposedIterator, public
//
//  Synopsis:   Constructor
//
//  Arguments:	[ppdf] - Public docfile
//		[pdfnKey] - Initial key
//		[pdfb] - DocFile basis
//		[ppc] - Context
//
//  History:    12-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedIterator::CExposedIterator(CPubDocFile *ppdf,
        CDfName *pdfnKey,
        CDFBasis *pdfb,
        CPerContext *ppc)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::CExposedIterator("
		"%p, %d:%s, %p, %p)\n", ppdf, pdfnKey->GetLength(),
                pdfnKey->GetBuffer(), pdfb, ppc));
    _ppc = ppc;
    _ppdf = P_TO_BP(CBasedPubDocFilePtr, ppdf);
    _ppdf->vAddRef();
    _dfnKey.Set(pdfnKey);
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _pdfb->vAddRef();
    _cReferences = 1;
    _sig = CEXPOSEDITER_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::~CExposedIterator, public
//
//  Synopsis:   Destructor
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedIterator::~CExposedIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::~CExposedIterator\n"));
    _sig = CEXPOSEDITER_SIGDEL;

    //In order to call into the tree, we need to take the mutex.
    //The mutex may get deleted in _ppc->Release(), so we can't
    //release it here.  The mutex actually gets released in
    //CPerContext::Release() or in the CPerContext destructor.
    SCODE sc;

#if !defined(MULTIHEAP)
    // TakeSem and ReleaseSem are moved to the Release Method
    // so that the deallocation for this object is protected
    if (_ppc)
    {
        sc = TakeSem();
        SetWriteAccess();
        olAssert(SUCCEEDED(sc));
    }
#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP

    olAssert(_cReferences == 0);
    if (_ppdf)
        _ppdf->CPubDocFile::vRelease();
    if (_pdfb)
        _pdfb->CDFBasis::vRelease();
#if !defined(MULTIHEAP)
    if (_ppc)
    {
        if (_ppc->Release() > 0)
            ReleaseSem(sc);
    }
#ifdef ASYNC
    //Mutex has been released, so we can release the connection point
    //  without fear of deadlock.
    if (pdacp != NULL)
        pdacp->Release();
#endif
#endif // MULTIHEAP
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::~CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Next, public
//
//  Synopsis:   Gets N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//              [rgelt] - Array for element return
//              [pceltFetched] - If non-NULL, contains the number of
//                      elements fetched
//
//  Returns:    Appropriate status code
//
//  Modifies:   [rgelt]
//              [pceltFetched]
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedIterator::Next(ULONG celt,
                                     STATSTGW FAR *rgelt,
                                     ULONG *pceltFetched)
{
    SAFE_SEM;
    SAFE_ACCESS;
    SCODE sc;
    STATSTGW *pelt = rgelt;
    ULONG celtDone;
    CDfName dfnInitial;
    CPtrCache pc;
    STATSTGW stat;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Next(%lu, %p, %p)\n",
                celt, rgelt, pceltFetched));

    OL_VALIDATE(Next(celt, rgelt, pceltFetched));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SetReadAccess();

    olChk(_ppdf->CheckReverted());

    // Preserve initial key to reset on failure
    dfnInitial.Set(&_dfnKey);

    TRY
    {
        for (; pelt<rgelt+celt; pelt++)
        {
            sc = _ppdf->FindGreaterEntry(&_dfnKey, NULL, &stat, FALSE);
            if (FAILED(sc))
            {
                if (sc == STG_E_NOMOREFILES)
                    sc = S_FALSE;
                break;
            }

            if (FAILED(sc = pc.Add(stat.pwcsName)))
            {
                TaskMemFree(stat.pwcsName);
                break;
            }

            _dfnKey.Set(stat.pwcsName);

            stat.grfMode = 0;
            stat.grfLocksSupported = 0;
            stat.STATSTG_dwStgFmt = 0;

            *pelt = stat;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    END_PENDING_LOOP;

    // Can't move this down because dfnInitial isn't set for all EH_Err cases
    if (FAILED(sc))
        _dfnKey.Set(&dfnInitial);

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Next => %lX\n", sc));
EH_Err:
    celtDone = (ULONG)(pelt-rgelt);
    if (FAILED(sc))
    {
        void *pv;

        pc.StartEnum();
        while (pc.Next(&pv))
            TaskMemFree(pv);

    }
    else if (pceltFetched)
        // May fault but that's acceptable
        *pceltFetched = celtDone;

    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Skip, public
//
//  Synopsis:   Skips N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::Skip(ULONG celt)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Skip(%lu)\n", celt));

    OL_VALIDATE(Skip(celt));
    
    if (SUCCEEDED(sc = Validate()))
        sc = hSkip(celt, FALSE);

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Skip\n"));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Reset, public
//
//  Synopsis:   Rewinds the iterator
//
//  Returns:    Appropriate status code
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::Reset(void)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Reset()\n"));

    OL_VALIDATE(Reset());
    
    if (SUCCEEDED(sc = Validate()))
        sc = hReset();

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Reset\n"));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Clone, public
//
//  Synopsis:   Clones this iterator
//
//  Arguments:  [ppenm] - Clone return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::Clone(IEnumSTATSTG **ppenm)
{
    SCODE sc, scSem = STG_E_INUSE;
    SafeCExposedIterator piExp;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Clone(%p)\n", ppenm));

    OL_VALIDATE(Clone(ppenm));
    
    olChk(Validate());
    olChk(scSem = TakeSem());
    if (!SUCCEEDED(sc = _ppdf->CheckReverted()))
    {
        ReleaseSem(scSem);
        olChk(sc);
    }
    SetReadAccess();

    piExp.Attach(new CExposedIterator(BP_TO_P(CPubDocFile *, _ppdf),
                                      &_dfnKey,
                                      BP_TO_P(CDFBasis *, _pdfb),
                                      _ppc));
    if ((CExposedIterator *)piExp == NULL)
        sc = STG_E_INSUFFICIENTMEMORY;

    ClearReadAccess();
    ReleaseSem(scSem);

    if (SUCCEEDED(sc))
    {
        _ppc->AddRef();
        TRANSFER_INTERFACE(piExp, IEnumSTATSTG, ppenm);
    }

    if (_cpoint.IsInitialized())
    {
        olChkTo(EH_init, piExp->InitClone(&_cpoint));
    }

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Clone => %p\n",
                *ppenm));
    // Fall through
EH_Err:
    return ResultFromScode(sc);
EH_init:
    piExp->Release();
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Release, public
//
//  Synopsis:   Releases resources for the iterator
//
//  Returns:    Appropriate status code
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedIterator::Release(void)
{
    LONG lRet;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Release()\n"));

#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
    CPerContext *ppc = _ppc;
    SCODE sc = S_OK;
#endif
    if (FAILED(Validate()))
        return 0;
    if ((lRet = hRelease()) == 0)
#ifdef MULTIHEAP
    {
        if (_ppc)
        {
            sc = TakeSem();
            SetWriteAccess();
            olAssert(SUCCEEDED(sc));
        }
#ifdef ASYNC
        IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP
        delete this;
#ifdef MULTIHEAP
        if (ppc)
        {
            if (ppc->Release() == 0)
                g_smAllocator.Uninit();
            else
                if (SUCCEEDED(sc)) ppc->UntakeSem();
        }
#ifdef ASYNC
        //Mutex has been released, so we can release the connection point
        //  without fear of deadlock.
        if (pdacp != NULL)
            pdacp->Release();
#endif
    }
#endif

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Release\n"));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedIterator::AddRef(void)
{
    ULONG ulRet;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::AddRef()\n"));

    if (FAILED(Validate()))
        return 0;
    ulRet = hAddRef();

    olDebugOut((DEB_TRACE, "Out CExposedIterator::AddRef\n"));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::QueryInterface(?, %p)\n",
                ppvObj));

    if (SUCCEEDED(sc = Validate()))
        sc = hQueryInterface(iid,
                             IID_IEnumSTATSTG,
                             (IEnumSTATSTG *)this,
                             ppvObj);
#ifdef ASYNC
    if (FAILED(sc) &&
        IsEqualIID(iid, IID_IConnectionPointContainer) &&
        _cpoint.IsInitialized())
    {
        *ppvObj = (IConnectionPointContainer *)this;
        CExposedIterator::AddRef();
    }
#endif

    olDebugOut((DEB_TRACE, "Out CExposedIterator::QueryInterface => %p\n",
                ppvObj));
    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\expst.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       expst.cxx
//
//  Contents:   CExposedStream code
//
//  History:    28-Feb-92   PhilipLa    Created.
//              20-Jun-96   MikeHill    Fixed the PropSet version of
//                                      Lock to check the result of TakeSem.
//              1-Jul-96    MikeHill    - Removed Win32 SEH from PropSet code.
//                                      - Receive NTPROP in propset Open method.
//              11-Feb-97   Danl        - Changed CMappedStream to IMappedStream
//                                      - Added QI support for IMappedStream.
//
//--------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <pbstream.hxx>
#include <expst.hxx>
#include <lock.hxx>
#include <seekptr.hxx>
#include <marshl.hxx>
#include <logfile.hxx>
#include <privguid.h>   // IID_IMappedStream
#include <expparam.hxx>

#ifndef LARGE_STREAMS
// Maximum stream size supported by exposed streams
// This is MAX_ULONG with one subtracted so that
// the seek pointer has a spot to sit even at the
// end of the stream
#define CBMAXSTREAM 0xfffffffeUL
// Maximum seek pointer value
#define CBMAXSEEK (CBMAXSTREAM+1)
#endif

#if DBG
DWORD MyGetLastError()
{
    return GetLastError();
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CExposedStream, public
//
//  Synopsis:   Empty object constructor
//
//  History:    30-Mar-92       DrewB   Created
//
//---------------------------------------------------------------



CExposedStream::CExposedStream(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::CExposedStream()\n"));
    _pdfb = NULL;
    _ppc = NULL;
    _cReferences = 0;
    _psp = NULL;
    _pst = NULL;
    olDebugOut((DEB_ITRACE, "Out CExposedStream::CExposedStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Init, public
//
//  Synopsis:   Base constructor
//
//  Arguments:  [pst] - Public stream
//              [pdfb] - DocFile basis
//              [ppc] - Context
//              [psp] - Seek pointer or NULL for new seek pointer
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CExposedStream::Init(CPubStream *pst,
                           CDFBasis *pdfb,
                           CPerContext *ppc,
                           CSeekPointer *psp)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedStream::Init("
                "%p, %p, %p, %p)\n",
                pst, pdfb, ppc, psp));

    if (psp == NULL)
    {
        CSeekPointer *pspTemp;
        olMem(pspTemp = new (pdfb->GetMalloc()) CSeekPointer(0));
        _psp = P_TO_BP(CBasedSeekPointerPtr, pspTemp);
    }
    else
        _psp = P_TO_BP(CBasedSeekPointerPtr, psp);
    _ppc = ppc;
    _pst = P_TO_BP(CBasedPubStreamPtr, pst);
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _pdfb->vAddRef();
    _cReferences = 1;
    _sig = CEXPOSEDSTREAM_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Init\n"));
    return S_OK;

EH_Err:
    return sc;
}

SCODE CExposedStream::InitMarshal(CPubStream *pst,
                                  CDFBasis *pdfb,
                                  CPerContext *ppc,
                                  DWORD dwAsyncFlags,
                                  IDocfileAsyncConnectionPoint *pdacp,
                                  CSeekPointer *psp)
{
    SCODE sc;
    sc = CExposedStream::Init(pst,
                              pdfb,
                              ppc,
                              psp);
    if (SUCCEEDED(sc))
    {
        sc = _cpoint.InitMarshal(this, dwAsyncFlags, pdacp);
    }
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CExposedStream::~CExposedStream, public
//
//  Synopsis:   Destructor
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


CExposedStream::~CExposedStream(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::~CExposedStream\n"));
    olAssert(_cReferences == 0);
    _sig = CEXPOSEDSTREAM_SIGDEL;

    //In order to call into the tree, we need to take the mutex.
    //The mutex may get deleted in _ppc->Release(), so we can't
    //release it here.  The mutex actually gets released in
    //CPerContext::Release() or in the CPerContext destructor.
    SCODE sc;

#if !defined(MULTIHEAP)
    // TakeSem and ReleaseSem are moved to the Release Method
    // so that the deallocation for this object is protected
    if (_ppc)
    {
        sc = TakeSem();
        SetWriteAccess();
        olAssert(SUCCEEDED(sc));
    }

#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP


    if (_pst)
        _pst->CPubStream::vRelease();
    if (_psp)
        _psp->CSeekPointer::vRelease();
    if (_pdfb)
        _pdfb->CDFBasis::vRelease();
#if !defined(MULTIHEAP)
    if (_ppc)
    {
        if (_ppc->Release() > 0)
            ReleaseSem(sc);
    }
#ifdef ASYNC
    //Mutex has been released, so we can release the connection point
    //  without fear of deadlock.
    if (pdacp != NULL)
        pdacp->Release();
#endif
#endif // MULTIHEAP


    olDebugOut((DEB_ITRACE, "Out CExposedStream::~CExposedStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Read, public
//
//  Synopsis:   Read from a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return number of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::Read(VOID HUGEP *pb, ULONG cb, ULONG *pcbRead)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    ULONG cbRead = 0;

    olLog(("%p::In  CExposedStream::Read(%p, %lu, %p)\n",
           this, pb, cb, pcbRead));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Read %p(%p, %lu, %p)\n",
                this, pb, cb, pcbRead));

    OL_VALIDATE(Read(pb, cb, pcbRead));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();
    sc = _pst->ReadAt(_psp->GetPos(), pb, cb, (ULONG STACKBASED *)&cbRead);
#ifndef LARGE_STREAMS
    olAssert(CBMAXSEEK-_psp->GetPos() >= cbRead);
#endif
    _psp->SetPos(_psp->GetPos()+cbRead);
    pb = (BYTE *)pb + cbRead;
    cb -= cbRead;
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Read => %lu\n", cbRead));

EH_Err:
    if (pcbRead)
    {
        *pcbRead = cbRead;
        olLog(("%p::Out CExposedStream::Read().  *pcbRead == %lu, ret = %lx\n",
               this, *pcbRead, sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Read().  ret == %lx\n", this, sc));
    }

    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Write, public
//
//  Synopsis:   Write to a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Write(
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG *pcbWritten)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    ULONG cbWritten = 0;

    olLog(("%p::In  CExposedStream::Write(%p, %lu, %p)\n",
           this, pb, cb, pcbWritten));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Write %p(%p, %lu, %p)\n",
                this, pb, cb, pcbWritten));

    OL_VALIDATE(Write(pb, cb, pcbWritten));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif
    sc = _pst->WriteAt(_psp->GetPos(), pb, cb,
                       (ULONG STACKBASED *)&cbWritten);
#ifndef LARGE_STREAMS
    olAssert(CBMAXSEEK-_psp->GetPos() >= cbWritten);
#endif
    _psp->SetPos(_psp->GetPos()+cbWritten);
    pb = (BYTE *)pb + cbWritten;
    cb -= cbWritten;
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Write => %lu\n",
                cbWritten));
EH_Err:
    if (pcbWritten)
    {
        *pcbWritten = cbWritten;
        olLog(("%p::Out CExposedStream::Write().  "
               "*pcbWritten == %lu, ret = %lx\n",
               this, *pcbWritten, sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Write().  ret == %lx\n", this, sc));
    }

    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Seek(LARGE_INTEGER dlibMove,
                                  DWORD dwOrigin,
                                  ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
#ifdef LARGE_STREAMS
    LONGLONG lMove;
#else
    LONG lMove;
#endif
    ULARGE_INTEGER ulPos = {0};

    olLog(("%p::In  CExposedStream::Seek(%ld, %lu, %p)\n",
           this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Seek %p(%ld, %lu, %p)\n",
                this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));

    OL_VALIDATE(Seek(dlibMove, dwOrigin, plibNewPosition));
    
    if (dwOrigin == STREAM_SEEK_SET)
    {
#ifdef LARGE_STREAMS
        if (dlibMove.QuadPart < 0)
            olErr (EH_Err, STG_E_INVALIDFUNCTION);
#else
        // Truncate dlibMove to 32 bits
        // Make sure we don't seek too far
        if (LIGetHigh(dlibMove) != 0)
            LISet32(dlibMove, 0xffffffff);
#endif
    }
    else
    {
#ifndef LARGE_STREAMS
        // High dword must be zero for positive values or -1 for
        // negative values
        // Additionally, for negative values, the low dword can't
        // exceed -0x80000000 because the 32nd bit is the sign
        // bit
        if (LIGetHigh(dlibMove) > 0 ||
            (LIGetHigh(dlibMove) == 0 &&
             LIGetLow(dlibMove) >= 0x80000000))
            LISet32(dlibMove, 0x7fffffff);
        else if (LIGetHigh(dlibMove) < -1 ||
                 (LIGetHigh(dlibMove) == -1 &&
                  LIGetLow(dlibMove) <= 0x7fffffff))
            LISet32(dlibMove, 0x80000000);
#endif
    }

#ifdef LARGE_STREAMS
    lMove = dlibMove.QuadPart;
#else
    lMove = (LONG)LIGetLow(dlibMove);
#endif
    olChk(Validate());

    //ASYNC Note:  We probably don't need this pending loop in Seek
    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(_pst->CheckReverted());
    SafeReadAccess();

#ifdef LARGE_STREAMS
    ulPos.QuadPart = _psp->GetPos();
#else
    ULISet32(ulPos, _psp->GetPos());
#endif
    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
#ifdef LARGE_STREAMS
        ulPos.QuadPart = lMove;
#else
        ULISetLow(ulPos, (ULONG)lMove);
#endif
        break;

    case STREAM_SEEK_END:
#ifdef LARGE_STREAMS
        ULONGLONG cbSize;
#else
        ULONG cbSize;
#endif
        olChk(_pst->GetSize(&cbSize));
        if (lMove < 0)
        {
#ifdef LARGE_STREAMS
            if ((ULONGLONG)(-lMove) > cbSize)
#else
            if ((ULONG)(-lMove) > cbSize)
#endif
                olErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
#ifdef LARGE_STREAMS
        ulPos.QuadPart = cbSize+lMove;
#else
        else if ((ULONG)lMove > CBMAXSEEK-cbSize)
            lMove = (LONG)(CBMAXSEEK-cbSize);
        ULISetLow(ulPos, cbSize+lMove);
#endif
        break;

    case STREAM_SEEK_CUR:
        if (lMove < 0)
        {
#ifdef LARGE_STREAMS
            if ((ULONGLONG)(-lMove) > _psp->GetPos())
#else
            if ((ULONG)(-lMove) > _psp->GetPos())
#endif
                olErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
#ifdef LARGE_STREAMS
        ulPos.QuadPart = _psp->GetPos()+lMove;
#else
        else if ((ULONG)lMove > CBMAXSEEK-_psp->GetPos())
            lMove = (LONG)(CBMAXSEEK-_psp->GetPos());
        ULISetLow(ulPos, _psp->GetPos()+lMove);
#endif
        break;
    }
#ifdef LARGE_STREAMS
    _psp->SetPos(ulPos.QuadPart);
#else
    _psp->SetPos(ULIGetLow(ulPos));
#endif

    if (plibNewPosition)
        *plibNewPosition = ulPos;
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Seek => %lu\n",
                ULIGetLow(ulPos)));
EH_Err:
    olLog(("%p::Out CExposedStream::Seek().  ulPos == %lu,  ret == %lx\n",
           this, ULIGetLow(ulPos), sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::SetSize(ULARGE_INTEGER ulNewSize)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedStream::SetSize(%lu)\n",
           this, ULIGetLow(ulNewSize)));
    olDebugOut((DEB_TRACE, "In  CExposedStream::SetSize %p(%lu)\n",
                this, ULIGetLow(ulNewSize)));

    OL_VALIDATE(SetSize(ulNewSize));
    
#ifndef LARGE_STREAMS
    if (ULIGetHigh(ulNewSize) != 0)
        olErr(EH_Err, STG_E_DOCFILETOOLARGE);
#endif
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif
#ifdef LARGE_STREAMS
    sc = _pst->SetSize(ulNewSize.QuadPart);
#else
    sc = _pst->SetSize(ULIGetLow(ulNewSize));
#endif
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::SetSize\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::SetSize().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CopyTo, public
//
//  Synopsis:   Copies information from one stream to another
//
//  Arguments:  [pstm] - Destination
//              [cb] - Number of bytes to copy
//              [pcbRead] - Return number of bytes read
//              [pcbWritten] - Return number of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//              [pcbWritten]
//
//  History:    25-Mar-92       DrewB   Created
//              12-Jan-93       AlexT   Rewritten without recursion
//
//  Notes:      We do our best to handle overlap correctly.  This allows
//              CopyTo to be used to insert and remove space within a
//              stream.
//
//              In the error case, we make no gurantees as to the
//              validity of pcbRead, pcbWritten, or either stream's
//              seek position.
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::CopyTo(IStream *pstm,
                                    ULARGE_INTEGER cb,
                                    ULARGE_INTEGER *pcbRead,
                                    ULARGE_INTEGER *pcbWritten)
{
    SCODE sc;
    SAFE_SEM;

    olLog(("%p::In  CExposedStream::CopyTo(%p, %lu, %p, %p)\n",
           this, pstm, ULIGetLow(cb), pcbRead, pcbWritten));
    olDebugOut((DEB_TRACE, "In  CExposedStream::CopyTo("
                "%p, %lu, %p, %p)\n", pstm, ULIGetLow(cb),
                pcbRead, pcbWritten));

    OL_VALIDATE(CopyTo(pstm, cb, pcbRead, pcbWritten));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());

    sc = CopyToWorker(pstm, cb, pcbRead, pcbWritten, &_ss);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::CopyTo => %lu, %lu\n",
                pcbRead ? ULIGetLow(*pcbRead) : 0,
                pcbWritten ? ULIGetLow(*pcbWritten) : 0));
EH_Err:
    return sc;
}

SCODE CExposedStream::CopyToWorker(IStream *pstm,
                                   ULARGE_INTEGER cb,
                                   ULARGE_INTEGER *pcbRead,
                                   ULARGE_INTEGER *pcbWritten,
                                   CSafeSem *pss)
{
    SCODE sc;
#ifdef LARGE_STREAMS
    ULONGLONG ulCopySize;
    ULONGLONG ulSrcSize, ulSrcOrig;
#else
    ULONG ulCopySize;
    ULONG ulSrcSize;
    ULONG ulSrcOrig;
#endif
    ULARGE_INTEGER uliDestOrig;
    LARGE_INTEGER liDestPos;
    BYTE *pb = NULL;
    BOOL fOverlap;
#ifdef LARGE_STREAMS
    ULONGLONG ulBytesCopied = 0;
#else
    ULONG ulBytesCopied = 0;
#endif
    ULONG ulBufferSize;

#ifdef LARGE_STREAMS
    ulCopySize = cb.QuadPart;
#else
    //  Bound the size of the copy
    //  1.  The maximum we can copy is 0xffffffff
    if (ULIGetHigh(cb) == 0)
        ulCopySize = ULIGetLow(cb);
    else
        ulCopySize = 0xffffffff;
#endif

    //  2.  We can only copy what's available in the source stream
    SetReadAccess();
    sc = _pst->GetSize(&ulSrcSize);
    ClearReadAccess();
    olChk(sc);

    ulSrcOrig = _psp->GetPos();
    if (ulSrcSize < ulSrcOrig)
    {
        //  Nothing in source to copy
        ulCopySize = 0;
    }
    else if ((ulSrcSize - ulSrcOrig) < ulCopySize)
    {
        //  Shrink ulCopySize to fit bytes in source
        ulCopySize = ulSrcSize - ulSrcOrig;
    }

    //  3.  We can only copy what will fit in the destination
    LISet32(liDestPos, 0);
    olHChk(pstm->Seek(liDestPos, STREAM_SEEK_CUR, &uliDestOrig));
#ifndef LARGE_STREAMS
    olAssert(ULIGetHigh(uliDestOrig) == 0);

    if (ulCopySize > CBMAXSEEK - ULIGetLow(uliDestOrig))
        ulCopySize = CBMAXSEEK - ULIGetLow(uliDestOrig);
#endif

    ulBufferSize = (_pdfb->GetOpenFlags() & DF_LARGE) ?
                    LARGESTREAMBUFFERSIZE : STREAMBUFFERSIZE;
    //  We are allowed to fail here with out-of-memory
    olChk(GetBuffer(STREAMBUFFERSIZE, ulBufferSize, &pb, &ulBufferSize));

    // Since we have no reliable way to determine if the source and
    // destination represent the same stream, we assume they
    // do and always handle overlap.

#ifdef LARGE_STREAMS
    fOverlap = (uliDestOrig.QuadPart > ulSrcOrig &&
                uliDestOrig.QuadPart < ulSrcOrig + ulCopySize);
#else
    fOverlap = (ULIGetLow(uliDestOrig) > ulSrcOrig &&
                ULIGetLow(uliDestOrig) < ulSrcOrig + ulCopySize);
#endif

#ifdef LARGE_STREAMS
    ULONGLONG ulSrcCopyOffset = 0;
    ULONGLONG ulDstCopyOffset = 0;
#else
    ULONG ulSrcCopyOffset = 0;
    ULONG ulDstCopyOffset = 0;
#endif
    if (fOverlap)
    {
        //  We're going to copy back to front, so determine the
        //  stream end positions
        ulSrcCopyOffset = ulSrcOrig + ulCopySize;

        //  uliDestOrig is the destination starting offset
#ifdef LARGE_STREAMS
        ulDstCopyOffset = uliDestOrig.QuadPart + ulCopySize;
#else
        ulDstCopyOffset = ULIGetLow(uliDestOrig) + ulCopySize;
#endif
    }

    while (ulCopySize > 0)
    {
        //  We can only copy up to ulBufferSize bytes at a time
        ULONG cbPart = (ULONG) min(ulCopySize, ulBufferSize);

        if (fOverlap)
        {
            //  We're copying back to front so we need to seek to
            //  set up the streams correctly

            ulSrcCopyOffset -= cbPart;
            ulDstCopyOffset -= cbPart;

            //  Set source stream position
            _psp->SetPos(ulSrcCopyOffset);

            //  Set destination stream position
            liDestPos.QuadPart = ulDstCopyOffset;
            olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
        }

        ULONG ulRead = 0;
        SetReadAccess();
        sc = _pst->ReadAt(_psp->GetPos(), pb, cbPart, &ulRead);
        ClearReadAccess();
#ifndef LARGE_STREAMS
        olAssert(CBMAXSEEK-_psp->GetPos() >= ulRead);
#endif
        _psp->SetPos(_psp->GetPos()+ulRead);
        olChk(sc);

        if (cbPart != ulRead)
        {
            //  There was no error, but we were unable to read cbPart
            //  bytes.  Something's wrong (the underlying ILockBytes?)
            //  but we can't control it;  just return an error.
            olErr(EH_Err, STG_E_READFAULT);
        }

        // We release the tree mutex before calling out to Write
        // to avoid a deadlock in the async FillAppend method
        ULONG ulWritten;
        SCODE sc2;
        pss->Release();
        sc2 = pstm->Write(pb, cbPart, &ulWritten);
        olChk(pss->Take());
        olChk (sc2);
        if (cbPart != ulWritten)
        {
            //  There was no error, but we were unable to write
            //  ulWritten bytes.  We can't trust the pstm
            //  implementation, so all we can do here is return
            //  an error.
            olErr(EH_Err, STG_E_WRITEFAULT);
        }

        olAssert(ulCopySize >= cbPart);
        ulCopySize -= cbPart;
        ulBytesCopied += cbPart;
    }

    if (fOverlap)
    {
        //  Set the seek pointers to the correct location
        _psp->SetPos(ulSrcOrig + ulBytesCopied);

        liDestPos.QuadPart = uliDestOrig.QuadPart + ulBytesCopied;
        olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
    }

    // Fall through

EH_Err:
    DfMemFree(pb);

    if (pcbRead)
        pcbRead->QuadPart = ulBytesCopied;
    if (pcbWritten)
        pcbWritten->QuadPart = ulBytesCopied;

    olLog(("%p::Out CExposedStream::CopyTo().  "
           "cbRead == %lu, cbWritten == %lu, ret == %lx\n",
           this, pcbRead ? ULIGetLow(*pcbRead) : 0,
           pcbWritten ? ULIGetLow(*pcbWritten) : 0, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedStream::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedStream::Release()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Release()\n"));

    if (FAILED(Validate()))
        return 0;
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
#ifdef MULTIHEAP
        CSafeMultiHeap smh(_ppc);
        CPerContext *ppc = _ppc;
        SCODE sc = S_OK;
        if (_ppc)
        {
            sc = TakeSem();
            SetWriteAccess();
            olAssert(SUCCEEDED(sc));
        }
#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP
        delete this;
#ifdef MULTIHEAP
        if (ppc)
        {
            if (ppc->Release() == 0)
                g_smAllocator.Uninit();
            else
                if (SUCCEEDED(sc)) ppc->UntakeSem();
        }
#ifdef ASYNC
        //Mutex has been released, so we can release the connection point
        //  without fear of deadlock.
        if (pdacp != NULL)
            pdacp->Release();
#endif
#endif
    }
    else if (lRet < 0)
        lRet = 0;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Release %p()=> %lu\n",
                this, lRet));
    olLog(("%p::Out CExposedStream::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    STATSTGW stat;

    olLog(("%p::In  CExposedStream::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Stat(%p)\n",
                pstatstg));

    OL_VALIDATE(Stat(pstatstg, grfStatFlag));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    sc = _pst->Stat(&stat, grfStatFlag);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
    {
        TRY
        {
            *pstatstg = stat;
            pstatstg->type = STGTY_STREAM;
            pstatstg->grfLocksSupported = 0;
            pstatstg->STATSTG_dwStgFmt = 0;
            pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwHighDateTime = 0;
            pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwHighDateTime = 0;
            pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        }
        CATCH(CException, e)
        {
            UNREFERENCED_PARM(e);
            if (stat.pwcsName)
                TaskMemFree(stat.pwcsName);
            sc = STG_E_INVALIDPOINTER;
        }
        END_CATCH
    }
    olDebugOut((DEB_TRACE, "Out CExposedStream::Stat\n"));
    // Fall through

EH_Err:
    olLog(("%p::Out CExposedStream::Stat().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Clone, public
//
//  Synopsis:   Clones a stream
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Clone(IStream **ppstm)
{
    SafeCExposedStream pst;
    CSeekPointer *psp;
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedStream::Clone(%p)\n", this, ppstm));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Clone(%p)\n", ppstm));

    OL_VALIDATE(Clone(ppstm));
    
    olChk(Validate());
    olChk(TakeSafeSem());
    olChk(_pst->CheckReverted());
    SafeReadAccess();
    olMem(psp = new (_pdfb->GetMalloc()) CSeekPointer(_psp->GetPos()));
    pst.Attach(new (_pdfb->GetMalloc()) CExposedStream);
    olMemTo(EH_psp, (CExposedStream *)pst);
    olChkTo(EH_pst, pst->Init(BP_TO_P(CPubStream *, _pst),
                              BP_TO_P(CDFBasis *, _pdfb),
                              _ppc, psp));

    _ppc->AddRef();
    _pst->vAddRef();
#ifdef ASYNC
    if (_cpoint.IsInitialized())
    {
        olChkTo(EH_pstInit, pst->InitClone(&_cpoint));
    }
#endif
    TRANSFER_INTERFACE(pst, IStream, ppstm);

    olDebugOut((DEB_TRACE, "Out CExposedStream::Clone => %p\n", *ppstm));

 EH_Err:
    olLog(("%p::Out CExposedStream::Clone().  *ppstm == %p, ret == %lx\n",
           this, *ppstm, sc));
    return ResultFromScode(sc);
EH_pstInit:
    pst->Release();
    goto EH_Err;
EH_pst:
    delete pst;
EH_psp:
    psp->vRelease();
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedStream::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedStream::AddRef()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedStream::AddRef()\n"));

    if (FAILED(Validate()))
        return 0;
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;

    olDebugOut((DEB_TRACE, "Out CExposedStream::AddRef %p() => %lu\n",
                this, _cReferences));
    olLog(("%p::Out CExposedStream::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::LockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    olDebugOut((DEB_TRACE, "In  CExposedStream::LockRegion("
                "%lu, %lu\n", ULIGetLow(cb), dwLockType));
    olDebugOut((DEB_TRACE, "Out CExposedStream::LockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::LockRegion()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::UnlockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    olDebugOut((DEB_TRACE, "In  CExposedStream::UnlockRegion(%lu, %lu)\n",
                ULIGetLow(cb), dwLockType));
    olDebugOut((DEB_TRACE, "Out CExposedStream::UnlockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::UnlockRegion()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Commit, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Commit(DWORD grfCommitFlags)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olDebugOut((DEB_TRACE, "In  CExposedStream::Commit(%lu)\n",
                grfCommitFlags));
    olLog(("%p::In  CExposedStream::Commit(%lx)\n", this, grfCommitFlags));

    OL_VALIDATE(Commit(grfCommitFlags));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

    sc = _pst->Commit(grfCommitFlags);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::Commit().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Revert, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Revert(void)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedStream::Revert()\n"));

    OL_VALIDATE(Revert());
    
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    //ASYNC Note:  Don't need pending loop here.
    sc = _pst->CheckReverted();
    olDebugOut((DEB_TRACE, "Out CExposedStream::Revert\n"));
    olLog(("%p::In  CExposedStream::Revert()\n", this));
    olLog(("%p::Out CExposedStream::Revert().  ret == %lx", this, sc));

    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_TRACE, "In  CExposedStream::QueryInterface(?, %p)\n",
                ppvObj));


    OL_VALIDATE(QueryInterface(iid, ppvObj));

    olChk(Validate());
    olChk(_pst->CheckReverted());

    sc = S_OK;
    if (IsEqualIID(iid, IID_IStream) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStream *)this;
        AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        //If the ILockBytes we'd need to marshal doesn't support IMarshal
        //  then we want to do standard marshalling on the stream, mostly
        //  to prevent deadlock problems but also because you'll get better
        //  performance.  So check, then do the right thing.

        IMarshal *pim;
        ILockBytes *plkb;
        plkb = _ppc->GetOriginal();
        if (plkb == NULL)
        {
            plkb = _ppc->GetBase();
        }

        sc = plkb->QueryInterface(IID_IMarshal, (void **)&pim);
        if (FAILED(sc))
        {
            olErr(EH_Err, E_NOINTERFACE);
        }
        pim->Release();

#ifdef MULTIHEAP
        if (_ppc->GetHeapBase() == NULL)
            olErr (EH_Err, E_NOINTERFACE);
#endif

        *ppvObj = (IMarshal *)this;
        AddRef();
    }
    else if (IsEqualIID(iid, IID_IMappedStream))
    {
        *ppvObj = (IMappedStream *)this;
        AddRef();
    }
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IConnectionPointContainer) &&
              _cpoint.IsInitialized())
    {
        *ppvObj = (IConnectionPointContainer *)this;
        CExposedStream::AddRef();
    }
#endif

    else
        sc = E_NOINTERFACE;

    olDebugOut((DEB_TRACE, "Out CExposedStream::QueryInterface => %p\n",
                *ppvObj));
EH_Err:
    olLog(("%p::Out CExposedStream::QueryInterface().  "
           "*ppvObj == %p, ret == %lx\n", this, *ppvObj, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Unmarshal, public
//
//  Synopsis:   Creates a duplicate stream from parts
//
//  Arguments:  [pstm] - Marshal stream
//              [ppv] - Object return
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    26-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CExposedStream::Unmarshal(IStream *pstm,
                                void **ppv,
                                DWORD mshlflags)
{
    SCODE sc;
    CDfMutex mtx;
    CPerContext *ppc;
    CPubStream *pst;
    CDFBasis *pdfb;
    CGlobalContext *pgc;
    CExposedStream *pest;
    CSeekPointer *psp;
    IStream *pstmStd = NULL;
#ifdef ASYNC
    DWORD dwAsyncFlags;
    IDocfileAsyncConnectionPoint *pdacp;
#endif
#ifdef POINTER_IDENTITY
    CMarshalList *pml;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedStream::Unmarshal(%p, %p, %lu)\n",
                pstm, ppv, mshlflags));

#ifdef MULTIHEAP
    void *pvBaseOld;
    void *pvBaseNew;
    ContextId cntxid;
    CPerContext pcSharedMemory (NULL);          // bootstrap object
#endif

    //First unmarshal the standard marshalled version
    sc = CoUnmarshalInterface(pstm, IID_IStream, (void **)&pstmStd);
    if (FAILED(sc))
    {
        // assume that entire standard marshaling stream has been read
        olAssert (pstmStd == NULL);
        sc = S_OK;
    }

#ifdef MULTIHEAP
    sc = UnmarshalSharedMemory(pstm, mshlflags, &pcSharedMemory, &cntxid);
    if (!SUCCEEDED(sc))
    {
#ifdef POINTER_IDENTITY
        UnmarshalPointer(pstm, (void **) &pest);
#endif
        UnmarshalPointer(pstm, (void **)&pst);
        UnmarshalPointer(pstm, (void **)&pdfb);
        UnmarshalPointer(pstm, (void **)&psp);
#ifdef ASYNC
        ReleaseContext(pstm, TRUE, FALSE, mshlflags);
        ReleaseConnection(pstm, mshlflags);
#else
        ReleaseContext(pstStm, FALSE, mshlflags);
#endif
        olChkTo(EH_std, sc);
    }
    pvBaseOld = DFBASEPTR;
#endif
#ifdef POINTER_IDENTITY
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **)&pest));
#endif
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **)&pst));
    olChkTo(EH_mem, ValidateBuffer(pst, sizeof(CPubStream)));
    olChkTo(EH_pst, UnmarshalPointer(pstm, (void **)&pdfb));
    olChkTo(EH_pdfb, UnmarshalPointer(pstm, (void **)&psp));
    olChkTo(EH_psp, UnmarshalPointer(pstm, (void **)&pgc));
    olChkTo(EH_pgc, ValidateBuffer(pgc, sizeof(CGlobalContext)));

    //So far, nothing has called into the tree so we don't really need
    //  to be holding the tree mutex.  The UnmarshalContext call does
    //  call into the tree, though, so we need to make sure this is
    //  threadsafe.  We'll do this my getting the mutex name from the
    //  CGlobalContext, then creating a new CDfMutex object.  While
    //  this is obviously not optimal, since it's possible we could
    //  reuse an existing CDfMutex, the reuse strategy isn't threadsafe
    //  since we can't do a lookup without the possibility of the thing
    //  we're looking for being released by another thread.
    TCHAR atcMutexName[CONTEXT_MUTEX_NAME_LENGTH];
    pgc->GetMutexName(atcMutexName);
    olChkTo(EH_pgc, mtx.Init(atcMutexName));
    olChkTo(EH_pgc, mtx.Take(INFINITE));

    //At this point we're holding the mutex.
#ifdef MULTIHEAP
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     FALSE,
                                     cntxid,
                                     FALSE));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     FALSE,
                                     cntxid,
                                     FALSE));
#endif
    if ((pvBaseNew = DFBASEPTR) != pvBaseOld)
    {
        pst = (CPubStream*) ((ULONG_PTR)pst - (ULONG_PTR)pvBaseOld 
                                           + (ULONG_PTR)pvBaseNew);
        pest = (CExposedStream*) ((ULONG_PTR)pest - (ULONG_PTR)pvBaseOld
                                                 + (ULONG_PTR)pvBaseNew);
        pdfb = (CDFBasis*) ((ULONG_PTR)pdfb - (ULONG_PTR)pvBaseOld
                                           + (ULONG_PTR)pvBaseNew);
        psp = (CSeekPointer*) ((ULONG_PTR)psp - (ULONG_PTR)pvBaseOld 
                                             + (ULONG_PTR)pvBaseNew);
    }
#else
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     FALSE,
                                     FALSE));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     FALSE,
                                     FALSE));
#endif //ASYNC
#endif
#ifdef ASYNC
    olChkTo(EH_ppc, UnmarshalConnection(pstm,
                                        &dwAsyncFlags,
                                        &pdacp,
                                        mshlflags));
#endif

    // if we use up 1Gig of address space, use standard unmarshaling
    if (gs_iSharedHeaps > (DOCFILE_SM_LIMIT / DOCFILE_SM_SIZE))
        olErr (EH_ppc, STG_E_INSUFFICIENTMEMORY);

#ifdef POINTER_IDENTITY
    olAssert (pest != NULL);
    pml = (CMarshalList *) pest;

    // Warning: these checks must remain valid across processes
    if (SUCCEEDED(pest->Validate()) && pest->GetPub() == pst)
    {
        pest = (CExposedStream *) pml->FindMarshal(GetCurrentContextId());
    }
    else
    {
        pml = NULL;
        pest = NULL;
    }

    if (pest == NULL)
    {
#endif
        olMemTo(EH_ppc, pest = new (pdfb->GetMalloc()) CExposedStream);
#ifdef ASYNC
        olChkTo(EH_pest, pest->InitMarshal(pst,
                                           pdfb,
                                           ppc,
                                           dwAsyncFlags,
                                           pdacp,
                                           psp));
        //InitMarshal adds a reference on pdacp.
        if (pdacp)
            pdacp->Release();
#else
        olChkTo(EH_pest, pest->Init(pst, pdfb, ppc, psp));
#endif
#ifdef POINTER_IDENTITY
        if (pml) pml->AddMarshal(pest);
        pst->vAddRef();  // CExposedStream::Init does not AddRef
        psp->vAddRef();
    }
    else
    {
        pdfb->SetAccess(ppc);
        pest->AddRef();         // reuse this object
        ppc->Release();         // reuse percontext
    }
#else
    pst->vAddRef();
    psp->vAddRef();
#endif

    *ppv = pest;
#ifdef MULTIHEAP
    if (pvBaseOld != pvBaseNew)
    {
        pcSharedMemory.SetThreadAllocatorState(NULL);
        g_smAllocator.Uninit();           // delete the extra mapping
    }
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

    mtx.Release();

    //We're returning the custom marshalled version, so release the
    //standard marshalled one.
    if (pstmStd != NULL)
        pstmStd->Release();
    
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Unmarshal => %p\n", *ppv));
    return S_OK;

 EH_pest:
    delete pest;
 EH_ppc:
    ppc->Release();
 EH_mtx:
    mtx.Release();
    goto EH_Err;
 EH_pgc:
    CoReleaseMarshalData(pstm); // release the ILockBytes
    CoReleaseMarshalData(pstm); // release the ILockBytes
#ifdef ASYNC
    ReleaseConnection(pstm, mshlflags);
#endif
 EH_psp:
 EH_pdfb:
 EH_pst:
EH_mem:
EH_Err:
#ifdef MULTIHEAP
    pcSharedMemory.SetThreadAllocatorState(NULL);
    g_smAllocator.Uninit();   // delete the file mapping in error case
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

 EH_std:
    if (pstmStd != NULL)
    {
        //We can return the standard marshalled version instead of an error.
        *ppv = pstmStd;
        return S_OK;
    }
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::GetUnmarshalClass(REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags,
                                               LPCLSID pcid)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::GetUnmarshalClass("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcid));
    olDebugOut((DEB_TRACE, "In  CExposedStream::GetUnmarshalClass:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this, pv, dwDestContext,
                pvDestContext, mshlflags, pcid));

    UNREFERENCED_PARM(pv);
    UNREFERENCED_PARM(mshlflags);

    olChk(ValidateOutBuffer(pcid, sizeof(CLSID)));
    memset(pcid, 0, sizeof(CLSID));
    olChk(ValidateIid(riid));
    olChk(Validate());
    olChk(_pst->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetUnmarshalClass(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcid));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(VerifyIid(riid, IID_IStream));
        *pcid = CLSID_DfMarshal;
    }

    olDebugOut((DEB_TRACE, "Out CExposedStream::GetUnmarshalClass\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::GetUnmarshalClass().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::GetMarshalSizeMax(REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags,
                                               LPDWORD pcbSize)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    UNREFERENCED_PARM(pv);
    olLog(("%p::In  CExposedStream::GetMarshalSizeMax("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcbSize));
    olDebugOut((DEB_TRACE, "In  CExposedStream::GetMarshalSizeMax:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this, pv, dwDestContext,
                pvDestContext, mshlflags, pcbSize));

    olChk(Validate());
    olChk(_pst->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcbSize));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        sc = GetStdMarshalSize(riid, IID_IStream, dwDestContext, pvDestContext,
                               mshlflags, pcbSize,
                               sizeof(CPubStream *)+sizeof(CDFBasis *)+
                               sizeof(CSeekPointer *),
#ifdef ASYNC
                               &_cpoint,
                               TRUE,
#endif
                               _ppc, FALSE);
        DWORD cbSize = 0;
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  &cbSize));
            pmsh->Release();
            *pcbSize += cbSize;
        }
    }

    olDebugOut((DEB_TRACE, "Out CExposedStream::GetMarshalSizeMax\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::GetMarshalSizeMax().  *pcbSize == %lu, "
           "ret == %lx\n", this, *pcbSize, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::MarshalInterface(IStream *pstStm,
                                              REFIID riid,
                                              void *pv,
                                              DWORD dwDestContext,
                                              LPVOID pvDestContext,
                                              DWORD mshlflags)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::MarshalInterface("
           "%p, riid, %p, %lu, %p, %lu).  Context == %lX\n",
           this, pstStm, pv, dwDestContext, pvDestContext,
           mshlflags, (ULONG)GetCurrentContextId()));
    olDebugOut((DEB_TRACE, "In  CExposedStream::MarshalInterface:%p("
                "%p, riid, %p, %lu, %p, %lu)\n", this, pstStm, pv,
                dwDestContext, pvDestContext, mshlflags));

    UNREFERENCED_PARM(pv);

    olChk(Validate());
    olChk(_pst->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->MarshalInterface(pstStm, riid, pv,
                                                 dwDestContext, pvDestContext,
                                                 mshlflags));
            pmsh->Release();
            olChk(sc);
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(StartMarshal(pstStm, riid, IID_IStream, mshlflags));

        //Always standard marshal, in case we get an error during
        //unmarshalling of the custom stuff.
        {
            IMarshal *pmsh;
            if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                               dwDestContext, pvDestContext,
                                               mshlflags, &pmsh)))
            {
                sc = pmsh->MarshalInterface(pstStm, riid, pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags);
                pmsh->Release();
            }
            olChk(sc);
        }
            
#ifdef MULTIHEAP
        olChk(MarshalSharedMemory(pstStm, _ppc));
#endif
#ifdef POINTER_IDENTITY
        olChk(MarshalPointer(pstStm, (CExposedStream*) GetNextMarshal()));
#endif
        olChk(MarshalPointer(pstStm, BP_TO_P(CPubStream *, _pst)));
        olChk(MarshalPointer(pstStm, BP_TO_P(CDFBasis *, _pdfb)));
        olChk(MarshalPointer(pstStm, BP_TO_P(CSeekPointer *, _psp)));
#ifdef ASYNC
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             TRUE,
                             FALSE));
#else
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             FALSE));
#endif

#ifdef ASYNC
        olChk(MarshalConnection(pstStm,
                                &_cpoint,
                                dwDestContext,
                                pvDestContext,
                                mshlflags));
#endif
    }

    olDebugOut((DEB_TRACE, "Out CExposedStream::MarshalInterface\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::MarshalInterface().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::UnmarshalInterface(IStream *pstStm,
                                                REFIID riid,
                                                void **ppvObj)
{
    olLog(("%p::INVALID CALL TO CExposedStream::UnmarshalInterface()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::StaticReleaseMarshalData, public static
//
//  Synopsis:   Releases any references held in marshal data
//
//  Arguments:  [pstStm] - Marshal data stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Feb-94       DrewB   Created
//
//  Notes:      Assumes standard marshal header has already been read
//
//---------------------------------------------------------------


SCODE CExposedStream::StaticReleaseMarshalData(IStream *pstStm,
                                               DWORD mshlflags)
{
    SCODE sc;
    CPubStream *pst;
    CDFBasis *pdfb;
    CSeekPointer *psp;
#ifdef POINTER_IDENTITY
    CExposedStream *pest;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedStream::StaticReleaseMarshalData:("
                "%p, %lX)\n", pstStm, mshlflags));

    //First release the standard marshalled stuff
    olChk(CoReleaseMarshalData(pstStm));
    // The final release of the exposed object may have shut down the
    // shared memory heap, so do not access shared memory after this point

    //Then do the rest of it
#ifdef MULTIHEAP
    olChk(SkipSharedMemory(pstStm, mshlflags));
#endif
#ifdef POINTER_IDENTITY
    olChk(UnmarshalPointer(pstStm, (void **) &pest));
#endif
    olChk(UnmarshalPointer(pstStm, (void **)&pst));
    olChk(UnmarshalPointer(pstStm, (void **)&pdfb));
    olChk(UnmarshalPointer(pstStm, (void **)&psp));
#ifdef ASYNC
    olChk(ReleaseContext(pstStm, TRUE, FALSE, mshlflags));
    olChk(ReleaseConnection(pstStm, mshlflags));
#else
    olChk(ReleaseContext(pstStm, FALSE, mshlflags));
#endif

#ifdef MULTIHEAP
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif
    olDebugOut((DEB_ITRACE,
                "Out CExposedStream::StaticReleaseMarshalData\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] - Stream
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    DWORD mshlflags;
    IID iid;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::ReleaseMarshalData(%p)\n", this, pstStm));
    olDebugOut((DEB_TRACE, "In  CExposedStream::ReleaseMarshalData:%p(%p)\n",
                this, pstStm));

    olChk(Validate());
    olChk(_pst->CheckReverted());
    olChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    olAssert(IsEqualIID(iid, IID_IStream));
    sc = StaticReleaseMarshalData(pstStm, mshlflags);

    olDebugOut((DEB_TRACE, "Out CExposedStream::ReleaseMarshalData\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::ReleaseMarshalData().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::DisconnectObject(DWORD dwReserved)
{
    olLog(("%p::INVALID CALL TO CExposedStream::DisconnectObject()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

#ifdef NEWPROPS
//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Open
//
//  Synopsis:   Opens mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Gets the size of the underlying stream and reads it
//              into memory so that it can be "mapped."
//
//--------------------------------------------------------------------

VOID CExposedStream::Open(IN VOID *powner, LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Open(powner, phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Close
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Does nothing because the object may be mapped in
//              another process.
//
//--------------------------------------------------------------------

VOID CExposedStream::Close(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Close(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::ReOpen
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Combined open and map.
//
//--------------------------------------------------------------------

VOID CExposedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().ReOpen(ppv,phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Quiesce
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Meaningless for docfile mapped stream.
//
//--------------------------------------------------------------------

VOID CExposedStream::Quiesce(VOID)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Quiesce();
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Map
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Return the address of the "mapping" buffer.
//
//--------------------------------------------------------------------

VOID CExposedStream::Map(BOOLEAN fCreate, VOID **ppv)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Map(fCreate, ppv);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Unmap
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Unmapping is merely zeroing the pointer.  We don't
//              flush because that's done explicitly by the
//              CPropertyStorage class.
//
//
//--------------------------------------------------------------------

VOID CExposedStream::Unmap(BOOLEAN fFlush, VOID **pv)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Unmap(fFlush, pv);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Flush
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//              Flush the memory property set to disk and commit it.
//
//  Signals:    HRESULT from IStream methods.
//
//  Notes:      Calls the shared memory buffer to do the actual flush
//              because that code path is shared with the "FlushBufferedData"
//              call for IStorage::Commit.
//
//--------------------------------------------------------------------

VOID CExposedStream::Flush(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Flush(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetSize
//
//  Synopsis:   Returns size of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//--------------------------------------------------------------------

ULONG CExposedStream::GetSize(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    return GetMappedStream().GetSize(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize
//
//  Synopsis:   Sets size of "map." Called by
//              NtCreatePropertySet et al.
//
//  Arguments:  [cb] -- requested size.
//		[fPersistent] -- FALSE if expanding in-memory read-only image
//              [ppv] -- new mapped address.
//
//  Signals:    Not enough disk space.
//
//  Notes:      In a low memory situation we may not be able to
//              get the requested amount of memory.  In this
//              case we must fall back on disk storage as the
//              actual map.
//
//--------------------------------------------------------------------

VOID  CExposedStream::SetSize(ULONG cb, BOOLEAN fPersistent, VOID **ppv, OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().SetSize(cb, fPersistent, ppv, phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Lock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS CExposedStream::Lock(BOOLEAN fExclusive)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    if( SUCCEEDED( sc = TakeSem() ))
    {
        SetDifferentBasisAccess(_pdfb, _ppc);
        return GetMappedStream().Lock(fExclusive);
    }
    else
    {
        olDebugOut((DEB_IERROR, "Couldn't take CExposedStream::Lock(%lx)\n", sc));
        return (STATUS_LOCK_NOT_GRANTED);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Unlock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS CExposedStream::Unlock(VOID)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    NTSTATUS Status = GetMappedStream().Unlock();
    ClearBasisAccess(_pdfb);
    ReleaseSem(S_OK);
    return Status;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::QueryTimeStamps(STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
    return; // not implemented
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryModifyTime
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    return FALSE;  // not implemented
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QuerySecurity
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QuerySecurity(OUT ULONG *pul) const
{
    return FALSE;  // not implemented
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsWriteable
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsWriteable() const
{
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetChangePending
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::SetChangePending(BOOLEAN f)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    return GetMappedStream().SetChangePending(f);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsNtMappedStream
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::IsNtMappedStream(VOID) const
{
    return FALSE;
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetParentHandle
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

HANDLE CExposedStream::GetHandle(VOID) const
{
    return INVALID_HANDLE_VALUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::SetModified(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().SetModified(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsModified(VOID) const
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    //return ((class CExposedStream*const)this)->GetMappedStream().IsModified();
    return GetConstMappedStream().IsModified();
}

#ifdef DIRECTWRITERLOCK
//+--------------------------------------------------------------
//
//  Member:     CExposedStream::ValidateWriteAccess, public
//
//  Synopsis:   returns whether writer currently has write access
//
//  Notes:      tree mutex must be taken
//
//  History:    30-Apr-96    HenryLee     Created
//
//---------------------------------------------------------------
HRESULT CExposedStream::ValidateWriteAccess()
{
    if (_pst->GetTransactedDepth() >= 1)
        return S_OK;

    return (!_pdfb->DirectWriterMode() || (*_ppc->GetRecursionCount())) ?
            S_OK : STG_E_ACCESSDENIED;
};

#endif // DIRECTWRITERLOCK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\filest.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       filest.cxx
//
//  Contents:   Generic 16/32 filestream code
//
//  History:    20-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <marshl.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::CFileStream, public
//
//  Synopsis:   Empty object constructor
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------


CFileStream::CFileStream(IMalloc * const pMalloc)
        : _pMalloc(pMalloc)
{
    _cReferences = 1;
    _hFile = INVALID_FH;
    _hReserved = INVALID_FH;
    _hPreDuped = INVALID_FH;
    _pgfst = NULL;
    _grfLocal = 0;
    _sig = CFILESTREAM_SIG;

#ifdef USE_FILEMAPPING
    _hMapObject = NULL;
    _pbBaseAddr = NULL;
    _cbViewSize = 0;
#endif

#ifdef ASYNC
    _ppc = NULL;
#endif
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::InitGlobal, public
//
//  Synopsis:   Constructor for flags only
//
//  Arguments:  [dwStartFlags] - Startup flags
//              [df] - Permissions
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CFileStream::InitGlobal(DWORD dwStartFlags,
                             DFLAGS df)
{
    SCODE sc = S_OK;
    CGlobalFileStream *pgfstTemp;

    fsAssert(_pgfst == NULL);

    fsMem(pgfstTemp = new (_pMalloc) CGlobalFileStream(_pMalloc,
                                     NULL, df, dwStartFlags));
    _pgfst = P_TO_BP(CBasedGlobalFileStreamPtr, pgfstTemp);
    _pgfst->Add(this);
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::InitFromGlobal, public
//
//  Synopsis:   Initializes a filestream with a global filestream
//
//  Arguments:  [pgfst] - Global object
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------


void CFileStream::InitFromGlobal(CGlobalFileStream *pgfst)
{
    _pgfst = P_TO_BP(CBasedGlobalFileStreamPtr, pgfst);
    _pgfst->AddRef();
    _pgfst->Add(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::InitFromFileStream public
//
//  Synopsis:   Initializes a filestream with another CFileStream
//
//  Arguments:  [pfst] - Global object
//
//  History:    24-Sep-1998     HenryLee  Created
//
//----------------------------------------------------------------------------

void CFileStream::InitFromFileStream (CFileStream *pfst)
{
    _hFile = pfst->_hFile;
    _hMapObject = pfst->_hMapObject;
    _pbBaseAddr = pfst->_pbBaseAddr;
    _cbViewSize = pfst->_cbViewSize;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlobalFileStream::InitFromGlobalFileStream public
//
//  Synopsis:   Initializes a global filestream from another global filestream
//
//  Arguments:  [pgfs] - Global object
//
//  History:    24-Sep-1998     HenryLee  Created
//
//----------------------------------------------------------------------------

void CGlobalFileStream::InitFromGlobalFileStream (CGlobalFileStream *pgfs)
{
#ifdef LARGE_DOCFILE
    _ulPos = pgfs->_ulPos;
#else
    _ulLowPos = pgfs->_ulLowPos;
#endif
    _cbMappedFileSize = pgfs->_cbMappedFileSize;
    _cbMappedCommitSize = pgfs->_cbMappedCommitSize;
    _dwMapFlags = pgfs->_dwMapFlags;
    StringCbCopy (_awcMapName, sizeof(_awcMapName), pgfs->_awcMapName);
    StringCbCopy (_awcPath, sizeof(_awcPath), pgfs->_awcPath);

#ifdef ASYNC
    _dwTerminate = pgfs->_dwTerminate;
    _ulHighWater = pgfs->_ulHighWater;
    _ulFailurePoint = pgfs->_ulFailurePoint;
#endif // ASYNC
#if DBG == 1
    _ulLastFilePos = pgfs->_ulLastFilePos;
#endif
    _cbSector = pgfs->_cbSector;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::vRelease, public
//
//  Synopsis:   PubList support
//
//  History:    19-Aug-92       DrewB   Created
//
//---------------------------------------------------------------


ULONG CFileStream::vRelease(void)
{
    LONG lRet;
    filestDebug((DEB_ITRACE, "In  CFileStream::vRelease:%p()\n", this));
    fsAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
#ifdef ASYNC
        if (_ppc != NULL)
        {
#ifdef MULTIHEAP
            CSafeMultiHeap smh(_ppc);
#endif
            SCODE sc;
            sc = TakeSem();
            fsAssert(SUCCEEDED(sc));
            CPerContext *ppc = _ppc;

            _ppc = NULL;
            delete this;

            if (ppc->ReleaseSharedMem() == 0)
            {
#ifdef MULTIHEAP
                g_smAllocator.Uninit();
#endif
            }
        }
        else
#endif
            delete this;
    }
    return (ULONG)lRet;
    filestDebug((DEB_ITRACE, "Out CFileStream::vRelease => %d\n",lRet));
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Release, public
//
//  Synopsis:   Releases resources for an LStream
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CFileStream::Release(void)
{
    ULONG ulRet;

    filestDebug((DEB_ITRACE, "In  CFileStream::Release()\n"));

    fsAssert(_cReferences >= 1);

    ulRet = CFileStream::vRelease();

    filestDebug((DEB_ITRACE, "Out CFileStream::Release\n"));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::AddRef, public
//
//  Synopsis:   Increases the ref count
//
//  History:    27-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CFileStream::AddRef(void)
{
    ULONG ulRet;

    filestDebug((DEB_ITRACE, "In  CFileStream::AddRef()\n"));


    CFileStream::vAddRef();
    ulRet = _cReferences;

    filestDebug((DEB_ITRACE, "Out CFileStream::AddRef, %ld\n", _cReferences));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetName, public
//
//  Synopsis:   Returns the internal path
//
//  Arguments:  [ppwcsName] - Name pointer return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppwcsName]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CFileStream::GetName(WCHAR **ppwcsName)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::GetName(%p)\n",
                ppwcsName));
    fsAssert(_pgfst->HasName());
    fsChk(DfAllocWC(lstrlenW(_pgfst->GetName())+1, ppwcsName));
    StringCchCopyW(*ppwcsName, lstrlenW(_pgfst->GetName())+1, _pgfst->GetName());

    filestDebug((DEB_ITRACE, "Out CFileStream::GetName => %ws\n",
                *ppwcsName));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;
#ifdef ASYNC
    BOOL fIsAsync = (_ppc != NULL);
#else
    const BOOL fIsAsync = FALSE;
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::QueryInterface(?, %p)\n",
                ppvObj));


    sc = S_OK;
    if (IsEqualIID(iid, IID_IFileLockBytes) ||
        IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IFileLockBytes *)this;
        CFileStream::vAddRef();
    }
    else if ((IsEqualIID(iid, IID_ILockBytes)) && !fIsAsync)
    {
        *ppvObj = (ILockBytes *)this;
        CFileStream::vAddRef();
    }
    else if ((IsEqualIID(iid, IID_IMarshal)) && !fIsAsync)
    {
        *ppvObj = (IMarshal *)this;
        CFileStream::vAddRef();
    }
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
        CFileStream::vAddRef();
    }
    else if (IsEqualIID(iid, IID_IFillInfo))
    {
        *ppvObj = (IFillInfo *)this;
        CFileStream::vAddRef();
    }
#endif
#if WIN32 >= 300
    else if (IsEqualIID(iid, IID_IAccessControl))
    {
        DWORD grfMode = 0;
        if (_pgfst->GetDFlags() & DF_TRANSACTED)
           grfMode |= STGM_TRANSACTED;
        if (_pgfst->GetDFlags() & DF_ACCESSCONTROL)
           grfMode |= STGM_EDIT_ACCESS_RIGHTS;

        // check if underlying file system supports security
        if (SUCCEEDED(sc = InitAccessControl(_hFile, grfMode, TRUE, NULL)))
        {
            *ppvObj = (IAccessControl *) this;
            CFileStream::vAddRef();
        }
        else sc = E_NOINTERFACE;
    }
#endif
    else
    {
        sc = E_NOINTERFACE;
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::QueryInterface => %p\n",
                ppvObj));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::Unmarshal, public
//
//  Synopsis:   Creates a duplicate FileStream
//
//  Arguments:  [ptsm] - Marshal stream
//              [ppv] - New filestream return
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    14-Apr-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CFileStream::Unmarshal(IStream *pstm,
                             void **ppv,
                             DWORD mshlflags)
{
    SCODE sc;
    CFileStream *pfst;
    CGlobalFileStream *pgfst;

    filestDebug((DEB_ITRACE, "In  CFileStream::Unmarshal(%p, %p, %lu)\n",
                 pstm, ppv, mshlflags));

    fsChk(UnmarshalPointer(pstm, (void **)&pgfst));
    pfst = pgfst->Find(GetCurrentContextId());

    if (pfst != NULL && !pfst->IsHandleValid())
        pfst = NULL;

    if (pfst)
    {
            pfst->AddRef();

            //
            // Scratch CFileStreams are always marshaled.  If we marshal a
            // direct-mode Base file, then an unopen uninitialized scratch
            // CFileStream is also marshaled (don't call InitUnmarshal here).
            // If a substorage is later opened in transacted mode then the
            // unopen scratch CFileStream is initialized (given a filename
            // and opened).  If the scratch is then marshaled, the reciever
            // must initialize his unopened scratch CFileStream.
            //
            if (pgfst->HasName())
            {
                fsChkTo(EH_pfst, pfst->InitUnmarshal());
            }
    }
    else
    {
            fsMemTo(EH_pgfst,
                    pfst = new (pgfst->GetMalloc())
                    CFileStream(pgfst->GetMalloc()));
            pfst->InitFromGlobal(pgfst);

            if (pgfst->HasName())
            {
                fsChkTo(EH_pfst, pfst->InitUnmarshal());
            }
    }
    *ppv = (void *)pfst;

    filestDebug((DEB_ITRACE, "Out CFileStream::Unmarshal => %p\n", *ppv));

    return S_OK;

 EH_pfst:
    pfst->Release();
 EH_pgfst:
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::GetUnmarshalClass(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPCLSID pcid)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::GetUnmarshalClass("
                "riid, %p, %lu, %p, %lu, %p)\n", pv, dwDestContext,
                pvDestContext, mshlflags, pcid));

    UNREFERENCED_PARM(pv);
    UNREFERENCED_PARM(mshlflags);


    *pcid = CLSID_DfMarshal;
    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::GetUnmarshalClass\n"));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [iid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::GetMarshalSizeMax(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPDWORD pcbSize)
{
    SCODE sc;

    UNREFERENCED_PARM(pv);
    fsChk(Validate());
    sc = GetStdMarshalSize(riid, IID_ILockBytes, dwDestContext, pvDestContext,
                           mshlflags, pcbSize, sizeof(CFileStream *),
#ifdef ASYNC
                           NULL,
                           FALSE,
                           NULL,
#else
                           NULL,
#endif
                           FALSE);

    fsAssert (_ppc == NULL);   // async lockbytes are standard marshaled
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [iid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::MarshalInterface(IStream *pstStm,
                                           REFIID riid,
                                           void *pv,
                                           DWORD dwDestContext,
                                           LPVOID pvDestContext,
                                           DWORD mshlflags)
{
    SCODE sc;
#ifdef ASYNC
    fsAssert (_ppc == NULL);   // async lockbytes are standard marshaled
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::MarshalInterface("
                "%p, iid, %p, %lu, %p, %lu)\n", pstStm, pv, dwDestContext,
                pvDestContext, mshlflags));

    UNREFERENCED_PARM(pv);

    fsChk(StartMarshal(pstStm, riid, IID_ILockBytes, mshlflags));
    fsChk(MarshalPointer(pstStm, BP_TO_P(CGlobalFileStream *, _pgfst)));

    filestDebug((DEB_ITRACE, "Out CFileStream::MarshalInterface\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [iid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::UnmarshalInterface(IStream *pstStm,
                                             REFIID iid,
                                             void **ppvObj)
{
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::StaticReleaseMarshalData, public static
//
//  Synopsis:   Releases any references held in marshal data
//
//  Arguments:  [pstStm] - Marshal data stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Feb-94       DrewB   Created
//
//  Notes:      Assumes standard marshal header has already been read
//
//---------------------------------------------------------------


SCODE CFileStream::StaticReleaseMarshalData(IStream *pstStm,
                                            DWORD mshlflags)
{
    SCODE sc;
    CGlobalFileStream *pgfst;

    filestDebug((DEB_ITRACE, "In  CFileStream::StaticReleaseMarshalData:("
                "%p, %lX)\n", pstStm, mshlflags));

    fsChk(UnmarshalPointer(pstStm, (void **)&pgfst));

    filestDebug((DEB_ITRACE, "Out CFileStream::StaticReleaseMarshalData\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    DWORD mshlflags;
    IID iid;

    filestDebug((DEB_ITRACE, "In  CFileStream::ReleaseMarshalData:%p(%p)\n",
                this, pstStm));


    fsChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    fsAssert(IsEqualIID(iid, IID_ILockBytes));
    sc = StaticReleaseMarshalData(pstStm, mshlflags);

    filestDebug((DEB_ITRACE, "Out CFileStream::ReleaseMarshalData\n"));
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwReserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::DisconnectObject(DWORD dwReserved)
{
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetLocksSupported, public
//
//  Synopsis:   Return lock capabilities
//
//  Arguments:  [pdwLockFlags] -- place holder for lock flags
//
//  Returns:    Appropriate status code
//
//  History:    12-Jul-93       AlexT   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::GetLocksSupported(DWORD *pdwLockFlags)
{
    if (pdwLockFlags != NULL)
        *pdwLockFlags = LOCK_EXCLUSIVE | LOCK_ONLYONCE;
    else
        return STG_E_INVALIDPOINTER;

    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\ptrcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	ptrcache.cxx
//
//  Contents:	CPtrCache implementation
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "exphead.cxx"
#pragma hdrstop

#include <ptrcache.hxx>

//+---------------------------------------------------------------------------
//
//  Member:	CPtrCache::~CPtrCache, public
//
//  Synopsis:	Destructor
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

CPtrCache::~CPtrCache(void)
{
    CPtrBlock *pb;

    Win4Assert(_pbHead != NULL);
    while (_pbHead != &_pbFirst)
    {
        pb = _pbHead->Next();
        delete _pbHead;
        _pbHead = pb;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CPtrCache::Add, public
//
//  Synopsis:	Adds a pointer to the cache
//
//  Arguments:	[pv] - Pointer
//
//  Returns:	Appropriate status code
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

SCODE CPtrCache::Add(void *pv)
{
    CPtrBlock *pb;
    
    Win4Assert(_pbHead != NULL);
    if (_pbHead->Full())
    {
        pb = new CPtrBlock(_pbHead);
        if (pb == NULL)
            return E_OUTOFMEMORY;
        _pbHead = pb;
    }
    _pbHead->Add(pv);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CPtrCache::Next, public
//
//  Synopsis:	Returns the next element in the enumeration
//
//  Arguments:	[ppv] - Pointer return
//
//  Returns:	TRUE/FALSE
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

BOOL CPtrCache::Next(void **ppv)
{
    if (_pbEnum && _iEnum >= _pbEnum->Count())
        _pbEnum = _pbEnum->Next();
    if (_pbEnum == NULL)
        return FALSE;
    *ppv = _pbEnum->Nth(_iEnum++);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\peiter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       peiter.cxx
//
//  Contents:   Implementation of PExposedIterator
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <peiter.hxx>
#include <expparam.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     PExposedIterator::hSkip, public
//
//  Synopsis:   Enumerator skip helper function
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE PExposedIterator::hSkip(ULONG celt, BOOL fProps)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hSkip:%p(%lu, %d)\n",
                this, celt, fProps));

    olChk(TakeSafeSem());
    olChk(_ppdf->CheckReverted());
    SafeReadAccess();

    for (; celt>0; celt--)
    {
        sc = _ppdf->FindGreaterEntry(&_dfnKey, &ib, NULL, fProps);
        if (FAILED(sc))
        {
            if (sc == STG_E_NOMOREFILES)
                sc = S_FALSE;
            break;
        }
        _dfnKey.Set(&ib.dfnName);
    }
    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hSkip\n"));
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     PExposedIterator::hRelease, public
//
//  Synopsis:   Release helper
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

LONG PExposedIterator::hRelease(void)
{
    LONG lRet;

    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hRelease:%p()\n", this));

    olAssert(_cReferences > 0);

    lRet = InterlockedDecrement(&_cReferences);

    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hRelease => %lu\n", lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     PExposedIterator::hQueryInterface, public
//
//  Synopsis:   QueryInterface helper
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE PExposedIterator::hQueryInterface(REFIID iid,
                                        REFIID riidSelf,
                                        IUnknown *punkSelf,
                                        void **ppv)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hQueryInterface:%p("
                "riid, riidSelf, %p, %p)\n", this, punkSelf, ppv));

    OL_VALIDATE(QueryInterface(iid, ppv));
    
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    olChk(_ppdf->CheckReverted());

    if (IsEqualIID(iid, riidSelf) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = punkSelf;
        hAddRef();
        sc = S_OK;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hQueryInterface\n"));
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	PExposedIterator::hReset, public
//
//  Synopsis:	Reset help
//
//  History:	18-Jan-93	DrewB	Created
//
//----------------------------------------------------------------------------

SCODE PExposedIterator::hReset(void)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    
    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hReset:%p()\n", this));

    olChk(TakeSafeSem());
    SafeReadAccess();
    
    _dfnKey.Set((WORD)0, (BYTE *)NULL);
    sc = _ppdf->CheckReverted();
    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hReset\n"));
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\mrshlist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       mrshlist.cxx
//
//  Contents:   CMarshalList implementation
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <mrshlist.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CMarshalList::FindMarshal, public
//
//  Synopsis:   Looks through the list for a matching context
//
//  Arguments:  [ctxid] - Context to look for
//
//  Returns:    Pointer to object or NULL
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

CMarshalList *CMarshalList::FindMarshal (ContextId ctxid) const
{
    CMarshalList *pmlResult = NULL;

    olDebugOut((DEB_ITRACE, "In  CMarshalList::Find:%p(%lu)Marshal\n", this, 
                                                                (ULONG)ctxid));
    olAssert (ctxid != INVALID_CONTEXT_ID);
    if (GetContextId() == ctxid)
        pmlResult = (CMarshalList *) this;  // cast away const
    else
    {
        CMarshalList *pml;
        for (pml = GetNextMarshal(); pml != this; pml = pml->GetNextMarshal())
        {
            olAssert (pml != NULL);
            if (pml->GetContextId() != INVALID_CONTEXT_ID &&
                pml->GetContextId() == ctxid)
            {
                pmlResult = pml;
                break;
            }
        }
    }

    olDebugOut((DEB_ITRACE, "Out CMarshalList::FindMarshal %p\n", pmlResult));
    return pmlResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarshalList::AddMarshal, public
//
//  Synopsis:   Adds a context to the list
//
//  Arguments:  [pml] - another marshaling of the same storage/stream
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

void CMarshalList::AddMarshal (CMarshalList *pml)
{
    olDebugOut((DEB_ITRACE, "In  CMarshalList::AddMarshal:%p(%p)\n",this,pml));
    olAssert (pml != NULL);
    olAssert (GetNextMarshal() != NULL);
    pml->SetNextMarshal(GetNextMarshal());
    SetNextMarshal(pml);
    olDebugOut((DEB_ITRACE, "Out CMarshalList::AddMarshal\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarshalList::RemoveMarshal, public
//
//  Synopsis:   Removes a context from the list
//
//  Arguments:  [pctx] - Context
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

void CMarshalList::RemoveMarshal(CMarshalList *pml)
{
    olDebugOut((DEB_ITRACE, "In  CMarshalList::RemoveMarshal:%p(%p)\n",
                            this,pml));
    if (GetNextMarshal() != NULL && GetNextMarshal() != this)
    {
        CMarshalList *pmlNext;
#if DBG == 1
        BOOL fFound = FALSE;
#endif
        for (pmlNext = GetNextMarshal(); pmlNext != this; 
             pmlNext = pmlNext->GetNextMarshal())
            if (pmlNext->GetNextMarshal() == pml)
            {
#if DBG == 1
                fFound = TRUE;
#endif
                pmlNext->SetNextMarshal(pml->GetNextMarshal());
                pml->SetNextMarshal(NULL);
                break;
            }
        olAssert(fFound == TRUE);
    }
    olDebugOut((DEB_ITRACE, "Out CMarshalList::RemoveMarshal\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\filest32.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       filest32.cxx
//
//  Contents:   Win32 LStream implementation
//
//  History:    12-May-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <time.h>
#include <marshl.hxx>
#include <df32.hxx>
#include <logfile.hxx>
#include <dfdeb.hxx>
#include <lock.hxx>

#if WIN32 != 200
#define USE_OVERLAPPED
#endif

DECLARE_INFOLEVEL(filest);

HRESULT GetNtHandleSectorSize (HANDLE Handle, ULONG * pulSectorSize);
HRESULT NtStatusToScode(NTSTATUS nts);

#if DBG == 1
//+--------------------------------------------------------------
//
//  Member:     CFileStream::PossibleDiskFull, private
//
//  Synopsis:   In debug builds it can simulate a disk full error
//
//  Returns:    STG_E_MEDIUMFULL when it wants to simulate an error.
//
//  History:    25-Nov-96       BChapman   Created
//
//---------------------------------------------------------------

#ifdef LARGE_DOCFILE
SCODE CFileStream::PossibleDiskFull(ULONGLONG ulOffset)
#else
SCODE CFileStream::PossibleDiskFull(ULONG iOffset)
#endif
{
#ifdef LARGE_DOCFILE
    ULARGE_INTEGER ulCurrentSize;

    ulCurrentSize.LowPart = GetFileSize(_hFile, &ulCurrentSize.HighPart);
    if (ulOffset > ulCurrentSize.QuadPart)
#else
    ULONG ulCurrentSize;

    ulCurrentSize = GetFileSize(_hFile, NULL);
    if ((iOffset) > ulCurrentSize)
#endif
    {
        if (SimulateFailure(DBF_DISKFULL))
        {
            return STG_E_MEDIUMFULL;
        }
    }
    return S_OK;
}

void CFileStream::CheckSeekPointer(void)
{
#ifdef LARGE_DOCFILE
    LARGE_INTEGER ulChk;
    ulChk.QuadPart = 0;
#else
    LONG lHighChk;
    ULONG ulLowChk;
    lHighChk = 0;
#endif

    if (_hFile != INVALID_FH)
    {
#ifdef LARGE_DOCFILE
        ulChk.LowPart = SetFilePointer(_hFile, 0, &ulChk.HighPart,FILE_CURRENT);
        if (ulChk.LowPart == MAX_ULONG && GetLastError() != NOERROR)
#else
        ulLowChk = SetFilePointer(_hFile, 0, &lHighChk, FILE_CURRENT);

        if (ulLowChk == 0xFFFFFFFF)
#endif
        {
            //An error of some sort occurred.
            filestDebug((DEB_ERROR, "SetFilePointer call failed with %x\n",
                        GetLastError()));
            return;
        }
        if (_pgfst != NULL)
        {
#ifdef LARGE_DOCFILE
        _pgfst->CheckSeekPointer(ulChk.QuadPart);
#else
        _pgfst->CheckSeekPointer(ulLowChk);
#endif
        }
    }
}
#endif  // DBG == 1

#if DBG == 1
#ifdef LARGE_DOCFILE
inline void CGlobalFileStream::CheckSeekPointer(ULONGLONG ulChk)
{
    if(ulChk != _ulPos && MAX_ULONGLONG != _ulPos)
    {
        filestDebug((DEB_ERROR,"Seek pointer mismatch."
                    "  Cached = 0x%Lx, Real = 0x%Lx, Last Checked = 0x%Lx"
                    " %ws\n",
                    _ulPos,
                    ulChk,
                    _ulLastFilePos,
                    GetName()));
        fsAssert(aMsg("Cached FilePointer incorrect!!\n"));
    }
    _ulLastFilePos = ulChk;
}
#else
inline void CGlobalFileStream::CheckSeekPointer(DWORD ulLowChk)
{
    if(ulLowChk != _ulLowPos && 0xFFFFFFFF != _ulLowPos)
    {
        filestDebug((DEB_ERROR,"Seek pointer mismatch."
                    "  Cached = 0x%06x, Real = 0x%06x, Last Checked = 0x%06x"
                    " %ws\n",
                    _ulLowPos,
                    ulLowChk,
                    _ulLastFilePos,
                    GetName()));
        fsAssert(aMsg("Cached FilePointer incorrect!!\n"));
    }
    _ulLastFilePos = ulLowChk;
}
#endif // LARGE_DOCFILE
#endif

//+--------------------------------------------------------------
//
//  Member:     CFileStream::InitWorker, private
//
//  Synopsis:   Constructor
//
//  Arguments:  [pwcsPath] -- Path
//              [dwFSInit] -- Reason why we are initing.
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92   DrewB       Created
//              20-Feb-97   BChapman    Rewrote.
//
//  Notes:  [pwcsPath] may be unsafe memory so we must be careful
//              not to propagate faults
//          The PathName will always be OLECHAR (WIDECHAR) so most of the
//              code is Unicode using WideWrap to talk to Win95.  Except
//              when creating a TempFile name.  To avoid lots of unnecessary
//              converting we work in TCHAR, and convert only the result.
//---------------------------------------------------------------

SCODE CFileStream::InitWorker(WCHAR const *pwcsPath, DWORD dwFSInit)
{
    WCHAR awcPath[_MAX_PATH+1];
    TCHAR atcPath[_MAX_PATH+1];
    TCHAR atcTempDirPath[_MAX_PATH+1];
    SCODE sc;
    DWORD DFlags = _pgfst->GetDFlags();

    filestDebug((DEB_ITRACE, "IN  CFileStream::InitWorker(%ws, 0x%x)\n",
                                pwcsPath, dwFSInit));

    // If we've already been constructed, leave

    if (INVALID_FH != _hFile)
    {
        filestDebug((DEB_ITRACE, "OUT CFileStream::Init returning %x\n", S_OK));
        return S_OK;
    }

    // Get file name from:
    //      1) the global object on Unmarshals (stored in Unicode).
    //      2) the passed parameter on Opens (OLE standard Unicode).
    //      3) MakeTmpName() when making Scratch or SnapShot files.
    //
    if (!_pgfst->HasName())
    {
        //
        // The Global object does not have a name so this CAN'T be an
        // unmarshal.   It is possible for scratch files to be marshaled
        // with no name because they have not yet been "demanded" but
        // Unmarshal() doesn't calls us if there is no name.
        //
//        fsAssert(!(dwFSInit & FSINIT_UNMARSHAL));

        // If we were passed a name, copy it.
        // Watch out for a possible bad pointer from the user.
        if (pwcsPath != NULL)
        {
            if (FAILED(StringCbCopyW (awcPath, sizeof(awcPath), pwcsPath)))
                fsErr(EH_Err, STG_E_INVALIDPOINTER);
        }
        else    // If we weren't given a name then make one up.
        {
            // We use native "TCHAR" when finding a temp name.
            //
            fsChk(Init_GetTempName(atcPath, atcTempDirPath));
            dwFSInit |= FSINIT_MADEUPNAME;

            if (FAILED(StringCbCopyW (awcPath, sizeof(awcPath), atcPath)))
                fsErr(EH_Err, STG_E_INVALIDPOINTER);
        }

        fsChk(Init_OpenOrCreate(awcPath,        // filename: given or created
                          atcTempDirPath,       // path to temp directory
                          dwFSInit));           // various state information
    }
    else
    {   // Name is in the global file object.  This is unmarshaling.
        // Or we could be in the 2nd init of a scratch file that was
        // "demanded" after it was marshaled.
        fsAssert( (dwFSInit & FSINIT_UNMARSHAL)
                        || (GetStartFlags() & RSF_SCRATCH) );

        fsChk(Init_DupFileHandle(dwFSInit));
    }

    //
    // If this is the first open of the file then we need to store
    // the name into the global object.
    // Set name to fully qualified path to avoid current-directory
    // dependencies.
    // Always store the path as Unicode.  We are using "WideWrap" here.
    //
    if (!_pgfst->HasName())
    {
        WCHAR awcFullPath[_MAX_PATH+1];
        WCHAR *pwcBaseName;

        if(0 == GetFullPathName(awcPath, _MAX_PATH, awcFullPath, &pwcBaseName))
        {
            fsErr(EH_File, LAST_STG_SCODE);
        }
        _pgfst->SetName(awcFullPath);

        //
        // If this is the first open of a SCRATCH then dup the file handle
        // to any other marshaled instances.  This covers the case of a
        // late "demand" scratch.
        //
        if(GetStartFlags() & RSF_SCRATCH)
            DupFileHandleToOthers();
    }

    CheckSeekPointer();
    filestDebug((DEB_INFO,
                "File=%2x Initialize this=%p thread %lX path %ws\n",
                _hFile, this, GetCurrentThreadId(), _pgfst->GetName()));

    //
    // When a file is mapped we can't shorten the real filesize except by
    // truncating when we close.
    //
    // If More than one context has the file mapped we can't truncate the
    // file when we close.
    //
    // If multiple writers having a file mapped data can be destroyed when
    // they close and truncate a file that the other guy may have written.
    // There is also a problem with readers holding the file mapped that
    // prevents the writer from truncating the file when he closes.
    //
    // So... the cases Where we want to allow mapping:
    //  - Direct,     Read
    //  - Transacted, Read  w/ Deny-Write
    //  - AnyMode,    Write w/ Deny-Write
    //  - Tempfiles (scratch and snapshot)
    //
    if(    (P_DIRECT(DFlags)     && P_READ(DFlags))
        || (P_TRANSACTED(DFlags) && P_READ(DFlags) && P_DENYWRITE(DFlags))
        || (P_WRITE(DFlags)      && P_DENYWRITE(DFlags))
        || (RSF_TEMPFILE & GetStartFlags()) )
    {
        Init_MemoryMap(dwFSInit);
    }
    else
    {
        filestDebug((DEB_MAP, "File=%2x Not creating a memory map for %ws.\n",
                                    _hFile, _pgfst->GetName()));
    }

    filestDebug((DEB_ITRACE, "OUT CFileStream::Init returning %x\n", S_OK));

    return S_OK;

EH_File:
    fsVerify(CloseHandle(_hFile));
    _hFile = INVALID_FH;
    if(RSF_CREATE & _pgfst->GetStartFlags())
        DeleteTheFile(awcPath);

EH_Err:
    filestDebug((DEB_ITRACE, "OUT CFileStream::Init returning %x\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_GetTempName, private
//
//  Synopsis:   Make up a temp filename.
//
//  Arguments: [ptcPath] -- [out] Tmp filename path
//          [ptcTmpPath] -- [out] Tmp directory path
//
//  Returns:    S_OK
//
//  History:    13-Jan-97       BChapman   Clean up InitWorker.
//
//  Note:  TCHAR issue.  We do as much as we can "native" and the
//      caller converts the result.  (If necessary)
//
//---------------------------------------------------------------
SCODE CFileStream::Init_GetTempName(TCHAR *ptcPath, TCHAR *ptcTmpPath)
{
    SCODE sc;
    LUID luid;
    DWORD cch;

    // Can't truncate since for temporary files we will
    // always be creating
    fsAssert(0 == (_pgfst->GetStartFlags() & RSF_TRUNCATE));

    // Create the Temp Name with native TCHAR.
    //
    cch = GetTempPath(_MAX_PATH, ptcTmpPath);
    if (0 == cch) 
    {
        fsErr(EH_Err, LAST_STG_SCODE);
    }
    else if (cch > _MAX_PATH)
    {
        fsErr(EH_Err, STG_E_PATHNOTFOUND);
    }

    if (AllocateLocallyUniqueId (&luid) == FALSE)
        fsErr (EH_Err, LAST_STG_SCODE);

    if(0 == GetTempFileName(ptcTmpPath, TEMPFILE_PREFIX, luid.LowPart, ptcPath))
    {
        fsErr(EH_Err, LAST_STG_SCODE);
    }

    return S_OK;

EH_Err:
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_GetNtOpenFlags, private
//
//  Synopsis:   Convert Docfile flags into NT Open flags.
//
//  Arguments:   [pdwAccess] -- [out] NT flags
//                [pdwShare] -- [out] NT flags
//             [pdwCreation] -- [out] NT Flags
//             [pdwFlagAttr] -- [out] NT Flags
//
//  Returns:    S_OK
//
//  Notes:      Uses _pgfst->GetDFlags() and _pgfst->GetStartFlags().
//
//  History:    6-Nov-96       BChapman   Clean up InitWorker.
//
//---------------------------------------------------------------
SCODE CFileStream::Init_GetNtOpenFlags(
        LPDWORD pdwAccess,
        LPDWORD pdwShare,
        LPDWORD pdwCreation,
        LPDWORD pdwFlagAttr)
{
    DWORD dwStartFlags = _pgfst->GetStartFlags();

    *pdwAccess = 0;
    *pdwShare = 0;
    *pdwCreation = 0;
    *pdwFlagAttr = 0;

    if (_pgfst->HasName())
    {
        dwStartFlags &= ~RSF_CREATEFLAGS;
        dwStartFlags |= RSF_OPEN;
    }

    if (dwStartFlags & RSF_OPENCREATE)
    {
        //  This is used for our internal logging
        *pdwCreation = OPEN_ALWAYS;
    }
    else if (dwStartFlags & RSF_CREATE)
    {
        if (dwStartFlags & RSF_TRUNCATE)
            *pdwCreation = CREATE_ALWAYS;
        else
            *pdwCreation = CREATE_NEW;
    }
    else
    {
        if (dwStartFlags & RSF_TRUNCATE)
            *pdwCreation = TRUNCATE_EXISTING;
        else
            *pdwCreation = OPEN_EXISTING;
    }

    DWORD dwDFlags = _pgfst->GetDFlags();
    if (!P_WRITE(dwDFlags))
        *pdwAccess = GENERIC_READ;
    else
        *pdwAccess = GENERIC_READ | GENERIC_WRITE;
    if (P_DENYWRITE(dwDFlags) && !P_WRITE(dwDFlags))
        *pdwShare = FILE_SHARE_READ;
    else
        *pdwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
#if WIN32 == 300
    if (dwDFlags & DF_ACCESSCONTROL)
        *pdwAccess |= WRITE_DAC | READ_CONTROL;
#endif

    // Make sure we're not attempting to create/truncate a read-only thing
    fsAssert(*pdwAccess != GENERIC_READ ||
             !(dwStartFlags & (RSF_CREATE | RSF_TRUNCATE)));

    switch(RSF_TEMPFILE & dwStartFlags)
    {
    case RSF_SCRATCH:
        *pdwFlagAttr = FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_RANDOM_ACCESS;
        break;

    case RSF_SNAPSHOT:
        *pdwFlagAttr = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;
        break;

    case 0:     // Normal "original" file
        *pdwFlagAttr = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;
        break;

    default:
        // if we get here something is rotten in the header files
        fsAssert(RSF_TEMPFILE == (RSF_SCRATCH | RSF_SNAPSHOT));
        break;
    }

    if(RSF_DELETEONRELEASE & dwStartFlags && RSF_TEMPFILE & dwStartFlags)
    {
        *pdwFlagAttr |= FILE_FLAG_DELETE_ON_CLOSE;
        *pdwShare |= FILE_SHARE_DELETE;
    }

    if (RSF_NO_BUFFERING & dwStartFlags)
    {
        *pdwFlagAttr |= FILE_FLAG_NO_BUFFERING;
    }

    if (RSF_ENCRYPTED & dwStartFlags)
    {
         *pdwFlagAttr |= FILE_ATTRIBUTE_ENCRYPTED;
    }

    return S_OK;
}



//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_OpenOrCreate, private
//
//  Synopsis:   Actually Open the NT file.
//
//  Arguments:   [pwcPath] -- Name of File to open.         OLECHAR
//            [ptcTmpPath] -- Path to the Temp Directory.   TCHAR
//              [dwFSInit] -- Flags.
//
//  Returns:    S_OK
//
//  History:    6-Nov-96       BChapman   InitWorker was too big.
//
//  Notes:  We pass the Temp directory path as a TCHAR because if we
//          need to construct a new temp file name we want to work
//          "native" as much as possible.
//
//---------------------------------------------------------------
SCODE CFileStream::Init_OpenOrCreate(
        WCHAR *pwcPath,
        TCHAR *ptcTmpPath,
        DWORD dwFSInit)
{
    SCODE sc;
    TCHAR atcPath[_MAX_PATH+1];
    DWORD dwAccess, dwShare, dwCreation, dwFlagAttr;
    DWORD dwDFlags = _pgfst->GetDFlags();

    Init_GetNtOpenFlags(&dwAccess, &dwShare, &dwCreation, &dwFlagAttr);

    //If we're opening with deny-read, we need to let the
    //   file system tell us if there are any other readers, to
    //   avoid our no-lock trick for the read-only deny-write case.
    //Yes, this is ugly.
    //Yes, it also has a race condition in which two people can
    //   get read access while specifying SHARE_DENY_READ.
    //
    if (!(dwFSInit & FSINIT_UNMARSHAL) &&
                !P_WRITE(dwDFlags) && P_DENYREAD(dwDFlags))
    {
        // We open read-only, share exclusive(ie == 0).  If this
        // fails, there is already another accessor, so we bail.
        //
        // If we are unmarshalling, we don't do this check because we
        // know there is already another reader, i.e. the original open.
        //
        //  Using WideWrap to handle the !UNICODE case.
        //
        _hFile = CreateFile(pwcPath, GENERIC_READ, 0, NULL,
                             dwCreation, dwFlagAttr, NULL);

        if (INVALID_FH == _hFile)
        {
            filestDebug((DEB_INFO, "Can open file %ws in the test open "
                                "read-only deny read case\n", pwcPath));
            if (GetLastError() == ERROR_ALREADY_EXISTS)
                fsErr(EH_Err, STG_E_FILEALREADYEXISTS)
            else
                fsErr(EH_Err, LAST_STG_SCODE);
        }

        CloseHandle(_hFile);
    }

    //
    // Open the File.  We use OLE WideWrap to handle !UNICODE
    //
    _hFile = CreateFile(pwcPath, dwAccess, dwShare, NULL,
                         dwCreation, dwFlagAttr, NULL);

    //
    //  If the Open failed w/ error = FILE_EXISTS and this is a temp file
    // then make up a new temp file name and keep tring until we succeed
    // or fail with a different error.
    //
    if (INVALID_FH == _hFile)
    {
        DWORD dwLastError = GetLastError();

        if (dwLastError != ERROR_ALREADY_EXISTS &&
            dwLastError != ERROR_FILE_EXISTS)
        {
            filestDebug((DEB_INFO, "File %ws Open Failed. err=%x\n",
                                        pwcPath, dwLastError));
            fsErr(EH_Err, STG_SCODE(dwLastError));
        }

        //
        // If we didn't make this name (ie. tempfile) then it is
        // time to error out.  Otherwise if we did make this name then
        // we can continue to try other names.
        //
        if(!(FSINIT_MADEUPNAME & dwFSInit))
        {
            filestDebug((DEB_INFO, "File Open Failed. File %ws Exists\n",
                                        pwcPath));
            fsErr(EH_Err, STG_E_FILEALREADYEXISTS);
        }

        LUID luid;
        CGlobalSecurity gs;     // put an secure ACL on the temp files
        fsChk (gs.Init(TRUE));

        while (1)
        {
            if (AllocateLocallyUniqueId (&luid) == FALSE)
                fsErr (EH_Err, LAST_STG_SCODE);

            filestDebug((DEB_INFO,
                    "CreateFile failed %x tring a new tempfile name.\n",
                    dwLastError));

            if (GetTempFileName(ptcTmpPath, TEMPFILE_PREFIX,
                                luid.LowPart, atcPath) == 0)
            {
                fsErr(EH_Err, LAST_STG_SCODE);
            }

            StringCchCopyW (pwcPath, MAX_PATH+1, atcPath);

            filestDebug((DEB_INFO,
                    "Tempfile CreateFile(%ws, %x, %x, NULL, %x, NORMAL|RANDOM, NULL)\n",
                    pwcPath, dwAccess, dwShare, dwCreation));

            //
            // Using WideWrap to handle the !UNICODE case
            //
            _hFile = CreateFile(
                        pwcPath,
                        dwAccess,
                        dwShare,
                        (SECURITY_ATTRIBUTES *) gs, 
                        dwCreation,
                        dwFlagAttr,
                        NULL);
            if (INVALID_FH != _hFile)
                break;

            dwLastError = GetLastError();
            if (dwLastError != ERROR_ALREADY_EXISTS &&
                dwLastError != ERROR_FILE_EXISTS)
            {
                fsErr(EH_Err, STG_SCODE(dwLastError));
            }
        }
    }

#if WIN32 == 100
    if (_pgfst->GetStartFlags() & RSF_NO_BUFFERING)
    {
        ULONG cbSector;
        fsChk (GetNtHandleSectorSize (_hFile, &cbSector));
        if ((cbSector % HEADERSIZE) == 0)  // only support sector sizes n*512
            _pgfst->SetSectorSize(cbSector);
    }
#endif

    filestDebug((DEB_INFO,
                "File=%2x CreateFile(%ws, %x, %x, NULL, %x, %x, NULL)\n",
                            _hFile, pwcPath, dwAccess, dwShare,
                            dwCreation, dwFlagAttr));

    //At this point the file handle is valid, so let's look at the
    //seek pointer and see what it is.
    CheckSeekPointer();

    return S_OK;

EH_Err:
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_DupFileHandle, private
//
//  Synopsis:   Dup any existing File Handle into _hFile.
//
//  Returns:    S_OK, System Error
//              or STG_E_INVALIDHANDLE if it can't file a file to Dup.
//
//  History:    15-Apr-96       BChapman    Created
//
//  Notes:  This is called from unmarshal.  So we can assert that there
//          MUST be another instance of an open handle in the list.
//
//---------------------------------------------------------------

SCODE CFileStream::Init_DupFileHandle(DWORD dwFSINIT)
{
    CFileStream *pfst;
    SCODE sc=E_FAIL;
    HANDLE hprocSrc = NULL;
    HANDLE hFileSrc;

    fsAssert(INVALID_FH == _hFile);

    //
    // Another context may have already Dup'ed the File Handle
    // to us.  (This is only in the marshaled-undemanded-scratch case)
    //
    if(INVALID_FH != _hPreDuped)
    {
        _hFile = _hPreDuped;
        _hPreDuped = INVALID_FH;
        return S_OK;
    }

    //
    // Search the list of contexts for someone we can Dup from.
    //
    pfst = _pgfst->GetFirstContext();
    fsAssert(NULL != pfst);

    while (pfst != NULL)
    {
        if (INVALID_FH == pfst->_hFile && INVALID_FH == pfst->_hPreDuped)
        {
            pfst = pfst->GetNext();
            continue;
        }
        
        //
        // Found someone with the file open.  Now Dup it.
        //
        hFileSrc = (INVALID_FH == pfst->_hFile) ?
            pfst->_hPreDuped :
            pfst->_hFile;

        hprocSrc = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pfst->GetContext());
        if(NULL == hprocSrc)
        {
            sc = LAST_STG_SCODE;
            pfst = pfst->GetNext();
            continue;
        }

        if(DuplicateHandle(hprocSrc,               // Src Process
                            hFileSrc,               // Src Handle
                            GetCurrentProcess(),    // Dest Process
                            &_hFile,                // Dest Handle
                            0, FALSE,
                            DUPLICATE_SAME_ACCESS))
        {
            sc = S_OK;
            break;
        }
        
        sc = LAST_STG_SCODE;
        CloseHandle(hprocSrc);
        pfst = pfst->GetNext();
    }
    if (NULL == pfst)
        fsErr(EH_Err, STG_E_INVALIDHANDLE);
        

    if (hprocSrc)
        CloseHandle(hprocSrc);
    return S_OK;

EH_Err:
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::DupFileHandleToOthers, private
//
//  Synopsis:   Dup your file handle into everyone else.
//
//  Returns:    S_OK, or system faliure code.
//
//  History:    17-Apr-96       BChapman    Created
//
//  Notes:  This is used when demanding a marshaled undemanded scratch.
//      We put the Dup'ed handle in "_hPreDuped".  The "Init_DupHandle()"
//      routine will find it an move it into _hFile.
//---------------------------------------------------------------

SCODE CFileStream::DupFileHandleToOthers()
{
    SCODE scAny = S_OK;
    CFileStream *pfst;
    HANDLE hprocDest;

    pfst = _pgfst->GetFirstContext();
    fsAssert(NULL != pfst);

    //
    //  Walk the list of contexts and Dup the file handle into all
    // contexts that don't already have it open.  If any of them fail,
    // keep going.  Hold onto the last error code and return it.
    //
    while(NULL != pfst)
    {
        if(INVALID_FH == pfst->_hFile && INVALID_FH == pfst->_hPreDuped)
        {
            //
            // Found someone that needs the file handle.
            //
            hprocDest = OpenProcess(PROCESS_DUP_HANDLE,
                                    FALSE,
                                    pfst->GetContext());
            if(NULL == hprocDest)
            {
                scAny = LAST_STG_SCODE;
            }
            else
            {
                if(!DuplicateHandle(GetCurrentProcess(),    // Src Process
                                    _hFile,                 // Src Handle
                                    hprocDest,              // Dest Process
                                    &pfst->_hPreDuped,      // Dest Handle
                                    0, FALSE,
                                    DUPLICATE_SAME_ACCESS))
                {
                    scAny = LAST_STG_SCODE;
                }
                CloseHandle(hprocDest);
            }
        }
        pfst = pfst->GetNext();
    }

    return scAny;
}


#ifdef USE_FILEMAPPING

//+--------------------------------------------------------
// The following are Memory mapped file support for NT
//      Init_MemoryMap
//      TurnOffMapping
//      MakeFileMapAddressValid
//+--------------------------------------------------------

//
//  This size will need to be revisited in the future.  Right now this is
// a balance between not consuming too much of a 32 address space, and big
// enough for most files without need to grow.
// In Nov 1996 (at the time of this writing) most documents are between
// 80-800K.  Some huge spreadsheets like the perf group reportare 18-20Mb.
//
#define MINIMUM_MAPPING_SIZE (512*1024)

BOOL DfIsRemoteFile (HANDLE hFile)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;

    DeviceInformation.Characteristics = 0;
    Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatus,
                &DeviceInformation,
                sizeof(DeviceInformation),
                FileFsDeviceInformation
                );

    if ( NT_SUCCESS(Status) &&
         (DeviceInformation.Characteristics & FILE_REMOTE_DEVICE) ) {

        return TRUE;

    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::IsEncryptedFile, private
//
//  Synopsis:   queries the file handle to see if it's encrypted
//
//  Arguments:  [dwFSInit] -- Flags.   Possible values:
//                      FSINIT_UNMARSHAL - This is an unmarshal.
//
//  Returns:      TRUE - if the file is encrypted on NTFS
//              FALSE  - if we can't tell
//
//  History:    05-Apr-2000    HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL CFileStream::IsEncryptedFile ()
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION BasicInformation;

    Status = NtQueryInformationFile(
                _hFile,
                &IoStatus,
                &BasicInformation,
                sizeof(BasicInformation),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) && 
         (BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) )
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::Init_MemoryMap, private
//
//  Synopsis:   Creates and Views a memory map for the current file.
//              Used by First open and Unmarshal.
//
//  Arguments:  [dwFSInit] -- Flags.   Possible values:
//                      FSINIT_UNMARSHAL - This is an unmarshal.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//              E_FAIL - When the global object says not to map the file.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  Private Effect:     Sets _hMapObject
//                      Sets _pbBaseAddr
//
//  Note:   The field _pbBaseAddr is check before each use of the memory map.
//
//  History:    19-Oct-96       BChapman   Created
//
//----------------------------------------------------------------------------

SCODE CFileStream::Init_MemoryMap(DWORD dwFSInit)
{
    LUID luid;
    WCHAR pwcMapName[MAPNAME_MAXLEN];
    DWORD dwPageFlags, dwMapFlags;
    ULONG cbFileSize;
    ULONG cbFileSizeHigh;
    ULONG cbViewSize;
    ULONG cbCommitedSize;
    SCODE sc;
    BOOL fMakeStub = FALSE;

    filestDebug((DEB_ITRACE, "In  Init_MemoryMap(0x%x)\n", dwFSInit));

    if (_pgfst->GetStartFlags() & RSF_NO_BUFFERING)
        fsErr (EH_Err, STG_E_INVALIDFUNCTION);

    cbFileSize = GetFileSize(_hFile, &cbFileSizeHigh);
    if (cbFileSize == MAX_ULONG && NO_ERROR != GetLastError())
            fsErr(EH_Err, LAST_STG_SCODE)

    if (cbFileSizeHigh > 0)
        fsErr (EH_Err, STG_E_DOCFILETOOLARGE);

    // disallow remote opens except for read, deny-write for NT4 compatiblity
    if ((P_WRITE(_pgfst->GetDFlags()) || !P_DENYWRITE(_pgfst->GetDFlags())) &&
        DfIsRemoteFile (_hFile))
        fsErr (EH_Err, STG_E_INVALIDFUNCTION);

    filestDebug((DEB_MAP, "File=%2x Init_MemoryMap filesize = %x\n",
                        _hFile, cbFileSize));

#if DBG==1
    //
    // DEBUG ASSERT
    // If the file is a temp file it must be delete on release.
    // The performance of mapped temp files that are not DELETE_ON_CLOSE
    // is very slow on FAT.
    //
    if(RSF_TEMPFILE & GetStartFlags())
        fsAssert(RSF_DELETEONRELEASE & GetStartFlags());
#endif

//
// This routine makes two kinds of mapping.
//  1) Writeable mappings over filesystem files that grow.
//  2) Readonly mappings over filesystem files that are fixed size.
//
    //
    // If we are opening for writing then grow the mapping upto
    // some limit so there is room for writes to extend the file.
    // If we are opening for reading then the mapping is the same
    // size as the original file.
    //
    if(_pgfst->GetDFlags() & DF_WRITE)
    {
        dwPageFlags = PAGE_READWRITE;
        dwMapFlags = FILE_MAP_WRITE;
        //
        // Nt can't Memory map a zero length file, so if the file is
        // zero length and we are open for writing then grow the file
        // to one sector before we create the memory map.  But don't set
        // the MappedFileSize or MappedCommitSize because the docfile
        // code uses filesize==0 to determine if this is a create or an
        // open.  So it is important to not expose the fact that we grew
        // the file.
        //
        if (0 == cbFileSize)
        {
            //Grow the file to 512 bytes in the create path - in the
            //open path we don't want to change the file size.
            //For the open path, don't map it - we'll fail later with
            //STG_E_INVALIDHEADER.
            if ((GetStartFlags() & RSF_CREATE) ||
                (GetStartFlags() & RSF_TEMPFILE))
            {
                if (SUCCEEDED(MakeFileStub()))
                    fMakeStub = TRUE;
            }
            else
                fsErr(EH_Err, E_OUTOFMEMORY);
        }
        
        if(cbFileSize < MINIMUM_MAPPING_SIZE/2)
            cbViewSize = MINIMUM_MAPPING_SIZE;
        else
            cbViewSize = cbFileSize * 2;
    }
    else
    {
        dwPageFlags = PAGE_READONLY;
        dwMapFlags = FILE_MAP_READ;
        cbViewSize = cbFileSize;
    }

    //
    // Get the mapping object.  Either open the existing one for this
    // file.   Or if this is the first open for this "DF context" then
    // create a new one.
    //
    if(NULL == _pgfst->GetMappingName())
    {
        //
        // If this is a first open for this "context" then we won't have
        // a name and the Unmarshaling flag should be FALSE.
        //
        //fsAssert(!(dwFSInit & FSINIT_UNMARSHAL));

        //
        // Create a new unique name for the Mapping.
        //
        AllocateLocallyUniqueId(&luid);
        StringCbPrintfW (pwcMapName, sizeof(pwcMapName),
                         MAPNAME_FORMAT, luid.HighPart, luid.LowPart);
        _pgfst->SetMappingName(pwcMapName);

        //
        //  Do not map very large files since they can consume
        //  too much virtual memory
        //
        MEMORYSTATUS memstatus;
        GlobalMemoryStatus (&memstatus);
        if (cbFileSize > memstatus.dwTotalPhys / 2 ||
            memstatus.dwAvailVirtual < DOCFILE_SM_LIMIT / 2)
            fsErr(EH_Err, E_OUTOFMEMORY);

        filestDebug((DEB_MAP,
                    "File=%2x New MappingName='%ws' FileName='%ws'\n",
                            _hFile, pwcMapName, _pgfst->GetName() ));


        //
        // Create the Mapping.  This only covers the orignal file size.
        //      RESERVED uncommitted extensions are done in MapView.
        //
        _hMapObject = CreateFileMappingW(_hFile,
                            NULL,          // default Security Descriptor.
                            dwPageFlags,
                            0, 0,  // Creation size of 0 means The Entire File.
                            _pgfst->GetMappingName()
        );

        //
        // This mapping is new and did not exist previously.
        //
        fsAssert(ERROR_ALREADY_EXISTS != GetLastError());

        //
        // Record the size of the file (also the commited region of the map)
        // We waited to record the size until after the mapping is created.
        // A seperate open could have shortened the file in the time between
        // the top of this routine and here.  But SetEndOfFile is disallowed
        // once a file mapping is active.
        // Note: Watch out for the case where the file is logically zero size
        // but we grew it a little so we could memory map it.
        //
        if(0 != cbFileSize)
        {
            cbFileSize = GetFileSize(_hFile, &cbFileSizeHigh);
            if (cbFileSize == MAX_ULONG && NO_ERROR != GetLastError())
            {
                sc = LAST_STG_SCODE;
                if (_hMapObject != NULL)
                {
                    CloseHandle (_hMapObject);
                    _hMapObject = NULL;
                }
                fsErr(EH_Err, sc)
            }
            fsAssert (cbFileSizeHigh == 0);
            _pgfst->SetMappedFileSize(cbFileSize);
            _pgfst->SetMappedCommitSize(cbFileSize);
        }

    }
    else
    {
        //
        // If the global object already has a mapping name then this must
        // be an unmarshal.   Or we could be in the 2nd init of a scratch
        // file that is "demanded" after it was first marshaled.
        //
        fsAssert( (dwFSInit & FSINIT_UNMARSHAL)
                                || (GetStartFlags() & RSF_SCRATCH) );

        filestDebug((DEB_MAP,
                    "File=%2x UnMarshal MappingName='%ws' FileName='%ws'\n",
                            _hFile, _pgfst->GetMappingName(),
                            _pgfst->GetName() ));

        // If the global object says the mapping is off,
        // then some other instance of this FileStream has declared
        // the mapping unuseable and no other instance should map it either.
        //
        if( ! _pgfst->TestMapState(FSTSTATE_MAPPED))
        {
            filestDebug((DEB_MAP, "Global Flag says Don't Map.\n"));
            filestDebug((DEB_ITRACE, "Out Init_MemoryMap() => %lx\n", E_FAIL));
            return E_FAIL;
        }

        _hMapObject = OpenFileMapping(dwMapFlags,
                            FALSE,          // Don't Inherit
                            _pgfst->GetMappingName()
        );
    }

    if (NULL == _hMapObject)
    {
        filestDebug((DEB_IWARN|DEB_MAP,
                        "File=%2x Create FileMapping '%ws' for "
                        "filename '%ws' failed, error=0x%x\n",
                        _hFile,
                        _pgfst->GetMappingName(),
                        _pgfst->GetName(),
                        GetLastError()));
        fsErr(EH_Err, E_OUTOFMEMORY);
    }

    filestDebug((DEB_MAP,
                "File=%2x Map=%2x filesize=0x%06x, commitsize=0x%06x\n",
                        _hFile, _hMapObject,
                        _pgfst->GetMappedFileSize(),
                        _pgfst->GetMappedCommitSize()));

    //
    // Add the file map to the process' address space.
    //
    if(FAILED(MapView(cbViewSize, dwPageFlags, dwFSInit)))
    {
        TurnOffAllMappings();
        fsErr(EH_Err, E_OUTOFMEMORY);
    }
    return S_OK;

EH_Err:
    //
    // If we can't get a mapping then set a flag so no other marshal's
    // of this context should try either.
    //
    _pgfst->ResetMapState(FSTSTATE_MAPPED);

    if (fMakeStub) // try to reset the filesize back to 0
    {
        SetFilePointer(_hFile, 0, NULL, FILE_BEGIN);
        SetEndOfFile(_hFile);
    }
        
    filestDebug((DEB_ITRACE, "Out Init_MemoryMap() => %lx\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::MakeFileStub, private
//
//  Synopsis:	Takes a zero length file and makes it 512 bytes.  This is
//              needed to support NT file mapping.  The important effects
//              are that it does NOT set the saved file size.
//
//  History:	09-Mar-96   Bchapman       Created
//
//---------------------------------------------------------------

HRESULT CFileStream::MakeFileStub()
{
    SCODE sc=S_OK;
#if DBG == 1
    ULONG cbFileSizeHigh;
#endif
    

    fsAssert(0 == GetFilePointer());
#if DBG == 1
    fsAssert(0 == GetFileSize(_hFile, &cbFileSizeHigh));
    fsAssert(0 == cbFileSizeHigh);
#endif

    SetFilePointer(_hFile, 512, NULL, FILE_BEGIN);

    if(FALSE == SetEndOfFile(_hFile))
        sc = LAST_STG_SCODE; 

    SetFilePointer(_hFile, 0, NULL, FILE_BEGIN);

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::MapView, private
//
//  Synopsis:	Maps a view of an existing File Mapping.
//
//  Arguments:  Size of the mapping, including extra space for RESERVED
//              pages that can be added with VIrtualAlloc.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  Private Effect:     Sets _pbBaseAddr
//                      Sets _cbViewSize
//
//  Note:
//
//  History:	25-Nov-96   Bchapman       Created
//
//---------------------------------------------------------------

HRESULT CFileStream::MapView(
            SIZE_T cbViewSize,
            DWORD dwPageFlags,
            DWORD dwFSInit)
{
    filestDebug((DEB_ITRACE, "In  MapView(0x%06x, 0x%x)\n",
                                cbViewSize, dwPageFlags));

    PVOID pvBase=NULL;
    LARGE_INTEGER SectionOffset;
    NTSTATUS Status;
    DWORD dwAllocationType = 0;

    LISet32(SectionOffset, 0);

    // confirm that we are mapping the whole file.
    fsAssert(cbViewSize >= _pgfst->GetMappedFileSize());

    if((PAGE_READWRITE & dwPageFlags))
        dwAllocationType = MEM_RESERVE;     // RESERVE uncommited pages.

    Status = NtMapViewOfSection(
                _hMapObject,
                GetCurrentProcess(),
                &pvBase,        // returned pointer to base of map.  If the
                                // initial value is non-Zero it is a "Hint".
                0L,             // ZeroBits: see ntos\mm\mapview.c
                0L,             // Commit: amount to initially Commit.
                &SectionOffset, // Offset in file for base of Map.
                &cbViewSize,    // Size of VirtAddr chunk to reserve.
                ViewShare,
                dwAllocationType,
                dwPageFlags);
    if(NT_ERROR(Status))
    {
        filestDebug((DEB_WARN|DEB_MAP,
                    "File=%2x NtMapViewOfSection Failed, viewsize=0x%06x, "
                    "dwPageFlags=%x, status=0x%x\n",
                    _hFile, _cbViewSize, dwPageFlags, Status));
        return E_OUTOFMEMORY;
    }

    _pgfst->SetMapState(FSTSTATE_MAPPED);
    _pbBaseAddr = (LPBYTE)pvBase;
    _cbViewSize = (ULONG)cbViewSize;

    filestDebug((DEB_MAP,
                "File=%2x Attaching Map: address=0x%07x, viewsz=0x%06x, "
                "commitsz=0x%06x\n",
                        _hFile, _pbBaseAddr, _cbViewSize,
                        _pgfst->GetMappedCommitSize()));

    filestDebug((DEB_ITRACE, "Out MapView => %lx\n", S_OK));
    return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:	CFileStream::TurnOffMapping, private
//
//  Synopsis:	Turns off the use of file mapping
//
//  Private Effect:     Clears _pbBaseAddr
//                      Clears _hMapObject
//
//  History:	31-Aug-96   DrewB       Created
//              22-Oct-96   BChapman    Trim the End of File.
//                 Nov-96   BChapman    Rewrote
//
//---------------------------------------------------------------

SCODE CFileStream::TurnOffMapping(BOOL fFlush)
{
    filestDebug((DEB_ITRACE, "In  TurnOffMapping(%d)\n", fFlush));

    //
    //  We want to be make sure the file mapping was in use.  Otherwise
    // the "MappedFileSize" may not be valid when we truncate the file
    // below.  Which destroys data.
    //
    // Checking for the map object is better than checking the base pointer
    // because this routine can be called when remapping the view.
    // Then the base pointer will be NULL but we still have a map object.
    //
    if(NULL == _hMapObject)
        return S_OK;

    //
    // Release the view of the map.  And release the Map Object.
    //  Don't exit on errors.  Do as much as we can.
    //
    if(NULL != _pbBaseAddr)
    {
        filestDebug((DEB_MAP, "File=%2x Detaching Map 0x%07x\n",
                                    _hFile, _pbBaseAddr));
        // the redirector cannot handle a dirty file mapping followed by
        // ReadFile calls; local filesystems have a single coherent cache
        // fortunately, we no longer map docfiles over the redirector
        if (fFlush)
            fsVerify(FlushViewOfFile(_pbBaseAddr, 0));
        fsVerify(UnmapViewOfFile(_pbBaseAddr));
        _pbBaseAddr = NULL;
    }

    if(NULL != _hMapObject)
    {
        fsVerify(CloseHandle(_hMapObject));
        _hMapObject = NULL;
    }

    filestDebug((DEB_MAP, "File=%2x TurnOffMapping RefCount=%x\n",
                        _hFile, _pgfst->CountContexts()));

    //
    // If file was open for writing, and this is the last/only instance
    // of this "DF context" then truncate the file to the proper size.
    // We do this when the file may have grown by commiting pages on
    // the end of the memory map, the system will grow the file in
    // whole MMU page units, so we may need to trim the extra off.
    //
    // Don't do this in the case of multiple 'seperate' writers.  Last
    // close wins on the file size and that is not good.
    //
    // Don't fail on errors.  We are only trimming the EOF.
    //
    // Bugfix Feb '98 BChapman
    //  Don't Set EOF unless the map was written to or SetSize was called.
    //  Many people were opening READ/WRITE, not writing, and expecting the
    //  Mod. time to remain unchanged.
    //
    if( (_pgfst->CountContexts() == 1)
          && (_pgfst->GetDFlags() & DF_WRITE)
          && (_pgfst->TestMapState(FSTSTATE_DIRTY) ) )
    {
#ifdef LARGE_DOCFILE
        ULONGLONG ret;
#else
        ULONG ret;
#endif
        ULONG cbFileSize = _pgfst->GetMappedFileSize();

        ret = SeekTo( cbFileSize );

#ifdef LARGE_DOCFILE
        if (ret == MAX_ULONGLONG)  // 0xFFFFFFFFFFFFFFFF
#else
        if (ret == 0xFFFFFFFF)
#endif
        {
            filestDebug((DEB_ERROR,
                        "File Seek in TurnOffMapping failed err=0x%x\n",
                        GetLastError()));
            return S_OK;
        }

        filestDebug((DEB_MAP,
                    "File=%2x TurnOffMapping->SetEndOfFile 0x%06x\n",
                            _hFile, cbFileSize));

        if(FALSE == SetEndOfFile(_hFile))
        {
            filestDebug((DEB_WARN,
                        "File=%2x SetEndOfFile in TurnOffMapping Failed. "
                        "file may still be open 'seperately'\n",
                                _hFile));
        }
    }

    filestDebug((DEB_ITRACE, "Out TurnOffMapping => S_OK\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::ExtendMapView, private
//
//  Synopsis:	Unmaps the Map object and creates a bigger View based
//              on the new request size.   The cbRequest is the requested
//              real size.  So we make a view larger than that to leave room.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  History:	20-Feb-97   BChapman    Created.
//
//---------------------------------------------------------------

#define MAX_MAPVIEW_GROWTH  (5*1024*1024)

SCODE CFileStream::ExtendMapView(ULONG cbRequest)
{
    ULONG dwPageFlag;
    ULONG cbNewView;

    //
    // Confirm that we were not needlessly called.
    //
    fsAssert(cbRequest > _cbViewSize);

    //
    //  If the mapping is small, then grow it by doubling.
    //  If the mapping is big add a fixed amount.
    //
    if(cbRequest < MAX_MAPVIEW_GROWTH)
        cbNewView = cbRequest * 2;
    else
        cbNewView = cbRequest + MAX_MAPVIEW_GROWTH;

    //
    // Someone else may have grown the mapping a huge amount.
    // If that is the case then increase the New View to include the
    // entire existing file.
    //
    if(cbNewView < _pgfst->GetMappedFileSize())
        cbNewView = _pgfst->GetMappedFileSize();

    filestDebug((DEB_MAP,
            "File=%2x Mapping view is being grown from 0x%06x to 0x%06x\n",
            _hFile, _cbViewSize, cbNewView));

    //
    //  Unmap the View and re-map it at more than the currenly needed size.
    //
    filestDebug((DEB_MAP, "File=%2x Detaching Map 0x%07x to grow it.\n",
                                                _hFile, _pbBaseAddr));
    fsVerify(UnmapViewOfFile(_pbBaseAddr));
    _pbBaseAddr = NULL;

    //
    // We know the mode must be read/write because we are growing.
    //
    if(FAILED(MapView(cbNewView, PAGE_READWRITE, 0)))
    {
        TurnOffAllMappings();
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+--------------------------------------------------------------
//  Helper routine to round up memory request in a consistant manner.
//+--------------------------------------------------------------

ULONG BlockUpCommit(ULONG x) {
    return((x+COMMIT_BLOCK-1) & (~(COMMIT_BLOCK-1)));
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::MakeFileMapAddressValidWorker, private
//
//  Synopsis:	Commits reserved pages that extend a writable
//              Memory Mapped file.  Used by WriteAt and SetSize.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  History:	31-Oct-96   BChapman    Created.
//
//---------------------------------------------------------------

SCODE CFileStream::MakeFileMapAddressValidWorker(
            ULONG cbRequested,
            ULONG cbCommitedSize)
{
    ULONG cbNeeded;
    ULONG iStart, cbGrown;
    SCODE sc;

    filestDebug((DEB_ITRACE|DEB_MAP,
                    "File=%2x MakeFileMappingAddressValidWorker(0x%06x)\n",
                    _hFile, cbRequested));

    // Assert we are not completely confused.
    fsAssert(IsFileMapped());
    fsAssert(cbCommitedSize >= _pgfst->GetMappedFileSize());

    // Assert we were called correctly.
    fsAssert(cbCommitedSize == _pgfst->GetMappedCommitSize());
    fsAssert(cbRequested > cbCommitedSize);

    //
    // We allocate pages in clumps to cut down on little VirtualAlloc calls.
    //
    cbNeeded = BlockUpCommit(cbRequested);

    //
    //  If the needed commit size is bigger than the view window, then
    // make the view size bigger first.
    //
    if(FAILED(CheckMapView(cbNeeded)))
        return E_OUTOFMEMORY;

    //
    // Now commit the new pages.
    //
    iStart = cbCommitedSize;
    cbGrown = cbNeeded - cbCommitedSize;

    filestDebug((DEB_MAP,
            "File=%2x VirtualAlloc map=0x%07x[0x%06x] + 0x%06x(0x%06x)\n",
                    _hFile, _pbBaseAddr,
                    iStart, cbGrown, cbNeeded));

    if(NULL==VirtualAlloc(
                (void*)&_pbBaseAddr[iStart],
                cbGrown,
                MEM_COMMIT,
                PAGE_READWRITE))
    {
        // Ran out of Virtual Memory or Filesystem disk space.
        filestDebug((DEB_ERROR|DEB_MAP,
                    "File=%2x VirtualAlloc(%x + %x) 1st Failure=%x.\n",
                    _hFile,
                    &_pbBaseAddr[iStart],
                    cbGrown,
                    GetLastError()));

        //
        // If the VirutalAlloc failed we try again.  The original
        // request was rounded up to some large block size so there
        // is a slim hope that we might get just what we need.
        //
        cbNeeded = cbRequested;
        cbGrown = cbNeeded - cbCommitedSize;

        filestDebug((DEB_MAP,
                "File=%2x Retry VirtualAlloc map=0x%07x[0x%06x] + 0x%06x(0x%06x)\n",
                        _hFile, _pbBaseAddr,
                        iStart, cbGrown, cbNeeded));

        if(NULL==VirtualAlloc(
                    (void*)&_pbBaseAddr[iStart],
                    cbGrown,
                    MEM_COMMIT,
                    PAGE_READWRITE))
        {
            // Ran out of Virtual Memory or Filesystem disk space.
            filestDebug((DEB_ERROR|DEB_MAP,
                        "File=%2x VirtualAlloc(%x + %x) 2nd Failure=%x.\n",
                                _hFile,
                                &_pbBaseAddr[iStart],
                                cbGrown,
                                GetLastError()));

            TurnOffMapping(TRUE);
            if (_pgfst != NULL)
                _pgfst->ResetMapState(FSTSTATE_MAPPED);
            return E_OUTOFMEMORY;
        }
    }

    _pgfst->SetMappedCommitSize(cbNeeded);

    return S_OK;
}

#endif      // Memory Mapped File Support

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::InitFromHandle, public
//
//  Synopsis:   Creates a filestream by duping an existing handle
//
//  Arguments:  [h] - Handle
//
//  Returns:    Appropriate status code
//
//  History:    09-Feb-94       DrewB   Created
//
//  Notes:      Intended only for creating a temporary ILockBytes on a file;
//              does not create a true CFileStream; there is no
//              global filestream, no access flags, etc.
//
//----------------------------------------------------------------------------

SCODE CFileStream::InitFromHandle(HANDLE h)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::InitFromHandle:%p(%p)\n",
                 this, h));

    if (!DuplicateHandle(GetCurrentProcess(), h, GetCurrentProcess(), &_hFile,
                         0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        sc = LAST_STG_SCODE;
    }
    else
    {
        sc = S_OK;
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::InitFromHandle\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::~CFileStream, public
//
//  Synopsis:   Destructor
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------
CFileStream::~CFileStream(void)
{
    filestDebug((DEB_ITRACE, "In  CFileStream::~CFileStream()\n"));
    fsAssert(_cReferences == 0);
    _sig = CFILESTREAM_SIGDEL;

    CheckSeekPointer();

    if (INVALID_FH != _hPreDuped)
        fsVerify(CloseHandle(_hPreDuped));

    if (INVALID_FH != _hFile)
    {
        filestDebug((DEB_INFO, "~CFileStream %p handle %p thread %lX\n",
                    this, _hFile, GetCurrentThreadId()));

        //
        // A CFileStream normally _always_ had a global object connected
        // to it.  But due to the abuses of the Debug Logger we need to
        // check this here.  Also see "CFileStream::InitFromHandle"
        //
        if(_pgfst)
            TurnOffMapping(FALSE);

        fsVerify(CloseHandle(_hFile));
#ifdef ASYNC
        if ((_pgfst) &&
            (_pgfst->GetTerminationStatus() == TERMINATED_ABNORMAL))
        {
            WCHAR *pwcsName;
            SCODE sc = GetName(&pwcsName);
            if (SUCCEEDED(sc))
            {
                DeleteTheFile(pwcsName);
                TaskMemFree(pwcsName);
            }
        }
#endif //ASYNC
    }
    if (_hReserved != INVALID_FH)
    {
        filestDebug((DEB_INFO, "~CFileStream reserved %p "
                    "handle %p thread %lX\n",
                    this, _hReserved, GetCurrentThreadId()));
        fsVerify(CloseHandle(_hReserved));
        _hReserved = INVALID_FH;
    }

    if (_pgfst)
    {
        _pgfst->Remove(this);
        if (_pgfst->HasName())
        {
            if (0 == _pgfst->CountContexts())
            {
                // Delete zero length files also.  A zero length file
                // is not a valid docfile so don't leave them around
                if (_pgfst->GetStartFlags() & RSF_DELETEONRELEASE)
                {
                    // This is allowed to fail if somebody
                    // else has the file open
                    DeleteTheFile(_pgfst->GetName());
                }
            }
        }
        _pgfst->Release();
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::~CFileStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReadAt, public
//
//  Synopsis:   Reads bytes at a specific point in a stream
//
//  Arguments:  [ulPosition] - Offset in file to read at
//              [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::ReadAt(ULARGE_INTEGER ulPosition,
                                 VOID *pb,
                                 ULONG cb,
                                 ULONG *pcbRead)
{
    SCODE sc;
    LONG lHigh = ULIGetHigh(ulPosition);
    ULONG uLow = ULIGetLow(ulPosition);

#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif
    fsAssert((!IsFileMapped() || lHigh == 0) &&
             aMsg("High dword other than zero passed to filestream."));

    filestDebug((DEB_ITRACE, "In  CFileStream::ReadAt("
                 "%x:%x, %p, %x, %p)\n", ULIGetHigh(ulPosition),
                 ULIGetLow(ulPosition), pb, cb, pcbRead));

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);
    *pcbRead = 0;

#ifdef ASYNC
    DWORD dwTerminate;
    dwTerminate = _pgfst->GetTerminationStatus();
    if (dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((dwTerminate != TERMINATED_NORMAL) &&
#ifdef LARGE_DOCFILE
             (ulPosition.QuadPart + cb > _pgfst->GetHighWaterMark()))
#else
             (uLow + cb > _pgfst->GetHighWaterMark()))
#endif
    {
        *pcbRead = 0;
#ifdef LARGE_DOCFILE
        _pgfst->SetFailurePoint(cb + ulPosition.QuadPart);
#else
        _pgfst->SetFailurePoint(cb + uLow);
#endif
        sc = E_PENDING;
    }
    else
    {
#endif
        if(!IsFileMapped())
        {                           // Read w/ ReadFile()
#ifdef LARGE_DOCFILE
            sc = ReadAt_FromFile(ulPosition.QuadPart, pb, cb, pcbRead);
#else
            sc = ReadAt_FromFile(uLow, pb, cb, pcbRead);
#endif
        }
        else
        {                           // Read from Map
            sc = ReadAt_FromMap(uLow, pb, cb, pcbRead);
            if (!SUCCEEDED(sc))
#ifdef LARGE_DOCFILE
               sc = ReadAt_FromFile(ulPosition.QuadPart, pb, cb, pcbRead);
#else
               sc = ReadAt_FromFile(uLow, pb, cb, pcbRead);
#endif
        }

#ifdef ASYNC
    }
#endif

    olLowLog(("STGIO - Read : %8x at %8x, %8d, %8d <--\n", _hFile, uLow, cb, *pcbRead));

    filestDebug((DEB_ITRACE, "Out CFileStream::ReadAt => %x\n", sc));
    
    CheckSeekPointer();
    return sc;
}


#ifdef USE_FILEMAPPING

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReadAt_FromMap, private
//
//  Synopsis:   Reads bytes at a specific point from the file mapping
//
//  Arguments:  [iPosition] - Offset in file
//              [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    16-Jan-97       BChapman   Created
//
//---------------------------------------------------------------
SCODE CFileStream::ReadAt_FromMap(
            ULONG iPosition,
            VOID  *pb,
            ULONG cb,
            ULONG *pcbRead)
{
    SCODE sc = S_OK;
    ULONG cbRead=0;
    ULONG cbFileSize = _pgfst->GetMappedFileSize();
    //
    // If any of the read is before the End of File then
    // we can read something.  Reads at EOF
    //
    *pcbRead = 0;
    if (iPosition < cbFileSize)
    {
        ULONG cbTail;

        filestDebug((DEB_MAPIO,
                    "File=%2x Read MapFile @ 0x%06x, 0x%04x, bytes\n",
                            _hFile, iPosition, cb));

        //
        // Possibly shorted the read request to fit inside
        // the logical End of File.
        //
        cbTail = cbFileSize - iPosition;

        if (cb < cbTail)
            cbRead = cb;
        else
            cbRead = cbTail;

        if(cb != cbRead)
        {
            filestDebug((DEB_MAPIO,
                        "File=%2x\t\t(Short Read 0x%04x bytes)\n",
                                _hFile, cbRead));
        }

        sc = CheckMapView(iPosition+cbRead);
        if (SUCCEEDED(sc))
        {
            __try
            {
                memcpy (pb, _pbBaseAddr+iPosition, cbRead);
                *pcbRead = cbRead;
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                filestDebug((DEB_WARN|DEB_MAP,
                    "File=%2x Mapfile READFAULT Xfer 0x%x bytes @ 0x%x %x\n",
                    _hFile, cbRead, iPosition, GetExceptionCode()));
                sc = STG_E_READFAULT;
            }
        }
        else // lost the file mapping
            sc = ReadAt_FromFile(iPosition, pb, cb, pcbRead);
    }
    else
    {
        if(cbFileSize < iPosition)
        {
            filestDebug((DEB_WARN|DEB_MAP,
                "File=%2x Read MapFile @ 0x%x, 0x%x bytes is entirely "
                "off the end @ 0x%x\n",
                        _hFile, iPosition, cb, cbFileSize));

            fsAssert(cbFileSize > iPosition);
        }
    }
    filestDebug((DEB_ITRACE, "Out CFileStream::ReadAt => %x\n", sc));
    return sc;
}

#endif // USE_FILEMAPPING

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReadAt_FromFile, private
//
//  Synopsis:   Reads bytes at a specific point from the file mapping
//
//  Arguments:  [iPosition] - Offset in file
//              [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    16-Jan-97       BChapman   Created
//
//---------------------------------------------------------------
SCODE CFileStream::ReadAt_FromFile(
#ifdef LARGE_DOCFILE
            ULONGLONG iPosition,
#else
            ULONG iPosition,
#endif
            VOID  *pb,
            ULONG cb,
            ULONG *pcbRead)
{
    SCODE sc = S_OK;

    if(0 == cb)
    {
        *pcbRead = 0;
        return S_OK;
    }

#ifndef USE_OVERLAPPED
    negChk(SeekTo(iPosition));

    filestDebug((DEB_FILEIO,
                "File=%2x ReadFile (old code) @ 0x%06x, 0x%04x bytes\n",
                _hFile, iPosition, cb));
    boolChk(ReadFile(_hFile, pb, cb, pcbRead, NULL));

    if(cb != *pcbRead)
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x\t\t(Short read 0x%x bytes)\n",
                            _hFile, *pcbRead));
    }

#else // ifndef USE_OVERLAPPED
    if (!FilePointerEqual(iPosition))
    {
        OVERLAPPED Overlapped;
#ifdef LARGE_DOCFILE
        LARGE_INTEGER ulPosition;
        ulPosition.QuadPart = iPosition;

        Overlapped.Offset = ulPosition.LowPart;
        Overlapped.OffsetHigh = ulPosition.HighPart;
#else
        Overlapped.Offset = iPosition;
        Overlapped.OffsetHigh = 0;
#endif
        Overlapped.hEvent = NULL;

        filestDebug((DEB_FILEIO,
                    "File=%2x ReadFile (w/seek) @ 0x%06x, 0x%04x bytes\n",
                    _hFile, (ULONG)iPosition, cb));
        if (!ReadFile(_hFile, pb, cb, pcbRead, &Overlapped))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
                fsErr(EH_Err, LAST_STG_SCODE);
        }
    }
    else
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x ReadFile @ 0x%Lx, 0x%04x bytes\n",
                    _hFile, iPosition, cb));
        boolChk(ReadFile(_hFile, pb, cb, pcbRead, NULL));
    }

    if(cb != *pcbRead)
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x\t\t(Short read 0x%04x bytes)\n",
                            _hFile, *pcbRead));
    }
#endif // USE_OVERLAPPED

    // if 0 bytes were read, the seek pointer has not changed
    if (*pcbRead > 0)
        SetCachedFilePointer(iPosition + *pcbRead);

    return S_OK;

EH_Err:
    filestDebug((DEB_ERROR|DEB_FILEIO, "ReadAt_FromFile Error = %x\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::WriteAt, public
//
//  Synopsis:   Writes bytes at a specific point in a stream
//
//  Arguments:  [ulPosition] - Offset in file
//              [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------
STDMETHODIMP CFileStream::WriteAt(ULARGE_INTEGER ulPosition,
                                  VOID const *pb,
                                  ULONG cb,
                                  ULONG *pcbWritten)
{
    SCODE sc;
    LONG lHigh = ULIGetHigh(ulPosition);
    ULONG uLow = ULIGetLow(ulPosition);

#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif
#ifndef LARGE_DOCFILE
    fsAssert(lHigh == 0 && 
             aMsg("High dword other than zero passed to filestream."));
#endif


    filestDebug((DEB_ITRACE, "In  CFileStream::WriteAt:%p("
                 "%x:%x, %p, %x, %p)\n", this, ULIGetHigh(ulPosition),
                 ULIGetLow(ulPosition), pb, cb, pcbWritten));

#ifdef ASYNC
    DWORD dwTerminate;
    dwTerminate = _pgfst->GetTerminationStatus();
    if (dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((dwTerminate == TERMINATED_NORMAL) ||
             (uLow + cb <= _pgfst->GetHighWaterMark()))
    {
#endif
#ifdef LARGE_DOCFILE
        sc = WriteAtWorker(ulPosition, pb, cb, pcbWritten);
#else
        sc = WriteAtWorker(uLow, pb, cb, pcbWritten);
#endif
#ifdef ASYNC
    }
    else
    {
        *pcbWritten = 0;
#ifdef LARGE_DOCFILE
        _pgfst->SetFailurePoint(cb + ulPosition.QuadPart);
#else
        _pgfst->SetFailurePoint(cb + uLow);
#endif
        sc = E_PENDING;
    }

#endif

    filestDebug((DEB_ITRACE, "Out CFileStream::WriteAt => %x\n", sc));
    return sc;
}


#ifdef LARGE_DOCFILE
SCODE CFileStream::WriteAtWorker(ULARGE_INTEGER ulPosition,
#else
SCODE CFileStream::WriteAtWorker(ULONG uLow,
#endif
                                 VOID const *pb,
                                 ULONG cb,
                                 ULONG *pcbWritten)
{
    SCODE sc;
#ifdef LARGE_DOCFILE
    ULONG uLow = ulPosition.LowPart;
#endif

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);
    *pcbWritten = 0;

#ifdef LARGE_DOCFILE
    fsChk(PossibleDiskFull(ulPosition.QuadPart + cb));
#else
    fsChk(PossibleDiskFull(uLow + cb));
#endif

#ifdef USE_FILEMAPPING
#ifdef LARGE_DOCFILE
    if (ulPosition.QuadPart + cb < MAX_ULONG/2)
        MakeFileMapAddressValid(uLow + cb);
    else
        TurnOffMapping(TRUE);
#else
    MakeFileMapAddressValid(uLow + cb);
#endif

    if (IsFileMapped())
    {
        filestDebug((DEB_MAPIO,
                        "File=%2x Write Mapfile @ 0x%06x, 0x%04x bytes\n",
                        _hFile, uLow, cb));

        __try
            {
                memcpy (_pbBaseAddr+uLow, pb, cb);
            }
        __except (EXCEPTION_EXECUTE_HANDLER)
            {
                filestDebug((DEB_WARN|DEB_MAP,
                    "File=%2x Mapfile WRITEFAULT Xfer 0x%x bytes @ 0x%x %x\n",
                    _hFile, cb, uLow, GetExceptionCode()));
                return STG_E_WRITEFAULT;
            }
        *pcbWritten = cb;

        _pgfst->SetMapState(FSTSTATE_DIRTY);

        if(_pgfst->GetMappedFileSize() < uLow + cb)
            _pgfst->SetMappedFileSize(uLow + cb);
        return S_OK;
    }
#endif

#ifndef USE_OVERLAPPED
#ifdef LARGE_DOCFILE
    negChk(SeekTo(ulPosition.QuadPart));
#else
    negChk(SeekTo(uLow));
#endif

    filestDebug((DEB_FILEIO,
                "File=%2x WriteFile (old code) @ 0x%06x, 0x%04x bytes\n",
                _hFile, uLow, cb));
    boolChk(WriteFile(_hFile, pb, cb, pcbWritten, NULL));
#else // ifndef USE_OVERLAPPED
#ifdef LARGE_DOCFILE
    if (!FilePointerEqual(ulPosition.QuadPart))
#else
    if (!FilePointerEqual(uLow))
#endif
    {
        OVERLAPPED Overlapped;
#ifdef LARGE_DOCFILE
        Overlapped.Offset = ulPosition.LowPart;
        Overlapped.OffsetHigh = ulPosition.HighPart;
#else
        Overlapped.Offset = uLow;
        Overlapped.OffsetHigh = 0;
#endif
        Overlapped.hEvent = NULL;
        filestDebug((DEB_FILEIO,
                    "File=%2x WriteFile (w/seek) @ 0x%06x, 0x%04x bytes\n",
                    _hFile, uLow, cb));
        boolChk(WriteFile(_hFile, pb, cb, pcbWritten,&Overlapped));
    }
    else
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x WriteFile @ 0x%06x, 0x%04x bytes\n",
                    _hFile, uLow, cb));
        boolChk(WriteFile(_hFile, pb, cb, pcbWritten, NULL));
    }
#endif
#ifdef LARGE_DOCFILE
    SetCachedFilePointer(ulPosition.QuadPart + *pcbWritten);
#else
    SetCachedFilePointer(uLow + *pcbWritten);
#endif
    if(_pgfst->GetMappedFileSize() < uLow + cb)
       _pgfst->SetMappedFileSize(uLow + cb);

    olLowLog(("STGIO - Write: %8x at %8x, %8d, %8d -->\n", _hFile, uLow, cb, *pcbWritten));

    sc = S_OK;

EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Flush, public
//
//  Synopsis:   Flushes buffers
//
//  Returns:    Appropriate status code
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::Flush(void)
{
    CheckSeekPointer();

#if WIN32 == 200
    SCODE sc = S_OK;

    if (_hReserved == INVALID_FH)
    {
        if (!DuplicateHandle(GetCurrentProcess(), _hFile, GetCurrentProcess(),
                             &_hReserved, 0, FALSE, DUPLICATE_SAME_ACCESS))
        {
            //We couldn't get a handle, so flush everything just to be
            //safe.
            sc = FlushCache();
        }
        else
        {
            fsAssert(_hReserved != INVALID_FH);
            fsVerify(CloseHandle(_hReserved));
            _hReserved = INVALID_FH;
        }
    }
    else
    {
        //In this case, we already have a duplicate of the file handle
        //  reserved, so close it, then reopen it again.
        fsVerify(CloseHandle(_hReserved));
        _hReserved = INVALID_FH;
    }

    if ((_hReserved == INVALID_FH) && (_grfLocal & LFF_RESERVE_HANDLE))
    {
        //Reacquire reserved handle.
        //If this fails there isn't anything we can do about it.  We'll
        //  try to reacquire the handle later when we really need it.
        DuplicateHandle(GetCurrentProcess(), _hFile, GetCurrentProcess(),
                        &_hReserved, 0, FALSE, DUPLICATE_SAME_ACCESS);
    }

    return ResultFromScode(sc);
#else

    // Otherwise on NT, the file system does the right thing, we think.
    return S_OK;
#endif
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::FlushCache, public
//
//  Synopsis:   Flushes buffers
//
//  Returns:    Appropriate status code
//
//  History:    12-Feb-93       AlexT   Created
//
//  Notes:
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::FlushCache(void)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::Flush()\n"));
    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    boolChk(FlushFileBuffers(_hFile));
    if (IsFileMapped())
        boolChk(FlushViewOfFile(_pbBaseAddr, 0));
    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::Flush\n"));
EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::SetSize, public
//
//  Synopsis:   Sets the size of the LStream
//
//  Arguments:  [ulSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::SetSize(ULARGE_INTEGER ulSize)
{
    SCODE sc;
#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif

#ifndef LARGE_DOCFILE
    ULONG uLow = ULIGetLow(ulSize);
    LONG lHigh = ULIGetHigh(ulSize);
    fsAssert(lHigh == 0 &&
             aMsg("High dword other than zero passed to filestream."));
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::SetSize:%p(%Lx)\n",
                 this, ulSize.QuadPart));

#ifdef ASYNC
    DWORD dwTerminate;
    dwTerminate = _pgfst->GetTerminationStatus();
    if (dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((dwTerminate == TERMINATED_NORMAL) ||
#ifdef LARGE_DOCFILE
             (ulSize.QuadPart <= _pgfst->GetHighWaterMark()))
#else
             (uLow <= _pgfst->GetHighWaterMark()))
#endif
    {
#endif
#ifdef LARGE_DOCFILE
        sc = SetSizeWorker(ulSize.QuadPart);
#else
        sc = SetSizeWorker(uLow);
#endif
#ifdef ASYNC
    }
    else
    {
#ifdef LARGE_DOCFILE
        _pgfst->SetFailurePoint(ulSize.QuadPart);
#else
        _pgfst->SetFailurePoint(uLow);
#endif
        sc = E_PENDING;
    }
#endif
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::SetSizeWorker, Private
//
//  Synopsis:   Sets the size of the File
//
//  Arguments:  [ulSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//              16-Jan-97       BChapman Added Support for File Mapping
//              08-Mar-97       BChapman Fixes for File Mapping
//
//  Note:  If the file is mapped then we grow the file with VirtualAlloc
//      and shrink it at unmap time with SetEndOfFile() and the intended
//      size recorded in the _pgfst.
//      If we are NOT mapped then we use normal File I/O. But things can
//      get tricky if we are switching from mapped to unmapped and all the
//      other marshalled opens have not yet unmapped.  If anyone has the
//      file mapped then SetEndOfFile doesn't work.
//      To avoid this we grow with WriteFile() and we try to shrink with
//      SetEndOfFile().  But we also always put the intended size in _pgfst,
//      so if the other guy has the file mapped he will shrink the file
//      when he unmaps.
//---------------------------------------------------------------

#ifdef LARGE_DOCFILE
SCODE CFileStream::SetSizeWorker(ULONGLONG ulSize)
#else
SCODE CFileStream::SetSizeWorker(ULONG uLow)
#endif
{
    SCODE sc;

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

#ifdef LARGE_DOCFILE
    fsChk(PossibleDiskFull(ulSize));

    if (ulSize < MAX_ULONG/2)
        MakeFileMapAddressValid((ULONG)ulSize);
    else
        TurnOffMapping(TRUE);
#else
    fsChk(PossibleDiskFull(uLow));

    MakeFileMapAddressValid(uLow);
#endif


    // Always record the intended size, because the mapped size is stored
    // globaly.  You might not be mapped but other marshalled opens could
    // be (they will fall back as soon as they run).
#ifdef USE_FILEMAPPING
#ifdef LARGE_DOCFILE
    // A memory mapped file can never be greater than 2G, even for 64-bit
    // platforms, because of the range locks at offset 2G in the file.
    _pgfst->SetMappedFileSize(ulSize > MAX_ULONG ? MAX_ULONG : (ULONG) ulSize);
#else
    _pgfst->SetMappedFileSize(uLow);
#endif
    _pgfst->SetMapState(FSTSTATE_DIRTY);
#endif // USE_FILEMAPPING

    if(!IsFileMapped())
    {
        ULARGE_INTEGER uliFileSize;
        ULONG ulZero=0;
        DWORD cbWritten;

        fsChk(GetSize(&uliFileSize));

#ifdef LARGE_DOCFILE
        if(uliFileSize.QuadPart == ulSize)
#else
        Assert (0 == uliFileSize.HighPart);

        if(uliFileSize.LowPart == uLow)
#endif
        {
#ifdef LARGE_DOCFILE
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%Lx)"
                                    " size didn't change\n",
                                    _hFile, ulSize));
#else
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%06x)"
                                    " size didn't change\n",
                                    _hFile, uLow));
#endif
            return S_OK;
        }


        // Grow the file.
        //
#ifdef LARGE_DOCFILE
        if(uliFileSize.QuadPart < ulSize &&
           !(_pgfst->GetDFlags() & DF_LARGE))
        {
            ULARGE_INTEGER uli;
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%Lx)"
                                    " increasing from 0x%Lx\n",
                                    _hFile, ulSize, uliFileSize));
            uli.QuadPart = ulSize - 1;
            fsChk(WriteAtWorker(uli, (LPCVOID)&ulZero, 1, &cbWritten));
        }
#else
        if(uliFileSize.LowPart < uLow)
        {
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%06x)"
                                    " increasing from 0x%06x\n",
                                    _hFile, uLow, uliFileSize.LowPart));
            fsChk(WriteAtWorker(uLow-1, (LPCVOID)&ulZero, 1, &cbWritten));
        }
#endif
        // Shrink the file or large sector docfile
        //
        else
        {
#ifdef LARGE_DOCFILE
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%Lx)"
                                    " reducing from 0x%Lx\n",
                                    _hFile, ulSize, uliFileSize));
            negChk(SeekTo(ulSize));
#else
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%06x)"
                                    " reducing from 0x%06x\n",
                                    _hFile, uLow, uliFileSize.LowPart));
            negChk(SeekTo(uLow));
#endif
            if(FALSE == SetEndOfFile(_hFile))
            {
                sc = LAST_STG_SCODE;
                // If a seperate marshaling still has the file mapped then
                // this will fail.  But this particular error is OK.
                //
                if(WIN32_SCODE(ERROR_USER_MAPPED_FILE) == sc)
                {
                    sc = S_OK;
                }
                fsChk (sc);
            }
        }
    }

    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::SetSize\n"));

EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SeekTo, private
//              CFileStream::GetFilePointer, private
//
//  Synopsis:	Wrap calls to SetFilePointer to make the usage more clear.
//              Esp. in the GetFilePointer case.
//
//  History:	07-Nov-96    BChapman Created
//
//----------------------------------------------------------------------------

#ifdef LARGE_DOCFILE
ULONGLONG CFileStream::SeekTo(ULONGLONG ulPos)
{
    LARGE_INTEGER uliPos;

    if(FilePointerEqual(ulPos))
    {
        filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%Lx) (cache hit)\n",
                                _hFile, ulPos));
        return ulPos;
    }

    uliPos.QuadPart = ulPos;
    uliPos.LowPart = 
        SetFilePointer(_hFile, uliPos.LowPart, &uliPos.HighPart, FILE_BEGIN);

    if (uliPos.LowPart == MAX_ULONG && GetLastError() != NO_ERROR)
        return MAX_ULONGLONG;  // 0xFFFFFFFFFFFFFFFF

    SetCachedFilePointer(uliPos.QuadPart);

    filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%Lx)\n", _hFile, ulPos));
    olLowLog(("STGIO - Seek : %8x at %Lx\n", _hFile, ulPos));

    return uliPos.QuadPart;
}

ULONGLONG CFileStream::GetFilePointer()
{
    LARGE_INTEGER ulPos = {0,0};

    ulPos.LowPart = SetFilePointer(_hFile, 0, &ulPos.HighPart, FILE_CURRENT);
    filestDebug((DEB_SEEK, "File=%2x GetFilePointer() => 0x%Lx\n",
                            _hFile, ulPos));
    return ulPos.QuadPart;
}
#else
DWORD CFileStream::SeekTo(ULONG Low)
{
    DWORD dwPos;

    if(FilePointerEqual(Low))
    {
        filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%06x) (cache hit)\n",
                                _hFile, Low));
        return Low;
    }

    if(0xFFFFFFFF == (dwPos = SetFilePointer(_hFile, Low, NULL, FILE_BEGIN)))
        return dwPos;

    SetCachedFilePointer(dwPos);

    filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%06x)\n", _hFile, Low));
    olLowLog(("STGIO - Seek : %8x at %8x\n", _hFile, Low));

    return dwPos;
}

DWORD CFileStream::GetFilePointer()
{
    DWORD dwPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);
    filestDebug((DEB_SEEK, "File=%2x GetFilePointer() => 0x%06x\n",
                            _hFile, dwPos));
    return dwPos;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CFileStream::LockRegion, public
//
//  Synopsis:   Gets a lock on a portion of the LStream
//
//  Arguments:  [ulStartOffset] - Lock start
//              [cbLockLength] - Length
//              [dwLockType] - Exclusive/Read only
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::LockRegion(ULARGE_INTEGER ulStartOffset,
                                     ULARGE_INTEGER cbLockLength,
                                     DWORD dwLockType)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::LockRegion("
                 "%x:%x, %x:%x, %x)\n", ULIGetHigh(ulStartOffset),
                 ULIGetLow(ulStartOffset), ULIGetHigh(cbLockLength),
                 ULIGetLow(cbLockLength), dwLockType));
    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    filestDebug((DEB_LOCK, "File=%2x LockRegion   %1x:%x bytes @ %1x:%x\n",
                        ULIGetLow(cbLockLength), ULIGetHigh(cbLockLength),
                        ULIGetLow(ulStartOffset), ULIGetHigh(ulStartOffset)));

    boolChk(LockFile(_hFile, ULIGetLow(ulStartOffset),
                     ULIGetHigh(ulStartOffset), ULIGetLow(cbLockLength),
                     ULIGetHigh(cbLockLength)));

    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::LockRegion\n"));
EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::UnlockRegion, public
//
//  Synopsis:   Releases an existing lock
//
//  Arguments:  [ulStartOffset] - Lock start
//              [cbLockLength] - Length
//              [dwLockType] - Lock type
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//  Notes:      Must match an existing lock exactly
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::UnlockRegion(ULARGE_INTEGER ulStartOffset,
                                       ULARGE_INTEGER cbLockLength,
                                       DWORD dwLockType)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::UnlockRegion("
                 "%x:%x, %x:%x, %x)\n", ULIGetHigh(ulStartOffset),
                 ULIGetLow(ulStartOffset), ULIGetHigh(cbLockLength),
                 ULIGetLow(cbLockLength), dwLockType));

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    filestDebug((DEB_LOCK, "File=%2x UnlockRegion %1x:%x bytes @ %1x:%x\n",
                            ULIGetLow(cbLockLength), ULIGetHigh(cbLockLength),
                            ULIGetLow(ulStartOffset), ULIGetHigh(ulStartOffset)));

    boolChk(UnlockFile(_hFile, ULIGetLow(ulStartOffset),
                       ULIGetHigh(ulStartOffset),
                       ULIGetLow(cbLockLength),
                       ULIGetHigh(cbLockLength)));

    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::UnlockRegion\n"));
EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Function:   FileTimeToTimeT, private
//
//  Synopsis:   Converts a FILETIME to a TIME_T
//
//  Arguments:  [pft] - FILETIME
//
//  Returns:    TIME_T
//
//  History:    12-May-92       DrewB   Created
//
//+--------------------------------------------------------------

#ifdef NOFILETIME
TIME_T FileTimeToTimeT(LPFILETIME pft)
{
    WORD dt, tm;
    struct tm tmFile;

    fsVerify(FileTimeToDosDateTime(pft, &dt, &tm));
    tmFile.tm_sec = (tm&31)*2;
    tmFile.tm_min = (tm>>5)&63;
    tmFile.tm_hour = (tm>>11)&31;
    tmFile.tm_mday = dt&31;
    tmFile.tm_mon = ((dt>>5)&15)-1;
    tmFile.tm_year = (dt>>9)+80;
    return (TIME_T)mktime(&tmFile);
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CFileStream::Stat, public
//
//  Synopsis:   Fills in a stat buffer for this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    25-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CFileStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::Stat(%p)\n", pstatstg));

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    fsChk(GetSize(&pstatstg->cbSize));
#ifdef NOFILETIME
    FILETIME ftCreation, ftAccess, ftWrite;
    boolChk(GetFileTime(_hFile, &ftCreation, &ftAccess, &ftWrite));
    if (ftCreation.dwLowDateTime == 0 && ftCreation.dwHighDateTime == 0)
        ftCreation = ftWrite;
    if (ftAccess.dwLowDateTime == 0 && ftAccess.dwHighDateTime == 0)
        ftAccess = ftWrite;
    pstatstg->ctime = FileTimeToTimeT(&ftCreation);
    pstatstg->atime = FileTimeToTimeT(&ftAccess);
    pstatstg->mtime = FileTimeToTimeT(&ftWrite);
#else
    boolChk(GetFileTime(_hFile, &pstatstg->ctime, &pstatstg->atime,
                        &pstatstg->mtime));
#endif
    fsHVerSucc(GetLocksSupported(&pstatstg->grfLocksSupported));
    pstatstg->type = STGTY_LOCKBYTES;
    pstatstg->grfMode = DFlagsToMode(_pgfst->GetDFlags());
    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        fsChk(GetName(&pstatstg->pwcsName));
    }
    sc = S_OK;
    CheckSeekPointer();

    filestDebug((DEB_ITRACE, "Out CFileStream::Stat\n"));
    return NOERROR;

EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SwitchToFile, public
//
//  Synopsis:   Changes the file this filestream uses
//
//  Arguments:  [ptcsFile] - File name
//              [ulCommitSize] -- Size needed to do overwrite commit
//              [cbBuffer] - Buffer size
//              [pvBuffer] - Buffer for file copying
//
//  Returns:    Appropriate status code
//
//  History:    08-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::SwitchToFile(OLECHAR const *ptcsFile,
#ifdef LARGE_DOCFILE
                                       ULONGLONG ulCommitSize,
#else
                                       ULONG ulCommitSize,
#endif
                                       ULONG cbBuffer,
                                       void *pvBuffer)
{
    SCODE sc;
    DWORD cbRead, cbWritten = 0;
    FILEH hOldFile;
    WCHAR awcOldName[_MAX_PATH+1];
    WCHAR wcsFile[_MAX_PATH+1];
    DWORD dwOldStartFlags;
    ULARGE_INTEGER ulPos;
    ULONG cbBufferSave = 0;

#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::SwitchToFile:%p(%s, %x, %p)\n",
                 this, ptcsFile, cbBuffer, pvBuffer));

    // Check for marshals
    //      This must be the only instance of this "context".  Other
    //      seperate opens are possible though.
    //
    if (_pgfst->CountContexts() != 1)
        fsErr(EH_Err, STG_E_EXTANTMARSHALLINGS);

    CheckSeekPointer();

    //
    //  We are about to switch physical files for this CFileStream.  So
    // turn off the mapping so we can switch to the new file.
    //
    fsChk(TurnOffMapping(TRUE));

    // Seek to beginning
    negChk(SeekTo(0));

    // Preserve old file information
    StringCbCopyW (awcOldName, sizeof(awcOldName), _pgfst->GetName());
    hOldFile = _hFile;
    dwOldStartFlags = _pgfst->GetStartFlags();

    // Set file information to prepare for new Init
    _pgfst->SetName(NULL);
    _pgfst->SetMappingName(NULL);
    _pgfst->SetMappedFileSize(0);
    _pgfst->SetMappedCommitSize(0);
    _pgfst->ResetMapState(~0UL);     // Clear All State Flags.
    _hFile = INVALID_FH;
    _pgfst->SetStartFlags((dwOldStartFlags & ~(RSF_CREATEFLAGS |
                                               RSF_CONVERT |
                                               RSF_DELETEONRELEASE |
                                               RSF_OPEN)) |
                                               RSF_CREATE);

    // Release reserved file handle so it can be consumed
    if (_hReserved != INVALID_FH)
    {
        fsVerify(CloseHandle(_hReserved));
        _hReserved = INVALID_FH;
    }

    if (FAILED(StringCbCopy(wcsFile, sizeof(wcsFile), ptcsFile)))
            fsErr(EH_ReplaceOld, STG_E_INVALIDPOINTER);

    // Attempt to create new file
    fsChkTo(EH_ReplaceOld, InitFile(wcsFile));

    ULARGE_INTEGER ulNewSize;
    ulNewSize.QuadPart = ulCommitSize;

    // SetSize to minimum commit size
    fsHChkTo(EH_NewFile, SetSize(ulNewSize));

    // SetSize changes the file pointer, so move it back to the beginning
    negChkTo(EH_NewFile, SeekTo(0));

    // Copy file contents
    ulPos.QuadPart = 0;
    for (;;)
    {
        BOOL fRangeLocks = IsInRangeLocks (ulPos.QuadPart, cbBuffer);
        if (fRangeLocks)
        {
            ULONG ulRangeLocksBegin = OLOCKREGIONEND_SECTORALIGNED;
            // The end of the range locks is within this cbBuffer block
            // For unbuffered I/O, make sure we skip a whole sector
            cbBufferSave = cbBuffer;
            ulRangeLocksBegin -= (_pgfst->GetDFlags() & DF_LARGE) ? 4096 : 512;
            cbBuffer = ulRangeLocksBegin - ulPos.LowPart;
        }

        if (cbBuffer > 0)
        {
            boolChkTo(EH_NewFile,
                  ReadFile(hOldFile, pvBuffer, (UINT)cbBuffer, &cbRead, NULL));
            if (cbRead == 0)
                break;      // EOF

            fsChkTo(EH_NewFile, WriteAt(ulPos, pvBuffer, cbRead, &cbWritten));
            if (cbWritten != cbRead)
                fsErr(EH_NewFile, STG_E_WRITEFAULT);
        }

        if (fRangeLocks)
        {
            cbBuffer = cbBufferSave;
            cbWritten = cbBuffer;
        }
        ulPos.QuadPart += cbWritten;
        if (fRangeLocks)
        {
            // If we've skipped the range locks, move past them
            if (SetFilePointer(hOldFile, ulPos.LowPart, (LONG*)&ulPos.HighPart,
                 FILE_BEGIN) == MAX_ULONG)
                fsChkTo(EH_NewFile, STG_SCODE(GetLastError()));
        }
    }

    fsVerify(CloseHandle(hOldFile));
    if (dwOldStartFlags & RSF_DELETEONRELEASE)
    {
        // This is allowed to fail if somebody else has
        // the file open
        DeleteTheFile(awcOldName);
    }


    filestDebug((DEB_ITRACE, "Out CFileStream::SwitchToFile\n"));
    SetCachedFilePointer(GetFilePointer());
    return S_OK;

EH_NewFile:
    TurnOffMapping(FALSE);
    fsVerify(CloseHandle(_hFile));
    fsVerify(DeleteTheFile(_pgfst->GetName()));
EH_ReplaceOld:
    _hFile = hOldFile;
    if (_pgfst != NULL)
    {
        _pgfst->SetName(awcOldName);
        _pgfst->SetStartFlags(dwOldStartFlags);
    }

EH_Err:
    SetCachedFilePointer(GetFilePointer());
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::Delete, public
//
//  Synopsis:   Closes and deletes the file, errors ignored
//
//  Returns:    Appropriate status code
//
//  History:    09-Feb-93       DrewB   Created
//
//----------------------------------------------------------------------------

void CFileStream::Delete(void)
{
    filestDebug((DEB_ITRACE, "In  CFileStream::Delete:%p()\n", this));

    TurnOffAllMappings();

    if (_hFile != INVALID_FH)
        CloseHandle(_hFile);
    _hFile = INVALID_FH;

    if (_hReserved != INVALID_FH)
        CloseHandle(_hReserved);
    _hReserved = INVALID_FH;

    DeleteTheFile(_pgfst->GetName());

    filestDebug((DEB_ITRACE, "Out CFileStream::Delete\n"));
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::DeleteTheFile, public
//
//  Synopsis:	Delete the file (using WideWrap DeleteFile), but don't
//              if we don't think the system as already done so.
//
//  History:	21-Jan-97	BChapman	Created
//
//---------------------------------------------------------------

BOOL CFileStream::DeleteTheFile(const WCHAR *pwcName)
{
#ifndef MAC
    //
    // If the file is a "TEMPFILE" then it is DELETE_ON_CLOSE
    // and the system already deleted it.
    //
    if(RSF_TEMPFILE & GetStartFlags())
        return TRUE;
#endif
    return DeleteFile(_pgfst->GetName());
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::ReserveHandle, public
//
//  Synopsis:   Reserves a backup file handle for handle-required operations
//
//  Returns:    Appropriate status code
//
//  History:    01-Jul-93       DrewB   Created
//
//  Notes:      May be called with a handle already reserved
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::ReserveHandle(void)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::ReserveHandle:%p()\n", this));
    if (_hReserved == INVALID_FH &&
        !DuplicateHandle(GetCurrentProcess(), _hFile, GetCurrentProcess(),
                         &_hReserved, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        sc = LAST_STG_SCODE;
    }
    else
    {
        filestDebug((DEB_INFO, "CFileStream reserved %p "
                    "handle %p thread %lX\n",
                    this, _hReserved, GetCurrentThreadId()));
        sc = S_OK;
        _grfLocal |= LFF_RESERVE_HANDLE;
    }
    filestDebug((DEB_ITRACE, "Out CFileStream::ReserveHandle => %lX\n", sc));
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::GetSize, public
//
//  Synopsis:   Return the size of the stream
//
//  Returns:    Appropriate status code
//
//  History:    12-Jul-93   AlexT   Created
//
//  Notes:      This is a separate method from Stat as an optimization
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::GetSize(ULARGE_INTEGER *puliSize)
{
    SCODE sc = S_OK;
    CheckSeekPointer();

    if(IsFileMapped())
    {
        puliSize->LowPart = _pgfst->GetMappedFileSize();
        puliSize->HighPart = 0;
    }
    else
#ifdef LARGE_DOCFILE
    {
        puliSize->LowPart = GetFileSize(_hFile, &puliSize->HighPart);
        if (puliSize->LowPart == MAX_ULONG && NO_ERROR != GetLastError())
            fsErr(EH_Err, LAST_STG_SCODE)
    }
#else
        negChk(puliSize->LowPart = GetFileSize(_hFile, &puliSize->HighPart));
#endif

EH_Err:
    CheckSeekPointer();
    return(ResultFromScode(sc));
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SetTime, public
//
//  Synopsis:   Set the times on the ILockbytes
//
//  Arguments:  [tt] -- Which time to set
//              [nt] -- New time stamp
//
//  Returns:    Appropriate status code
//
//  History:    24-Mar-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CFileStream::SetTime(WHICHTIME tt,
                           TIME_T nt)
{
    filestDebug((DEB_ITRACE, "In CFileStream::SetTime()\n"));

    SCODE sc = S_OK;

    FILETIME *pctime = NULL, *patime = NULL, *pmtime = NULL;
    CheckSeekPointer();

    if (tt == WT_CREATION)
    {
        pctime = &nt;
    }
    else if (tt == WT_MODIFICATION)
    {
        pmtime = &nt;
    }
    else
    {
        patime = &nt;
    }

    boolChk(SetFileTime(_hFile,
                        pctime,
                        patime,
                        pmtime));

EH_Err:
    filestDebug((DEB_ITRACE, "Out CFileStream::SetTime() => %lx\n", sc));
    CheckSeekPointer();
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SetAllTimes, public
//
//  Synopsis:   Set the times on the ILockbytes
//
//  Arguments:  [atm] Access time
//              [mtm] Modification time
//              [ctm] Creation time
//
//  Returns:    Appropriate status code
//
//  History:    24-Nov-95       SusiA   Created
//
//----------------------------------------------------------------------------

SCODE CFileStream::SetAllTimes( TIME_T atm,
                                TIME_T mtm,
                                TIME_T ctm)
{
    filestDebug((DEB_ITRACE, "In CFileStream::SetAllTimes()\n"));

    SCODE sc = S_OK;

    CheckSeekPointer();

    boolChk(SetFileTime(_hFile, &ctm, &atm,  &mtm));

EH_Err:
    filestDebug((DEB_ITRACE, "Out CFileStream::SetAllTimes() => %lx\n", sc));
    CheckSeekPointer();
    return sc;
}


#ifdef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::FillAppend, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::FillAppend(void const *pv,
                                     ULONG cb,
                                     ULONG *pcbWritten)
{
    SCODE sc;
    SAFE_SEM;
    HANDLE hEvent;

    filestDebug((DEB_ITRACE, "In  CFileStream::FillAppend:%p()\n", this));
    fsChk(TakeSafeSem());
    if (_pgfst->GetTerminationStatus() != UNTERMINATED)
    {
        sc = STG_E_TERMINATED;
    }
    else
    {
        ULONG cbWritten;
#ifdef LARGE_DOCFILE
        ULARGE_INTEGER ulHighWater;
        ulHighWater.QuadPart = _pgfst->GetHighWaterMark();
#else
        ULONG ulHighWater = _pgfst->GetHighWaterMark();
#endif

        sc = CFileStream::WriteAtWorker(ulHighWater, pv, cb, &cbWritten);
#ifdef LARGE_DOCFILE
        _pgfst->SetHighWaterMark(ulHighWater.QuadPart + cbWritten);
#else
        _pgfst->SetHighWaterMark(ulHighWater + cbWritten);
#endif
        if (pcbWritten != NULL)
        {
            *pcbWritten = cbWritten;
        }

        hEvent = _ppc->GetNotificationEvent();
        if (!PulseEvent(hEvent))
        {
            sc = Win32ErrorToScode(GetLastError());
        }
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::FillAppend\n"));
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::FillAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::FillAt(ULARGE_INTEGER ulOffset,
                                 void const *pv,
                                 ULONG cb,
                                 ULONG *pcbWritten)
{
    filestDebug((DEB_ITRACE, "In  CFileStream::FillAt:%p()\n", this));
    filestDebug((DEB_ITRACE, "Out CFileStream::FillAt\n"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::SetFillSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::SetFillSize(ULARGE_INTEGER ulSize)
{
    SCODE sc;
    SAFE_SEM;

    filestDebug((DEB_ITRACE,
                 "In  CFileStream::SetFillSize:%p()\n", this));

    fsChk(TakeSafeSem());
    if (_pgfst->GetTerminationStatus() == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
#ifndef LARGE_DOCFILE
        ULONG uLow = ULIGetLow(ulSize);
        LONG lHigh = ULIGetHigh(ulSize);
        fsAssert(lHigh == 0 &&
                 aMsg("High dword other than zero passed to filestream."));
#endif

#ifdef LARGE_DOCFILE
        sc = SetSizeWorker(ulSize.QuadPart);
#else
        sc = SetSizeWorker(uLow);
#endif
    }
    filestDebug((DEB_ITRACE, "Out CFileStream::SetFillSize\n"));
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::Terminate, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::Terminate(BOOL bCanceled)
{
    SCODE sc;
    SAFE_SEM;
    HANDLE hEvent;

    filestDebug((DEB_ITRACE, "In  CFileStream::Terminate:%p()\n", this));

    fsChk(TakeSafeSem());
    _pgfst->SetTerminationStatus((bCanceled) ?
                                 TERMINATED_ABNORMAL :
                                 TERMINATED_NORMAL);

    hEvent = _ppc->GetNotificationEvent();

    if ((hEvent != INVALID_HANDLE_VALUE) && (!SetEvent(hEvent)))
    {
        return Win32ErrorToScode(GetLastError());
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::Terminate\n"));
EH_Err:
    return sc;
}

void CFileStream::StartAsyncMode(void)
{
    //Note:  No semaphore here - this must be called before the ILockBytes
    //  is returned to an app.
    _pgfst->SetTerminationStatus(UNTERMINATED);
}

STDMETHODIMP CFileStream::GetFailureInfo(ULONG *pulWaterMark,
                                         ULONG *pulFailurePoint)
{
    //We don't take a sema